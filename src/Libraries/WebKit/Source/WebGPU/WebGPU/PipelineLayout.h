/*
 *
 * Copyright (c) NeXTHub Corporation. All Rights Reserved. 
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Author: Tunjay Akbarli
 * Date: Saturday, June 1, 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201, 
 * Middletown, DE 19709, New Castle County, USA.
 *
 */
#pragma once

#import <wtf/FastMalloc.h>
#import <wtf/HashMap.h>
#import <wtf/HashTraits.h>
#import <wtf/Ref.h>
#import <wtf/RefCountedAndCanMakeWeakPtr.h>
#import <wtf/TZoneMalloc.h>
#import <wtf/Vector.h>
#import <wtf/WeakPtr.h>

struct WGPUPipelineLayoutImpl {
};

namespace WebGPU {

class BindGroup;
class BindGroupLayout;
class Device;

// https://gpuweb.github.io/gpuweb/#gpupipelinelayout
class PipelineLayout : public RefCountedAndCanMakeWeakPtr<PipelineLayout>, public WGPUPipelineLayoutImpl {
    WTF_MAKE_TZONE_ALLOCATED(PipelineLayout);
public:
    static Ref<PipelineLayout> create(std::optional<Vector<Ref<BindGroupLayout>>>&& bindGroupLayouts, bool isAutogenerated, Device& device)
    {
        return adoptRef(*new PipelineLayout(WTFMove(bindGroupLayouts), isAutogenerated, device));
    }
    static Ref<PipelineLayout> createInvalid(Device& device)
    {
        return adoptRef(*new PipelineLayout(device));
    }

    ~PipelineLayout();

    void setLabel(String&&);

    bool isValid() const { return m_isValid; }

    bool operator==(const PipelineLayout&) const;

    bool isAutoLayout() const;
    size_t numberOfBindGroupLayouts() const { return m_bindGroupLayouts ? m_bindGroupLayouts->size() : 0; }
    BindGroupLayout& bindGroupLayout(size_t) const;
    BindGroupLayout* optionalBindGroupLayout(size_t) const;

    Device& device() const { return m_device; }
    void makeInvalid();
    size_t sizeOfVertexDynamicOffsets() const;
    size_t sizeOfFragmentDynamicOffsets() const;
    size_t sizeOfComputeDynamicOffsets() const;

    size_t vertexOffsetForBindGroup(uint32_t) const;
    size_t fragmentOffsetForBindGroup(uint32_t) const;
    size_t computeOffsetForBindGroup(uint32_t) const;

    const Vector<uint32_t>* vertexOffsets(uint32_t, const Vector<uint32_t>&);
    const Vector<uint32_t>* fragmentOffsets(uint32_t, const Vector<uint32_t>&);
    const Vector<uint32_t>* computeOffsets(uint32_t, const Vector<uint32_t>&);
    using BindGroupHashMap = HashMap<uint32_t, RefPtr<const BindGroup>, DefaultHash<uint32_t>, WTF::UnsignedWithZeroKeyHashTraits<uint32_t>>;
    NSString* errorValidatingBindGroupCompatibility(const BindGroupHashMap&) const;
private:
    PipelineLayout(std::optional<Vector<Ref<BindGroupLayout>>>&&, bool, Device&);
    PipelineLayout(Device&);

    std::optional<Vector<Ref<BindGroupLayout>>> m_bindGroupLayouts;
    using DynamicOffsetMap = HashMap<uint32_t, uint32_t, DefaultHash<uint32_t>, WTF::UnsignedWithZeroKeyHashTraits<uint32_t>>;
    DynamicOffsetMap m_vertexDynamicOffsets;
    DynamicOffsetMap m_fragmentDynamicOffsets;
    DynamicOffsetMap m_computeDynamicOffsets;

    using DynamicOffsetBufferMap = HashMap<uint32_t, Vector<uint32_t>, DefaultHash<uint32_t>, WTF::UnsignedWithZeroKeyHashTraits<uint32_t>>;
    mutable DynamicOffsetBufferMap m_vertexOffsets;
    mutable DynamicOffsetBufferMap m_fragmentOffsets;
    mutable DynamicOffsetBufferMap m_computeOffsets;
    const Vector<uint32_t>* offsetVectorForBindGroup(uint32_t bindGroupIndex, DynamicOffsetBufferMap& stageOffsets, const Vector<uint32_t>& dynamicOffsets, WGPUShaderStage);


    const Ref<Device> m_device;
    bool m_isValid { true };
    const bool m_isAutogenerated { false };
};

} // namespace WebGPU
