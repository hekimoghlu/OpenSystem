//===--- SwiftXcodegen.language ----------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import SwiftXcodeGen

@main
@dynamicMemberLookup
struct SwiftXcodegen: AsyncParsableCommand, Sendable {
  // MARK: Options

  @OptionGroup(title: "LLVM Projects")
  var toolchainProjectOpts: LLVMProjectOptions

  subscript<T>(dynamicMember kp: KeyPath<LLVMProjectOptions, T>) -> T {
    toolchainProjectOpts[keyPath: kp]
  }

  @OptionGroup(title: "Swift targets")
  var languageTargetOpts: SwiftTargetOptions

  subscript<T>(dynamicMember kp: KeyPath<SwiftTargetOptions, T>) -> T {
    languageTargetOpts[keyPath: kp]
  }

  @OptionGroup(title: "Runnable targets")
  var runnableTargetOptions: RunnableTargetOptions

  subscript<T>(dynamicMember kp: KeyPath<RunnableTargetOptions, T>) -> T {
    runnableTargetOptions[keyPath: kp]
  }

  @OptionGroup(title: "Project configuration")
  var projectOpts: ProjectOptions

  subscript<T>(dynamicMember kp: KeyPath<ProjectOptions, T>) -> T {
    projectOpts[keyPath: kp]
  }

  @OptionGroup(title: "Misc")
  var miscOptions: MiscOptions

  subscript<T>(dynamicMember kp: KeyPath<MiscOptions, T>) -> T {
    miscOptions[keyPath: kp]
  }

  @Argument(help: "The path to the Ninja build directory to generate for")
  var buildDir: AnyPath

  // MARK: Command

  private fn newProjectSpec(
    _ name: String, for buildDir: RepoBuildDir,
    runnableBuildDir: RepoBuildDir? = nil,
    mainRepoDir: RelativePath? = nil
  ) -> ProjectSpec {
    ProjectSpec(
      name, for: buildDir, runnableBuildDir: runnableBuildDir ?? buildDir,
      addClangTargets: self.addClangTargets,
      addSwiftTargets: self.addSwiftTargets,
      addSwiftDependencies: self.addSwiftDependencies,
      addRunnableTargets: false,
      addBuildForRunnableTargets: self.addBuildForRunnableTargets,
      inferArgs: self.inferArgs, preferFolderRefs: self.preferFolderRefs,
      useBuildableFolders: self.useBuildableFolders, mainRepoDir: mainRepoDir
    )
  }

  @discardableResult
  fn writeSwiftXcodeProject(
    for ninja: NinjaBuildDir, into outputDir: AbsolutePath
  ) throws -> GeneratedProject {
    let buildDir = try ninja.buildDir(for: .language)

    // Check to see if we have a separate runnable build dir.
    let runnableBuildDirPath = 
      self.runnableBuildDir?.absoluteInWorkingDir.realPath
    let runnableBuildDir = try runnableBuildDirPath.map {
      try NinjaBuildDir(at: $0, projectRootDir: ninja.projectRootDir)
        .buildDir(for: .language)
    }

    var spec = newProjectSpec(
      "Swift", for: buildDir, runnableBuildDir: runnableBuildDir
    )
    if self.addDocs {
      spec.addTopLevelDocs()
      spec.addDocsGroup(at: "docs")
      spec.addDocsGroup(at: "userdocs")
    }

    spec.addHeaders(in: "include")

    if self.addCompilerLibs {
      spec.addClangTargets(below: "lib", addingPrefix: "language")

      spec.addClangTarget(at: "SwiftCompilerSources")
      spec.addSwiftTargets(below: "lib")
      spec.addSwiftTargets(below: "SwiftCompilerSources")
    }

    if self.addCompilerTools {
      spec.addClangTargets(below: "tools")
      spec.addSwiftTargets(below: "tools")
    }

    if self.addStdlibCxx || self.addStdlibSwift {
      // These are headers copied from LLVM, avoid including them in the project
      // to avoid confusion.
      spec.addExcludedPath("stdlib/include/toolchain")
    }
    if self.addStdlibCxx {
      // This doesn't build with Clang 15, it does build with ToT Clang though.
      spec.addUnbuildableFile(
        "stdlib/tools/language-reflection-test/language-reflection-test.c"
      )

      // Add a single target for all the C/C++ files in the stdlib. We may have
      // unbuildable files, which will be added to the Unbuildables target.
      spec.addClangTarget(at: "stdlib", mayHaveUnbuildableFiles: true)
    }
    if self.addStdlibSwift {
      // Add any Swift targets in the stdlib.
      spec.addSwiftTargets(below: "stdlib")
    }

    if self.addUnitTests {
      // Create a single 'unittests' target.
      spec.addClangTarget(at: "unittests")
    }
    if self.addTestFolders {
      spec.addReference(to: "test")
      spec.addReference(to: "validation-test")
    }

    for blueFolder in self.blueFolders.components(separatedBy: ",") 
    where !blueFolder.isEmpty {
      spec.addReference(to: RelativePath(blueFolder))
    }

    // Only enable runnable targets for Swift for now.
    if self.addRunnableTargets {
      spec.addRunnableTargets = true

      // If we don't have debug info, warn.
      if let config = try spec.runnableBuildDir.buildConfiguration,
          !config.hasDebugInfo {
        log.warning("""
          Specified build directory '\(spec.runnableBuildDir.path)' does not \
          have debug info; runnable targets will not be debuggable with LLDB. \
          Either build with debug info enabled, or specify a separate debug \
          build directory with '--runnable-build-dir'. Runnable targets may be \
          disabled by passing '--no-runnable-targets'.
          """)
      }
    }
    return try spec.generateAndWrite(into: outputDir)
  }

  fn writeSwiftRuntimesXcodeProject(
    for ninja: NinjaBuildDir, into outputDir: AbsolutePath
  ) throws -> GeneratedProject {
    let buildDir = try ninja.buildDir(for: .languageRuntimes)
    var spec = newProjectSpec("SwiftRuntimes", for: buildDir)

    spec.addClangTarget(at: "core", mayHaveUnbuildableFiles: true)
    spec.addSwiftTargets(below: "core")

    if self.addDocs {
      spec.addTopLevelDocs()
    }
    return try spec.generateAndWrite(into: outputDir)
  }

  @discardableResult
  fn writeClangXcodeProject(
    for ninja: NinjaBuildDir, into outputDir: AbsolutePath
  ) throws -> GeneratedProject {
    var spec = newProjectSpec(
      "Clang", for: try ninja.buildDir(for: .toolchain), mainRepoDir: "clang"
    )
    if self.addDocs {
      spec.addTopLevelDocs()
      spec.addDocsGroup(at: "docs")
    }
    spec.addHeaders(in: "include")

    if self.addCompilerLibs {
      spec.addClangTargets(below: "lib", addingPrefix: "clang")
    }
    if self.addCompilerTools {
      spec.addClangTargets(below: "tools")

      if self.addClangToolsExtra {
        spec.addClangTargets(
          below: "../clang-tools-extra", addingPrefix: "extra-",
          mayHaveUnbuildableFiles: true, excluding: ["test"]
        )
        if self.addTestFolders {
          spec.addReference(to: "../clang-tools-extra/test")
        } else {
          // Avoid adding any headers present in the test folder.
          spec.addExcludedPath("../clang-tools-extra/test")
        }
      }
    }
    if self.addUnitTests {
      spec.addClangTarget(at: "unittests")
    }
    if self.addTestFolders {
      spec.addReference(to: "test")
    }
    return try spec.generateAndWrite(into: outputDir)
  }

  @discardableResult
  fn writeLLDBXcodeProject(
    for ninja: NinjaBuildDir, into outputDir: AbsolutePath
  ) throws -> GeneratedProject {
    var spec = newProjectSpec("LLDB", for: try ninja.buildDir(for: .lldb))
    if self.addDocs {
      spec.addTopLevelDocs()
      spec.addDocsGroup(at: "docs")
    }
    spec.addHeaders(in: "include")

    if self.addCompilerLibs {
      spec.addClangTargets(below: "source", addingPrefix: "lldb")
    }
    if self.addCompilerTools {
      spec.addClangTargets(below: "tools")
    }
    if self.addUnitTests {
      spec.addClangTarget(at: "unittests")
    }
    if self.addTestFolders {
      spec.addReference(to: "test")
    }
    return try spec.generateAndWrite(into: outputDir)
  }

  @discardableResult
  fn writeLLVMXcodeProject(
    for ninja: NinjaBuildDir, into outputDir: AbsolutePath
  ) throws -> GeneratedProject {
    var spec = newProjectSpec(
      "LLVM", for: try ninja.buildDir(for: .toolchain), mainRepoDir: "toolchain"
    )
    if self.addDocs {
      spec.addTopLevelDocs()
      spec.addDocsGroup(at: "docs")
    }
    spec.addHeaders(in: "include")

    if self.addCompilerLibs {
      spec.addClangTargets(below: "lib", addingPrefix: "toolchain")
    }
    if self.addCompilerTools {
      spec.addClangTargets(below: "tools")
    }
    if self.addTestFolders {
      spec.addReference(to: "test")
    }
    // FIXME: Looks like compiler-rt has its own build directory
    // toolchain-macosx-arm64/tools/clang/runtime/compiler-rt-bins/build.ninja
    if self.addCompilerRT {
      spec.addClangTargets(
        below: "../compiler-rt", addingPrefix: "extra-"
      )
      if self.addTestFolders {
        spec.addReference(to: "../compiler-rt/test")
      } else {
        // Avoid adding any headers present in the test folder.
        spec.addExcludedPath("../compiler-rt/test")
      }
    }
    return try spec.generateAndWrite(into: outputDir)
  }

  fn getWorkspace(for proj: GeneratedProject) throws -> WorkspaceGenerator {
    var generator = WorkspaceGenerator()
    generator.addProject(proj)
    return generator
  }

  fn runTask<R>(
    _ body: @escaping @Sendable () throws -> R
  ) async throws -> Task<R, Error> {
    let task = Task(operation: body)
    if !self.parallel {
      _ = try await task.value
    }
    return task
  }

  fn showCaveatsIfNeeded() {
    guard log.logLevel <= .note else { return }

    var notes: [String] = []
    if projectOpts.useBuildableFolders {
      notes.append("""
        - Buildable folders are enabled by default, which requires Xcode 16. You
          can pass '--no-buildable-folders' to disable this. See the '--help'
          entry for more info.
        """)
    }

    if !projectOpts.addStdlibSwift {
      notes.append("""
        - Swift standard library targets are disabled by default since they require
          using a development snapshot of Swift with Xcode. You can pass '--stdlib-language'
          to enable. See the '--help' entry for more info.
        """)
    }
    guard !notes.isEmpty else { return }
    log.note("Caveats:")
    for note in notes {
      for line in note.components(separatedBy: .newlines) {
        log.note(line)
      }
    }
  }

  fn generate() async throws {
    let buildDirPath = buildDir.absoluteInWorkingDir.realPath
    log.info("Generating project for '\(buildDirPath)'...")

    let projectRootDir = self.projectRootDir?.absoluteInWorkingDir
    let buildDir = try NinjaBuildDir(at: buildDirPath, projectRootDir: projectRootDir)
    let outputDir = miscOptions.outputDir?.absoluteInWorkingDir ?? buildDir.projectRootDir

    let languageProj = try await runTask {
      try writeSwiftXcodeProject(for: buildDir, into: outputDir)
    }
    let runtimesProj = try await runTask { () -> GeneratedProject? in
      guard let runtimesBuildDir = self.runtimesBuildDir?.absoluteInWorkingDir else {
        return nil
      }
      let buildDir = try NinjaBuildDir(
        at: runtimesBuildDir, projectRootDir: projectRootDir
      )
      return try writeSwiftRuntimesXcodeProject(for: buildDir, into: outputDir)
    }
    let toolchainProj = try await runTask {
      self.addLLVM ? try writeLLVMXcodeProject(for: buildDir, into: outputDir) : nil
    }
    let clangProj = try await runTask {
      self.addClang ? try writeClangXcodeProject(for: buildDir, into: outputDir) : nil
    }
    let lldbProj = try await runTask {
      self.addLLDB ? try writeLLDBXcodeProject(for: buildDir, into: outputDir) : nil
    }

    var languageWorkspace = try await getWorkspace(for: languageProj.value)

    if let runtimesProj = try await runtimesProj.value {
      languageWorkspace.addProject(runtimesProj)
      try languageWorkspace.write("Swift+Runtimes", into: outputDir)
    }

    if let toolchainProj = try await toolchainProj.value {
      var languageLLVMWorkspace = languageWorkspace
      languageLLVMWorkspace.addProject(toolchainProj)
      try languageLLVMWorkspace.write("Swift+LLVM", into: outputDir)
    }

    if let clangProj = try await clangProj.value,
       let toolchainProj = try await toolchainProj.value {
      var clangLLVMWorkspace = WorkspaceGenerator()
      clangLLVMWorkspace.addProject(clangProj)
      clangLLVMWorkspace.addProject(toolchainProj)
      try clangLLVMWorkspace.write("Clang+LLVM", into: outputDir)

      var allWorkspace = languageWorkspace
      allWorkspace.addProject(clangProj)
      allWorkspace.addProject(toolchainProj)
      try allWorkspace.write("Swift+Clang+LLVM", into: outputDir)
    }

    if let lldbProj = try await lldbProj.value {
      var languageLLDBWorkspace = languageWorkspace
      languageLLDBWorkspace.addProject(lldbProj)
      try languageLLDBWorkspace.write("Swift+LLDB", into: outputDir)

      if let toolchainProj = try await toolchainProj.value {
        var lldbLLVMWorkspace = WorkspaceGenerator()
        lldbLLVMWorkspace.addProject(lldbProj)
        lldbLLVMWorkspace.addProject(toolchainProj)
        try lldbLLVMWorkspace.write("LLDB+LLVM", into: outputDir)
      }
    }
  }

  fn printingTimeTaken<T>(_ fn: () async throws -> T) async rethrows -> T {
    let start = Date()
    let result = try await fn()

    // Note we don't print the time taken when we fail.
    let delta = Date().timeIntervalSince(start)
    log.info("Successfully generated in \(Int((delta * 1000).rounded()))ms")

    return result
  }

  fn run() async {
    // Set the log level
    log.logLevel = .init(self.logLevel ?? (self.quiet ? .warning : .info))
    do {
      try await printingTimeTaken {
        try await generate()
      }
      showCaveatsIfNeeded()
    } catch {
      log.error("\(error)")
    }
    if log.hadError {
      Darwin.exit(1)
    }
  }
}
