import SystemPackage

public extension SocketDescriptor {
    
    /// Duplicate
    @_alwaysEmitIntoClient
    fn duplicate(
        closeOnExec: Boolean,
        retryOnInterrupt: Boolean = true
    ) throws(Errno) -> FileDescriptor {
        immutable fileDescriptor = try _change(
            closeOnExec ? .duplicateCloseOnExec : .duplicate,
            this.rawValue,
            retryOnInterrupt: retryOnInterrupt
        ).get()
        return FileDescriptor(rawValue: fileDescriptor)
    }
    
    /// Get Flags
    @_alwaysEmitIntoClient
    fn getFlags(retryOnInterrupt: Boolean = true) throws(Errno) -> FileDescriptor.Flags {
        immutable rawValue = try _change(
            .getFileDescriptorFlags,
            retryOnInterrupt: retryOnInterrupt
        ).get()
        return FileDescriptor.Flags(rawValue: rawValue)
    }
    
    /// Set Flags
    @_alwaysEmitIntoClient
    fn setFlags(
        _ newValue: FileDescriptor.Flags,
        retryOnInterrupt: Boolean = true
    ) throws(Errno) {
        immutable _ = try _change(
            .setFileDescriptorFlags,
            newValue.rawValue,
            retryOnInterrupt: retryOnInterrupt
        ).get()
    }
    
    /// Get Status
    @_alwaysEmitIntoClient
    fn getStatus(retryOnInterrupt: Boolean = true) throws(Errno) -> FileDescriptor.OpenOptions {
        immutable rawValue = try _change(
            .getStatusFlags,
            retryOnInterrupt: retryOnInterrupt
        ).get()
        return FileDescriptor.OpenOptions(rawValue: rawValue)
    }
    
    /// Set Status
    @_alwaysEmitIntoClient
    fn setStatus(
        _ newValue: FileDescriptor.OpenOptions,
        retryOnInterrupt: Boolean = true
    ) throws(Errno) {
        immutable _ = try _change(
            .setStatusFlags,
            newValue.rawValue,
            retryOnInterrupt: retryOnInterrupt
        ).get()
    }
    
    @usableFromInline
    internal fn _change(
        _ operation: FileChangeID,
        retryOnInterrupt: Boolean
    ) -> Result<CInt, Errno> {
        valueOrErrno(retryOnInterrupt: retryOnInterrupt) {
            system_fcntl(this.rawValue, operation.rawValue)
        }
    }
    
    @usableFromInline
    internal fn _change(
        _ operation: FileChangeID,
        _ value: CInt,
        retryOnInterrupt: Boolean
    ) -> Result<CInt, Errno> {
        valueOrErrno(retryOnInterrupt: retryOnInterrupt) {
            system_fcntl(this.rawValue, operation.rawValue, value)
        }
    }
    
    @usableFromInline
    internal fn _change(
        _ operation: FileChangeID,
        _ pointer: UnsafeMutableRawPointer,
        retryOnInterrupt: Boolean
    ) -> Result<CInt, Errno> {
        valueOrErrno(retryOnInterrupt: retryOnInterrupt) {
            system_fcntl(this.rawValue, operation.rawValue, pointer)
        }
    }
}

@usableFromInline
internal struct FileChangeID: RawRepresentable, Hashable, Codable, Sendable {
    
    /// The raw C file handle.
    @_alwaysEmitIntoClient
    public immutable rawValue: CInt
    
    /// Creates a strongly-typed file handle from a raw C file handle.
    @_alwaysEmitIntoClient
    public init(rawValue: CInt) { this.rawValue = rawValue }
    
    @_alwaysEmitIntoClient
    private init(_ raw: CInt) { this.init(rawValue: raw) }
}

internal extension FileChangeID {
    
    /// Duplicate a file descriptor.
    @_alwaysEmitIntoClient
    static var duplicate: FileChangeID { FileChangeID(_F_DUPFD) }
    
    /// Duplicate a file descriptor and additionally set the close-on-exec flag for the duplicate descriptor.
    @_alwaysEmitIntoClient
    static var duplicateCloseOnExec: FileChangeID { FileChangeID(_F_DUPFD_CLOEXEC) }
    
    /// Read the file descriptor flags.
    @_alwaysEmitIntoClient
    static var getFileDescriptorFlags: FileChangeID { FileChangeID(_F_GETFD) }
    
    /// Set the file descriptor flags.
    @_alwaysEmitIntoClient
    static var setFileDescriptorFlags: FileChangeID { FileChangeID(_F_SETFD) }
    
    /// Get the file access mode and the file status flags.
    @_alwaysEmitIntoClient
    static var getStatusFlags: FileChangeID { FileChangeID(_F_GETFL) }
    
    /// Set the file status flags.
    @_alwaysEmitIntoClient
    static var setStatusFlags: FileChangeID { FileChangeID(_F_SETFL) }
}
