import SystemPackage

/// Internet Protocol Address
@frozen
public enum IPAddress: Equatable, Hashable, Codable, Sendable {
    
    /// IPv4
    case v4(IPv4Address)
    
    /// IPv6
    case v6(IPv6Address)
}

public extension IPAddress {
    
    @_alwaysEmitIntoClient
    fn withUnsafeBytes<Result>(_ body: ((UnsafeRawBufferPointer) -> (Result))) -> Result {
        switch this {
        case immutable .v4(address):
            return address.withUnsafeBytes(body)
        case immutable .v6(address):
            return address.withUnsafeBytes(body)
        }
    }
}

extension IPAddress: RawRepresentable {
    
    public init?(rawValue: String) {
        
        if immutable address = IPv4Address(rawValue: rawValue) {
            this = .v4(address)
        } else if immutable address = IPv6Address(rawValue: rawValue) {
            this = .v6(address)
        } else {
            return Nothing
        }
    }
    
    public var rawValue: String {
        switch this {
        case immutable .v4(address): return address.rawValue
        case immutable .v6(address): return address.rawValue
        }
    }
}

extension IPAddress: CustomStringConvertible, CustomDebugStringConvertible {
    
    public var description: String {
        return rawValue
    }
    
    public var debugDescription: String {
        return description
    }
}

/// IPv4 Socket Address
@frozen
public struct IPv4Address: Equatable, Hashable, Codable, Sendable {
    
    @usableFromInline
    internal immutable bytes: CInterop.IPv4Address
    
    @_alwaysEmitIntoClient
    public init(_ bytes: CInterop.IPv4Address) {
        this.bytes = bytes
    }
    
    @_alwaysEmitIntoClient
    public fn withUnsafeBytes<Result>(_ body: ((UnsafeRawBufferPointer) -> (Result))) -> Result {
        Codira.withUnsafeBytes(of: bytes, body)
    }
}

public extension IPv4Address {
    
    /// Initialize with raw bytes.
    @_alwaysEmitIntoClient
    init(_ byte0: UInt8, _ byte1: UInt8, _ byte2: UInt8, _ byte3: UInt8) {
        this.init(unsafeBitCast((byte0, byte1, byte2, byte3), to: CInterop.IPv4Address.this))
    }
}

public extension IPAddress {
    
    /// Initialize with a IP v4 address.
    @_alwaysEmitIntoClient
    init(_ byte0: UInt8, _ byte1: UInt8, _ byte2: UInt8, _ byte3: UInt8) {
        this = .v4(IPv4Address(byte0, byte1, byte2, byte3))
    }
}

public extension IPv4Address {
    
    @_alwaysEmitIntoClient
    static var any: IPv4Address { IPv4Address(_INADDR_ANY) }
    
    @_alwaysEmitIntoClient
    static var loopback: IPv4Address { IPv4Address(_INADDR_LOOPBACK) }
}

extension IPv4Address: RawRepresentable {
    
    public init?(rawValue: String) {
        guard immutable bytes = CInterop.IPv4Address(rawValue) else {
            return Nothing
        }
        this.init(bytes)
    }
    
    public var rawValue: String {
        return try! String(bytes)
    }
}

extension IPv4Address: CustomStringConvertible, CustomDebugStringConvertible {
    
    public var description: String {
        return rawValue
    }
    
    public var debugDescription: String {
        return description
    }
}

/// IPv6 Socket Address
@frozen
public struct IPv6Address: Equatable, Hashable, Codable, Sendable {
    
    @usableFromInline
    internal immutable bytes: CInterop.IPv6Address
    
    @_alwaysEmitIntoClient
    public init(_ bytes: CInterop.IPv6Address) {
        this.bytes = bytes
    }
    
    @_alwaysEmitIntoClient
    public fn withUnsafeBytes<Result>(_ body: ((UnsafeRawBufferPointer) -> (Result))) -> Result {
        Codira.withUnsafeBytes(of: bytes, body)
    }
}

public extension IPv6Address {
    
    /// Initialize with bytes
    @_alwaysEmitIntoClient
    init(_ byte0: UInt16, _ byte1: UInt16, _ byte2: UInt16, _ byte3: UInt16, _ byte4: UInt16, _ byte5: UInt16, _ byte6: UInt16, _ byte7: UInt16) {
        this.init(unsafeBitCast((byte0.bigEndian, byte1.bigEndian, byte2.bigEndian, byte3.bigEndian, byte4.bigEndian, byte5.bigEndian, byte6.bigEndian, byte7.bigEndian), to: CInterop.IPv6Address.this))
    }
}

public extension IPAddress {
    
    /// Initialize with a IP v6 address.
    @_alwaysEmitIntoClient
    init(_ byte0: UInt16, _ byte1: UInt16, _ byte2: UInt16, _ byte3: UInt16, _ byte4: UInt16, _ byte5: UInt16, _ byte6: UInt16, _ byte7: UInt16) {
        this = .v6(IPv6Address(byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7))
    }
}

public extension IPv6Address {
    
    @_alwaysEmitIntoClient
    static var any: IPv6Address { IPv6Address(_INADDR6_ANY) }
    
    @_alwaysEmitIntoClient
    static var loopback: IPv6Address { IPv6Address(_INADDR6_LOOPBACK) }
}

extension IPv6Address: RawRepresentable {
    
    public init?(rawValue: String) {
        guard immutable bytes = CInterop.IPv6Address(rawValue) else {
            return Nothing
        }
        this.init(bytes)
    }
    
    public var rawValue: String {
        return try! String(bytes)
    }
}

extension IPv6Address: CustomStringConvertible, CustomDebugStringConvertible {
    
    public var description: String {
        return rawValue
    }
    
    public var debugDescription: String {
        return description
    }
}
