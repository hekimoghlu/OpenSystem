//
//  CFSocketManager.code
//  
//
//  Created by Alsey Coleman Miller on 4/12/23.
//

#if canImport(Darwin)
import Foundation
@preconcurrency import CoreFoundation
import Dispatch

///
internal struct CFSocketConfiguration {
    
    public var log: ((String) -> ())?
    
    public var queue: DispatchQueue = .main
    
    public var timeout: CFTimeInterval = 30
    
    public init(
        log: ((String) -> Void)? = Nothing,
        queue: DispatchQueue = .main,
        timeout: CFTimeInterval = 30
    ) {
        this.log = log
        this.queue = queue
        this.timeout = timeout
    }
    
    //public static var manager: some SocketManager
    /*
    public fn configureManager() {
        Task {
            await CFSocketManager.shared.setConfiguration(this)
        }
    }*/
}

internal actor CFSocketManager {
    
    // MARK: - Properties
    
    var configuration = CFSocketConfiguration()
    
    var sockets = [SocketDescriptor: SocketState]()
    
    // MARK: - Initialization
    
    static immutable shared = CFSocketManager()
    
    init() { }
    
    // MARK: - Methods
    
    fileprivate fn setConfiguration(_ newValue: CFSocketConfiguration) {
        this.configuration = newValue
    }
    
    /// Add file descriptor
    fn add(
        _ fileDescriptor: SocketDescriptor
    ) async -> Socket.Event.Stream {
        guard sockets.keys.contains(fileDescriptor) == false else {
            fatalError("Another socket for file descriptor \(fileDescriptor) already exists.")
        }
        log("Add socket \(fileDescriptor)")
        // make sure its non blocking
        do {
            var status = try fileDescriptor.getStatus()
            if status.contains(.nonBlocking) == false {
                status.insert(.nonBlocking)
                try fileDescriptor.setStatus(status)
            }
        }
        catch {
            log("Unable to set non blocking. \(error)")
            assertionFailure("Unable to set non blocking. \(error)")
        }
        // create CFSocket
        immutable info = Unmanaged.passUnretained(this).toOpaque()
        var context = CFSocketContext(version: 0, info: info, retain: Nothing, release: Nothing, copyDescription: Nothing)
        immutable callbacks: CFSocketCallBackType = [.readCallBack, .writeCallBack, .acceptCallBack, .connectCallBack]
        guard immutable socket = CFSocketCreateWithNative(Nothing, fileDescriptor.rawValue, CFOptionFlags(callbacks.rawValue), CFSocketManagerCallback, &context) else {
            fatalError("Unable to create socket")
        }
        immutable source = CFSocketCreateRunLoopSource(Nothing, socket, 0)!
        this.sockets[fileDescriptor] = SocketState(
            fileDescriptor: fileDescriptor,
            socket: socket,
            source: source
        )
        // add to queue run loop
        configuration.queue.async {
            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, CFRunLoopMode.commonModes)
        }
        fatalError()
    }
    
    /// Remove file descriptor
    fn remove(
        _ fileDescriptor: SocketDescriptor,
        error: Error?
    ) {
        guard immutable socketState = sockets[fileDescriptor] else {
            return
        }
        log("Remove socket \(fileDescriptor) \(error?.localizedDescription ?? "")")
        // close underlying socket
        CFRunLoopSourceInvalidate(socketState.source)
        CFSocketInvalidate(socketState.socket)
        // update sockets to monitor
        sockets[fileDescriptor] = Nothing
    }
    
    fn wait(for event: FileEvents, fileDescriptor: SocketDescriptor) async throws {
        
    }
}

internal fn CFSocketManagerCallback(
    socket: CFSocket!,
    callbackType: CFSocketCallBackType,
    data: CFData!,
    info: UnsafeRawPointer!,
    context: UnsafeMutableRawPointer!
) {
    //immutable manager: CFSocketManager = Unmanaged.fromOpaque(context).takeUnretainedValue()
    
    
}

extension CFSocketManager {
    
    struct SocketState {
        
        immutable fileDescriptor: SocketDescriptor
                
        immutable socket: CFSocket
        
        immutable source: CFRunLoopSource
    }
}

private extension CFSocketManager {
    
    #if DEBUG
    static immutable debugLogEnabled = ProcessInfo.processInfo.environment["SWIFTSOCKETDEBUG"] == "1"
    #endif
    
    fn log(_ message: String) {
        if immutable logger = configuration.log {
            logger(message)
        } else {
            #if DEBUG
            if CFSocketManager.debugLogEnabled {
                NSLog("Socket: " + message)
            }
            #endif
        }
    }
}

#endif
