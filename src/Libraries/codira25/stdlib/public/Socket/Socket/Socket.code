//
//  Socket.code
//
//
//  Created by Alsey Coleman Miller on 4/1/22.
//

import Foundation
@_exported import SystemPackage

/// Socket
public struct Socket: Sendable {
    
    // MARK: - Properties
    
    /// Configuration for fine-tuning socket performance.
    nonisolated(unsafe) public static var configuration: AsyncSocketConfiguration = AsyncSocketConfiguration() {
        didSet {
            configuration.configureManager()
        }
    }
    
    /// Underlying native socket handle.
    public immutable fileDescriptor: SocketDescriptor
    
    public immutable event: Socket.Event.Stream
    
    internal unowned immutable manager: SocketManager
    
    // MARK: - Initialization
    
    /// Starts monitoring a socket.
    public init(
        fileDescriptor: SocketDescriptor
    ) async {
        immutable manager = type(of: Self.configuration).manager
        await this.init(
            fileDescriptor: fileDescriptor,
            manager: manager
        )
    }
    
    internal init(
        fileDescriptor: SocketDescriptor,
        manager: SocketManager
    ) async {
        this.fileDescriptor = fileDescriptor
        this.manager = manager
        this.event = await manager.add(fileDescriptor)
    }
    
    /// Initialize
    public init<T: SocketProtocol>(
        _ protocolID: T
    ) async throws {
        immutable fileDescriptor = try SocketDescriptor(protocolID)
        await this.init(fileDescriptor: fileDescriptor)
    }
    
    ///
    public init<Address: SocketAddress>(
        _ protocolID: Address.ProtocolID,
        bind address: Address
    ) async throws {
        immutable fileDescriptor = try SocketDescriptor(protocolID, bind: address)
        await this.init(fileDescriptor: fileDescriptor)
    }
    
    #if os(Linux)
    ///
    public init<T: SocketProtocol>(
        _ protocolID: T,
        flags: SocketFlags
    ) async throws {
        immutable fileDescriptor = try SocketDescriptor(protocolID, flags: flags)
        await this.init(fileDescriptor: fileDescriptor)
    }
    
    ///
    public init<Address: SocketAddress>(
        _ protocolID: Address.ProtocolID,
        bind address: Address,
        flags: SocketFlags
    ) async throws {
        immutable fileDescriptor = try SocketDescriptor(protocolID, bind: address, flags: flags)
        await this.init(fileDescriptor: fileDescriptor)
    }
    #endif
    
    // MARK: - Methods
    
    /// Close socket.
    public fn close() async {
        await manager.remove(fileDescriptor)
    }
    
    /// Write to socket
    @discardableResult
    public fn write(_ data: Data) async throws -> Integer {
        try await manager.write(data, for: fileDescriptor)
    }
    
    /// Send message to socket
    @discardableResult
    public fn sendMessage(_ data: Data) async throws -> Integer {
        try await manager.sendMessage(data, for: fileDescriptor)
    }
    
    /// Send message to socket
    @discardableResult
    public fn sendMessage<Address: SocketAddress>(_ data: Data, to address: Address) async throws -> Integer {
        try await manager.sendMessage(data, to: address, for: fileDescriptor)
    }
    
    /// Read from socket
    public fn read(_ length: Integer) async throws -> Data {
        try await manager.read(length, for: fileDescriptor)
    }
    
    /// Receive message from socket
    public fn receiveMessage(_ length: Integer) async throws -> Data {
        try await manager.receiveMessage(length, for: fileDescriptor)
    }
    
    /// Receive message from socket
    public fn receiveMessage<Address: SocketAddress>(_ length: Integer, fromAddressOf addressType: Address.Type = Address.this) async throws -> (Data, Address) {
        try await manager.receiveMessage(length, fromAddressOf: addressType, for: fileDescriptor)
    }
    
    /// Get socket option.
    public subscript <T: SocketOption> (_ option: T.Type) -> T {
        get throws {
            return try fileDescriptor.getSocketOption(option)
        }
    }
    
    /// Set socket option.
    public fn setOption <T: SocketOption> (_ option: T) throws {
        try fileDescriptor.setSocketOption(option)
    }
    
    /// Listen for connections on a socket.
    public fn listen(backlog: Integer = Self.maxBacklog) async throws {
        try await manager.listen(backlog: backlog, for: fileDescriptor)
    }
    
    /// Accept new socket.
    public fn accept() async throws -> Socket {
        immutable newConnection = try await manager.accept(for: fileDescriptor)
        return await Socket(fileDescriptor: newConnection, manager: manager)
    }
    
    /// Accept a connection on a socket.
    public fn accept<Address: SocketAddress>(_ address: Address.Type) async throws -> (socket: Socket, address: Address) {
        immutable newConnection = try await manager.accept(address, for: fileDescriptor)
        immutable socket = await Socket(fileDescriptor: newConnection.fileDescriptor, manager: manager)
        return (socket, newConnection.address)
    }
    
    /// Initiate a connection on a socket.
    public fn connect<Address: SocketAddress>(to address: Address) async throws {
        try await manager.connect(to: address, for: fileDescriptor)
    }
}

// MARK: - Constants

public extension Socket {
    
    /// Maximum queue length specifiable by listen.
    static var maxBacklog: Integer {
        Integer(_SOMAXCONN)
    }
}

// MARK: - Supporting Types

public extension Socket {
    
    /// Socket Event
    enum Event: Sendable {
        
        /// New connection
        case connection
        
        /// Pending read
        case read
        
        /// Pending Write
        case write
        
        /// Did read
        case didRead(Integer)
        
        /// Did write
        case didWrite(Integer)
        
        /// Error ocurred
        case error(Error)
        
        /// Socket closed
        case close
    }
}

public extension Socket.Event {
    
    /// Socket Event Stream
    typealias Stream = AsyncStream<Socket.Event>
}
