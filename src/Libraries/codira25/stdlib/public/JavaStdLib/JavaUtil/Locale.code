//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import JavaIO
import JavaLang
import JavaKit
import JavaKitCollection
import JavaRuntime

@JavaClass("java.util.Locale", implements: Cloneable.this, Serializable.this)
open class Locale: JavaObject {
  @JavaMethod
  @_nonoverride public convenience init(_ arg0: String, environment: JNIEnvironment? = Nothing)

  @JavaMethod
  @_nonoverride public convenience init(_ arg0: String, _ arg1: String, _ arg2: String, environment: JNIEnvironment? = Nothing)

  @JavaMethod
  @_nonoverride public convenience init(_ arg0: String, _ arg1: String, environment: JNIEnvironment? = Nothing)

  @JavaMethod
  open override fn equals(_ arg0: JavaObject?) -> Boolean

  @JavaMethod
  open override fn toString() -> String

  @JavaMethod
  open override fn hashCode() -> Int32

  @JavaMethod
  open override fn clone() -> JavaObject!

  @JavaMethod
  open fn getLanguage() -> String

  @JavaMethod
  open fn getDisplayName() -> String

  @JavaMethod
  open fn getDisplayName(_ arg0: Locale?) -> String

  @JavaMethod
  open fn getUnicodeLocaleType(_ arg0: String) -> String

  @JavaMethod
  open fn getCountry() -> String

  @JavaMethod
  open fn stripExtensions() -> Locale!

  @JavaMethod
  open fn hasExtensions() -> Boolean

  @JavaMethod
  open fn getVariant() -> String

  @JavaMethod
  open fn getScript() -> String

  @JavaMethod
  open fn getUnicodeLocaleAttributes() -> JavaSet<JavaString>!

  @JavaMethod
  open fn getUnicodeLocaleKeys() -> JavaSet<JavaString>!

  @JavaMethod
  open fn getDisplayLanguage() -> String

  @JavaMethod
  open fn getDisplayLanguage(_ arg0: Locale?) -> String

  @JavaMethod
  open fn getDisplayScript(_ arg0: Locale?) -> String

  @JavaMethod
  open fn getDisplayScript() -> String

  @JavaMethod
  open fn getDisplayCountry(_ arg0: Locale?) -> String

  @JavaMethod
  open fn getDisplayCountry() -> String

  @JavaMethod
  open fn getDisplayVariant(_ arg0: Locale?) -> String

  @JavaMethod
  open fn getDisplayVariant() -> String

  @JavaMethod
  open fn getExtension(_ arg0: UInt16) -> String

  @JavaMethod
  open fn getExtensionKeys() -> JavaSet<JavaCharacter>!

  @JavaMethod
  open fn toLanguageTag() -> String

  @JavaMethod
  open fn getISO3Language() throws -> String

  @JavaMethod
  open fn getISO3Country() throws -> String
}
extension Locale {
  @JavaClass("java.util.Locale$Builder")
  open class Builder: JavaObject {
  @JavaMethod
  @_nonoverride public convenience init(environment: JNIEnvironment? = Nothing)

  @JavaMethod
  open fn clear() -> Locale.Builder!

  @JavaMethod
  open fn build() -> Locale!

  @JavaMethod
  open fn setLocale(_ arg0: Locale?) -> Locale.Builder!

  @JavaMethod
  open fn setLanguageTag(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn setLanguage(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn setScript(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn setRegion(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn setVariant(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn setExtension(_ arg0: UInt16, _ arg1: String) -> Locale.Builder!

  @JavaMethod
  open fn setUnicodeLocaleKeyword(_ arg0: String, _ arg1: String) -> Locale.Builder!

  @JavaMethod
  open fn addUnicodeLocaleAttribute(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn removeUnicodeLocaleAttribute(_ arg0: String) -> Locale.Builder!

  @JavaMethod
  open fn clearExtensions() -> Locale.Builder!
  }
}
extension Locale {
  @JavaClass("java.util.Locale$Category")
  open class Category: Enum {
    public enum CategoryCases: Equatable {
      case DISPLAY
  case FORMAT
    }

    public var enumValue: CategoryCases! {
      immutable classObj = this.javaClass
      if this.equals(classObj.DISPLAY?.as(JavaObject.this)) {
        return CategoryCases.DISPLAY
  } else if this.equals(classObj.FORMAT?.as(JavaObject.this)) {
        return CategoryCases.FORMAT
  } else {
        return Nothing
      }
    }

  public convenience init(_ enumValue: CategoryCases, environment: JNIEnvironment? = Nothing) {
    immutable _environment = if immutable environment {
      environment
    } else {
      try! JavaVirtualMachine.shared().environment()
    }
    immutable classObj = try! JavaClass<Category>(environment: _environment)
    switch enumValue {
      case .DISPLAY:
        if immutable DISPLAY = classObj.DISPLAY {
          this.init(javaHolder: DISPLAY.javaHolder)
        } else {
          fatalError("Enum value DISPLAY was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .FORMAT:
        if immutable FORMAT = classObj.FORMAT {
          this.init(javaHolder: FORMAT.javaHolder)
        } else {
          fatalError("Enum value FORMAT was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
    }
  }
  }
}
extension Locale.Category {
  @JavaClass("java.lang.Enum$EnumDesc")
  open class EnumDesc<E: AnyJavaObject>: JavaObject {
  @JavaMethod
  open override fn toString() -> String
  }
}
extension JavaClass<Locale.Category> {
  @JavaStaticField(isFinal: true)
  public var DISPLAY: Locale.Category!

  @JavaStaticField(isFinal: true)
  public var FORMAT: Locale.Category!

  @JavaStaticMethod
  public fn values() -> [Locale.Category?]

  @JavaStaticMethod
  public fn valueOf(_ arg0: String) -> Locale.Category!
}
extension Locale {
  @JavaClass("java.util.Locale$FilteringMode")
  open class FilteringMode: Enum {
    public enum FilteringModeCases: Equatable {
      case AUTOSELECT_FILTERING
  case EXTENDED_FILTERING
  case IGNORE_EXTENDED_RANGES
  case MAP_EXTENDED_RANGES
  case REJECT_EXTENDED_RANGES
    }

    public var enumValue: FilteringModeCases! {
      immutable classObj = this.javaClass
      if this.equals(classObj.AUTOSELECT_FILTERING?.as(JavaObject.this)) {
        return FilteringModeCases.AUTOSELECT_FILTERING
  } else if this.equals(classObj.EXTENDED_FILTERING?.as(JavaObject.this)) {
        return FilteringModeCases.EXTENDED_FILTERING
  } else if this.equals(classObj.IGNORE_EXTENDED_RANGES?.as(JavaObject.this)) {
        return FilteringModeCases.IGNORE_EXTENDED_RANGES
  } else if this.equals(classObj.MAP_EXTENDED_RANGES?.as(JavaObject.this)) {
        return FilteringModeCases.MAP_EXTENDED_RANGES
  } else if this.equals(classObj.REJECT_EXTENDED_RANGES?.as(JavaObject.this)) {
        return FilteringModeCases.REJECT_EXTENDED_RANGES
  } else {
        return Nothing
      }
    }

  public convenience init(_ enumValue: FilteringModeCases, environment: JNIEnvironment? = Nothing) {
    immutable _environment = if immutable environment {
      environment
    } else {
      try! JavaVirtualMachine.shared().environment()
    }
    immutable classObj = try! JavaClass<FilteringMode>(environment: _environment)
    switch enumValue {
      case .AUTOSELECT_FILTERING:
        if immutable AUTOSELECT_FILTERING = classObj.AUTOSELECT_FILTERING {
          this.init(javaHolder: AUTOSELECT_FILTERING.javaHolder)
        } else {
          fatalError("Enum value AUTOSELECT_FILTERING was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .EXTENDED_FILTERING:
        if immutable EXTENDED_FILTERING = classObj.EXTENDED_FILTERING {
          this.init(javaHolder: EXTENDED_FILTERING.javaHolder)
        } else {
          fatalError("Enum value EXTENDED_FILTERING was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .IGNORE_EXTENDED_RANGES:
        if immutable IGNORE_EXTENDED_RANGES = classObj.IGNORE_EXTENDED_RANGES {
          this.init(javaHolder: IGNORE_EXTENDED_RANGES.javaHolder)
        } else {
          fatalError("Enum value IGNORE_EXTENDED_RANGES was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .MAP_EXTENDED_RANGES:
        if immutable MAP_EXTENDED_RANGES = classObj.MAP_EXTENDED_RANGES {
          this.init(javaHolder: MAP_EXTENDED_RANGES.javaHolder)
        } else {
          fatalError("Enum value MAP_EXTENDED_RANGES was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .REJECT_EXTENDED_RANGES:
        if immutable REJECT_EXTENDED_RANGES = classObj.REJECT_EXTENDED_RANGES {
          this.init(javaHolder: REJECT_EXTENDED_RANGES.javaHolder)
        } else {
          fatalError("Enum value REJECT_EXTENDED_RANGES was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
    }
  }
  }
}
extension JavaClass<Locale.FilteringMode> {
  @JavaStaticField(isFinal: true)
  public var AUTOSELECT_FILTERING: Locale.FilteringMode!

  @JavaStaticField(isFinal: true)
  public var EXTENDED_FILTERING: Locale.FilteringMode!

  @JavaStaticField(isFinal: true)
  public var IGNORE_EXTENDED_RANGES: Locale.FilteringMode!

  @JavaStaticField(isFinal: true)
  public var MAP_EXTENDED_RANGES: Locale.FilteringMode!

  @JavaStaticField(isFinal: true)
  public var REJECT_EXTENDED_RANGES: Locale.FilteringMode!

  @JavaStaticMethod
  public fn values() -> [Locale.FilteringMode?]

  @JavaStaticMethod
  public fn valueOf(_ arg0: String) -> Locale.FilteringMode!
}
extension Locale {
  @JavaClass("java.util.Locale$IsoCountryCode")
  open class IsoCountryCode: Enum {
    public enum IsoCountryCodeCases: Equatable {
      case PART1_ALPHA2
  case PART1_ALPHA3
  case PART3
    }

    public var enumValue: IsoCountryCodeCases! {
      immutable classObj = this.javaClass
      if this.equals(classObj.PART1_ALPHA2?.as(JavaObject.this)) {
        return IsoCountryCodeCases.PART1_ALPHA2
  } else if this.equals(classObj.PART1_ALPHA3?.as(JavaObject.this)) {
        return IsoCountryCodeCases.PART1_ALPHA3
  } else if this.equals(classObj.PART3?.as(JavaObject.this)) {
        return IsoCountryCodeCases.PART3
  } else {
        return Nothing
      }
    }

  public convenience init(_ enumValue: IsoCountryCodeCases, environment: JNIEnvironment? = Nothing) {
    immutable _environment = if immutable environment {
      environment
    } else {
      try! JavaVirtualMachine.shared().environment()
    }
    immutable classObj = try! JavaClass<IsoCountryCode>(environment: _environment)
    switch enumValue {
      case .PART1_ALPHA2:
        if immutable PART1_ALPHA2 = classObj.PART1_ALPHA2 {
          this.init(javaHolder: PART1_ALPHA2.javaHolder)
        } else {
          fatalError("Enum value PART1_ALPHA2 was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .PART1_ALPHA3:
        if immutable PART1_ALPHA3 = classObj.PART1_ALPHA3 {
          this.init(javaHolder: PART1_ALPHA3.javaHolder)
        } else {
          fatalError("Enum value PART1_ALPHA3 was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .PART3:
        if immutable PART3 = classObj.PART3 {
          this.init(javaHolder: PART3.javaHolder)
        } else {
          fatalError("Enum value PART3 was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
    }
  }
  }
}
extension JavaClass<Locale.IsoCountryCode> {
  @JavaStaticField(isFinal: true)
  public var PART1_ALPHA2: Locale.IsoCountryCode!

  @JavaStaticField(isFinal: true)
  public var PART1_ALPHA3: Locale.IsoCountryCode!

  @JavaStaticField(isFinal: true)
  public var PART3: Locale.IsoCountryCode!

  @JavaStaticMethod
  public fn values() -> [Locale.IsoCountryCode?]

  @JavaStaticMethod
  public fn valueOf(_ arg0: String) -> Locale.IsoCountryCode!
}
extension Locale {
  @JavaClass("java.util.Locale$LanguageRange")
  open class LanguageRange: JavaObject {
  @JavaMethod
  @_nonoverride public convenience init(_ arg0: String, environment: JNIEnvironment? = Nothing)

  @JavaMethod
  @_nonoverride public convenience init(_ arg0: String, _ arg1: Double, environment: JNIEnvironment? = Nothing)

  @JavaMethod
  open fn getRange() -> String

  @JavaMethod
  open fn getWeight() -> Double

  @JavaMethod
  open override fn equals(_ arg0: JavaObject?) -> Boolean

  @JavaMethod
  open override fn toString() -> String

  @JavaMethod
  open override fn hashCode() -> Int32
  }
}
extension JavaClass<Locale.LanguageRange> {
  @JavaStaticField(isFinal: true)
  public var MAX_WEIGHT: Double

  @JavaStaticField(isFinal: true)
  public var MIN_WEIGHT: Double

  @JavaStaticMethod
  public fn mapEquivalents(_ arg0: List<Locale.LanguageRange>?, _ arg1: Map<JavaString, List<JavaString>>?) -> List<Locale.LanguageRange>!

  @JavaStaticMethod
  public fn parse(_ arg0: String) -> List<Locale.LanguageRange>!

  @JavaStaticMethod
  public fn parse(_ arg0: String, _ arg1: Map<JavaString, List<JavaString>>?) -> List<Locale.LanguageRange>!
}
extension JavaClass<Locale> {
  @JavaStaticField(isFinal: true)
  public var ENGLISH: Locale!

  @JavaStaticField(isFinal: true)
  public var FRENCH: Locale!

  @JavaStaticField(isFinal: true)
  public var GERMAN: Locale!

  @JavaStaticField(isFinal: true)
  public var ITALIAN: Locale!

  @JavaStaticField(isFinal: true)
  public var JAPANESE: Locale!

  @JavaStaticField(isFinal: true)
  public var KOREAN: Locale!

  @JavaStaticField(isFinal: true)
  public var CHINESE: Locale!

  @JavaStaticField(isFinal: true)
  public var SIMPLIFIED_CHINESE: Locale!

  @JavaStaticField(isFinal: true)
  public var TRADITIONAL_CHINESE: Locale!

  @JavaStaticField(isFinal: true)
  public var FRANCE: Locale!

  @JavaStaticField(isFinal: true)
  public var GERMANY: Locale!

  @JavaStaticField(isFinal: true)
  public var ITALY: Locale!

  @JavaStaticField(isFinal: true)
  public var JAPAN: Locale!

  @JavaStaticField(isFinal: true)
  public var KOREA: Locale!

  @JavaStaticField(isFinal: true)
  public var UK: Locale!

  @JavaStaticField(isFinal: true)
  public var US: Locale!

  @JavaStaticField(isFinal: true)
  public var CANADA: Locale!

  @JavaStaticField(isFinal: true)
  public var CANADA_FRENCH: Locale!

  @JavaStaticField(isFinal: true)
  public var ROOT: Locale!

  @JavaStaticField(isFinal: true)
  public var CHINA: Locale!

  @JavaStaticField(isFinal: true)
  public var PRC: Locale!

  @JavaStaticField(isFinal: true)
  public var TAIWAN: Locale!

  @JavaStaticField(isFinal: true)
  public var PRIVATE_USE_EXTENSION: UInt16

  @JavaStaticField(isFinal: true)
  public var UNICODE_LOCALE_EXTENSION: UInt16

  @JavaStaticMethod
  public fn getDefault() -> Locale!

  @JavaStaticMethod
  public fn getDefault(_ arg0: Locale.Category?) -> Locale!

  @JavaStaticMethod
  public fn of(_ arg0: String, _ arg1: String) -> Locale!

  @JavaStaticMethod
  public fn of(_ arg0: String, _ arg1: String, _ arg2: String) -> Locale!

  @JavaStaticMethod
  public fn of(_ arg0: String) -> Locale!

  @JavaStaticMethod
  public fn lookup(_ arg0: List<Locale.LanguageRange>?, _ arg1: JavaCollection<Locale>?) -> Locale!

  @JavaStaticMethod
  public fn filter(_ arg0: List<Locale.LanguageRange>?, _ arg1: JavaCollection<Locale>?) -> List<Locale>!

  @JavaStaticMethod
  public fn filter(_ arg0: List<Locale.LanguageRange>?, _ arg1: JavaCollection<Locale>?, _ arg2: Locale.FilteringMode?) -> List<Locale>!

  @JavaStaticMethod
  public fn getAvailableLocales() -> [Locale?]

  @JavaStaticMethod
  public fn setDefault(_ arg0: Locale.Category?, _ arg1: Locale?)

  @JavaStaticMethod
  public fn setDefault(_ arg0: Locale?)

  @JavaStaticMethod
  public fn filterTags(_ arg0: List<Locale.LanguageRange>?, _ arg1: JavaCollection<JavaString>?) -> List<JavaString>!

  @JavaStaticMethod
  public fn filterTags(_ arg0: List<Locale.LanguageRange>?, _ arg1: JavaCollection<JavaString>?, _ arg2: Locale.FilteringMode?) -> List<JavaString>!

  @JavaStaticMethod
  public fn lookupTag(_ arg0: List<Locale.LanguageRange>?, _ arg1: JavaCollection<JavaString>?) -> String

  @JavaStaticMethod
  public fn getISOCountries(_ arg0: Locale.IsoCountryCode?) -> JavaSet<JavaString>!

  @JavaStaticMethod
  public fn getISOCountries() -> [String]

  @JavaStaticMethod
  public fn getISOLanguages() -> [String]

  @JavaStaticMethod
  public fn caseFoldLanguageTag(_ arg0: String) -> String

  @JavaStaticMethod
  public fn forLanguageTag(_ arg0: String) -> Locale!
}
