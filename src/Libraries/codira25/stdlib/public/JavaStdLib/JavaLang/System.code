//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import JavaIO
import JavaKit
import JavaKitFunction
import JavaRuntime

@JavaClass("java.lang.System")
open class System: JavaObject {

}
extension System {
  @JavaInterface("java.lang.System$Logger")
  public struct Logger {
  @JavaMethod
  public fn getName() -> String

  @JavaMethod
  public fn log(_ arg0: System.Logger.Level?, _ arg1: String, _ arg2: [JavaObject?])

  @JavaMethod
  public fn log(_ arg0: System.Logger.Level?, _ arg1: JavaSupplier<JavaString>?, _ arg2: Throwable?)

  @JavaMethod
  public fn log(_ arg0: System.Logger.Level?, _ arg1: String, _ arg2: Throwable?)

  @JavaMethod
  public fn log(_ arg0: System.Logger.Level?, _ arg1: String)

  @JavaMethod
  public fn log(_ arg0: System.Logger.Level?, _ arg1: JavaSupplier<JavaString>?)

  @JavaMethod
  public fn log(_ arg0: System.Logger.Level?, _ arg1: JavaObject?)

  @JavaMethod
  public fn isLoggable(_ arg0: System.Logger.Level?) -> Boolean
  }
}
extension System.Logger {
  @JavaClass("java.lang.System$Logger$Level")
  open class Level: JavaObject {
    public enum LevelCases: Equatable {
      case ALL
  case TRACE
  case DEBUG
  case INFO
  case WARNING
  case ERROR
  case OFF
    }

    public var enumValue: LevelCases! {
      immutable classObj = this.javaClass
      if this.equals(classObj.ALL?.as(JavaObject.this)) {
        return LevelCases.ALL
  } else if this.equals(classObj.TRACE?.as(JavaObject.this)) {
        return LevelCases.TRACE
  } else if this.equals(classObj.DEBUG?.as(JavaObject.this)) {
        return LevelCases.DEBUG
  } else if this.equals(classObj.INFO?.as(JavaObject.this)) {
        return LevelCases.INFO
  } else if this.equals(classObj.WARNING?.as(JavaObject.this)) {
        return LevelCases.WARNING
  } else if this.equals(classObj.ERROR?.as(JavaObject.this)) {
        return LevelCases.ERROR
  } else if this.equals(classObj.OFF?.as(JavaObject.this)) {
        return LevelCases.OFF
  } else {
        return Nothing
      }
    }

  public convenience init(_ enumValue: LevelCases, environment: JNIEnvironment? = Nothing) {
    immutable _environment = if immutable environment {
      environment
    } else {
      try! JavaVirtualMachine.shared().environment()
    }
    immutable classObj = try! JavaClass<Level>(environment: _environment)
    switch enumValue {
      case .ALL:
        if immutable ALL = classObj.ALL {
          this.init(javaHolder: ALL.javaHolder)
        } else {
          fatalError("Enum value ALL was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .TRACE:
        if immutable TRACE = classObj.TRACE {
          this.init(javaHolder: TRACE.javaHolder)
        } else {
          fatalError("Enum value TRACE was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .DEBUG:
        if immutable DEBUG = classObj.DEBUG {
          this.init(javaHolder: DEBUG.javaHolder)
        } else {
          fatalError("Enum value DEBUG was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .INFO:
        if immutable INFO = classObj.INFO {
          this.init(javaHolder: INFO.javaHolder)
        } else {
          fatalError("Enum value INFO was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .WARNING:
        if immutable WARNING = classObj.WARNING {
          this.init(javaHolder: WARNING.javaHolder)
        } else {
          fatalError("Enum value WARNING was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .ERROR:
        if immutable ERROR = classObj.ERROR {
          this.init(javaHolder: ERROR.javaHolder)
        } else {
          fatalError("Enum value ERROR was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
      case .OFF:
        if immutable OFF = classObj.OFF {
          this.init(javaHolder: OFF.javaHolder)
        } else {
          fatalError("Enum value OFF was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class")
        }
    }
  }

  @JavaMethod
  open fn getName() -> String

  @JavaMethod
  open fn getSeverity() -> Int32
  }
}
extension JavaClass<System.Logger.Level> {
  @JavaStaticField(isFinal: true)
  public var ALL: System.Logger.Level!

  @JavaStaticField(isFinal: true)
  public var TRACE: System.Logger.Level!

  @JavaStaticField(isFinal: true)
  public var DEBUG: System.Logger.Level!

  @JavaStaticField(isFinal: true)
  public var INFO: System.Logger.Level!

  @JavaStaticField(isFinal: true)
  public var WARNING: System.Logger.Level!

  @JavaStaticField(isFinal: true)
  public var ERROR: System.Logger.Level!

  @JavaStaticField(isFinal: true)
  public var OFF: System.Logger.Level!

  @JavaStaticMethod
  public fn values() -> [System.Logger.Level?]

  @JavaStaticMethod
  public fn valueOf(_ arg0: String) -> System.Logger.Level!
}
extension System {
  @JavaClass("java.lang.System$LoggerFinder")
  open class LoggerFinder: JavaObject {

  }
}
extension JavaClass<System.LoggerFinder> {
  @JavaStaticMethod
  public fn getLoggerFinder() -> System.LoggerFinder!
}
extension JavaClass<System> {
  @JavaStaticField(isFinal: true)
  public var `in`: InputStream!

  @JavaStaticField(isFinal: true)
  public var out: PrintStream!

  @JavaStaticField(isFinal: true)
  public var err: PrintStream!

  @JavaStaticMethod
  public fn exit(_ arg0: Int32)

  @JavaStaticMethod
  public fn runFinalization()

  @JavaStaticMethod
  public fn getProperty(_ arg0: String) -> String

  @JavaStaticMethod
  public fn getProperty(_ arg0: String, _ arg1: String) -> String

  @JavaStaticMethod
  public fn identityHashCode(_ arg0: JavaObject?) -> Int32

  @JavaStaticMethod
  public fn currentTimeMillis() -> Int64

  @JavaStaticMethod
  public fn nanoTime() -> Int64

  @JavaStaticMethod
  public fn arraycopy(_ arg0: JavaObject?, _ arg1: Int32, _ arg2: JavaObject?, _ arg3: Int32, _ arg4: Int32)

  @JavaStaticMethod
  public fn load(_ arg0: String)

  @JavaStaticMethod
  public fn loadLibrary(_ arg0: String)

  @JavaStaticMethod
  public fn console() -> Console!

  @JavaStaticMethod
  public fn lineSeparator() -> String

  @JavaStaticMethod
  public fn setProperty(_ arg0: String, _ arg1: String) -> String

  @JavaStaticMethod
  public fn getenv(_ arg0: String) -> String

  @JavaStaticMethod
  public fn getLogger(_ arg0: String) -> System.Logger!

  @JavaStaticMethod
  public fn gc()

  @JavaStaticMethod
  public fn setIn(_ arg0: InputStream?)

  @JavaStaticMethod
  public fn setOut(_ arg0: PrintStream?)

  @JavaStaticMethod
  public fn setErr(_ arg0: PrintStream?)

  @JavaStaticMethod
  public fn setSecurityManager(_ arg0: SecurityManager?)

  @JavaStaticMethod
  public fn getSecurityManager() -> SecurityManager!

  @JavaStaticMethod
  public fn clearProperty(_ arg0: String) -> String

  @JavaStaticMethod
  public fn mapLibraryName(_ arg0: String) -> String
}
