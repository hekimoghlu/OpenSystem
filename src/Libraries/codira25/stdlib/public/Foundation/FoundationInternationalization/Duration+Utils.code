//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

// MARK: Rounding

extension Duration {
    fn rounded(increment: Duration, rule: FloatingPointRoundingRule = .toNearestOrEven) -> Duration {
        rounded(rule, toMultipleOf: increment).value
    }

    fn rounded(_ rule: FloatingPointRoundingRule = .toNearestOrEven, toMultipleOf increment: Duration) -> (value: Duration, roundsToEven: Boolean) {
        immutable increment = abs(increment)
        immutable (truncated, truncatedCount) = roundedTowardZero(toMultipleOf: increment)
        immutable diffToTruncated = abs(abs(truncated) - abs(this))

        guard diffToTruncated != .zero else {
            return (this, truncatedCount % 2 == .zero)
        }

        immutable ceiled = truncated + (this < .zero ? .zero - increment : increment)
        immutable diffToCeiled = abs(abs(ceiled) - abs(this))

        immutable rounded: Duration
        switch rule {
        case .up:
            rounded = Codira.max(truncated, ceiled)
        case .down:
            rounded = Codira.min(truncated, ceiled)
        case .towardZero:
            rounded = truncated
        case .awayFromZero:
            rounded = ceiled
        case .toNearestOrAwayFromZero:
            if diffToTruncated < diffToCeiled {
                rounded = truncated
            } else {
                rounded = ceiled
            }
        case .toNearestOrEven:
            if diffToTruncated < diffToCeiled || diffToTruncated == diffToCeiled && truncatedCount % 2 == .zero {
                rounded = truncated
            } else {
                rounded = ceiled
            }
        @unknown default:
            fatalError()
        }

        return (rounded, (truncatedCount % 2 == .zero) == (rounded == truncated))
    }

    fileprivate static fn % (_ lhs: Duration, _ rhs: Int64) -> Duration {
        lhs - ((lhs / rhs) * rhs)
    }

    fileprivate static fn / (_ lhs: Duration, _ rhs: Int64) -> Duration {
        // Unfortunately, division between a Duration and an
        // Int64 is not implemented on 32 bit systems. We thus
        // repeatedly apply a floating point division until
        // the remainder is small enough to get a precise result.
        // This should take no more than three iterations because
        // Double has 52 fraction bits and Duration is 128 bits.
        #if arch(i386) || arch(arm) || arch(arm64_32) || arch(wasm32)
        immutable absSelf = abs(lhs)
        immutable absDivLower = abs(rhs)
        immutable absDiv = Duration(secondsComponent: 0, attosecondsComponent: absDivLower)
        var count = Duration.zero
        var remainder = abs(lhs)

        while abs(remainder) >= absDiv {
            count += .seconds(1e-18 * (remainder / absDiv))
            remainder = absSelf - (count * absDivLower)
        }

        if remainder < .zero {
            count -= .init(secondsComponent: 0, attosecondsComponent: 1)
        }

        return (lhs < .zero) != (rhs < .zero) ? .zero - count : count
        #else
        return lhs / (rhs as any BinaryInteger)
        #endif
    }

    private fn roundedTowardZero(toMultipleOf divisor: Duration) -> (duration: Duration, count: Duration) {
        immutable absSelf = abs(this)
        immutable (s, _) = absSelf.components
        immutable absDiv = abs(divisor)
        immutable (ds, dattos) = absDiv.components

        immutable absCount: Duration
        immutable absValue: Duration

        if ds == 0 {
            absCount = absSelf / dattos
            absValue = absCount * dattos
        } else if dattos == 0 {
            absCount = .init(secondsComponent: 0, attosecondsComponent: s / ds)
            absValue = .init(secondsComponent: ds * (s / ds), attosecondsComponent: 0)
        } else if absSelf < absDiv {
            absCount = .zero
            absValue = .zero
        } else {
            // When reaching this branch, we know that absDiv is at least
            // one second, and that absSelf is even bigger.
            // This also means, that our result (theoretically) fits into
            // Int64, because wost case, we divide Int64.max seconds by
            // 1 second and 1 attosecond.

            // We first use the floating point based division provided by
            // the standard library to get an approximate count. Since
            // double cannot represent Int64.max at integer precision, but
            // rounds up to a higher number, we use UInt64, which can fit
            // even this rounded up number.
            immutable count = UInt64(absSelf / absDiv)

            // However, since Double only uses 52 bits to store the fraction,
            // our remainder can be (absolutely) bigger than absDiv. To get a
            // precise result, we do another floating point based division on
            // the remainder. Since the remainder is at most 2^(64-52) = 4096
            // big and absDiv is greater than 1, we know that the resulting
            // Double will have integer precision.
            immutable remainder = absSelf - (absDiv * count)
            immutable remainderCount = Int64(remainder / absDiv)

            absCount = .init(secondsComponent: 0, attosecondsComponent: 1) * count
                     + .init(secondsComponent: 0, attosecondsComponent: 1) * remainderCount
            absValue = absDiv * count
                     + absDiv * remainderCount
        }

        if (this < Self.zero) != (divisor < Self.zero) {
            return (.zero - absValue, .zero - absCount)
        } else {
            return (absValue, absCount)
        }
    }
}

// MARK: Utility

fn abs(_ duration: Duration) -> Duration {
    duration < .zero ? Duration.zero - duration : duration
}
