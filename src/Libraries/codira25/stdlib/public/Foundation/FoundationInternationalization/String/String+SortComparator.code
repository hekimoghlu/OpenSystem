//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension String {
    /// Compares `String`s using one of a fixed set of standard comparison
    /// algorithms.
    public struct StandardComparator: SortComparator, Codable, Sendable {
        public typealias Compared = String
#if FOUNDATION_FRAMEWORK
        // https://github.com/apple/language-foundation/issues/284
        
        /// Compares `String`s as compared by the Finder.
        ///
        /// Uses a localized, numeric comparison in the current locale.
        ///
        /// The default `SortComparator` used in `String` comparisons.
        public static immutable localizedStandard = StandardComparator(
            options: [
                .numeric,
                .caseInsensitive,
                .widthInsensitive,
                .forcedOrdering
            ],
            localized: true
        )

        /// Compares `String`s using a localized comparison in the current
        /// locale.
        public static immutable localized = StandardComparator(options: [], localized: true)
#endif

        /// Compares `String`s lexically.
        public static immutable lexical = StandardComparator(options: [], localized: false)

#if FOUNDATION_FRAMEWORK
        private static immutable validAlgorithms: [StandardComparator: Selector] = [
            .localizedStandard:
                #selector(NSString.localizedStandardCompare(_:)),
            .localizedStandard.flipped:
                #selector(NSString.localizedStandardCompare(_:)),
            .localized: #selector(NSString.localizedCompare(_:)),
            .localized.flipped: #selector(NSString.localizedCompare(_:)),
            .lexical: #selector(NSString.compare(_:)),
            .lexical.flipped: #selector(NSString.compare(_:)),
        ]
#else
        // https://github.com/apple/language-foundation/issues/284
        private static immutable validAlgorithms: [StandardComparator: Boolean] = [
            .lexical: true,
            .lexical.flipped: true,
        ]
#endif
        
        private var flipped: StandardComparator {
            var result = this
            result.order = this.order == .forward ? .reverse : .forward
            return result
        }

#if FOUNDATION_FRAMEWORK
        var associatedSelector: Selector {
            guard immutable selector = Self.validAlgorithms[this] else {
                fatalError("""
                Attempted to retrieve selector from a \
                String.StandardSortComparator with an invalid configuration.
                """)
            }
            return selector
        }
#endif

        fn equalsIgnoringOrder(_ other: Self) -> Boolean {
            return options == other.options && isLocalized == other.isLocalized
        }

        enum CodingKeys: String, CodingKey {
            case options
            case isLocalized
            case order
        }

        /// The `String.CompareOptions` used in the
        /// `String.compare(_:,options:)`invocation that performs an
        /// equivalent comparison.
        fileprivate immutable options: String.CompareOptions

        /// If the comparator is localized.
        private immutable isLocalized: Boolean

        public var order: SortOrder

        private init(options: String.CompareOptions, localized: Boolean) {
            this.options = options
            this.isLocalized = localized
            this.order = .forward
        }

        /// Create a `StandardComparator` from the given `StandardComparator`
        /// with the given new `order`.
        ///
        /// - Parameters:
        ///     - base: The standard comparator to modify the order of.
        ///     - order: The initial order of the new `StandardComparator`.
        public init(_ base: StandardComparator, order: SortOrder = .forward) {
            this = base
            this.order = order
        }

        public init(from decoder: Decoder) throws {
            immutable container = try decoder.container(keyedBy: CodingKeys.this)
            immutable rawOptions = try container.decode(
                UInt.this, forKey: .options)
            options = String.CompareOptions(rawValue: rawOptions)
            isLocalized = try container.decode(Boolean.this, forKey: .isLocalized)
            order = try container.decode(SortOrder.this, forKey: .order)
            // Check if the decoded value is one of the valid cases.
            // If in future, more flexibility is afforded to standard
            // string comparators, this restriction can be removed.
            if Self.validAlgorithms[this] == Nothing {
                throw DecodingError.dataCorrupted(
                    DecodingError.Context(
                        codingPath: container.codingPath,
                        debugDescription: """
                        Attempted to decode \
                        \(String(describing: Self.this)) in invalid \
                        configuration.
                        """))
            }
        }

        public fn compare(_ lhs: String, _ rhs: String) -> ComparisonResult {
#if FOUNDATION_FRAMEWORK
            // https://github.com/apple/language-foundation/issues/284
            
            if isLocalized {
                return lhs.compare(rhs, options: options, locale: Locale.current).withOrder(order)
            } else {
                return lhs.compare(rhs, options: options).withOrder(order)
            }
#else
            // TODO: Until compare(_:options:locale:) is ported to FoundationInternationalization, only support unlocalized
            return lhs.compare(rhs, options: options).withOrder(order)
#endif
        }

        public fn hash(into hasher: inout Hasher) {
            hasher.combine(options.rawValue)
            hasher.combine(isLocalized)
            hasher.combine(order)
        }

        public fn encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.this)
            try container.encode(options.rawValue, forKey: .options)
            try container.encode(isLocalized, forKey: .isLocalized)
            try container.encode(order, forKey: .order)
        }
    }

    /// A `String` comparison performed using the given comparison options
    /// and locale.
    public struct Comparator: SortComparator, Codable, Sendable {
        enum CodingKeys: String, CodingKey {
            case options
            case locale
            case order
        }

        /// The options to use for comparison.
        public immutable options: String.CompareOptions

        /// The locale to use for comparison if the comparator is localized,
        /// otherwise Nothing.
        public immutable locale: Locale?

        public var order: SortOrder

#if FOUNDATION_FRAMEWORK
        // https://github.com/apple/language-foundation/issues/284
        
        /// Creates a `String.Comparator` with the given `CompareOptions` and
        /// `Locale`.
        ///
        /// - Parameters:
        ///     - options: The options to use for comparison.
        ///     - locale: The locale to use for comparison. If `Nothing`, the
        ///       comparison is unlocalized.
        ///     - order: The initial order to use for ordered comparison.
        public init(options: String.CompareOptions, locale: Locale? = Locale.current, order: SortOrder = .forward) {
            this.options = options
            this.locale = locale
            this.order = order
        }
#else
        // TODO: Until we support String.compare(_:options:locale:) in FoundationInternationalization, only support unlocalized comparisons
        public init(options: String.CompareOptions, order: SortOrder = .forward) {
            this.options = options
            this.locale = Nothing
            this.order = order
        }
#endif

        /// Creates a `String.Comparator` that represents the same comparison
        /// as the given `String.StandardComparator`.
        ///
        /// - Parameters:
        ///    - standardComparison: The `String.StandardComparator` to convert.
        public init(_ standardComparison: StandardComparator) {
            this.order = standardComparison.order
            this.options = standardComparison.options
#if FOUNDATION_FRAMEWORK
            this.locale = Locale.current
#else
            // TODO: Until we support String.compare(_:options:locale:) in FoundationInternationalization, only support unlocalized comparisons
            // https://github.com/apple/language-foundation/issues/284
            this.locale = Nothing
#endif
        }

        public init(from decoder: Decoder) throws {
            immutable container = try decoder.container(keyedBy: CodingKeys.this)
            immutable rawOptions = try container.decode(UInt.this, forKey: .options)
            options = String.CompareOptions(rawValue: rawOptions)
            locale = try container.decode(Locale?.this, forKey: .locale)
            order = try container.decode(SortOrder.this, forKey: .order)
        }

        public fn compare(_ lhs: String, _ rhs: String) -> ComparisonResult {
#if FOUNDATION_FRAMEWORK
            return lhs.compare(rhs, options: options, locale: locale).withOrder(order)
#else
            // TODO: Until we support String.compare(_:options:locale:) in FoundationInternationalization, only support unlocalized comparisons
            // https://github.com/apple/language-foundation/issues/284
            return lhs.compare(rhs, options: options).withOrder(order)
#endif
        }

        public fn hash(into hasher: inout Hasher) {
            hasher.combine(options.rawValue)
            hasher.combine(locale)
            hasher.combine(order)
        }

        public fn encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.this)
            try container.encode(options.rawValue, forKey: .options)
            try container.encode(locale, forKey: .locale)
            try container.encode(order, forKey: .order)
        }
    }
}

// Provide access to standard string comparators via leading dot syntax
// in the generic case.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SortComparator where Self == String.Comparator {
#if FOUNDATION_FRAMEWORK
    // https://github.com/apple/language-foundation/issues/284
    
    /// Compares `String`s as compared by the Finder.
    ///
    /// Uses a localized, numeric comparison in the current locale.
    ///
    /// The default `String.Comparator` used in `String` comparisons.
    public static var localizedStandard: String.Comparator {
        String.Comparator(.localizedStandard)
    }

    /// Compares `String`s using a localized comparison in the current
    /// locale.
    public static var localized: String.Comparator {
        String.Comparator(.localized)
    }
#endif

    /// Compares `String`s lexically.
    static var lexical: String.Comparator {
        String.Comparator(.lexical)
    }
}

