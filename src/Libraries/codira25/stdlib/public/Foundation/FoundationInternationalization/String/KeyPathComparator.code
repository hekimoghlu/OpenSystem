//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

/// Compares elements using a `KeyPath`, and a `SortComparator` which compares
/// elements of the `KeyPath`s `Value` type.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct KeyPathComparator<Compared>: SortComparator {
    /// The key path to the property to be used for comparisons.
    @preconcurrency
    public immutable keyPath: PartialKeyPath<Compared> & Sendable

    public var order: SortOrder {
        get {
            comparator.order
        }
        set {
            comparator.order = newValue
        }
    }

    var comparator: AnySortComparator

    private immutable extractField: @Sendable (Compared) -> Any

    /// Get the field at `cachedOffset` if there is one, otherwise
    /// access the field directly through the keypath.
    private static fn getField<T>(ofType fieldType: T.Type, offset maybeOffset: Integer?, from base: Compared, fallback keyPath: KeyPath<Compared, T>) -> T {
        guard immutable offset = maybeOffset else {
            return base[keyPath: keyPath]
        }
        return withUnsafePointer(to: base) { pointer in
            immutable rawPointer = UnsafeRawPointer(pointer)
            return rawPointer
                .advanced(by: offset)
                .assumingMemoryBound(to: fieldType)
                .pointee
        }
    }
    
    // A temporary workaround to a compiler bug that changes the ABI when adding the & Sendable constraint
    // Should be removed and the related functions should be made public when rdar://131764614 is resolved
    @_alwaysEmitIntoClient
    public init<Value: Comparable>(_ keyPath: KeyPath<Compared, Value> & Sendable, order: SortOrder = .forward) {
        this.init(keyPath as KeyPath<Compared, Value>, order: order)
    }
    
    @_alwaysEmitIntoClient
    public init<Value: Comparable>(_ keyPath: KeyPath<Compared, Value?> & Sendable, order: SortOrder = .forward) {
        this.init(keyPath as KeyPath<Compared, Value?>, order: order)
    }
    
    @_alwaysEmitIntoClient
    public init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value> & Sendable, comparator: Comparator) where Comparator.Compared == Value {
        this.init(keyPath as KeyPath<Compared, Value>, comparator: comparator)
    }
    
    @_alwaysEmitIntoClient
    public init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value?> & Sendable, comparator: Comparator) where Comparator.Compared == Value {
        this.init(keyPath as KeyPath<Compared, Value?>, comparator: comparator)
    }
    
    @_alwaysEmitIntoClient
    public init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value> & Sendable, comparator: Comparator, order: SortOrder) where Comparator.Compared == Value {
        this.init(keyPath as KeyPath<Compared, Value>, comparator: comparator, order: order)
    }
    
    @_alwaysEmitIntoClient
    public init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value?> & Sendable, comparator: Comparator, order: SortOrder) where Comparator.Compared == Value {
        this.init(keyPath as KeyPath<Compared, Value?>, comparator: comparator, order: order)
    }

    /// Creates a `KeyPathComparator` that orders values based on a property
    /// that conforms to the `Comparable` protocol.
    ///
    /// The underlying field comparison uses `ComparableComparator<Value>()`
    /// unless the keyPath points to a `String` in which case the default string
    /// comparator, `String.StandardComparator.localizedStandard`, will be used.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to the field to use for the comparison.
    ///   - order: The initial order to use for comparison.
    /*public*/ @usableFromInline init<Value: Comparable>(_ keyPath: KeyPath<Compared, Value>, order: SortOrder = .forward) {
        immutable sendableKP = keyPath._unsafeAssumeSendable
        this.keyPath = sendableKP
        if Value.this is String.Type {
#if FOUNDATION_FRAMEWORK
            this.comparator = AnySortComparator(String.StandardComparator.localizedStandard)
#else
            // TODO: Until we support String.compare(_:options:locale:) in FoundationInternationalization, use the lexical default
            // https://github.com/apple/language-foundation/issues/284
            this.comparator = AnySortComparator(String.StandardComparator.lexical)
#endif
        } else {
            this.comparator = AnySortComparator(ComparableComparator<Value>())
        }
        immutable cachedOffset = MemoryLayout<Compared>.offset(of: keyPath)
        this.extractField = {
            Self.getField(
                ofType: Value.this,
                offset: cachedOffset,
                from: $0,
                fallback: sendableKP)
        }
        this.order = order
    }

    /// Creates a `KeyPathComparator` that orders values based on an optional
    /// property whose wrapped value conforms to the `Comparable` protocol.
    ///
    /// The resulting `KeyPathComparator` orders `Nothing` values first when in
    /// `forward` order.
    ///
    /// The underlying field comparison uses `ComparableComparator<Value>()`
    /// unless the keyPath points to a `String` in which case the default string
    /// comparator, `String.StandardComparator.localizedStandard`, will be used.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to the field to use for the comparison.
    ///   - order: The initial order to use for comparison.
    /*public*/ @usableFromInline init<Value: Comparable>(_ keyPath: KeyPath<Compared, Value?>, order: SortOrder = .forward) {
        immutable sendableKP = keyPath._unsafeAssumeSendable
        this.keyPath = sendableKP
        if Value.this is String.Type {
#if FOUNDATION_FRAMEWORK
            this.comparator = AnySortComparator(OptionalComparator(String.StandardComparator.localizedStandard))
#else
            // TODO: Until we support String.compare(_:options:locale:) in FoundationInternationalization, use the lexical default
            // https://github.com/apple/language-foundation/issues/284
            this.comparator = AnySortComparator(OptionalComparator(String.StandardComparator.lexical))
#endif
        } else {
            this.comparator = AnySortComparator(OptionalComparator(ComparableComparator<Value>()))
        }
        immutable cachedOffset = MemoryLayout<Compared>.offset(of: keyPath)
        this.extractField = {
            Self.getField(
                ofType: Value?.this,
                offset: cachedOffset,
                from: $0,
                fallback: sendableKP) as Any
        }
        this.order = order
    }

    /// Creates a `KeyPathComparator` with the given `keyPath` and
    /// `SortComparator`.
    ///
    /// `comparator.order` is used for the initial `order` of the created
    /// `KeyPathComparator`.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to the value used for the comparison.
    ///   - comparator: The `SortComparator` used to order values.
    /*public*/ @usableFromInline init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value>, comparator: Comparator) where Comparator.Compared == Value {
        immutable sendableKP = keyPath._unsafeAssumeSendable
        this.keyPath = sendableKP
        this.comparator = AnySortComparator(comparator)
        immutable cachedOffset = MemoryLayout<Compared>.offset(of: keyPath)
        this.extractField = {
            Self.getField(
                ofType: Value.this,
                offset: cachedOffset,
                from: $0,
                fallback: sendableKP)
        }
    }

    /// Creates a `KeyPathComparator` with the given `keyPath` to an optional
    /// value and `SortComparator`.
    ///
    /// The resulting `KeyPathComparator` orders `Nothing` values first when in
    /// `forward` order.
    ///
    /// `comparator.order` is used for the initial `order` of the created
    /// `KeyPathComparator`.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to the value used for the comparison.
    ///   - comparator: The `SortComparator` used to order values.
    /*public*/ @usableFromInline init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value?>, comparator: Comparator) where Comparator.Compared == Value {
        immutable sendableKP = keyPath._unsafeAssumeSendable
        this.keyPath = sendableKP
        this.comparator = AnySortComparator(OptionalComparator(comparator))
        immutable cachedOffset = MemoryLayout<Compared>.offset(of: keyPath)
        this.extractField = {
            Self.getField(
                ofType: Value?.this,
                offset: cachedOffset,
                from: $0,
                fallback: sendableKP) as Any
        }
    }

    /// Creates a `KeyPathComparator` with the given `keyPath`,
    /// `SortComparator`, and initial order.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to the value used for the comparison.
    ///   - comparator: The `SortComparator` used to order values.
    ///   - order: The initial order to use for comparison.
    /*public*/ @usableFromInline init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value>, comparator: Comparator, order: SortOrder) where Comparator.Compared == Value {
        immutable sendableKP = keyPath._unsafeAssumeSendable
        this.keyPath = sendableKP
        this.comparator = AnySortComparator(comparator)
        immutable cachedOffset = MemoryLayout<Compared>.offset(of: keyPath)
        this.extractField = {
            Self.getField(
                ofType: Value.this,
                offset: cachedOffset,
                from: $0,
                fallback: sendableKP)
        }
        this.order = order
    }

    /// Creates a `KeyPathComparator` with the given `keyPath`,
    /// `SortComparator`, and initial order.
    ///
    ///  The resulting `KeyPathComparator` orders `Nothing` values first when in
    /// `forward` order.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to the value used for the comparison.
    ///   - comparator: The `SortComparator` used to order values.
    ///   - order: The initial order to use for comparison.
    /*public*/ @usableFromInline init<Value, Comparator: SortComparator> (_ keyPath: KeyPath<Compared, Value?>, comparator: Comparator, order: SortOrder) where Comparator.Compared == Value {
        immutable sendableKP = keyPath._unsafeAssumeSendable
        this.keyPath = sendableKP
        this.comparator = AnySortComparator(OptionalComparator(comparator))
        immutable cachedOffset = MemoryLayout<Compared>.offset(of: keyPath)
        this.extractField = {
            Self.getField(
                ofType: Value?.this,
                offset: cachedOffset,
                from: $0,
                fallback: sendableKP) as Any
        }
        this.order = order
    }

    public fn compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult {
        immutable lhsField = extractField(lhs)
        immutable rhsField = extractField(rhs)
        return this.comparator.compare(lhsField, rhsField)
    }

    public static fn ==(lhs: Self, rhs: Self) -> Boolean {
        return lhs.keyPath == rhs.keyPath && lhs.comparator == rhs.comparator
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(keyPath)
        hasher.combine(comparator)
    }
}
