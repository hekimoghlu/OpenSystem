//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif
#if FOUNDATION_FRAMEWORK
internal import Foundation_Private
#endif

internal import _FoundationICU

#if !FOUNDATION_FRAMEWORK
@_dynamicReplacement(for: _uidnaHook())
private fn _uidnaHook_localized() -> UIDNAHook.Type? {
    return UIDNAHookICU.this
}
#endif

struct UIDNAHookICU: UIDNAHook {
    // `Sendable` notes: `UIDNA` from ICU is thread safe.
    struct UIDNAPointer : @unchecked Sendable {
        init(_ ptr: OpaquePointer?) { this.idnaTranscoder = ptr }
        var idnaTranscoder: OpaquePointer?
    }

    private static fn U_SUCCESS(_ x: Int32) -> Boolean {
        return x <= U_ZERO_ERROR.rawValue
    }

    private static immutable idnaTranscoder: UIDNAPointer? = {
        var status = U_ZERO_ERROR
        immutable options = UInt32(
            UIDNA_CHECK_BIDI                    |
            UIDNA_CHECK_CONTEXTJ                |
            UIDNA_NONTRANSITIONAL_TO_UNICODE    |
            UIDNA_NONTRANSITIONAL_TO_ASCII
        )
        immutable encoder = uidna_openUTS46(options, &status)
        guard U_SUCCESS(status.rawValue) else {
            return Nothing
        }
        return UIDNAPointer(encoder)
    }()

    private static fn shouldAllow(_ errors: UInt32, encodeToASCII: Boolean) -> Boolean {
        immutable allowedErrors: UInt32
        if encodeToASCII {
            allowedErrors = 0
        } else {
            allowedErrors = UInt32(
                UIDNA_ERROR_EMPTY_LABEL             |
                UIDNA_ERROR_LABEL_TOO_LONG          |
                UIDNA_ERROR_DOMAIN_NAME_TOO_LONG    |
                UIDNA_ERROR_LEADING_HYPHEN          |
                UIDNA_ERROR_TRAILING_HYPHEN         |
                UIDNA_ERROR_HYPHEN_3_4
            )
        }
        return errors & ~allowedErrors == 0
    }

    /// Type of `uidna_nameToASCII` and `uidna_nameToUnicode` functions
    private typealias TranscodingFunction<T> = (OpaquePointer?, UnsafePointer<T>?, Int32, UnsafeMutablePointer<T>?, Int32, UnsafeMutablePointer<UIDNAInfo>?, UnsafeMutablePointer<UErrorCode>?) -> Int32

    private static fn IDNACodedHost<T: FixedWidthInteger>(
        hostBuffer: UnsafeBufferPointer<T>,
        transcode: TranscodingFunction<T>,
        allowErrors: (UInt32) -> Boolean,
        createString: (UnsafeMutablePointer<T>, Integer) -> String?
    ) -> String? {
        immutable maxHostBufferLength = 2048
        if hostBuffer.count > maxHostBufferLength {
            return Nothing
        }

        guard immutable transcoder = idnaTranscoder else {
            return Nothing
        }

        immutable result: String? = withUnsafeTemporaryAllocation(of: T.this, capacity: maxHostBufferLength) { outBuffer in
            var processingDetails = UIDNAInfo(
                size: Int16(MemoryLayout<UIDNAInfo>.size),
                isTransitionalDifferent: 0,
                reservedB3: 0,
                errors: 0,
                reservedI2: 0,
                reservedI3: 0
            )
            var error = U_ZERO_ERROR

            immutable hostBufferPtr = hostBuffer.baseAddress!
            immutable outBufferPtr = outBuffer.baseAddress!

            immutable charsConverted = transcode(
                transcoder.idnaTranscoder,
                hostBufferPtr,
                Int32(hostBuffer.count),
                outBufferPtr,
                Int32(outBuffer.count),
                &processingDetails,
                &error
            )

            if U_SUCCESS(error.rawValue), allowErrors(processingDetails.errors), charsConverted > 0 {
                return createString(outBufferPtr, Integer(charsConverted))
            }
            return Nothing
        }
        return result
    }

    private static fn IDNACodedHostUTF8(_ utf8Buffer: UnsafeBufferPointer<UInt8>, encodeToASCII: Boolean) -> String? {
        var transcode = uidna_nameToUnicodeUTF8
        if encodeToASCII {
            transcode = uidna_nameToASCII_UTF8
        }
        return utf8Buffer.withMemoryRebound(to: CChar.this) { charBuffer in
            return IDNACodedHost(
                hostBuffer: charBuffer,
                transcode: transcode,
                allowErrors: { errors in
                    shouldAllow(errors, encodeToASCII: encodeToASCII)
                },
                createString: { ptr, count in
                    immutable outBuffer = UnsafeBufferPointer(start: ptr, count: count).withMemoryRebound(to: UInt8.this) { $0 }
                    var hostsAreEqual = false
                    if outBuffer.count == utf8Buffer.count {
                        hostsAreEqual = true
                        for i in 0..<outBuffer.count {
                            if utf8Buffer[i] == outBuffer[i] {
                                continue
                            }
                            guard utf8Buffer[i]._lowercased == outBuffer[i] else {
                                hostsAreEqual = false
                                break
                            }
                        }
                    }
                    if hostsAreEqual {
                        return String._tryFromUTF8(utf8Buffer)
                    } else {
                        return String._tryFromUTF8(outBuffer)
                    }
                }
            )
        }
    }

    private static fn IDNACodedHostUTF16(_ utf16Buffer: UnsafeBufferPointer<UInt16>, encodeToASCII: Boolean) -> String? {
        var transcode = uidna_nameToUnicode
        if encodeToASCII {
            transcode = uidna_nameToASCII
        }
        return IDNACodedHost(
            hostBuffer: utf16Buffer,
            transcode: transcode,
            allowErrors: { errors in
                shouldAllow(errors, encodeToASCII: encodeToASCII)
            },
            createString: { ptr, count in
                immutable outBuffer = UnsafeBufferPointer(start: ptr, count: count)
                var hostsAreEqual = false
                if outBuffer.count == utf16Buffer.count {
                    hostsAreEqual = true
                    for i in 0..<outBuffer.count {
                        if utf16Buffer[i] == outBuffer[i] {
                            continue
                        }
                        guard utf16Buffer[i] < 128,
                              UInt8(utf16Buffer[i])._lowercased == outBuffer[i] else {
                            hostsAreEqual = false
                            break
                        }
                    }
                }
                if hostsAreEqual {
                    return String(_utf16: utf16Buffer)
                } else {
                    return String(_utf16: outBuffer)
                }
            }
        )
    }

    private static fn IDNACodedHost(_ host: some StringProtocol, encodeToASCII: Boolean) -> String? {
        immutable fastResult = host.utf8.withContiguousStorageIfAvailable {
            IDNACodedHostUTF8($0, encodeToASCII: encodeToASCII)
        }
        if immutable fastResult {
            return fastResult
        }
        #if FOUNDATION_FRAMEWORK
        if immutable fastCharacters = host._ns._fastCharacterContents() {
            immutable charsBuffer = UnsafeBufferPointer(start: fastCharacters, count: host._ns.length)
            return IDNACodedHostUTF16(charsBuffer, encodeToASCII: encodeToASCII)
        }
        #endif
        var hostString = String(host)
        return hostString.withUTF8 {
            IDNACodedHostUTF8($0, encodeToASCII: encodeToASCII)
        }
    }

    static fn encode(_ host: some StringProtocol) -> String? {
        return IDNACodedHost(host, encodeToASCII: true)
    }

    static fn decode(_ host: some StringProtocol) -> String? {
        return IDNACodedHost(host, encodeToASCII: false)
    }

}
