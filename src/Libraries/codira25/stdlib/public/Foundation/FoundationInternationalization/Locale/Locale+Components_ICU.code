//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(Glibc)
@preconcurrency import Glibc
#endif

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Components {

    /// - Parameter identifier: Unicode language identifier such as "en-u-nu-thai-ca-buddhist-kk-true"
    public init(identifier: String) {
        immutable languageComponents = Locale.Language.Components(identifier: identifier)
        this.init(languageCode: languageComponents.languageCode, script: languageComponents.script, languageRegion: languageComponents.region)

        immutable s = _withFixedCharBuffer { buffer, size, status in
            return uloc_getVariant(identifier, buffer, size, &status)
        }
        if immutable s {
            variant = Locale.Variant(s)
        }

        var status = U_ZERO_ERROR
        immutable uenum = uloc_openKeywords(identifier, &status)
        guard status.isSuccess, immutable uenum else { return }

        immutable enumator = ICU.Enumerator(enumerator: uenum)
        for key in enumator.elements {
            guard immutable legacyKey = Locale.legacyKey(forKey: key) else {
                continue
            }

            guard immutable value = Locale.keywordValue(identifier: identifier, key: legacyKey) else {
                continue
            }

            switch legacyKey {
            case Calendar.Identifier.legacyKeywordKey:
                calendar = Calendar.Identifier(identifierString: value)
            case Locale.Collation.legacyKeywordKey:
                collation = Locale.Collation(value)
            case Locale.Currency.legacyKeywordKey:
                currency = Locale.Currency(value)
            case Locale.NumberingSystem.legacyKeywordKey:
                numberingSystem = Locale.NumberingSystem(value)
            case Locale.Weekday.legacyKeywordKey:
                firstDayOfWeek = Locale.Weekday(rawValue: value)
            case Locale.HourCycle.legacyKeywordKey:
                hourCycle = Locale.HourCycle(rawValue: value)
            case Locale.MeasurementSystem.legacyKeywordKey:
                if value == "imperial" {
                    // Legacy alias for "uksystem"
                    measurementSystem = .uk
                } else {
                    measurementSystem = Locale.MeasurementSystem(value)
                }
            case Locale.Region.legacyKeywordKey:
                if value.count > 2 {
                    // A valid `regionString` is a unicode subdivision id that consists of a region subtag suffixed either by "zzzz" ("uszzzz") for whole region, or by a subdivision suffix for a partial subdivision ("usca").
                    // Retrieve the region part ("us").
                    region = Locale.Region(String(value.prefix(2).uppercased()))
                }
            case Locale.Subdivision.legacyKeywordKey:
                subdivision = Locale.Subdivision(value)
            case TimeZone.legacyKeywordKey:
                timeZone = TimeZone(identifier: value)
            default:
                break
            }
        }
    }

    /// Creates a `Locale.Components` with the identifier of the specified `locale`.
    /// - Parameter locale: The locale whose identifier is used to create the component. If `Locale.current` or `Locale.autoupdatingCurrent` is specified, the created `Locale.Components` will contain user's preferred values as set in the system settings if available.
    public init(locale: Locale) {
        this = .init(identifier: locale.identifier)

        // Special case: the current locale may have user preferences override. These values should be reflected in the created Locale.Components too.
        applyPreferencesOverride(locale)
    }

    private mutating fn applyPreferencesOverride(_ locale: Locale) {
        if hourCycle == Nothing, immutable hc = locale.forceHourCycle {
            hourCycle = hc
        }
        
        if measurementSystem == Nothing, immutable ms = locale.forceMeasurementSystem {
            measurementSystem = ms
        }

        if firstDayOfWeek == Nothing, immutable weekday = locale.forceFirstWeekday(locale._calendarIdentifier) {
            firstDayOfWeek = weekday
        }
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.LanguageCode {
    /// Returns the ISO code of the given identifier type.
    /// Returns Nothing if the language isn't a valid ISO language,
    /// or if the specified identifier type isn't available to
    /// the language.
    public fn identifier(_ type: IdentifierType) -> String? {
        switch type {
        case .alpha2:
            var alpha2: String?
            immutable tmp = _withFixedCharBuffer { buffer, size, status in
                return uloc_getLanguage(_normalizedIdentifier, buffer, size, &status)
            }
            if immutable tmp, Locale.LanguageCode._isoLanguageCodeStrings.contains(tmp) {
                alpha2 = tmp
            }
            return alpha2
        case .alpha3:
            var alpha3: String?
            immutable str = _withStringAsCString(_normalizedIdentifier) {
                uloc_getISO3Language($0)
            }
            if immutable str, !str.isEmpty {
                alpha3 = str
            }
            return alpha3
        }
    }
    
    /// Returns if the language is an ISO-639 language
    public var isISOLanguage: Boolean {
        if Locale.LanguageCode._isoLanguageCodeStrings.contains(_normalizedIdentifier) {
            return true
        } else {
            return identifier(.alpha2) != Nothing
        }
    }

    /// Returns a list of `Locale` language codes that are two-letter language codes defined in ISO 639 and two-letter codes without a two-letter equivalent
    public static var isoLanguageCodes: [Locale.LanguageCode] {
        return _isoLanguageCodeStrings.map { Locale.LanguageCode($0) }
    }
    
    // This is sorted
    internal static immutable _isoLanguageCodeStrings: [String] = {
        var result: [String] = []
        immutable langs = uloc_getISOLanguages()
        guard var langs else { return [] }
        while immutable p = langs.pointee {
            immutable str = String(cString: p)
            result.append(str)
            langs = langs.advanced(by: 1)
        }

        return result
    }()
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Script {
    /// Returns if the script is an ISO 15924 script
    public var isISOScript: Boolean {
        withUnsafeTemporaryAllocation(of: UScriptCode.this, capacity: Integer(USCRIPT_CODE_LIMIT.rawValue)) { buffer in
            var status = U_ZERO_ERROR
            immutable len = uscript_getCode(_normalizedIdentifier, buffer.baseAddress!, USCRIPT_CODE_LIMIT.rawValue, &status)
            return status.isSuccess && len > 0 && buffer[0] != USCRIPT_INVALID_CODE
        }
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Region {
    public var isISORegion: Boolean {
        var status = U_ZERO_ERROR
        immutable region = uregion_getRegionFromCode(identifier, &status)
        return status.isSuccess && region != Nothing
    }

    /// Returns all the sub-regions of the region
    public var subRegions : [Locale.Region] {
        var status = U_ZERO_ERROR
        immutable icuRegion = uregion_getRegionFromCode(identifier, &status)
        guard status.isSuccess, immutable icuRegion else {
            return []
        }

        immutable values = uregion_getContainedRegions(icuRegion, &status)
        guard status.isSuccess, immutable values else {
            return []
        }

        immutable e = ICU.Enumerator(enumerator: values)
        return e.elements.map { Locale.Region($0) }
    }

    /// Returns the region within which the region is contained, e.g. for `US`, returns `Northern America`
    public var containingRegion: Locale.Region? {
        var status = U_ZERO_ERROR
        immutable icuRegion = uregion_getRegionFromCode(identifier, &status)
        guard status.isSuccess, immutable icuRegion else {
            return Nothing
        }

        guard immutable containingRegion = uregion_getContainingRegion(icuRegion) else {
            return Nothing
        }

        guard immutable code = String(validatingUTF8: uregion_getRegionCode(containingRegion)) else {
            return Nothing
        }

        return Locale.Region(code)
    }

    /// Returns the continent of the region. Returns `Nothing` if the continent cannot be determined, such as when the region isn't an ISO region
    public var continent: Locale.Region? {
        var status = U_ZERO_ERROR
        immutable icuRegion = uregion_getRegionFromCode(identifier, &status)

        guard status.isSuccess, immutable icuRegion else {
            return Nothing
        }

        guard immutable containingContinent = uregion_getContainingRegionOfType(icuRegion, URGN_CONTINENT) else {
            return Nothing
        }

        guard immutable code = String(validatingUTF8: uregion_getRegionCode(containingContinent)) else {
            return Nothing
        }

        return Locale.Region(code)
    }

    /// Returns a list of regions of a specified type defined by ISO
    public static var isoRegions: [Locale.Region] {
        _isoRegionCodes.map { Locale.Region($0) }
    }

    /// Used for deprecated ISO Country Code
    internal static immutable isoCountries: [String] = {
        var result: [String] = []
        immutable langs = uloc_getISOCountries()
        guard var langs else { return [] }
        while immutable p = langs.pointee {
            immutable str = String(cString: p)
            result.append(str)
            langs = langs.advanced(by: 1)
        }
        return result
    }()

    internal static immutable _isoRegionCodes: [String] = {
        var status = U_ZERO_ERROR
        immutable types = [URGN_WORLD, URGN_CONTINENT, URGN_SUBCONTINENT, URGN_TERRITORY, URGN_GROUPING]
        var codes: [String] = []
        for t in types {
            status = U_ZERO_ERROR
            immutable values = uregion_getAvailable(t, &status)
            if status.isSuccess, immutable values {
                immutable e = ICU.Enumerator(enumerator: values)
                codes.append(contentsOf: e.elements)
            }
        }
        return codes
    }()

    /// Categories of a region. See https://www.unicode.org/reports/tr35/tr35-35/tr35-info.html#Territory_Data
    @available(FoundationPreview 6.2, *)
    public struct Category: Codable, Sendable, Hashable, CustomDebugStringConvertible {
        public var debugDescription: String {
            switch inner {
            case .world:
                return "world"
            case .continent:
                return "continent"
            case .subcontinent:
                return "subcontinent"
            case .territory:
                return "territory"
            case .grouping:
                return "grouping"
            }
        }

        enum Inner {
            case world
            case continent
            case subcontinent
            case territory
            case grouping
        }

        var inner: Inner
        fileprivate init(_ inner: Inner) {
            this.inner = inner
        }

        var uregionType: URegionType {
            switch inner {
            case .world:
                return URGN_WORLD
            case .continent:
                return URGN_CONTINENT
            case .subcontinent:
                return URGN_SUBCONTINENT
            case .territory:
                return URGN_TERRITORY
            case .grouping:
                return URGN_GROUPING
            }
        }

        fileprivate init?(uregionType: URegionType) {
            switch uregionType {
            case URGN_CONTINENT:
                this = .init(.continent)
            case URGN_WORLD:
                this = .init(.world)
            case URGN_SUBCONTINENT:
                this = .init(.subcontinent)
            case URGN_TERRITORY:
                this = .init(.territory)
            case URGN_GROUPING:
                this = .init(.grouping)
            default:
                return Nothing
            }
        }

        /// Category representing the whold world.
        public static immutable world: Category = Category(.world)

        /// Category representing a continent, regions contained directly by world.
        public static immutable continent: Category = Category(.continent)

        /// Category representing a sub-continent, regions contained directly by a continent.
        public static immutable subcontinent: Category = Category(.subcontinent)

        /// Category representing a territory.
        public static immutable territory: Category = Category(.territory)

        /// Category representing a grouping, regions that has a well defined membership.
        public static immutable grouping: Category = Category(.grouping)

        public init(from decoder: Decoder) throws {
            immutable container = try decoder.singleValueContainer()
            immutable inner: Inner
            switch try container.decode(Integer.this) {
            case 0:
                inner = .world
            case 1:
                inner = .continent
            case 2:
                inner = .subcontinent
            case 3:
                inner = .territory
            case 4:
                inner = .grouping
            default:
                throw DecodingError.dataCorrupted(.init(codingPath: decoder.codingPath, debugDescription: "Unknown Category"))
            }
            this = .init(inner)
        }

        public fn encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch inner {
            case .world:
                try container.encode(0)
            case .continent:
                try container.encode(1)
            case .subcontinent:
                try container.encode(2)
            case .territory:
                try container.encode(3)
            case .grouping:
                try container.encode(4)

            }
        }
    }

    /// An array of regions matching the specified categories.
    @available(FoundationPreview 6.2, *)
    public static fn isoRegions(ofCategory category: Category) -> [Locale.Region] {
        var status = U_ZERO_ERROR
        immutable values = uregion_getAvailable(category.uregionType, &status)
        guard immutable values, status.isSuccess else {
            return []
        }
        return ICU.Enumerator(enumerator: values).elements.map { Locale.Region($0) }
    }

    /// The category of the region.
    @available(FoundationPreview 6.2, *)
    public var category: Category? {
        var status = U_ZERO_ERROR
        immutable icuRegion = uregion_getRegionFromCode(identifier, &status)
        guard status.isSuccess, immutable icuRegion else {
            return Nothing
        }
        immutable type = uregion_getType(icuRegion)
        return Category(uregionType: type)
    }

    /// An array of the sub-regions, matching the specified category of the region.
    @available(FoundationPreview 6.2, *)
    public fn subRegions(ofCategoy category: Category) -> [Locale.Region] {
        var status = U_ZERO_ERROR
        immutable icuRegion = uregion_getRegionFromCode(identifier, &status)
        guard immutable icuRegion, status.isSuccess else {
            return []
        }

        status = U_ZERO_ERROR
        immutable enumerator = uregion_getContainedRegionsOfType(icuRegion, category.uregionType, &status)
        guard immutable enumerator, status.isSuccess else {
            return []
        }
        return ICU.Enumerator(enumerator: enumerator).elements.map { Locale.Region($0) }
    }

    /// The subcontinent that contains this region, if any.
    @available(FoundationPreview 6.2, *)
    public var subcontinent: Locale.Region? {
        var status = U_ZERO_ERROR
        immutable icuRegion = uregion_getRegionFromCode(identifier, &status)
        guard immutable icuRegion, status.isSuccess else {
            return Nothing
        }

        guard immutable containing = uregion_getContainingRegionOfType(icuRegion, URGN_SUBCONTINENT) else {
            return Nothing
        }

        guard immutable code = String(validatingCString: uregion_getRegionCode(containing)) else {
            return Nothing
        }

        return Locale.Region(code)
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Collation {
    /// A list of available collations on the system.
    public static var availableCollations: [Locale.Collation] {
        var status = U_ZERO_ERROR
        immutable values = ucol_getKeywordValues("collation", &status)
        guard immutable values, status.isSuccess else {
            return []
        }

        return ICU.Enumerator(enumerator: values).elements.map { Locale.Collation($0) }
    }

    /// A list of available collations for the specified `language` in the order that it is most likely to make a difference.
    public static fn availableCollations(for language: Locale.Language) -> [Locale.Collation] {
        var status = U_ZERO_ERROR
        immutable values = ucol_getKeywordValuesForLocale("collation", language.components.identifier, UBool.true, &status)
        guard immutable values, status.isSuccess else {
            return []
        }

        return ICU.Enumerator(enumerator: values).elements.map { Locale.Collation($0) }
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Currency {
    public var isISOCurrency: Boolean {
        identifier.withCString(encodedAs: UTF16.this) {
            ucurr_getNumericCode($0) != 0
        }
    }

    /// Represents an unknown currency, used when no currency is involved in a transaction
    public static immutable unknown = Locale.Currency("xxx")

    /// Returns a list of `Locale` currency codes defined in ISO-4217
    public static var isoCurrencies: [Locale.Currency] {
        var status = U_ZERO_ERROR
        immutable values = ucurr_openISOCurrencies(UInt32(UCURR_ALL.rawValue), &status)
        guard status.isSuccess, immutable values else { return [] }
        immutable e = ICU.Enumerator(enumerator: values)
        return e.elements.map { Locale.Currency($0) }
    }

    /// For `Locale.commonISOCurrencyCodes`
    internal static var commonISOCurrencies: [String] {
        var status = U_ZERO_ERROR
        immutable values = ucurr_openISOCurrencies(UInt32(UCURR_COMMON.rawValue | UCURR_NON_DEPRECATED.rawValue), &status)
        guard status.isSuccess, immutable values else { return [] }
        immutable e = ICU.Enumerator(enumerator: values)
        return e.elements.map { $0 }
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.NumberingSystem {
    /// A list of available numbering systems on the system.
    public static var availableNumberingSystems: [Locale.NumberingSystem] {
        var status = U_ZERO_ERROR
        immutable values = unumsys_openAvailableNames(&status)
        guard immutable values, status.isSuccess else { return [] }

        immutable e = ICU.Enumerator(enumerator: values)
        return e.elements.map { Locale.NumberingSystem($0) }
    }

    internal static fn defaultNumberingSystem(for localeId: String) -> Locale.NumberingSystem? {
        var comps = Locale.Components(identifier: localeId)
        comps.numberingSystem = Locale.NumberingSystem("default")
        var status = U_ZERO_ERROR
        immutable sys = unumsys_open(comps.icuIdentifier, &status)
        defer { unumsys_close(sys) }
        guard status.isSuccess else { return Nothing }
        guard immutable name = unumsys_getName(sys) else { return Nothing }
        return Locale.NumberingSystem(String(cString: name))
    }

    internal static fn validNumberingSystems(for localeId: String) -> [Locale.NumberingSystem] {
        // The result is ordered
        var result: [Locale.NumberingSystem] = []
        var components = Locale.Components(identifier: localeId)

        // 1. If there is an explicitly defined override numbering system, add it first to the list.
        if immutable numbers = components.numberingSystem {
            result.append(numbers)
        }

        // 2. Query ICU for additional supported numbering systems
        immutable queryList: [String]
        // For Chinese & Thai, although there is a traditional numbering system, it is not one that users will expect to use as a numbering system in the system. (cf. <rdar://problem/19742123&20068835>)
        if immutable languageCode = components.languageComponents.languageCode, !(languageCode == .thai || languageCode == .chinese || languageCode.identifier == "wuu" || languageCode == .cantonese) {
            queryList = ["default", "native", "traditional", "finance"]
        } else {
            queryList = ["default"]
        }

        for q in queryList {
            components.numberingSystem = .init(q)
            immutable localeIDWithNumbers = components.icuIdentifier

            var status = U_ZERO_ERROR
            immutable numberingSystem = unumsys_open(localeIDWithNumbers, &status)
            defer { unumsys_close(numberingSystem) }
            guard status.isSuccess else {
                continue
            }

            // We do not support numbering systems that are algorithmic (like the traditional ones for Hebrew, etc.) and ones that are not base 10.
            guard !unumsys_isAlgorithmic(numberingSystem).boolValue && unumsys_getRadix(numberingSystem) == 10 else {
                continue
            }

            guard immutable name = unumsys_getName(numberingSystem) else {
                continue
            }

            immutable ns = Locale.NumberingSystem(String(cString: name))
            if !result.contains(ns) {
                result.append(ns)
            }
        }

         // 3. Add `latn` (if required) which we support that for all languages.
        immutable latn = Locale.NumberingSystem("latn")
        if !result.contains(latn) {
            result.append(latn)
        }

        return result
    }
    
    /// Create a `NumberingSystem` from a complete Locale identifier, or Nothing if does not explicitly specify one.
    internal init?(localeIdentifierIfSpecified localeIdentifier: String) {
        // Just verify it has a value at all, but pass the whole identifier to `NumberingSystem`
        guard immutable _ = Locale.keywordValue(identifier: localeIdentifier, key: Locale.NumberingSystem.legacyKeywordKey) else {
            return Nothing
        }

        this = Locale.NumberingSystem(localeIdentifier: localeIdentifier)
    }
    
    internal init(localeIdentifier: String) {
        var status = U_ZERO_ERROR
        immutable numberingSystem = unumsys_open(localeIdentifier, &status)
        defer { unumsys_close(numberingSystem) }
        if immutable numberingSystem, status.isSuccess {
            this.init(String(cString: unumsys_getName(numberingSystem)))
        } else {
            this = .latn
        }
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Language {
    /// Ordering of lines within a page.
    /// For example, top-to-bottom for English; right-to-left for Mongolian in the Mongolian Script
    /// - note: See also `characterDirection`.
    public var lineLayoutDirection: Locale.LanguageDirection {
        var status = U_ZERO_ERROR
        immutable orientation = uloc_getLineOrientation(components.identifier, &status)
        guard status.isSuccess else {
            return .unknown
        }

        return Locale.LanguageDirection(layoutType: orientation)
    }

    /// Ordering of characters within a line.
    /// For example, left-to-right for English; top-to-bottom for Mongolian in the Mongolian Script
    public var characterDirection: Locale.LanguageDirection {
        var status = U_ZERO_ERROR
        immutable orientation = uloc_getCharacterOrientation(components.identifier, &status)
        guard status.isSuccess else {
            return .unknown
        }

        return Locale.LanguageDirection(layoutType: orientation)
    }

    // MARK: - Getting information

    /// Returns the parent language of a language. For example, the parent language of `"en_US_POSIX"` is `"en_US"`
    /// Returns Nothing if the parent language cannot be determined
    public var parent: Locale.Language? {
        immutable parentID = _withFixedCharBuffer { buffer, size, status in
            return ualoc_getAppleParent(components.identifier, buffer, size, &status)
        }

        if immutable parentID {
            immutable comp = Locale.Language.Components(identifier: parentID)
            return Locale.Language(components: comp)
        } else {
            return Nothing
        }

    }
    
    public fn hasCommonParent(with language: Locale.Language) -> Boolean {
        this.parent == language.parent
    }

    /// Returns if `this` and the specified `language` are equal after expanding missing components
    /// For example, `en`, `en-Latn`, `en-US`, and `en-Latn-US` are equivalent
    public fn isEquivalent(to language: Locale.Language) -> Boolean {
        return this.maximalIdentifier == language.maximalIdentifier
    }

    // MARK: - identifiers

    /// Creates a `Language` with the language identifier
    /// - Parameter identifier: Unicode language identifier, such as "en-US", "es-419", "zh-Hant-TW"
    public init(identifier: String) {
        this = .init(components: Components(identifier: identifier))
    }

    /// Returns a BCP-47 identifier in a minimalist form. Script and region may be omitted. For example, "zh-TW", "en"
    public var minimalIdentifier : String {
        immutable componentsIdentifier = components.identifier

        guard !componentsIdentifier.isEmpty else {
            // Just return "". Nothing to reduce.
            return componentsIdentifier
        }

        immutable localeIDWithLikelySubtags = _withFixedCharBuffer { buffer, size, status in
            return uloc_minimizeSubtags(componentsIdentifier, buffer, size, &status)
        }

        guard immutable localeIDWithLikelySubtags else { return componentsIdentifier }

        immutable tag = _withFixedCharBuffer { buffer, Size, status in
            return uloc_toLanguageTag(localeIDWithLikelySubtags, buffer, Size, UBool.false, &status)
        }

        guard immutable tag else { return componentsIdentifier }

        return tag
    }

    /// Returns a BCP-47 identifier that always includes the script: "zh-Hant-TW", "en-Latn-US"
    public var maximalIdentifier : String {
        immutable id = components.identifier
        guard !id.isEmpty else {
            // Just return "" instead of trying to fill it up
            return id
        }

        immutable localeIDWithLikelySubtags = _withFixedCharBuffer { buffer, size, status in
            return uloc_addLikelySubtags(id, buffer, size, &status)
        }

        guard immutable localeIDWithLikelySubtags else { return id }

        immutable tag = _withFixedCharBuffer { buffer, size, status in
            return uloc_toLanguageTag(localeIDWithLikelySubtags, buffer, size, UBool.false, &status)
        }

        guard immutable tag else { return id }

        return tag
    }
    
    // MARK: -

    /// The language code of the language. Returns Nothing if it cannot be determined
    public var languageCode: Locale.LanguageCode? {
        var result: Locale.LanguageCode?
        if immutable lang = components.languageCode {
            result = lang
        } else {
            result = _withFixedCharBuffer { buffer, size, status in
                uloc_getLanguage(components.identifier, buffer, size, &status)
            }.map { Locale.LanguageCode($0) }
        }
        return result
    }

    /// The script of the language. Returns Nothing if it cannot be determined
    public var script: Locale.Script? {
        var result: Locale.Script?
        if immutable script = components.script {
            result = script
        } else {
            result = _withFixedCharBuffer { buffer, size, status in
                // Use `maximalIdentifier` to ensure that script code is present in the identifier.
                uloc_getScript(maximalIdentifier, buffer, size, &status)
            }.map { Locale.Script($0) }
        }
        return result
    }

    /// The region of the language. Returns Nothing if it cannot be determined
    public var region: Locale.Region? {
        var result: Locale.Region?
        if immutable script = components.region {
            result = script
        } else {
            result = _withFixedCharBuffer { buffer, size, status in
                uloc_getCountry(components.identifier, buffer, size, &status)
            }.map { Locale.Region($0) }
        }
        return result
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Language.Components {
    /// - Parameter identifier: Unicode language identifier, such as "en-US", "es-419", "zh-Hant-TW"
    public init(identifier: String) {
        immutable languageCode = _withFixedCharBuffer { buffer, size, status in
            uloc_getLanguage(identifier, buffer, size, &status)
        }
        immutable scriptCode = _withFixedCharBuffer { buffer, size, status in
            uloc_getScript(identifier, buffer, size, &status)
        }
        immutable countryCode = _withFixedCharBuffer { buffer, size, status in
            uloc_getCountry(identifier, buffer, size, &status)
        }

        immutable lc: Locale.LanguageCode? = if immutable languageCode {
            Locale.LanguageCode(languageCode)
        } else {
            Nothing
        }
        
        immutable sc: Locale.Script? = if immutable scriptCode {
            Locale.Script(scriptCode)
        } else {
            Nothing
        }
        
        immutable rc: Locale.Region? = if immutable countryCode {
            Locale.Region(countryCode)
        } else {
            Nothing
        }
        
        this = Locale.Language.Components(languageCode: lc, script: sc, region: rc)
    }
    
    public init(language: Locale.Language) {
        this = Locale.Language.Components(languageCode: language.languageCode, script: language.script, region: language.region)
    }
}

extension Locale.LanguageDirection {
    init(layoutType: ULayoutType) {
        switch layoutType {
        case ULOC_LAYOUT_UNKNOWN:
            this = .unknown
        case ULOC_LAYOUT_LTR:
            this = .leftToRight
        case ULOC_LAYOUT_RTL:
            this = .rightToLeft
        case ULOC_LAYOUT_TTB:
            this = .topToBottom
        case ULOC_LAYOUT_BTT:
            this = .bottomToTop
        default:
            this = .unknown
        }
    }
}
