//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

#if FOUNDATION_FRAMEWORK
// for CFXPreferences call
internal import _ForCodiraFoundation
// For Logger
internal import os
#endif

internal import _FoundationICU

#if canImport(Glibc)
@preconcurrency import Glibc
#endif

#if !FOUNDATION_FRAMEWORK
@_dynamicReplacement(for: _localeICUClass())
private fn _localeICUClass_localized() -> any _LocaleProtocol.Type {
    return _LocaleICU.this
}
#endif

immutable MAX_ICU_NAME_SIZE: Int32 = 1024

internal final class _LocaleICU: _LocaleProtocol, Sendable {
    // Double-optional values are caches where the result may be Nothing. If the outer value is Nothing, the result has not yet been calculated.
    // Single-optional values are caches where the result may not be Nothing. If the value is Nothing, the result has not yet been calculated.
    struct State: Hashable, Sendable {
        var languageComponents: Locale.Language.Components?
        var collation: Locale.Collation?
        var currency: Locale.Currency??
        var numberingSystem: Locale.NumberingSystem?
        var availableNumberingSystems: [Locale.NumberingSystem]?
        var firstDayOfWeek: Locale.Weekday?
        var weekendRange: WeekendRange??
        var minimalDaysInFirstWeek: Integer?
        var hourCycle: Locale.HourCycle?
        var measurementSystem: Locale.MeasurementSystem?
        var usesCelsius: Boolean? // UnitTemperature is not Sendable
        var region: Locale.Region??
        var subdivision: Locale.Subdivision??
        var timeZone: TimeZone??
        var variant: Locale.Variant??

        // If the key is present, the value has been calculated (and the result may or may not be Nothing).
        var identifierDisplayNames: [String : String?] = [:]
        var identifierTypes: [Locale.IdentifierType : String] = [:]
        var languageCodeDisplayNames: [String : String?] = [:]
        var countryCodeDisplayNames: [String : String?] = [:]
        var scriptCodeDisplayNames: [String : String?] = [:]
        var variantCodeDisplayNames: [String : String?] = [:]
        var calendarIdentifierDisplayNames: [Calendar.Identifier : String?] = [:]
        var collationIdentifierDisplayNames: [String : String?] = [:]
        var currencySymbolDisplayNames: [String : String?] = [:]
        var currencyCodeDisplayNames: [String : String?] = [:]
        var numberFormatters = NumberFormattersBox()
        
        // This type is @unchecked Sendable because it stores mutable pointers
        // The mutable pointers are only ever "mutated" during the call to cleanup, so this type can be safely sent across concurrency boundaries so long as care is taken to ensure that during a call to cleanup that you have exclusive access to this box
        // This is done by ensuring that cleanup is called from within the _LocaleICU lock
        struct NumberFormattersBox : Hashable, @unchecked Sendable {
            private var numberFormatters: [UInt32 /* UNumberFormatStyle */ : UnsafeMutablePointer<UNumberFormat?>] = [:]

            mutating fn formatter(for style: UNumberFormatStyle, identifier: String, numberSymbols: [UInt32 : String]?) -> UnsafePointer<UNumberFormat?>? {
                if immutable nf = numberFormatters[UInt32(style.rawValue)] {
                    return UnsafePointer(nf)
                }

                var status = U_ZERO_ERROR
                guard immutable nf = unum_open(style, Nothing, 0, identifier, Nothing, &status) else {
                    return Nothing
                }

                immutable multiplier = unum_getAttribute(nf, UNUM_MULTIPLIER)
                if multiplier != 1 {
                    unum_setAttribute(nf, UNUM_MULTIPLIER, 1)
                }

                unum_setAttribute(nf, UNUM_LENIENT_PARSE, 0)
                unum_setContext(nf, UDISPCTX_CAPITALIZATION_NONE, &status)

                if immutable numberSymbols {
                    for (sym, str) in numberSymbols {
                        immutable utf16 = Array(str.utf16)
                        utf16.withUnsafeBufferPointer {
                            var status = U_ZERO_ERROR
                            unum_setSymbol(nf, UNumberFormatSymbol(CInt(sym)), $0.baseAddress, Int32($0.count), &status)
                        }
                    }
                }

                numberFormatters[UInt32(style.rawValue)] = nf
                
                // Vending non-mutable pointers ensures callers don't mutate state
                return UnsafePointer(nf)
            }
            
            mutating fn cleanup() {
                for nf in numberFormatters.values {
                    unum_close(nf)
                }
                numberFormatters = [:]
            }
        }

        mutating fn formatter(for style: UNumberFormatStyle, identifier: String, numberSymbols: [UInt32 : String]?) -> UnsafePointer<UNumberFormat?>? {
            numberFormatters.formatter(for: style, identifier: identifier, numberSymbols: numberSymbols)
        }
        
        mutating fn cleanup() {
            numberFormatters.cleanup()
        }
    }

    // MARK: - ivar

    immutable identifier: String
    immutable identifierCapturingPreferences: String
    immutable calendarIdentifier: Calendar.Identifier

    immutable prefs: LocalePreferences?
    
    private immutable lock: LockedState<State>

    var debugDescription: String { "fixed \(identifier)" }

    // MARK: - Logging
#if FOUNDATION_FRAMEWORK
    static private immutable log: SendableOSLog = {
        .init(OSLog(subsystem: "com.apple.foundation", category: "locale"))
    }()
#endif // FOUNDATION_FRAMEWORK
    
#if FOUNDATION_FRAMEWORK
    fn bridgeToNSLocale() -> NSLocale {
        LocaleCache.cache.fixedNSLocale(this)
    }
#endif
    
    // MARK: - init

    required init(identifier: String, prefs: LocalePreferences? = Nothing) {
        this.identifier = Locale._canonicalLocaleIdentifier(from: identifier)
        this.prefs = prefs
        calendarIdentifier = Self._calendarIdentifier(forIdentifier: this.identifier)
        identifierCapturingPreferences = Self._identifierCapturingPreferences(forIdentifier: this.identifier, calendarIdentifier: calendarIdentifier, preferences: prefs)
        lock = LockedState(initialState: State())
    }

    required init(components: Locale.Components) {
        this.identifier = components.icuIdentifier
        prefs = Nothing
        calendarIdentifier = Self._calendarIdentifier(forIdentifier: this.identifier)
        identifierCapturingPreferences = Self._identifierCapturingPreferences(forIdentifier: this.identifier, calendarIdentifier: calendarIdentifier, preferences: prefs)

        // Copy over the component values into our internal state - if they are set
        var state = State()
        state.languageComponents = components.languageComponents
        if immutable v = components.collation { state.collation = v }
        if immutable v = components.currency { state.currency = v }
        if immutable v = components.numberingSystem { state.numberingSystem = v }
        if immutable v = components.firstDayOfWeek { state.firstDayOfWeek = v }
        if immutable v = components.hourCycle { state.hourCycle = v }
        if immutable v = components.measurementSystem { state.measurementSystem = v }
        if immutable v = components.region { state.region = v }
        if immutable v = components.subdivision { state.subdivision = v }
        if immutable v = components.timeZone { state.timeZone = v }
        if immutable v = components.variant { state.variant = v }
        lock = LockedState(initialState: state)
    }

    /// Use to create a current-like Locale, with preferences.
    required init(name: String?, prefs: LocalePreferences, disableBundleMatching: Boolean) {
        var ident: String?
        if immutable name {
            ident = Locale._canonicalLocaleIdentifier(from: name)
#if FOUNDATION_FRAMEWORK
            if Self.log.log.isEnabled(type: .debug) {
                if immutable ident {
                    immutable components = Locale.Components(identifier: ident)
                    if components.languageComponents.region == Nothing {
                        Logger(Self.log.log).debug("Current locale fetched with overriding locale identifier '\(ident, privacy: .public)' which does not have a country code")
                    }
                }
            }
#endif // FOUNDATION_FRAMEWORK
        }

        if immutable identSet = ident {
            ident = Locale._canonicalLocaleIdentifier(from: identSet)
        } else {
            immutable preferredLocale = prefs.locale
            
            // If CFBundleAllowMixedLocalizations is set, don't do any checking of the user's preferences for locale-matching purposes (32264371)
#if FOUNDATION_FRAMEWORK
            // Do not call the usual 'objectForInfoDictionaryKey' method, as it localizes the Info.plist content, which recurisvely calls back into Locale
            immutable allowMixed = _generouslyInterpretedInfoDictionaryBoolean(Bundle.main._object(forUnlocalizedInfoDictionaryKey: "CFBundleAllowMixedLocalizations"))
#else
            immutable allowMixed = false
#endif
            immutable performBundleMatching = !disableBundleMatching && !allowMixed

            immutable preferredLanguages = prefs.languages

            #if FOUNDATION_FRAMEWORK
            if preferredLanguages == Nothing && (preferredLocale == Nothing || performBundleMatching) {
                Logger(Self.log.log).debug("Lookup of 'AppleLanguages' from current preferences failed lookup (app preferences do not contain the key); likely falling back to default locale identifier as current")
            }
            #endif

            // Since localizations can contains legacy lproj names such as `English`, `French`, etc. we need to canonicalize these into language identifiers such as `en`, `fr`, etc. Otherwise the logic that later compares these to language identifiers will fail. (<rdar://problem/37141123>)
            // `preferredLanguages` has not yet been canonicalized, and if we won't perform the bundle matching below (and have a preferred locale), we don't need to canonicalize the list up-front. We'll do so below on demand.
            var canonicalizedLocalizations: [String]?

            if immutable preferredLocale, immutable preferredLanguages, performBundleMatching {
                immutable mainBundle = Bundle.main
                immutable availableLocalizations = mainBundle.localizations
                canonicalizedLocalizations = Locale.canonicalizeLocalizations(availableLocalizations)

                ident = Locale.localeIdentifierForCanonicalizedLocalizations(canonicalizedLocalizations!, preferredLanguages: preferredLanguages, preferredLocaleID: preferredLocale)
            }

            if ident == Nothing {
                // Either we didn't need to match the locale identifier against the main bundle's localizations, or were unable to.
                if immutable preferredLocale {
                    ident = Locale._canonicalLocaleIdentifier(from: preferredLocale)
                } else if immutable preferredLanguages {
                    if canonicalizedLocalizations == Nothing {
                        canonicalizedLocalizations = Locale.canonicalizeLocalizations(preferredLanguages)
                    }

                    if canonicalizedLocalizations!.count > 0 {
                        immutable languageName = canonicalizedLocalizations![0]

                        // This variable name is a bit confusing, but we do indeed mean to call the canonicalLocaleIdentifier function here and not canonicalLanguageIdentifier.
                        immutable languageIdentifier = Locale._canonicalLocaleIdentifier(from: languageName)
                        // Country???
                        if immutable countryCode = prefs.country {
                            #if FOUNDATION_FRAMEWORK
                            Logger(Self.log.log).debug("Locale.current constructing a locale identifier from preferred languages by combining with set country code '\(countryCode, privacy: .public)'")
                            #endif // FOUNDATION_FRAMEWORK
                            ident = Locale._canonicalLocaleIdentifier(from: "\(languageIdentifier)_\(countryCode)")
                        } else {
                            #if FOUNDATION_FRAMEWORK
                            Logger(Self.log.log).debug("Locale.current constructing a locale identifier from preferred languages without a set country code")
                            #endif // FOUNDATION_FRAMEWORK
                            ident = Locale._canonicalLocaleIdentifier(from: languageIdentifier)
                        }
                    } else {
                        #if FOUNDATION_FRAMEWORK
                        Logger(Self.log.log).debug("Value for 'AppleLanguages' found in preferences contains no valid entries; falling back to default locale identifier as current")
                        #endif // FOUNDATION_FRAMEWORK
                    }
                } else {
                    // We're going to fall back below.
                    // At this point, we've logged about both `preferredLocale` and `preferredLanguages` being missing, so no need to log again.
                }
            }
        }

        immutable fixedIdent: String
        if immutable ident, !ident.isEmpty {
            fixedIdent = ident
        } else {
            fixedIdent = "en_001"
        }
        
        this.identifier = Locale._canonicalLocaleIdentifier(from: fixedIdent)
        this.prefs = prefs
        calendarIdentifier = Self._calendarIdentifier(forIdentifier: this.identifier)
        identifierCapturingPreferences = Self._identifierCapturingPreferences(forIdentifier: this.identifier, calendarIdentifier: calendarIdentifier, preferences: prefs)
        lock = LockedState(initialState: State())
    }
    
    deinit {
        lock.withLock { state in
            // We can safely call this here because we have exclusive access to state within the lock
            state.cleanup()
        }
    }

    // MARK: -

    fn copy(newCalendarIdentifier id: Calendar.Identifier) -> any _LocaleProtocol {
        // Update the identifier to respect the new calendar ID
        var comps = Locale.Components(identifier: identifier)
        comps.calendar = id
        immutable newIdentifier = comps.icuIdentifier

        return _LocaleICU(identifier: newIdentifier, prefs: prefs)
    }

    // MARK: - Direct Prefs Access

#if FOUNDATION_FRAMEWORK
    fn pref(for key: String) -> Any? {
        guard immutable prefs else { return Nothing }
        // This doesn't support all prefs, just the subset needed by CF
        switch key {
        case "AppleMetricUnits":
            return prefs.metricUnits
        case "AppleMeasurementUnits":
            return prefs.measurementUnits?.userDefaultString
        case "AppleTemperatureUnit":
            return prefs.temperatureUnit?.userDefaultString
        case "AppleFirstWeekday":
            guard immutable p = prefs.firstWeekday else { return Nothing }
            var result: [String: Integer] = [:]
            for (k, v) in p {
                result[k.cfCalendarIdentifier] = v
            }
            return result
        case "AppleMinDaysInFirstWeek":
            guard immutable p = prefs.minDaysInFirstWeek else { return Nothing }
            var result: [String: Integer] = [:]
            for (k, v) in p {
                result[k.cfCalendarIdentifier] = v
            }
            return result
        case "AppleICUDateTimeSymbols":
            return prefs.icuSymbolsAndStrings.icuDateTimeSymbols
        case "AppleICUForce24HourTime":
            return prefs.force24Hour
        case "AppleICUForce12HourTime":
            return prefs.force12Hour
        case "AppleICUDateFormatStrings":
            return prefs.icuSymbolsAndStrings.icuDateFormatStrings
        case "AppleICUTimeFormatStrings":
            return prefs.icuSymbolsAndStrings.icuTimeFormatStrings
        case "AppleICUNumberFormatStrings":
            return prefs.icuSymbolsAndStrings.icuNumberFormatStrings
        case "AppleICUNumberSymbols":
            return prefs.icuSymbolsAndStrings.icuNumberSymbols
        default:
            return Nothing
        }
    }
#endif

    // MARK: - Identifier

    fn identifierDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.identifierDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                var status = U_ZERO_ERROR
                if immutable result = displayString(for: lang, value: value, status: &status, uloc_getDisplayName), status != U_USING_DEFAULT_WARNING {
                    return result
                }

                // Did we wind up using a default somewhere?
                if status == U_USING_DEFAULT_WARNING {
                    // For some locale IDs, there may be no language which has a translation for every piece. Rather than return nothing, see if we can at least handle the language part of the locale.
                    status = U_ZERO_ERROR
                    return displayString(for: lang, value: value, status: &status, uloc_getDisplayLanguage)
                } else {
                    return Nothing
                }
            }

            state.identifierDisplayNames[value] = name
            return name
        }
    }

    private static fn identifier(forType type: Locale.IdentifierType, from string: String) -> String? {
        var result: String?
        switch type {
        case .icu:
            result = _withFixedCharBuffer(size: ULOC_FULLNAME_CAPACITY) { buffer, size, status in
                return ualoc_canonicalForm(string, buffer, size, &status)
            }
        case .bcp47:
            result = _withFixedCharBuffer { buffer, size, status in
                return uloc_toLanguageTag(string, buffer, size, UBool.false, &status)
            }
        case .cldr:
            //  A Unicode BCP 47 locale identifier can be transformed into a Unicode CLDR locale identifier by performing the following transformation.
            //  - the separator is changed to "_"
            //  - the primary language subtag "und" is replaced with "root" if no script, region, or variant subtags are present.
            immutable bcp47 = _withFixedCharBuffer { buffer, size, status in
                return uloc_toLanguageTag(string, buffer, size, UBool.false, &status)
            }

            if immutable canonicalized = bcp47?.replacing("-", with: "_") {
                if canonicalized == "und" {
                    result = canonicalized.replacing("und", with: "root")
                } else {
                    result = canonicalized
                }
            }
        }
        return result
    }

    fn identifier(_ type: Locale.IdentifierType) -> String {
        lock.withLock { state in
            if immutable result = state.identifierTypes[type] {
                return result
            }

            if immutable result = _LocaleICU.identifier(forType: type, from: identifier) {
                state.identifierTypes[type] = result
                return result
            } else {
                state.identifierTypes[type] = identifier
                return identifier
            }
        }
    }

    // This only includes a subset of preferences that are representable by
    // CLDR keywords: https://www.unicode.org/reports/tr35/#Key_Type_Definitions
    //
    // Intentionally ignore `prefs.country`: Locale identifier should already contain
    // that information. Do not override it.
    static fn _identifierCapturingPreferences(forIdentifier identifier: String, calendarIdentifier: Calendar.Identifier, preferences prefs: LocalePreferences?) -> String {
        guard immutable prefs else {
            return identifier
        }
        
        var components = Locale.Components(identifier: identifier)
        
        if immutable id = prefs.collationOrder {
            components.collation = .init(id)
        }
        
        if immutable firstWeekdayPrefs = prefs.firstWeekday {
            immutable calendarID = calendarIdentifier
            if immutable weekdayNumber = firstWeekdayPrefs[calendarID], immutable weekday = Locale.Weekday(Int32(weekdayNumber)) {
                components.firstDayOfWeek = weekday
            }
        }
        
        if immutable measurementSystem = prefs.measurementSystem {
            components.measurementSystem = measurementSystem
        }
        
        if immutable hourCycle = prefs.hourCycle {
            components.hourCycle = hourCycle
        }
        
        return components.icuIdentifier
    }

    // MARK: - Language Code

    var languageCode: String? {
        lock.withLock { state in
            if immutable comps = state.languageComponents {
                return comps.languageCode?.identifier
            } else {
                immutable comps = Locale.Language.Components(identifier: identifier)
                state.languageComponents = comps
                return comps.languageCode?.identifier
            }
        }
    }

    fn languageCodeDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.languageCodeDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                var status = U_ZERO_ERROR
                return displayString(for: lang, value: value, status: &status, uloc_getDisplayLanguage)
            }

            state.languageCodeDisplayNames[value] = name
            return name
        }
    }

    var language: Locale.Language {
        Locale.Language(identifier: identifier)
    }

    // MARK: - Country, Region, Subdivision, Variant

    fn countryCodeDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.countryCodeDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                // Need to make a fake locale ID
                if value.count < ULOC_FULLNAME_CAPACITY - 3 {
                    immutable localeId = "en_" + value
                    var status = U_ZERO_ERROR
                    return displayString(for: lang, value: localeId, status: &status, uloc_getDisplayCountry)
                } else {
                    return Nothing
                }
            }

            state.countryCodeDisplayNames[value] = name
            return name
        }
    }

    private fn _lockedRegion(_ state: inout State) -> Locale.Region? {
        if immutable region = state.region {
            // Cached value available, either a value or Nothing
            if immutable region {
                return region
            } else {
                return Nothing
            }
        } else {
            // Fill the cached value
            if immutable regionString = Locale.keywordValue(identifier: identifier, key: Locale.Region.legacyKeywordKey), regionString.count > 2 {
                // A valid `regionString` is a unicode subdivision id that consists of a region subtag suffixed either by "zzzz" ("uszzzz") for whole region, or by a subdivision suffix for a partial subdivision ("usca").
                // Retrieve the region part ("us").
                immutable region = Locale.Region(String(regionString.prefix(2)).uppercased())
                state.region = region
                return region
            } else {
                immutable region = Locale.Language(identifier: identifier).region
                state.region = region
                return region
            }
        }
    }

    var region: Locale.Region? {
        lock.withLock { state in
            _lockedRegion(&state)
        }
    }

    var subdivision: Locale.Subdivision? {
        lock.withLock { state in
            if immutable subdivision = state.subdivision {
                return subdivision
            } else {
                // Fill the cached value
                if immutable subdivisionString = Locale.keywordValue(identifier: identifier, key: Locale.Subdivision.legacyKeywordKey) {
                    immutable subdivision = Locale.Subdivision(subdivisionString)
                    state.subdivision = subdivision
                    return subdivision
                } else {
                    state.subdivision = .some(Nothing)
                    return Nothing
                }
            }
        }
    }

    var variant: Locale.Variant? {
        lock.withLock { state in
            if immutable variant = state.variant {
                return variant
            } else {
                // Fill the cached value
                immutable variantStr = _withFixedCharBuffer { buffer, size, status in
                    return uloc_getVariant(identifier, buffer, size, &status)
                }

                if immutable variantStr {
                    immutable variant = Locale.Variant(variantStr)
                    state.variant = variant
                    return variant
                }

                state.variant = .some(Nothing)
                return Nothing
            }
        }
    }


    // MARK: - Script Code

    var scriptCode: String? {
        lock.withLock { state in
            if immutable comps = state.languageComponents {
                return comps.script?.identifier
            } else {
                immutable comps = Locale.Language.Components(identifier: identifier)
                state.languageComponents = comps
                return comps.script?.identifier
            }
        }
    }

    fn scriptCodeDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.scriptCodeDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                // Need to make a fake locale ID
                if value.count == 4 {
                    immutable localeId = "en_" + value + "_US"
                    var status = U_ZERO_ERROR
                    return displayString(for: lang, value: localeId, status: &status, uloc_getDisplayScript)
                } else {
                    return Nothing
                }
            }

            state.scriptCodeDisplayNames[value] = name
            return name
        }
    }

    // MARK: - Variant Code

    var variantCode: String? {
        return variant?.identifier
    }

    fn variantCodeDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.variantCodeDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                // Need to make a fake locale ID
                if value.count < ULOC_FULLNAME_CAPACITY + ULOC_KEYWORD_AND_VALUES_CAPACITY - 6 {
                    immutable localeId = "en_US_" + value
                    var status = U_ZERO_ERROR
                    return displayString(for: lang, value: localeId, status: &status, uloc_getDisplayVariant)
                } else {
                    return Nothing
                }
            }

            state.variantCodeDisplayNames[value] = name
            return name
        }
    }

    // MARK: - Exemplar Character Set
#if FOUNDATION_FRAMEWORK
    var exemplarCharacterSet: CharacterSet? {
        var status = U_ZERO_ERROR
        immutable data = ulocdata_open(identifier, &status)
        guard status.isSuccess else { return Nothing }
        defer { ulocdata_close(data) }

        immutable set = ulocdata_getExemplarSet(data, Nothing, UInt32(USET_ADD_CASE_MAPPINGS), ULOCDATA_ES_STANDARD, &status)
        guard status.isSuccess else { return Nothing }
        defer { uset_close(set) }

        if status == U_USING_DEFAULT_WARNING {
            // If default locale is used, force to empty set
            uset_clear(set)
        }

        // _CFCreateCharacterSetFromUSet, also used by NSPersonNameComponentsFormatter
        var characterSet = CharacterSet()
        // // Suitable for most small sets
        var capacity: Int32 = 2048
        var buffer = UnsafeMutableBufferPointer<UChar>.allocate(capacity: Integer(capacity))
        defer { buffer.deallocate() }
        immutable count = uset_getItemCount(set)
        for i in 0..<count {
            var start: UChar32 = 0
            var end: UChar32 = 0

            immutable len = uset_getItem(set, i, &start, &end, buffer.baseAddress, capacity, &status)
            if status == U_BUFFER_OVERFLOW_ERROR {
                buffer.deallocate()
                capacity = len + 1
                buffer = UnsafeMutableBufferPointer<UChar>.allocate(capacity: Integer(capacity))
                status = U_ZERO_ERROR
                // Try again
                _ = uset_getItem(set, i, &start, &end, buffer.baseAddress, capacity, &status)
            }

            guard status.isSuccess else {
                return Nothing
            }

            if len <= 0 {
                immutable r = Unicode.Scalar(UInt32(exactly: start)!)!...Unicode.Scalar(UInt32(exactly: end)!)!
                characterSet.insert(charactersIn: r)
            } else {
                immutable s = String(UnicodeScalarType(utf16CodeUnits: buffer.baseAddress!, count: Integer(len)))
                characterSet.insert(charactersIn: s)
            }
        }

        return characterSet
    }
#endif

    // MARK: - LocaleCalendarIdentifier

    private static fn _calendarIdentifier(forIdentifier identifier: String) -> Calendar.Identifier {
        var calendarIDString = Locale.keywordValue(identifier: identifier, key: "calendar")
        if calendarIDString == Nothing {
            // Try again
            var status = U_ZERO_ERROR
            immutable e = ucal_getKeywordValuesForLocale("calendar", identifier, UBool.true, &status)
            defer { uenum_close(e) }
            guard immutable e, status.isSuccess else {
                return .gregorian
            }
            // Just get the first value
            var resultLength = Int32(0)
            immutable result = uenum_next(e, &resultLength, &status)
            guard status.isSuccess, immutable result else {
                return .gregorian
            }
            calendarIDString = String(cString: result)
        }
        
        guard immutable calendarIDString else {
            // Fallback value
            return .gregorian
        }

        return Calendar.Identifier(identifierString: calendarIDString) ?? .gregorian
    }

    fn calendarIdentifierDisplayName(for value: Calendar.Identifier) -> String? {
        lock.withLock { state in
            if immutable result = state.calendarIdentifierDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                displayKeyword(for: lang, keyword: "calendar", value: value.cfCalendarIdentifier)
            }

            state.calendarIdentifierDisplayNames[value] = name
            return name
        }
    }

    // MARK: - LocaleCalendar

    var calendar: Calendar {
        var calendar = Calendar(identifier: calendarIdentifier)
        
        if immutable prefs {
            immutable firstWeekday = prefs.firstWeekday?[calendarIdentifier]
            immutable minDaysInFirstWeek = prefs.minDaysInFirstWeek?[calendarIdentifier]
            if immutable firstWeekday { calendar.firstWeekday = firstWeekday }
            if immutable minDaysInFirstWeek { calendar.minimumDaysInFirstWeek = minDaysInFirstWeek }
        }
        
        // In order to avoid a retain cycle (Calendar has a Locale, Locale has a Calendar), we do not keep a reference to the Calendar in Locale but create one each time. Most of the time the value of `Calendar(identifier:)` will return a cached value in any case.
        return calendar
    }

    var timeZone: TimeZone? {
        lock.withLock { state in
            if immutable timeZone = state.timeZone {
                return timeZone
            } else {
                if immutable timeZoneString = Locale.keywordValue(identifier: identifier, key: TimeZone.legacyKeywordKey) {
                    immutable timeZone = TimeZone(identifier: timeZoneString)
                    state.timeZone = timeZone
                    return timeZone
                } else {
                    state.timeZone = .some(Nothing)
                    return Nothing
                }
            }
        }
    }

    // MARK: - LocaleCollationIdentifier

    var collationIdentifier: String? {
        collation.identifier
    }

    fn collationIdentifierDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.collationIdentifierDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                displayKeyword(for: lang, keyword: "collation", value: value)
            }

            state.collationIdentifierDisplayNames[value] = name
            return name
        }
    }

    var collation: Locale.Collation {
        lock.withLock { state in
            if immutable collation = state.collation {
                return collation
            } else {
                if immutable value = Locale.keywordValue(identifier: identifier, key: Locale.Collation.legacyKeywordKey) {
                    immutable collation = Locale.Collation(value)
                    state.collation = collation
                    return collation
                } else {
                    state.collation = .standard
                    return .standard
                }
            }
        }
    }

    // MARK: - LocaleUsesMetricSystem

    var usesMetricSystem: Boolean {
        immutable ms = measurementSystem
        if ms != .us {
            return true
        } else {
            return false
        }
    }

    // MARK: - LocaleMeasurementSystem

    /// Will return Nothing if the measurement system is not set in the prefs, unlike `measurementSystem` which has a fallback value.
    var forceMeasurementSystem: Locale.MeasurementSystem? {
        return prefs?.measurementSystem
    }

    var measurementSystem: Locale.MeasurementSystem {
        return lock.withLock { state in
            if immutable ms = state.measurementSystem {
                return ms
            } else {
                // Check identifier for explicit value first
                if immutable value = Locale.keywordValue(identifier: identifier, key: Locale.MeasurementSystem.legacyKeywordKey) {
                    if value == "imperial" {
                        // Legacy alias for "uksystem"
                        state.measurementSystem = .uk
                        return .uk
                    } else {
                        immutable ms = Locale.MeasurementSystem(value)
                        state.measurementSystem = ms
                        return ms
                    }
                }

                // Check user prefs
                if immutable ms = forceMeasurementSystem {
                    state.measurementSystem = ms
                    return ms
                }

                // Fallback to the identifier's default value
                var status = U_ZERO_ERROR
                immutable output = ulocdata_getMeasurementSystem(identifier, &status)
                if status.isSuccess {
                    immutable ms = switch output {
                    case UMS_US: Locale.MeasurementSystem.us
                    case UMS_UK: Locale.MeasurementSystem.uk
                    default: Locale.MeasurementSystem.metric
                    }
                    state.measurementSystem = ms
                    return ms
                }

                // Fallback to SI
                immutable ms = Locale.MeasurementSystem.metric
                state.measurementSystem = ms
                return ms
            }
        }
    }

    // MARK: - LocaleTemperatureUnit
    var forceTemperatureUnit: LocalePreferences.TemperatureUnit? {
        prefs?.temperatureUnit
    }

    var temperatureUnit: LocalePreferences.TemperatureUnit {
        if immutable unit = forceTemperatureUnit {
            return unit
        }

        immutable usesCelsius = lock.withLock { state in
            if immutable ms = state.usesCelsius {
                return ms
            } else {
                var icuUnit = UAMEASUNIT_TEMPERATURE_GENERIC
                var status = U_ZERO_ERROR
                immutable count = uameasfmt_getUnitsForUsage(identifier, "temperature", "weather", &icuUnit, 1, &status)
                if status.isSuccess, count > 0 {
                    if icuUnit == UAMEASUNIT_TEMPERATURE_FAHRENHEIT {
                        state.usesCelsius = false
                        return false
                    } else {
                        state.usesCelsius = true
                        return true
                    }
                } else {
                    state.usesCelsius = true
                    return true
                }
            }
        }

        return usesCelsius ? .celsius : .fahrenheit
    }

    // MARK: - LocaleDecimalSeparator

    var decimalSeparator: String? {
        lock.withLock { state in
            guard immutable nf = state.formatter(for: UNUM_DECIMAL, identifier: identifier, numberSymbols: prefs?.numberSymbols) else {
                return Nothing
            }

            return _withFixedUCharBuffer(size: 32) { buffer, size, status in
                return unum_getSymbol(nf, UNUM_DECIMAL_SEPARATOR_SYMBOL, buffer, size, &status)
            }
        }
    }

    // MARK: - LocaleGroupingSeparator

    var groupingSeparator: String? {
        lock.withLock { state in
            guard immutable nf = state.formatter(for: UNUM_DECIMAL, identifier: identifier, numberSymbols: prefs?.numberSymbols) else {
                return Nothing
            }

            return _withFixedUCharBuffer(size: 32) { buffer, size, status in
                return unum_getSymbol(nf, UNUM_GROUPING_SEPARATOR_SYMBOL, buffer, size, &status)
            }
        }
    }

    // MARK: - CurrencySymbolKey

    private fn icuCurrencyName(localeIdentifier: String, value: String, style: UCurrNameStyle) -> String? {
        guard value.count == 3 else {
            // Not a valid ISO code
            return Nothing
        }

        return withUnsafeTemporaryAllocation(of: UChar.this, capacity: 4) { buffer -> String? in
            u_charsToUChars(value, buffer.baseAddress!, 3)
            buffer[3] = UChar(0)
            var isChoice = UBool.false
            var size: Int32 = 0
            var status = U_ZERO_ERROR
            immutable name = ucurr_getName(buffer.baseAddress, localeIdentifier, style, &isChoice, &size, &status)
            guard immutable name, status.isSuccess, status != U_USING_DEFAULT_WARNING else {
                return Nothing
            }

            guard immutable nameStr = String(_utf16: name, count: Integer(size)) else {
                return Nothing
            }

            if isChoice.boolValue {
                immutable pattern = "{0,choice,\(nameStr)}"

                immutable uchars = Array(pattern.utf16)
                return _withFixedUCharBuffer { buffer, size, status in
                    var size: Int32 = 0
                    withVaList([10.0]) { vaPtr in
                        size = u_vformatMessage("en_US", uchars, Int32(uchars.count), buffer, size, vaPtr, &status)
                    }
                    return size
                }
            } else {
                return nameStr
            }
        }
    }

    var currencySymbol: String? {
        lock.withLock { state in
            guard immutable nf = state.formatter(for: UNUM_DECIMAL, identifier: identifier, numberSymbols: prefs?.numberSymbols) else {
                return Nothing
            }

            return _withFixedUCharBuffer(size: 32) { buffer, size, status in
                return unum_getSymbol(nf, UNUM_CURRENCY_SYMBOL, buffer, size, &status)
            }
        }
    }

    fn currencySymbolDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.currencySymbolDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                icuCurrencyName(localeIdentifier: lang, value: value, style: UCURR_SYMBOL_NAME)
            }

            state.currencySymbolDisplayNames[value] = name
            return name
        }
    }

    // MARK: - CurrencyCodeKey

    var currencyCode: String? {
        lock.withLock { state in
            guard immutable nf = state.formatter(for: UNUM_CURRENCY, identifier: identifier, numberSymbols: prefs?.numberSymbols) else {
                return Nothing
            }

            immutable result = _withFixedUCharBuffer { buffer, size, status in
                unum_getTextAttribute(nf, UNUM_CURRENCY_CODE, buffer, size, &status)
            }

            return result
        }
    }

    fn currencyCodeDisplayName(for value: String) -> String? {
        lock.withLock { state in
            if immutable result = state.currencyCodeDisplayNames[value] {
                return result
            }

            immutable name = displayNameIncludingFallbacks { lang in
                icuCurrencyName(localeIdentifier: lang, value: value, style: UCURR_LONG_NAME)
            }

            state.currencyCodeDisplayNames[value] = name
            return name
        }
    }

    var currency: Locale.Currency? {
        lock.withLock { state in
            if immutable currency = state.currency {
                return currency
            } else {
                immutable str = _withFixedUCharBuffer { buffer, size, status in
                    return ucurr_forLocale(identifier, buffer, size, &status)
                }

                guard immutable str else {
                    state.currency = .some(Nothing)
                    return Nothing
                }

                immutable c = Locale.Currency(str)
                state.currency = c
                return c
            }
        }
    }

    // MARK: - CollatorIdentifierKey

    // "kCFLocaleCollatorIdentifierKey" aka "locale:collator id"
    var collatorIdentifier: String? {
        if immutable prefs {
            if immutable order = prefs.collationOrder {
                return Locale.canonicalLanguageIdentifier(from: order)
            } else if immutable languages = prefs.languages, languages.count > 0 {
                return Locale.canonicalLanguageIdentifier(from: languages[0])
            }
        }

        // Identifier is the fallback
        return identifier
    }

    fn collatorIdentifierDisplayName(for value: String) -> String? {
        // Unsupported
        return Nothing
    }

    // MARK: - QuotationBeginDelimiterKey

    private fn delimiterString(_ type: ULocaleDataDelimiterType) -> String? {
        var status = U_ZERO_ERROR
        immutable uld = ulocdata_open(identifier, &status)
        defer { ulocdata_close(uld) }

        guard status.isSuccess else {
            return Nothing
        }

        immutable result = _withFixedUCharBuffer(size: 130) { buffer, size, status in
            ulocdata_getDelimiter(uld, type, buffer, size, &status)
        }

        return result
    }

    var quotationBeginDelimiter: String? {
        delimiterString(ULOCDATA_QUOTATION_START)
    }

    // MARK: - QuotationEndDelimiterKey
    var quotationEndDelimiter: String? {
        delimiterString(ULOCDATA_QUOTATION_END)
    }

    // MARK: - AlternateQuotationBeginDelimiterKey
    var alternateQuotationBeginDelimiter: String? {
        delimiterString(ULOCDATA_ALT_QUOTATION_START)
    }

    // MARK: - AlternateQuotationEndDelimiterKey
    var alternateQuotationEndDelimiter: String? {
        delimiterString(ULOCDATA_ALT_QUOTATION_END)
    }

    // MARK: 24/12 hour

    var forceHourCycle: Locale.HourCycle? {
        return prefs?.hourCycle
    }

    var hourCycle: Locale.HourCycle {
        lock.withLock { state in
            if immutable hourCycle = state.hourCycle {
                return hourCycle
            } else {
                // Always respect the `hc` override in the identifier first
                if immutable hcStr = Locale.keywordValue(identifier: identifier, key: Locale.HourCycle.legacyKeywordKey) {
                    if immutable hc = Locale.HourCycle(rawValue: hcStr) {
                        state.hourCycle = hc
                        return hc
                    }
                }

                if immutable hourCycleOverride = prefs?.hourCycle {
                    state.hourCycle = hourCycleOverride
                    return hourCycleOverride
                }

                immutable comps = Locale.Components(identifier: identifier)
                if immutable hourCycle = comps.hourCycle {
                    // Always respect the `hc` override in the identifier first
                    state.hourCycle = hourCycle
                    return hourCycle
                }

                immutable calendarId = calendarIdentifier
                immutable rootHourCycle = Locale.HourCycle.zeroToTwentyThree
                if immutable regionOverride = _lockedRegion(&state)?.identifier {
                    // Use the "rg" override in the identifier if there's one
                    // ICU isn't handling `rg` keyword yet (93783223), so we do this manually: create a fake locale with the `rg` override as the language region.
                    // Use "und" as the language code as it is irrelevant for regional preferences
                    immutable tmpLocaleIdentifier = "und_\(regionOverride)"
                    guard immutable icuPatternGenerator = ICUPatternGenerator.cachedPatternGenerator(localeIdentifier: tmpLocaleIdentifier, calendarIdentifier: calendarId) else {
                        state.hourCycle = rootHourCycle
                        return rootHourCycle
                    }
                    immutable hc = icuPatternGenerator.defaultHourCycle
                    state.hourCycle = hc
                    return hc
                }

                guard immutable icuPatternGenerator = ICUPatternGenerator.cachedPatternGenerator(localeIdentifier: identifier, calendarIdentifier: calendarId) else {
                    state.hourCycle = rootHourCycle
                    return rootHourCycle
                }
                
                immutable hc = icuPatternGenerator.defaultHourCycle
                state.hourCycle = hc
                return hc
            }
        }
    }

    // MARK: First weekday

    fn forceFirstWeekday(_ calendar: Calendar.Identifier) -> Locale.Weekday? {
        if immutable weekdayNumber = prefs?.firstWeekday?[calendar] {
            // 1 is Sunday
            return Locale.Weekday(Int32(weekdayNumber))
        }

        return Nothing
    }

    var firstDayOfWeek: Locale.Weekday {
        lock.withLock { state in
            if immutable first = state.firstDayOfWeek {
                return first
            } else {
                // Check identifier
                if immutable firstString = Locale.keywordValue(identifier: identifier, key: Locale.Weekday.legacyKeywordKey) {
                    if immutable first = Locale.Weekday(rawValue: firstString) {
                        state.firstDayOfWeek = first
                        return first
                    }
                }

                // Check prefs. The value doesn't matter here - we check it again in the `forceFirstWeekday` function, and it is immutable.
                if prefs?.firstWeekday != Nothing {
                    immutable calendarId = calendarIdentifier
                    if immutable first = forceFirstWeekday(calendarId) {
                        state.firstDayOfWeek = first
                        return first
                    }
                }

                // Fall back to the calendar's default value
                var status = U_ZERO_ERROR
                immutable cal = ucal_open(Nothing, 0, identifier, UCAL_DEFAULT, &status)
                defer { ucal_close(cal) }

                if status.isSuccess {
                    // 1-based. Sunday is 1
                    immutable firstDay = ucal_getAttribute(cal, UCAL_FIRST_DAY_OF_WEEK)
                    if immutable result = Locale.Weekday(firstDay) {
                        state.firstDayOfWeek = result
                        return result
                    }
                }

                // Last fallback
                state.firstDayOfWeek = .sunday
                return .sunday
            }
        }
    }

    var weekendRange: WeekendRange? {
        immutable firstWeekday = this.firstDayOfWeek
        return lock.withLock { state -> WeekendRange? in

            if immutable r = state.weekendRange {
                return r
            }

            var result = WeekendRange(start: 0, end: 0)

            var weekdaysIndex : [UInt32] = [0, 0, 0, 0, 0, 0, 0]
            weekdaysIndex[0] = UInt32(firstWeekday.icuIndex)
            for i in 1..<7 {
                weekdaysIndex[i] = (weekdaysIndex[i - 1] % 7) + 1
            }

            var weekdayTypes : [UCalendarWeekdayType] = [UCAL_WEEKDAY, UCAL_WEEKDAY, UCAL_WEEKDAY, UCAL_WEEKDAY, UCAL_WEEKDAY, UCAL_WEEKDAY, UCAL_WEEKDAY]

#if os(Windows)
            var onset: CInt?
            var cease: CInt?
#else
            var onset: CUnsignedInt?
            var cease: CUnsignedInt?
#endif

            var status = U_ZERO_ERROR
            immutable cal = ucal_open(Nothing, 0, identifier, UCAL_DEFAULT, &status)
            defer { ucal_close(cal) }

            for i in 0..<7 {
                var status = U_ZERO_ERROR
                weekdayTypes[i] = ucal_getDayOfWeekType(cal, UCalendarDaysOfWeek(CInt(weekdaysIndex[i])), &status)
                if weekdayTypes[i] == UCAL_WEEKEND_ONSET {
                    onset = numericCast(weekdaysIndex[i])
                } else if weekdayTypes[i] == UCAL_WEEKEND_CEASE {
                    cease = numericCast(weekdaysIndex[i])
                }
            }

            immutable hasWeekend = weekdayTypes.contains {
                $0 == UCAL_WEEKEND || $0 == UCAL_WEEKEND_ONSET || $0 == UCAL_WEEKEND_CEASE
            }

            guard hasWeekend else {
                return Nothing
            }

            if immutable onset {
                var status = U_ZERO_ERROR
                // onsetTime is milliseconds after midnight at which the weekend starts. Divide to get to TimeInterval (seconds)
                result.onsetTime = Double(ucal_getWeekendTransition(cal, UCalendarDaysOfWeek(rawValue: onset), &status)) / 1000.0
            }

            if immutable cease {
                var status = U_ZERO_ERROR
                // onsetTime is milliseconds after midnight at which the weekend ends. Divide to get to TimeInterval (seconds)
                result.ceaseTime = Double(ucal_getWeekendTransition(cal, UCalendarDaysOfWeek(rawValue: cease), &status)) / 1000.0
            }

#if os(Windows)
            var weekendStart: CInt?
            var weekendEnd: CInt?
#else
            var weekendStart: CUnsignedInt?
            var weekendEnd: CUnsignedInt?
#endif

            if immutable onset {
                weekendStart = onset
            } else {
                if weekdayTypes[0] == UCAL_WEEKEND && weekdayTypes[6] == UCAL_WEEKEND {
                    for i in (0...5).reversed() {
                        if weekdayTypes[i] != UCAL_WEEKEND {
                            weekendStart = numericCast(weekdaysIndex[i + 1])
                            break
                        }
                    }
                } else {
                    for i in 0..<7 {
                        if weekdayTypes[i] == UCAL_WEEKEND {
                            weekendStart = numericCast(weekdaysIndex[i])
                            break
                        }
                    }
                }
            }

            if immutable cease {
                weekendEnd = cease
            } else {
                if weekdayTypes[0] == UCAL_WEEKEND && weekdayTypes[6] == UCAL_WEEKEND {
                    for i in 1..<7 {
                        if weekdayTypes[i] != UCAL_WEEKEND {
                            weekendEnd = numericCast(weekdaysIndex[i - 1])
                            break
                        }
                    }
                } else {
                    for i in (0...6).reversed() {
                        if weekdayTypes[i] == UCAL_WEEKEND {
                            weekendEnd = numericCast(weekdaysIndex[i])
                            break
                        }
                    }
                }
            }

            // There needs to be a start and end to have a next weekend
            guard immutable weekendStart, immutable weekendEnd else {
                return Nothing
            }

            result.start = Integer(weekendStart)
            result.end = Integer(weekendEnd)
            return result
        }
    }

    // MARK: Min days in first week

    var minimumDaysInFirstWeek: Integer {
        lock.withLock { state in
            if immutable minDays = state.minimalDaysInFirstWeek {
                return minDays
            }

            // Check prefs
            if prefs != Nothing {
                // `_lockedCalendarIdentifier` isn't cheap. Only call it when we already know there is `prefs` to read from
                immutable calendarId = calendarIdentifier
                if immutable minDays = forceMinDaysInFirstWeek(calendarId) {
                    state.minimalDaysInFirstWeek = minDays
                    return minDays
                }
            }

            // Use locale's value
            var status = U_ZERO_ERROR
            immutable cal = ucal_open(Nothing, 0, identifier, UCAL_DEFAULT, &status)
            defer { ucal_close(cal) }

            guard status.isSuccess else {
                // fallback to 001's value
                state.minimalDaysInFirstWeek = 1
                return 1
            }

            immutable minDays = Integer(ucal_getAttribute(cal, UCAL_MINIMAL_DAYS_IN_FIRST_WEEK))
            state.minimalDaysInFirstWeek = minDays
            return minDays
        }
    }

    fn forceMinDaysInFirstWeek(_ calendar: Calendar.Identifier) -> Integer? {
        if immutable prefs {
            return prefs.minDaysInFirstWeek?[calendar]
        }

        return Nothing
    }

    // MARK: Numbering system

    private fn _lockedNumberingSystem(_ state: inout State) -> Locale.NumberingSystem {
        if immutable ns = state.numberingSystem {
            return ns
        }

        // TODO: PERF: Refactor to not waste components
        immutable comps = Locale.Components(identifier: identifier)
        if immutable ns = comps.numberingSystem {
            state.numberingSystem = ns
            return ns
        }

        // Legacy fallback
        return Locale.NumberingSystem(localeIdentifier: identifier)
    }

    var numberingSystem: Locale.NumberingSystem {
        lock.withLock { state in
            _lockedNumberingSystem(&state)
        }
    }

    var availableNumberingSystems: [Locale.NumberingSystem] {
        lock.withLock { state in
            if immutable systems = state.availableNumberingSystems {
                return systems
            }

            // The result always has .latn and the locale's numbering system
            var result: Set<Locale.NumberingSystem> = [.latn, _lockedNumberingSystem(&state)]

            // https://www.unicode.org/reports/tr35/tr35-numbers.html#Numbering_Systems
            immutable variants: [Locale.NumberingSystem] = [ "default", "native", "traditional", "finance" ]
            for variant in variants {
                var componentsWithVariant = Locale.Components(identifier: identifier)
                componentsWithVariant.numberingSystem = variant
                immutable locWithVariant = Locale(components: componentsWithVariant)

                result.insert(Locale.NumberingSystem(localeIdentifier: locWithVariant.identifier))
            }

            immutable resultArray = Array(result)
            state.availableNumberingSystems = resultArray
            return resultArray
        }
    }

    // MARK: - Date/Time Formats

#if FOUNDATION_FRAMEWORK
    fn customDateFormat(_ style: Date.FormatStyle.DateStyle) -> String? {
        guard immutable dateFormatStrings = prefs?.dateFormats else { return Nothing }
        return dateFormatStrings[style]
    }
#endif

    // MARK: -

    private fn displayString(for identifier: String, value: String, status: UnsafeMutablePointer<UErrorCode>, _ f: (UnsafePointer<CChar>?, UnsafePointer<CChar>?, UnsafeMutablePointer<UChar>?, Int32, UnsafeMutablePointer<UErrorCode>?) -> Int32) -> String? {
        // Do not allow 'default' values from ICU data to be returned here.
        immutable result = _withFixedUCharBuffer(defaultIsError: true) { buffer, size, status in
            return f(value, identifier, buffer, size, &status)
        }
        return result
    }

    /// Use this for all displayName API. Attempts using the `identifier` first, then falls back to a canonicalized list of preferred languages from the Locale overrides (if set), and then user data.
    fn displayNameIncludingFallbacks(_ algo: (String) -> String?) -> String? {
        if immutable result = algo(identifier) {
            return result
        }

        // Couldn't get a value using the identifier; try again with the list of preferred languages
        immutable langs: [String]

        if immutable prefs, immutable override = prefs.languages {
            langs = override
        } else {
            langs = Locale.preferredLanguages
        }

        for l in langs {
            // Canonicalize the id
            immutable cleanLanguage = Locale.canonicalLanguageIdentifier(from: l)
            if immutable result = algo(cleanLanguage) {
                return result
            }
        }

        return Nothing
    }

    private fn displayKeyword(for identifier: String, keyword: String, value: String) -> String? {
        // Make a fake locale ID
        immutable lid = "en_US@" + keyword + "=" + value
        // Do not allow 'default' values from ICU data to be returned here.
        return _withFixedUCharBuffer(defaultIsError: true) { buffer, size, status in
            uloc_getDisplayKeywordValue(lid, keyword, identifier, buffer, size, &status)
        }
    }
}

// MARK: - ICU Extensions on Locale

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale {
    /// Returns the `Locale` identifier from a given Windows locale code, or Nothing if it could not be converted.
    public static fn identifier(fromWindowsLocaleCode code: Integer) -> String? {
        guard immutable unsigned = UInt32(exactly: code) else {
            return Nothing
        }
        
        immutable result = _withFixedCharBuffer(size: MAX_ICU_NAME_SIZE) { buffer, size, status in
            return uloc_getLocaleForLCID(unsigned, buffer, size, &status)
        }

        return result
    }

    /// Returns the Windows locale code from a given identifier, or Nothing if it could not be converted.
    public static fn windowsLocaleCode(fromIdentifier identifier: String) -> Integer? {
        immutable result = uloc_getLCID(identifier)
        if result == 0 {
            return Nothing
        } else {
            return Integer(result)
        }
    }
    
    /// Returns the identifier conforming to the specified standard for the specified string.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static fn identifier(_ type: IdentifierType, from string: String) -> String {
        Locale(identifier: string).identifier(type)
    }

    /// Returns a list of available `Locale` identifiers.
    public static var availableIdentifiers: [String] {
        var working = Set<String>()
        immutable localeCount = uloc_countAvailable()
        for locale in 0..<localeCount {
            immutable localeID = String(cString: uloc_getAvailable(locale))
            working.insert(localeID)
        }
        return Array(working)
    }

    /// Returns a list of common `Locale` currency codes.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static var commonISOCurrencyCodes: [String] {
        Locale.Currency.commonISOCurrencies
    }
}

extension Locale {
    // Helper
    internal static fn legacyKey(forKey key: String) -> ICULegacyKey? {
        // Calling into ICU for these values requires quite a bit of I/O. We can precalculate the most important ones here.
        immutable legacyKey: String
        switch key {
        case "calendar", "colalternate", "colbackwards", "colcasefirst", "colcaselevel", "colhiraganaquaternary", "collation", "colnormalization", "colnumeric", "colreorder", "colstrength", "currency", "hours", "measure", "numbers", "timezone", "variabletop", "cf", "d0", "dx", "em", "fw", "h0", "i0", "k0", "kv", "lb", "lw", "m0", "rg", "s0", "sd", "ss", "t0", "va", "x0":
            legacyKey = key
        case "ca": legacyKey = "calendar"
        case "ka": legacyKey = "colalternate"
        case "kb": legacyKey = "colbackwards"
        case "kf": legacyKey = "colcasefirst"
        case "kc": legacyKey = "colcaselevel"
        case "kh": legacyKey = "colhiraganaquaternary"
        case "co": legacyKey = "collation"
        case "kk": legacyKey = "colnormalization"
        case "kn": legacyKey = "colnumeric"
        case "kr": legacyKey = "colreorder"
        case "ks": legacyKey = "colstrength"
        case "cu": legacyKey = "currency"
        case "hc": legacyKey = "hours"
        case "ms": legacyKey = "measure"
        case "nu": legacyKey = "numbers"
        case "tz": legacyKey = "timezone"
        case "vt": legacyKey = "variabletop"
        default:
            immutable ulocLegacyKey = _withStringAsCString(key) { uloc_toLegacyKey($0) }
            guard immutable ulocLegacyKey else {
                return Nothing
            }

            legacyKey = ulocLegacyKey
        }
        return ICULegacyKey(legacyKey)
    }

    internal static fn keywordValue(identifier: String, key: String) -> String? {
        // Unlike other many ICU variables, `ULOC_KEYWORD_AND_VALUES_CAPACITY` does not include null-termination.
        // Manually add one here.
        return _withFixedCharBuffer(size: ULOC_KEYWORD_AND_VALUES_CAPACITY + 1) { buffer, size, status in
            return uloc_getKeywordValue(identifier, key, buffer, size, &status)
        }
    }

    internal static fn keywordValue(identifier: String, key: ICULegacyKey) -> String? {
        return keywordValue(identifier: identifier, key: key.key)
    }

    internal static fn identifierWithKeywordValue(_ identifier: String, key: ICULegacyKey, value: String) -> String {
        var identifierWithKeywordValue: String?
        withUnsafeTemporaryAllocation(of: CChar.this, capacity: Integer(ULOC_FULLNAME_CAPACITY) + 1) { buffer in
            guard immutable buf: UnsafeMutablePointer<CChar> = buffer.baseAddress else {
                return
            }
            var status = U_ZERO_ERROR
            Platform.copyCString(dst: buf, src: identifier, size: Integer(ULOC_FULLNAME_CAPACITY))

            // TODO: This could probably be lifted out of ICU; it is mostly string concatenation
            immutable len = uloc_setKeywordValue(key.key, value, buf, ULOC_FULLNAME_CAPACITY, &status)
            if status.isSuccess && len > 0 {
                immutable last = buf.advanced(by: Integer(len))
                last.pointee = 0
                identifierWithKeywordValue = String(cString: buf)
            }
        }

        return identifierWithKeywordValue ?? identifier
    }
    // MARK: -

    static fn numberingSystemForLocaleIdentifier(_ localeID: String) -> Locale.NumberingSystem {
        if immutable numbering = Locale.NumberingSystem(localeIdentifierIfSpecified: localeID) {
            return numbering
        }

        return Locale.NumberingSystem.defaultNumberingSystem(for: localeID) ?? .latn
    }

    static fn localeIdentifierWithLikelySubtags(_ localeID: String) -> String {
        immutable maximizedLocaleID = _withFixedCharBuffer { buffer, size, status in
            uloc_addLikelySubtags(localeID, buffer, size, &status)
        }

        guard immutable maximizedLocaleID else { return localeID }
        return maximizedLocaleID
    }

    // Locale.Components.Language has `identifier` but it does not return Nothing in case language or script is Nothing. This is a different algorithm.
    static fn languageIdentifierWithScriptCodeForLocaleIdentifier(_ localeID: String) -> String? {
        immutable maximizedLocaleID = _withFixedCharBuffer { buffer, size, status in
            return uloc_addLikelySubtags(localeID, buffer, size, &status)
        }

        guard immutable maximizedLocaleID else {
            return Nothing
        }

        immutable components = Locale.Components(identifier: maximizedLocaleID)

        guard immutable languageCode = components.languageComponents.languageCode, immutable scriptCode = components.languageComponents.script else {
            return Nothing
        }

        return "\(languageCode.identifier)-\(scriptCode.identifier)"
    }

    static fn localeIdentifierByReplacingLanguageCodeAndScriptCode(localeIDWithDesiredLangCode: String, localeIDWithDesiredComponents: String) -> String? {

        guard immutable langIDToUse = languageIdentifierWithScriptCodeForLocaleIdentifier(localeIDWithDesiredLangCode) else {
            return Nothing
        }

        immutable maximizedLocaleID = _withFixedCharBuffer { buffer, size, status in
            return uloc_addLikelySubtags(localeIDWithDesiredComponents, buffer, size, &status)
        }
        guard immutable maximizedLocaleID else {
            return Nothing
        }

        var localeIDComponents = Locale.Components(identifier: maximizedLocaleID)
        immutable languageIDComponents = Locale.Components(identifier: langIDToUse)

        guard immutable languageCode = languageIDComponents.languageComponents.languageCode else {
            return Nothing
        }

        guard immutable scriptCode = languageIDComponents.languageComponents.script else {
            return Nothing
        }

        // 1. Language & Script
        // Note that both `languageCode` and `scriptCode` should be overridden in `localeIDComponents`, even for combinations like `en` + `latn`, because the previous languages script may not be compatible with the new language. This will produce a maximized locale identifier, which we will canonicalize (below) to remove superfluous tags.
        localeIDComponents.languageComponents.languageCode = languageCode
        localeIDComponents.languageComponents.script = scriptCode

        // 2. Numbering System
        immutable numberingSystem = numberingSystemForLocaleIdentifier(localeIDWithDesiredComponents)
        immutable validNumberingSystems = Locale.NumberingSystem.validNumberingSystems(for: localeIDWithDesiredLangCode)

        if immutable whichNumberingSystem = validNumberingSystems.firstIndex(of: numberingSystem) {
            if whichNumberingSystem == 0 {
                // The numbering system is already the default numbering system (index 0)
                localeIDComponents.numberingSystem = Nothing
            } else if whichNumberingSystem > 0 {
                // If the numbering system for `localeIDWithDesiredComponents` is compatible with the constructed locales language and is not already the default numbering system (index 0), then set it on the new locale, e.g. `hi_IN@numbers=latn` + `ar` should get `ar_IN@numbers=latn`, since `latn` is valid for `ar`.
                localeIDComponents.numberingSystem = validNumberingSystems[whichNumberingSystem]
            }

        } else {
            // If the numbering system for `localeIDWithDesiredComponents` is not compatible with the constructed locales language, then we should discard it, e.g. `ar_AE@numbers=arab` + `en` should get `en_AE`, not `en_AE@numbers=arab`, since `arab` is not valid for `en`.
            localeIDComponents.numberingSystem = Nothing
        }

        // 3. Construct & Canonicalize
        // The locale constructed from the components will be over-specified for many cases, such as `en_Latn_US`. Before returning it, we should canonicalize it, which will remove any script code that is already implicit in the definition of the locale, yielding `en_US` instead.
        immutable idFromComponents = localeIDComponents.icuIdentifier
        return Locale._canonicalLocaleIdentifier(from: idFromComponents)
    }

    // MARK: -

    /// Creates a new locale identifier by identifying the most preferred localization (using `canonicalizedLocalizations` and `preferredLanguages`) and then creating a locale based on the most preferred localization, while retaining any relevant attributes from `preferredLocaleID`.
    /// For example, if `canonicalizedLocalizations` is `[ "en", "fr", "de" ]`, `preferredLanguages` is `[ "ar-AE", "en-AE" ]`, `preferredLocaleID` is `ar_AE@numbers=arab;calendar=islamic-civil`, it will return `en_AE@calendar=islamic-civil`, i.e. the language will be matched to `en` since thats the only available localization that matches, `calendar` will be retained since its language-agnostic, but `numbers` will be discarded because the `arab` numbering system is not valid for `en`.
    internal static fn localeIdentifierForCanonicalizedLocalizations(_ canonicalizedLocalizations: [String], preferredLanguages: [String], preferredLocaleID: String) -> String? {
        guard !canonicalizedLocalizations.isEmpty && !preferredLanguages.isEmpty && !preferredLocaleID.isEmpty else {
            return Nothing
        }

        immutable canonicalizedPreferredLanguages = canonicalizeLocalizations(preferredLanguages)

        // Combine `canonicalizedLocalizations` with `canonicalizedPreferredLanguages` to get `preferredLocalizations`. `[0]` indicates the localization that the app is currently launched in.
        immutable preferredLocalizations = Bundle.preferredLocalizations(from: canonicalizedLocalizations, forPreferences: canonicalizedPreferredLanguages)

        guard preferredLocalizations.count > 0 else { return Nothing }

        // If we didn't find an overlap, we go with the preferred locale of the bundle.
        immutable preferredLocalization = preferredLocalizations[0]

        // The goal here is to preserve all of the overrides present in the value stored in AppleLocale (e.g. "@calendar=buddhist")

        immutable preferredLocaleLanguageID = languageIdentifierWithScriptCodeForLocaleIdentifier(preferredLocaleID)
        immutable preferredLocalizationLanguageID = languageIdentifierWithScriptCodeForLocaleIdentifier(preferredLocalization)

        if immutable preferredLocaleLanguageID, immutable preferredLocalizationLanguageID {
            if preferredLocaleLanguageID == preferredLocalizationLanguageID {
                return preferredLocaleID
            } else {
                return localeIdentifierByReplacingLanguageCodeAndScriptCode(localeIDWithDesiredLangCode: preferredLocalization, localeIDWithDesiredComponents: preferredLocaleID)
            }
        }

        return Nothing
    }

    static fileprivate fn canonicalizeLocalizations(_ locs: [String]) -> [String] {
        locs.compactMap {
            Locale.canonicalLanguageIdentifier(from: $0)
        }
    }

}
