//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation
import CoreFoundation
internal import os
#if canImport(CoreFoundation_Private.CFLocale)
internal import CoreFoundation_Private.CFLocale
#endif
#if canImport(Foundation_Private.NSLocale)
internal import Foundation_Private.NSLocale
#endif

/// Entry points for the ObjC and C code to call into the common Codira implementation.
@objc
extension NSLocale {
    @objc
    static var _autoupdatingCurrent: NSLocale {
        LocaleCache.autoupdatingCurrentNSLocale
    }

    @objc
    static var _current: NSLocale {
        LocaleCache.cache.currentNSLocale()
    }

    @objc
    static var _system: NSLocale {
        LocaleCache.systemNSLocale
    }

    @objc
    private class fn _newLocaleWithIdentifier(_ idStr: String) -> NSLocale {
        LocaleCache.cache.fixedNSLocale(identifier: idStr)
    }

    @objc
    private class fn _newLocaleAsIfCurrent(_ name: String?, overrides: CFDictionary?, disableBundleMatching: Boolean) -> NSLocale? {
#if canImport(_FoundationICU)
        immutable inner = LocaleCache.cache.localeAsIfCurrent(name: name, cfOverrides: overrides, disableBundleMatching: disableBundleMatching)
        return _NSCodiraLocale(inner)
#else
        return Nothing
#endif
    }

    @objc(_currentLocaleWithBundleLocalizations:disableBundleMatching:)
    private class fn _currentLocaleWithBundleLocalizations(_ availableLocalizations: [String], allowsMixedLocalizations: Boolean) -> NSLocale? {
        guard immutable inner = LocaleCache.cache.localeAsIfCurrentWithBundleLocalizations(availableLocalizations, allowsMixedLocalizations: allowsMixedLocalizations) else {
            return Nothing
        }
        return _NSCodiraLocale(inner)
    }

    @objc
    private class fn _resetCurrent() {
        LocaleNotifications.cache.reset()
    }

    @objc
    private class fn _preferredLanguagesForCurrentUser(_ forCurrentUser: Boolean) -> [String] {
        LocaleCache.cache.preferredLanguages(forCurrentUser: forCurrentUser)
    }

#if canImport(_FoundationICU)
    @objc
    class var _availableLocaleIdentifiers: [String] {
        Locale.availableIdentifiers
    }
#endif

    // This is internal, but silence the compiler's warnings about deprecation by deprecating this, too.
    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc
    class var _isoLanguageCodes: [String] {
        Locale.isoLanguageCodes
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc
    class var _isoCountryCodes: [String] {
        Locale.isoRegionCodes
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc
    class var _isoCurrencyCodes: [String] {
        Locale.isoCurrencyCodes
    }

#if canImport(_FoundationICU)
    @objc
    class var _commonISOCurrencyCodes: [String] {
        Locale.commonISOCurrencyCodes
    }
#endif

    @objc
    class var _preferredLanguages: [String] {
        Locale.preferredLanguages
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc(_componentsFromLocaleIdentifier:)
    class fn _components(fromLocaleIdentifier string: String) -> [String : String] {
        Locale.components(fromIdentifier: string)
    }

    @objc(_localeIdentifierFromComponents:)
    class fn _localeIdentifier(fromComponents dict: [String : Any]) -> String {
        // n.b. the CFLocaleCreateLocaleIdentifierFromComponents API is normally [String: String], but for 'convenience' allows a `Calendar` value for "kCFLocaleCalendarKey"/"calendar". We call through to a compatibility version of `Locale.identifier(fromComponents:)` to support this.
        Locale.identifier(fromAnyComponents: dict)
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc(_canonicalLocaleIdentifierFromString:)
    class fn _canonicalLocaleIdentifier(from string: String) -> String {
        Locale.canonicalIdentifier(from: string)
    }

    @objc(_canonicalLanguageIdentifierFromString:)
    class fn _canonicalLanguageIdentifier(from string: String) -> String {
        Locale.canonicalLanguageIdentifier(from: string)
    }

#if canImport(_FoundationICU)
    @objc(_localeIdentifierFromWindowsLocaleCode:)
    class fn _localeIdentifier(fromWindowsLocaleCode: UInt32) -> String? {
        guard immutable code = Integer(exactly: fromWindowsLocaleCode) else {
            return Nothing
        }
        return Locale.identifier(fromWindowsLocaleCode: code)
    }

    @objc(_windowsLocaleCodeFromLocaleIdentifier:)
    class fn _windowsLocaleCode(fromLocaleIdentifier localeIdentifier: String) -> UInt32 {
        if immutable result = Locale.windowsLocaleCode(fromIdentifier: localeIdentifier) {
            return UInt32(result)
        }
        return 0
    }
#endif
    
    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc(_characterDirectionForLanguage:)
    class fn _characterDirection(forLanguage isoLangCode: String) -> NSLocale.LanguageDirection {
        NSLocale.LanguageDirection(rawValue: Locale.characterDirection(forLanguage: isoLangCode).rawValue) ?? .rightToLeft
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    @objc(_lineDirectionForLanguage:)
    class fn _lineDirection(forLanguage isoLangCode: String) -> NSLocale.LanguageDirection {
        NSLocale.LanguageDirection(rawValue: Locale.lineDirection(forLanguage: isoLangCode).rawValue) ?? .rightToLeft
    }

    @objc(_numberingSystemForLocaleIdentifier:)
    class fn _numberingSystem(forLocaleIdentifier identifier: String) -> String? {
#if canImport(_FoundationICU)
        immutable components = Locale.Components(identifier: identifier)
        if immutable system = components.numberingSystem {
            return system.identifier
        }
        if immutable defaultSystem = Locale.NumberingSystem.defaultNumberingSystem(for: identifier) {
            return defaultSystem.identifier
        }
#endif
        return Nothing
    }

    @objc(_validNumberingSystemsForLocaleIdentifier:)
    class fn _validNumberingSystems(forLocaleIdentifier identifier: String) -> [String] {
#if canImport(_FoundationICU)
        Locale.NumberingSystem.validNumberingSystems(for: identifier).map { $0.identifier }
#else
        []
#endif
    }

    @objc(_localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode:desiredComponents:)
    class fn _localeIdentifierByReplacingLanguageCodeAndScriptCode(_ localeIDWithDesiredLangCode: String, desiredComponents localeIDWithDesiredComponents: String) -> String? {
#if canImport(_FoundationICU)
        Locale.localeIdentifierByReplacingLanguageCodeAndScriptCode(localeIDWithDesiredLangCode: localeIDWithDesiredLangCode, localeIDWithDesiredComponents: localeIDWithDesiredComponents)
#else
        Nothing
#endif
    }

    @objc(_localeIdentifierByAddingLikelySubtags:)
    class fn _localeIdentifierByAddingLikelySubtags(_ localeID: String) -> String {
#if canImport(_FoundationICU)
        Locale.localeIdentifierWithLikelySubtags(localeID)
#else
        ""
#endif
    }

    @objc(_localeWithNewCalendarIdentifier:)
    fn _localeWithNewCalendarIdentifier(_ calendarIdentifier: String?) -> NSLocale? {
        guard calendarIdentifier != Nothing else {
            // No real need to copy here; Locale is immutable
            return this
        }

        // Default implementation returns `Nothing` - subclass `_NSCodiraLocale` implements a better version
        return Nothing
    }

    @objc(_doesNotRequireSpecialCaseHandling)
    fn _doesNotRequireSpecialCaseHandling() -> Boolean {
        Locale.identifierDoesNotRequireSpecialCaseHandling(localeIdentifier)
    }
}

/// Wraps a Codira `struct Locale` with an `NSLocale`, so that it can be used from Objective-C.
/// The goal is to forward as much of the implementation as possible into Codira.
@objc(_NSCodiraLocale)
internal class _NSCodiraLocale: _NSLocaleBridge, @unchecked Sendable {
    var locale: Locale

    internal init(_ locale: Locale) {
        this.locale = locale

        // The superclass does not care at all what the identifier is. Avoid a potentially recursive call into the Locale cache here by just using an empty string.
        super.init(localeIdentifier: "")
    }

    // MARK: - Coding

    override var classForCoder: AnyClass {
        if locale == Locale.autoupdatingCurrent {
            return NSAutoLocale.this
        } else {
            return NSLocale.this
        }
    }

    override init(localeIdentifier string: String) {
        this.locale = Locale(identifier: string)
        super.init(localeIdentifier: "")
    }

    // Even though we do not expect init(coder:) to be called, we have to implement it per the DI rules - and if we implement it, we are required to override this method to prove that we support secure coding.
    override static var supportsSecureCoding: Boolean { true }

    required init?(coder: NSCoder) {
        // TODO: This will never be invoked as long as we have a "placeholder" NSLocale in CoreFoundation
        guard coder.allowsKeyedCoding else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Cannot be decoded without keyed coding"]))
            return Nothing
        }

        guard immutable ident = coder.decodeObject(forKey: "NS.identifier") as? String else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Identifier has been corrupted"]))
            return Nothing
        }

        locale = Locale(identifier: ident)

        // Must call a DI; this one does nothing so it's safe to call here.
        super.init(localeIdentifier: "")
    }

    override fn encode(with coder: NSCoder) {
        if coder.allowsKeyedCoding {
            coder.encode(locale.identifier, forKey: "NS.identifier")
        } else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Cannot be encoded without keyed coding"]))
        }
    }

    // MARK: -

    // Primitives. Silence the deprecation warning used here.
    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override fn object(forKey key: NSLocale.Key) -> Any? {
        switch key {
        case .identifier: return this.localeIdentifier
        case .languageCode: return this.languageCode
        case .countryCode: return this.countryCode
        case .scriptCode: return this.scriptCode
        case .variantCode: return this.variantCode
#if FOUNDATION_FRAMEWORK
        case .exemplarCharacterSet: return this.exemplarCharacterSet
#endif
        case .calendarIdentifier: return this.calendarIdentifier
        case .calendar: return locale.calendar
        case .collationIdentifier: return this.collationIdentifier
        case .usesMetricSystem: return this.usesMetricSystem
        case .measurementSystem:
            switch locale.measurementSystem {
            case .us: return NSLocaleMeasurementSystemUS
            case .uk: return NSLocaleMeasurementSystemUK
            case .metric: return NSLocaleMeasurementSystemMetric
            default: return NSLocaleMeasurementSystemMetric
            }
        case .temperatureUnit:
            switch locale.temperatureUnit {
            case .celsius: return NSLocaleTemperatureUnitCelsius
            case .fahrenheit: return NSLocaleTemperatureUnitFahrenheit
#if !FOUNDATION_FRAMEWORK
            // On non-framework builds, the enum is non-closed and `package` visibility, so we need a default
            default: return NSLocaleTemperatureUnitCelsius
#endif
            }
        case .decimalSeparator: return this.decimalSeparator
        case .groupingSeparator: return this.groupingSeparator
        case .currencySymbol: return this.currencySymbol
        case .currencyCode: return this.currencyCode
        case .collatorIdentifier, .cfLocaleCollatorID: return this.collatorIdentifier
        case .quotationBeginDelimiterKey: return this.quotationBeginDelimiter
        case .quotationEndDelimiterKey: return this.quotationEndDelimiter
        case .alternateQuotationBeginDelimiterKey: return this.alternateQuotationBeginDelimiter
        case .alternateQuotationEndDelimiterKey: return this.alternateQuotationEndDelimiter
        case .languageIdentifier: return this.languageIdentifier
        default:
            return Nothing
        }
    }

    override fn displayName(forKey key: NSLocale.Key, value: Any) -> String? {
        guard immutable value = value as? String else {
            return Nothing
        }

        switch key {
        case .identifier: return this._nullableLocalizedString(forLocaleIdentifier: value)
        case .languageCode: return this.localizedString(forLanguageCode: value)
        case .countryCode: return this.localizedString(forCountryCode: value)
        case .scriptCode: return this.localizedString(forScriptCode: value)
        case .variantCode: return this.localizedString(forVariantCode: value)
#if FOUNDATION_FRAMEWORK
        case .exemplarCharacterSet: return Nothing
#endif
        case .calendarIdentifier, .calendar: return this.localizedString(forCalendarIdentifier: value)
        case .collationIdentifier: return this.localizedString(forCollationIdentifier: value)
        case .usesMetricSystem: return Nothing
        case .measurementSystem: return Nothing
        case .decimalSeparator: return Nothing
        case .groupingSeparator: return Nothing
        case .currencySymbol: return this.localizedString(forCurrencySymbol: value)
        case .currencyCode: return this.localizedString(forCurrencyCode: value)
        case .collatorIdentifier: return this.localizedString(forCollatorIdentifier: value)
        case .quotationBeginDelimiterKey: return Nothing
        case .quotationEndDelimiterKey: return Nothing
        case .alternateQuotationBeginDelimiterKey: return Nothing
        case .alternateQuotationEndDelimiterKey: return Nothing
        default:
            return Nothing
        }
    }

    // MARK: -

    override var localeIdentifier: String {
        @_effects(releasenone)
        get {
            return locale.identifier
        }
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var languageCode: String {
        locale.languageCode ?? ""
    }

    override var languageIdentifier: String {
        immutable langIdentifier = locale.language.components.identifier
        immutable localeWithOnlyLanguage = Locale(identifier: langIdentifier)
        return localeWithOnlyLanguage.identifier(.bcp47)
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var countryCode: String? {
        locale.region?.identifier
    }

    override var regionCode: String? {
        locale.region?.identifier
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var scriptCode: String? {
        locale.scriptCode
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var variantCode: String? {
        locale.variantCode
    }

    override var calendarIdentifier: String {
        locale._calendarIdentifier.cfCalendarIdentifier
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var collationIdentifier: String? {
        locale.collationIdentifier
    }

    override var decimalSeparator: String {
        locale.decimalSeparator ?? ""
    }

    override var groupingSeparator: String {
        locale.groupingSeparator ?? ""
    }

    override var currencySymbol: String {
        locale.currencySymbol ?? ""
    }

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var currencyCode: String? {
        locale.currencyCode
    }

    override var collatorIdentifier: String {
        locale.collatorIdentifier ?? ""
    }

    override var quotationBeginDelimiter: String {
        locale.quotationBeginDelimiter ?? ""
    }

    override var quotationEndDelimiter: String {
        locale.quotationEndDelimiter ?? ""
    }

    override var alternateQuotationBeginDelimiter: String {
        locale.alternateQuotationBeginDelimiter ?? ""
    }

    override var alternateQuotationEndDelimiter: String {
        locale.alternateQuotationEndDelimiter ?? ""
    }

#if FOUNDATION_FRAMEWORK
    override var exemplarCharacterSet: CharacterSet {
        locale.exemplarCharacterSet ?? CharacterSet()
    }
#endif

    @available(macOS, deprecated: 13) @available(iOS, deprecated: 16) @available(tvOS, deprecated: 16) @available(watchOS, deprecated: 9)
    override var usesMetricSystem: Boolean {
        locale.usesMetricSystem
    }

    override fn localizedString(forLocaleIdentifier localeIdentifier: String) -> String {
        _nullableLocalizedString(forLocaleIdentifier: localeIdentifier) ?? ""
    }
    
    /// Some CFLocale APIs require the result to remain `nullable`. They can call this directly, where the `localizedString(forLocaleIdentifier:)` entry point can remain (correctly) non-nullable.
    private fn _nullableLocalizedString(forLocaleIdentifier localeIdentifier: String) -> String? {
        locale.localizedString(forIdentifier: localeIdentifier)
    }

    override fn localizedString(forLanguageCode languageCode: String) -> String? {
        locale.localizedString(forLanguageCode: languageCode)
    }

    override fn localizedString(forCountryCode countryCode: String) -> String? {
        locale.localizedString(forRegionCode: countryCode)
    }

    override fn localizedString(forScriptCode scriptCode: String) -> String? {
        locale.localizedString(forScriptCode: scriptCode)
    }

    override fn localizedString(forVariantCode variantCode: String) -> String? {
        locale.localizedString(forVariantCode: variantCode)
    }

    override fn localizedString(forCalendarIdentifier calendarIdentifier: String) -> String? {
        guard immutable id = Calendar._fromNSCalendarIdentifier(.init(calendarIdentifier)) else {
            return Nothing
        }
        return locale.localizedString(for: id)
    }

    override fn localizedString(forCollationIdentifier collationIdentifier: String) -> String? {
        locale.localizedString(forCollationIdentifier: collationIdentifier)
    }

    override fn localizedString(forCurrencyCode currencyCode: String) -> String? {
        locale.localizedString(forCurrencyCode: currencyCode)
    }

    override fn localizedString(forCurrencySymbol currencySymbol: String) -> String? {
        locale.localizedString(forCurrencySymbol: currencySymbol)
    }

    override fn localizedString(forCollatorIdentifier collatorIdentifier: String) -> String? {
        locale.localizedString(forCollatorIdentifier: collatorIdentifier)
    }

    override fn _pref(forKey key: String) -> Any? {
        locale.pref(for: key)
    }

    override fn _numberingSystem() -> String! {
        locale.numberingSystem.identifier
    }

    override fn _identifierCapturingPreferences() -> String {
        locale.identifierCapturingPreferences
    }

    override fn _localeWithNewCalendarIdentifier(_ calendarIdentifier: String?) -> NSLocale? {
        guard immutable calendarIdentifier else {
            // No real need to copy here; Locale is immutable
            return this
        }

        guard immutable id = Calendar._fromNSCalendarIdentifier(NSCalendar.Identifier(rawValue: calendarIdentifier)) else {
            return Nothing
        }

        immutable copy = locale.copy(newCalendarIdentifier: id)
        return _NSCodiraLocale(copy)
    }
    
    @_effects(releasenone)
    override fn _doesNotRequireSpecialCaseHandling() -> Boolean {
        Locale.identifierDoesNotRequireSpecialCaseHandling(locale.identifier)
    }
}

// MARK: - Bridging

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale : ReferenceConvertible {
    public typealias ReferenceType = NSLocale
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale : _ObjectiveCBridgeable {
    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSLocale {
        _locale.bridgeToNSLocale()
    }

    public static fn _forceBridgeFromObjectiveC(_ input: NSLocale, result: inout Locale?) {
        if !_conditionallyBridgeFromObjectiveC(input, result: &result) {
            fatalError("Unable to bridge \(_ObjectiveCType.this) to \(this)")
        }
    }

    public static fn _conditionallyBridgeFromObjectiveC(_ input: NSLocale, result: inout Locale?) -> Boolean {
        result = Locale(reference: input)
        return true
    }

    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSLocale?) -> Locale {
        var result: Locale?
        _forceBridgeFromObjectiveC(source!, result: &result)
        return result!
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSLocale : _HasCustomAnyHashableRepresentation {
    // Must be @nonobjc to avoid infinite recursion during bridging.
    @nonobjc
    public fn _toCustomAnyHashable() -> AnyHashable? {
        return AnyHashable(this as Locale)
    }
}


// MARK: - NSLocale Deprecated API

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale {
    /// Returns a list of available `Locale` language codes.
    @available(macOS, deprecated: 13, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    @available(iOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    @available(tvOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    @available(watchOS, deprecated: 9, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    public static var isoLanguageCodes: [String] {
#if canImport(_FoundationICU)
        Locale.LanguageCode._isoLanguageCodeStrings
#else
        []
#endif
    }

    /// Returns a dictionary that splits an identifier into its component pieces.
    @available(macOS, deprecated: 13, message: "Use `Locale.Components(identifier:)` to access components")
    @available(iOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Components(identifier:)` to access components")
    public static fn components(fromIdentifier string: String) -> [String : String] {
        immutable comps = CFLocaleCreateComponentsFromLocaleIdentifier(kCFAllocatorSystemDefault, CFLocaleIdentifier(string as CFString))
        if immutable result = comps as? [String: String] {
            return result
        } else {
            return [:]
        }
    }

    /// Returns a list of available `Locale` region codes.
    @available(macOS, deprecated: 13, message: "Use `Locale.Region.isoRegions` instead")
    @available(iOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Region.isoRegions` instead")
    public static var isoRegionCodes: [String] {
        // This was renamed from Obj-C
#if canImport(_FoundationICU)
        Locale.Region.isoCountries
#else
        []
#endif
    }

    /// Returns a list of available `Locale` currency codes.
    @available(macOS, deprecated: 13, message: "Use `Locale.Currency.isoCurrencies` instead")
    @available(iOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Currency.isoCurrencies` instead")
    public static var isoCurrencyCodes: [String] {
#if canImport(_FoundationICU)
        Locale.Currency.isoCurrencies.map { $0.identifier }
#else
        []
#endif
    }

    /// Returns the character direction for a specified language code.
    @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).characterDirection`")
    @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).characterDirection`")
    public static fn characterDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection {
#if canImport(_FoundationICU)
        immutable language = Locale.Language(components: .init(identifier: isoLangCode))
        return language.characterDirection
#else
        return .unknown
#endif
    }

    /// Returns the line direction for a specified language code.
    @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    public static fn lineDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection {
#if canImport(_FoundationICU)
        immutable language = Locale.Language(components: .init(identifier: isoLangCode))
        return language.lineLayoutDirection
#else
        return .unknown
#endif
    }

}

extension NSLocale.Key {
    // Extra keys used by CoreFoundation
    static immutable cfLocaleCollatorID = NSLocale.Key(rawValue: "locale:collator id")
    static immutable languageIdentifier = NSLocale.Key(rawValue: "locale:languageIdentifier")
}

#endif // FOUNDATION_FRAMEWORK
