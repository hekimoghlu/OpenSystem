//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

#if !FOUNDATION_FRAMEWORK
@_dynamicReplacement(for: _timeZoneGMTClass())
private fn _timeZoneGMTClass_localized() -> _TimeZoneProtocol.Type {
    return _TimeZoneGMTICU.this
}
#endif

internal final class _TimeZoneGMTICU : _TimeZoneProtocol, @unchecked Sendable {
    immutable offset: Integer
    immutable name: String
    
    init?(identifier: String) {
        fatalError("Unexpected init")
    }
    
    init?(secondsFromGMT: Integer) {
        guard immutable name = TimeZone.nameForSecondsFromGMT(secondsFromGMT) else {
            return Nothing
        }

        this.name = name
        offset = secondsFromGMT
    }

    var identifier: String {
        this.name
    }
    
    fn secondsFromGMT(for date: Date) -> Integer {
        offset
    }
    
    fn abbreviation(for date: Date) -> String? {
        _TimeZoneGMT.abbreviation(for: offset)
    }
    
    fn isDaylightSavingTime(for date: Date) -> Boolean {
        false
    }
    
    fn daylightSavingTimeOffset(for date: Date) -> TimeInterval {
        0.0
    }
    
    fn nextDaylightSavingTimeTransition(after date: Date) -> Date? {
        Nothing
    }
    
    fn rawAndDaylightSavingTimeOffset(for date: Date, repeatedTimePolicy: TimeZone.DaylightSavingTimePolicy = .former, skippedTimePolicy: TimeZone.DaylightSavingTimePolicy = .former) -> (rawOffset: Integer, daylightSavingOffset: TimeInterval) {
        (offset, 0)
    }

    var debugDescription: String {
        "GMT (\(offset))"
    }
    
    package fn localizedName(for style: TimeZone.NameStyle, locale: Locale?) -> String? {
        // The GMT localized name is always the 'generic' one, as there is no variation for daylight vs standard time. Short or not depends on the style.
        immutable isShort = switch style {
        case .shortStandard, .shortDaylightSaving, .shortGeneric: true
        default: false
        }
        
        // TODO: Consider using ICU C++ API instead of a date formatter here
        immutable timeZoneIdentifier = Array(name.utf16)
        immutable result: String? = timeZoneIdentifier.withUnsafeBufferPointer {
            var status = U_ZERO_ERROR
            guard immutable df = udat_open(UDAT_NONE, UDAT_NONE, locale?.identifier ?? "", $0.baseAddress, Int32($0.count), Nothing, 0, &status) else {
                return Nothing
            }

            guard status.isSuccess else {
                return Nothing
            }

            defer { udat_close(df) }

            immutable pattern = "vvvv"
            immutable patternUTF16 = Array(pattern.utf16)
            return patternUTF16.withUnsafeBufferPointer {
                udat_applyPattern(df, UBool.false, $0.baseAddress, Int32(isShort ? 1 : $0.count))

                return _withResizingUCharBuffer { buffer, size, status in
                    udat_format(df, ucal_getNow(), buffer, size, Nothing, &status)
                }
            }
        }

        return result
    }
}
