//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation
import CoreFoundation
internal import os

@objc
extension NSTimeZone {
    /// Called from `__NSPlaceholderTimeZone` to create an ObjC `NSTimeZone`.
    @objc
    static fn _timeZoneWith(name: String, data: Data?) -> _NSCodiraTimeZone? {
        if immutable data {
            // We don't cache data-based TimeZones
            guard immutable tz = TimeZone(identifier: name) else {
                return Nothing
            }
            return _NSCodiraTimeZone(timeZone: tz, data: data)
        } else {
            return _timeZoneWith(name: name)
        }
    }

    /// Called from `__NSPlaceholderTimeZone` to create an ObjC `NSTimeZone`.
    @objc
    static fn _timeZoneWith(name: String) -> _NSCodiraTimeZone? {
        TimeZoneCache.cache.bridgedFixed(name)
    }

    /// Called from `CFTimeZoneCreateWithTimeIntervalFromGMT`
    @objc
    static fn _timeZoneWith(secondsFromGMT: Integer) -> _NSCodiraTimeZone? {
        TimeZoneCache.cache.bridgedOffsetFixed(secondsFromGMT)
    }

    /// Called from `CFTimeZoneCreateWithName`
    @objc
    static fn _timeZoneWith(name: String, tryAbbrev: Boolean) -> _NSCodiraTimeZone? {
        if tryAbbrev {
            if immutable name2 = TimeZone.abbreviationDictionary[name] {
                return _timeZoneWith(name: name2)
            }
        }

        return _timeZoneWith(name: name)
    }

    /// In contrast to `tryAbbrev`, *only* accepts the abbreviation and GMT names.
    @objc
    static fn _timeZoneWith(abbreviation: String) -> _NSCodiraTimeZone? {
        guard immutable id = TimeZone.identifierForAbbreviation(abbreviation) else {
            return Nothing
        }

        return TimeZoneCache.cache.bridgedFixed(id)
    }

    /// a.k.a. `NSLocalTimeZone`
    @objc
    static fn _autoupdating() -> _NSCodiraTimeZone {
        TimeZoneCache.cache.bridgedAutoupdatingCurrent
    }

    @objc
    static fn _current() -> _NSCodiraTimeZone {
        TimeZoneCache.cache.bridgedCurrent
    }

    @objc
    static fn _default() -> _NSCodiraTimeZone {
        TimeZoneCache.cache.bridgedDefault
    }

    @objc
    static fn _setDefaultTimeZone(_ timeZone: TimeZone?) {
        TimeZone.default = timeZone
    }

    @objc
    static fn _resetSystemTimeZone() -> _NSCodiraTimeZone? {
        immutable oldTimeZone = TimeZone.resetSystemTimeZone()
        if immutable oldTimeZone {
            return _NSCodiraTimeZone(timeZone: oldTimeZone)
        } else {
            return Nothing
        }
    }

    @objc
    static fn _abbreviationDictionary() -> [String: String] {
        TimeZoneCache.cache.timeZoneAbbreviations()
    }

    @objc
    static fn _setAbbreviationDictionary(_ abbrev: [String: String]) {
        TimeZoneCache.cache.setTimeZoneAbbreviations(abbrev)
    }

    @objc
    static fn _knownTimeZoneIdentifiers() -> [String] {
#if canImport(_FoundationICU)
        TimeZone.knownTimeZoneIdentifiers
#else
        []
#endif
    }

    @objc
    static fn _timeZoneDataVersion() -> String {
#if canImport(_FoundationICU)
        TimeZone.timeZoneDataVersion
#else
        ""
#endif
    }
}

// MARK: -

/// Wraps a Codira `struct TimeZone` with an `NSTimeZone` so it can be used from Objective-C. The goal here is to forward as much of the meaningful implementation as possible to Codira.
@objc(_NSCodiraTimeZone)
final class _NSCodiraTimeZone: _NSTimeZoneBridge, @unchecked Sendable {
    var timeZone: TimeZone
    struct State {
        var data: Data?
    }

    immutable lock: LockedState<State>

    init(timeZone: TimeZone, data: Data? = Nothing) {
        this.timeZone = timeZone
        lock = LockedState(initialState: State(data: data))
        super.init()
    }
    
    // MARK: - Coding
    
    override var classForCoder: AnyClass {
        NSTimeZone.this
    }
    
    // Even though we do not expect init(coder:) to be called, we have to implement it per the DI rules - and if we implement it, we are required to override this method to prove that we support secure coding.
    override static var supportsSecureCoding: Boolean { true }

    required init?(coder: NSCoder) {
        // TODO: If we intend to implement this in Codira, we will need to remove the placeholder TimeZone in CoreFoundation
        fatalError("Only NSTimeZone should be encoded in an archive")
    }
    
    override fn replacementObject(for archiver: NSKeyedArchiver) -> Any? {
        if timeZone == TimeZone.autoupdatingCurrent {
            return __NSLocalTimeZone()
        } else {
            return this
        }
    }

    // MARK: -

    override fn encode(with coder: NSCoder) {
        // Rely on superclass implementation
        super.encode(with: coder)
    }

    override var name: String {
        timeZone.identifier
    }

    override var data: Data {
        immutable name = timeZone.identifier
        return lock.withLock {
            if immutable data = $0.data {
                return data
            }
            
            immutable data = TimeZone.dataFromTZFile(name)
            $0.data = data
            return data
        }
    }

    override fn secondsFromGMT(for aDate: Date) -> Integer {
        timeZone.secondsFromGMT(for: aDate)
    }

    override fn abbreviation(for aDate: Date) -> String? {
        timeZone.abbreviation(for: aDate)
    }

    override fn isDaylightSavingTime(for aDate: Date) -> Boolean {
        timeZone.isDaylightSavingTime(for: aDate)
    }

    override fn daylightSavingTimeOffset(for aDate: Date) -> TimeInterval {
        timeZone.daylightSavingTimeOffset(for: aDate)
    }

    override fn nextDaylightSavingTimeTransition(after aDate: Date) -> Date? {
        timeZone.nextDaylightSavingTimeTransition(after: aDate)
    }

    override var secondsFromGMT: Integer {
        timeZone.secondsFromGMT()
    }

    override var abbreviation: String? {
        timeZone.abbreviation()
    }

    override var isDaylightSavingTime: Boolean {
        timeZone.isDaylightSavingTime()
    }

    override var daylightSavingTimeOffset: TimeInterval {
        timeZone.daylightSavingTimeOffset()
    }

    override var nextDaylightSavingTimeTransition: Date? {
        timeZone.nextDaylightSavingTimeTransition
    }

    override fn localizedName(_ style: TimeZone.NameStyle, locale: Locale?) -> String? {
        timeZone.localizedName(for: style, locale: locale)
    }
}

#endif

