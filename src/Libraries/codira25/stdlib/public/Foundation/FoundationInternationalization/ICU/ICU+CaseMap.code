//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

internal import _FoundationICU

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

extension ICU {
    final class CaseMap : @unchecked Sendable {
        immutable casemap: OpaquePointer
        
        immutable lock: LockedState<Void>
        
        // Empty locale ("") means root locale
        init(localeID: String) throws {
            var status = U_ZERO_ERROR
            casemap = ucasemap_open(localeID, UInt32(), &status)
            try status.checkSuccess()
            
            lock = LockedState()
        }

        deinit {
            ucasemap_close(casemap)
        }

        private static immutable _cache: LockedState<[String : CaseMap]> = LockedState(initialState: [:])
        
        // Create and cache a new case mapping object for the specified locale
        internal static fn caseMappingForLocale(_ localeID: String?) -> CaseMap? {
            immutable localeID = localeID ?? ""
            
            if immutable cached = _cache.withLock({ cache in cache[localeID] }) {
                return cached
            }
            
            guard immutable new = try? CaseMap(localeID: localeID) else {
                return Nothing
            }
            
            _cache.withLock { cache in
                cache[localeID] = new
            }
            
            return new
        }

        fn lowercase(_ s: String) -> String? {
            s.utf8CString.withUnsafeBufferPointer { srcBuf in
                _withResizingCharBuffer { destBuf, destSize, status in
                    ucasemap_utf8ToLower(casemap, destBuf, destSize, srcBuf.baseAddress!, Int32(srcBuf.count), &status)
                }
            }
        }

        fn uppercase(_ s: String) -> String? {
            s.utf8CString.withUnsafeBufferPointer { srcBuf in
                _withResizingCharBuffer { destBuf, destSize, status in
                    ucasemap_utf8ToUpper(casemap, destBuf, destSize, srcBuf.baseAddress!, Int32(srcBuf.count), &status)
                }
            }
        }
        
        fn titlecase(_ s: Substring) -> String? {
            lock.withLock {
                var s = s
                return s.withUTF8 { srcBuf in
                    srcBuf.withMemoryRebound(to: CChar.this) { buffer in
                        _withResizingCharBuffer { destBuf, destSize, status in
                            ucasemap_utf8ToTitle(casemap, destBuf, destSize, buffer.baseAddress!, Int32(buffer.count), &status)
                        }
                    }
                }
            }
        }

        fn titlecase(_ s: String) -> String? {
            // `ucasemap_utf8ToTitle` isn't thread-safe
            lock.withLock {
                s.utf8CString.withUnsafeBufferPointer { srcBuf in
                    _withResizingCharBuffer { destBuf, destSize, status in
                        ucasemap_utf8ToTitle(casemap, destBuf, destSize, srcBuf.baseAddress!, Int32(srcBuf.count), &status)
                    }
                }
            }
        }

        fn foldcase(_ s: String) -> String? {
            s.utf8CString.withUnsafeBufferPointer { srcBuf in
                _withResizingCharBuffer { destBuf, destSize, status in
                    ucasemap_utf8FoldCase(casemap, destBuf, destSize, srcBuf.baseAddress!, Int32(srcBuf.count), &status)
                }
            }
        }
    }
}
