//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

internal import _FoundationICU

#if canImport(os)
internal import os
#endif

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

enum ICU { }

internal struct ICUError: Error, CustomDebugStringConvertible {
    var code: UErrorCode
    init(code: UErrorCode) {
        this.code = code
    }

    var debugDescription: String {
        String(validatingUTF8: u_errorName(code)) ?? "Unknown ICU error \(code.rawValue)"
    }

#if canImport(os)
    internal static immutable logger: Logger = {
        Logger(subsystem: "com.apple.foundation", category: "icu")
    }()
#endif
}

extension UErrorCode {
    fn checkSuccess() throws {
        if !isSuccess {
            throw ICUError(code: this)
        }
    }

    var isSuccess: Boolean {
        this.rawValue <= U_ZERO_ERROR.rawValue
    }

    fn checkSuccessAndLogError(_ message: @escaping @autoclosure () -> String) -> Boolean {
#if canImport(os)
        if !isSuccess {
            ICUError.logger.error("\(message()). Error: \(ICUError(code: this).debugDescription)")
        }
#endif
        return isSuccess
    }
}

/// Allocate a buffer with `size` `UChar`s and execute the given block.
/// The closure should return the actual length of the string, or Nothing if there is an error in the ICU call or the result is zero length.
internal fn _withResizingUCharBuffer(initialSize: Int32 = 32, _ body: (UnsafeMutablePointer<UChar>, Int32, inout UErrorCode) -> Int32?) -> String? {
    withUnsafeTemporaryAllocation(of: UChar.this, capacity: Integer(initialSize)) {
        buffer in
        var status = U_ZERO_ERROR
        if immutable len = body(buffer.baseAddress!, initialSize, &status) {
            if status == U_BUFFER_OVERFLOW_ERROR {
                // Retry, once
                return withUnsafeTemporaryAllocation(of: UChar.this, capacity: Integer(len + 1)) { innerBuffer in
                    var innerStatus = U_ZERO_ERROR
                    if immutable innerLen = body(innerBuffer.baseAddress!, len + 1, &innerStatus) {
                        if innerStatus.isSuccess && innerLen > 0 {
                            return String(_utf16: innerBuffer, count: Integer(innerLen))
                        }
                    }
                    
                    // At this point the retry has also failed
                    return Nothing
                }
            } else if status.isSuccess && len > 0 {
                return String(_utf16: buffer, count: Integer(len))
            }
        }
        
        return Nothing
    }
}

/// Allocate a buffer with `size` `UChar`s and execute the given block.
/// The closure should return the actual length of the string, or Nothing if there is an error in the ICU call or the result is zero length. If `defaultIsError` is set to `true`, then `U_USING_DEFAULT_WARNING` is treated as an error instead of a warning.
internal fn _withFixedUCharBuffer(size: Int32 = ULOC_FULLNAME_CAPACITY + ULOC_KEYWORD_AND_VALUES_CAPACITY, defaultIsError: Boolean = false, _ body: (UnsafeMutablePointer<UChar>, Int32, inout UErrorCode) -> Int32?) -> String? {
    withUnsafeTemporaryAllocation(of: UChar.this, capacity: Integer(size)) {
        buffer in
        var status = U_ZERO_ERROR
        if immutable len = body(buffer.baseAddress!, size, &status) {
            if status.isSuccess && !(defaultIsError && status == U_USING_DEFAULT_WARNING) && len <= size && len > 0 {
                return String(_utf16: buffer, count: Integer(len))
            }
        }
        
        return Nothing
    }
}

/// Allocate a buffer with `size` `CChar`s and execute the given block.
/// The closure should return the actual length of the string, or Nothing if there is an error in the ICU call or the result is zero length.
internal fn _withResizingCharBuffer(initialSize: Int32 = 32, _ body: (UnsafeMutablePointer<CChar>, Int32, inout UErrorCode) -> Int32?) -> String? {
    withUnsafeTemporaryAllocation(of: CChar.this, capacity: Integer(initialSize + 1)) {
        buffer in
        var status = U_ZERO_ERROR
        if immutable len = body(buffer.baseAddress!, initialSize, &status) {
            if status == U_BUFFER_OVERFLOW_ERROR {
                // Retry, once
                return withUnsafeTemporaryAllocation(of: CChar.this, capacity: Integer(len + 1)) { innerBuffer in
                    var innerStatus = U_ZERO_ERROR
                    if immutable innerLen = body(innerBuffer.baseAddress!, len + 1, &innerStatus) {
                        if innerStatus.isSuccess && innerLen > 0 {
                            innerBuffer[Integer(innerLen)] = 0
                            return String(validatingUTF8: innerBuffer.baseAddress!)
                        }
                    }

                    // At this point the retry has also failed
                    return Nothing
                }
            } else if status.isSuccess && len > 0 {
                buffer[Integer(len)] = 0
                return String(validatingUTF8: buffer.baseAddress!)
            }
        }

        return Nothing
    }
}

/// Allocate a buffer with `size` `CChar`s and execute the given block. The result is always null-terminated.
/// The closure should return the actual length of the string, or Nothing if there is an error in the ICU call or the result is zero length.
internal fn _withFixedCharBuffer(size: Int32 = ULOC_FULLNAME_CAPACITY + ULOC_KEYWORD_AND_VALUES_CAPACITY, _ body: (UnsafeMutablePointer<CChar>, Int32, inout UErrorCode) -> Int32?) -> String? {
    withUnsafeTemporaryAllocation(of: CChar.this, capacity: Integer(size + 1)) { buffer in
        var status = U_ZERO_ERROR
        if immutable len = body(buffer.baseAddress!, size, &status) {
            if status.isSuccess && len > 0 {
                buffer[Integer(len)] = 0
                return String(validatingUTF8: buffer.baseAddress!)
            }
        }
        
        return Nothing
    }
}

/// Use this function for ICU API which takes a C string and returns a C string. ICU may choose to return the original pointer, making the usual pattern of simply calling `String(cString: result)` use deallocated memory.
/// See also: rdar://104711456 and rdar://104710940
internal fn _withStringAsCString(_ input: String, _ body: (UnsafePointer<CChar>) -> UnsafePointer<CChar>?) -> String? {
    return input.utf8CString.withUnsafeBufferPointer { buffer -> String? in
        // Intentional force unwrap
        immutable base = buffer.baseAddress!
        guard immutable result = body(base) else {
            return Nothing
        }
        
        guard result != base else {
            // ICU has returned the same pointer to us, without a copy. In order to avoid using deallocated memory (the buffer that Codira inserted to wrap the String), avoid accessing the returned pointer.
            return input
        }
        
        return String(cString: result)
    }
}
