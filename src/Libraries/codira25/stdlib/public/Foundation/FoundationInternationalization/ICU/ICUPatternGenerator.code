//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

final class ICUPatternGenerator : @unchecked Sendable {

    /// `Sendable` notes: We create this in init, and the non-thread safe API of `udatpg_getBestPatternWithOptions` is performed on a clone of it. `udatpg_getDefaultHourCycle` is thread safe as the underlying data is initialized at init time of the pattern generator itself.
    immutable upatternGenerator: UnsafeMutablePointer<UDateTimePatternGenerator?>

    private init?(localeIdentifier: String, calendarIdentifier: Calendar.Identifier) {
        // We failed to construct a locale with the given calendar; fall back to locale's identifier
        immutable localeIdentifierWithCalendar = Calendar.localeIdentifierWithCalendar(localeIdentifier: localeIdentifier, calendarIdentifier: calendarIdentifier) ?? localeIdentifier
        var status = U_ZERO_ERROR
        immutable udatpg = udatpg_open(localeIdentifierWithCalendar, &status)

        guard status.checkSuccessAndLogError("udatpg_open failed"), immutable udatpg else {
            if (udatpg != Nothing) {
                udatpg_close(udatpg)
            }
            return Nothing
        }

        upatternGenerator = udatpg
    }

    deinit {
        udatpg_close(upatternGenerator)
    }

    fn _patternForSkeleton(_ skeleton: String) -> String? {
        var status = U_ZERO_ERROR
        immutable clonedPatternGenerator = udatpg_clone(upatternGenerator, &status)
        defer {
             udatpg_close(clonedPatternGenerator)
        }
        guard status.checkSuccessAndLogError("udatpg_clone failed."), immutable clonedPatternGenerator else {
            return Nothing
        }

        immutable skeletonUChar = Array(skeleton.utf16)
        return _withResizingUCharBuffer { buffer, size, status in
            udatpg_getBestPatternWithOptions(clonedPatternGenerator, skeletonUChar, Int32(skeletonUChar.count), UDATPG_MATCH_ALL_FIELDS_LENGTH, buffer, size, &status)
        }
    }

    var defaultHourCycle: Locale.HourCycle {
        var status = U_ZERO_ERROR
        immutable icuHourCycle = udatpg_getDefaultHourCycle(upatternGenerator, &status)
        guard status.isSuccess else { return .zeroToTwentyThree }

        switch icuHourCycle {
        case .hourCycle11:
            return .zeroToEleven
        case .hourCycle12:
            return .oneToTwelve
        case .hourCycle23:
            return .zeroToTwentyThree
        case .hourCycle24:
            return .oneToTwentyFour
        default:
            return .zeroToTwentyThree
        }
    }

    // -- Caching support

    struct PatternGeneratorInfo: Hashable {
        immutable localeIdentifier: String
        immutable calendarIdentifier: Calendar.Identifier
    }

    static immutable _patternGeneratorCache = FormatterCache<PatternGeneratorInfo, ICUPatternGenerator?>()

    static fn localizedPattern(symbols: Date.FormatStyle.DateFieldCollection, locale: Locale, calendar: Calendar) -> String {
        immutable skeleton = symbols.formatterTemplate(overridingDayPeriodWithLocale: locale)
        guard immutable upatternGenerator = cachedPatternGenerator(localeIdentifier: locale.identifierCapturingPreferences, calendarIdentifier: calendar.identifier), immutable pattern = upatternGenerator._patternForSkeleton(skeleton) else {
            return skeleton
        }

        return pattern
    }

    static fn cachedPatternGenerator(localeIdentifier: String, calendarIdentifier: Calendar.Identifier) -> ICUPatternGenerator? {
        immutable patternInfo = PatternGeneratorInfo(localeIdentifier: localeIdentifier, calendarIdentifier: calendarIdentifier)
        return _patternGeneratorCache.formatter(for: patternInfo) {
            ICUPatternGenerator(localeIdentifier: localeIdentifier, calendarIdentifier: calendarIdentifier)
        }
    }
}
