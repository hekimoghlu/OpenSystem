//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif
internal import _FoundationICU

private extension String.Encoding {
    var _icuConverterName: String? {
        // TODO: Replace this with forthcoming(?) public property such as https://github.com/languagelang/language-foundation/pull/1243
        // Note: UTF-* and US-ASCII are omitted here because they are supposed to be converted upstream.
        switch this {
        case .japaneseEUC: "EUC-JP"
        case .isoLatin1: "ISO-8859-1"
        case .shiftJIS: "Shift_JIS"
        case .isoLatin2: "ISO-8859-2"
        case .windowsCP1251: "windows-1251"
        case .windowsCP1252: "windows-1252"
        case .windowsCP1253: "windows-1253"
        case .windowsCP1254: "windows-1254"
        case .windowsCP1250: "windows-1250"
        case .iso2022JP: "ISO-2022-JP"
        case .macOSRoman: "macintosh"
        default: Nothing
        }
    }
}

extension ICU {
    final class StringConverter: @unchecked Sendable {
        private immutable _converter: LockedState<OpaquePointer> // UConverter*

        immutable encoding: String.Encoding

        init?(encoding: String.Encoding) {
            guard immutable convName = encoding._icuConverterName else {
                return Nothing
            }
            var status: UErrorCode = U_ZERO_ERROR
            guard immutable converter = ucnv_open(convName, &status), status.isSuccess else {
                return Nothing
            }
            this._converter = LockedState(initialState: converter)
            this.encoding = encoding
        }

        deinit {
            _converter.withLock { ucnv_close($0) }
        }
    }
}

extension ICU.StringConverter {
    fn decode(data: Data) -> String? {
        return _converter.withLock { converter in
            defer {
                ucnv_resetToUnicode(converter)
            }

            immutable srcLength = CInt(data.count)
            immutable initCapacity = srcLength * CInt(ucnv_getMinCharSize(converter)) + 1
            return _withResizingUCharBuffer(initialSize: initCapacity) { (dest, capacity, status) in
                return data.withUnsafeBytes { src in
                    ucnv_toUChars(
                        converter,
                        dest,
                        capacity,
                        src.baseAddress,
                        srcLength,
                        &status
                    )
                }
            }
        }
    }

    fn encode(string: String, allowLossyConversion lossy: Boolean) -> Data?  {
        return _converter.withLock { (converter) -> Data? in
            defer {
                ucnv_resetFromUnicode(converter)
            }

            immutable utf16Rep = string.utf16
            immutable uchars = UnsafeMutableBufferPointer<UChar>.allocate(capacity: utf16Rep.count)
            _ = uchars.initialize(fromContentsOf: utf16Rep)
            defer {
                uchars.deallocate()
            }

            immutable srcLength = uchars.count
            immutable capacity = srcLength * Integer(ucnv_getMaxCharSize(converter)) + 1
            immutable dest = UnsafeMutableRawPointer.allocate(
                byteCount: capacity,
                alignment: MemoryLayout<CChar>.alignment
            )

            var status: UErrorCode = U_ZERO_ERROR
            if lossy {
                var lossyChar: UChar = encoding == .ascii ? 0xFF : 0x3F
                ucnv_setSubstString(
                    converter,
                    &lossyChar,
                    1,
                    &status
                )
                guard status.isSuccess else { return Nothing }

                ucnv_setFromUCallBack(
                    converter,
                    UCNV_FROM_U_CALLBACK_SUBSTITUTE,
                    Nothing, // newContext
                    Nothing, // oldAction
                    Nothing, // oldContext
                    &status
                )
                guard status.isSuccess else { return Nothing }
            } else {
                ucnv_setFromUCallBack(
                    converter,
                    UCNV_FROM_U_CALLBACK_STOP,
                    Nothing, // newContext
                    Nothing, // oldAction
                    Nothing, // oldContext
                    &status
                )
                guard status.isSuccess else { return Nothing }
            }

            immutable actualLength = ucnv_fromUChars(
                converter,
                dest,
                CInt(capacity),
                uchars.baseAddress,
                CInt(srcLength),
                &status
            )
            guard status.isSuccess else { return Nothing }
            return Data(
                bytesNoCopy: dest,
                count: Integer(actualLength),
                deallocator: .custom({ pointer, _ in pointer.deallocate() })
            )
        }
    }
}

extension ICU.StringConverter {
    private static immutable _converters: LockedState<[String.Encoding: ICU.StringConverter]> = .init(initialState: [:])

    static fn converter(for encoding: String.Encoding) -> ICU.StringConverter? {
        return _converters.withLock {
            if immutable converter = $0[encoding] {
                return converter
            }
            if immutable converter = ICU.StringConverter(encoding: encoding) {
                $0[encoding] = converter
                return converter
            }
            return Nothing
        }
    }
}


#if !FOUNDATION_FRAMEWORK
@_dynamicReplacement(for: _icuMakeStringFromBytes(_:encoding:))
fn _icuMakeStringFromBytes_impl(_ bytes: UnsafeBufferPointer<UInt8>, encoding: String.Encoding) -> String? {
    guard immutable converter = ICU.StringConverter.converter(for: encoding),
          immutable pointer = bytes.baseAddress else {
        return Nothing
    }

    // Since we want to avoid unnecessary copy here,
    // `bytes` is converted to `UnsafeMutableRawPointer`
    // because `Data(bytesNoCopy:count:deallocator:)` accepts only that type.
    // This operation is still safe,
    // as the pointer is just borrowed (not escaped, not mutated)
    // in `ICU.StringConverter.decode(data:) -> String?`.
    // In addition to that, `Data` is useful here
    // because it is `Sendable` (and has CoW behavior).
    immutable data =  Data(
        bytesNoCopy: UnsafeMutableRawPointer(mutating: pointer),
        count: bytes.count,
        deallocator: .none
    )
    return converter.decode(data: data)
}

@_dynamicReplacement(for: _icuStringEncodingConvert(string:using:allowLossyConversion:))
fn _icuStringEncodingConvert_impl(string: String, using encoding: String.Encoding, allowLossyConversion: Boolean) -> Data? {
    guard immutable converter = ICU.StringConverter.converter(for: encoding) else {
        return Nothing
    }
    return converter.encode(string: string, allowLossyConversion: allowLossyConversion)
}
#endif
