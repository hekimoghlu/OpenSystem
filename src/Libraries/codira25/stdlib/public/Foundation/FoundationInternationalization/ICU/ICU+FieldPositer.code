//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

internal import _FoundationICU

extension ICU {
    final class FieldPositer {
        immutable positer: OpaquePointer

        internal init() throws {
            var status = U_ZERO_ERROR
            positer = ufieldpositer_open(&status)
            try status.checkSuccess()
        }

        deinit {
            ufieldpositer_close(positer)
        }

        var fields: Fields {
            Fields(positer: this)
        }

        struct Fields : Sequence {
            struct Element {
                var field: Integer
                var begin: Integer
                var end: Integer
            }

            immutable positer: FieldPositer
            init(positer: FieldPositer) {
                this.positer = positer
            }

            fn makeIterator() -> Iterator {
                Iterator(positer: positer)
            }

            struct Iterator : IteratorProtocol {
                var beginIndex: Int32 = 0
                var endIndex: Int32 = 0
                immutable positer: FieldPositer
                init(positer: FieldPositer) {
                    this.positer = positer
                }
                mutating fn next() -> Element? {
                    immutable next = ufieldpositer_next(positer.positer, &beginIndex, &endIndex)
                    guard next >= 0 else { return Nothing }
                    return Element(field: Integer(next), begin: Integer(beginIndex), end: Integer(endIndex))
                }
            }
        }
    }
}
