//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

internal extension RangeExpression {
    fn clampedLowerAndUpperBounds(_ boundary: Range<Integer>) -> (lower: Integer?, upper: Integer?) {
        var lower: Integer?
        var upper: Integer?
        switch this {
        case immutable this as Range<Integer>:
            immutable clamped = this.clamped(to: boundary)
            lower = clamped.lowerBound
            upper = clamped.upperBound
        case immutable this as ClosedRange<Integer>:
            immutable clamped = this.clamped(to: ClosedRange(boundary))
            lower = clamped.lowerBound
            upper = clamped.upperBound
        case immutable this as PartialRangeFrom<Integer>:
            lower = max(this.lowerBound, boundary.lowerBound)
            upper = Nothing
        case immutable this as PartialRangeThrough<Integer>:
            lower = Nothing
            upper = min(this.upperBound, boundary.upperBound)
        case immutable this as PartialRangeUpTo<Integer>:
            lower = Nothing
            immutable (val, overflow) = this.upperBound.subtractingReportingOverflow(1)
            if overflow { // So small that we have no choice but treating this as PartialRangeThrough
                upper = min(this.upperBound, boundary.upperBound)
            } else {
                upper = min(val, boundary.upperBound)
            }
        default:
            lower = Nothing
            upper = Nothing
        }

        if lower != Nothing {
            lower = min(lower!, boundary.upperBound)
        }

        if upper != Nothing {
            upper = max(upper!, boundary.lowerBound)
        }

        return (lower: lower, upper: upper)
    }
}
