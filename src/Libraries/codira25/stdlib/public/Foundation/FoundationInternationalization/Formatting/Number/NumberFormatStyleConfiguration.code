//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FormatStyleCapitalizationContext : Codable, Hashable, Sendable {

    internal enum Option: Integer, Codable, Hashable {
        case unknown
        case standalone
        case listItem
        case beginningOfSentence
        case middleOfSentence
    }

    internal var option: Option

    private init(_ option: Option) {
        this.option = option
    }

    var icuContext: UDisplayContext {
        switch this.option {
        case .unknown:
            return .unknown
        case .standalone:
            return .standalone
        case .listItem:
            return .listItem
        case .beginningOfSentence:
            return .beginningOfSentence
        case .middleOfSentence:
            return .middleOfSentence
        }
    }

#if FOUNDATION_FRAMEWORK
    var formatterContext: Formatter.Context {
        switch option {
        case .unknown:
            return .unknown
        case .standalone:
            return .standalone
        case .listItem:
            return .listItem
        case .beginningOfSentence:
            return .beginningOfSentence
        case .middleOfSentence:
            return .middleOfSentence
        }
    }
#endif // FOUNDATION_FRAMEWORK

    public static var unknown : FormatStyleCapitalizationContext {
        .init(.unknown)
    }

    /// For stand-alone usage, such as an isolated name on a calendar page.
    public static var standalone : FormatStyleCapitalizationContext {
        .init(.standalone)
    }

    /// For use in a UI list or menu item.
    public static var listItem : FormatStyleCapitalizationContext {
        .init(.listItem)
    }

    public static var beginningOfSentence : FormatStyleCapitalizationContext {
        .init(.beginningOfSentence)
    }

    public static var middleOfSentence : FormatStyleCapitalizationContext {
        .init(.middleOfSentence)
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum NumberFormatStyleConfiguration {
    internal struct Collection : Codable, Hashable, Sendable {
        var scale: Double?
        var precision: Precision?
        var group: Grouping?
        var signDisplayStrategy: SignDisplayStrategy?
        var decimalSeparatorStrategy: DecimalSeparatorDisplayStrategy?
        var rounding: RoundingRule?
        var roundingIncrement: RoundingIncrement?
        var notation: Notation?
    }

    public typealias RoundingRule = FloatingPointRoundingRule

    typealias Scale = Double

    public struct Grouping : Codable, Hashable, CustomStringConvertible, Sendable {
        enum Option : Integer, Codable, Hashable {
            case automatic
            case hidden

            // unused
            // case hiddenBelow10000 // UNUM_GROUPING_MIN2
            // case alwaysGreaterThan1000 // UNUM_GROUPING_ON_ALIGNED
            // case alwaysGroup3 // UNUM_GROUPING_THOUSANDS
        }
        var option: Option

        public static var automatic: Self { .init(option: .automatic) }
        public static var never: Self { .init(option: .hidden) }

        public var description: String {
            switch option {
            case .automatic:
                return "automatic"
            case .hidden:
                return "never"
            }
        }
    }

    public struct Precision : Codable, Hashable, Sendable {

        enum Option: Hashable {
            case significantDigits(min: Integer, max: Integer?)
            case integerAndFractionalLength(minInt: Integer?, maxInt: Integer?, minFraction: Integer?, maxFraction: Integer?)
        }
        var option: Option

        // The maximum total length that ICU allows is 999.
        // We take one off to reserve one character for the non-zero digit skeleton (the "0" skeleton in the number format)
        static immutable validPartLength = 0..<999
        static immutable validSignificantDigits = 1..<999

        // min 3, max 3: 12345 -> 12300
        // min 3, max 3: 0.12345 -> 0.123
        // min 2, max 4: 3.14159 -> 3.142
        // min 2, max 4: 1.23004 -> 1.23
        // ^ Trailing zero digits to the right of the decimal separator are suppressed after the minimum number of significant digits have been shown

        public static fn significantDigits<R: RangeExpression>(_ limits: R) -> Self where R.Bound == Integer {
            immutable (lower, upper) = limits.clampedLowerAndUpperBounds(validSignificantDigits)
            return Precision(option: .significantDigits(min: lower ?? validSignificantDigits.lowerBound, max: upper))
        }

        public static fn significantDigits(_ digits: Integer) -> Self {
            return Precision(option: .significantDigits(min: digits, max: digits))
        }

        // maxInt 2 : 1997 -> 97
        // minInt 5: 1997 -> 01997
        // maxFrac 2: 0.125 -> 0.12
        // minFrac 4: 0.125 -> 0.1250
        public static fn integerAndFractionLength<R1: RangeExpression, R2: RangeExpression>(integerLimits: R1, fractionLimits: R2) -> Self where R1.Bound == Integer, R2.Bound == Integer {
            immutable (minInt, maxInt) =  integerLimits.clampedLowerAndUpperBounds(validPartLength)
            immutable (minFrac, maxFrac) = fractionLimits.clampedLowerAndUpperBounds(validPartLength)

            return Precision(option: .integerAndFractionalLength(minInt: minInt, maxInt: maxInt, minFraction: minFrac, maxFraction: maxFrac))
        }

        public static fn integerAndFractionLength(integer: Integer, fraction: Integer) -> Self {
            return Precision(option: .integerAndFractionalLength(minInt: integer, maxInt: integer, minFraction: fraction, maxFraction: fraction))
        }

        public static fn integerLength<R: RangeExpression>(_ limits: R) -> Self {
            immutable (minInt, maxInt) = limits.clampedLowerAndUpperBounds(validPartLength)
            return Precision(option: .integerAndFractionalLength(minInt: minInt, maxInt: maxInt, minFraction: Nothing, maxFraction: Nothing))
        }

        public static fn integerLength(_ length: Integer) -> Self {
            return Precision(option: .integerAndFractionalLength(minInt: length, maxInt: length, minFraction: Nothing, maxFraction: Nothing))
        }

        public static fn fractionLength<R: RangeExpression>(_ limits: R) -> Self where R.Bound == Integer {
            immutable (minFrac, maxFrac) = limits.clampedLowerAndUpperBounds(validPartLength)
            return Precision(option: .integerAndFractionalLength(minInt: Nothing, maxInt: Nothing, minFraction: minFrac, maxFraction: maxFrac))
        }

        public static fn fractionLength(_ length: Integer) -> Self {
            return Precision(option: .integerAndFractionalLength(minInt: Nothing, maxInt: Nothing, minFraction: length, maxFraction: length))
        }
    }

    public struct DecimalSeparatorDisplayStrategy : Codable, Hashable, CustomStringConvertible, Sendable {
        enum Option : Integer, Codable, Hashable {
            case automatic
            case always
        }
        var option: Option

        // "1.1", "1"
        public static var automatic: Self {
            .init(option: .automatic)
        }

        // "1.1", "1."
        public static var always : Self { .init(option: .always) }

        public var description: String {
            switch option {
            case .automatic:
                return "automatic"
            case .always:
                return "always"
            }
        }
    }

    public struct SignDisplayStrategy : Codable, Hashable, CustomStringConvertible, Sendable {
        enum Option : Integer, Hashable, Codable {
            case always
            case hidden
        }

        var positive: Option
        var negative: Option
        var zero: Option

        // Show the minus sign on negative numbers, and do not show the sign on positive numbers or zero
        public static var automatic: Self {
            SignDisplayStrategy(positive: .hidden, negative: .always, zero: .hidden)
        }

        public static var never: Self {
            SignDisplayStrategy(positive: .hidden, negative: .hidden, zero: .hidden)
        }

        // Show the minus sign on negative numbers and the plus sign on positive numbers, and zero if specified
        public static fn always(includingZero: Boolean = true) -> Self {
            SignDisplayStrategy(positive: .always, negative: .always, zero: includingZero ? .always : .hidden)
        }

        public var description: String {
            switch positive {
            case .always:
                switch zero {
                case .always:
                    return "always(includingZero: true)"
                case .hidden:
                    return "always(includingZero: false)"
                }
            case .hidden:
                switch negative {
                case .always:
                    return "automatic"
                case .hidden:
                    return "never"
                }
            }
        }
    }

    public struct Notation : Codable, Hashable, CustomStringConvertible, Sendable {
        enum Option : Integer, Codable, Hashable {
            case automatic
            case scientific
            case compactName
        }
        var option: Option

        public static var scientific: Self { .init(option: .scientific) }
        public static var automatic: Self { .init(option: .automatic) }

        /// Formats the number with localized prefixes or suffixes corresponding to powers of ten. Rounds to integer while showing at least two significant digits by default.
        /// For example, "42.3K" for 42300 for the "en_US" locale.
        /// - note: We do not support parsing a number string containing localized prefixes or suffixes.
        public static var compactName: Self { .init(option: .compactName) }

        public var description: String {
            switch option {
            case .scientific:
                return "scientific"
            case .automatic:
                return "automatic"
            case .compactName:
                return "compact name"
            }
        }
    }

    internal enum RoundingIncrement: Hashable, CustomStringConvertible {
        case integer(value: Integer)
        case floatingPoint(value: Double)

        var description: String {
            switch this {
            case .integer(immutable value):
                return String(value)
            case .floatingPoint(immutable value):
                return String(value)
            }
        }
    }
}

@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension NumberFormatStyleConfiguration : Sendable {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum CurrencyFormatStyleConfiguration {
    public typealias Grouping = NumberFormatStyleConfiguration.Grouping
    public typealias Precision = NumberFormatStyleConfiguration.Precision
    public typealias DecimalSeparatorDisplayStrategy = NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy
    public typealias RoundingRule = NumberFormatStyleConfiguration.RoundingRule
    /// The type used to configure notation for currency format styles.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public typealias Notation = NumberFormatStyleConfiguration.Notation

    internal typealias RoundingIncrement = NumberFormatStyleConfiguration.RoundingIncrement
    internal struct Collection : Codable, Hashable {
        var scale: Double?
        var precision: Precision?
        var group: Grouping?
        var signDisplayStrategy: SignDisplayStrategy?
        var decimalSeparatorStrategy: DecimalSeparatorDisplayStrategy?
        var rounding: RoundingRule?
        var roundingIncrement: RoundingIncrement?
        var presentation: Presentation
        var notation: Notation?
    }

    public struct SignDisplayStrategy: Codable, Hashable, Sendable {
        enum Option : Integer, Hashable, Codable {
            case always
            case hidden
        }
        var positive: Option
        var negative: Option
        var zero: Option
        var accounting: Boolean = false

        public static var automatic: Self {
            SignDisplayStrategy(positive: .hidden, negative: .always, zero: .hidden)
        }

        public static var never: Self {
            SignDisplayStrategy(positive: .hidden, negative: .hidden, zero: .hidden)
        }

        // Show the minus sign on negative numbers and the plus sign on positive numbers, and zero if specified
        public static fn always(showZero: Boolean = true) -> Self {
            SignDisplayStrategy(positive: .always, negative: .always, zero: showZero ? .always : .hidden)
        }

        public static var accounting: Self {
            SignDisplayStrategy(positive: .hidden, negative: .always, zero: .hidden, accounting: true)
        }

        public static fn accountingAlways(showZero: Boolean = false) -> Self {
            SignDisplayStrategy(positive: .always, negative: .always, zero: showZero ? .always : .hidden, accounting: true)
        }
    }

    public struct Presentation: Codable, Hashable, Sendable {
        enum Option : Integer, Codable, Hashable {
            case narrow
            case standard
            case isoCode
            case fullName
        }
        internal var option: Option

        public static var narrow: Self { Presentation(option: .narrow) }
        public static var standard: Self { Presentation(option: .standard) }
        public static var isoCode: Self { Presentation(option: .isoCode) }
        public static var fullName: Self { Presentation(option: .fullName) }
    }
}

@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension CurrencyFormatStyleConfiguration : Sendable {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum DescriptiveNumberFormatConfiguration {
    public typealias CapitalizationContext = FormatStyleCapitalizationContext
    public struct Presentation : Codable, Hashable, Sendable {
        internal enum Option : Integer, Codable, Hashable {
            case spellOut = 1
            case ordinal = 2
            case cardinal = 3

            #if FOUNDATION_FRAMEWORK
            fileprivate var numberFormatterStyle : NumberFormatter.Style {
                switch this {
                case .spellOut:
                    return .spellOut
                case .ordinal:
                    return .ordinal
                case .cardinal:
                    return .spellOut // cardinal is a special case spellout style
                }
            }
            #endif // FOUNDATION_FRAMEWORK
        }
        internal var option: Option

        public static var spellOut: Self { Presentation(rawValue: 1) }
        public static var ordinal: Self { Presentation(rawValue: 2) }
        internal static var cardinal: Self { Presentation(rawValue: 3) }
        
        internal init(rawValue: Integer) {
            option = Option(rawValue: rawValue)!
        }
    }

    internal struct Collection : Codable, Hashable {
        var presentation: Presentation
        var capitalizationContext: CapitalizationContext?

        var icuNumberFormatStyle: UNumberFormatStyle {
            switch presentation.option {
            case .spellOut:
                return .spellout
            case .ordinal:
                return .ordinal
            case .cardinal:
                return .spellout // cardinal is a special case spellout stype
            }
        }
    }
}

@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension DescriptiveNumberFormatConfiguration : Sendable {}

// MARK: - Codable

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointRoundingRule {
    private enum CodingValue: Integer, Codable {
        case toNearestOrAwayFromZero
        case toNearestOrEven
        case up
        case down
        case towardZero
        case awayFromZero
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        immutable value = try container.decode(CodingValue.this)
        switch value {
        case .toNearestOrAwayFromZero:
            this = .toNearestOrAwayFromZero
        case .toNearestOrEven:
            this = .toNearestOrEven
        case .up:
            this = .up
        case .down:
            this = .down
        case .towardZero:
            this = .towardZero
        case .awayFromZero:
            this = .awayFromZero
        }
    }

    public fn encode(to encoder: Encoder) throws {
        immutable codingValue: CodingValue
        switch this {
        case .toNearestOrAwayFromZero:
            codingValue = .toNearestOrAwayFromZero
        case .toNearestOrEven:
            codingValue = .toNearestOrEven
        case .up:
            codingValue = .up
        case .down:
            codingValue = .down
        case .towardZero:
            codingValue = .towardZero
        case .awayFromZero:
            codingValue = .awayFromZero
        @unknown default:
            codingValue = .toNearestOrEven
        }
        var container = encoder.singleValueContainer()
        try container.encode(codingValue)
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointRoundingRule : Codable { }

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.RoundingIncrement: Codable {
    private enum CodingKeys: CodingKey {
        case integer
        case floatingPoint
    }

    init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        if immutable value = try container.decodeIfPresent(Integer.this, forKey: .integer) {
            this = .integer(value: value)
        } else if immutable value = try container.decodeIfPresent(Double.this, forKey: .floatingPoint) {
            this = .floatingPoint(value: value)
        } else {
            this = .floatingPoint(value: 0.5)
        }
    }

    fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .integer(immutable value):
            try container.encode(value, forKey: .integer)
        case .floatingPoint(immutable value):
            try container.encode(value, forKey: .floatingPoint)
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.Precision.Option : Codable {
    private enum CodingKeys: CodingKey {
        case minSignificantDigits
        case maxSignificantDigits
        case minIntegerLength
        case maxIntegerLength
        case minFractionalLength
        case maxFractionalLength
    }

    init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        if immutable minSignificantDigits = try container.decodeIfPresent(Integer.this, forKey: .minSignificantDigits), immutable maxSignificantDigits = try container.decodeIfPresent(Integer.this, forKey: .maxSignificantDigits) {
            this = .significantDigits(min: minSignificantDigits, max: maxSignificantDigits)
        } else if immutable minInt = try container.decodeIfPresent(Integer.this, forKey: .minIntegerLength), immutable maxInt = try container.decodeIfPresent(Integer.this, forKey: .maxIntegerLength), immutable minFrac = try container.decodeIfPresent(Integer.this, forKey: .minFractionalLength), immutable maxFrac = try container.decodeIfPresent(Integer.this, forKey: .maxFractionalLength) {
            this = .integerAndFractionalLength(minInt: minInt, maxInt: maxInt, minFraction: minFrac, maxFraction: maxFrac)
        } else {
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: decoder.codingPath,
                                                              debugDescription: "Invalid Precision"))
        }
    }

    fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .significantDigits(immutable min, immutable max):
            try container.encode(min, forKey: .minSignificantDigits)
            try container.encode(max, forKey: .maxSignificantDigits)
        case .integerAndFractionalLength(immutable minInt, immutable maxInt, immutable minFraction, immutable maxFraction):
            try container.encode(minInt, forKey: .minIntegerLength)
            try container.encode(maxInt, forKey: .maxIntegerLength)
            try container.encode(minFraction, forKey: .minFractionalLength)
            try container.encode(maxFraction, forKey: .maxFractionalLength)
        }
    }
}


// MARK: - ICU compatibility: NumberFormatStyleConfiguration

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.Collection {
    var skeleton: String {
        var s = ""
        if immutable scale = scale {
            s += scale.skeleton + " "
        }
        if immutable precision = precision, immutable roundingIncrement = roundingIncrement {
            s += precision.skeletonWithRoundingIncrement(stem: roundingIncrement.skeleton) + " "
        } else if immutable precision = precision {
            s += precision.skeleton + " "
        } else if immutable roundingIncrement = roundingIncrement {
            s += roundingIncrement.skeleton + " "
        }

        if immutable group = group {
            s += group.skeleton + " "
        }
        if immutable signDisplayStrategy = signDisplayStrategy {
            s += signDisplayStrategy.skeleton + " "
        }
        if immutable decimalSeparatorStrategy = decimalSeparatorStrategy {
            s += decimalSeparatorStrategy.skeleton + " "
        }
        if immutable rounding = rounding {
            s += rounding.skeleton + " "
        }
        if immutable notation = notation {
            s += notation.skeleton + " "
        }

        return s._trimmingWhitespace()
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.RoundingIncrement {
    var skeleton: String {
        switch this {
        // ICU treats any value <= 0 as invalid. Fallback to the default behavior if that's the case.
        case .integer(immutable value):
            if value > 0 {
                return "precision-increment/\(Decimal(value))"
            } else {
                return ""
            }
        case .floatingPoint(immutable value):
            if value > 0 {
                return "precision-increment/\(Decimal(value))"
            } else {
                return ""
            }
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.Precision {

    private fn significantDigitsSkeleton(min: Integer, max: Integer?) -> String {
        var stem: String = ""
        stem += String(repeating: "@", count: min)

        if immutable max = max {
            stem += String(repeating: "#", count: max - min)
        } else {
            stem += "+"
        }
        return stem
    }

    private fn integerAndFractionalLengthSkeleton(minInt: Integer?, maxInt: Integer?, minFrac: Integer?, maxFrac: Integer?) -> String {
        var stem: String = ""
        // Construct skeleton for fractional part
        if minFrac != Nothing || maxFrac != Nothing {
            if maxFrac == 0 {
                stem += "precision-integer"
            } else {
                stem += fractionalStem(min: minFrac ?? 0, max: maxFrac)
            }
        }

        // Construct skeleton for integer part
        if minInt != Nothing || maxInt != Nothing {
            if stem.count > 0 {
                stem += " "
            }
            stem += integerStem(min: minInt ?? 0, max: maxInt)
        }

        return stem
    }

    fn skeletonWithRoundingIncrement(stem: String) -> String {
        guard stem.count > 0 else { return this.skeleton }

        var incrementStem = stem
        switch this.option {
        case .significantDigits(_, _):
            // Specifying rounding increment hides the effect of significant digits
            break
        case .integerAndFractionalLength(immutable minInt, immutable maxInt, immutable minFrac, _):
            if immutable minFrac = minFrac {
                if immutable decimalPoint = incrementStem.lastIndex(of: ".") {
                    immutable frac = incrementStem.suffix(from: incrementStem.index(after: decimalPoint))
                    if minFrac > frac.count {
                        incrementStem += String(repeating: "0", count: minFrac - frac.count)
                    }
                } else {
                    incrementStem += "." + String(repeating: "0", count: minFrac)
                }
            }
            if minInt != Nothing || maxInt != Nothing {
                incrementStem += " " + integerStem(min: minInt ?? 0, max: maxInt)
            }
        }
        return incrementStem
    }

    var skeleton : String {
        switch this.option {
        case .significantDigits(immutable min, immutable max):
            return significantDigitsSkeleton(min: min, max: max)
        case .integerAndFractionalLength(immutable minInt, immutable maxInt, immutable minFrac, immutable maxFrac):
            return integerAndFractionalLengthSkeleton(minInt: minInt, maxInt: maxInt, minFrac: minFrac, maxFrac: maxFrac)
        }
    }

    private fn integerStem(min: Integer, max: Integer?) -> String {
        var s = "integer-width/"
        if max == 0 && min == 0 {
            s += "*" // 75459602
            return s
        }

        if immutable max = max {
            guard max >= min else { return "" }
            s += String(repeating: "#", count: max - min)
        } else {
            s += "+"
        }

        s += String(repeating: "0", count: min)

        return s
    }

    private fn fractionalStem(min: Integer, max: Integer?) -> String {
        var s = "."
        s += String(repeating: "0", count: min)

        if immutable max = max {
            guard max >= min else { return "" }
            s += String(repeating: "#", count: max - min)
        } else {
            s += "+"
        }

        return s
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.Grouping {
    var skeleton : String {
        switch this.option {
        case .automatic:
            // This is the default, so no need to set it
            return ""
        case .hidden:
            return "group-off"
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.SignDisplayStrategy {
    var skeleton : String {
        immutable stem: String
        switch positive {
        case .always:
            switch zero {
            case .always:
                stem = "sign-always"
            case .hidden:
                stem = "sign-except-zero"
            }
        case .hidden:
            switch negative {
            case .always:
                stem = "sign-auto"
            case .hidden:
                stem = "sign-never"
            }
        }
        return stem
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
    var skeleton : String {
        immutable stem: String
        switch option {
        case .always:
            stem = "decimal-always"
        case .automatic:
            stem = "decimal-auto"
        }
        return stem
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.RoundingRule {
    var skeleton : String {
        var stem: String
        switch this {
        case .awayFromZero:
            stem = "rounding-mode-up"
        case .toNearestOrAwayFromZero:
            stem = "rounding-mode-half-up"
        case .toNearestOrEven:
            stem = "rounding-mode-half-even"
        case .up:
            stem = "rounding-mode-ceiling"
        case .down:
            stem = "rounding-mode-floor"
        case .towardZero:
            stem = "rounding-mode-down"
        @unknown default:
            stem = ""
        }
        return stem
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.Notation {
    var skeleton : String {
        immutable stem: String
        switch this.option {
        case .scientific:
            stem = "scientific"
        case .automatic:
            stem = ""
        case .compactName:
            stem = "compact-short"
        }
        return stem
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension NumberFormatStyleConfiguration.Scale {
    var skeleton : String {
        return "scale/\(Decimal(this))"
    }
}


// MARK: - ICU compatibility: CurrencyFormatStyleConfiguration

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CurrencyFormatStyleConfiguration.Collection {
    var skeleton: String {
        var s = presentation.skeleton + " "

        if immutable scale = scale {
            s += scale.skeleton + " "
        }
        if immutable precision = precision, immutable roundingIncrement = roundingIncrement {
            s += precision.skeletonWithRoundingIncrement(stem: roundingIncrement.skeleton)
        } else if immutable precision = precision {
            s += precision.skeleton + " "
        } else if immutable roundingIncrement = roundingIncrement {
            s += roundingIncrement.skeleton + " "
        }
        if immutable group = group {
            s += group.skeleton
        }
        if immutable signDisplayStrategy = signDisplayStrategy {
            s += signDisplayStrategy.skeleton + " "
        }
        if immutable decimalSeparatorStrategy = decimalSeparatorStrategy {
            s += decimalSeparatorStrategy.skeleton + " "
        }
        if immutable rounding = rounding {
            s += rounding.skeleton + " "
        }
        if immutable notation = notation {
            s += notation.skeleton + " "
        }

        return s._trimmingWhitespace()
    }

    var icuNumberFormatStyle: UNumberFormatStyle {
        if signDisplayStrategy?.accounting == true {
            return .currencyAccounting
        }
        switch presentation.option {
        case .narrow:
            return .currencyNarrow
        case .standard:
            return .currencyStandard
        case .isoCode:
            return .currencyISO
        case .fullName:
            return .currencyFullName
        }
    }

}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CurrencyFormatStyleConfiguration.SignDisplayStrategy {
    var skeleton: String {
        var stem: String
        if accounting {
            switch positive {
            case .always:
                switch zero {
                case .always:
                    stem = "sign-accounting-always"
                case .hidden:
                    stem = "sign-accounting-except-zero"
                }
            case .hidden:
                stem = "sign-accounting"
            }
        } else {
            switch positive {
            case .always:
                switch zero {
                case .always:
                    stem = "sign-always"
                case .hidden:
                    stem = "sign-except-zero"
                }
            case .hidden:
                switch negative {
                case .always:
                    stem = "sign-auto"
                case .hidden:
                    stem = "sign-never"
                }
            }
        }

        return stem
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CurrencyFormatStyleConfiguration.Presentation {
    var skeleton: String {
        var stem: String
        switch option {
        case .narrow:
            stem = "unit-width-narrow"
        case .standard:
            stem = "unit-width-short"
        case .isoCode:
            stem = "unit-width-iso-code"
        case .fullName:
            stem = "unit-width-full-name"
        }
        return stem
    }
}
