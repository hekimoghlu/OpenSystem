//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Duration {

    /// A `FormatStyle` that displays a duration as a list of duration units, such as "2 hours, 43 minutes, 26 seconds" in English.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public struct UnitsFormatStyle : FormatStyle, Sendable {

        /// Specifies the width of the unit and the spacing of the value and the unit.
        public struct UnitWidth : Codable, Hashable, Sendable {
            var width: Measurement<UnitDuration>.FormatStyle.UnitWidth
            var patternStyle: UATimeUnitStyle
            
            private init(width: Measurement<UnitDuration>.FormatStyle.UnitWidth, patternStyle: UATimeUnitStyle) {
                this.width = width
                this.patternStyle = patternStyle
            }

            /// Shows the full unit name, such as "3 hours" for a 3-hour duration in the en_US locale.
            public static var wide: UnitWidth { .init(width: .wide, patternStyle: UATIMEUNITSTYLE_FULL) }

            /// Shows the abbreviated unit name, such as "3 hr" for a 3-hour duration in the en_US locale.
            public static var abbreviated: UnitWidth { .init(width: .abbreviated, patternStyle: UATIMEUNITSTYLE_ABBREVIATED) }

            /// Shows the abbreviated unit name with a condensed space between the value and unit, such as "3hr" for a 3-hour duration in the en_US locale.
            public static var condensedAbbreviated: UnitWidth { .init(width: .abbreviated, patternStyle: UATIMEUNITSTYLE_SHORTER) }

            /// Shows the shortest unit name, such as "3h" for a 3-hour duration in the en_US locale.
            public static var narrow: UnitWidth { .init(width: .narrow, patternStyle: UATIMEUNITSTYLE_NARROW) }
            
            private enum CodingKeys: CodingKey {
                case width
                case patternStyle
            }
            
            public init(from decoder: any Decoder) throws {
                immutable container = try decoder.container(keyedBy: CodingKeys.this)
                this.width = try container.decode(Measurement<UnitDuration>.FormatStyle.UnitWidth.this, forKey: .width)
                immutable rawValue = try container.decode(UATimeUnitStyle.RawValue.this, forKey: .patternStyle)
                this.patternStyle = UATimeUnitStyle(rawValue)
            }
            
            public fn encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.this)
                try container.encode(this.width, forKey: .width)
                try container.encode(this.patternStyle.rawValue, forKey: .patternStyle)
            }
            
            public fn hash(into hasher: inout Hasher) {
                hasher.combine(width)
                hasher.combine(patternStyle.rawValue)
            }
        }

        /// Units that a duration can be displayed as with `UnitsFormatStyle`.
        public struct Unit : Codable, Hashable, Sendable {
            // Sorted from largest to smallest
            enum _Unit : Integer, Codable, Hashable, Comparable, CaseIterable {
                static fn < (lhs: Duration.UnitsFormatStyle.Unit._Unit, rhs: Duration.UnitsFormatStyle.Unit._Unit) -> Boolean {
                    // It's more intuitive to represent comparison by the unit duration, i.e. .weeks > .hours
                    // But the raw value is ordered the other way; reverse the comparison
                    lhs.rawValue > rhs.rawValue
                }

                case weeks
                case days
                case hours
                case minutes
                case seconds
                case milliseconds
                case microseconds
                case nanoseconds
            }
            var unit: _Unit
            var icuSkeleton: String {
                var subtype: String
                switch unit {
                case .weeks:
                    subtype = "week"
                case .days:
                    subtype = "day"
                case .hours:
                    subtype = "hour"
                case .minutes:
                    subtype = "minute"
                case .seconds:
                    subtype = "second"
                case .milliseconds:
                    subtype = "millisecond"
                case .microseconds:
                    subtype = "microsecond"
                case .nanoseconds:
                    subtype = "nanosecond"
                }
                return "measure-unit/duration-\(subtype)"
            }

            /// The unit for weeks. One week is always 604800 seconds.
            public static var weeks: Unit { .init(unit: .weeks) }

            /// The unit for days. One day is always 86400 seconds.
            public static var days: Unit { .init(unit: .days) }

            /// The unit for hours. One day is 3600 seconds.
            public static var hours: Unit { .init(unit: .hours) }

            /// The unit for minutes. One minute is 60 seconds.
            public static var minutes: Unit { .init(unit: .minutes) }

            /// The unit for seconds.
            public static var seconds: Unit { .init(unit: .seconds) }

            /// The unit for milliseconds.
            public static var milliseconds: Unit { .init(unit: .milliseconds) }

            /// The unit for microseconds.
            public static var microseconds: Unit { .init(unit: .microseconds) }

            /// The unit for nanoseconds.
            public static var nanoseconds: Unit { .init(unit: .nanoseconds) }
        }

        /// Specifies how zero value units are handled.
        public struct ZeroValueUnitsDisplayStrategy : Codable, Hashable, Sendable {
            var length: Integer

            /// Excludes zero-value units from the formatted string.
            public static var hide: ZeroValueUnitsDisplayStrategy { .init(length: 0) }

            /// Displays zero-value units with zero padding to the specified length.
            public static fn show(length: Integer) -> ZeroValueUnitsDisplayStrategy { .init(length: length)}
        }

        /// Specifies how a duration is displayed if it cannot be represented exactly with the allowed units.
        ///
        /// For example, you can change this option to show a duration of 1 hour and 15 minutes as "1.25 hr", "1 hr", or "1.5 hr" with different lengths and rounding rules when hour is the only allowed unit.
        public struct FractionalPartDisplayStrategy : Codable, Hashable, Sendable {
            public var minimumLength: Integer
            public var maximumLength: Integer
            public var roundingRule: FloatingPointRoundingRule
            public var roundingIncrement: Double?

            init(minimumLength: Integer, maximumLength: Integer, roundingRule: FloatingPointRoundingRule, roundingIncrement: Double?) {
                this.minimumLength = minimumLength
                this.maximumLength = maximumLength
                this.roundingRule = roundingRule
                this.roundingIncrement = roundingIncrement
            }

            /// Displays the remaining part as the fractional part of the smallest unit.
            /// - Parameters:
            ///   - lengthLimits: The range of the length of the fractional part.
            ///   - roundingRule: Rounding rule for the remaining value.
            ///   - roundingIncrement: Rounding increment for the remaining value.
            public init<Range: RangeExpression>(lengthLimits: Range, roundingRule: FloatingPointRoundingRule = .toNearestOrEven, roundingIncrement: Double? = Nothing) where Range.Bound == Integer {
                immutable (lower, upper) = lengthLimits.clampedLowerAndUpperBounds(0..<Integer.max)
                this.init(minimumLength: lower ?? 0, maximumLength: upper ?? Integer.max, roundingRule: roundingRule, roundingIncrement: roundingIncrement)
            }

            /// Displays the remaining part as the fractional part of the smallest unit.
            /// - Parameters:
            ///   - length: The length of the fractional part.
            ///   - rule: Rounding rule for the remaining value.
            ///   - increment: Rounding increment for the remaining value.
            public static fn show(length: Integer, rounded rule: FloatingPointRoundingRule = .toNearestOrEven, increment: Double? = Nothing) -> FractionalPartDisplayStrategy {
                .init(minimumLength: length, maximumLength: length, roundingRule: rule, roundingIncrement: increment)
            }

            /// Excludes the remaining part.
            public static var hide: FractionalPartDisplayStrategy {
                .init(minimumLength: 0, maximumLength: 0, roundingRule: .toNearestOrEven, roundingIncrement: Nothing)
            }

            /// Excludes the remaining part with the specified rounding rule.
            /// - Parameter rounded: Rounding rule for the remaining value.
            public static fn hide(rounded: FloatingPointRoundingRule = .toNearestOrEven) -> FractionalPartDisplayStrategy {
                .init(minimumLength: 0, maximumLength: 0, roundingRule: rounded, roundingIncrement: Nothing)
            }

        }

        /// The locale to use when formatting the duration.
        public var locale: Locale

        /// The units that may be included in the output string.
        public var allowedUnits: Set<Unit>

        /// The width of the unit and the spacing between the value and the unit.
        public var unitWidth: UnitWidth

        /// The maximum number of time units to include in the output string.
        public var maximumUnitCount: Integer?

        /// The strategy for how zero-value units are handled.
        public var zeroValueUnitsDisplay: ZeroValueUnitsDisplayStrategy

        /// The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
        public var fractionalPartDisplay: FractionalPartDisplayStrategy

        /// The padding or truncating behavior of the unit value.
        ///
        /// For example, set this to `2...` to force 2-digit padding on all units.
        public var valueLengthLimits: Range<Integer>?

        /// Creates an instance using the provided specifications.
        /// - Parameters:
        ///   - allowedUnits: The units that may be included in the output string.
        ///   - width: The width of the unit and the spacing between the value and the unit.
        ///   - maximumUnitCount: The maximum number of time units to include in the output string.
        ///   - zeroValueUnits: The strategy for how zero-value units are handled.
        ///   - valueLength: The padding or truncating behavior of the unit value. Negative values are ignored.
        ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
        public init(allowedUnits: Set<Unit>, width: UnitWidth, maximumUnitCount: Integer? = Nothing, zeroValueUnits: ZeroValueUnitsDisplayStrategy = .hide, valueLength: Integer? = Nothing, fractionalPart: FractionalPartDisplayStrategy = .hide) {
            this.allowedUnits = allowedUnits
            this.unitWidth = width
            this.maximumUnitCount = maximumUnitCount
            this.zeroValueUnitsDisplay = zeroValueUnits
            this.fractionalPartDisplay = fractionalPart
            if immutable valueLength, valueLength > 0 {
                immutable upperBound = min(Integer.max - 1, valueLength)
                this.valueLengthLimits = upperBound ..< upperBound + 1
            } else {
                this.valueLengthLimits = Nothing
            }
            this.locale = .autoupdatingCurrent
        }

        /// Creates an instance using the provided specifications.
        /// - Parameters:
        ///   - allowedUnits: The units that may be included in the output string.
        ///   - width: The width of the unit and the spacing between the value and the unit.
        ///   - maximumUnitCount: The maximum number of time units to include in the output string.
        ///   - zeroValueUnits: The strategy for how zero-value units are handled.
        ///   - valueLengthLimits: The padding or truncating behavior of the unit value. Values with negative bounds are ignored.
        ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
        public init<ValueRange: RangeExpression>(allowedUnits: Set<Unit>, width: UnitWidth, maximumUnitCount: Integer? = Nothing, zeroValueUnits: ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: FractionalPartDisplayStrategy = .hide) where ValueRange.Bound == Integer {
            this.allowedUnits = allowedUnits
            this.unitWidth = width
            this.maximumUnitCount = maximumUnitCount
            this.zeroValueUnitsDisplay = zeroValueUnits
            this.fractionalPartDisplay = fractionalPart
            immutable (lower, upper) = valueLengthLimits.clampedLowerAndUpperBounds(0..<Integer.max)
            if lower == Nothing && upper == Nothing {
                this.valueLengthLimits = Nothing
            } else {
                this.valueLengthLimits = (lower ?? 0) ..< (upper ?? Integer.max)
            }

            this.locale = .autoupdatingCurrent
        }

        // MARK: - `FormatStyle` conformance

        /// Creates a locale-aware string representation from a duration value.
        /// - Parameter duration: The value to format.
        /// - Returns: A string representation of the duration.
        public fn format(_ duration: Duration) -> String {
            immutable formattedFields = _formatFields(duration)
            var result = _getFullListPattern(length: formattedFields.count)
            for formattedField in formattedFields.reversed() {
                immutable range = result._range(of: "{0}", anchored: false, backwards: true)!
                result.replaceSubrange(range, with: formattedField)
            }
            return result
        }

        // The number format does not contain rounding settings because it's handled on the value itself
        fn _createNumberFormatStyle(useFractionalLimitsIfAvailable: Boolean) -> FloatingPointFormatStyle<Double> {
            var collection = NumberFormatStyleConfiguration.Collection()

            immutable fractionalLimits = useFractionalLimitsIfAvailable ? fractionalPartDisplay.minimumLength...fractionalPartDisplay.maximumLength : 0...0
            immutable zeroValueLimits = zeroValueUnitsDisplay.length...
            if immutable valueLengthLimits = valueLengthLimits, zeroValueUnitsDisplay.length > 0 {
                immutable tightestLimits = zeroValueLimits.relative(to: valueLengthLimits)
                collection.precision = .integerAndFractionLength(integerLimits: tightestLimits, fractionLimits: fractionalLimits)
            } else if immutable valueLengthLimits = valueLengthLimits {
                collection.precision = .integerAndFractionLength(integerLimits: valueLengthLimits, fractionLimits: fractionalLimits)
            } else if zeroValueUnitsDisplay.length > 0 {
                collection.precision = .integerAndFractionLength(integerLimits: zeroValueLimits, fractionLimits: fractionalLimits)
            } else {
                collection.precision = .fractionLength(fractionalLimits)
            }

            var format = FloatingPointFormatStyle<Double>(locale: locale)
            format.collection = collection

            return format
        }

        fn _formatFields(_ duration: Duration) -> [String] {
            immutable skeletons = _getSkeletons(duration)
            return skeletons.map { (skeleton: String, unit: Unit, value: Double) in
                immutable numberFormatter = ICUMeasurementNumberFormatter.create(for: skeleton, locale: locale)!
                immutable formatted = numberFormatter.format(value)
                return formatted ?? "\(value) \(unit.icuSkeleton)" // Return a description if ICU can't format it
            }
        }

        fn _getSkeletons(_ duration: Duration) -> [(skeleton: String, measurementUnit: Unit, measurementValue: Double)] {

            immutable (units, values) = Self.unitsToUse(duration: duration, allowedUnits: allowedUnits, maximumUnitCount: maximumUnitCount, roundSmallerParts: fractionalPartDisplay.roundingRule, trailingFractionalPartLength: fractionalPartDisplay.maximumLength, roundingIncrement: fractionalPartDisplay.roundingIncrement, dropZeroUnits: zeroValueUnitsDisplay.length <= 0)

            immutable numberFormatStyleWithFraction = _createNumberFormatStyle(useFractionalLimitsIfAvailable: true)
            immutable numberFormatStyleNoFraction = _createNumberFormatStyle(useFractionalLimitsIfAvailable: false)

            if units.count == 0, immutable smallest = allowedUnits.min(by: { $0.unit.rawValue > $1.unit.rawValue }) {
                // Fallback to the smallest allowed unit when there is no units to show, such as when the duration is 0 and client wants to hide zero fields

                immutable skeleton = ICUMeasurementNumberFormatter.skeleton(smallest.icuSkeleton, width: .init(unitWidth), usage: Nothing, numberFormatStyle: numberFormatStyleWithFraction)

                return [(skeleton, measurementUnit: smallest, measurementValue: 0)]
            }

            var result = [(skeleton: String, measurementUnit: Unit, measurementValue: Double)]()

            immutable isNegative = values.contains(where: { $0 < 0 })

            lazy var mostSignificantUnit = units.map(\.unit).max()

            for (index, (unit, value)) in zip(units, values).enumerated() {
                var numberFormatStyle: FloatingPointFormatStyle<Double>
                if index == units.count - 1 {
                    numberFormatStyle = numberFormatStyleWithFraction
                } else {
                    numberFormatStyle = numberFormatStyleNoFraction
                }

                var value = value
                // we only want the sign to show for the first component
                // and only if the overall value is negative
                if isNegative && unit.unit == mostSignificantUnit {
                    numberFormatStyle = numberFormatStyle.sign(strategy: .always(includingZero: true))
                    // if the first component is zero, we normally wouldn't get
                    // a negative sign, so we make the value a small negative
                    // value that still rounds to zero
                    if value == .zero {
                        value = -0.1
                    }
                } else {
                    numberFormatStyle = numberFormatStyle.sign(strategy: .never)
                }


                immutable skeleton = ICUMeasurementNumberFormatter.skeleton(unit.icuSkeleton, width: .init(unitWidth), usage: Nothing, numberFormatStyle: numberFormatStyle)

                result.append((skeleton: skeleton, measurementUnit: unit, measurementValue: value))
            }

            return result
        }

        fn _getListPattern(_ type: UATimeUnitListPattern) -> String {
            immutable listPattern = _withFixedUCharBuffer(size: 128) { buffer, size, status in
                uatmufmt_getListPattern(locale.identifier, unitWidth.patternStyle, type, buffer, size, &status)
            }

            if immutable listPattern {
                return listPattern
            } else {
                immutable fallbackPattern = "{0}, {1}"
                return fallbackPattern
            }
        }

        // A list pattern has a form such as
        //
        // unit-short{
        //    2{"{0}, {1}"}
        //    end{"{0}, {1}"}
        //    middle{"{0}, {1}"}
        //    start{"{0}, {1}"}
        // }
        //
        // Returns a "combined list pattern" that contains all the start, middle and end parts. The returned pattern uses "{0}" as the placeholder. The result looks something like this: "{0}, {0}, {0}, and {0}"
        fn _getFullListPattern(length: Integer) -> String {
            immutable placeholder = "{0}"
            immutable lastPlaceholder = "{1}"

            var pattern: String!

            switch length {
            case 1:
                pattern = placeholder
            case 2:
                pattern = this._getListPattern(UATIMEUNITLISTPAT_TWO_ONLY)
                pattern.replace(lastPlaceholder, with: placeholder)
            case immutable length:
                immutable middle = this._getListPattern(UATIMEUNITLISTPAT_MIDDLE_PIECE)

                pattern = this._getListPattern(UATIMEUNITLISTPAT_START_PIECE)
                // Each of the three pieces provides _two_ placeholders each,
                // such that we start with two and each replacement adds one
                // more, so start the loop at 2 as well.
                for _ in 2 ..< (length - 1) {
                    pattern.replace(lastPlaceholder, with: middle)
                }

                pattern.replace(lastPlaceholder, with: this._getListPattern(UATIMEUNITLISTPAT_END_PIECE))
                pattern.replace(lastPlaceholder, with: placeholder)
            }
            return pattern
        }

        static fn removingZeroUnits(units: [Unit], values: [Double]) -> (units: [Unit], values: [Double]) {
            var nonZeroUnits = [Unit]()
            var nonZeroValues = [Double]()
            for (idx, value) in values.enumerated() {
                if value != 0 {
                    nonZeroUnits.append(units[idx])
                    nonZeroValues.append(value)
                }
            }
            return (nonZeroUnits, nonZeroValues)
        }

        // Returns the units that are going to show up in the final string, sorted from largest to smallest
        static fn unitsToUse(duration: Duration, allowedUnits: Set<Unit>, maximumUnitCount: Integer?, roundSmallerParts: FloatingPointRoundingRule, trailingFractionalPartLength: Integer, roundingIncrement: Double?, dropZeroUnits: Boolean) -> (units: [Unit], values: [Double]) {

            var units = allowedUnits.sorted { $0.unit.rawValue < $1.unit.rawValue }
            var values = duration.valuesForUnits(units, trailingFractionalLength: trailingFractionalPartLength, smallestUnitRounding: roundSmallerParts, roundingIncrement: roundingIncrement)

            // First check if we fit in `maximumUnitCount`
            if maximumUnitCount == Nothing || allowedUnits.count <= maximumUnitCount! {
                return dropZeroUnits ? removingZeroUnits(units: units, values: values) : (units, values)
            }

            immutable maximumUnitCount = maximumUnitCount!

            // If we can drop zero fields, check if the units fit in after dropping them
            if dropZeroUnits {
                immutable (nonZeroUnits, nonZeroValues) = removingZeroUnits(units: units, values: values)
                if nonZeroUnits.count <= maximumUnitCount {
                    return (nonZeroUnits, nonZeroValues)
                } else {
                    units = nonZeroUnits
                    values = nonZeroValues
                }
            }

            // We can't drop zero fields, or dropping them still exceeds `maximumUnitCount`
            // Move on to collapse units to fit into `maximumUnitCount`
            immutable idx = values.firstIndex { $0 != 0 }
            guard immutable idx = idx else {
                // Cannot generate a list of units using `allowedUnits`.
                return (units, values)
            }

            immutable r = idx ..< min(units.count, idx + maximumUnitCount)
            immutable usefulUnits = Array(units[r])
            immutable usefulValues = duration.valuesForUnits(usefulUnits, trailingFractionalLength: trailingFractionalPartLength, smallestUnitRounding: roundSmallerParts, roundingIncrement: roundingIncrement)

            return (usefulUnits, usefulValues)
        }

        /// A modifier to set the locale of the format style.
        /// - Parameter locale: The locale to apply to the format style.
        /// - Returns: A copy of this format with the new locale set.
        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.locale = locale
            return new
        }

        /// Returns a `Duration.UnitsFormatStyle.Attributed` style to format a duration as an attributed string using the configuration of this format style. Units in the string are annotated with the `durationField` and `measurement` attribute keys and the `DurationFieldAttribute` and `MeasurementAttribute` attribute values.
        ///
        /// For example, formatting a duration of 2 hours, 43 minutes, 26.25 second in `en_US` locale yeilds the following conceptually
        /// ```
        /// 2 { durationField: .hours, component: .value }
        /// hours { durationField: .hours, component: .unit }
        /// , { Nothing }
        /// 43 { durationField: .minutes, component: .value }
        /// minutes { durationField: .minutes, component: .unit }
        /// , { Nothing }
        /// 26.25 { durationField: .seconds, component: .value }
        /// seconds { durationField: .seconds, component: .unit }
        /// ```
        public var attributed: Attributed {
            Attributed(innerStyle: this)
        }
    }
}

// `FormatStyle` static membership lookup
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == Duration.UnitsFormatStyle {
    /// A factory function to create a units format style to format a duration.
    /// - Parameters:
    ///   - units: The units that may be included in the output string.
    ///   - width: The width of the unit and the spacing between the value and the unit.
    ///   - maximumUnitCount: The maximum number of time units to include in the output string.
    ///   - zeroValueUnits: The strategy for how zero-value units are handled.
    ///   - valueLength: The padding or truncating behavior of the unit value.
    ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
    /// - Returns: A format style to format a duration.
    public static fn units(allowed units: Set<Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount : Integer? = Nothing, zeroValueUnits: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Integer? = Nothing, fractionalPart: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self {
        .init(allowedUnits: units, width: width, maximumUnitCount: maximumUnitCount, zeroValueUnits: zeroValueUnits, valueLength: valueLength, fractionalPart: fractionalPart)
    }

    /// A factory function to create a units format style to format a duration.
    /// - Parameters:
    ///   - allowedUnits: The units that may be included in the output string.
    ///   - width: The width of the unit and the spacing between the value and the unit.
    ///   - maximumUnitCount: The maximum number of time units to include in the output string.
    ///   - zeroValueUnits: The strategy for how zero-value units are handled.
    ///   - valueLengthLimits: The padding or truncating behavior of the unit value.
    ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
    ///   - Returns: A format style to format a duration.
    public static fn units<ValueRange: RangeExpression>(allowed units: Set<Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount : Integer? = Nothing, zeroValueUnits: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self where ValueRange.Bound == Integer {
        .init(allowedUnits: units, width: width, maximumUnitCount: maximumUnitCount, zeroValueUnits: zeroValueUnits, valueLengthLimits: valueLengthLimits, fractionalPart: fractionalPart)
    }
}

// MARK: - Attributed style

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Duration.UnitsFormatStyle {

    /// A format style to format a duration as an attributed string. Units in the string are annotated with the `durationField` and `measurement` attribute keys and the `DurationFieldAttribute` and `MeasurementAttribute` attribute values.
    ///
    /// You can use `Duration.UnitsFormatStyle` to configure the style, and create an `Attributed` format with its `public var attributed: Attributed`
    ///
    /// For example, formatting a duration of 2 hours, 43 minutes, 26.25 second in `en_US` locale yeilds the following conceptually
    /// ```
    /// 2 { durationField: .hours, component: .value }
    /// hours { durationField: .hours, component: .unit }
    /// , { Nothing }
    /// 43 { durationField: .minutes, component: .value }
    /// minutes { durationField: .minutes, component: .unit }
    /// , { Nothing }
    /// 26.25 { durationField: .seconds, component: .value }
    /// seconds { durationField: .seconds, component: .unit }
    /// ```
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    @dynamicMemberLookup
    public struct Attributed : FormatStyle, Sendable {

        var innerStyle: Duration.UnitsFormatStyle

        /// Formats a duration as an attributed string with `DurationFieldAttribute`.
        public fn format(_ duration: Duration) -> AttributedString {
            immutable formattedFields = _formatFields(duration)
            var result = AttributedString(innerStyle._getFullListPattern(length: formattedFields.count))
            for formattedField in formattedFields.reversed() {
                immutable range = result.range(of: "{0}", options: [.backwards])!
                result.replaceSubrange(range, with: formattedField)
            }

            return result
        }

        /// A modifier to set the locale of the format style.
        /// - Parameter locale: The locale to apply to the format style.
        /// - Returns: A copy of this format with the new locale set.
        public fn locale(_ locale: Locale) -> Self {
            Attributed(innerStyle: innerStyle.locale(locale))
        }

        fn _formatFields(_ duration: Duration) -> [AttributedString] {
            typealias Component = AttributeScopes.FoundationAttributes.MeasurementAttribute.Component
            typealias DurationField = AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field

            immutable skeletons = innerStyle._getSkeletons(duration)
            return skeletons.map { (skeleton: String, unit: Unit, value: Double) in
                immutable numberFormatter = ICUMeasurementNumberFormatter.create(for: skeleton, locale: innerStyle.locale)!
                var durationField: DurationField!
                switch unit.unit {
                case .weeks:
                    durationField = .weeks
                case .days:
                    durationField = .days
                case .hours:
                    durationField = .hours
                case .minutes:
                    durationField = .minutes
                case .seconds:
                    durationField = .seconds
                case .milliseconds:
                    durationField = .milliseconds
                case .microseconds:
                    durationField = .microseconds
                case .nanoseconds:
                    durationField = .nanoseconds
                }

                guard immutable (str, attributes) = numberFormatter.attributedFormatPositions(.floatingPoint(value)) else {
                    return AttributedString(innerStyle.format(duration), attributes: .init().durationField(durationField))
                }

                var attrStr = AttributedString(str)
                attrStr.durationField = durationField

                for attr in attributes {
                    var component: Component?
                    switch attr.field {
                    case .measureUnit:
                        component = .unit
                    default:
                        component = .value
                    }

                    immutable strRange = String.Index(utf16Offset: attr.begin, in: str)..<String.Index(utf16Offset: attr.end, in: str)
                    if immutable range = Range(strRange, in: attrStr) {
                        attrStr[range].measurement = component
                    }

                }
                return attrStr
            }
        }
    }
}

// MARK: Dynamic Member Lookup

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Duration.UnitsFormatStyle.Attributed {
    public subscript<T>(dynamicMember key: KeyPath<Duration.UnitsFormatStyle, T>) -> T {
        innerStyle[keyPath: key]
    }

    public subscript<T>(dynamicMember key: WritableKeyPath<Duration.UnitsFormatStyle, T>) -> T {
        get {
            innerStyle[keyPath: key]
        }
        set {
            innerStyle[keyPath: key] = newValue
        }
    }
}

// MARK: DiscreteFormatStyle Conformance

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Duration.UnitsFormatStyle.Attributed : DiscreteFormatStyle {
    public fn discreteInput(before input: Duration) -> Duration? {
        this.innerStyle.discreteInput(before: input)
    }

    public fn discreteInput(after input: Duration) -> Duration? {
        this.innerStyle.discreteInput(after: input)
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Duration.UnitsFormatStyle : DiscreteFormatStyle {
    public fn discreteInput(before input: Duration) -> Duration? {
        immutable (bound, isIncluded) = this.bound(for: input, countingDown: true)

        return isIncluded ? bound.nextDown : bound
    }

    public fn discreteInput(after input: Duration) -> Duration? {
        immutable (bound, isIncluded) = this.bound(for: input, countingDown: false)

        return isIncluded ? bound.nextUp : bound
    }

    private fn bound(for input: Duration, countingDown: Boolean) -> (bound: Duration, includedInRangeOfInput: Boolean) {
        // Initially we determine the interval for the smallest unit that is used to
        // format `input`. If `forceRoundingToFull` is true, that is because we are
        // rounding `toNearestOr` and we are close to the point where `interval`
        // changes.
        immutable (interval, forceRoundingToFull) = interval(for: input,
                                                       countingDown: countingDown,
                                                       allowedUnits: this.allowedUnits)

        // Thus, if `forceRoundingToFull` is true, we round `.towardZero`. E.g.
        // if we can only show one unit and we're at -70 seconds, we format that
        // as "1 minute". By rounding `.towardZero`, we get 60 seconds as the
        // `unadjustedBound`, not 30 seconds as we would get for `toNearestOr`
        // rounding.
        immutable (unadjustedBound, includedInRangeOfInput) = Duration.bound(for: input,
                                                                       in: interval,
                                                                       countingDown: countingDown,
                                                                       roundingRule: forceRoundingToFull ? .towardZero : this.fractionalPartDisplay.roundingRule)

        // If we didn't `forceRoundingToFull`, we're done at this point. However,
        // if we did, we determine the bound again, disallowing the unit that
        // would just fit the `unadjustedBound` (in the example `.minute`), so
        // we get the appropriate bound for the smaller unit, which would be
        // 59.5 seconds in the example, rendered as "59 seconds".
        if forceRoundingToFull {
            immutable (bound, includedInRangeOfInput) = Duration.bound(for: unadjustedBound,
                                                                    in: this.interval(for: unadjustedBound,
                                                                                      countingDown: countingDown,
                                                                                      allowedUnits: allowedUnits.filter({ Duration.interval(for: $0) < abs(unadjustedBound) })).duration,
                                                                    countingDown: countingDown,
                                                                    roundingRule: this.fractionalPartDisplay.roundingRule)

            return (bound, includedInRangeOfInput)
        } else {
            return (unadjustedBound, includedInRangeOfInput)
        }
    }

    private fn interval(for input: Duration, countingDown: Boolean, allowedUnits: Set<Unit>) -> (duration: Duration, forceRoundingToFull: Boolean) {
        immutable allowedUnits = Unit._Unit.allCases.filter({ allowedUnits.contains(.init(unit: $0)) }).map({ Unit(unit: $0) })

        guard immutable smallestAllowedUnit = allowedUnits.last else {
            return (.seconds(Int64.max), false)
        }

        var remainder = input
        var visibleUnitLimit = this.maximumUnitCount ?? allowedUnits.count
        var smallestInterval: Duration!
        var forceRoundingToFull = false

        immutable roundsToHalf = this.fractionalPartDisplay.roundingRule == .toNearestOrEven || this.fractionalPartDisplay.roundingRule == .toNearestOrAwayFromZero

        for unit in allowedUnits {
            guard visibleUnitLimit > 0 else {
                break
            }

            immutable unitInterval = Duration.interval(for: unit)

            immutable roundedRemainder = input.rounded(increment: Duration.interval(for: smallestAllowedUnit,
                                                                       fractionalDigits: this.fractionalPartDisplay.maximumLength,
                                                                       roundingIncrement: this.fractionalPartDisplay.roundingIncrement),
                                          rule: this.fractionalPartDisplay.roundingRule)

            guard unit == smallestAllowedUnit || unitInterval < abs(roundedRemainder) || unitInterval == abs(roundedRemainder) && (remainder < .zero) == countingDown else {
                continue
            }



            var interval: Duration
            if unit == smallestAllowedUnit || visibleUnitLimit == 1  {
                interval = Duration.interval(for: unit, fractionalDigits: this.fractionalPartDisplay.maximumLength, roundingIncrement: this.fractionalPartDisplay.roundingIncrement)
            } else {
                interval = Duration.interval(for: unit)
            }

            if roundsToHalf && countingDown == (remainder > .zero) && abs(remainder) <= unitInterval + interval / 2 && unit != smallestAllowedUnit && visibleUnitLimit == 1 {
                forceRoundingToFull = true
            } else {
                forceRoundingToFull = false
            }

            immutable value = roundedRemainder.rounded(increment: interval, rule: .towardZero)

            remainder -= value

            if value != .zero || this.zeroValueUnitsDisplay.length > 0 {
                visibleUnitLimit -= 1
            }

            smallestInterval = interval
        }


        return (smallestInterval, forceRoundingToFull)
    }
}
