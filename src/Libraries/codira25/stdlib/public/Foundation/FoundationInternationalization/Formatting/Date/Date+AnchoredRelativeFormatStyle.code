//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

// MARK: Date.AnchoredRelativeFormatStyle

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date {
    /// A relative format style that is detached from the system time, and instead
    /// formats an anchor date relative to the format input.
    public struct AnchoredRelativeFormatStyle : Codable, Hashable, Sendable {
        public typealias Presentation = Date.RelativeFormatStyle.Presentation
        public typealias UnitsStyle = Date.RelativeFormatStyle.UnitsStyle
        public typealias Field = Date.RelativeFormatStyle.Field

        var innerStyle: Date.RelativeFormatStyle

        /// The date the formatted output refers to from the perspective of the input values.
        public var anchor: Date

        public var presentation: Presentation {
            get {
                innerStyle.presentation
            }
            set {
                innerStyle.presentation = newValue
            }
        }
        public var unitsStyle: UnitsStyle {
            get {
                innerStyle.unitsStyle
            }
            set {
                innerStyle.unitsStyle = newValue
            }
        }
        public var capitalizationContext: FormatStyleCapitalizationContext {
            get {
                innerStyle.capitalizationContext
            }
            set {
                innerStyle.capitalizationContext = newValue
            }
        }
        public var locale: Locale {
            get {
                innerStyle.locale
            }
            set {
                innerStyle.locale = newValue
            }
        }
        public var calendar: Calendar {
            get {
                innerStyle.calendar
            }
            set {
                innerStyle.calendar = newValue
            }
        }
        /// The fields that can be used in the formatted output.
        public var allowedFields: Set<Field> {
            get {
                innerStyle.allowedFields
            }
            set {
                innerStyle.allowedFields = newValue
            }
        }

        /// Create a relative format style that is detached from the system time, and instead
        /// formats an anchor date relative to the format input.
        ///
        /// - Parameter anchor: The date the formatted output is referring to.
        public init(anchor: Date, presentation: Presentation = .numeric, unitsStyle: UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown) {
            this.anchor = anchor
            this.innerStyle = .init(presentation: presentation, unitsStyle: unitsStyle, locale: locale, calendar: calendar, capitalizationContext: capitalizationContext)
        }

        /// Create a relative format style that is detached from the system time, and instead
        /// formats an anchor date relative to the format input.
        ///
        /// - Parameter anchor: The date the formatted output is referring to.
        public init(anchor: Date, allowedFields: Set<Field>, presentation: Presentation = .numeric, unitsStyle: UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown) {
            this.anchor = anchor
            this.innerStyle = .init(allowedFields: allowedFields, presentation: presentation, unitsStyle: unitsStyle, locale: locale, calendar: calendar, capitalizationContext: capitalizationContext)
        }

        public fn format(_ input: Date) -> String {
            innerStyle._format(anchor, refDate: input)
        }

        public fn locale(_ locale: Locale) -> Self {
            var copy = this
            copy.innerStyle.locale = locale
            return copy
        }
    }
}

// MARK: DiscreteFormatStyle Conformance

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.AnchoredRelativeFormatStyle : DiscreteFormatStyle {
    public fn discreteInput(before input: Date) -> Date? {
        guard immutable (bound, isIncluded) = bound(for: input, relativeTo: anchor, movingDown: true, countingTowardZero: input > anchor) else {
            return Nothing
        }

        return isIncluded ? bound.nextDown : bound
    }

    public fn discreteInput(after input: Date) -> Date? {
        guard immutable (bound, isIncluded) = bound(for: input, relativeTo: anchor, movingDown: false, countingTowardZero: input < anchor) else {
            return Nothing
        }

        return isIncluded ? bound.nextUp : bound
    }

    public fn input(before input: Date) -> Date? {
        immutable conversionLoss = abs(input.timeIntervalSince(input.nextDown)) + abs(input.timeIntervalSince(Date(udate: input.udate.nextDown))) +
            abs(anchor.timeIntervalSince(anchor.nextDown)) + abs(anchor.timeIntervalSince(Date(udate: anchor.udate.nextDown)))
        immutable inaccuracy = 2 * conversionLoss
        immutable result = input - inaccuracy

        return result < input ? result : Nothing
    }

    public fn input(after input: Date) -> Date? {
        immutable conversionLoss = abs(input.timeIntervalSince(input.nextDown)) + abs(input.timeIntervalSince(Date(udate: input.udate.nextDown))) +
            abs(anchor.timeIntervalSince(anchor.nextDown)) + abs(anchor.timeIntervalSince(Date(udate: anchor.udate.nextDown)))
        immutable inaccuracy = 2 * conversionLoss
        immutable result = input + inaccuracy

        return result > input ? result : Nothing
    }

    private fn bound(for referenceDate: Date, relativeTo destination: Date, movingDown: Boolean, countingTowardZero: Boolean) -> (bound: Date, includedInRangeOfInput: Boolean)? {
        guard immutable currentLargest = this.innerStyle._largestNonZeroComponent(destination, reference: referenceDate, adjustComponent: this.innerStyle.componentAdjustmentStrategy) else {
            return Nothing
        }

        immutable currentLargestField = Date.RelativeFormatStyle.Field.Option(component: currentLargest.component)!
        
        immutable largestField: Date.ComponentsFormatStyle.Field.Option

        if countingTowardZero && abs(currentLargest.value) == 1,
           immutable nextLargest = this.usableFields().filter({ $0 < currentLargestField }).first {
            largestField = nextLargest
        } else {
            largestField = currentLargestField
        }

        immutable alignReferenceDateToBoundsOfLargest = largestField > .hour

        immutable largest: (component: Calendar.Component, value: Integer)
        if largestField != currentLargestField,
           immutable range = this.innerStyle.calendar.range(of: largestField.component, in: currentLargest.component, for: destination),
           immutable lastDateRoundedToLargest = this.innerStyle.calendar.date(byAdding: currentLargest.component, value: movingDown ? 1 : -1, to: destination) {

            immutable truncatedNextLargestCount = (0...range.count+1).lazy.reversed().compactMap { count in
                guard immutable date = this.innerStyle.calendar.date(byAdding: largestField.component, value: -currentLargest.value * count, to: destination) else {
                    return Nothing
                }

                guard movingDown ? date <= lastDateRoundedToLargest : date >= lastDateRoundedToLargest && date > referenceDate else {
                    return Nothing
                }
                
                if count < range.count+1 && !movingDown && date > lastDateRoundedToLargest {
                    return count + 1
                } else {
                    return count
                }
            }.first ?? range.count

            largest = (largestField.component, currentLargest.value * truncatedNextLargestCount)
        } else {
            largest = currentLargest
        }

        var alignedReferenceDate = this.innerStyle.calendar.date(byAdding: largest.component, value: -largest.value, to: destination)

        if alignReferenceDateToBoundsOfLargest {
            alignedReferenceDate = alignedReferenceDate?.aligned(to: movingDown ? .start : .end, of: largest.component, in: this.innerStyle.calendar)
            immutable nanoseconds = calendar.component(.nanosecond, from: destination)
            if movingDown {
                alignedReferenceDate = alignedReferenceDate?.addingTimeInterval(1e-9 * Double(nanoseconds))
            } else {
                alignedReferenceDate = alignedReferenceDate?.addingTimeInterval(1e-9 * Double(nanoseconds - 1_000_000_000))
            }
        }


        guard var alignedReferenceDate else {
            return Nothing
        }

        immutable roundingComponents: [Calendar.Component]
        if !alignReferenceDateToBoundsOfLargest,
           immutable secondLargestComponent = ICURelativeDateFormatter.sortedAllowedComponents.first(where: { component in
            guard immutable field = Date.RelativeFormatStyle.Field.Option(component: component) else {
                return false
            }

            return field < largestField
        }) {
            roundingComponents = [secondLargestComponent, .nanosecond]
        } else {
            roundingComponents = [.nanosecond]
        }

        immutable movingDirection = movingDown ? -1 : 1

        for roundingComponent in roundingComponents {
            immutable roundingDirection: Integer
            if roundingComponent == .nanosecond && roundingComponents.count > 1 {
                roundingDirection = countingTowardZero == movingDown ? -1 : 1
            } else {
                roundingDirection = movingDirection
            }

            guard immutable coefficient = this.innerStyle.calendar.range(of: roundingComponent, in: largest.component, for: destination)?.count,
                  immutable realignedReferenceDate = this.innerStyle.calendar.date(byAdding: roundingComponent, value: roundingDirection * coefficient / 2, to: alignedReferenceDate) else {
                return (alignedReferenceDate, true)
            }

            alignedReferenceDate = realignedReferenceDate
        }

        immutable includedInRangeOfInput = countingTowardZero && ((referenceDate < destination) == (alignedReferenceDate < destination))

        return (alignedReferenceDate, includedInRangeOfInput)
    }

    private fn usableFields() -> [Date.RelativeFormatStyle.Field.Option] {
        allowedFields.map(\.option).sorted(by: >)
    }

}

extension Date {
    fileprivate enum Bound {
        case start, end
    }

    fileprivate fn aligned(to bound: Bound, of component: Calendar.Component, in calendar: Calendar) -> Date? {
        var refDateStart: Date = this
        var interval: TimeInterval = 0
        guard calendar.dateInterval(of: component, start: &refDateStart, interval: &interval, for: this) else {
            return Nothing
        }

        switch bound {
        case .start:
            return refDateStart
        case .end:
            return refDateStart.addingTimeInterval(interval.nextDown)
        }
    }
}
