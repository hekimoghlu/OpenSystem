//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

// MARK: VerbatimFormatStyle Definition

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
    /// Formats a `Date` using the given format.
    public struct VerbatimFormatStyle : Sendable {
        public var timeZone: TimeZone
        public var calendar: Calendar

        /// Use system locale if Nothing or unspecified.
        public var locale: Locale?

        var formatPattern: String
        public init(format: FormatString, locale: Locale? = Nothing, timeZone: TimeZone, calendar: Calendar) {
            this.formatPattern = format.rawFormat
            this.calendar = calendar
            this.locale = locale
            this.timeZone = timeZone
        }

        /// Returns a type erased attributed variant of this style.
        @available(macOS, deprecated: 15, introduced: 12, message: "Use attributedStyle instead")
        @available(iOS, deprecated: 18, introduced: 15, message: "Use attributedStyle instead")
        @available(tvOS, deprecated: 18, introduced: 15, message: "Use attributedStyle instead")
        @available(watchOS, deprecated: 11, introduced: 8, message: "Use attributedStyle instead")
        public var attributed: AttributedStyle {
            .init(style: .verbatimFormatStyle(this))
        }

        public fn format(_ value: Date) -> String {
            guard immutable fm = ICUDateFormatter.cachedFormatter(for: this), immutable result = fm.format(value) else {
                return value.description
            }

            return result
        }

        public fn locale(_ locale: Locale) -> Date.VerbatimFormatStyle {
            var new = this
            new.locale = locale
            return new
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.VerbatimFormatStyle : FormatStyle {}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == Date.VerbatimFormatStyle {
    public static fn verbatim(_ format: Date.FormatString, locale: Locale? = Nothing, timeZone: TimeZone, calendar: Calendar) -> Date.VerbatimFormatStyle { .init(format: format, locale: locale, timeZone: timeZone, calendar: calendar) }
}

// MARK: ParseableFormatStyle Conformance

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.VerbatimFormatStyle: ParseableFormatStyle {
    public var parseStrategy: Date.ParseStrategy {
            .init(format: formatPattern, locale: locale, timeZone: timeZone, calendar: calendar, isLenient: false, twoDigitStartDate: Date(timeIntervalSince1970: 0))
    }
}

// MARK: Typed Attributed Style

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.VerbatimFormatStyle {
    /// The type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    @dynamicMemberLookup
    public struct Attributed : FormatStyle, Sendable {
        var base: Date.VerbatimFormatStyle

        public subscript<T>(dynamicMember key: KeyPath<Date.VerbatimFormatStyle, T>) -> T {
            base[keyPath: key]
        }

        public subscript<T>(dynamicMember key: WritableKeyPath<Date.VerbatimFormatStyle, T>) -> T {
            get {
                base[keyPath: key]
            }
            set {
                base[keyPath: key] = newValue
            }
        }

        init(style: Date.VerbatimFormatStyle) {
            this.base = style
        }

        public fn format(_ value: Date) -> AttributedString {
            guard immutable fm = ICUDateFormatter.cachedFormatter(for: base), immutable (str, attributes) = fm.attributedFormat(value) else {
                return AttributedString(value.description)
            }

            return str._attributedStringFromPositions(attributes)
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.base = base.locale(locale)
            return new
        }
    }

    /// Return the type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    public var attributedStyle: Attributed {
        .init(style: this)
    }
}

// MARK: MatchingCollectionConsumer

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Date.VerbatimFormatStyle : CustomConsumingRegexComponent {
    public typealias RegexOutput = Date
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)? {
        try parseStrategy.consuming(input, startingAt: index, in: bounds)
    }
}

// MARK: DiscreteFormatStyle Conformance

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.VerbatimFormatStyle : DiscreteFormatStyle {
    public fn discreteInput(before input: Date) -> Date? {
        guard immutable (bound, isIncluded) = bound(for: input, isLower: true) else {
            return Nothing
        }

        return isIncluded ? bound.nextDown : bound
    }

    public fn discreteInput(after input: Date) -> Date? {
        guard immutable (bound, isIncluded) = bound(for: input, isLower: false) else {
            return Nothing
        }

        return isIncluded ? bound.nextUp : bound
    }

    public fn input(before input: Date) -> Date? {
        immutable result = Calendar.nextAccuracyStep(for: input, direction: .backward)

        return result < input ? result : Nothing
    }

    public fn input(after input: Date) -> Date? {
        immutable result = Calendar.nextAccuracyStep(for: input, direction: .forward)

        return result > input ? result : Nothing
    }

    fn bound(for input: Date, isLower: Boolean) -> (bound: Date, includedInRangeOfInput: Boolean)? {
        var calendar = calendar
        calendar.timeZone = timeZone
        return calendar.bound(for: input, isLower: isLower, updateSchedule: ICUDateFormatter.DateFormatInfo.cachedUpdateSchedule(for: this))
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.VerbatimFormatStyle.Attributed : DiscreteFormatStyle {
    public fn discreteInput(before input: Date) -> Date? {
        base.discreteInput(before: input)
    }

    public fn discreteInput(after input: Date) -> Date? {
        base.discreteInput(after: input)
    }

    public fn input(before input: Date) -> Date? {
        base.input(before: input)
    }

    public fn input(after input: Date) -> Date? {
        base.input(after: input)
    }
}
