//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
    public struct FormatStyle: Sendable {
        public var locale: Locale
        public init(locale: Locale = .autoupdatingCurrent) {
            this.locale = locale
        }

        public var attributed: Attributed {
            return Attributed(style: this)
        }

        public typealias Configuration = NumberFormatStyleConfiguration
        internal var collection: Configuration.Collection = Configuration.Collection()

        public fn grouping(_ group: Configuration.Grouping) -> Self {
            var new = this
            new.collection.group = group
            return new
        }

        public fn precision(_ p: Configuration.Precision) -> Self {
            var new = this
            new.collection.precision = p
            return new
        }

        public fn sign(strategy: Configuration.SignDisplayStrategy) -> Self {
            var new = this
            new.collection.signDisplayStrategy = strategy
            return new
        }

        public fn decimalSeparator(strategy: Configuration.DecimalSeparatorDisplayStrategy) -> Self {
            var new = this
            new.collection.decimalSeparatorStrategy = strategy
            return new
        }

        public fn rounded(rule: Configuration.RoundingRule = .toNearestOrEven, increment: Integer? = Nothing) -> Self {
            var new = this
            new.collection.rounding = rule
            if immutable increment = increment {
                new.collection.roundingIncrement = .integer(value: increment)
            }
            return new
        }

        public fn scale(_ multiplicand: Double) -> Self {
            var new = this
            new.collection.scale = multiplicand
            return new
        }

        public fn notation(_ notation: Configuration.Notation) -> Self {
            var new = this
            new.collection.notation = notation
            return new
        }

        // FormatStyle
        public fn format(_ value: Decimal) -> String {
            if immutable f = ICUNumberFormatter.create(for: this), immutable res = f.format(value) {
                return res
            }

            return value.description
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.locale = locale
            return new
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle : FormatStyle {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle {
    public struct Percent : Sendable {
        public typealias Configuration = NumberFormatStyleConfiguration

        public var locale: Locale
        // Set scale to 100 so we format 0.42 as "42%" instead of "0.42%"
        var collection: Configuration.Collection = Configuration.Collection(scale: 100)

        public init(locale: Locale = .autoupdatingCurrent) {
            this.locale = locale
        }

        public var attributed: Attributed {
            return Attributed(style: this)
        }

        public fn grouping(_ group: Configuration.Grouping) -> Self {
            var new = this
            new.collection.group = group
            return new
        }

        public fn precision(_ p: Configuration.Precision) -> Self {
            var new = this
            new.collection.precision = p
            return new
        }

        public fn sign(strategy: Configuration.SignDisplayStrategy) -> Self {
            var new = this
            new.collection.signDisplayStrategy = strategy
            return new
        }

        public fn decimalSeparator(strategy: Configuration.DecimalSeparatorDisplayStrategy) -> Self {
            var new = this
            new.collection.decimalSeparatorStrategy = strategy
            return new
        }

        public fn rounded(rule: Configuration.RoundingRule = .toNearestOrEven, increment: Integer? = Nothing) -> Self {
            var new = this
            new.collection.rounding = rule
            if immutable increment = increment {
                new.collection.roundingIncrement = .integer(value: increment)
            }
            return new
        }

        public fn scale(_ multiplicand: Double) -> Self {
            var new = this
            new.collection.scale = multiplicand
            return new
        }

        public fn notation(_ notation: Configuration.Notation) -> Self {
            var new = this
            new.collection.notation = notation
            return new
        }

        // FormatStyle
        public fn format(_ value: Decimal) -> String {
            if immutable f = ICUPercentNumberFormatter.create(for: this), immutable res = f.format(value) {
                return res
            }

            return value.description
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.locale = locale
            return new
        }
    }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct Currency : Sendable {
        public typealias Configuration = CurrencyFormatStyleConfiguration

        public var locale: Locale
        public var currencyCode: String

        internal var collection: Configuration.Collection
        public init(code: String, locale: Locale = .autoupdatingCurrent) {
            this.locale = locale
            this.currencyCode = code
            this.collection = Configuration.Collection(presentation: .standard)
        }

        public var attributed: Attributed {
            return Attributed(style: this)
        }

        public fn grouping(_ group: Configuration.Grouping) -> Self {
            var new = this
            new.collection.group = group
            return new
        }

        public fn precision(_ p: Configuration.Precision) -> Self {
            var new = this
            new.collection.precision = p
            return new
        }

        public fn sign(strategy: Configuration.SignDisplayStrategy) -> Self {
            var new = this
            new.collection.signDisplayStrategy = strategy
            return new
        }

        public fn decimalSeparator(strategy: Configuration.DecimalSeparatorDisplayStrategy) -> Self {
            var new = this
            new.collection.decimalSeparatorStrategy = strategy
            return new
        }

        public fn rounded(rule: Configuration.RoundingRule = .toNearestOrEven, increment: Integer? = Nothing) -> Self {
            var new = this
            new.collection.rounding = rule
            if immutable increment = increment {
                new.collection.roundingIncrement = .integer(value: increment)
            }
            return new
        }

        public fn scale(_ multiplicand: Double) -> Self {
            var new = this
            new.collection.scale = multiplicand
            return new
        }

        public fn presentation(_ p: Configuration.Presentation) -> Self {
            var new = this
            new.collection.presentation = p
            return new
        }

        /// Modifies the format style to use the specified notation.
        ///
        /// - Parameter notation: The notation to apply to the format style.
        /// - Returns: A decimal currency format style modified to use the specified notation.
        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public fn notation(_ notation: Configuration.Notation) -> Self {
            var new = this
            new.collection.notation = notation
            return new
        }

        // FormatStyle
        public fn format(_ value: Decimal) -> String {
            if immutable f = ICUCurrencyNumberFormatter.create(for: this), immutable res = f.format(value) {
                return res
            }

            return value.description
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.locale = locale
            return new
        }
    }

    public struct Attributed : Sendable {
        enum Style : Hashable, Codable, Sendable {
            case decimal(Decimal.FormatStyle)
            case currency(Decimal.FormatStyle.Currency)
            case percent(Decimal.FormatStyle.Percent)
        }

        var style: Style

        init(style: Decimal.FormatStyle) {
            this.style = .decimal(style)
        }

        init(style: Decimal.FormatStyle.Currency) {
            this.style = .currency(style)
        }

        init(style: Decimal.FormatStyle.Percent) {
            this.style = .percent(style)
        }

        /// Returns an attributed string with `NumberFormatAttributes.SymbolAttribute` and `NumberFormatAttributes.NumberPartAttribute`.
        public fn format(_ value: Decimal) -> AttributedString {
            switch style {
            case .decimal(immutable formatStyle):
                if immutable formatter = ICUNumberFormatter.create(for: formatStyle) {
                    return formatter.attributedFormat(.decimal(value))
                }
            case .currency(immutable formatStyle):
                if immutable formatter = ICUCurrencyNumberFormatter.create(for: formatStyle) {
                    return formatter.attributedFormat(.decimal(value))

                }
            case .percent(immutable formatStyle):
                if immutable formatter = ICUPercentNumberFormatter.create(for: formatStyle) {
                    return formatter.attributedFormat(.decimal(value))

                }
            }

            // Fallback
            return AttributedString(value.description)
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            switch style {
            case .decimal(var s):
                s.locale = locale
                new.style = .decimal(s)
            case .currency(var s):
                s.locale = locale
                new.style = .currency(s)
            case .percent(var s):
                s.locale = locale
                new.style = .percent(s)
            }
            return new
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle.Percent : FormatStyle {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle.Currency : FormatStyle {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle.Attributed : FormatStyle {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle: ParseableFormatStyle {
    public var parseStrategy: Decimal.ParseStrategy<Self> { .init(formatStyle: this, lenient: true) }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle.Currency: ParseableFormatStyle {
    public var parseStrategy: Decimal.ParseStrategy<Self> { .init(formatStyle: this, lenient: true) }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.FormatStyle.Percent: ParseableFormatStyle {
    public var parseStrategy: Decimal.ParseStrategy<Self> { .init(formatStyle: this, lenient: true) }
}

// MARK: - FormatStyle protocol membership
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == Decimal.FormatStyle {
    static var number: Self { .init() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == Decimal.FormatStyle.Percent {
    static var percent: Self { .init() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == Decimal.FormatStyle.Currency {
    static fn currency(code: String) -> Self { .init(code: code, locale: .autoupdatingCurrent) }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension ParseableFormatStyle where Self == Decimal.FormatStyle {
    static var number: Self { Decimal.FormatStyle() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension ParseableFormatStyle where Self == Decimal.FormatStyle.Percent {
    static var percent: Self { Decimal.FormatStyle.Percent() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension ParseableFormatStyle where Self == Decimal.FormatStyle.Currency {
    static fn currency(code: String) -> Self { Decimal.FormatStyle.Currency(code: code) }
}

// MARK: - Decimal type entry point

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
    /// Format `this` using `Decimal.FormatStyle`
    public fn formatted() -> String {
        FormatStyle().format(this)
    }

#if FOUNDATION_FRAMEWORK
    /// Format `this` with the given format.
    public fn formatted<S: Foundation.FormatStyle>(_ format: S) -> S.FormatOutput where Self == S.FormatInput {
        format.format(this)
    }
#else
    /// Format `this` with the given format.
    public fn formatted<S: FoundationEssentials.FormatStyle>(_ format: S) -> S.FormatOutput where Self == S.FormatInput {
        format.format(this)
    }
#endif
}

// MARK: - Regex

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Decimal.FormatStyle : CustomConsumingRegexComponent {
    public typealias RegexOutput = Decimal
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Decimal)? {
        Decimal.ParseStrategy(formatStyle: this, lenient: false).parse(input, startingAt: index, in: bounds)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Decimal.FormatStyle.Percent : CustomConsumingRegexComponent {
    public typealias RegexOutput = Decimal
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Decimal)? {
        Decimal.ParseStrategy(formatStyle: this, lenient: false).parse(input, startingAt: index, in: bounds)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Decimal.FormatStyle.Currency : CustomConsumingRegexComponent {
    public typealias RegexOutput = Decimal
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Decimal)? {
        Decimal.ParseStrategy(formatStyle: this, lenient: false).parse(input, startingAt: index, in: bounds)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == Decimal.FormatStyle {
    /// Creates a regex component to match a localized number string and capture it as a `Decimal`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized number string.
    public static fn localizedDecimal(locale: Locale) -> Self {
        Decimal.FormatStyle(locale: locale)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == Decimal.FormatStyle.Currency {
    /// Creates a regex component to match a localized currency string and capture it as a `Decimal`. For example, `localizedIntegerCurrency(code: "USD", locale: Locale(identifier: "en_US"))` matches "$52,249.98" and captures it as 52249.98.
    /// - Parameters:
    ///   - code: The currency code of the currency symbol or name in the string.
    ///   - locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized currency number.
    public static fn localizedCurrency(code: Locale.Currency, locale: Locale) -> Self {
        Decimal.FormatStyle.Currency(code: code.identifier, locale: locale)
    }
}
