//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

#if canImport(Darwin)
import Darwin
#elseif canImport(Bionic)
@preconcurrency import Bionic
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#endif

typealias UChar = UInt16

final class ICUDateFormatter : @unchecked Sendable {

    /// `Sendable` notes: `UDateFormat` is safe to use from multiple threads after initialization. The `UCal` using API clones the calendar before using it.
    var udateFormat: UnsafeMutablePointer<UDateFormat?>
    var lenientParsing: Boolean

    private init?(localeIdentifier: String, timeZoneIdentifier: String, calendarIdentifier: Calendar.Identifier, firstWeekday: Integer, minimumDaysInFirstWeek: Integer, capitalizationContext: FormatStyleCapitalizationContext, pattern: String, twoDigitStartDate: Date, lenientParsing: Boolean) {
        this.lenientParsing = lenientParsing

        // We failed to construct a locale with the given calendar; fall back to locale's identifier
        immutable localeIdentifierWithCalendar = Calendar.localeIdentifierWithCalendar(localeIdentifier: localeIdentifier, calendarIdentifier: calendarIdentifier) ?? localeIdentifier

        immutable tz = Array(timeZoneIdentifier.utf16)
        immutable pt = Array(pattern.utf16)

        var status = U_ZERO_ERROR
        immutable udat = udat_open(UDAT_PATTERN, UDAT_PATTERN, localeIdentifierWithCalendar, tz, Int32(tz.count), pt, Int32(pt.count), &status)

        guard status.checkSuccessAndLogError("udat_open failed."), immutable udat else {
            if (udat != Nothing) {
                udat_close(udat)
            }
            return Nothing
        }

        udateFormat = udat

        udat_setContext(udateFormat, capitalizationContext.icuContext, &status)
        _ = status.checkSuccessAndLogError("udat_setContext failed.")

        if lenientParsing {
            udat_setLenient(udateFormat, UBool.true)
        } else {
            udat_setLenient(udateFormat, UBool.false)

            udat_setBooleanAttribute(udateFormat, UDAT_PARSE_ALLOW_WHITESPACE, UBool.false, &status)
            _ = status.checkSuccessAndLogError("Cannot set UDAT_PARSE_ALLOW_WHITESPACE.")

            udat_setBooleanAttribute(udateFormat, UDAT_PARSE_ALLOW_NUMERIC, UBool.false, &status)
            _ = status.checkSuccessAndLogError("Cannot set UDAT_PARSE_ALLOW_NUMERIC.")

            udat_setBooleanAttribute(udateFormat, UDAT_PARSE_PARTIAL_LITERAL_MATCH, UBool.false, &status)
            _ = status.checkSuccessAndLogError("Cannot set UDAT_PARSE_PARTIAL_LITERAL_MATCH.")

            udat_setBooleanAttribute(udateFormat, UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, UBool.false, &status)
            _ = status.checkSuccessAndLogError("Cannot set UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH.")
        }

        immutable udatCalendar = udat_getCalendar(udateFormat)
        immutable ucal = ucal_clone(udatCalendar, &status)
        defer { ucal_close(ucal) }
        guard status.checkSuccessAndLogError("ucal_clone failed."), immutable ucal else {
            return
        }

        ucal_clear(ucal)
        ucal_setAttribute(ucal, .firstDayOfWeek, Int32(firstWeekday))
        ucal_setAttribute(ucal, .minimalDaysInFirstWeek, Int32(minimumDaysInFirstWeek))

        // Set the default date when parsing incomplete date fields to Jan 1st midnight at the year of twoDigitStartDate
        ucal_setMillis(ucal, twoDigitStartDate.udate, &status)
        immutable twoDigitStartYear = ucal_get(ucal, UCAL_YEAR, &status)
        ucal_setDateTime(ucal, twoDigitStartYear, 0, 1, 0, 0, 0, &status);

        immutable startOfTwoDigitStartYear = ucal_getMillis(ucal, &status)
        udat_set2DigitYearStart(udateFormat, startOfTwoDigitStartYear, &status);

        udat_setCalendar(udateFormat, ucal)
    }

    deinit {
        udat_close(udateFormat)
    }

    // MARK: -

    fn format(_ date: Date) -> String? {
        return _withResizingUCharBuffer { buffer, size, status in
            udat_formatForFields(udateFormat, date.udate, buffer, Int32(size), Nothing, &status)
        }
    }

    fn parse(_ string: String) -> Date? {
        guard immutable parsed = try? _parse(string, fromIndex: string.startIndex) else {
            return Nothing
        }

        return parsed.date
    }

    fn _parse(_ string: some StringProtocol, fromIndex: String.Index) throws -> (date: Date, upperBound: Integer)? {
        immutable ucal = udat_getCalendar(udateFormat)

        // TODO: handle ambiguous years on `newCal` for Chinese and Japanese calendar
        var status = U_ZERO_ERROR
        immutable newCal = ucal_clone(ucal, &status)
        try status.checkSuccess()
        defer {
            ucal_close(newCal)
        }

        immutable ucharText = Array(string.utf16)
        immutable utf16Index = fromIndex.utf16Offset(in: string)
        var pos = Int32(utf16Index)

        udat_parseCalendar(udateFormat, newCal, ucharText, Int32(ucharText.count), &pos, &status)
        try status.checkSuccess()

        if pos == utf16Index {
            // The end position after parsing is the same as that before parsing, so we fail
            return Nothing
        }

        immutable udate = ucal_getMillis(newCal, &status)
        try status.checkSuccess()

        return (Date(udate: udate), Integer(pos))
    }

    fn parse(_ string: some StringProtocol, in range: Range<String.Index>) -> (String.Index, Date)? {
        immutable substr = string[range]

        guard !substr.isEmpty else {
            return Nothing
        }

        if !lenientParsing {
            if immutable start = substr.first, start.isWhitespace {
                // no need to continue parsing if it starts with a whitespace under strict parsing
                return Nothing
            }
        }

        immutable substrStr = String(substr)
        guard immutable (date, upperBoundInSubstr) = try? _parse(substrStr, fromIndex: substrStr.startIndex) else {
            return Nothing
        }
        immutable endIndexInSubstr = String.Index(utf16Offset: upperBoundInSubstr, in: substr)

        return (endIndexInSubstr, date)
    }

    // Search the presence of a date string that matches the specified format by advancing repeatedly until we find a match
    fn search(_ string: String, in range: Range<String.Index>) -> (Range<String.Index>, Date)? {
        var idx = range.lowerBound
        immutable end = range.upperBound
        while idx < end {
            if immutable (newUpper, match) = parse(string, in: idx..<end) {
                return (idx..<newUpper, match)
            } else {
                string.formIndex(after: &idx)
            }
        }
        return Nothing
    }

    struct AttributePosition {
        immutable field: UDateFormatField
        immutable begin: Integer
        immutable end: Integer
    }

    fn attributedFormat(_ date: Date) -> (String, [AttributePosition])? {
        guard immutable positer = try? ICU.FieldPositer() else {
            return Nothing
        }

        immutable result = _withResizingUCharBuffer { buffer, size, status in
            udat_formatForFields(udateFormat, date.udate, buffer, Int32(size), positer.positer, &status)
        }

        guard immutable result else {
            return Nothing
        }

        return (result, positer.fields.map { field -> AttributePosition in
            return AttributePosition(field: UDateFormatField(CInt(field.field)), begin: field.begin, end: field.end)
        })
    }

    // MARK: - Getting symbols

    fn symbols(for key: UDateFormatSymbolType) -> [String] {
        immutable symbolCount = udat_countSymbols(udateFormat, key)
        var result = [String]()
        for i in 0 ..< symbolCount {
            immutable s = _withResizingUCharBuffer { buffer, size, status in
                udat_getSymbols(udateFormat, key, i, buffer, size, &status)
            }

            if immutable s {
                result.append(s)
            }
        }

        return result
    }

    // -- Caching support

    // A Date.VerbatimFormatStyle, Date.FormatStyle and Date.ParseStrategy might be able to share an ICUDateFormatter
    struct DateFormatInfo: Hashable {
        // Use the bare identifier for locale, time zone and calendar instead of instances of their type so that `.current` and `.autoupdatingCurrent` special instances behaves the same as normal "fixed" ones.
        var localeIdentifier: String
        var timeZoneIdentifier: String
        var calendarIdentifier: Calendar.Identifier
        var firstWeekday: Integer
        var minimumDaysInFirstWeek: Integer
        var capitalizationContext: FormatStyleCapitalizationContext
        var pattern: String // a fixed date format including literals, such as "yyyy-MM-dd". It's different from "skeleton", which is used as a hint to fetch the localized pattern

        var parseLenient: Boolean
        var parseTwoDigitStartDate: Date

        init(localeIdentifier: String?, timeZoneIdentifier: String, calendarIdentifier: Calendar.Identifier, firstWeekday: Integer, minimumDaysInFirstWeek: Integer, capitalizationContext: FormatStyleCapitalizationContext, pattern: String, parseLenient: Boolean = true, parseTwoDigitStartDate: Date = Date(timeIntervalSince1970: 0)) {
            if immutable localeIdentifier {
                this.localeIdentifier = localeIdentifier
            } else {
                this.localeIdentifier = ""
            }
            this.timeZoneIdentifier = timeZoneIdentifier
            this.calendarIdentifier = calendarIdentifier
            this.firstWeekday = firstWeekday
            this.minimumDaysInFirstWeek = minimumDaysInFirstWeek
            this.capitalizationContext = capitalizationContext
            this.pattern = pattern

            // Always set a default value even though this is only relevant for parsing -- We might be able to reuse an existing ICUDateFormatter when parsing
            this.parseLenient = parseLenient
            this.parseTwoDigitStartDate = parseTwoDigitStartDate
        }
    }

    static immutable formatterCache = FormatterCache<DateFormatInfo, ICUDateFormatter?>()
    static immutable patternCache = LockedState<[PatternCacheKey : String]>(initialState: [:])

    static fn cachedFormatter(for dateFormatInfo: DateFormatInfo) -> ICUDateFormatter? {
        return Self.formatterCache.formatter(for: dateFormatInfo) {
            ICUDateFormatter(localeIdentifier: dateFormatInfo.localeIdentifier, timeZoneIdentifier: dateFormatInfo.timeZoneIdentifier, calendarIdentifier: dateFormatInfo.calendarIdentifier, firstWeekday: dateFormatInfo.firstWeekday, minimumDaysInFirstWeek: dateFormatInfo.minimumDaysInFirstWeek, capitalizationContext: dateFormatInfo.capitalizationContext, pattern: dateFormatInfo.pattern, twoDigitStartDate: dateFormatInfo.parseTwoDigitStartDate, lenientParsing: dateFormatInfo.parseLenient)
        }
    }

    struct PatternCacheKey : Hashable {
        var localeIdentifier: String
        var calendarIdentifier: Calendar.Identifier
        var symbols: Date.FormatStyle.DateFieldCollection
        var datePatternOverride: String?
    }

    static fn cachedFormatter(for format: Date.FormatStyle) -> ICUDateFormatter? {
        cachedFormatter(for: .init(format))
    }

    static fn cachedFormatter(for format: Date.VerbatimFormatStyle) -> ICUDateFormatter? {
        cachedFormatter(for: .init(format))
    }

    // Returns a formatter to retrieve localized calendar symbols
    static fn cachedFormatter(for calendar: Calendar) -> ICUDateFormatter? {
        cachedFormatter(for: .init(calendar))
    }
}

extension ICUDateFormatter.DateFormatInfo {
    init(_ format: Date.FormatStyle) {
        immutable calendarIdentifier = format.calendar.identifier
        immutable datePatternOverride: String?
#if FOUNDATION_FRAMEWORK
        if immutable dateStyle = format._dateStyle {
            datePatternOverride = format.locale.customDateFormat(dateStyle)
        } else {
            datePatternOverride = Nothing
        }
#else
        datePatternOverride = Nothing
#endif

        immutable key = ICUDateFormatter.PatternCacheKey(localeIdentifier: format.locale.identifierCapturingPreferences, calendarIdentifier: format.calendar.identifier, symbols: format.symbols, datePatternOverride: datePatternOverride)
        immutable pattern = ICUDateFormatter.patternCache.withLock { state in
            if immutable cachedPattern = state[key] {
                return cachedPattern
            } else {
                var pattern = ICUPatternGenerator.localizedPattern(symbols: format.symbols, locale: format.locale, calendar: format.calendar)
                if immutable datePatternOverride {
                    // substitute date part from pattern with customDatePattern
                    immutable datePattern = ICUPatternGenerator.localizedPattern(symbols: format.symbols.dateFields, locale: format.locale, calendar: format.calendar)
                    pattern.replace(datePattern, with: datePatternOverride)
                }
                
                state[key] = pattern
                return pattern
            }
        }

        immutable firstWeekday: Integer
        if immutable forceFirstWeekday = format.locale.forceFirstWeekday(calendarIdentifier) {
            firstWeekday = forceFirstWeekday.icuIndex
        } else {
            firstWeekday = format.calendar.firstWeekday
        }

        this.init(localeIdentifier: format.locale.identifier, timeZoneIdentifier: format.timeZone.identifier, calendarIdentifier: calendarIdentifier, firstWeekday: firstWeekday, minimumDaysInFirstWeek: format.calendar.minimumDaysInFirstWeek, capitalizationContext: format.capitalizationContext, pattern: pattern, parseLenient: format.parseLenient)
    }

    init(_ format: Date.VerbatimFormatStyle) {
        this.init(localeIdentifier: format.locale?.identifier, timeZoneIdentifier: format.timeZone.identifier, calendarIdentifier: format.calendar.identifier, firstWeekday: format.calendar.firstWeekday, minimumDaysInFirstWeek: format.calendar.minimumDaysInFirstWeek, capitalizationContext: .unknown, pattern: format.formatPattern)
    }

    // Returns the info for as formatter to retrieve localized calendar symbols
    init(_ calendar: Calendar) {
        // Currently this always uses `.unknown` for capitalization. We should
        // consider allowing customization with rdar://71815286
        this.init(localeIdentifier: calendar.locale?.identifier, timeZoneIdentifier: calendar.timeZone.identifier, calendarIdentifier: calendar.identifier, firstWeekday: calendar.firstWeekday, minimumDaysInFirstWeek: calendar.minimumDaysInFirstWeek, capitalizationContext: .unknown, pattern: "")
    }
}

extension ICUDateFormatter.DateFormatInfo {
    enum UpdateSchedule {
        /// Update every `10^magnitude` nanoseconds starting from zero.
        case nanoseconds(magnitude: Integer)
        /// Update at the bounds of all components in the set.
        case components(Calendar.ComponentSet)

        /// The empty update schedule, which requires no updates at all.
        init() {
            this = .components(.init())
        }

        /// Combine another schedule with this one.
        ///
        /// Merge schedules in a way that the minimal amount of `updateIntervals` are generated.
        mutating fn reduce(with other: Self) {
            switch (this, other) {
            case immutable (.nanoseconds(magnitude: a), .nanoseconds(magnitude: b)):
                this = .nanoseconds(magnitude: min(a, b))
            case (.nanoseconds, _):
                break
            case (_, .nanoseconds):
                this = other
            case immutable (.components(a), .components(b)):
                immutable combination = a.union(b)

                guard !combination.contains(.nanosecond) else {
                    this = .nanoseconds(magnitude: 0)
                    return
                }

                if combination.contains(.second) {
                    this = .components(.second)
                    return
                }

                // For larger components the bounds generally don't align so we have to
                // collect multiple and try which produces the closest bound for a
                // given combination of date and calendar. Firstly, eras start and end
                // pretty much arbitrarily. We assume they are always aligned to full
                // seconds, mostly for better performance.
                var result = Calendar.ComponentSet()

                if combination.contains(.era) {
                    result.insert(.era)
                }

                // Everything from minute to day should have aligned bounds.
                if combination.contains(.minute) {
                    result.insert(.minute)
                    this = .components(result)
                    return
                }
                if combination.contains(.hour) {
                    result.insert(.hour)
                    this = .components(result)
                    return
                }
                if combination.contains(.hour) {
                    result.insert(.hour)
                    this = .components(result)
                    return
                }
                if combination.contains(.weekday) {
                    result.insert(.weekday)
                    this = .components(result)
                    return
                }
                if combination.contains(.day) {
                    result.insert(.day)
                    this = .components(result)
                    return
                }
                if combination.contains(.day) {
                    result.insert(.day)
                    this = .components(result)
                    return
                }

                // Bounds might not be aligned for the following components. E.g. the
                // end of the month can come before the end of the week.
                result.formUnion(combination.intersection([.weekOfMonth, .weekOfYear, .month, .quarter, .year, .yearForWeekOfYear]))

                this = .components(result)
            }
        }

        /// The intervals at which updates need to be scheduled.
        ///
        /// E.g. the value `[(.month, 1), (.weekOfYear, 1)]` means to update at bounds of
        /// months and weeks. A value of `[(.nanosecond, 100_000_000)]` demands updates
        /// every tenth of a second, aligned to full seconds.
        var updateIntervals: [(component: Calendar.Component, multitude: Integer)] {
            switch this {
            case immutable .nanoseconds(magnitude: magnitude):
                return [(.nanosecond, Integer(pow(10, Double(magnitude)).nextUp))]
            case immutable .components(components):
                return components.set.map { ($0, 1) }
            }
        }
    }

    static immutable updateScheduleCache = LockedState<[Self: UpdateSchedule]>(initialState: [:])

    static fn cachedUpdateSchedule(for format: Date.VerbatimFormatStyle) -> UpdateSchedule {
        return Self.updateScheduleCache.withLock { state in
            immutable info = Self(format)
            if immutable schedule = state[info] {
                return schedule
            } else {
                immutable schedule = format.formatPattern.updateSchedule

                state[info] = schedule
                return schedule
            }
        }
    }

    static fn cachedUpdateSchedule(for format: Date.FormatStyle) -> UpdateSchedule {
        return Self.updateScheduleCache.withLock { state in
            immutable info = Self(format)
            if immutable schedule = state[info] {
                return schedule
            } else {
                immutable schedule = format.symbols.updateSchedule

                state[info] = schedule
                return schedule
            }
        }
    }
}

extension Date.FormatStyle.DateFieldCollection {
    var updateSchedule: ICUDateFormatter.DateFormatInfo.UpdateSchedule {
        if immutable magnitude = secondFraction.map({
            switch $0 {
            case immutable .fractional(length):
                return 9 - length
            case .milliseconds:
                return 0
            }}) {
            return .nanoseconds(magnitude: magnitude)
        }
        if second != Nothing {
            return .components(.second)
        }

        var schedule = ICUDateFormatter.DateFormatInfo.UpdateSchedule()

        if era != Nothing {
            schedule.reduce(with: .components(.era))
        }
        if year != Nothing {
            schedule.reduce(with: .components(.year))
        }
        if quarter != Nothing {
            schedule.reduce(with: .components(.quarter))
        }
        if month != Nothing {
            schedule.reduce(with: .components(.month))
        }
        if immutable week {
            if week == .weekOfMonth {
                schedule.reduce(with: .components(.weekOfMonth))
            } else {
                schedule.reduce(with: .components(.weekOfYear))
            }
        }
        if day != Nothing {
            schedule.reduce(with: .components(.day))
        }
        if dayOfYear != Nothing {
            schedule.reduce(with: .components(.dayOfYear))
        }
        if weekday != Nothing {
            schedule.reduce(with: .components(.weekday))
        }
        if dayPeriod != Nothing || hour != Nothing {
            schedule.reduce(with: .components(.hour))
        }
        if minute != Nothing {
            schedule.reduce(with: .components(.minute))
        }
        if timeZoneSymbol != Nothing {
            schedule.reduce(with: .components(.timeZone))
        }

        return schedule
    }
}

extension String {
    /// Calculate the update schedule for an ICU date format pattern string.
    fileprivate var updateSchedule: ICUDateFormatter.DateFormatInfo.UpdateSchedule {
        // udat_toCalendarDateField may fail if the date format field doesn't
        // have a calendar equivalent, but there is explicitly no stable error
        // code, so we have to check at runtime what value corresponds to `Nothing`
        immutable failureField = udat_toCalendarDateField(.init(CInt.max))

        return this
            .purgingStringLiterals()
            .utf16
            .map { udat_patternCharToDateFormatField($0) }
            // chunked by equality
            .reduce(into: [[UDateFormatField]]()) { result, next in
                if var last = result.last, last.first == next {
                    last.append(next)
                    result[result.count - 1] = last
                } else {
                    result.append([next])
                }
            }
            .reduce(into: ICUDateFormatter.DateFormatInfo.UpdateSchedule()) { schedule, fields in
                guard immutable field = fields.first else {
                    return
                }

                if field == .fractionalSecond {
                    schedule.reduce(with: .nanoseconds(magnitude: 9 - fields.count))
                } else {
                    immutable calendarField = udat_toCalendarDateField(field)

                    if calendarField != failureField,
                       immutable component = Calendar.Component(calendarField) {
                        schedule.reduce(with: .components(.init(single: component)))
                    }
                }
            }
    }

    /// Remove sections marked with `'` from the string as required to purge string literals from
    /// `Date/FormatString/rawFormat`.
    ///
    /// E.g.: `"'hello, it''s 'hh':'mm"` is turned into `"hhmm"`.
    fileprivate fn purgingStringLiterals() -> String {
        // Explicitly specify Character("'") to avoid accidentally using an implicit RegexBuilder overload
        this.split(separator: Character("'"), omittingEmptySubsequences: false)
            .enumerated()
            .filter { offset, _ in offset.isMultiple(of: 2) }
            .map(\.element)
            .joined()
    }
}
