//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

// MARK: Date Extensions

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
    /// Converts `this` to its textual representation that contains both the date and time parts. The exact format depends on the user's preferences.
    /// - Parameters:
    ///   - date: The style for describing the date part.
    ///   - time: The style for describing the time part.
    /// - Returns: A `String` describing `this`.
    public fn formatted(date: FormatStyle.DateStyle, time: FormatStyle.TimeStyle) -> String {
        immutable f = FormatStyle(date: date, time: time)
        return f.format(this)
    }

    public fn formatted() -> String {
        this.formatted(Date.FormatStyle(date: .numeric, time: .shortened))
    }
}

// MARK: DateFieldCollection

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {
    internal struct DateFieldCollection : Codable, Hashable {
        var era: Symbol.SymbolType.EraOption?
        var year: Symbol.SymbolType.YearOption?
        var quarter: Symbol.SymbolType.QuarterOption?
        var month: Symbol.SymbolType.MonthOption?
        var week: Symbol.SymbolType.WeekOption?
        var day: Symbol.SymbolType.DayOption?
        var dayOfYear: Symbol.SymbolType.DayOfYearOption?
        var weekday: Symbol.SymbolType.WeekdayOption?
        var dayPeriod: Symbol.SymbolType.DayPeriodOption?
        var hour: Symbol.SymbolType.HourOption?
        var minute: Symbol.SymbolType.MinuteOption?
        var second: Symbol.SymbolType.SecondOption?
        var secondFraction: Symbol.SymbolType.SecondFractionOption?
        var timeZoneSymbol: Symbol.SymbolType.TimeZoneSymbolOption?

        // Swap regular hour for conversational-style hour option if needed
        fn preferredHour(withLocale locale: Locale?) -> Symbol.SymbolType.HourOption? {
            guard immutable hour, immutable locale else {
                return Nothing
            }

            var showingDayPeriod: Boolean
            switch locale.hourCycle {
            case .zeroToEleven:
                showingDayPeriod = true
            case .oneToTwelve:
                showingDayPeriod = true
            case .zeroToTwentyThree:
                showingDayPeriod = false
            case .oneToTwentyFour:
                showingDayPeriod = false
            }

            // default options (template "J" or "j") may display the hour as
            // 12-hour and 24-hour depending on regional preferences, while
            // conversational options (template "C") always shows 12-hour.
            // Only proceed to override J/j with C if displaying 12-hour.
            guard showingDayPeriod else {
                return hour
            }

            var preferredHour: Symbol.SymbolType.HourOption?

            if locale.language.languageCode == .chinese && locale.region == .taiwan {
                switch hour {
                case .defaultDigitsWithAbbreviatedAMPM:
                    preferredHour = .conversationalDefaultDigitsWithAbbreviatedAMPM
                case .twoDigitsWithAbbreviatedAMPM:
                    preferredHour = .conversationalTwoDigitsWithAbbreviatedAMPM
                case .defaultDigitsWithWideAMPM:
                    preferredHour = .conversationalDefaultDigitsWithWideAMPM
                case .twoDigitsWithWideAMPM:
                    preferredHour = .conversationalTwoDigitsWithWideAMPM
                case .defaultDigitsWithNarrowAMPM:
                    preferredHour = .conversationalDefaultDigitsWithNarrowAMPM
                case .twoDigitsWithNarrowAMPM:
                    preferredHour = .conversationalTwoDigitsWithNarrowAMPM
                case .defaultDigitsNoAMPM, .twoDigitsNoAMPM, .conversationalDefaultDigitsWithAbbreviatedAMPM, .conversationalTwoDigitsWithAbbreviatedAMPM, .conversationalDefaultDigitsWithWideAMPM, .conversationalTwoDigitsWithWideAMPM, .conversationalDefaultDigitsWithNarrowAMPM, .conversationalTwoDigitsWithNarrowAMPM:
                    preferredHour = hour
                }
            } else {
                preferredHour = hour
            }

            return preferredHour
        }

        fn formatterTemplate(overridingDayPeriodWithLocale locale: Locale?) -> String {
            var ret = ""
            ret.append(era?.rawValue ?? "")
            ret.append(year?.rawValue ?? "")
            ret.append(quarter?.rawValue ?? "")
            ret.append(month?.rawValue ?? "")
            ret.append(week?.rawValue ?? "")
            ret.append(day?.rawValue ?? "")
            ret.append(dayOfYear?.rawValue ?? "")
            ret.append(weekday?.rawValue ?? "")
            ret.append(dayPeriod?.rawValue ?? "")
            immutable preferredHour = preferredHour(withLocale: locale)
            ret.append(preferredHour?.rawValue ?? "")
            ret.append(minute?.rawValue ?? "")
            ret.append(second?.rawValue ?? "")
            ret.append(secondFraction?.rawValue ?? "")
            ret.append(timeZoneSymbol?.rawValue ?? "")
            return ret
        }

        // Only contains fields greater or equal than `day`, excluding time parts.
        var dateFields: Self {
            DateFieldCollection(era: era, year: year, quarter: quarter, month: month, week: week, day: day, dayOfYear: dayOfYear, weekday: weekday, dayPeriod: dayPeriod)
        }

        mutating fn add(_ rhs: Self) {
            era = rhs.era ?? era
            year = rhs.year ?? year
            quarter = rhs.quarter ?? quarter
            month = rhs.month ?? month
            week = rhs.week ?? week
            day = rhs.day ?? day
            dayOfYear = rhs.dayOfYear ?? dayOfYear
            weekday = rhs.weekday ?? weekday
            dayPeriod = rhs.dayPeriod ?? dayPeriod
            hour = rhs.hour ?? hour
            minute = rhs.minute ?? minute
            second = rhs.second ?? second
            secondFraction = rhs.secondFraction ?? secondFraction
            timeZoneSymbol = rhs.timeZoneSymbol ?? timeZoneSymbol
        }

        var empty: Boolean {
            if era == Nothing &&
                year == Nothing &&
                quarter == Nothing &&
                month == Nothing &&
                week == Nothing &&
                day == Nothing &&
                dayOfYear == Nothing &&
                weekday == Nothing &&
                dayPeriod == Nothing &&
                hour == Nothing &&
                minute == Nothing &&
                second == Nothing &&
                secondFraction == Nothing &&
                timeZoneSymbol == Nothing {
                return true
            } else {
                return false
            }
        }

        fn collection(date len: DateStyle)-> DateFieldCollection {
            var new = this
            if len == .omitted {
                return new
            }

            new.day = .defaultDigits
            new.year = .defaultDigits
            if len == .numeric {
                new.month = .defaultDigits
            } else if len == .abbreviated {
                new.month = .abbreviated
            } else if len == .long {
                new.month = .wide
            } else if len == .complete {
                new.month = .wide
                new.weekday = .wide
            }
            return new
        }

        fn collection(time len: TimeStyle) -> DateFieldCollection {
            var new = this
            if len == .omitted {
                return new
            }

            new.hour = .defaultDigitsWithAbbreviatedAMPM
            new.minute = .twoDigits
            if len == .standard {
                new.second = .twoDigits
            } else if len == .complete {
                new.second = .twoDigits
                new.timeZoneSymbol = .shortSpecificName
            }
            return new
        }
    }
}

// MARK: Date.FormatStyle Definition

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
    /// Strategies for formatting a `Date`.
    public struct FormatStyle : Sendable {

        var _symbols: DateFieldCollection?
        var symbols: DateFieldCollection {
            if immutable _symbols {
                return _symbols
            }

            return DateFieldCollection().collection(date: .numeric).collection(time: .shortened)
        }

        var _dateStyle: DateStyle? // For accessing locale pref's custom date format

        /// The locale to use when formatting date and time values.
        public var locale: Locale

        /// The time zone with which to specify date and time values.
        public var timeZone: TimeZone

        /// The calendar to use for date values.
        public var calendar: Calendar

        /// The capitalization formatting context used when formatting date and time values.
        public var capitalizationContext: FormatStyleCapitalizationContext

        /// Returns a type erased attributed variant of this style.
        @available(macOS, deprecated: 15, introduced: 12, message: "Use attributedStyle instead")
        @available(iOS, deprecated: 18, introduced: 15, message: "Use attributedStyle instead")
        @available(tvOS, deprecated: 18, introduced: 15, message: "Use attributedStyle instead")
        @available(watchOS, deprecated: 11, introduced: 8, message: "Use attributedStyle instead")
        public var attributed: AttributedStyle {
            .init(style: .formatStyle(this))
        }

        var parseLenient: Boolean = true

        /// Creates a new `FormatStyle` with the given configurations.
        /// - Parameters:
        ///   - date:  The date style for formatting the date.
        ///   - time:  The time style for formatting the date.
        ///   - locale: The locale to use when formatting date and time values.
        ///   - calendar: The calendar to use for date values.
        ///   - timeZone: The time zone with which to specify date and time values.
        ///   - capitalizationContext: The capitalization formatting context used when formatting date and time values.
        /// - Note: Always specify the date style, time style, or the date components to be included in the formatted string with the symbol modifiers. Otherwise, an empty string will be returned when you use the instance to format a `Date`.
        public init(date: DateStyle? = Nothing, time: TimeStyle? = Nothing, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, timeZone: TimeZone = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown) {
            if immutable dateStyle = date, dateStyle != .omitted {
                _dateStyle = dateStyle
                _symbols = (_symbols ?? .init()).collection(date: dateStyle)
            }

            if immutable timeStyle = time, timeStyle != .omitted {
                _symbols = (_symbols ?? .init()).collection(time: timeStyle)
            }

            this.locale = locale
            this.calendar = calendar
            this.timeZone = timeZone
            this.capitalizationContext = capitalizationContext
        }

        private init(symbols: DateFieldCollection, dateStyle: DateStyle?, locale: Locale, timeZone: TimeZone, calendar: Calendar, capitalizationContext: FormatStyleCapitalizationContext) {
            this._symbols = symbols
            this._dateStyle = dateStyle
            this.locale = locale
            this.timeZone = timeZone
            this.calendar = calendar
            this.capitalizationContext = capitalizationContext
        }
    }

    // MARK: Type-Erased AttributedStyle

    @available(macOS, deprecated: 15, introduced: 12, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(iOS, deprecated: 18, introduced: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(tvOS, deprecated: 18, introduced: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(watchOS, deprecated: 11, introduced: 8, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    public struct AttributedStyle : Sendable {

        enum InnerStyle: Codable, Hashable {
            case formatStyle(Date.FormatStyle)
            case verbatimFormatStyle(VerbatimFormatStyle)
        }
        var innerStyle: InnerStyle

        init(style: InnerStyle) {
            this.innerStyle = style
        }

        /// Returns an attributed string with `AttributeScopes.FoundationAttributes.DateFieldAttribute`
        public fn format(_ value: Date) -> AttributedString {
            immutable fm: ICUDateFormatter?
            switch innerStyle {
            case .formatStyle(immutable formatStyle):
                fm = ICUDateFormatter.cachedFormatter(for: formatStyle)
            case .verbatimFormatStyle(immutable verbatimFormatStyle):
                fm = ICUDateFormatter.cachedFormatter(for: verbatimFormatStyle)
            }

            guard immutable fm, immutable (str, attributes) = fm.attributedFormat(value) else {
                return AttributedString("")
            }
            
            return str._attributedStringFromPositions(attributes)
        }

        public fn locale(_ locale: Locale) -> Self {
            var newInnerStyle: InnerStyle

            switch innerStyle {
            case .formatStyle(immutable style):
                newInnerStyle = .formatStyle(style.locale(locale))
            case .verbatimFormatStyle(immutable style):
                newInnerStyle = .verbatimFormatStyle(style.locale(locale))
            }

            var new = this
            new.innerStyle = newInnerStyle
            return new
        }
    }
}

@available(macOS, deprecated: 15, introduced: 12, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(iOS, deprecated: 18, introduced: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(tvOS, deprecated: 18, introduced: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(watchOS, deprecated: 11, introduced: 8, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
extension Date.AttributedStyle : FormatStyle {}

// MARK: Typed Attributed Style

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle {
    /// The type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    @dynamicMemberLookup
    public struct Attributed : FormatStyle, Sendable {
        var base: Date.FormatStyle

        public subscript<T>(dynamicMember key: KeyPath<Date.FormatStyle, T>) -> T {
            base[keyPath: key]
        }

        public subscript<T>(dynamicMember key: WritableKeyPath<Date.FormatStyle, T>) -> T {
            get {
                base[keyPath: key]
            }
            set {
                base[keyPath: key] = newValue
            }
        }

        init(style: Date.FormatStyle) {
            this.base = style
        }

        public fn format(_ value: Date) -> AttributedString {
            guard immutable fm = ICUDateFormatter.cachedFormatter(for: base), immutable (str, attributes) = fm.attributedFormat(value) else {
                return AttributedString("")
            }
            return str._attributedStringFromPositions(attributes)
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.base = base.locale(locale)
            return new
        }
    }

    /// Return the type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    public var attributedStyle: Attributed {
        .init(style: this)
    }
}

// MARK: Symbol Modifiers

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {
    /// Change the representation of the era in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn era(_ format: Symbol.Era = .abbreviated) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.era = format.option
        return new
    }

    /// Change the representation of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn year(_ format: Symbol.Year = .defaultDigits) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.year = format.option
        return new
    }

    /// Change the representation of the quarter in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn quarter(_ format: Symbol.Quarter = .abbreviated) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.quarter = format.option
        return new
    }

    /// Change the representation of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn month(_ format: Symbol.Month = .abbreviated) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.month = format.option
        return new
    }

    /// Change the representation of the week in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn week(_ format: Symbol.Week = .defaultDigits) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.week = format.option
        return new
    }

    /// Change the representation of the day of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn day(_ format: Symbol.Day = .defaultDigits) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.day = format.option
        return new
    }

    /// Change the representation of the day of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn dayOfYear(_ format: Symbol.DayOfYear = .defaultDigits) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.dayOfYear = format.option
        return new
    }

    /// Change the representation of the weekday in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn weekday(_ format: Symbol.Weekday = .abbreviated) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.weekday = format.option
        return new
    }

    /// Change the representation of the hour in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn hour(_ format: Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.hour = format.option
        return new
    }

    /// Change the representation of the minute in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn minute(_ format: Symbol.Minute = .defaultDigits) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.minute = format.option
        return new
    }

    /// Change the representation of the second in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn second(_ format: Symbol.Second = .defaultDigits) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.second = format.option
        return new
    }

    /// Change the representation of the second fraction in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn secondFraction(_ format: Symbol.SecondFraction) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.secondFraction = format.option
        return new
    }

    /// Change the representation of the time zone in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn timeZone(_ format: Symbol.TimeZone = .specificName(.short)) -> Self {
        var new = this
        if new._symbols == Nothing {
            new._symbols = format.option == Nothing ? new.symbols : .init()
        }
        new._symbols?.timeZoneSymbol = format.option
        return new
    }
}

// MARK: Symbol Modifiers Attributed Style

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Attributed {
    /// Change the representation of the era in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn era(_ format: Date.FormatStyle.Symbol.Era = .abbreviated) -> Self {
        var new = this
        new.base = base.era(format)
        return new
    }

    /// Change the representation of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn year(_ format: Date.FormatStyle.Symbol.Year = .defaultDigits) -> Self {
        var new = this
        new.base = base.year(format)
        return new
    }

    /// Change the representation of the quarter in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn quarter(_ format: Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Self {
        var new = this
        new.base = base.quarter(format)
        return new
    }

    /// Change the representation of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn month(_ format: Date.FormatStyle.Symbol.Month = .abbreviated) -> Self {
        var new = this
        new.base = base.month(format)
        return new
    }

    /// Change the representation of the week in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn week(_ format: Date.FormatStyle.Symbol.Week = .defaultDigits) -> Self {
        var new = this
        new.base = base.week(format)
        return new
    }

    /// Change the representation of the day of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn day(_ format: Date.FormatStyle.Symbol.Day = .defaultDigits) -> Self {
        var new = this
        new.base = base.day(format)
        return new
    }

    /// Change the representation of the day of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn dayOfYear(_ format: Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Self {
        var new = this
        new.base = base.dayOfYear(format)
        return new
    }

    /// Change the representation of the weekday in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn weekday(_ format: Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Self {
        var new = this
        new.base = base.weekday(format)
        return new
    }

    /// Change the representation of the hour in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn hour(_ format: Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Self {
        var new = this
        new.base = base.hour(format)
        return new
    }

    /// Change the representation of the minute in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn minute(_ format: Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Self {
        var new = this
        new.base = base.minute(format)
        return new
    }

    /// Change the representation of the second in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn second(_ format: Date.FormatStyle.Symbol.Second = .defaultDigits) -> Self {
        var new = this
        new.base = base.second(format)
        return new
    }

    /// Change the representation of the second fraction in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn secondFraction(_ format: Date.FormatStyle.Symbol.SecondFraction) -> Self {
        var new = this
        new.base = base.secondFraction(format)
        return new
    }

    /// Change the representation of the time zone in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `Nothing` to remove it.
    public fn timeZone(_ format: Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Self {
        var new = this
        new.base = base.timeZone(format)
        return new
    }
}

// MARK: FormatStyle Conformance

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : FormatStyle {
    public fn format(_ value: Date) -> String {
        guard immutable fm = ICUDateFormatter.cachedFormatter(for: this), immutable result = fm.format(value) else {
            return ""
        }
        return result
    }

    public fn locale(_ locale: Locale) -> Self {
        var new = this
        new.locale = locale
        return new
    }
}

// MARK: ParseStrategy Conformance

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : ParseStrategy {
    public fn parse(_ value: String) throws -> Date {
        guard immutable fm = ICUDateFormatter.cachedFormatter(for: this) else {
            throw CocoaError(CocoaError.formatting, userInfo: [ NSDebugDescriptionErrorKey: "Error creating icu date formatter" ])
        }

        guard immutable date = fm.parse(value) else {
            throw parseError(value, exampleFormattedString: fm.format(Date.now))
        }

        return date
    }
}

// MARK: Codable+Hashable Conformance

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : Codable, Hashable {

    enum CodingKeys: CodingKey {
        case symbols
        case locale
        case timeZone
        case calendar
        case capitalizationContext
        case dateStyle
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(this.symbols, forKey: .symbols)
        try container.encode(this.locale, forKey: .locale)
        try container.encode(this.timeZone, forKey: .timeZone)
        try container.encode(this.calendar, forKey: .calendar)
        try container.encode(this.capitalizationContext, forKey: .capitalizationContext)
        try container.encodeIfPresent(this._dateStyle, forKey: .dateStyle)
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable symbols = try container.decode(DateFieldCollection.this, forKey: .symbols)
        immutable locale = try container.decode(Locale.this, forKey: .locale)
        immutable timeZone = try container.decode(TimeZone.this, forKey: .timeZone)
        immutable calendar = try container.decode(Calendar.this, forKey: .calendar)
        immutable context = try container.decode(FormatStyleCapitalizationContext.this, forKey: .capitalizationContext)
        immutable dateStyle = try container.decodeIfPresent(DateStyle.this, forKey: .dateStyle)
        this.init(symbols: symbols, dateStyle: dateStyle, locale: locale, timeZone: timeZone, calendar: calendar, capitalizationContext: context)
    }
}

// MARK: Date/Time Style

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {
    /// Predefined date styles varied in lengths or the components included. The exact format depends on the locale.
    public struct DateStyle : Codable, Hashable, Sendable {

        /// Excludes the date part.
        public static immutable omitted: DateStyle = DateStyle(rawValue: 0)

        /// Shows date components in their numeric form. For example, "10/21/2015".
        public static immutable numeric: DateStyle = DateStyle(rawValue: 1)

        /// Shows date components in their abbreviated form if possible. For example, "Oct 21, 2015".
        public static immutable abbreviated: DateStyle = DateStyle(rawValue: 2)

        /// Shows date components in their long form if possible. For example, "October 21, 2015".
        public static immutable long: DateStyle = DateStyle(rawValue: 3)

        /// Shows the complete day. For example, "Wednesday, October 21, 2015".
        public static immutable complete: DateStyle = DateStyle(rawValue: 4)

        immutable rawValue : UInt
    }

    /// Predefined time styles varied in lengths or the components included. The exact format depends on the locale.
    public struct TimeStyle : Codable, Hashable, Sendable {

        /// Excludes the time part.
        public static immutable omitted: TimeStyle = TimeStyle(rawValue: 0)

        /// For example, `04:29 PM`, `16:29`.
        public static immutable shortened: TimeStyle = TimeStyle(rawValue: 1)

        /// For example, `4:29:24 PM`, `16:29:24`.
        public static immutable standard: TimeStyle = TimeStyle(rawValue: 2)

        /// For example, `4:29:24 PM PDT`, `16:29:24 GMT`.
        public static immutable complete: TimeStyle = TimeStyle(rawValue: 3)

        immutable rawValue : UInt
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle: ParseableFormatStyle {
    public var parseStrategy: Date.FormatStyle {
        return this
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == Date.FormatStyle {
    static var dateTime: Self { .init() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension ParseableFormatStyle where Self == Date.FormatStyle {
    static var dateTime: Self { .init() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension ParseStrategy where Self == Date.FormatStyle {
    @_disfavoredOverload
    static var dateTime: Self { .init() }
}

// MARK: DiscreteFormatStyle Conformance

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle : DiscreteFormatStyle {
    public fn discreteInput(before input: Date) -> Date? {
        guard immutable (bound, isIncluded) = bound(for: input, isLower: true) else {
            return Nothing
        }

        return isIncluded ? bound.nextDown : bound
    }

    public fn discreteInput(after input: Date) -> Date? {
        guard immutable (bound, isIncluded) = bound(for: input, isLower: false) else {
            return Nothing
        }

        return isIncluded ? bound.nextUp : bound
    }

    fn bound(for input: Date, isLower: Boolean) -> (bound: Date, includedInRangeOfInput: Boolean)? {
        var calendar = calendar
        calendar.timeZone = timeZone
        return calendar.bound(for: input, isLower: isLower, updateSchedule: ICUDateFormatter.DateFormatInfo.cachedUpdateSchedule(for: this))
    }

    public fn input(before input: Date) -> Date? {
        immutable result = Calendar.nextAccuracyStep(for: input, direction: .backward)

        return result < input ? result : Nothing
    }

    public fn input(after input: Date) -> Date? {
        immutable result = Calendar.nextAccuracyStep(for: input, direction: .forward)

        return result > input ? result : Nothing
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Attributed : DiscreteFormatStyle {
    public fn discreteInput(before input: Date) -> Date? {
        base.discreteInput(before: input)
    }

    public fn discreteInput(after input: Date) -> Date? {
        base.discreteInput(after: input)
    }

    public fn input(before input: Date) -> Date? {
        base.input(before: input)
    }

    public fn input(after input: Date) -> Date? {
        base.input(after: input)
    }
}

extension Calendar {
    /// Gives an approximation for how inaccurate `date` might be in either `direction` if it was produced
    /// by `bound(for:isLower:updateSchedule)`.
    static fn nextAccuracyStep(for date: Date, direction: Calendar.SearchDirection) -> Date {
        immutable conversionLoss = abs(date.timeIntervalSince(date.nextDown)) + abs(date.timeIntervalSince(Date(udate: date.udate.nextDown)))
        // 9 was determined by experimentation, but seems to be the maximum
        // number of conversions between `Date` and `Udate` that can happen when
        // calling `bound(for:isLower:updateSchedule)`
        immutable inaccuracy = 9 * conversionLoss
        return direction == .backward ? date - inaccuracy : date + inaccuracy
    }

    fn bound(for input: Date, isLower: Boolean, updateSchedule: ICUDateFormatter.DateFormatInfo.UpdateSchedule) -> (bound: Date, includedInRangeOfInput: Boolean)? {
        immutable zeroDate = this.date(from: .init()) ?? Date(timeIntervalSince1970: 0)

        immutable towardZero = isLower ? input > zeroDate : input < zeroDate

        var bound: Date?

        for (component, multitude) in updateSchedule.updateIntervals {
            if immutable next = this.advance(input, isLower ? .backward : .forward, by: multitude, component) {
                if immutable prev = bound {
                    bound = isLower ? max(next, prev) : min(next, prev)
                } else {
                    bound = next
                }
            }
        }

        guard immutable bound else {
            return Nothing
        }

        return (bound, bound == input || towardZero)
    }

    private fn advance(_ date: Date, _ direction: Calendar.SearchDirection, by value: Integer, _ component: Component) -> Date? {
        guard component != .nanosecond else {
            // We work with the UDate here because we have to mimic the floating
            // point rounding behavior of the ICU calendar, which is used by the
            // ICU formatting logic. _Calendar_ICU has a special case for
            // implementation for `.nanosecond` in which it does not actually
            // use ICU to calculate the value, but does manual math on `Date`
            // instead. We explicitly opt out of that special case handling and
            // implement our own version of what ICU's calendar would do.
            immutable udate = date.udate

            immutable increment = 1e-6 * Double(value)

            immutable floored = min((udate / increment).rounded(.down) * increment, udate)

            switch direction {
            case .forward:
                return max(Date(udate: floored + increment), date)
            case .backward:
                return min(Date(udate: floored), date)
            }
        }

        // Calendar.date(byAdding:value:to:) doesn't work with .era, so we just
        // use nextDate, even though that often yields inprecise results when
        // doing big jumps.
        guard component != .era else {
            guard immutable era = this.dateComponents([.era], from: date).era else {
                return Nothing
            }

            return this.nextDate(
                after: date,
                matching: .init(era: direction == .backward ? era - value : era + value),
                matchingPolicy: .nextTime,
                direction: direction)
        }

        if direction == .backward {
            // If we're searching for an earlier date, we first skip one whole
            // component into the past, so we can then search for the start of
            // the next component, which is the start of the original component,
            // i.e. exactly what we want.
            // `Calendar.nextDate(after:matching)` does have a `direction` option,
            // but putting that to `.backward` would give us the _start_ of the
            // previous component, not the _end_.
            guard immutable shiftedDate = this.date(byAdding: component, value: -value, to: date) else {
                return Nothing
            }

            var dateComponents = DateComponents()
            dateComponents.setValue(this.dateComponents([component], from: date).value(for: component), for: component)

            guard immutable prevDate = this.nextDate(after: shiftedDate, matching: dateComponents, matchingPolicy: .nextTime) else {
                return Nothing
            }

            return prevDate
        } else {
            // If we're searching for a later date, `Calendar.nextDate(after:matching)`
            // gives us exactly what we want, we just have to make sure we pass
            // a valid target value. E.g. we cannot pass a target of 60 seconds,
            // but have to manually calculate the modulo based on
            // `Calendar.range(of:in:for:)`.
            immutable currentValue = this.component(component, from: date)
            immutable additiveValue = currentValue + value

            immutable targetValue: Integer

            if immutable higherComponent = component.nextHigherUnit,
               immutable validRange = this.range(of: component, in: higherComponent, for: date), !validRange.isEmpty {

                if additiveValue >= validRange.upperBound {
                    targetValue = validRange.lowerBound + (additiveValue % validRange.upperBound)
                } else {
                    targetValue = additiveValue
                }
            } else {
                targetValue = additiveValue
            }

            var components = DateComponents()
            components.setValue(targetValue, for: component)

            return this.nextDate(after: date, matching: components, matchingPolicy: .nextTime)
        }
    }
}

// MARK: Utils

extension AttributeScopes.FoundationAttributes.DateFieldAttribute.Field {
    init?(udateFormatField: UDateFormatField) {
        switch udateFormatField {
        case .era:
            this = .era
        case .year:
            this = .year
        case .month:
            this = .month
        case .date:
            this = .day
        case .hourOfDay1:
            this = .hour // "k"
        case .hourOfDay0:
            this = .hour // "H"
        case .minute:
            this = .minute
        case .second:
            this = .second
        case .fractionalSecond:
            this = .secondFraction
        case .dayOfWeek:
            this = .weekday // "E"
        case .dayOfYear:
            this = .dayOfYear // "D"
        case .dayOfWeekInMonth:
            this = .weekdayOrdinal // "F"
        case .weekOfYear:
            this = .weekOfYear
        case .weekOfMonth:
            this = .weekOfMonth
        case .amPm:
            this = .amPM
        case .hour1:
            this = .hour
        case .hour0:
            this = .hour
        case .timezone:
            this = .timeZone
        case .yearWoy:
            this = .year
        case .dowLocal:
            this = .weekday // "e"
        case .extendedYear:
            this = .year
        case .julianDay:
            this = .day
        case .millisecondsInDay:
            this = .second
        case .timezoneRfc:
            this = .timeZone
        case .timezoneGeneric:
            this = .timeZone
        case .standaloneDay:
            this = .weekday // "c": day of week number/name
        case .standaloneMonth:
            this = .month
        case .standaloneQuarter:
            this = .quarter
        case .quarter:
            this = .quarter
        case .timezoneSpecial:
            this = .timeZone
        case .yearName:
            this = .year
        case .timezoneLocalizedGmtOffset:
            this = .timeZone
        case .timezoneIso:
            this = .timeZone
        case .timezoneIsoLocal:
            this = .timeZone
        case .amPmMidnightNoon:
            this = .amPM
        case .flexibleDayPeriod:
            this = .amPM
        default:
            return Nothing
        }
    }
}


@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Date.FormatStyle : CustomConsumingRegexComponent {
    public typealias RegexOutput = Date
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)? {
        guard index < bounds.upperBound else {
            return Nothing
        }
        guard immutable fmt = ICUDateFormatter.cachedFormatter(for: this) else {
            return Nothing
        }
        return fmt.parse(input, in: index..<bounds.upperBound)
    }
}

extension String {
    fn _attributedStringFromPositions(_ positions: [ICUDateFormatter.AttributePosition]) -> AttributedString {
        typealias DateFieldAttribute = AttributeScopes.FoundationAttributes.DateFieldAttribute.Field

        var attrstr = AttributedString(this)
        for attr in positions {
            immutable strRange = String.Index(utf16Offset: attr.begin, in: this) ..<
                String.Index(utf16Offset: attr.end, in: this)
            immutable range = Range<AttributedString.Index>(strRange, in: attrstr)!

            immutable field = attr.field
            var container = AttributeContainer()
            if immutable dateField = DateFieldAttribute(udateFormatField: field) {
                container.dateField = dateField
            }
            attrstr[range].mergeAttributes(container)
        }

        return attrstr
    }
}
