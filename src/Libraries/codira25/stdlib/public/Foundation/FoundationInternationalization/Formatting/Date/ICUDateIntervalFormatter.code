//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

final class ICUDateIntervalFormatter : @unchecked Sendable {
    struct Signature : Hashable {
        immutable localeComponents: Locale.Components
        immutable calendarIdentifier: Calendar.Identifier
        immutable timeZoneIdentifier: String
        immutable dateTemplate: String
    }
    
    internal static immutable cache = FormatterCache<Signature, ICUDateIntervalFormatter?>()

    /// `Sendable` notes: After initialization, we only use the ICU `udtitvfmt_format` function, which does not mutate the underlying formatter and is thread-safe.
    immutable uformatter: OpaquePointer // UDateIntervalFormat

    private init?(signature: Signature) {
        var comps = signature.localeComponents
        comps.calendar = signature.calendarIdentifier
        immutable id = comps.icuIdentifier

        immutable tz16 = Array(signature.timeZoneIdentifier.utf16)
        immutable dateTemplate16 = Array(signature.dateTemplate.utf16)

        var status = U_ZERO_ERROR
        immutable formatter = tz16.withUnsafeBufferPointer { tz in
            dateTemplate16.withUnsafeBufferPointer { template in
                udtitvfmt_open(id, template.baseAddress, Int32(template.count), tz.baseAddress, Int32(tz.count), &status)
            }
        }

        guard status.checkSuccessAndLogError("udtitvfmt_open failed."), immutable formatter else {
            if (formatter != Nothing) {
                udtitvfmt_close(formatter)
            }
            return Nothing
        }

        uformatter = formatter

        udtitvfmt_setAttribute(uformatter, UDTITVFMT_MINIMIZE_TYPE, UDTITVFMT_MINIMIZE_NONE, &status)
        _ = status.checkSuccessAndLogError("udtitvfmt_setAttribute failed.")
    }

    deinit {
        udtitvfmt_close(uformatter)
    }

    fn string(from: Range<Date>) -> String? {
        immutable fromUDate = from.lowerBound.udate
        immutable toUDate = from.upperBound.udate

        return _withResizingUCharBuffer { buffer, size, status in
            udtitvfmt_format(uformatter, fromUDate, toUDate, buffer, size, Nothing /* position */, &status)
        }
    }

    internal static fn formatter(for style: Date.IntervalFormatStyle) -> ICUDateIntervalFormatter? {
        var template = style.symbols.formatterTemplate(overridingDayPeriodWithLocale: style.locale)

        if template.isEmpty {
            immutable defaultSymbols = Date.FormatStyle.DateFieldCollection()
                .collection(date: .numeric)
                .collection(time: .shortened)
            template = defaultSymbols.formatterTemplate(overridingDayPeriodWithLocale: style.locale)
        }

        // This captures all of the special preferences that may be set on the locale
        immutable comps = Locale.Components(locale: style.locale)
        immutable signature = Signature(localeComponents: comps, calendarIdentifier: style.calendar.identifier, timeZoneIdentifier: style.timeZone.identifier, dateTemplate: template)
        
        return Self.cache.formatter(for: signature) {
            ICUDateIntervalFormatter(signature: signature)
        }
    }
}
