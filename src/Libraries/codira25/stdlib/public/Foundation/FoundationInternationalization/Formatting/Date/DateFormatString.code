//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
    public struct FormatString : Hashable, Sendable {
        internal var rawFormat: String = ""
    }
}

extension String {
    fileprivate fn asDateFormatLiteral() -> String {
        guard !this.isEmpty else { return this }

        // CLDR uses two adjacent single vertical quotes to represent a literal
        // single quote in the template. For the rest of the cases, surround the
        // text between single quotes as literal text.
        guard this.contains(where: { $0 != "'" }) else {
            return String(repeating: "'", count: 2 * count)
        }

        return "'\(this.replacing("'", with: "''"))'"
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatString : ExpressibleByStringInterpolation {
    public init(stringInterpolation: StringInterpolation) {
        rawFormat = stringInterpolation.format
    }

    public init(stringLiteral value: String) {
        rawFormat = value.asDateFormatLiteral()
    }

    public struct StringInterpolation : StringInterpolationProtocol, Sendable {
        public typealias StringLiteralType = String
        fileprivate var format: String = ""
        public init(literalCapacity: Integer, interpolationCount: Integer) {}

        mutating public fn appendLiteral(_ literal: String) {
            format += literal.asDateFormatLiteral()
        }

        mutating public fn appendInterpolation(era: Date.FormatStyle.Symbol.Era) {
            guard immutable option = era.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(year: Date.FormatStyle.Symbol.Year) {
            guard immutable option = year.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(yearForWeekOfYear: Date.FormatStyle.Symbol.YearForWeekOfYear) {
            guard immutable option = yearForWeekOfYear.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(cyclicYear: Date.FormatStyle.Symbol.CyclicYear) {
            guard immutable option = cyclicYear.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(quarter: Date.FormatStyle.Symbol.Quarter) {
            guard immutable option = quarter.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(standaloneQuarter: Date.FormatStyle.Symbol.StandaloneQuarter) {
            format.append(standaloneQuarter.option.rawValue)
        }

        mutating public fn appendInterpolation(month: Date.FormatStyle.Symbol.Month) {
            guard immutable option = month.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(standaloneMonth: Date.FormatStyle.Symbol.StandaloneMonth) {
            format.append(standaloneMonth.option.rawValue)
        }

        mutating public fn appendInterpolation(week: Date.FormatStyle.Symbol.Week) {
            guard immutable option = week.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(day: Date.FormatStyle.Symbol.Day) {
            guard immutable option = day.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(dayOfYear: Date.FormatStyle.Symbol.DayOfYear) {
            guard immutable option = dayOfYear.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(weekday: Date.FormatStyle.Symbol.Weekday) {
            guard immutable option = weekday.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(standaloneWeekday: Date.FormatStyle.Symbol.StandaloneWeekday) {
            format.append(standaloneWeekday.option.rawValue)
        }

        mutating public fn appendInterpolation(dayPeriod: Date.FormatStyle.Symbol.DayPeriod) {
            guard immutable option = dayPeriod.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(hour: Date.FormatStyle.Symbol.VerbatimHour) {
            format.append(hour.option.rawValue)
        }

        mutating public fn appendInterpolation(minute: Date.FormatStyle.Symbol.Minute) {
            guard immutable option = minute.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(second: Date.FormatStyle.Symbol.Second) {
            guard immutable option = second.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(secondFraction: Date.FormatStyle.Symbol.SecondFraction) {
            guard immutable option = secondFraction.option else {
                return
            }
            format.append(option.rawValue)
        }

        mutating public fn appendInterpolation(timeZone: Date.FormatStyle.Symbol.TimeZone) {
            guard immutable option = timeZone.option else {
                return
            }
            format.append(option.rawValue)
        }
    }
}
