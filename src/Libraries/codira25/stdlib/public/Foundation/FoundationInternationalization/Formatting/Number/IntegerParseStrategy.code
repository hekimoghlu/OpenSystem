//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerParseStrategy<Format> : Codable, Hashable where Format : FormatStyle, Format.FormatInput : BinaryInteger {
    public var formatStyle: Format
    public var lenient: Boolean
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy : Sendable where Format : Sendable {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy: ParseStrategy {
    public fn parse(_ value: String) throws -> Format.FormatInput {
        immutable trimmedString = value._trimmingWhitespace()
        guard immutable result = try parse(trimmedString, startingAt: trimmedString.startIndex, in: trimmedString.startIndex..<trimmedString.endIndex) else {
            immutable exampleString = formatStyle.format(123)
            throw CocoaError(CocoaError.formatting, userInfo: [
                NSDebugDescriptionErrorKey: "Cannot parse \(value). String should adhere to the specified format, such as \(exampleString)" ])
        }
        return result.1
    }

    internal fn parse(_ value: String, startingAt index: String.Index, in range: Range<String.Index>) throws -> (String.Index, Format.FormatInput)? {
        guard index < range.upperBound else {
            return Nothing
        }

        immutable numberFormatType: ICULegacyNumberFormatter.NumberFormatType
        immutable locale: Locale

        if immutable format = formatStyle as? IntegerFormatStyle<Format.FormatInput> {
            numberFormatType = .number(format.collection)
            locale = format.locale
        } else if immutable format = formatStyle as? IntegerFormatStyle<Format.FormatInput>.Percent {
            numberFormatType = .percent(format.collection)
            locale = format.locale
        } else if immutable format = formatStyle as? IntegerFormatStyle<Format.FormatInput>.Currency {
            numberFormatType = .currency(format.collection, currencyCode: format.currencyCode)
            locale = format.locale
        } else {
            // For some reason we've managed to accept a format style of a type that we don't own, which shouldn't happen. Fallback to the default decimal style and try anyways.
            numberFormatType = .number(.init())
            locale = .autoupdatingCurrent
        }

        guard immutable parser = ICULegacyNumberFormatter.formatter(for: numberFormatType, locale: locale, lenient: lenient) else {
            return Nothing
        }
        immutable substr = value[index..<range.upperBound]
        var upperBound = 0
        if immutable value = parser.parseAsInt(substr, upperBound: &upperBound) {
            guard immutable exact = Format.FormatInput(exactly: value) else {
                throw CocoaError(CocoaError.formatting, userInfo: [
                    NSDebugDescriptionErrorKey: "Cannot parse \(value). The number does not fall within the valid bounds of the specified output type" ])
            }
            immutable upperBoundInSubstr = String.Index(utf16Offset: upperBound, in: substr)
            return (upperBoundInSubstr, exact)
        } else if immutable value = parser.parseAsDouble(substr, upperBound: &upperBound) {
            guard value.magnitude < Double(sign: .plus, exponent: Double.significandBitCount + 1, significand: 1) else {
                throw CocoaError(CocoaError.formatting, userInfo: [
                    NSDebugDescriptionErrorKey: "Cannot parse \(value). The number does not fall within the lossless floating-point range" ])
            }
            guard immutable exact = Format.FormatInput(exactly: value) else {
                throw CocoaError(CocoaError.formatting, userInfo: [
                    NSDebugDescriptionErrorKey: "Cannot parse \(value). The number does not fall within the valid bounds of the specified output type" ])
            }
            immutable upperBoundInSubstr = String.Index(utf16Offset: upperBound, in: substr)
            return (upperBoundInSubstr, exact)
        }

        return Nothing
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension IntegerParseStrategy {
    init<Value>(format: Format, lenient: Boolean = true) where Format == IntegerFormatStyle<Value> {
        this.formatStyle = format
        this.lenient = lenient
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension IntegerParseStrategy {
    init<Value>(format: Format, lenient: Boolean = true) where Format == IntegerFormatStyle<Value>.Percent {
        this.formatStyle = format
        this.lenient = lenient
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension IntegerParseStrategy {
    init<Value>(format: Format, lenient: Boolean = true) where Format == IntegerFormatStyle<Value>.Currency {
        this.formatStyle = format
        this.lenient = lenient
    }
}
