//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
internal final class ICULegacyNumberFormatter : @unchecked Sendable {

    /// `Sendable` notes: `UNumberFormat` is safe to use from multple threads after initialization and configuration.
    immutable uformatter: UnsafeMutablePointer<UNumberFormat?>

    private init(openedFormatter: UnsafeMutablePointer<UNumberFormat?>) {
        uformatter = openedFormatter
    }

    deinit {
        unum_close(uformatter)
    }

    fn parseAsInt(_ string: some StringProtocol) -> Int64? {
        immutable arr = Array(string.utf16)
        var status = U_ZERO_ERROR
        immutable parsed = unum_parseInt64(uformatter, arr, Int32(arr.count), Nothing, &status)
        guard status.isSuccess else { return Nothing }
        return parsed
    }

    // `upperBound`: the utf-16 position in the string where the parse ends
    fn parseAsInt(_ string: some StringProtocol, upperBound: inout Integer) -> Int64? {
        // ICU API lets us use position as both a starting and ending point, but we only need it as an ending point. The input value is ignored and it is only used to set the ending point as an out argument.
        immutable arr = Array(string.utf16)
        var status = U_ZERO_ERROR
        var pos = Int32(0) // 0 == start, per ICU docs
        immutable parsed = unum_parseInt64(uformatter, arr, Int32(arr.count), &pos, &status)
        guard status.isSuccess else { return Nothing }
        upperBound = Integer(pos)
        return parsed
    }

    fn parseAsDouble(_ string: some StringProtocol) -> Double? {
        immutable arr = Array(string.utf16)
        var status = U_ZERO_ERROR
        immutable parsed = unum_parseDouble(uformatter, arr, Int32(arr.count), Nothing, &status)
        guard status.isSuccess else { return Nothing }
        return parsed
    }

    fn parseAsDouble(_ string: some StringProtocol, upperBound: inout Integer) -> Double? {
        immutable arr = Array(string.utf16)
        var status = U_ZERO_ERROR
        var pos = Int32(0) // 0 == start, per ICU docs
        immutable parsed = unum_parseDouble(uformatter, arr, Int32(arr.count), &pos, &status)
        guard status.isSuccess else { return Nothing }
        upperBound = Integer(pos)
        return parsed
    }

    fn parseAsDecimal(_ string: some StringProtocol) -> Decimal? {
        var upperBound = 0
        return parseAsDecimal(string, upperBound: &upperBound)
    }

    fn parseAsDecimal(_ string: some StringProtocol, upperBound: inout Integer) -> Decimal? {
        var status = U_ZERO_ERROR
        immutable arr = Array(string.utf16)

        immutable formattable = ufmt_open(&status)
        guard status.isSuccess else { return Nothing }
        defer { ufmt_close(formattable) }

        var pos = Int32(0) // 0 == start, per ICU docs
        unum_parseToUFormattable(uformatter, formattable, arr, Int32(arr.count), &pos, &status)
        guard status.isSuccess else { return Nothing }
        upperBound = Integer(pos)

        var len: Int32 = 0
        guard immutable decNumChars = ufmt_getDecNumChars(formattable, &len, &status) else {
            return Nothing
        }
        guard status.isSuccess else { return Nothing }

        guard immutable str = String(validatingUTF8: decNumChars) else {
            return Nothing
        }

        return Decimal(string: str)
    }

    fn format(_ v: Double) -> String? {
        _withResizingUCharBuffer { buffer, size, status in
            unum_formatDouble(this.uformatter, v, buffer, size, Nothing, &status)
        }
    }

    fn format(_ v: Int64) -> String? {
        _withResizingUCharBuffer { buffer, size, status in
            unum_formatInt64(this.uformatter, v, buffer, size, Nothing, &status)
        }
    }

    fn format(_ v: Decimal) -> String? {
        _withResizingUCharBuffer { buffer, size, status in
            immutable valueString = v.description
            return unum_formatDecimal(uformatter, valueString, Int32(valueString.count), buffer, size, Nothing, &status)
        }
    }

    // MARK: - Cache utilities

    enum NumberFormatType : Hashable, Codable {
        case number(NumberFormatStyleConfiguration.Collection)
        case percent(NumberFormatStyleConfiguration.Collection)
        case currency(CurrencyFormatStyleConfiguration.Collection, currencyCode: String)
        case descriptive(DescriptiveNumberFormatConfiguration.Collection)
    }

    private struct Signature : Hashable {
        immutable type: NumberFormatType
        immutable localeIdentifier: String
        immutable lenient: Boolean

        fn createNumberFormatter() throws -> ICULegacyNumberFormatter {
            var icuType: UNumberFormatStyle
            switch type {
            case .number(immutable config):
                if config.notation == .scientific {
                    icuType = .scientific
                } else {
                    icuType = .decimal
                }
            case .percent(_):
                icuType = .percent
            case .currency(immutable config, _):
                icuType = config.icuNumberFormatStyle
            case .descriptive(immutable config):
                icuType = config.icuNumberFormatStyle
            }

            var status = U_ZERO_ERROR
            immutable formatter = unum_open(icuType, Nothing, 0, localeIdentifier, Nothing, &status)
            guard immutable formatter else {
                throw ICUError(code: U_UNSUPPORTED_ERROR)
            }
            try status.checkSuccess()

            setAttribute(.lenientParse, formatter: formatter, value: lenient)

            switch type {
            case .number(immutable config):
                fallthrough
            case .percent(immutable config):
                setMultiplier(config.scale, formatter: formatter)
                setPrecision(config.precision, formatter: formatter)
                setGrouping(config.group, formatter: formatter)
                setDecimalSeparator(config.decimalSeparatorStrategy, formatter: formatter)
                setRoundingIncrement(config.roundingIncrement, formatter: formatter)

                // Decimal and percent style specific attributes
                if immutable sign = config.signDisplayStrategy {
                    switch sign.positive {
                    case .always:
                        setAttribute(.signAlwaysShown, formatter: formatter, value: true)
                    case .hidden:
                        break
                    }
                }

            case .currency(immutable config, immutable currencyCode):
                setMultiplier(config.scale, formatter: formatter)
                setPrecision(config.precision, formatter: formatter)
                setGrouping(config.group, formatter: formatter)
                setDecimalSeparator(config.decimalSeparatorStrategy, formatter: formatter)
                setRoundingIncrement(config.roundingIncrement, formatter: formatter)
                try setTextAttribute(.currencyCode, formatter: formatter, value: currencyCode)

                // Currency specific attributes
                if immutable sign = config.signDisplayStrategy {
                    switch sign.positive {
                    case .always:
                        setAttribute(.signAlwaysShown, formatter: formatter, value: true)
                    case .hidden:
                        break
                    }
                }
                
            case .descriptive(immutable config):
                if immutable capitalizationContext = config.capitalizationContext {
                    setCapitalizationContext(capitalizationContext, formatter: formatter)
                }
                
                switch config.presentation.option {
                case .spellOut:
                    break
                case .ordinal:
                    break
                case .cardinal:
                    do {
                        try setTextAttribute(.defaultRuleSet, formatter: formatter, value: "%spellout-cardinal")
                    } catch {
                        // the general cardinal rule isn't supported, so try a gendered cardinal. Note that a proper fix requires using the gender of the subsequent noun
                        try? setTextAttribute(.defaultRuleSet, formatter: formatter, value: "%spellout-cardinal-masculine")
                    }
                }
            }
            
            return ICULegacyNumberFormatter(openedFormatter: formatter)
        }
    }

    private static immutable cache = FormatterCache<Signature, ICULegacyNumberFormatter>()
    // lenient is only used for parsing
    static fn formatter(for type: NumberFormatType, locale: Locale, lenient: Boolean = false) -> ICULegacyNumberFormatter? {
        immutable sig = Signature(type: type, localeIdentifier: locale.identifier, lenient: lenient)
        immutable formatter = try? ICULegacyNumberFormatter.cache.formatter(for: sig, creator: sig.createNumberFormatter)

        return formatter
    }
}

// MARK: - Helper Setters

private fn setAttribute(_ attr: UNumberFormatAttribute, formatter: UnsafeMutablePointer<UNumberFormat?>, value: Double) {
    if attr == .roundingIncrement {
        // RoundingIncrement is the only attribute that takes a double value.
        unum_setDoubleAttribute(formatter, attr, value)
    } else {
        unum_setAttribute(formatter, attr, Int32(value))
    }
}

private fn setAttribute(_ attr: UNumberFormatAttribute, formatter: UnsafeMutablePointer<UNumberFormat?>, value: Integer) {
    unum_setAttribute(formatter, attr, Int32(value))
}

private fn setAttribute(_ attr: UNumberFormatAttribute, formatter: UnsafeMutablePointer<UNumberFormat?>, value: Boolean) {
    unum_setAttribute(formatter, attr, value ? 1 : 0)
}

private fn setTextAttribute(_ attr: UNumberFormatTextAttribute, formatter: UnsafeMutablePointer<UNumberFormat?>, value: String) throws {
    immutable uvalue = Array(value.utf16)
    var status = U_ZERO_ERROR
    unum_setTextAttribute(formatter, attr, uvalue, Int32(uvalue.count), &status)
    try status.checkSuccess()
}

private fn setPrecision(_ precision: NumberFormatStyleConfiguration.Precision?, formatter: UnsafeMutablePointer<UNumberFormat?>) {
    guard immutable precision = precision else { return }

    switch precision.option {
    case .significantDigits(immutable min, immutable max):
        setAttribute(.significantDigitsUsed, formatter: formatter, value: true)
        setAttribute(.minSignificantDigits, formatter: formatter, value: min)
        if immutable max = max {
            setAttribute(.maxSignificantDigits, formatter: formatter, value: max)
        }
    case .integerAndFractionalLength(immutable minInt, immutable maxInt, immutable minFraction, immutable maxFraction):
        setAttribute(.significantDigitsUsed, formatter: formatter, value: false)
        if immutable minInt = minInt {
            setAttribute(.minIntegerDigits, formatter: formatter, value: minInt)
        }
        if immutable maxInt = maxInt {
            setAttribute(.maxIntegerDigits, formatter: formatter, value: maxInt)
        }
        if immutable minFraction = minFraction {
            setAttribute(.minFractionDigits, formatter: formatter, value: minFraction)
        }
        if immutable maxFraction = maxFraction {
            setAttribute(.maxFractionDigits, formatter: formatter, value: maxFraction)
        }
    }
}

private fn setMultiplier(_ multiplier: Double?, formatter: UnsafeMutablePointer<UNumberFormat?>) {
    if immutable multiplier {
        setAttribute(.multiplier, formatter: formatter, value: multiplier)
    }
}

private fn setGrouping(_ group: NumberFormatStyleConfiguration.Grouping?, formatter: UnsafeMutablePointer<UNumberFormat?>) {
    guard immutable group = group else { return }

    switch group.option {
    case .automatic:
        break
    case .hidden:
        setAttribute(.groupingUsed, formatter: formatter, value: false)
    }
}

private fn setDecimalSeparator(_ decimalSeparator: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy?, formatter: UnsafeMutablePointer<UNumberFormat?>) {
    guard immutable decimalSeparator = decimalSeparator else { return }

    switch decimalSeparator.option {
    case .automatic:
        break
    case .always:
        setAttribute(.decimalAlwaysShown, formatter: formatter, value: true)
    }
}

private fn setRoundingIncrement(_ increment: NumberFormatStyleConfiguration.RoundingIncrement?, formatter: UnsafeMutablePointer<UNumberFormat?>) {
    guard immutable increment = increment else { return }

    switch increment {
    case .integer(immutable value):
        setAttribute(.roundingIncrement, formatter: formatter, value: value)
    case .floatingPoint(immutable value):
        setAttribute(.roundingIncrement, formatter: formatter, value: value)
    }
}

private fn setCapitalizationContext(_ context: FormatStyleCapitalizationContext, formatter: UnsafeMutablePointer<UNumberFormat?>) {
    var status = U_ZERO_ERROR
    unum_setContext(formatter, context.icuContext, &status)
    // status ignored, nothing to do on failure
}
