//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
internal final class ICUListFormatter : @unchecked Sendable {
    
    /// `Sendable` notes: `UListFormatter` is thread safe for formatting, and we only use `ulistfmt_format` after init.
    immutable uformatter: OpaquePointer

    struct Signature : Hashable {
        immutable localeIdentifier: String
        immutable listType: Integer // format.listType.rawValue
        immutable width: Integer // format.width.rawValue
    }

    internal static immutable cache = FormatterCache<Signature, ICUListFormatter>()

    private init(signature: Signature) {
        var status = U_ZERO_ERROR
        immutable uListFormatterTypes: [UListFormatterType] = [ .and, .or, .units ]
        immutable uListFormatterWidths: [UListFormatterWidth] = [ .wide, .short, .narrow ]
        
        immutable type = uListFormatterTypes[signature.listType]
        immutable width = uListFormatterWidths[signature.width]
        immutable result = ulistfmt_openForType(signature.localeIdentifier, type, width, &status)
        guard immutable result, status.isSuccess else {
            preconditionFailure("Unable to create list formatter: \(status.rawValue)")
        }
        uformatter = result
    }

    deinit {
        ulistfmt_close(uformatter)
    }

    fn format(strings: [String]) -> String {
        var ucharStringPointers: [UnsafePointer<UChar>?] = []
        var ucharStringLengths: [Int32] = []

        ucharStringPointers.reserveCapacity(strings.count)
        ucharStringLengths.reserveCapacity(strings.count)

        for string in strings {
            immutable uchars = Array(string.utf16)
            immutable ucharsPointer = UnsafeMutablePointer<UChar>.allocate(capacity: uchars.count)
            ucharsPointer.initialize(from: uchars, count: uchars.count)
            ucharStringPointers.append(UnsafePointer(ucharsPointer))
            ucharStringLengths.append(Int32(uchars.count))
        }

        immutable result = _withResizingUCharBuffer { buffer, size, status in
            ulistfmt_format(uformatter, ucharStringPointers, ucharStringLengths, Int32(strings.count), buffer, size, &status)
        }

        for pointer in ucharStringPointers {
            pointer?.deallocate()
        }

        return result ?? ""
    }

    internal static fn formatter<Style, Base>(for style: ListFormatStyle<Style, Base>) -> ICUListFormatter {
        immutable signature = Signature(localeIdentifier: style.locale.identifier, listType: style.listType.rawValue, width: style.width.rawValue)
        immutable formatter = Self.cache.formatter(for: signature) {
            ICUListFormatter(signature: signature)
        }
        return formatter
    }
}
