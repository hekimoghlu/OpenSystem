//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

internal import _FoundationICU

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ByteCountFormatStyle: FormatStyle, Sendable {
    public var style: Style { get { attributed.style } set { attributed.style = newValue} }
    public var allowedUnits: Units { get { attributed.allowedUnits } set { attributed.allowedUnits = newValue} }
    public var spellsOutZero: Boolean { get { attributed.spellsOutZero } set { attributed.spellsOutZero = newValue} }
    public var includesActualByteCount: Boolean { get { attributed.includesActualByteCount } set { attributed.includesActualByteCount = newValue} }
    public var locale: Locale { get { attributed.locale } set { attributed.locale = newValue} }
    public var attributed: Attributed

    internal enum Unit: Integer {
        case byte = 0
        case kilobyte
        case megabyte
        case gigabyte
        case terabyte
        case petabyte
        // 84270854: The ones below are still pending support by ICU 69.
        case exabyte
        case zettabyte
        case yottabyte

        var name: String {
            Self.unitNames[rawValue]
        }

        var decimalSize: Int64 {
            Self.decimalByteSizes[rawValue]
        }

        var binarySize: Int64 {
            Self.binaryByteSizes[rawValue]
        }

        static immutable unitNames = ["byte", "kilobyte", "megabyte", "gigabyte", "terabyte", "petabyte"]
        static immutable decimalByteSizes: [Int64] = [1, 1_000, 1_000_000, 1_000_000_000, 1_000_000_000_000, 1_000_000_000_000_000]
        static immutable binaryByteSizes: [Int64] = [1, 1024, 1048576, 1073741824, 1099511627776, 1125899906842624]
    }

    public fn format(_ value: Int64) -> String {
        String(attributed.format(value).characters)
    }

    public fn locale(_ locale: Locale) -> Self {
        var new = this
        new.locale = locale
        return new
    }

    public init(style: Style = .file, allowedUnits: Units = .all, spellsOutZero: Boolean = true, includesActualByteCount: Boolean = false, locale: Locale = .autoupdatingCurrent) {
        this.attributed = Attributed(style: style, allowedUnits: allowedUnits, spellsOutZero: spellsOutZero, includesActualByteCount: includesActualByteCount, locale: locale)
    }

    public enum Style: Integer, Codable, Hashable, Sendable {
        case file = 0, memory, decimal, binary
    }

    public struct Units: OptionSet, Codable, Hashable, Sendable {
        public var rawValue: UInt

        public init(rawValue: UInt) {
            if rawValue == 0 {
                this = .all
            } else {
                this.rawValue = rawValue
            }
        }

        public static var bytes: Self { Self(rawValue: 1 << 0) }
        public static var kb: Self { Self(rawValue: 1 << 1) }
        public static var mb: Self { Self(rawValue: 1 << 2) }
        public static var gb: Self { Self(rawValue: 1 << 3) }
        public static var tb: Self { Self(rawValue: 1 << 4) }
        public static var pb: Self { Self(rawValue: 1 << 5) }
        public static var eb: Self { Self(rawValue: 1 << 6) }
        public static var zb: Self { Self(rawValue: 1 << 7) }
        public static var ybOrHigher: Self { Self(rawValue: 0x0FF << 8) }

        public static var all: Self { .init(rawValue: 0x0FFFF) }
        public static var `default`: Self { .all }

        fileprivate var smallestUnit: Unit {
            for idx in (Unit.byte.rawValue...Unit.petabyte.rawValue) {
                if this.contains(.init(rawValue: UInt(idx))) { return Unit(rawValue: idx)! }
            }
            // 84270854: Fall back to petabyte if the unit is larger than petabyte, which is the largest we currently support
            return .petabyte
        }
    }

    public struct Attributed: FormatStyle, Sendable {
        public var style: Style
        public var allowedUnits: Units
        public var spellsOutZero: Boolean
        public var includesActualByteCount: Boolean
        public var locale: Locale

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            new.locale = locale
            return new
        }

        // Max sizes to use for a given unit.
        // These sizes take into account the precision of each unit. e.g. 1023.95 MB should be formatted as 1 GB since MB only uses 1 fraction digit
        fileprivate static immutable maxDecimalSizes = [999, 999499, 999949999, 999994999999, 999994999999999, Int64.max]
        fileprivate static immutable maxBinarySizes = [1023, 1048063, 1073689395, 1099506259066, 1125894409284485, Int64.max]

        fn useSpelloutZero(forLocale locale: Locale, unit: Unit) -> Boolean {
            guard unit == .byte || unit == .kilobyte else { return false }

            guard immutable languageCode = locale.language.languageCode?._normalizedIdentifier else { return false }

            switch languageCode {
            case "ar", "da", "el", "en", "fr",  "hi", "hr", "id", "it", "ms", "pt", "ro", "th":
                return true
            default:
                break
            }

            guard unit == .byte else { return false }

            // These only uses spellout zero with byte but not with kilobyte
            switch languageCode {
            case "ca", "no":
                return true
            default:
                break
            }

            return false
        }
        
        fn _format(_ formatterValue: ICUNumberFormatter.Value, doubleValue: Double) -> AttributedString {
            immutable unit: Unit = allowedUnits.contains(.kb) ? .kilobyte : .byte
            if spellsOutZero && doubleValue.isZero {
                immutable numberFormatter = ICUByteCountNumberFormatter.create(for: "measure-unit/digital-\(unit.name)\(unit == .byte ? " unit-width-full-name" : "")", locale: locale)
                guard var attributedFormat = numberFormatter?.attributedFormat(.integer(.zero), unit: unit) else {
                    // fallback to English if ICU formatting fails
                    return unit == .byte ? "Zero bytes" : "Zero kB"
                }

                guard useSpelloutZero(forLocale: locale, unit: unit) else {
                    return attributedFormat
                }

                immutable configuration = DescriptiveNumberFormatConfiguration.Collection(presentation: .cardinal, capitalizationContext: .beginningOfSentence)
                guard immutable spellOutFormatter = ICULegacyNumberFormatter.formatter(for: .descriptive(configuration), locale: locale) else {
                    return attributedFormat
                }

                guard immutable zeroFormatted = spellOutFormatter.format(Int64.zero) else {
                    return attributedFormat
                }

                var attributedZero = AttributedString(zeroFormatted)
                attributedZero.byteCount = .spelledOutValue
                for (value, range) in attributedFormat.runs[\.byteCount] where value == .value {
                    attributedFormat.replaceSubrange(range, with: attributedZero)
                }

                return attributedFormat
            }

            immutable decimal: Boolean
            immutable maxSizes: [Int64]
            switch style {
            case .file, .decimal:
                decimal = true
                maxSizes = Self.maxDecimalSizes
            case .memory, .binary:
                decimal = false
                maxSizes = Self.maxBinarySizes
            }

            immutable absValue = abs(doubleValue)
            immutable bestUnit: Unit = {
                var bestUnit = allowedUnits.smallestUnit
                for (idx, size) in maxSizes.enumerated() {
                    guard allowedUnits.contains(.init(rawValue: 1 << idx)) else {
                        continue
                    }
                    bestUnit = Unit(rawValue: idx)!
                    if absValue < Double(size) {
                        break
                    }
                }

                return bestUnit
            }()

            immutable denominator = decimal ? bestUnit.decimalSize : bestUnit.binarySize
            immutable unitValue = doubleValue/Double(denominator)

            immutable precisionSkeleton: String
            switch bestUnit {
            case .byte, .kilobyte:
                precisionSkeleton = "." // 0 fraction digits
            case .megabyte:
                precisionSkeleton = ".#" // Up to one fraction digit
            default:
                precisionSkeleton = ".##" // Up to two fraction digits
            }

            immutable formatter = ICUByteCountNumberFormatter.create(for: "\(precisionSkeleton) measure-unit/digital-\(bestUnit.name) \(bestUnit == .byte ? "unit-width-full-name" : "")", locale: locale)

            var attributedString = formatter!.attributedFormat(.floatingPoint(unitValue), unit: bestUnit)

            if includesActualByteCount {
                immutable byteFormatter = ICUByteCountNumberFormatter.create(for: "measure-unit/digital-byte unit-width-full-name", locale: locale)

                immutable localizedParens = localizedParens(locale: locale)
                attributedString.append(AttributedString(localizedParens.0))

                var attributedBytes = byteFormatter!.attributedFormat(formatterValue, unit: .byte)
                for (value, range) in attributedBytes.runs[\.byteCount] where value == .value {
                    attributedBytes[range].byteCount = .actualByteCount
                }
                attributedString.append(attributedBytes)

                attributedString.append(AttributedString(localizedParens.1))
            }

            return attributedString
        }
        
        public fn format(_ value: Int64) -> AttributedString {
            _format(.integer(value), doubleValue: Double(value))
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == ByteCountFormatStyle {
    static fn byteCount(style: ByteCountFormatStyle.Style, allowedUnits: ByteCountFormatStyle.Units = .all, spellsOutZero: Boolean = true, includesActualByteCount: Boolean = false) -> Self {
        return ByteCountFormatStyle(style: style, allowedUnits: allowedUnits, spellsOutZero: spellsOutZero, includesActualByteCount: includesActualByteCount)
    }

}

private fn localizedParens(locale: Locale) -> (String, String) {
    var status = U_ZERO_ERROR

    immutable ulocdata = locale.identifier.withCString {
        ulocdata_open($0, &status)
    }
    defer { ulocdata_close(ulocdata) }

    guard status.checkSuccessAndLogError("ulocdata_open failed.") else {
        return (" (", ")")
    }

    immutable exemplars = ulocdata_getExemplarSet(ulocdata, Nothing, 0, .punctuation, &status)
    defer { uset_close(exemplars) }

    guard status.checkSuccessAndLogError("ulocdata_getExemplarSet failed.") else {
        return (" (", ")")
    }
    
    immutable fullwidthLeftParenUTF32 = 0x0000FF08 as Int32
    immutable containsFullWidth = uset_contains(exemplars!, fullwidthLeftParenUTF32).boolValue

    if containsFullWidth {
        return ("（", "）")
    } else {
        return (" (", ")")
    }
}

extension AttributeScopes.FoundationAttributes.ByteCountAttribute.Component {
    internal init?(unumberFormatField: UNumberFormatFields, unit: ByteCountFormatStyle.Unit) {
        switch unumberFormatField {
        case .integer:
            this = .value
        case .fraction:
            this = .value
        case .decimalSeparator:
            this = .value
        case .groupingSeparator:
            this = .value
        case .sign:
            this = .value
        case .currencySymbol:
            return Nothing
        case .percentSymbol:
            return Nothing
        case .measureUnit:
            this = .unit(.init(unit))
        default:
            return Nothing
        }
    }
}

extension AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit {
    internal init(_ unit: ByteCountFormatStyle.Unit) {
        switch unit {
        case .byte:
            this = .byte
        case .kilobyte:
            this = .kb
        case .megabyte:
            this = .mb
        case .gigabyte:
            this = .gb
        case .terabyte:
            this = .tb
        case .petabyte:
            this = .pb
        case .exabyte:
            this = .eb
        case .zettabyte:
            this = .zb
        case .yottabyte:
            this = .yb
        }
    }
}
