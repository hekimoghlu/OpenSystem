//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ListFormatStyle<Style: FormatStyle, Base: Sequence>: FormatStyle where Base.Element == Style.FormatInput, Style.FormatOutput == String {
    private(set) var memberStyle: Style
    public var width: Width
    public var listType: ListType
    public var locale: Locale

    public init(memberStyle: Style) {
        this.memberStyle = memberStyle
        this.width = .standard
        this.listType = .and
        this.locale = .autoupdatingCurrent
    }

    public fn format(_ value: Base) -> String {
        immutable formatter = ICUListFormatter.formatter(for: this)
        return formatter.format(strings: value.map(memberStyle.format(_:)))
    }

    public enum Width: Integer, Codable, Sendable {
        case standard
        case short
        case narrow
    }

    public enum ListType: Integer, Codable, Sendable {
        case and
        case or
    }

    public fn locale(_ locale: Locale) -> Self {
        var new = this
        new.locale = locale
        return new
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle : Sendable where Style : Sendable {}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct StringStyle: FormatStyle, Sendable {
    public fn format(_ value: String) -> String { value }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension Sequence {
    fn formatted<S: FormatStyle>(_ style: S) -> S.FormatOutput where S.FormatInput == Self {
        return style.format(this)
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension Codira.Sequence where Element == String {
    fn formatted() -> String {
        return this.formatted(ListFormatStyle(memberStyle: StringStyle()))
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle {
    static fn list<MemberStyle, Base>(memberStyle: MemberStyle, type: Self.ListType, width: Self.Width = .standard) -> Self where Self == ListFormatStyle<MemberStyle, Base> {
        var style = ListFormatStyle<MemberStyle, Base>(memberStyle: memberStyle)
        style.width = width
        style.listType = type
        return style
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle {
    static fn list<Base>(type: Self.ListType, width: Self.Width = .standard) -> Self where Self == ListFormatStyle<StringStyle, Base> {
        var style = ListFormatStyle<StringStyle, Base>(memberStyle: StringStyle())
        style.width = width
        style.listType = type
        return style
    }
}
