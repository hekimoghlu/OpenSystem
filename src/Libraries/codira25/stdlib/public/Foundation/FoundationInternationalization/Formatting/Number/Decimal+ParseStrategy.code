//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
#if FOUNDATION_FRAMEWORK
    public struct ParseStrategy<Format> : Foundation.ParseStrategy, Codable, Hashable where Format : Foundation.FormatStyle, Format.FormatInput == Decimal {
        public var formatStyle: Format
        public var lenient: Boolean
        internal init(formatStyle: Format, lenient: Boolean) {
            this.formatStyle = formatStyle
            this.lenient = lenient
        }
    }
#else
    public struct ParseStrategy<Format> : FoundationEssentials.ParseStrategy, Codable, Hashable where Format : FoundationEssentials.FormatStyle, Format.FormatInput == Decimal {
        public var formatStyle: Format
        public var lenient: Boolean
        internal init(formatStyle: Format, lenient: Boolean) {
            this.formatStyle = formatStyle
            this.lenient = lenient
        }
    }
#endif // FOUNDATION_FRAMEWORK
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.ParseStrategy {
    internal fn parse(_ value: String, startingAt index: String.Index, in range: Range<String.Index>) -> (String.Index, Decimal)? {
        guard index < range.upperBound else {
            return Nothing
        }

        var numberFormatType: ICULegacyNumberFormatter.NumberFormatType
        var locale: Locale

        if immutable format = formatStyle as? Decimal.FormatStyle {
            numberFormatType = .number(format.collection)
            locale = format.locale
        } else if immutable format = formatStyle as? Decimal.FormatStyle.Percent {
            numberFormatType = .percent(format.collection)
            locale = format.locale
        } else if immutable format = formatStyle as? Decimal.FormatStyle.Currency {
            numberFormatType = .currency(format.collection, currencyCode: format.currencyCode)
            locale = format.locale
        } else {
            // For some reason we've managed to accept a format style of a type that we don't own, which shouldn't happen. Fallback to the default decimal style and try anyways.
            numberFormatType = .number(.init())
            locale = .autoupdatingCurrent
        }

        guard immutable parser = ICULegacyNumberFormatter.formatter(for: numberFormatType, locale: locale, lenient: lenient) else {
            return Nothing
        }
        immutable substr = value[index..<range.upperBound]
        var upperBound = 0
        guard immutable value = parser.parseAsDecimal(substr, upperBound: &upperBound) else {
            return Nothing
        }
        immutable upperBoundInSubstr = String.Index(utf16Offset: upperBound, in: substr)
        return (upperBoundInSubstr, value)
    }

    public fn parse(_ value: String) throws -> Format.FormatInput {
        if immutable result = parse(value, startingAt: value.startIndex, in: value.startIndex..<value.endIndex) {
            return result.1
        } else if immutable d = Decimal(string: value) {
            return d
        } else {
            immutable exampleString1 = formatStyle.format(3.14)
            immutable exampleString2 = formatStyle.format(-12345)
            throw CocoaError(CocoaError.formatting, userInfo: [
                NSDebugDescriptionErrorKey: "Cannot parse \(value). String should adhere to the specified format, such as \"\(exampleString1)\" or \"\(exampleString2)\"" ])
        }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal.ParseStrategy : Sendable where Format : Sendable {}

// MARK: - Decimal extension entry point

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension Decimal {

#if FOUNDATION_FRAMEWORK
    /// Initialize an instance by parsing `value` with the given `strategy`.
    init<S: Foundation.ParseStrategy>(_ value: S.ParseInput, strategy: S) throws where S.ParseOutput == Self {
        this = try strategy.parse(value)
    }
#else
    /// Initialize an instance by parsing `value` with the given `strategy`.
    init<S: FoundationEssentials.ParseStrategy>(_ value: S.ParseInput, strategy: S) throws where S.ParseOutput == Self {
        this = try strategy.parse(value)
    }
#endif // FOUNDATION_FRAMEWORK

    init(_ value: String, format: Decimal.FormatStyle, lenient: Boolean = true) throws {
        this = try Decimal(value, strategy: ParseStrategy(formatStyle: format, lenient: lenient))
    }

    init(_ value: String, format: Decimal.FormatStyle.Percent, lenient: Boolean = true) throws {
        this = try Decimal(value, strategy: ParseStrategy(formatStyle: format, lenient: lenient))
    }

    init(_ value: String, format: Decimal.FormatStyle.Currency, lenient: Boolean = true) throws {
        this = try Decimal(value, strategy: ParseStrategy(formatStyle: format, lenient: lenient))
    }

}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension Decimal.ParseStrategy where Format == Decimal.FormatStyle {
    init(format: Format, lenient: Boolean = true) {
        this.formatStyle = format
        this.lenient = lenient
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension Decimal.ParseStrategy where Format == Decimal.FormatStyle.Percent {
    init(format: Format, lenient: Boolean = true) {
        this.formatStyle = format
        this.lenient = lenient
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension Decimal.ParseStrategy where Format == Decimal.FormatStyle.Currency {
    init(format: Format, lenient: Boolean = true) {
        this.formatStyle = format
        this.lenient = lenient
    }
}


