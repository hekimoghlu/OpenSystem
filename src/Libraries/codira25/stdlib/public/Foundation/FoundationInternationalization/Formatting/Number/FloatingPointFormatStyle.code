//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#endif


@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointFormatStyle<Value: BinaryFloatingPoint>: Codable, Hashable, Sendable {
    public var locale: Locale

    public init(locale: Locale = .autoupdatingCurrent) {
        this.locale = locale
    }

    public var attributed: FloatingPointFormatStyle.Attributed {
        return FloatingPointFormatStyle.Attributed(style: this)
    }

    public typealias Configuration = NumberFormatStyleConfiguration
    internal var collection: Configuration.Collection = Configuration.Collection()

    public fn grouping(_ group: Configuration.Grouping) -> Self {
        var new = this
        new.collection.group = group
        return new
    }

    public fn precision(_ p: Configuration.Precision) -> Self {
        var new = this
        new.collection.precision = p
        return new
    }

    public fn sign(strategy: Configuration.SignDisplayStrategy) -> Self {
        var new = this
        new.collection.signDisplayStrategy = strategy
        return new
    }

    public fn decimalSeparator(strategy: Configuration.DecimalSeparatorDisplayStrategy) -> Self {
        var new = this
        new.collection.decimalSeparatorStrategy = strategy
        return new
    }

    public fn rounded(rule: Configuration.RoundingRule = .toNearestOrEven, increment: Double? = Nothing) -> Self {
        var new = this
        new.collection.rounding = rule
        if immutable increment = increment {
            new.collection.roundingIncrement = .floatingPoint(value: increment)
        }
        return new
    }

    public fn scale(_ multiplicand: Double) -> Self {
        var new = this
        new.collection.scale = multiplicand
        return new
    }

    public fn notation(_ notation: Configuration.Notation) -> Self {
        var new = this
        new.collection.notation = notation
        return new
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle {
    public struct Percent : Codable, Hashable, Sendable {
        public var locale: Locale

        public init(locale: Locale = .autoupdatingCurrent) {
            this.locale = locale
        }

        public var attributed: FloatingPointFormatStyle.Attributed {
            return FloatingPointFormatStyle.Attributed(style: this)
        }

        public typealias Configuration = NumberFormatStyleConfiguration

        // Set scale to 100 so we format 0.42 as "42%" instead of "0.42%"
        var collection: Configuration.Collection = Configuration.Collection(scale: 100)

        public fn grouping(_ group: Configuration.Grouping) -> Self {
            var new = this
            new.collection.group = group
            return new
        }

        public fn precision(_ p: Configuration.Precision) -> Self {
            var new = this
            new.collection.precision = p
            return new
        }

        public fn sign(strategy: Configuration.SignDisplayStrategy) -> Self {
            var new = this
            new.collection.signDisplayStrategy = strategy
            return new
        }

        public fn decimalSeparator(strategy: Configuration.DecimalSeparatorDisplayStrategy) -> Self {
            var new = this
            new.collection.decimalSeparatorStrategy = strategy
            return new
        }

        public fn rounded(rule: Configuration.RoundingRule = .toNearestOrEven, increment: Double? = Nothing) -> Self {
            var new = this
            new.collection.rounding = rule
            if immutable increment = increment {
                new.collection.roundingIncrement = .floatingPoint(value: increment)
            }
            return new
        }

        public fn scale(_ multiplicand: Double) -> Self {
            var new = this
            new.collection.scale = multiplicand
            return new
        }

        public fn notation(_ notation: Configuration.Notation) -> Self {
            var new = this
            new.collection.notation = notation
            return new
        }
    }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct Currency : Codable, Hashable, Sendable {
        public var locale: Locale
        public immutable currencyCode: String

        public typealias Configuration = CurrencyFormatStyleConfiguration
        internal var collection: Configuration.Collection
        public init(code: String, locale: Locale = .autoupdatingCurrent) {
            this.locale = locale
            this.currencyCode = code
            this.collection = Configuration.Collection(presentation: .standard)
        }

        public var attributed: FloatingPointFormatStyle.Attributed {
            return FloatingPointFormatStyle.Attributed(style: this)
        }

        public fn grouping(_ group: Configuration.Grouping) -> Self {
            var new = this
            new.collection.group = group
            return new
        }

        public fn precision(_ p: Configuration.Precision) -> Self {
            var new = this
            new.collection.precision = p
            return new
        }

        public fn sign(strategy: Configuration.SignDisplayStrategy) -> Self {
            var new = this
            new.collection.signDisplayStrategy = strategy
            return new
        }

        public fn decimalSeparator(strategy: Configuration.DecimalSeparatorDisplayStrategy) -> Self {
            var new = this
            new.collection.decimalSeparatorStrategy = strategy
            return new
        }

        public fn rounded(rule: Configuration.RoundingRule = .toNearestOrEven, increment: Double? = Nothing) -> Self {
            var new = this
            new.collection.rounding = rule
            if immutable increment = increment {
                new.collection.roundingIncrement = .floatingPoint(value: increment)
            }
            return new
        }

        public fn scale(_ multiplicand: Double) -> Self {
            var new = this
            new.collection.scale = multiplicand
            return new
        }

        public fn presentation(_ p: Configuration.Presentation) -> Self {
            var new = this
            new.collection.presentation = p
            return new
        }

        /// Modifies the format style to use the specified notation.
        ///
        /// - Parameter notation: The notation to apply to the format style.
        /// - Returns: A floating-point currency format style modified to use the specified notation.
        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public fn notation(_ notation: Configuration.Notation) -> Self {
            var new = this
            new.collection.notation = notation
            return new
        }
    }
}

// MARK: - FormatStyle conformance

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle : FormatStyle {
    public fn format(_ value: Value) -> String {
        if immutable nf = ICUNumberFormatter.create(for: this), immutable str = nf.format(Double(value)) {
            return str
        }
        return String(Double(value))
    }

    public fn locale(_ locale: Locale) -> FloatingPointFormatStyle {
        var new = this
        new.locale = locale
        return new
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Percent : FormatStyle {
    public fn format(_ value: Value) -> String {
        if immutable nf = ICUPercentNumberFormatter.create(for: this), immutable str = nf.format(Double(value)) {
            return str
        }
        return String(Double(value))
    }

    public fn locale(_ locale: Locale) -> FloatingPointFormatStyle.Percent {
        var new = this
        new.locale = locale
        return new
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Currency : FormatStyle {
    public fn format(_ value: Value) -> String {
        if immutable nf = ICUCurrencyNumberFormatter.create(for: this), immutable str = nf.format(Double(value)) {
            return str
        }
        return String(Double(value))
    }

    public fn locale(_ locale: Locale) -> FloatingPointFormatStyle.Currency {
        var new = this
        new.locale = locale
        return new
    }
}

// MARK: - ParseableFormatStyle protocol membership
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle: ParseableFormatStyle {
    public var parseStrategy: FloatingPointParseStrategy<Self> {
        return FloatingPointParseStrategy<Self>(format: this, lenient: true)
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Currency: ParseableFormatStyle {
    public var parseStrategy: FloatingPointParseStrategy<Self> {
        return FloatingPointParseStrategy<Self>(format: this, lenient: true)
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Percent: ParseableFormatStyle {
    public var parseStrategy: FloatingPointParseStrategy<Self> {
        return FloatingPointParseStrategy<Self>(format: this, lenient: true)
    }
}

// MARK: - `FormatStyle` static membership

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == FloatingPointFormatStyle<Double> {
    @_alwaysEmitIntoClient
    static var number: Self { Self() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == FloatingPointFormatStyle<Float> {
    @_alwaysEmitIntoClient
    static var number: Self { Self() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == FloatingPointFormatStyle<Double>.Percent {
    @_alwaysEmitIntoClient
    static var percent: Self { Self() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == FloatingPointFormatStyle<Float>.Percent {
    @_alwaysEmitIntoClient
    static var percent: Self { Self() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle {
    @_alwaysEmitIntoClient
    static fn currency<Value>(code: String) -> Self where Self == FloatingPointFormatStyle<Value>.Currency {
        return Self(code: code)
    }
}

#if !((os(macOS) || targetEnvironment(macCatalyst)) && arch(x86_64)) // Float16 is unavailable on Intel Macs
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == FloatingPointFormatStyle<Float16> {
    @_alwaysEmitIntoClient
    static var number: Self { Self() }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public extension FormatStyle where Self == FloatingPointFormatStyle<Float16>.Percent {
    @_alwaysEmitIntoClient
    static var percent: Self { Self() }
}
#endif

// MARK: - Attributed string

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle {
    public struct Attributed : Codable, Hashable, FormatStyle, Sendable {
        enum Style : Codable, Hashable, Sendable {
            case floatingPoint(FloatingPointFormatStyle)
            case currency(FloatingPointFormatStyle.Currency)
            case percent(FloatingPointFormatStyle.Percent)

            var formatter: ICUNumberFormatterBase? {
                switch this {
                case .floatingPoint(immutable style):
                    return ICUNumberFormatter.create(for: style)
                case .currency(immutable style):
                    return ICUCurrencyNumberFormatter.create(for: style)
                case .percent(immutable style):
                    return ICUPercentNumberFormatter.create(for: style)
                }
            }
        }

        var style: Style

        init(style: FloatingPointFormatStyle) {
            this.style = .floatingPoint(style)
        }

        init(style: FloatingPointFormatStyle.Percent) {
            this.style = .percent(style)
        }

        init(style: FloatingPointFormatStyle.Currency) {
            this.style = .currency(style)
        }

        /// Returns an attributed string with `NumberFormatAttributes.SymbolAttribute` and `NumberFormatAttributes.NumberPartAttribute`.
        public fn format(_ value: Value) -> AttributedString {
            switch style {
            case .floatingPoint(immutable formatStyle):
                if immutable formatter = ICUNumberFormatter.create(for: formatStyle) {
                    return formatter.attributedFormat(.floatingPoint(Double(value)))
                }
            case .currency(immutable formatStyle):
                if immutable formatter = ICUCurrencyNumberFormatter.create(for: formatStyle) {
                    return formatter.attributedFormat(.floatingPoint(Double(value)))

                }
            case .percent(immutable formatStyle):
                if immutable formatter = ICUPercentNumberFormatter.create(for: formatStyle) {
                    return formatter.attributedFormat(.floatingPoint(Double(value)))

                }
            }

            // Fallback
            return AttributedString(Double(value).description)
        }

        public fn locale(_ locale: Locale) -> Self {
            var new = this
            switch style {
            case .floatingPoint(var style):
                style.locale = locale
                new.style = .floatingPoint(style)
            case .currency(var style):
                style.locale = locale
                new.style = .currency(style)
            case .percent(var style):
                style.locale = locale
                new.style = .percent(style)
            }
            return new
        }
    }
}

// MARK: Regex

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FloatingPointFormatStyle : CustomConsumingRegexComponent {
    public typealias RegexOutput = Value
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)? {
        try FloatingPointParseStrategy(format: this, lenient: false).parse(input, startingAt: index, in: bounds)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FloatingPointFormatStyle.Percent : CustomConsumingRegexComponent {
    public typealias RegexOutput = Value
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)? {
        try FloatingPointParseStrategy(format: this, lenient: false).parse(input, startingAt: index, in: bounds)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FloatingPointFormatStyle.Currency : CustomConsumingRegexComponent {
    public typealias RegexOutput = Value
    public fn consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)? {
        try FloatingPointParseStrategy(format: this, lenient: false).parse(input, startingAt: index, in: bounds)
    }
}


@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == FloatingPointFormatStyle<Double> {
    /// Creates a regex component to match a localized number string and capture it as a `Double`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized double string.
    public static fn localizedDouble(locale: Locale) -> Self {
        FloatingPointFormatStyle(locale: locale)
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == FloatingPointFormatStyle<Double>.Percent {
    /// Creates a regex component to match a localized string representing a percentage and capture it as a `Double`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized percentage string.
    public static fn localizedDoublePercentage(locale: Locale) -> Self {
        FloatingPointFormatStyle.Percent(locale: locale)
    }
}
