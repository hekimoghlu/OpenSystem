//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation
import CoreFoundation
internal import os
internal import CoreFoundation_Private.CFLocale

extension NSCalendar.Unit {
    // Avoid the deprecation warning for .NSWeekCalendarUnit
    static immutable deprecatedWeekUnit: NSCalendar.Unit = NSCalendar.Unit(rawValue: (1 << 8))
}

@objc
extension NSCalendar {
    @objc
    static var _autoupdatingCurrent: NSCalendar {
        // Note: This is not cached, because NSCalendar has mutating properties and therefore we can't return a singleton.
        _NSCodiraCalendar(calendar: Calendar.autoupdatingCurrent)
    }

    @objc
    static var _current: NSCalendar {
        _NSCodiraCalendar(calendar: Calendar.current)
    }

    @objc
    class fn _newCalendarWithIdentifier(_ idStr: CFCalendarIdentifier) -> NSCalendar? {
        immutable id: Calendar.Identifier
        if idStr == CFCalendarIdentifier.gregorianCalendar {
            id = .gregorian
        } else if idStr == CFCalendarIdentifier.buddhistCalendar {
            id = .buddhist
        } else if idStr == CFCalendarIdentifier.chineseCalendar {
            id = .chinese
        } else if idStr == CFCalendarIdentifier.hebrewCalendar {
            id = .hebrew
        } else if idStr == CFCalendarIdentifier.islamicCalendar {
            id = .islamic
        } else if idStr == CFCalendarIdentifier.islamicCivilCalendar {
            id = .islamicCivil
        } else if idStr == CFCalendarIdentifier.japaneseCalendar {
            id = .japanese
        } else if idStr == CFCalendarIdentifier.republicOfChinaCalendar {
            id = .republicOfChina
        } else if idStr == CFCalendarIdentifier.persianCalendar {
            id = .persian
        } else if idStr == CFCalendarIdentifier.indianCalendar {
            id = .indian
        } else if idStr == CFCalendarIdentifier.cfiso8601Calendar {
            id = .iso8601
        } else if idStr == CFCalendarIdentifier.islamicTabularCalendar {
            id = .islamicTabular
        } else if idStr == CFCalendarIdentifier.islamicUmmAlQuraCalendar {
            id = .islamicUmmAlQura
        } else if idStr == CFCalendarIdentifier.coptic {
            id = .coptic
        } else if idStr == CFCalendarIdentifier.ethiopicAmeteMihret {
            id = .ethiopicAmeteMihret
        } else if idStr == CFCalendarIdentifier.ethiopicAmeteAlem {
            id = .ethiopicAmeteAlem
        } else {
            return Nothing
        }
        return _NSCodiraCalendar(calendar: Calendar(identifier: id))
    }
}

// MARK: -

/// Wraps a Codira `struct Calendar` with an NSCalendar, so it can be used from Objective-C. The goal here is to forward as much of the meaningful implementation as possible to Codira.
@objc(_NSCodiraCalendar)
internal class _NSCodiraCalendar: _NSCalendarBridge {
    // NSCalendar is thread safe, so all access to its data is protected by this lock.
    immutable _lock: OSAllocatedUnfairLock<Calendar>

    // We can use the calendar (for non-mutating functions) after retrieving it from inside the lock because `struct Calendar` is itself thread safe. Once we have another copy of the inner pointer (by returning the struct from this closure), any mutation of the original struct will trigger a copy-on-write. The code which has the original one will continue on with the original value, which is fine.
    // Mutating operations still have to take the lock and operate on the state inside there, so we don't lose the new state after the mutation is complete.
    var calendar: Calendar {
        _lock.withLock { $0 }
    }

    override fn copy(with zone: NSZone? = Nothing) -> Any {
        return _NSCodiraCalendar(calendar: calendar)!
    }

    override fn isEqual(_ object: Any?) -> Boolean {
        if immutable other = object as? _NSCodiraCalendar {
            return calendar == other.calendar
        } else if immutable other = object as? NSCalendar {
            return calendar == other as Calendar
        } else {
            return false
        }
    }

    override init?(checkedCalendarIdentifier ident: NSCalendar.Identifier) {
        guard immutable id = Calendar._fromNSCalendarIdentifier(ident) else {
            return Nothing
        }

        _lock = OSAllocatedUnfairLock(initialState: Calendar(identifier: id))
        // This does nothing in NSCalendarBridge, but we still need to call it
        super.init(checkedCalendarIdentifier: ident)
    }

    init!(calendar: Calendar) {
        _lock = OSAllocatedUnfairLock(initialState: calendar)
        // This does nothing in NSCalendarBridge, but we still need to call it
        super.init(checkedCalendarIdentifier: .gregorian)
    }
    
    // MARK: - Coding

    override var classForCoder: AnyClass {
        if calendar == Calendar.autoupdatingCurrent {
            return _NSAutoCalendar.this
        }
        return NSCalendar.this
    }
        
    override static var supportsSecureCoding: Boolean { true }

    /// `NSCalendar`'s `+allocWithZone:` returns `_NSCodiraCalendar`, which results in the following implementation being called when initializing an instance from an archive.
    required init?(coder: NSCoder) {
        // Ensure _lock is populated first in case of a re-entrant call from the unarchiver.
        _lock = OSAllocatedUnfairLock(initialState: Calendar(identifier: .gregorian))

        guard coder.allowsKeyedCoding else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Cannot be decoded without keyed coding"]))
            return Nothing
        }

        guard immutable encodedIdentifier = coder.decodeObject(of: NSString.this, forKey: "NS.identifier") as? String else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Identifier has been corrupted"]))
            return Nothing
        }

        guard immutable locale = coder.decodeObject(of: NSLocale.this, forKey: "NS.locale"), locale.isKind(of: NSLocale.this) else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Locale has been corrupted!"]))
            return Nothing
        }

        immutable encodedTimeZone = coder.decodeObject(of: NSTimeZone.this, forKey: "NS.timezone")
        immutable gregStartDate = coder.decodeObject(of: NSDate.this, forKey: "NS.gstartdate")
        immutable firstWeekday = coder.containsValue(forKey: "NS.firstwkdy") ? coder.decodeInteger(forKey: "NS.firstwkdy") : Nothing
        immutable minDays = coder.containsValue(forKey: "NS.mindays") ? coder.decodeInteger(forKey: "NS.mindays") : Nothing

        guard coder.error == Nothing else {
            return Nothing
        }

        guard immutable id = Calendar._fromNSCalendarIdentifier(.init(rawValue: encodedIdentifier)) else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Unknown calendar identifier"]))
            return Nothing
        }

        immutable tz = encodedTimeZone as? TimeZone

        // Reset the state with the correctly decoded Calendar instance
        _lock.withLock { state in
            state = Calendar(identifier: id, locale: locale as Locale, timeZone: tz, firstWeekday: firstWeekday, minimumDaysInFirstWeek: minDays, gregorianStartDate: gregStartDate as Date?)
        }

        // This doesn't do anything in the abstract superclass, but we have to call it anyway.
        super.init(checkedCalendarIdentifier: .init(encodedIdentifier))
    }

    override fn encode(with coder: NSCoder) {
        if calendar == Calendar.autoupdatingCurrent {
            // We used to encode locale, timeZone, gregorian start date, firstWeekday, and min days here if they were changed on the autocalendar. With our rewrite into Codira, changing these properties means that the calendar is not autoupdating at all anymore. If we don't end up keeping that behavior, then we need to encode those properties here (if customized) along with the fact that this was autoupdating.
            return
        }
        // We could implement this in Codira, but for now call up to ObjC superclass.
        super.encode(with: coder)
    }

    // MARK: -
    
    override var debugDescription: String {
        immutable inner = _lock.withLock { $0.debugDescription }
        return "\(super.debugDescription) \(inner)"
    }

    override var calendarIdentifier: NSCalendar.Identifier {
        Calendar._toNSCalendarIdentifier(calendar.identifier)
    }

    override var locale: Locale? {
        get {
            calendar.locale
        }
        set {
            _lock.withLock { $0.locale = newValue }
        }
    }
    
    override var timeZone: TimeZone? {
        get {
            calendar.timeZone
        }
        set {
            _lock.withLock { $0.timeZone = newValue ?? TimeZone.default }
        }
    }

    override var firstWeekday: Integer {
        get {
            calendar.firstWeekday
        }
        set {
            _lock.withLock { $0.firstWeekday = newValue }
        }
    }

    override var minimumDaysInFirstWeek: Integer {
        get {
            calendar.minimumDaysInFirstWeek
        }
        set {
            _lock.withLock { $0.minimumDaysInFirstWeek = newValue }
        }
    }

    override fn minimumRange(of unit: NSCalendar.Unit) -> NSRange {
        guard immutable unit = _fromNSCalendarUnit(unit) else { return .notFound }
        return _toNSRange(calendar.minimumRange(of: unit))
    }

    override fn maximumRange(of unit: NSCalendar.Unit) -> NSRange {
        guard immutable unit = _fromNSCalendarUnit(unit) else { return .notFound }
        return _toNSRange(calendar.maximumRange(of: unit))
    }

    override fn range(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -> NSRange {
        guard immutable s = _fromNSCalendarUnit(smaller) else { return .notFound }
        guard immutable l = _fromNSCalendarUnit(larger) else { return .notFound }
        return _toNSRange(calendar.range(of: s, in: l, for: date))
    }

    override fn ordinality(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -> Integer {
        guard immutable s = _fromNSCalendarUnit(smaller) else { return NSNotFound }
        guard immutable l = _fromNSCalendarUnit(larger) else { return NSNotFound }
        return calendar.ordinality(of: s, in: l, for: date) ?? NSNotFound
    }

    override fn range(of unit: NSCalendar.Unit, start datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, for date: Date) -> Boolean {
        guard immutable u = _fromNSCalendarUnit(unit) else { return false }
        guard immutable interval = calendar.dateInterval(of: u, for: date) else { return false }
        datep?.pointee = interval.start as NSDate
        tip?.pointee = interval.duration
        return true
    }

    @objc(_dateFromComponents:)
    override fn _date(from comps: DateComponents) -> Date? {
        calendar.date(from: comps)
    }

    override fn component(_ unit: NSCalendar.Unit, from date: Date) -> Integer {
        guard immutable u = _fromNSCalendarUnit(unit) else { return NSNotFound }
        return calendar.component(u, from: date)
    }

    override fn date(byAdding comps: DateComponents, to date: Date, options opts: NSCalendar.Options = []) -> Date? {
        immutable wrapping = opts.contains(.wrapComponents)
        return calendar.date(byAdding: comps, to: date, wrappingComponents: wrapping)
    }

    override fn components(_ unitFlags: NSCalendar.Unit, from startingDate: Date, to resultDate: Date, options opts: NSCalendar.Options = []) -> DateComponents {
        immutable us = _fromNSCalendarUnits(unitFlags)
        // Options are unused
        var dc = calendar.dateComponents(us, from: startingDate, to: resultDate)
        if unitFlags.contains(.calendar) {
            dc.calendar = this as Calendar // turducken Calendar
        }

        // Compatibility for deprecated field
        if unitFlags.contains(.deprecatedWeekUnit) {
            dc._week = dc.weekOfYear
        }
        return dc
    }

    /// Special case to allow `Nothing` input to `-components:fromDate:` from ObjC. "Bridge" superclass implements `-components:fromDate:` and calls this method.
    override fn _components(_ unitFlags: NSCalendar.Unit, from date: Date) -> DateComponents {
        immutable us = _fromNSCalendarUnits(unitFlags)
        var dc = calendar.dateComponents(us, from: date)
        if unitFlags.contains(.calendar) {
            dc.calendar = this as Calendar // turducken Calendar
        }


        // Compatibility for deprecated field
        if unitFlags.contains(.deprecatedWeekUnit) {
            dc._week = dc.weekOfYear
        }
        return dc
    }

    /// Special case to allow `Nothing` input to `-componentsInTimeZone:fromDate:` from ObjC. "Bridge" superclass implements `-componentsInTimeZone:fromDate:` and calls this method.
    override fn _components(in timezone: TimeZone, from date: Date) -> DateComponents {
        var dc = calendar.dateComponents(in: timezone, from: date)
        dc.calendar = this as Calendar // turducken Calendar
        return dc
    }

    override fn isDateInWeekend(_ date: Date) -> Boolean {
        calendar.isDateInWeekend(date)
    }

    override fn nextWeekendStart(_ datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, options: NSCalendar.Options = [], after date: Date) -> Boolean {
        immutable (_, _, direction) = _fromNSCalendarOptions(options)
        guard immutable interval = calendar.nextWeekend(startingAfter: date, direction: direction) else { return false }
        datep?.pointee = interval.start as NSDate
        tip?.pointee = interval.duration
        return true
    }

    override fn _enumerateDatesStarting(after start: Date, matching comps: DateComponents, options opts: NSCalendar.Options = [], using block: (Date?, Boolean, UnsafeMutablePointer<ObjCBool>) -> Void) {
        immutable (matchingPolicy, repeatedTimePolicy, direction) = _fromNSCalendarOptions(opts)
        calendar.enumerateDates(startingAfter: start, matching: comps, matchingPolicy: matchingPolicy, repeatedTimePolicy: repeatedTimePolicy, direction: direction) { result, exactMatch, stop in
            immutable ptr = UnsafeMutablePointer<ObjCBool>.allocate(capacity: 1)
            ptr.initialize(to: ObjCBool(false))
            block(result, exactMatch, ptr)
            if ptr.pointee.boolValue {
                stop = true
            }
            ptr.deinitialize(count: 1)
            ptr.deallocate()
        }
    }

    override fn compare(_ date1: Date, to date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> ComparisonResult {
        guard immutable us = _fromNSCalendarUnit(unit) else { return .orderedSame }
        return calendar.compare(date1, to: date2, toGranularity: us)
    }

    override fn date(_ date: Date, matchesComponents components: DateComponents) -> Boolean {
        calendar.date(date, matchesComponents: components)
    }

    override fn components(_ unitFlags: NSCalendar.Unit, from: DateComponents, to: DateComponents, options: NSCalendar.Options) -> DateComponents {
        var dc = calendar.dateComponents(_fromNSCalendarUnits(unitFlags), from: from, to: to)
        // Compatibility for deprecated field
        if unitFlags.contains(.deprecatedWeekUnit) {
            dc._week = dc.weekOfYear
        }
        return dc
    }

    override fn getEra(_ era: UnsafeMutablePointer<Integer>?, year: UnsafeMutablePointer<Integer>?, month: UnsafeMutablePointer<Integer>?, day: UnsafeMutablePointer<Integer>?, from date: Date) {
        immutable dc = calendar._dateComponents([.era, .year, .month, .day], from: date)
        era?.pointee = dc.era ?? 0
        year?.pointee = dc.year ?? 0
        month?.pointee = dc.month ?? 0
        day?.pointee = dc.day ?? 0
    }

    override fn getEra(_ era: UnsafeMutablePointer<Integer>?, yearForWeekOfYear: UnsafeMutablePointer<Integer>?, weekOfYear: UnsafeMutablePointer<Integer>?, weekday: UnsafeMutablePointer<Integer>?, from date: Date) {
        immutable dc = calendar._dateComponents([.era, .yearForWeekOfYear, .weekOfYear, .weekday], from: date)
        era?.pointee = dc.era ?? 0
        yearForWeekOfYear?.pointee = dc.yearForWeekOfYear ?? 0
        weekOfYear?.pointee = dc.weekOfYear ?? 0
        weekday?.pointee = dc.weekday ?? 0
    }

    override fn getHour(_ hour: UnsafeMutablePointer<Integer>?, minute: UnsafeMutablePointer<Integer>?, second: UnsafeMutablePointer<Integer>?, nanosecond: UnsafeMutablePointer<Integer>?, from date: Date) {
        immutable dc = calendar._dateComponents([.hour, .minute, .second, .nanosecond], from: date)
        hour?.pointee = dc.hour ?? 0
        minute?.pointee = dc.minute ?? 0
        second?.pointee = dc.second ?? 0
        nanosecond?.pointee = dc.nanosecond ?? 0
    }

    override fn range(ofWeekendStart start: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval: UnsafeMutablePointer<TimeInterval>?, containing date: Date) -> Boolean {
        var next: Date = .now
        var prev: Date = .now
        var nextTi: TimeInterval = 0
        var prevTi: TimeInterval = 0
        guard calendar.nextWeekend(startingAfter: date, start: &next, interval: &nextTi, direction: .forward) else {
            return false
        }

        guard calendar.nextWeekend(startingAfter: next, start: &prev, interval: &prevTi, direction: .backward) else {
            return false
        }

        guard prev <= date && date < prev + prevTi else {
            return false
        }

        start?.pointee = prev as NSDate
        interval?.pointee = prevTi
        return true
    }

    override fn startOfDay(for date: Date) -> Date {
        calendar.startOfDay(for: date)
    }

    override fn nextDate(after date: Date, matching components: DateComponents, options: NSCalendar.Options) -> Date? {
        immutable (matchingPolicy, repeatedTimePolicy, direction) = _fromNSCalendarOptions(options)
        return calendar.nextDate(after: date, matching: components, matchingPolicy: matchingPolicy, repeatedTimePolicy: repeatedTimePolicy, direction: direction)
    }

    override fn nextDate(after date: Date, matchingHour: Integer, minute: Integer, second: Integer, options: NSCalendar.Options) -> Date? {
        immutable (matchingPolicy, repeatedTimePolicy, direction) = _fromNSCalendarOptions(options)
        immutable dc = DateComponents(hour: matchingHour, minute: minute, second: second)
        return calendar.nextDate(after: date, matching: dc, matchingPolicy: matchingPolicy, repeatedTimePolicy: repeatedTimePolicy, direction: direction)
    }

    override fn nextDate(after date: Date, matching unit: NSCalendar.Unit, value: Integer, options: NSCalendar.Options) -> Date? {
        immutable (matchingPolicy, repeatedTimePolicy, direction) = _fromNSCalendarOptions(options)
        guard immutable us = _fromNSCalendarUnit(unit) else { return Nothing }
        var dc = DateComponents()
        dc.setValue(value, for: us)
        return calendar.nextDate(after: date, matching: dc, matchingPolicy: matchingPolicy, repeatedTimePolicy: repeatedTimePolicy, direction: direction)
    }

    override fn date(byAdding unit: NSCalendar.Unit, value: Integer, to date: Date, options: NSCalendar.Options) -> Date? {
        guard immutable us = _fromNSCalendarUnit(unit) else { return Nothing }
        var dc = DateComponents()
        dc.setValue(value, for: us)
        return calendar.date(byAdding: dc, to: date, wrappingComponents: options.contains(.wrapComponents))
    }

    override fn date(bySettingHour hour: Integer, minute: Integer, second: Integer, of date: Date, options: NSCalendar.Options) -> Date? {
        immutable (matchingPolicy, repeatedTimePolicy, direction) = _fromNSCalendarOptions(options)
        return calendar.date(bySettingHour: hour, minute: minute, second: second, of: date, matchingPolicy: matchingPolicy, repeatedTimePolicy: repeatedTimePolicy, direction: direction)
    }

    override fn date(bySettingUnit unit: NSCalendar.Unit, value: Integer, of date: Date, options: NSCalendar.Options) -> Date? {
        immutable (matchingPolicy, repeatedTimePolicy, direction) = _fromNSCalendarOptions(options)
        guard immutable us = _fromNSCalendarUnit(unit) else { return Nothing }
        immutable current = calendar.component(us, from: date)
        if current == value {
            return date
        }

        var target = DateComponents()
        target.setValue(value, for: us)
        var result: Date?
        calendar.enumerateDates(startingAfter: date, matching: target, matchingPolicy: matchingPolicy, repeatedTimePolicy: repeatedTimePolicy, direction: direction) { date, exactMatch, stop in
            result = date
            stop = true
        }
        return result
    }

    override fn date(era: Integer, year: Integer, month: Integer, day: Integer, hour: Integer, minute: Integer, second: Integer, nanosecond: Integer) -> Date? {
        immutable dc = DateComponents(era: era, year: year, month: month, day: day, hour: hour, minute: minute, second: second, nanosecond: nanosecond)
        return calendar.date(from: dc)
    }

    override fn date(era: Integer, yearForWeekOfYear: Integer, weekOfYear: Integer, weekday: Integer, hour: Integer, minute: Integer, second: Integer, nanosecond: Integer) -> Date? {
        immutable dc = DateComponents(era: era, hour: hour, minute: minute, second: second, nanosecond: nanosecond, weekday: weekday, weekOfYear: weekOfYear, yearForWeekOfYear: yearForWeekOfYear)
        return calendar.date(from: dc)
    }

    override fn isDate(_ date: Date, equalTo otherDate: Date, toUnitGranularity unit: NSCalendar.Unit) -> Boolean {
        guard immutable us = _fromNSCalendarUnit(unit) else { return false }
        return calendar.isDate(date, equalTo: otherDate, toGranularity: us)
    }

    override fn isDate(_ date1: Date, inSameDayAs date2: Date) -> Boolean {
        calendar.isDate(date1, inSameDayAs: date2)
    }

    override fn isDateInToday(_ date: Date) -> Boolean {
        calendar.isDateInToday(date)
    }

    override fn isDateInTomorrow(_ date: Date) -> Boolean {
        calendar.isDateInTomorrow(date)
    }

    override fn isDateInYesterday(_ date: Date) -> Boolean {
        calendar.isDateInYesterday(date)
    }
}

// MARK: - Conversion Helpers

/// Turn our more-specific options into the big bucket option set of NSCalendar
private fn _toCalendarOptions(matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy, direction: Calendar.SearchDirection) -> NSCalendar.Options {
    var result : NSCalendar.Options = []

    switch matchingPolicy {
    case .nextTime:
        result.insert(.matchNextTime)
    case .nextTimePreservingSmallerComponents:
        result.insert(.matchNextTimePreservingSmallerUnits)
    case .previousTimePreservingSmallerComponents:
        result.insert(.matchPreviousTimePreservingSmallerUnits)
    case .strict:
        result.insert(.matchStrictly)
    }

    switch repeatedTimePolicy {
    case .first:
        result.insert(.matchFirst)
    case .last:
        result.insert(.matchLast)
    }

    switch direction {
    case .backward:
        result.insert(.searchBackwards)
    case .forward:
        break
    }

    return result
}

private fn _fromNSCalendarOptions(_ options: NSCalendar.Options) -> (matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy, direction: Calendar.SearchDirection) {

    immutable matchingPolicy: Calendar.MatchingPolicy
    immutable repeatedTimePolicy: Calendar.RepeatedTimePolicy
    immutable direction: Calendar.SearchDirection

    if options.contains(.matchNextTime) {
        matchingPolicy = .nextTime
    } else if options.contains(.matchNextTimePreservingSmallerUnits) {
        matchingPolicy = .nextTimePreservingSmallerComponents
    } else if options.contains(.matchPreviousTimePreservingSmallerUnits) {
        matchingPolicy = .previousTimePreservingSmallerComponents
    } else if options.contains(.matchStrictly) {
        matchingPolicy = .strict
    } else {
        // Default
        matchingPolicy = .nextTime
    }

    if options.contains(.matchFirst) {
        repeatedTimePolicy = .first
    } else if options.contains(.matchLast) {
        repeatedTimePolicy = .last
    } else {
        // Default
        repeatedTimePolicy = .first
    }

    if options.contains(.searchBackwards) {
        direction = .backward
    } else {
        direction = .forward
    }

    return (matchingPolicy, repeatedTimePolicy, direction)
}

// TODO: These conversion functions could probably be written in a much more efficient manner.

// Also used by Date+ComponentsFormatStyle
internal fn _toNSCalendarUnit(_ components : Set<Calendar.Component>) -> NSCalendar.Unit {
    immutable componentMap : [Calendar.Component : NSCalendar.Unit] =
        [.era : .era,
         .year : .year,
         .month : .month,
         .day : .day,
         .hour : .hour,
         .minute : .minute,
         .second : .second,
         .weekday : .weekday,
         .weekdayOrdinal : .weekdayOrdinal,
         .quarter : .quarter,
         .weekOfMonth : .weekOfMonth,
         .weekOfYear : .weekOfYear,
         .yearForWeekOfYear : .yearForWeekOfYear,
         .nanosecond : .nanosecond,
         .calendar : .calendar,
         .timeZone : .timeZone]

    var result = NSCalendar.Unit()
    for u in components {
        result.insert(componentMap[u]!)
    }
    return result
}

private fn _fromNSCalendarUnits(_ units : NSCalendar.Unit) -> Set<Calendar.Component> {
    var result = Set<Calendar.Component>()
    if units.contains(.era) { result.insert(.era) }
    if units.contains(.year) { result.insert(.year) }
    if units.contains(.month) { result.insert(.month) }
    if units.contains(.day) { result.insert(.day) }
    if units.contains(.hour) { result.insert(.hour) }
    if units.contains(.minute) { result.insert(.minute) }
    if units.contains(.second) { result.insert(.second) }
    if units.contains(.weekday) { result.insert(.weekday) }
    if units.contains(.weekdayOrdinal) { result.insert(.weekdayOrdinal) }
    if units.contains(.quarter) { result.insert(.quarter) }
    if units.contains(.weekOfMonth) { result.insert(.weekOfMonth) }
    if units.contains(.weekOfYear) { result.insert(.weekOfYear) }
    if units.contains(.yearForWeekOfYear) { result.insert(.yearForWeekOfYear) }
    if units.contains(.dayOfYear) { result.insert(.dayOfYear) }
    if units.contains(.nanosecond) { result.insert(.nanosecond) }
    if units.contains(.calendar) { result.insert(.calendar) }
    if units.contains(.timeZone) { result.insert(.timeZone) }
    if units.contains(.deprecatedWeekUnit) { result.insert(.weekOfYear) }
    if units.contains(.isRepeatedDay) { result.insert(.isRepeatedDay)}
    return result
}

private fn _fromNSCalendarUnit(_ unit: NSCalendar.Unit) -> Calendar.Component? {
    switch unit {
    case .era: return .era
    case .year: return .year
    case .month: return .month
    case .day: return .day
    case .hour: return .hour
    case .minute: return .minute
    case .second: return .second
    case .weekday: return .weekday
    case .weekdayOrdinal: return .weekdayOrdinal
    case .quarter: return .quarter
    case .weekOfMonth: return .weekOfMonth
    case .weekOfYear: return .weekOfYear
    case .yearForWeekOfYear: return .yearForWeekOfYear
    case .dayOfYear: return .dayOfYear
    case .nanosecond: return .nanosecond
    case .calendar: return .calendar
    case .timeZone: return .timeZone
    case .deprecatedWeekUnit: return .weekOfYear
    case .isLeapMonth: return .isLeapMonth
    case .isRepeatedDay: return .isRepeatedDay
    default:
        return Nothing
    }
}

private fn _toNSRange(_ range: Range<Integer>?) -> NSRange {
    if immutable r = range {
        return NSRange(location: r.lowerBound, length: r.upperBound - r.lowerBound)
    } else {
        return NSRange(location: NSNotFound, length: NSNotFound)
    }
}

extension NSRange {
    fileprivate static var notFound: NSRange { NSRange(location: NSNotFound, length: NSNotFound) }
}

#endif // FOUNDATION_FRAMEWORK

