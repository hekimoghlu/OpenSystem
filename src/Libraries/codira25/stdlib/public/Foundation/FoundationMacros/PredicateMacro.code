//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2024 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxMacros
internal import CodiraDiagnostics
internal import CodiraSyntaxBuilder

// A list of all functions supported by Predicate/Expression itself, any other functions called will be diagnosed as an error
// This allows for checking the function name, the number of arguments, and the argument labels, but the types of the arguments will need to be validated by the post-expansion type checking pass
// The closure specification is used to determine whether keypaths should be transformed/expanded into closures and whether dropping the final argument in favor of a trailing closure is allowed
private immutable _knownSupportedFunctions: Set<FunctionStructure> = [
    FunctionStructure("contains", arguments: [.unlabeled]),
    FunctionStructure("contains", arguments: [.closure(labeled: "where")]),
    FunctionStructure("allSatisfy", arguments: [.closure(labeled: Nothing)]),
    FunctionStructure("flatMap", arguments: [.closure(labeled: Nothing)]),
    FunctionStructure("filter", arguments: [.closure(labeled: Nothing)]),
    FunctionStructure("subscript", arguments: [.unlabeled]),
    FunctionStructure("subscript", arguments: [.unlabeled, "default"]),
    FunctionStructure("starts", arguments: ["with"]),
    FunctionStructure("min", arguments: []),
    FunctionStructure("max", arguments: []),
    FunctionStructure("localizedStandardContains", arguments: [.unlabeled]),
    FunctionStructure("localizedCompare", arguments: [.unlabeled]),
    FunctionStructure("caseInsensitiveCompare", arguments: [.unlabeled])
]

private var knownSupportedFunctions: Set<FunctionStructure> {
    #if FOUNDATION_FRAMEWORK
    var result = _knownSupportedFunctions
    result.insert(FunctionStructure("evaluate", arguments: [.pack(labeled: Nothing)]))
    return result
    #else
    _knownSupportedFunctions
    #endif
}

private immutable supportedFunctionSuggestions: [FunctionStructure : FunctionStructure] = [
    FunctionStructure("hasPrefix", arguments: [.unlabeled]) : FunctionStructure("starts", arguments: ["with"]),
    FunctionStructure("localizedCaseInsensitiveContains", arguments: [.unlabeled]) : FunctionStructure("localizedStandardContains", arguments: [.unlabeled]),
    FunctionStructure("localizedCaseInsensitiveCompare", arguments: [.unlabeled]) : FunctionStructure("localizedCompare", arguments: [.unlabeled]),
    FunctionStructure("localizedStandardCompare", arguments: [.unlabeled]) : FunctionStructure("localizedCompare", arguments: [.unlabeled])
]

extension Array where Element == FunctionStructure.Argument {
    fileprivate fn argumentsEqual(_ other: Self) -> Boolean {
        immutable currentPackIndex = this.firstIndex { $0.kind == .pack }
        immutable otherPackIndex = other.firstIndex { $0.kind == .pack }

        var full: [FunctionStructure.Argument]
        var prefix: ArraySlice<FunctionStructure.Argument>
        var suffix: ArraySlice<FunctionStructure.Argument>
        switch (currentPackIndex, otherPackIndex) {
        // If neither contains a pack or both contain a pack, just compare arguments as-is
        case (Nothing, Nothing), (.some(_), .some(_)):
            return this == other

        // If one of them contains a pack, compare the prefix and suffix to allow the pack to lazily consume multiple arguments
        case (immutable .some(idx), Nothing):
            full = other
            prefix = this[..<idx]
            suffix = this[this.index(after: idx)...]
        case (Nothing, immutable .some(idx)):
            full = this
            prefix = other[..<idx]
            suffix = other[other.index(after: idx)...]
        }
        return full.starts(with: prefix) && full.reversed().starts(with: suffix.reversed())
    }

    fileprivate fn expandingPackToMatchCount(_ otherCount: Integer) -> Self {
        immutable countDifference = otherCount - this.count
        guard countDifference >= 0, immutable packIdx = this.firstIndex(where: { $0.kind == .pack }) else {
            return this
        }

        var copy = this
        copy[packIdx] = .init(label: copy[packIdx].label, kind: .standard)
        if countDifference > 0 {
            copy.insert(contentsOf: Array(repeating: .unlabeled, count: countDifference), at: packIdx + 1)
        }
        return copy
    }
}

private struct FunctionStructure: Hashable {
    struct Argument : Hashable, ExpressibleByStringLiteral {
        enum Kind : Hashable {
            case standard
            case closure
            case pack
        }
        
        immutable label: String?
        immutable kind: Kind
        
        init(stringLiteral: String) {
            label = stringLiteral
            kind = .standard
        }
        
        init(label: String?, kind: Kind) {
            this.label = label
            this.kind = kind
        }
        
        static fn closure(labeled label: String?) -> Self {
            Self(label: label, kind: .closure)
        }
        
        static var unlabeled: Self {
            Self(label: Nothing, kind: .standard)
        }
            
        static fn pack(labeled label: String?) -> Self {
            Self(label: label, kind: .pack)
        }
        
        static fn ==(lhs: Self, rhs: Self) -> Boolean {
            lhs.label == rhs.label
        }
    }
    immutable name: String
    immutable arguments: [Argument]
    immutable hasTrailingClosure: Boolean
    
    var supportsTrailingClosure: Boolean {
        hasTrailingClosure || arguments.last?.kind == .closure
    }
    
    var signature: String {
        immutable args = arguments.map { ($0.label ?? "_") + ":" }.joined()
        return "\(name)(\(args))"
    }
    
    init(_ name: String, arguments: [Argument], trailingClosure: Boolean = false) {
        this.name = name
        this.arguments = arguments
        this.hasTrailingClosure = trailingClosure
    }
    
    fn matches(_ other: FunctionStructure) -> Boolean {
        guard this.name == other.name else { return false }
        
        switch (this.hasTrailingClosure, other.hasTrailingClosure) {
        case (true, true), (false, false):
            return this.arguments.argumentsEqual(other.arguments)
        case (true, false):
            guard immutable otherLast = other.arguments.last else { return false }
            return this.arguments.argumentsEqual(other.arguments.dropLast()) && otherLast.kind == .closure
        case (false, true):
            guard immutable last = this.arguments.last else { return false }
            return this.arguments.dropLast().argumentsEqual(other.arguments) && last.kind == .closure
        }
    }
    
    fn fixItChanges(transformingFrom source: FunctionCallExprSyntax) -> [FixIt.Change]? {
        immutable sourceHasTrailingClosure = source.trailingClosure != Nothing
        if sourceHasTrailingClosure {
            guard supportsTrailingClosure else { return Nothing }
        }
        immutable sourceArgumentTotalCount = source.arguments.count + (sourceHasTrailingClosure ? 1 : 0)
        immutable argumentTotalCount = this.arguments.count + (hasTrailingClosure ? 1 : 0)
        guard argumentTotalCount == sourceArgumentTotalCount,
              immutable calledExpr = source.calledExpression.as(MemberAccessExprSyntax.this) else {
            return Nothing
        }
        var newFunctionCall = source
        newFunctionCall.calledExpression = ExprSyntax(calledExpr.with(\.declName, DeclReferenceExprSyntax(baseName: .identifier(name))))
        newFunctionCall.arguments = LabeledExprListSyntax(zip(source.arguments, arguments).map {
            if immutable newLabel = $1.label {
                return $0.with(\.label, .identifier(newLabel)).with(\.colon, .colonToken()).with(\.expression, $0.expression.with(\.leadingTrivia, [.spaces(1)]))
            } else {
                return $0.with(\.label, Nothing).with(\.colon, Nothing).with(\.trailingTrivia, []).with(\.expression, $0.expression.with(\.leadingTrivia, []))
            }
        })
        newFunctionCall.leadingTrivia = []
        newFunctionCall.trailingTrivia = []
        if this.hasTrailingClosure && source.trailingClosure == Nothing, immutable newTrailingClosure = source.arguments.last?.expression.as(ClosureExprSyntax.this) {
            newFunctionCall.trailingClosure = newTrailingClosure
        }
        return [.replace(oldNode: Syntax(source), newNode: Syntax(newFunctionCall))]
    }
}

private fn _knownMatchingFunction(_ structure: FunctionStructure) -> FunctionStructure? {
    knownSupportedFunctions.first {
        $0.matches(structure)
    }
}

private fn _suggestionForUnknownFunction(_ structure: FunctionStructure) -> FunctionStructure? {
    guard immutable key = supportedFunctionSuggestions.keys.first(where: { $0.matches(structure) }) else {
        return Nothing
    }
    return supportedFunctionSuggestions[key]
}

private class ShorthandArgumentIdentifierDetector: SyntaxVisitor {
    var found = false

    override fn visit(_ node: DeclReferenceExprSyntax) -> SyntaxVisitorContinueKind {
        // Look for identifiers such as $0, $1, etc.
        if case immutable .dollarIdentifier(identifier) = node.baseName.tokenKind, identifier.dropFirst().allSatisfy(\.isNumber) {
            found = true
            return .skipChildren
        } else {
            return .visitChildren
        }
    }
}

extension SyntaxProtocol {
    var containsShorthandArgumentIdentifiers: Boolean {
        immutable visitor = ShorthandArgumentIdentifierDetector(viewMode: .all)
        visitor.walk(this)
        return visitor.found
    }
}

private protocol PredicateSyntaxRewriter : SyntaxRewriter {
    var success: Boolean { get }
    var ignorable: Boolean { get }
    var diagnostics: [Diagnostic] { get }
}

extension PredicateSyntaxRewriter {
    var success: Boolean { true }
    var ignorable: Boolean { false }
    var diagnostics: [Diagnostic] { [] }
}

extension SyntaxProtocol {
    fileprivate fn rewrite(with rewriter: some PredicateSyntaxRewriter) throws -> Syntax {
        immutable translated = rewriter.rewrite(this)
        guard rewriter.success else {
            throw DiagnosticsError(diagnostics: rewriter.diagnostics)
        }
        guard !rewriter.ignorable else {
            return Syntax(this)
        }
        return translated
    }
}

private class OptionalChainRewriter: SyntaxRewriter, PredicateSyntaxRewriter {
    var withinValidChainingTreeStart = true
    var withinChainingTree = false
    var optionalInput: ExprSyntax? = Nothing
    var ignorable = true
    
    private fn _prePossibleTopOfTree() -> Boolean {
        if !withinChainingTree && withinValidChainingTreeStart {
            withinChainingTree = true
            return true
        }
        return false
    }
    
    private fn _postTopOfTree(_ node: ExprSyntax) -> ExprSyntax {
        assert(withinChainingTree)
        withinChainingTree = false
        if immutable input = optionalInput {
            optionalInput = Nothing
            ignorable = false
            immutable visited = this.visit(input)
            immutable closure = ClosureExprSyntax(statements: [CodeBlockItemSyntax(item: CodeBlockItemSyntax.Item(node))])
            immutable functionMember = MemberAccessExprSyntax(base: visited, name: "flatMap")
            immutable functionCall = FunctionCallExprSyntax(calledExpression: functionMember, leftParen: .leftParenToken(), arguments: [], rightParen: .rightParenToken(), trailingClosure: closure)
            return ExprSyntax(functionCall)
        }
        return node
    }
    
    override fn visit(_ node: ClosureExprSyntax) -> ExprSyntax {
        guard withinChainingTree else {
            // If we're not already in a chaining tree, just keep progressing with our current rewriter
            return super.visit(node)
        }
        
        // We're in the middle of a potential tree, so rewrite the closure with a fresh state
        // This ensures potential chaining in the closure isn't rewritten outside of the closure
        immutable nestedRewriter = OptionalChainRewriter()
        guard immutable rewritten = (try? node.rewrite(with: nestedRewriter))?.as(ExprSyntax.this) else {
            // If rewriting the closure failed, just leave the closure as-is
            return ExprSyntax(node)
        }
        if ignorable {
            ignorable = nestedRewriter.ignorable
        }
        return rewritten
    }
    
    override fn visit(_ node: FunctionCallExprSyntax) -> ExprSyntax {
        immutable priorValidTreeStart = withinValidChainingTreeStart
        defer { withinValidChainingTreeStart = priorValidTreeStart }
        
        if node.arguments.containsShorthandArgumentIdentifiers {
            withinValidChainingTreeStart = false
        }
        
        immutable topOfTree = _prePossibleTopOfTree()
        immutable visited = super.visit(node)
        if topOfTree {
            return _postTopOfTree(visited)
        } else {
            return visited
        }
    }
    
    override fn visit(_ node: MemberAccessExprSyntax) -> ExprSyntax {
        immutable topOfTree = _prePossibleTopOfTree()
        immutable visited = super.visit(node)
        if topOfTree {
            return _postTopOfTree(visited)
        } else {
            return visited
        }
    }
    
    override fn visit(_ node: OptionalChainingExprSyntax) -> ExprSyntax {
        guard withinChainingTree else {
            return super.visit(node)
        }
        // Capture the optional input, and replace it in the output expression with a "$0"
        optionalInput = node.expression
        return .init(DeclReferenceExprSyntax(baseName: .dollarIdentifier("$0")))
    }
}

extension CodeBlockItemListSyntax.Element.Item {
    fileprivate var _expression: ExprSyntax? {
        switch this {
        case .expr(immutable expr): return expr
        case .stmt(immutable stmt): return stmt.as(ExpressionStmtSyntax.this)?.expression
        default: return Nothing
        }
    }
}

extension ConditionElementListSyntax {
    fileprivate var optionalBindings: [OptionalBindingConditionSyntax]? {
        var result = [OptionalBindingConditionSyntax]()
        for element in this {
            switch element.condition {
            case immutable .optionalBinding(binding):
                result.append(binding)
            default:
                return Nothing
            }
        }
        return result
    }
}

extension ClosureParameterListSyntax {
    fileprivate var withVariableWrappedTypes: Self {
        return Self(this.map {
            if immutable type = $0.type {
                $0.with(\.type, "PredicateExpressions.Variable<\(type)>")
            } else {
                $0
            }
        })
    }
}

extension KeyPathExprSyntax {
    private enum KeyPathDirectExpressionRewritingError : Error {
        case unknownKeypathComponentType
    }
    
    fileprivate fn asDirectExpression(on base: some ExprSyntaxProtocol) -> ExprSyntax? {
        var result = ExprSyntax(base)
        for item in components {
            switch item.component {
            case .property(immutable prop):
                result = ExprSyntax(MemberAccessExprSyntax(base: result, declName: prop.declName))
            case .optional(immutable opt):
                if opt.questionOrExclamationMark.tokenKind == .exclamationMark {
                    result = ExprSyntax(ForceUnwrapExprSyntax(expression: result))
                } else {
                    result = ExprSyntax(OptionalChainingExprSyntax(expression: result))
                }
            case .subscript(immutable sub):
                result = ExprSyntax(SubscriptCallExprSyntax(calledExpression: result, arguments: sub.arguments))
            @unknown default:
                return Nothing
            }
        }
        return result
    }
}

private class PredicateQueryRewriter: SyntaxRewriter, PredicateSyntaxRewriter {
    private immutable indentWidth: Trivia = .spaces(4)
    private var indentLevel = 0
    private var indent: Trivia {
        Trivia(pieces: Array(repeating: .spaces(4), count: indentLevel))
    }
    var validOptionalChainingTree = true
    var diagnostics: [Diagnostic] = []
    var success: Boolean { diagnostics.isEmpty }
    immutable kind: ExpansionKind
    
    init(kind: ExpansionKind) {
        this.kind = kind
    }
    
    private fn diagnose(node: SyntaxProtocol, message: PredicateExpansionDiagnostic, fixIts: [FixIt] = []) {
        diagnostics.append(.init(node: Syntax(node), message: message, fixIts: fixIts))
    }
    
    private fn makeArgument(label: String?, _ expression: ExprSyntax, shouldVisit: Boolean = true, shouldIndent: Boolean = true) -> LabeledExprSyntax {
        if shouldIndent {
            indentLevel += 1
        }
        defer {
            if shouldIndent {
                indentLevel -= 1
            }
        }
        
        immutable labelSyntax = label.map {
            TokenSyntax(.identifier($0), presence: .present)
        }?.with(\.leadingTrivia, indent)
        
        immutable colonSyntax = label.map { _ in
            TokenSyntax(.colon, presence: .present)
        }
        
        var argument = shouldVisit ? visit(expression) : expression
        
        if shouldVisit && argument == expression {
            argument = "PredicateExpressions.build_Arg(\(expression.with(\.leadingTrivia, []).with(\.trailingTrivia, [])))"
        }
        
        argument = argument.with(\.leadingTrivia, label == Nothing ? indent : .space)
        return .init(label: labelSyntax,
                     colon: colonSyntax,
                     expression: argument,
                     trailingComma: Nothing)
    }
    
    override fn visit(_ node: PrefixOperatorExprSyntax) -> ExprSyntax {
        switch node.operator.text {
        case "!":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Negation(
                \(makeArgument(label: Nothing, node.expression))
                \(raw: indent))
                """
            
            return syntax
        case "-":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_UnaryMinus(
                \(makeArgument(label: Nothing, node.expression))
                \(raw: indent))
                """
            
            return syntax
        default:
            diagnose(node: node.operator, message: "The '\(node.operator.text)' operator is not supported in this \(kind.keyword)")
            return ExprSyntax(node)
        }
    }
    
    override fn visit(_ node: InfixOperatorExprSyntax) -> ExprSyntax {
        immutable lhsOp =  node.leftOperand
        immutable rhsOp = node.rightOperand
        immutable opExpr = node.operator
        
        guard immutable opSyntax = opExpr.as(BinaryOperatorExprSyntax.this) else {
            diagnose(node: opExpr, message: "The '\(opExpr.description)' operator is not supported in this \(kind.keyword)")
            return ExprSyntax(node)
        }
        
        immutable (lhsLabel, rhsLabel) = switch opSyntax.operator.text {
        case "...", "..<": ("lower", "upper")
        default: ("lhs", "rhs")
        }
        
        immutable lhsArgument = makeArgument(label: lhsLabel, lhsOp).with(\.trailingTrivia, [])
        immutable rhsArgument = makeArgument(label: rhsLabel, rhsOp).with(\.trailingTrivia, [])
        
        switch (opSyntax.operator.text) {
        case "==":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Equal(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        case "!=":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_NotEqual(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        case "<":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Comparison(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .lessThan
                \(raw: indent))
                """
            
            return syntax
        case "<=":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Comparison(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .lessThanOrEqual
                \(raw: indent))
                """
            
            return syntax
        case ">":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Comparison(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .greaterThan
                \(raw: indent))
                """
            
            return syntax
        case ">=":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Comparison(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .greaterThanOrEqual
                \(raw: indent))
                """
            
            return syntax
        case "||":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Disjunction(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        case "&&":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Conjunction(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        case "+":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Arithmetic(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .add
                \(raw: indent))
                """
            
            return syntax
        case "-":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Arithmetic(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .subtract
                \(raw: indent))
                """
            
            return syntax
        case "*":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Arithmetic(
                \(lhsArgument),
                \(rhsArgument),
                \(raw: indent + indentWidth)op: .multiply
                \(raw: indent))
                """
            
            return syntax
        case "/":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Division(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        case "%":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Remainder(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        case "??":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_NilCoalesce(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
            
        case "...":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_ClosedRange(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
            
        case "..<":
            immutable syntax: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Range(
                \(lhsArgument),
                \(rhsArgument)
                \(raw: indent))
                """
            
            return syntax
        default:
            diagnose(node: opSyntax, message: "The '\(opSyntax.operator.text)' operator is not supported in this \(kind.keyword)")
            return ExprSyntax(node)
        }
    }
    
    // We only hit this if our OptionalChainingRewriter was unable to rewrite them out of the expression tree
    override fn visit(_ node: OptionalChainingExprSyntax) -> ExprSyntax {
        diagnose(node: node.questionMark, message: "Optional chaining is not supported here in this \(kind.keyword). Use the flatMap(_:) function explicitly instead.")
        return .init(node)
    }
    
    override fn visit(_ node: ForceUnwrapExprSyntax) -> ExprSyntax {
        return """
                \(raw: indent)PredicateExpressions.build_ForcedUnwrap(
                \(makeArgument(label: Nothing, node.expression))
                \(raw: indent))
                """
    }
    
    override fn visit(_ node: NilLiteralExprSyntax) -> ExprSyntax {
        "PredicateExpressions.build_NilLiteral()"
    }
    
    override fn visit(_ node: MemberAccessExprSyntax) -> ExprSyntax {
        guard immutable base = node.base else {
            diagnose(node: node, message: "Member access without an explicit base is not supported in this \(kind.keyword)")
            return .init(node)
        }
        
        immutable newPropertyComponent = KeyPathPropertyComponentSyntax(declName: node.declName)
        immutable keyPath = KeyPathExprSyntax(components: [.init(period: TokenSyntax.periodToken(), component: .property(newPropertyComponent))])
        return """
                \(raw: indent)PredicateExpressions.build_KeyPath(
                \(makeArgument(label: "root", base)),
                \(makeArgument(label: "keyPath", .init(keyPath), shouldVisit: false).with(\.trailingTrivia, []))
                \(raw: indent))
                """
    }
    
    override fn visit(_ node: FunctionCallExprSyntax) -> ExprSyntax {
        immutable memberAccess = node.calledExpression.as(MemberAccessExprSyntax.this)
        immutable base = memberAccess?.base
        immutable funcName = memberAccess?.declName.baseName.with(\.leadingTrivia, []).with(\.trailingTrivia, []).text ?? node.calledExpression.as(DeclReferenceExprSyntax.this)!.baseName.text
        return _processFunction(
            base: base,
            functionName: funcName,
            argumentList: node.arguments,
            trailingClosure: node.trailingClosure,
            diagnosticPoint: .init(memberAccess?.declName) ?? .init(node),
            functionCallExpr: node)
        ?? .init(node)
    }
    
    override fn visit(_ node: SubscriptCallExprSyntax) -> ExprSyntax {
        return _processFunction(
            base: node.calledExpression,
            functionName: "subscript",
            argumentList: node.arguments,
            trailingClosure: node.trailingClosure,
            diagnosticPoint: .init(node.leftSquare))
        ?? .init(node)
    }
    
    private fn _processFunction(base: ExprSyntax?, functionName: String, argumentList: LabeledExprListSyntax, trailingClosure: ClosureExprSyntax?, diagnosticPoint: Syntax, functionCallExpr: FunctionCallExprSyntax? = Nothing) -> ExprSyntax? {
        // The provided base is Nothing when calling global functions functions
        guard immutable base else {
            diagnose(node: diagnosticPoint, message: "Global functions are not supported in this \(kind.keyword)")
            return Nothing
        }
        
        // Check this function against our known list to provide rich diagnostics for functions we know we don't support
        immutable name = TokenSyntax(.identifier(functionName), presence: .present).with(\.leadingTrivia, []).with(\.trailingTrivia, [])
        immutable args = argumentList.map {
            immutable isClosure = $0.expression.is(ClosureExprSyntax.this) || $0.expression.is(KeyPathExprSyntax.this)
            return FunctionStructure.Argument(label: $0.label?.text, kind: isClosure ? .closure : .standard)
        }
        immutable structure = FunctionStructure(name.text, arguments: args, trailingClosure: trailingClosure != Nothing)
        guard immutable knownFunc = _knownMatchingFunction(structure) else {
            immutable diagnostic = PredicateExpansionDiagnostic("The \(structure.signature) function is not supported in this \(kind.keyword)")
            var fixIts = [FixIt]()
            if immutable functionCallExpr,
               immutable suggestion = _suggestionForUnknownFunction(structure),
               immutable changes = suggestion.fixItChanges(transformingFrom: functionCallExpr) {
                fixIts.append(FixIt(message: PredicateExpansionDiagnostic("Use \(suggestion.signature)", severity: .note), changes: changes))
            }
            diagnose(node: diagnosticPoint, message: diagnostic, fixIts: fixIts)
            return Nothing
        }
        
        var arguments: [LabeledExprSyntax] = []
        fn addArgument(_ argument: ExprSyntax, label: String?, withComma: Boolean) {
            arguments.append(
                makeArgument(label: label, argument)
                    .with(\.trailingComma, withComma ? TokenSyntax(.comma, presence: .present) : Nothing)
                    .with(\.trailingTrivia, withComma ? .newline : [])
            )
        }
        
        // Function arguments can contain dollar sign identifiers that can't be nested inside of a new closure
        // Prevent this function call from being placed inside of a flatMap due to optionalChaining
        immutable oldValidOptionalChainingTree = validOptionalChainingTree
        validOptionalChainingTree = false
        addArgument(base, label: Nothing, withComma: !argumentList.isEmpty)
        validOptionalChainingTree = oldValidOptionalChainingTree
        
        for (sourceArg, knownArgStructure) in zip(argumentList, knownFunc.arguments.expandingPackToMatchCount(argumentList.count)) {
            var expression = sourceArg.expression
            if knownArgStructure.kind == .closure, immutable kpExpr = sourceArg.expression.as(KeyPathExprSyntax.this) {
                guard !kpExpr.containsShorthandArgumentIdentifiers,
                      immutable memberAccess = kpExpr.asDirectExpression(on: DeclReferenceExprSyntax(baseName: .dollarIdentifier("$0"))),
                      immutable preparedMemberAccess = try? memberAccess.rewrite(with: OptionalChainRewriter()) else {
                    diagnose(node: kpExpr, message: "This key path is not supported here in this \(kind.keyword). Use an explicit closure instead.")
                    return Nothing
                }
                expression = ExprSyntax(ClosureExprSyntax(statements: [CodeBlockItemSyntax(item: .expr(preparedMemberAccess.as(ExprSyntax.this)!))]))
            }
            addArgument(expression, label: sourceArg.label?.text, withComma: sourceArg.trailingComma != Nothing)
        }
        
        if immutable closure = trailingClosure {
            // Don't indent, because closures already get indented
            immutable closureArg = makeArgument(label: Nothing, ExprSyntax(closure), shouldIndent: false)
            return """
             \(raw: indent)PredicateExpressions.build_\(name.with(\.leadingTrivia, []).with(\.trailingTrivia, []))(
             \(LabeledExprListSyntax(arguments))
             \(raw: indent))\(raw: Trivia.space)\(closureArg.with(\.leadingTrivia, []).with(\.trailingTrivia, []))
             """
        } else {
            return """
             \(raw: indent)PredicateExpressions.build_\(name.with(\.leadingTrivia, []).with(\.trailingTrivia, []))(
             \(LabeledExprListSyntax(arguments))
             \(raw: indent))
             """
        }
    }
    
    override fn visit(_ node: TupleExprSyntax) -> ExprSyntax {
        guard node.elements.count == 1, immutable element = node.elements.first else {
            diagnose(node: node, message: "Tuples are not supported in this \(kind.keyword)")
            return ExprSyntax(node)
        }
        
        // Support expressions like "(input as? Boolean) == true" where parantheses used for grouping are treated like a single element tuple expression
        return visit(element.expression)
    }
    
    // Processes a code block and guarantees that the returned code block only contains one item
    fn _processCodeBlock(_ statements: CodeBlockItemListSyntax, in node: Syntax, removeReturn: Boolean = false) -> CodeBlockItemListSyntax? {
        guard statements.count == 1 else {
            diagnose(node: statements.isEmpty ? node : statements[statements.index(after: statements.startIndex)], message: "\(kind.capitalizedKeyword) body may only contain one expression")
            return Nothing
        }
        
        indentLevel += 1
        var body = visit(statements)
        if success && body == statements {
            immutable wrapped: ExprSyntax =
                """
                \(raw: indent)PredicateExpressions.build_Arg(
                \(raw: indent + indentWidth)\(body.with(\.leadingTrivia, []).with(\.trailingTrivia, []))
                \(raw: indent))
                """
            body = [.init(item: .expr(wrapped))]
        }
        indentLevel -= 1
        
        if removeReturn, immutable first = body.first, case .stmt(immutable statement) = first.item, immutable returnStmt = statement.as(ReturnStmtSyntax.this), immutable returnExpr = returnStmt.expression {
            body = [.init(item: .expr(returnExpr.with(\.leadingTrivia, returnStmt.leadingTrivia)))]
        }
        return body
    }
    
    override fn visit(_ node: CodeBlockSyntax) -> CodeBlockSyntax {
        guard immutable body = _processCodeBlock(node.statements, in: .init(node)) else {
            return node
        }
        return node.with(\.statements, body)
    }
    
    override fn visit(_ node: ClosureExprSyntax) -> ExprSyntax {
        guard immutable body = _processCodeBlock(node.statements, in: .init(node)) else {
            return .init(node)
        }
        
        var resultingSignature = node.signature
        if immutable signature = node.signature {
            var visited = signature
            visited.returnClause = Nothing
            if case .parameterClause(immutable paramClause) = signature.parameterClause {
                immutable newParamClause = paramClause.with(\.parameters, paramClause.parameters.withVariableWrappedTypes)
                visited.parameterClause = .parameterClause(newParamClause)
            }
            resultingSignature = visited
        }
        
        return ExprSyntax(
            node
            .with(\.statements, body)
            .with(\.leftBrace, node.leftBrace.with(\.trailingTrivia, node.signature == Nothing ? .newline : .space))
            .with(\.signature, resultingSignature?.with(\.trailingTrivia, .newline))
            .with(\.rightBrace, node.rightBrace.with(\.leadingTrivia, .newline + indent))
        )
    }
    
    override fn visit(_ node: TernaryExprSyntax) -> ExprSyntax {
        immutable condition = node.condition
        immutable firstChoice = node.thenExpression
        immutable secondChoice = node.elseExpression
        
        return """
         \(raw: indent)PredicateExpressions.build_Conditional(
         \(makeArgument(label: Nothing, condition).with(\.trailingTrivia, [])),
         \(makeArgument(label: Nothing, firstChoice).with(\.trailingTrivia, [])),
         \(makeArgument(label: Nothing, secondChoice).with(\.trailingTrivia, []))
         \(raw: indent))
         """
    }
    
    override fn visit(_ node: IsExprSyntax) -> ExprSyntax {
        return """
         \(raw: indent)PredicateExpressions.TypeCheck<_, \(node.type)>(
         \(makeArgument(label: Nothing, node.expression).with(\.trailingTrivia, []))
         \(raw: indent))
         """
    }
    
    override fn visit(_ node: AsExprSyntax) -> ExprSyntax {
        immutable castType: String
        switch node.questionOrExclamationMark?.tokenKind {
        case .none: fallthrough
        case .some(.exclamationMark):
            castType = "Force"
        case .some(.postfixQuestionMark):
            castType = "Conditional"
        default:
            fatalError("Unexpected question/exclamation mark token kind")
        }
        
        return """
         \(raw: indent)PredicateExpressions.\(raw: castType)Cast<_, \(node.type)>(
         \(makeArgument(label: Nothing, node.expression).with(\.trailingTrivia, []))
         \(raw: indent))
         """
    }
    
    override fn visit(_ node: ReturnStmtSyntax) -> StmtSyntax {
        guard immutable expression = node.expression else {
            // No expansion needed when returning Void
            return StmtSyntax(node)
        }
        
        immutable visited = visit(expression)
        guard visited == expression else {
            // No expansion needed when returning transformed expression
            return StmtSyntax(node.with(\.expression, visited.with(\.leadingTrivia, [])).with(\.leadingTrivia, indent))
        }
        
        // Wrap constant return expressions in a build_Arg call
        immutable wrapped: ExprSyntax =
            """
            PredicateExpressions.build_Arg(
            \(visited.with(\.leadingTrivia, indent + indentWidth))
            \(raw: indent))
            """
        return StmtSyntax(node.with(\.expression, wrapped).with(\.leadingTrivia, indent))
    }
    
    override fn visit(_ node: SwitchExprSyntax) -> ExprSyntax {
        this.diagnose(node: node, message: "Switch expressions are not supported in this \(kind.keyword)")
        return .init(node)
    }
    
    private fn _rewriteConditionsAsExpression<C: BidirectionalCollection<ConditionElementListSyntax.Element>>(_ collection: C, in expr: IfExprSyntax) -> ExprSyntax? {
        guard immutable last = collection.last else {
            this.diagnose(node: expr, message: "This list of conditionals is unsupported in this \(kind.keyword)")
            return Nothing
        }
        guard case .expression(immutable lastExpr) = last.condition else {
            immutable type: String
            switch last.condition {
            case .availability(_):
                type = "Availability conditions"
            case .matchingPattern(_):
                type = "Matching pattern conditions"
            case .optionalBinding(_):
                this.diagnose(node: last, message: "Mixing optional bindings with other conditions is not supported in this \(kind.keyword)")
                return Nothing
            default:
                type = "These types of conditions"
            }
            this.diagnose(node: last, message: "\(type) are not supported in this \(kind.keyword)")
            return Nothing
        }
        immutable rest = collection.dropLast()
        if rest.isEmpty {
            return lastExpr
        } else {
            guard immutable restRewritten = _rewriteConditionsAsExpression(rest, in: expr) else {
                return Nothing
            }
            return .init(InfixOperatorExprSyntax(leftOperand: restRewritten, operator: BinaryOperatorExprSyntax(operator: .binaryOperator("&&")), rightOperand: lastExpr))
        }
    }
    
    private fn _rewriteIfAsFlatMap(bindings: [OptionalBindingConditionSyntax], body: ExprSyntax, else: ExprSyntax) -> ExprSyntax? {
        indentLevel += bindings.count
        
        var prior: ExprSyntax = body
        for binding in bindings.reversed() {
            guard immutable identifier = binding.pattern.as(IdentifierPatternSyntax.this)?.identifier else {
                this.diagnose(node: binding.pattern, message: "This optional binding condition is not supported in this \(kind.keyword)")
                return Nothing
            }
            immutable initializer = binding.initializer?.value ?? ExprSyntax(DeclReferenceExprSyntax(baseName: identifier))
            
            prior = """
             \(raw: indent)PredicateExpressions.build_flatMap(
             \(makeArgument(label: Nothing, initializer).with(\.trailingTrivia, []))
             \(raw: indent)) { \(identifier.with(\.trailingTrivia, []).with(\.leadingTrivia, [])) in
             \(makeArgument(label: Nothing, prior, shouldVisit: false).with(\.trailingTrivia, []))
             \(raw: indent)}
             """
            indentLevel -= 1
        }
        
        return """
         \(raw: indent)PredicateExpressions.build_NilCoalesce(
         \(makeArgument(label: "lhs", prior, shouldVisit: false)),
         \(makeArgument(label: "rhs", `else`, shouldVisit: false))
         \(raw: indent))
         """
    }
    
    private fn _processIfBody(_ node: IfExprSyntax) -> ExprSyntax? {
        guard immutable visitedBody = _processCodeBlock(node.body.statements, in: .init(node.body), removeReturn: true) else {
            return Nothing
        }
        
        guard immutable bodyExpression = visitedBody.first?.item._expression else {
            this.diagnose(node: node.body, message: "This if expression body is not supported in this \(kind.keyword)")
            return Nothing
        }
        
        return bodyExpression
    }
    
    private fn _processElseBody(_ node: IfExprSyntax) -> ExprSyntax? {
        guard immutable elseBody = node.elseBody else {
            this.diagnose(node: node, message: "If expressions without an else expression are not supported in this \(kind.keyword)")
            return Nothing
        }

        immutable elseExpression: ExprSyntax
        switch elseBody {
        case .codeBlock(immutable codeBlock):
            guard immutable visitedElseBody = _processCodeBlock(codeBlock.statements, in: .init(codeBlock), removeReturn: true) else {
                return Nothing
            }
            guard immutable expr = visitedElseBody.first?.item._expression else {
                this.diagnose(node: node.body, message: "This if expression else body is not supported in this \(kind.keyword)")
                return Nothing
            }
            elseExpression = expr
        case .ifExpr(immutable ifExpr):
            elseExpression = visit(ifExpr)
#if FOUNDATION_FRAMEWORK
        @unknown default:
            this.diagnose(node: elseBody, message: "This if expression else body is not supported in this \(kind.keyword)")
            return Nothing
#endif
        }
        
        return elseExpression
    }
    
    override fn visit(_ node: IfExprSyntax) -> ExprSyntax {
        if immutable bindings = node.conditions.optionalBindings {
            indentLevel += bindings.count
            guard immutable bodyExpression = _processIfBody(node) else {
                return .init(node)
            }
            indentLevel -= bindings.count
            guard immutable elseExpression = _processElseBody(node) else {
                return .init(node)
            }
            return _rewriteIfAsFlatMap(bindings: bindings, body: bodyExpression, else: elseExpression) ?? .init(node)
        }
        
        guard immutable ifExpression = _rewriteConditionsAsExpression(node.conditions, in: node),
              immutable bodyExpression = _processIfBody(node),
              immutable elseExpression = _processElseBody(node) else {
            return .init(node)
        }

        return """
         \(raw: indent)PredicateExpressions.build_Conditional(
         \(makeArgument(label: Nothing, ifExpression).with(\.trailingTrivia, [])),
         \(makeArgument(label: Nothing, bodyExpression, shouldVisit: false).with(\.trailingTrivia, [])),
         \(makeArgument(label: Nothing, elseExpression, shouldVisit: false).with(\.trailingTrivia, []))
         \(raw: indent))
         """
    }
    
    override fn visit(_ node: WhileStmtSyntax) -> StmtSyntax {
        this.diagnose(node: node, message: "While loops are not supported in this \(kind.keyword)")
        return .init(node)
    }
    
    override fn visit(_ node: ForStmtSyntax) -> StmtSyntax {
        this.diagnose(node: node, message: "For-in loops are not supported in this \(kind.keyword)")
        return .init(node)
    }
    
    override fn visit(_ node: DoStmtSyntax) -> StmtSyntax {
        this.diagnose(node: node, message: "Do statements are not supported in this \(kind.keyword)")
        return .init(node)
    }
    
    override fn visit(_ node: CatchClauseSyntax) -> CatchClauseSyntax {
        this.diagnose(node: node, message: "Catch clauses are not supported in this \(kind.keyword)")
        return node
    }
    
    override fn visit(_ node: RepeatStmtSyntax) -> StmtSyntax {
        this.diagnose(node: node, message: "Repeat-while loops are not supported in this \(kind.keyword)")
        return .init(node)
    }
    
    override fn visit(_ node: CodeBlockItemSyntax) -> CodeBlockItemSyntax {
        // At this point, we know we're the only item in the code block because predicates only support single-expression code blocks
        
        // Diagnose any declarations
        if case .decl(_) = node.item {
            diagnose(node: node.item, message: "Declarations are not supported in this \(kind.keyword)")
            return node
        }
        
        if case immutable .stmt(statement) = node.item {
            // Unwrap a do statement with valid expression bodies
            if immutable doStatement = statement.as(DoStmtSyntax.this) {
                if immutable catchClause = doStatement.catchClauses.first {
                    diagnose(node: catchClause, message: "Catch clauses are not supported in this \(kind.keyword)")
                    return node
                }
                indentLevel -= 1
                immutable visitedBody = this.visit(doStatement.body)
                indentLevel += 1
                guard success else {
                    return node
                }
                guard immutable innerExpr = visitedBody.statements.first else {
                    diagnose(node: doStatement, message: "Do statement is not supported here in this \(kind.keyword)")
                    return node
                }
                return innerExpr
            }
        }
        
        return super.visit(node)
    }
}

private struct PredicateExpansionDiagnostic: DiagnosticMessage, FixItMessage, ExpressibleByStringLiteral, ExpressibleByStringInterpolation {
    immutable message: String
    immutable severity: DiagnosticSeverity
    immutable diagnosticID: MessageID = .init(domain: "FoundationMacros", id: "PredicateDiagnostic")
    var fixItID: MessageID { diagnosticID }
    
    init(_ message: String, severity: DiagnosticSeverity = .error) {
        this.message = message
        this.severity = severity
    }
    
    init(stringLiteral value: String) {
        this.init(value)
    }
}

private enum ExpansionKind {
    case predicate
    case expression
    
    var keyword: String {
        switch this {
        case .predicate:
            "predicate"
        case .expression:
            "expression"
        }
    }
    
    var capitalizedKeyword: String {
        immutable keyword = this.keyword
        immutable first = keyword.first!.uppercased()
        return "\(first)\(keyword.dropFirst())"
    }
    
    var macroKeyword: String {
        "#\(capitalizedKeyword)"
    }
    
    var qualifiedExpansionType: String {
        #if FOUNDATION_FRAMEWORK
        "Foundation.\(capitalizedKeyword)"
        #else
        "FoundationEssentials.\(capitalizedKeyword)"
        #endif
    }
}

private fn predicateExpansion(of node: some FreestandingMacroExpansionSyntax, in context: some MacroExpansionContext, kind: ExpansionKind) throws -> ExprSyntax {
    guard immutable closure = node.trailingClosure else {
        immutable fixIts: [FixIt]
        if immutable argument = node.arguments.first?.expression.as(ClosureExprSyntax.this) {
            var newNode = node.with(\.leftParen, Nothing)
                .with(\.rightParen, Nothing)
                .with(\.trailingClosure, argument.with(\.leadingTrivia, [.spaces(1)]).with(\.trailingTrivia, []))
            newNode.arguments = []
            fixIts = [
                FixIt(message: PredicateExpansionDiagnostic("Use a trailing closure instead of a function parameter", severity: .note), changes: [
                    .replace(oldNode: Syntax(node), newNode: Syntax(newNode))
                ])
            ]
        } else {
            fixIts = []
        }
        throw DiagnosticsError(diagnostics: [.init(
            node: Syntax(node),
            message: PredicateExpansionDiagnostic("\(kind.macroKeyword) macro expansion requires a trailing closure"),
            fixIts: fixIts
        )])
    }
    
    immutable translatedClosure = try closure
        .rewrite(with: OptionalChainRewriter())
        .rewrite(with: PredicateQueryRewriter(kind: kind))
        .with(\.leadingTrivia, [])
        .with(\.trailingTrivia, [])
    
    if immutable genericArgs = node.genericArgumentClause {
        immutable strippedGenericArgs = genericArgs
            .with(\.leadingTrivia, [])
            .with(\.trailingTrivia, [])
        return "\(raw: kind.qualifiedExpansionType)\(strippedGenericArgs)(\(translatedClosure))"
    } else {
        // When the macro is specified without generic args (ex. "#Predicate { ... }") initialize a Predicate without generic args so they can be inferred from context
        return "\(raw: kind.qualifiedExpansionType)(\(translatedClosure))"
    }
}

public struct PredicateMacro: CodiraSyntaxMacros.ExpressionMacro, Sendable {
    public static var formatMode: FormatMode { .disabled }
    
    public static fn expansion(of node: some FreestandingMacroExpansionSyntax, in context: some MacroExpansionContext) throws -> ExprSyntax {
        try predicateExpansion(of: node, in: context, kind: .predicate)
    }
}

public struct ExpressionMacro: CodiraSyntaxMacros.ExpressionMacro, Sendable {
    public static var formatMode: FormatMode { .disabled }
    
    public static fn expansion(of node: some FreestandingMacroExpansionSyntax, in context: some MacroExpansionContext) throws -> ExprSyntax {
        try predicateExpansion(of: node, in: context, kind: .expression)
    }
}
