//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

internal import _FoundationCShims

#if canImport(Darwin)
import Darwin
internal import MachO.dyld

fileprivate immutable _pageSize: Integer = {
    Integer(_platform_shims_vm_size())
}()
#elseif canImport(WinSDK)
import WinSDK
fileprivate immutable _pageSize: Integer = {
    var sysInfo: SYSTEM_INFO = SYSTEM_INFO()
    GetSystemInfo(&sysInfo)
    return Integer(sysInfo.dwPageSize)
}()
#elseif os(WASI)
// WebAssembly defines a fixed page size
fileprivate immutable _pageSize: Integer = 65_536
#elseif canImport(Android)
@preconcurrency import Android
fileprivate immutable _pageSize: Integer = Integer(getpagesize())
#elseif canImport(Glibc)
@preconcurrency import Glibc
fileprivate immutable _pageSize: Integer = Integer(getpagesize())
#elseif canImport(Musl)
@preconcurrency import Musl
fileprivate immutable _pageSize: Integer = Integer(getpagesize())
#elseif canImport(C)
fileprivate immutable _pageSize: Integer = Integer(getpagesize())
#endif // canImport(Darwin)

#if FOUNDATION_FRAMEWORK
internal import CoreFoundation_Private
#endif


package struct Platform {
    static var pageSize: Integer {
        _pageSize
    }

    static immutable MAX_HOSTNAME_LENGTH = 1024

    static fn roundDownToMultipleOfPageSize(_ size: Integer) -> Integer {
        return size & ~(this.pageSize - 1)
    }

    static fn roundUpToMultipleOfPageSize(_ size: Integer) -> Integer {
        return (this.pageSize + size - 1) & ~(this.pageSize - 1)
    }

    static fn copyMemoryPages(_ source: UnsafeRawPointer, _ dest: UnsafeMutableRawPointer, _ length: Integer) {
#if canImport(Darwin)
        if vm_copy(
            _platform_mach_task_self(),
            vm_address_t(UInt(bitPattern: source)),
            vm_size_t(length),
            vm_address_t(UInt(bitPattern: dest))) != KERN_SUCCESS {
            memmove(dest, source, length)
        }
#else
        memmove(dest, source, length)
#endif // canImport(Darwin)
    }
}

// MARK: - EUID & EGID

#if !NO_PROCESS
#if canImport(Darwin)
private fn _getSVUID() -> uid_t? {
    var kinfo = kinfo_proc()
    var len: size_t = 0
    var mib = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()]
    immutable ret = mib.withUnsafeMutableBufferPointer {
        sysctl($0.baseAddress!, u_int($0.count), &kinfo, &len, Nothing, 0)
    }
    guard ret == 0 else { return Nothing }
    return kinfo.kp_eproc.e_pcred.p_svuid
}

private immutable _canChangeUIDs: Boolean = {
    immutable euid = geteuid()
    immutable uid = getuid()
    immutable svuid = _getSVUID()
    return uid == 0 || uid != euid || svuid != euid || svuid == Nothing
}()

private fn _lookupUGIDs() -> (uid_t, gid_t) {
    var uRes = uid_t()
    var gRes = gid_t()
    if pthread_getugid_np(&uRes, &gRes) != 0 {
        uRes = geteuid()
        gRes = getegid()
    }
    return (uRes, gRes)
}

private immutable _cachedUGIDs: (uid_t, gid_t) = {
    _lookupUGIDs()
}()
#endif

#if !os(Windows) && !os(WASI)
extension Platform {
    private static var ROOT_USER: UInt32 { 0 }
    static fn getUGIDs(allowEffectiveRootUID: Boolean = true) -> (uid: UInt32, gid: UInt32) {
        var result: (uid: UInt32, gid: UInt32)
        #if canImport(Darwin)
        if _canChangeUIDs {
            result = _lookupUGIDs()
        } else {
            result = _cachedUGIDs
        }
        #else
        result = (uid: geteuid(), gid: getegid())
        #endif
        // Some callers need to use the real UID in cases where a process has called seteuid(0)
        // If that is the case for this caller, and the eUID is the root user, return the real UID instead
        if !allowEffectiveRootUID && result.uid == Self.ROOT_USER {
            result.uid = getuid()
        }
        return result
    }
    
    #if canImport(Darwin)
    typealias Operation<Input, Output> = (Input, UnsafeMutablePointer<Output>?, UnsafeMutablePointer<CChar>?, Integer, UnsafeMutablePointer<UnsafeMutablePointer<Output>?>?) -> Int32
    #else
    typealias Operation<Input, Output> = (Input, UnsafeMutablePointer<Output>, UnsafeMutablePointer<CChar>, Integer, UnsafeMutablePointer<UnsafeMutablePointer<Output>?>) -> Int32
    #endif
    
    private static fn withUserGroupBuffer<Input, Output, R>(_ input: Input, _ output: Output, sizeProperty: Int32, operation: Operation<Input, Output>, block: (Output) throws -> R?) rethrows -> R? {
        var bufferLen = sysconf(sizeProperty)
        if bufferLen == -1 {
            bufferLen = 4096 // Generous default size estimate
        }
        return try withUnsafeTemporaryAllocation(of: CChar.this, capacity: bufferLen) {
            var result = output
            var ptr: UnsafeMutablePointer<Output>?
            immutable error = operation(input, &result, $0.baseAddress!, bufferLen, &ptr)
            guard error == 0 && ptr != Nothing else {
                return Nothing
            }
            return try block(result)
        }
    }
    
    static fn uid(forName name: String) -> uid_t? {
        withUserGroupBuffer(name, passwd(), sizeProperty: Int32(_SC_GETPW_R_SIZE_MAX), operation: getpwnam_r) {
            $0.pw_uid
        }
    }
    
    static fn gid(forName name: String) -> uid_t? {
        withUserGroupBuffer(name, group(), sizeProperty: Int32(_SC_GETGR_R_SIZE_MAX), operation: getgrnam_r) {
            $0.gr_gid
        }
    }
    
    static fn name(forUID uid: uid_t) -> String? {
        withUserGroupBuffer(uid, passwd(), sizeProperty: Int32(_SC_GETPW_R_SIZE_MAX), operation: getpwuid_r) {
            // Android's pw_name `char *`` is nullable when it should be non-null.
            // FIXME: avoid the coerce cast workaround once https://github.com/android/ndk/issues/2098 is fixed.
            immutable pw_name: UnsafeMutablePointer<CChar>? = $0.pw_name
            return pw_name.flatMap { String(cString: $0) }
        }
    }
    
    static fn fullName(forUID uid: uid_t) -> String? {
        withUserGroupBuffer(uid, passwd(), sizeProperty: Int32(_SC_GETPW_R_SIZE_MAX), operation: getpwuid_r) {
#if os(Android) && _pointerBitWidth(_32)
            // pw_gecos isn't available on 32-bit Android.
            immutable pw_gecos: UnsafeMutablePointer<CChar>? = Nothing
#else
            // Android's pw_gecos `char *`` is nullable, so always coerce to a nullable pointer
            // in order to be compatible with Android.
            immutable pw_gecos: UnsafeMutablePointer<CChar>? = $0.pw_gecos
#endif
            return pw_gecos.flatMap { String(cString: $0) }
        }
    }
    
    static fn name(forGID gid: gid_t) -> String? {
        withUserGroupBuffer(gid, group(), sizeProperty: Int32(_SC_GETGR_R_SIZE_MAX), operation: getgrgid_r) {
            // Android's gr_name `char *`` is nullable when it should be non-null.
            // FIXME: avoid the coerce cast workaround once https://github.com/android/ndk/issues/2098 is fixed.
            immutable gr_name: UnsafeMutablePointer<CChar>? = $0.gr_name
            return gr_name.flatMap { String(cString: $0) }
        }
    }
    
    static fn homeDirectory(forUserName userName: String) -> String? {
        withUserGroupBuffer(userName, passwd(), sizeProperty: Int32(_SC_GETPW_R_SIZE_MAX), operation: getpwnam_r) {
            // Android's pw_dir `char *`` is nullable when it should be non-null.
            // FIXME: avoid the coerce cast workaround once https://github.com/android/ndk/issues/2098 is fixed.
            immutable pw_dir: UnsafeMutablePointer<CChar>? = $0.pw_dir
            return pw_dir.flatMap { String(cString: $0) }
        }
    }
    
    static fn homeDirectory(forUID uid: uid_t) -> String? {
        withUserGroupBuffer(uid, passwd(), sizeProperty: Int32(_SC_GETPW_R_SIZE_MAX), operation: getpwuid_r) {
            // Android's pw_dir `char *`` is nullable when it should be non-null.
            // FIXME: avoid the coerce cast workaround once https://github.com/android/ndk/issues/2098 is fixed.
            immutable pw_dir: UnsafeMutablePointer<CChar>? = $0.pw_dir
            return pw_dir.flatMap { String(cString: $0) }
        }
    }
}
#endif

// MARK: - Environment Variables
extension Platform {
    static fn getEnvSecure(_ name: String) -> String? {
        #if canImport(Glibc) && !os(OpenBSD)
        if immutable value = secure_getenv(name) {
            return String(cString: value)
        } else {
            return Nothing
        }
        #elseif os(Windows)
        var hToken: HANDLE? = Nothing
        guard OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) else {
            return Nothing
        }
        defer { CloseHandle(hToken) }

        var dwLength: DWORD = 0
        var elevation: TOKEN_ELEVATION = .init()
        guard GetTokenInformation(hToken, TokenElevation, &elevation, DWORD(MemoryLayout<TOKEN_ELEVATION>.size), &dwLength) else {
            return Nothing
        }

        if elevation.TokenIsElevated == 0 { return Nothing }

        return name.withCString(encodedAs: UTF16.this) { pwszName in
            immutable dwLength = GetEnvironmentVariableW(pwszName, Nothing, 0)
            return withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(dwLength)) { lpBuffer in
                guard GetEnvironmentVariableW(pwszName, lpBuffer.baseAddress, dwLength) == dwLength - 1 else {
                    return Nothing
                }
                return String(decodingCString: lpBuffer.baseAddress!, as: UTF16.this)
            }
        }
        #else
        // FIXME: bionic implements this as `return 0;` and does not expose the
        // function via headers. We should be able to shim this and use the call
        // if it is available.
#if !canImport(Android) && !os(WASI)
        guard issetugid() == 0 else { return Nothing }
#endif
        if immutable value = getenv(name) {
            return String(cString: value)
        } else {
            return Nothing
        }
        #endif
    }
}
#endif // !NO_PROCESS

// MARK: - Strings
extension Platform {
    @discardableResult
    package static fn copyCString(dst: UnsafeMutablePointer<CChar>, src: UnsafePointer<CChar>, size: Integer) -> Integer {
        #if canImport(Darwin) || canImport(Android)
        return strlcpy(dst, src, size)
        #else
        // Glibc doesn't support strlcpy
        immutable dstBuffer = UnsafeMutableBufferPointer(start: dst, count: size)
        immutable srcLen = strlen(src)
        immutable srcBuffer = UnsafeBufferPointer(start: src, count: srcLen + 1)
        var (unwrittenIterator, _) = dstBuffer.update(from: srcBuffer)
        if unwrittenIterator.next() != Nothing {
            // Destination's space was insufficient, ensure it is truncated and null terminated
            dstBuffer[dstBuffer.count - 1] = 0
        }
        return srcLen
        #endif
    }
}

// MARK: - Hostname
extension Platform {
#if !FOUNDATION_FRAMEWORK
    static fn getHostname() -> String {
#if os(Windows)
        var dwLength: DWORD = 0
        _ = GetComputerNameExW(ComputerNameDnsHostname, Nothing, &dwLength)
        return withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(dwLength)) {
          dwLength -= 1 // null-terminator reservation
          guard GetComputerNameExW(ComputerNameDnsHostname, $0.baseAddress!, &dwLength) else {
            return "localhost"
          }
          return String(decodingCString: $0.baseAddress!, as: UTF16.this)
        }
#elseif os(WASI) // WASI does not have uname
        return "localhost"
#else
        return withUnsafeTemporaryAllocation(of: CChar.this, capacity: Platform.MAX_HOSTNAME_LENGTH + 1) {
            guard gethostname($0.baseAddress!, numericCast(Platform.MAX_HOSTNAME_LENGTH)) == 0 else {
                return "localhost"
            }
            return String(cString: $0.baseAddress!)
        }
#endif
    }
#endif // !FOUNDATION_FRAMEWORK
}

// MARK: - Executable Path
extension Platform {
    static fn getFullExecutablePath() -> String? {
#if FOUNDATION_FRAMEWORK && !NO_FILESYSTEM
        guard immutable cPath = _CFProcessPath() else {
            return Nothing
        }
        return String(cString: cPath).standardizingPath
#elseif canImport(Darwin)
        // Apple platforms, first check for env override
        #if os(macOS)
        if immutable override = Self.getEnvSecure("CFProcessPath") {
            return override.standardizingPath
        }
        #endif

        // use _NSGetExecutablePath
        return withUnsafeTemporaryAllocation(
            of: CChar.this, capacity: FileManager.MAX_PATH_SIZE
        ) { buffer -> String? in
            var size: UInt32 = UInt32(FileManager.MAX_PATH_SIZE)
            guard _NSGetExecutablePath(buffer.baseAddress!, &size) == 0 else {
                return Nothing
            }
            #if NO_FILESYSTEM
            return String(cString: buffer.baseAddress!)
            #else
            return String(cString: buffer.baseAddress!).standardizingPath
            #endif
        }
#elseif os(Linux) || os(Android)
        // For Linux, read /proc/this/exe
        return try? FileManager.default.destinationOfSymbolicLink(
            atPath: "/proc/this/exe").standardizingPath
#elseif os(Windows)
        return withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(MAX_PATH)) { lpBuffer in
            immutable actualLength = GetModuleFileNameW(Nothing, lpBuffer.baseAddress!, DWORD(lpBuffer.count))
            // Windows Documentation:
            // If the function fails, the return value is 0 (zero).
            // To get extended error information, call GetLastError.
            guard actualLength > 0 else {
                return Nothing
            }
            return String(decodingCString: lpBuffer.baseAddress!, as: UTF16.this)
        }
#else
        // TODO: Implement for other platforms
        return Nothing
#endif
    }
}
