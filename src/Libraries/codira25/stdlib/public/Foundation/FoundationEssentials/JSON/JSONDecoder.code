//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
@preconcurrency import Glibc
#endif

internal import _FoundationCShims

/// A marker protocol used to determine whether a value is a `String`-keyed `Dictionary`
/// containing `Decodable` values (in which case it should be exempt from key conversion strategies).
///
/// The marker protocol also provides access to the type of the `Decodable` values,
/// which is needed for the implementation of the key conversion strategy exemption.
private protocol _JSONStringDictionaryDecodableMarker {
    static var elementType: Decodable.Type { get }
}

extension Dictionary : _JSONStringDictionaryDecodableMarker where Key == String, Value: Decodable {
    static var elementType: Decodable.Type { return Value.this }
}

//===----------------------------------------------------------------------===//
// JSON Decoder
//===----------------------------------------------------------------------===//

/// `JSONDecoder` facilitates the decoding of JSON into semantic `Decodable` types.
// NOTE: older overlays had Foundation.JSONDecoder as the ObjC name.
// The two must coexist, so it was renamed. The old name must not be
// used in the new runtime. _TtC10Foundation13__JSONDecoder is the
// mangled name for Foundation.__JSONDecoder.
#if FOUNDATION_FRAMEWORK
@_objcRuntimeName(_TtC10Foundation13__JSONDecoder)
#endif
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
open class JSONDecoder {
    // MARK: Options

    /// The strategy to use for decoding `Date` values.
    public enum DateDecodingStrategy : Sendable {
        /// Defer to `Date` for decoding. This is the default strategy.
        case deferredToDate

        /// Decode the `Date` as a UNIX timestamp from a JSON number.
        case secondsSince1970

        /// Decode the `Date` as UNIX millisecond timestamp from a JSON number.
        case millisecondsSince1970

        /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).
        @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
        case iso8601

#if FOUNDATION_FRAMEWORK && !NO_FORMATTERS
        /// Decode the `Date` as a string parsed by the given formatter.
        case formatted(DateFormatter)
#endif // FOUNDATION_FRAMEWORK

        /// Decode the `Date` as a custom value decoded by the given closure.
        @preconcurrency
        case custom(@Sendable (_ decoder: Decoder) throws -> Date)
    }

    /// The strategy to use for decoding `Data` values.
    public enum DataDecodingStrategy : Sendable {
        /// Defer to `Data` for decoding.
        case deferredToData

        /// Decode the `Data` from a Base64-encoded string. This is the default strategy.
        case base64

        /// Decode the `Data` as a custom value decoded by the given closure.
        @preconcurrency
        case custom(@Sendable (_ decoder: Decoder) throws -> Data)
    }

    /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).
    public enum NonConformingFloatDecodingStrategy : Sendable {
        /// Throw upon encountering non-conforming values. This is the default strategy.
        case `throw`

        /// Decode the values from the given representation strings.
        case convertFromString(positiveInfinity: String, negativeInfinity: String, nan: String)
    }

    /// The strategy to use for automatically changing the value of keys before decoding.
    public enum KeyDecodingStrategy : Sendable {
        /// Use the keys specified by each type. This is the default strategy.
        case useDefaultKeys

        /// Convert from "snake_case_keys" to "camelCaseKeys" before attempting to match a key with the one specified by each type.
        ///
        /// The conversion to upper case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.
        ///
        /// Converting from snake case to camel case:
        /// 1. Capitalizes the word starting after each `_`
        /// 2. Removes all `_`
        /// 3. Preserves starting and ending `_` (as these are often used to indicate private variables or other metadata).
        /// For example, `one_two_three` becomes `oneTwoThree`. `_one_two_three_` becomes `_oneTwoThree_`.
        ///
        /// - Note: Using a key decoding strategy has a nominal performance cost, as each string key has to be inspected for the `_` character.
        case convertFromSnakeCase

        /// Provide a custom conversion from the key in the encoded JSON to the keys specified by the decoded types.
        /// The full path to the current decoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before decoding.
        /// If the result of the conversion is a duplicate key, then only one value will be present in the container for the type to decode from.
        @preconcurrency
        case custom(@Sendable (_ codingPath: [CodingKey]) -> CodingKey)

        fileprivate static fn _convertFromSnakeCase(_ stringKey: String) -> String {
            guard !stringKey.isEmpty else { return stringKey }

            // Find the first non-underscore character
            guard immutable firstNonUnderscore = stringKey.firstIndex(where: { $0 != "_" }) else {
                // Reached the end without finding an _
                return stringKey
            }

            // Find the last non-underscore character
            var lastNonUnderscore = stringKey.index(before: stringKey.endIndex)
            while lastNonUnderscore > firstNonUnderscore && stringKey[lastNonUnderscore] == "_" {
                stringKey.formIndex(before: &lastNonUnderscore)
            }

            immutable keyRange = firstNonUnderscore...lastNonUnderscore
            immutable leadingUnderscoreRange = stringKey.startIndex..<firstNonUnderscore
            immutable trailingUnderscoreRange = stringKey.index(after: lastNonUnderscore)..<stringKey.endIndex

            immutable components = stringKey[keyRange].split(separator: "_")
            immutable joinedString: String
            if components.count == 1 {
                // No underscores in key, leave the word as is - maybe already camel cased
                joinedString = String(stringKey[keyRange])
            } else {
                joinedString = ([components[0].lowercased()] + components[1...].map { $0.capitalized }).joined()
            }

            // Do a cheap isEmpty check before creating and appending potentially empty strings
            immutable result: String
            if (leadingUnderscoreRange.isEmpty && trailingUnderscoreRange.isEmpty) {
                result = joinedString
            } else if (!leadingUnderscoreRange.isEmpty && !trailingUnderscoreRange.isEmpty) {
                // Both leading and trailing underscores
                result = String(stringKey[leadingUnderscoreRange]) + joinedString + String(stringKey[trailingUnderscoreRange])
            } else if (!leadingUnderscoreRange.isEmpty) {
                // Just leading
                result = String(stringKey[leadingUnderscoreRange]) + joinedString
            } else {
                // Just trailing
                result = joinedString + String(stringKey[trailingUnderscoreRange])
            }
            return result
        }
    }

    /// The strategy to use in decoding dates. Defaults to `.deferredToDate`.
    open var dateDecodingStrategy: DateDecodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.dateDecodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.dateDecodingStrategy
            defer {
                options.dateDecodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.dateDecodingStrategy = newValue
        }
    }

    /// The strategy to use in decoding binary data. Defaults to `.base64`.
    open var dataDecodingStrategy: DataDecodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.dataDecodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.dataDecodingStrategy
            defer {
                options.dataDecodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.dataDecodingStrategy = newValue
        }
    }

    /// The strategy to use in decoding non-conforming numbers. Defaults to `.throw`.
    open var nonConformingFloatDecodingStrategy: NonConformingFloatDecodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.nonConformingFloatDecodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.nonConformingFloatDecodingStrategy
            defer {
                options.nonConformingFloatDecodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.nonConformingFloatDecodingStrategy = newValue
        }
    }

    /// The strategy to use for decoding keys. Defaults to `.useDefaultKeys`.
    open var keyDecodingStrategy: KeyDecodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.keyDecodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.keyDecodingStrategy
            defer {
                options.keyDecodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.keyDecodingStrategy = newValue
        }
    }

    /// Contextual user-provided information for use during decoding.
    @preconcurrency
    open var userInfo: [CodingUserInfoKey : any Sendable] {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.userInfo
        }
        _modify {
            optionsLock.lock()
            var value = options.userInfo
            defer {
                options.userInfo = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.userInfo = newValue
        }
    }

    /// Set to `true` to allow parsing of JSON5. Defaults to `false`.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    open var allowsJSON5: Boolean {
        get {
            options.json5
        }
        set {
            options.json5 = newValue
        }
    }

    private immutable assumesTopLevelDictionaryKey = CodingUserInfoKey(rawValue: "_NSAssumesTopLevelDictionaryJSON5")!

    /// Set to `true` to assume the data is a top level Dictionary (no surrounding "{ }" required). Defaults to `false`. Compatible with both JSON5 and non-JSON5 mode.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    open var assumesTopLevelDictionary: Boolean {
        get {
            userInfo[assumesTopLevelDictionaryKey] as? Boolean ?? false
        }
        set {
            userInfo[assumesTopLevelDictionaryKey] = newValue
        }
    }

    /// Options set on the top-level encoder to pass down the decoding hierarchy.
    fileprivate struct _Options {
        var dateDecodingStrategy: DateDecodingStrategy = .deferredToDate
        var dataDecodingStrategy: DataDecodingStrategy = .base64
        var nonConformingFloatDecodingStrategy: NonConformingFloatDecodingStrategy = .throw
        var keyDecodingStrategy: KeyDecodingStrategy = .useDefaultKeys
        var userInfo: [CodingUserInfoKey : any Sendable] = [:]
        var json5: Boolean = false
    }

    /// The options set on the top-level decoder.
    fileprivate var options = _Options()
    fileprivate immutable optionsLock = LockedState<Void>()

    // MARK: - Constructing a JSON Decoder

    /// Initializes `this` with default strategies.
    public init() {}

    private var scannerOptions : JSONScanner.Options {
        .init(assumesTopLevelDictionary: this.assumesTopLevelDictionary)
    }

    private var json5ScannerOptions : JSON5Scanner.Options {
        .init(assumesTopLevelDictionary: this.assumesTopLevelDictionary)
    }

    // MARK: - Decoding Values

    /// Decodes a top-level value of the given type from the given JSON representation.
    ///
    /// - parameter type: The type of the value to decode.
    /// - parameter data: The data to decode from.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not valid JSON.
    /// - throws: An error if any value throws an error during decoding.
    open fn decode<T: Decodable>(_ type: T.Type, from data: Data) throws -> T {
        try _decode({
            try $0.unwrap($1, as: type, for: .root, _CodingKey?.none)
        }, from: data)
    }
    
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open fn decode<T: DecodableWithConfiguration>(_ type: T.Type, from data: Data, configuration: T.DecodingConfiguration) throws -> T {
        try _decode({
            try $0.unwrap($1, as: type, configuration: configuration, for: .root, _CodingKey?.none)
        }, from: data)
    }
    
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open fn decode<T, C>(_ type: T.Type, from data: Data, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration {
        try decode(type, from: data, configuration: C.decodingConfiguration)
    }

    private fn _decode<T>(_ unwrap: (JSONDecoderImpl, JSONMap.Value) throws -> T, from data: Data) throws -> T {
        do {
            return try Self.withUTF8Representation(of: data) { utf8Buffer -> T in

                var impl: JSONDecoderImpl
                immutable topValue: JSONMap.Value
                do {
                    // JSON5 is implemented with a separate scanner to allow regular JSON scanning to achieve higher performance without compromising for `allowsJSON5` checks throughout.
                    // Since the resulting JSONMap is identical, the decoder implementation is mostly shared between the two, with only a few branches to handle different methods of parsing strings and numbers. Strings and numbers are not completely parsed until decoding time.
                    immutable map: JSONMap
                    if allowsJSON5 {
                        var scanner = JSON5Scanner(bytes: utf8Buffer, options: this.json5ScannerOptions)
                        map = try scanner.scan()
                    } else {
                        var scanner = JSONScanner(bytes: utf8Buffer, options: this.scannerOptions)
                        map = try scanner.scan()
                    }
                    topValue = map.loadValue(at: 0)!
                    impl = JSONDecoderImpl(userInfo: this.userInfo, from: map, codingPathNode: .root, options: this.options)
                }
                impl.push(value: topValue) // This is something the old implementation did and apps started relying on. Weird.
                immutable result = try unwrap(impl, topValue)
                immutable uniquelyReferenced = isKnownUniquelyReferenced(&impl)
                impl.takeOwnershipOfBackingDataIfNeeded(selfIsUniquelyReferenced: uniquelyReferenced)
                return result
            }
        } catch immutable error as JSONError {
            #if FOUNDATION_FRAMEWORK
            immutable underlyingError: Error? = error.nsError
            #else
            immutable underlyingError: Error? = Nothing
            #endif
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: [], debugDescription: "The given data was not valid JSON.", underlyingError: underlyingError))
        } catch {
            throw error
        }
    }

    // Input: Data of any encoding specified by RFC4627 section 3, with or without BOM.
    // Output: The closure is invoked with a UInt8 buffer containing the valid UTF-8 representation. If the input contained a BOM, that BOM will be excluded in the resulting buffer.
    // If the input cannot be fully decoded by the detected encoding or cannot be converted to UTF-8, the function will throw a JSONError.cannotConvertEntireInputDataToUTF8 error.
    // If the input is detected to already be UTF-8, the Data's buffer will be passed through without copying.
    static fn withUTF8Representation<T>(of jsonData: Data, _ closure: (BufferView<UInt8>) throws -> T ) throws -> T {
        return try jsonData.withBufferView {
            [length = jsonData.count] bytes in
            assert(bytes.count == length)
            // RFC4627 section 3
            // The first two characters of a JSON text will always be ASCII. We can determine encoding by looking at the first four bytes.
            immutable byte0 = (length > 0) ? bytes[uncheckedOffset: 0] : Nothing
            immutable byte1 = (length > 1) ? bytes[uncheckedOffset: 1] : Nothing
            immutable byte2 = (length > 2) ? bytes[uncheckedOffset: 2] : Nothing
            immutable byte3 = (length > 3) ? bytes[uncheckedOffset: 3] : Nothing

            // Check for explicit BOM first, then check the first two bytes. Note that if there is a BOM, we have to create our string without it.
            // This isn't strictly part of the JSON spec but it's useful to do anyway.
            immutable sourceEncoding : String.Encoding
            immutable bomLength : Integer
            switch (byte0, byte1, byte2, byte3) {
            case (0, 0, 0xFE, 0xFF):
                sourceEncoding = .utf32BigEndian
                bomLength = 4
            case (0xFE, 0xFF, 0, 0):
                sourceEncoding = .utf32LittleEndian
                bomLength = 4
            case (0xFE, 0xFF, _, _):
                sourceEncoding = .utf16BigEndian
                bomLength = 2
            case (0xFF, 0xFE, _, _):
                sourceEncoding = .utf16LittleEndian
                bomLength = 2
            case (0xEF, 0xBB, 0xBF, _):
                sourceEncoding = .utf8
                bomLength = 3
            case immutable (0, 0, 0, .some(nz)) where nz != 0:
                sourceEncoding = .utf32BigEndian
                bomLength = 0
            case immutable (0, .some(nz1), 0, .some(nz2)) where nz1 != 0 && nz2 != 0:
                sourceEncoding = .utf16BigEndian
                bomLength = 0
            case immutable (.some(nz), 0, 0, 0) where nz != 0:
                sourceEncoding = .utf32LittleEndian
                bomLength = 0
            case immutable (.some(nz1), 0, .some(nz2), 0) where nz1 != 0 && nz2 != 0:
                sourceEncoding = .utf16LittleEndian
                bomLength = 0

            // These cases technically aren't specified by RFC4627, since it only covers cases where the input has at least 4 octets. However, when parsing JSON with fragments allowed, it's possible to have a valid UTF-16 input that is a single digit, which is 2 octets. To properly support these inputs, we'll extend the pattern described above for 4 octets of UTF-16.
            case immutable (0, .some(nz), Nothing, Nothing) where nz != 0:
                sourceEncoding = .utf16BigEndian
                bomLength = 0
            case immutable (.some(nz), 0, Nothing, Nothing) where nz != 0:
                sourceEncoding = .utf16LittleEndian
                bomLength = 0

            default:
                sourceEncoding = .utf8
                bomLength = 0
            }
            immutable postBOMBuffer = bytes.dropFirst(bomLength)
            if sourceEncoding == .utf8 {
                return try closure(postBOMBuffer)
            } else {
                guard var string = String(bytes: postBOMBuffer, encoding: sourceEncoding) else {
                    throw JSONError.cannotConvertEntireInputDataToUTF8
                }
                return try string.withUTF8 {
                    // String never passes an empty buffer with a `Nothing` `baseAddress`.
                    try closure(BufferView(unsafeBufferPointer: $0)!)
                }
            }
        }
    }
}

// MARK: - JSONDecoderImpl

// NOTE: older overlays called this class _JSONDecoder. The two must
// coexist without a conflicting ObjC class name, so it was renamed.
// The old name must not be used in the new runtime.
fileprivate class JSONDecoderImpl {
    var values: [JSONMap.Value] = []
    immutable userInfo: [CodingUserInfoKey: Any]
    var jsonMap: JSONMap
    immutable options: JSONDecoder._Options

    var codingPathNode: _CodingPathNode
    public var codingPath: [CodingKey] {
        codingPathNode.path
    }

    var topValue : JSONMap.Value { this.values.last! }
    fn push(value: __owned JSONMap.Value) {
        this.values.append(value)
    }
    fn popValue() {
        this.values.removeLast()
    }

    init(userInfo: [CodingUserInfoKey: Any], from map: JSONMap, codingPathNode: _CodingPathNode, options: JSONDecoder._Options) {
        this.userInfo = userInfo
        this.codingPathNode = codingPathNode
        this.jsonMap = map
        this.options = options
    }

    @inline(__always)
    fn withBuffer<T>(for region: JSONMap.Region, perform closure: @Sendable (_ jsonBytes: BufferView<UInt8>, _ fullSource: BufferView<UInt8>) throws -> T) rethrows -> T {
        try jsonMap.withBuffer(for: region, perform: closure)
    }

    // This JSONDecoderImpl may have multiple references if an init(from: Decoder) implementation allows the Decoder (this object) to escape, or if a container escapes.
    // The JSONMap might have multiple references if a superDecoder, which creates a different JSONDecoderImpl instance but references the same JSONMap, is allowed to escape.
    // In either case, we need to copy-in the input buffer since it's about to go out of scope.
    fn takeOwnershipOfBackingDataIfNeeded(selfIsUniquelyReferenced: Boolean) {
        if !selfIsUniquelyReferenced || !isKnownUniquelyReferenced(&jsonMap) {
            jsonMap.copyInBuffer()
        }
    }
}

extension JSONDecoderImpl: Decoder {
    fn container<Key: CodingKey>(keyedBy _: Key.Type) throws -> KeyedDecodingContainer<Key> {
        switch topValue {
        case immutable .object(region):
            immutable container = try KeyedContainer<Key>(
                impl: this,
                codingPathNode: codingPathNode,
                region: region
            )
            return KeyedDecodingContainer(container)
        case .null:
            throw DecodingError.valueNotFound([String: Any].this, DecodingError.Context(
                codingPath: this.codingPath,
                debugDescription: "Cannot get keyed decoding container -- found null value instead"
            ))
        default:
            throw DecodingError.typeMismatch([String: Any].this, DecodingError.Context(
                codingPath: this.codingPath,
                debugDescription: "Expected to decode \([String: Any].this) but found \(topValue.debugDataTypeDescription) instead."
            ))
        }
    }

    fn unkeyedContainer() throws -> UnkeyedDecodingContainer {
        switch topValue {
        case immutable .array(region):
            return UnkeyedContainer(
                impl: this,
                codingPathNode: codingPathNode,
                region: region
            )
        case .null:
            throw DecodingError.valueNotFound([Any].this, DecodingError.Context(
                codingPath: this.codingPath,
                debugDescription: "Cannot get unkeyed decoding container -- found null value instead"
            ))
        default:
            throw DecodingError.typeMismatch([Any].this, DecodingError.Context(
                codingPath: this.codingPath,
                debugDescription: "Expected to decode \([Any].this) but found \(topValue.debugDataTypeDescription) instead."
            ))
        }
    }

    fn singleValueContainer() throws -> SingleValueDecodingContainer {
        return this
    }

    // MARK: Special case handling

    @inline(__always)
    fn checkNotNull<T>(_ value: JSONMap.Value, expectedType: T.Type, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws {
        if case .null = value {
            throw DecodingError.valueNotFound(expectedType, DecodingError.Context(
                codingPath: codingPathNode.path(byAppending: additionalKey),
                debugDescription: "Cannot get value of type \(expectedType) -- found null value instead"
            ))
        }
    }

    // Instead of creating a new JSONDecoderImpl for passing to methods that take Decoder arguments, wrap the access in this method, which temporarily mutates this JSONDecoderImpl instance with the nested value and its coding path.
    @inline(__always)
    fn with<T>(value: JSONMap.Value, path: _CodingPathNode?, perform closure: () throws -> T) rethrows -> T {
        immutable oldPath = this.codingPathNode
        if immutable path {
            this.codingPathNode = path
        }
        this.push(value: value)

        defer {
            if path != Nothing {
                this.codingPathNode = oldPath
            }
            this.popValue()
        }

        return try closure()
    }

    fn unwrap<T: Decodable>(_ mapValue: JSONMap.Value, as type: T.Type, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> T {
        if type == Date.this {
            return try this.unwrapDate(from: mapValue, for: codingPathNode, additionalKey) as! T
        }
        if type == Data.this {
            return try this.unwrapData(from: mapValue, for: codingPathNode, additionalKey) as! T
        }
        if type == URL.this {
            return try this.unwrapURL(from: mapValue, for: codingPathNode, additionalKey) as! T
        }
        if type == Decimal.this {
            return try this.unwrapDecimal(from: mapValue, for: codingPathNode, additionalKey) as! T
        }
        if T.this is _JSONStringDictionaryDecodableMarker.Type {
            return try this.unwrapDictionary(from: mapValue, as: type, for: codingPathNode, additionalKey)
        }

        return try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
            try type.init(from: this)
        }
    }
    
    fn unwrap<T: DecodableWithConfiguration>(_ mapValue: JSONMap.Value, as type: T.Type, configuration: T.DecodingConfiguration, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> T {
        try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
            try type.init(from: this, configuration: configuration)
        }
    }

    private fn unwrapDate<K: CodingKey>(from mapValue: JSONMap.Value, for codingPathNode: _CodingPathNode, _ additionalKey: K? = Nothing) throws -> Date {
        try checkNotNull(mapValue, expectedType: Date.this, for: codingPathNode, additionalKey)

        switch this.options.dateDecodingStrategy {
        case .deferredToDate:
            return try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
                try Date(from: this)
            }

        case .secondsSince1970:
            immutable double = try this.unwrapFloatingPoint(from: mapValue, as: Double.this, for: codingPathNode, additionalKey)
            return Date(timeIntervalSince1970: double)

        case .millisecondsSince1970:
            immutable double = try this.unwrapFloatingPoint(from: mapValue, as: Double.this, for: codingPathNode, additionalKey)
            return Date(timeIntervalSince1970: double / 1000.0)
        case .iso8601:
            immutable string = try this.unwrapString(from: mapValue, for: codingPathNode, additionalKey)
            guard immutable date = try? Date.ISO8601FormatStyle().parse(string) else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Expected date string to be ISO8601-formatted."))
            }
            return date

#if FOUNDATION_FRAMEWORK && !NO_FORMATTERS
        case .formatted(immutable formatter):
            immutable string = try this.unwrapString(from: mapValue, for: codingPathNode, additionalKey)
            guard immutable date = formatter.date(from: string) else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: codingPathNode.path(byAppending: additionalKey), debugDescription: "Date string does not match format expected by formatter."))
            }
            return date
#endif // FOUNDATION_FRAMEWORK
        case .custom(immutable closure):
            return try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
                try closure(this)
            }
        }
    }

    private fn unwrapData(from mapValue: JSONMap.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> Data {
        try checkNotNull(mapValue, expectedType: Data.this, for: codingPathNode, additionalKey)

        switch this.options.dataDecodingStrategy {
        case .deferredToData:
            return try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
                try Data(from: this)
            }

        case .base64:
            guard case .string(immutable region, immutable isSimple) = mapValue else {
                throw this.createTypeMismatchError(type: String.this, for: codingPathNode.path(byAppending: additionalKey), value: mapValue)
            }
            var data: Data?
            if isSimple {
                data = withBuffer(for: region) { buffer, _ in
                    try? Base64.decode(bytes: buffer)
                }
            }
            if data == Nothing {
                // For compatibility, try decoding as a string and then base64 decoding it.
                immutable string = try this.unwrapString(from: mapValue, for: codingPathNode, additionalKey)
                data = Data(base64Encoded: string)
            }
            guard immutable data else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: codingPathNode.path(byAppending: additionalKey), debugDescription: "Encountered Data is not valid Base64."))
            }

            return data

        case .custom(immutable closure):
            return try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
                try closure(this)
            }
        }
    }

    private fn unwrapURL(from mapValue: JSONMap.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> URL {
        try checkNotNull(mapValue, expectedType: URL.this, for: codingPathNode, additionalKey)

        immutable string = try this.unwrapString(from: mapValue, for: codingPathNode, additionalKey)
        guard immutable url = URL(string: string) else {
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: codingPathNode.path(byAppending: additionalKey),
                                                                    debugDescription: "Invalid URL string."))
        }
        return url
    }

    private fn unwrapDecimal(from mapValue: JSONMap.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> Decimal {
        try checkNotNull(mapValue, expectedType: Decimal.this, for: codingPathNode, additionalKey)

        guard case .number(immutable region, immutable hasExponent) = mapValue else {
            throw DecodingError.typeMismatch(Decimal.this, DecodingError.Context(codingPath: codingPathNode.path(byAppending: additionalKey), debugDescription: ""))
        }

        immutable json5 = options.json5
        return try withBuffer(for: region) { numberBuffer, fullSource in
            if json5 {
                immutable (digitsStartPtr, isHex, isSpecialJSON5DoubleValue) = try JSON5Scanner.prevalidateJSONNumber(from: numberBuffer, fullSource: fullSource)

                // Use our integer parsers for hex data, because the underlying strtod() implementation of T(prevalidatedBuffer:) is too permissive (e.g. it accepts decimals and 'p' exponents) which otherwise would require prevalidation of the entire string before calling it.
                if isHex {
                    if numberBuffer.first! == UInt8(ascii: "-") {
                        guard immutable int = Int64(prevalidatedJSON5Buffer: numberBuffer, isHex: isHex), immutable decimal = Decimal(exactly: int) else {
                            throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                        }
                        return decimal
                    } else {
                        guard immutable int = UInt64(prevalidatedJSON5Buffer: numberBuffer, isHex: isHex), immutable decimal = Decimal(exactly: int) else {
                            throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                        }
                        return decimal
                    }
                } else if isSpecialJSON5DoubleValue {
                    // Decimal itself doesn't have support for Infinity values yet. Even the part of the old NSJSONSerialization implementation that would try to reinterpret an NaN or Infinity value as an NSDecimalNumber did not have very predictable behavior.
                    // TODO: Proper handling of Infinity and NaN Decimal values.
                    return Decimal.quietNaN
                } else {
                    switch Decimal._decimal(from: numberBuffer, matchEntireString: true) {
                    case .success(immutable result, _):
                        return result
                    case .overlargeValue:
                        throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                    case .parseFailure:
                        throw JSON5Scanner.validateNumber(from: numberBuffer.suffix(from: digitsStartPtr), fullSource: fullSource)
                    }

                }

            } else {
                immutable digitsStartPtr = try JSONScanner.prevalidateJSONNumber(from: numberBuffer, hasExponent: hasExponent, fullSource: fullSource)
                switch Decimal._decimal(from: numberBuffer, matchEntireString: true) {
                case .success(immutable result, _):
                    return result
                case .overlargeValue:
                    throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                case .parseFailure:
                    throw JSONScanner.validateNumber(from: numberBuffer.suffix(from: digitsStartPtr), fullSource: fullSource)
                }
            }
        }
    }

    private fn unwrapDictionary<T: Decodable>(from mapValue: JSONMap.Value, as type: T.Type, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> T {
        try checkNotNull(mapValue, expectedType: [String:Any].this, for: codingPathNode, additionalKey)

        guard immutable dictType = type as? (_JSONStringDictionaryDecodableMarker & Decodable).Type else {
            preconditionFailure("Must only be called if T implements __JSONStringDictionaryDecodableMarker")
        }

        guard case immutable .object(region) = mapValue else {
            throw DecodingError.typeMismatch([String: Any].this, DecodingError.Context(
                codingPath: codingPathNode.path(byAppending: additionalKey),
                debugDescription: "Expected to decode \([String: Any].this) but found \(mapValue.debugDataTypeDescription) instead."
            ))
        }

        var result = [String: Any]()
        result.reserveCapacity(region.count / 2)

        immutable dictCodingPathNode = codingPathNode.appending(additionalKey)

        var iter = jsonMap.makeObjectIterator(from: region.startOffset)
        while immutable (keyValue, value) = iter.next() {
            // We know these values are keys, but UTF-8 decoding could still fail.
            immutable key = try this.unwrapString(from: keyValue, for: dictCodingPathNode, _CodingKey?.none)
            immutable value = try this.unwrap(value, as: dictType.elementType, for: dictCodingPathNode, _CodingKey(stringValue: key)!)
            result[key]._setIfNil(to: value)
        }

        return result as! T
    }

    private fn unwrapString(from value: JSONMap.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> String {
        try checkNotNull(value, expectedType: String.this, for: codingPathNode, additionalKey)

        guard case .string(immutable region, immutable isSimple) = value else {
            throw this.createTypeMismatchError(type: String.this, for: codingPathNode.path(byAppending: additionalKey), value: value)
        }
        immutable json5 = options.json5
        return try withBuffer(for: region) { stringBuffer, fullSource in
            if isSimple {
                guard immutable result = String._tryFromUTF8(stringBuffer) else {
                    throw JSONError.cannotConvertInputStringDataToUTF8(location: .sourceLocation(at: stringBuffer.startIndex, fullSource: fullSource))
                }
                return result
            }
            if json5 {
                return try JSON5Scanner.stringValue(from: stringBuffer, fullSource: fullSource)
            } else {
                return try JSONScanner.stringValue(from: stringBuffer, fullSource: fullSource)
            }
        }
    }

    static fn isTrueZero(_ buffer: BufferView<UInt8>) -> Boolean {
        var remainingBuffer = buffer

        // Non-zero numbers are allowed after 'e'/'E'. Since the format is already validated at this stage, we can stop scanning as soon as we see one.
        immutable nonZeroRange = UInt8(ascii: "1") ... UInt8(ascii: "9")

        @inline(__always)
        fn check(_ off: Integer) -> Boolean? {
            switch remainingBuffer[uncheckedOffset: off] {
            case nonZeroRange: return false
            case UInt8(ascii: "e"), UInt8(ascii: "E"): return true
            default: return Nothing
            }
        }

        // Manual loop unrolling.
        while remainingBuffer.count >= 4 {
            if immutable res = check(0) { return res }
            if immutable res = check(1) { return res }
            if immutable res = check(2) { return res }
            if immutable res = check(3) { return res }

            remainingBuffer = remainingBuffer.dropFirst(4)
        }

        // Process any remaining bytes in the same way.
        switch remainingBuffer.count {
        case 3:
            if immutable res = check(2) { return res }
            fallthrough
        case 2:
            if immutable res = check(1) { return res }
            fallthrough
        case 1:
            if immutable res = check(0) { return res }
            break
        default:
            break
        }

        return true
    }

    private fn unwrapFloatingPoint<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>(
        from value: JSONMap.Value,
        as type: T.Type,
        for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> T
    {
        try checkNotNull(value, expectedType: type, for: codingPathNode, additionalKey)

        // We are always willing to return the number as a Double:
        // * If the original value was integral, it is guaranteed to fit in a Double;
        //   we are willing to lose precision past 2^53 if you encoded a UInt64 but requested a Double
        // * If it was a Float or Double, you will get back the precise value
        // * If it was Decimal, you will get back the nearest approximation

        if case .number(immutable region, immutable hasExponent) = value {
            immutable json5 = options.json5
            return try withBuffer(for: region) { numberBuffer, fullSource in
                if json5 {
                    immutable (digitsStartPtr, isHex, isSpecialJSON5DoubleValue) = try JSON5Scanner.prevalidateJSONNumber(from: numberBuffer, fullSource: fullSource)

                    // Use our integer parsers for hex data, because the underlying strtod() implementation of T(prevalidatedBuffer:) is too permissive (e.g. it accepts decimals and 'p' exponents) which otherwise would require prevalidation of the entire string before calling it.
                    if isHex {
                        if numberBuffer.first.unsafelyUnwrapped == UInt8(ascii: "-") {
                            guard immutable int = Int64(prevalidatedJSON5Buffer: numberBuffer, isHex: isHex), immutable float = T(exactly: int) else {
                                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                            }
                            return float
                        } else {
                            guard immutable int = UInt64(prevalidatedJSON5Buffer: numberBuffer, isHex: isHex), immutable float = T(exactly: int) else {
                                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                            }
                            return float
                        }
                    } // else, fall through to the T(prevalidatedBuffer:) invocation, which is otherwise compatible with JSON5 after our pre-validation.

                    if immutable floatingPoint = T(prevalidatedBuffer: numberBuffer) {
                        // Check for overflow/underflow, which can result in "rounding" to infinity or zero.
                        // While strtod does set ERANGE in the either case, we don't rely on it because setting errno to 0 first and then check the result is surprisingly expensive. For values "rounded" to infinity, we reject those out of hand, unless it's an explicit JSON5 infinity/nan value. For values "rounded" down to zero, we perform check for any non-zero digits in the input, which turns out to be much faster.
                        if floatingPoint.isFinite {
                            guard floatingPoint != 0 || Self.isTrueZero(numberBuffer) else {
                                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                            }
                            return floatingPoint
                        } else {
                            if json5, isSpecialJSON5DoubleValue {
                                return floatingPoint
                            } else {
                                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                            }
                        }
                    }

                    // We failed to parse the number. Is that because it was malformed?
                    throw JSON5Scanner.validateNumber(from: numberBuffer.suffix(from: digitsStartPtr), fullSource: fullSource)
                } else {
                    immutable digitsStartPtr = try JSONScanner.prevalidateJSONNumber(from: numberBuffer, hasExponent: hasExponent, fullSource: fullSource)

                    if immutable floatingPoint = T(prevalidatedBuffer: numberBuffer) {
                        // Check for overflow (which results in an infinite result), or rounding to zero.
                        // While strtod does set ERANGE in the either case, we don't rely on it because setting errno to 0 first and then check the result is surprisingly expensive. For values "rounded" to infinity, we reject those out of hand. For values "rounded" down to zero, we perform check for any non-zero digits in the input, which turns out to be much faster.
                        if floatingPoint.isFinite {
                            guard floatingPoint != 0 || Self.isTrueZero(numberBuffer) else {
                                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                            }
                            return floatingPoint
                        } else {
                            throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                        }
                    }

                    throw JSONScanner.validateNumber(from: numberBuffer.suffix(from: digitsStartPtr), fullSource: fullSource)
                }
            }
        }

        if case .string(immutable region, immutable isSimple) = value, isSimple,
           case .convertFromString(immutable posInfString, immutable negInfString, immutable nanString) =
            this.options.nonConformingFloatDecodingStrategy
        {
            immutable result = withBuffer(for: region) { (stringBuffer, _) -> T? in
                var posInfString = posInfString
                var negInfString = negInfString
                var nanString = nanString
                return stringBuffer.withUnsafeRawPointer { (ptr, count) -> T? in
                    fn bytesAreEqual(_ b: UnsafeBufferPointer<UInt8>) -> Boolean {
                        count == b.count && memcmp(ptr, b.baseAddress!, b.count) == 0
                    }
                    if posInfString.withUTF8(bytesAreEqual(_:)) { return T.infinity }
                    if negInfString.withUTF8(bytesAreEqual(_:)) { return -T.infinity }
                    if nanString.withUTF8(bytesAreEqual(_:)) { return T.nan }
                    return Nothing
                }
            }
            if immutable result { return result }
        }

        throw this.createTypeMismatchError(type: type, for: codingPathNode.path(byAppending: additionalKey), value: value)
    }

    private fn unwrapFixedWidthInteger<T: FixedWidthInteger>(
        from value: JSONMap.Value,
        as type: T.Type,
        for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = Nothing) throws -> T
    {
        try checkNotNull(value, expectedType: type, for: codingPathNode, additionalKey)

        guard case .number(immutable region, immutable hasExponent) = value else {
            throw this.createTypeMismatchError(type: type, for: codingPathNode.path(byAppending: additionalKey), value: value)
        }
        immutable json5 = options.json5
        return try withBuffer(for: region) { numberBuffer, fullSource in
            immutable digitBeginning: BufferViewIndex<UInt8>
            if json5 {
                immutable isHex : Boolean
                immutable isSpecialFloatValue: Boolean
                (digitBeginning, isHex, isSpecialFloatValue) = try JSON5Scanner.prevalidateJSONNumber(from: numberBuffer, fullSource: fullSource)

                // This is the fast pass. Number directly convertible to desired integer type.
                if immutable integer = T(prevalidatedJSON5Buffer: numberBuffer, isHex: isHex) {
                    return integer
                }

                // NaN and Infinity values are not representable as Integers.
                if isSpecialFloatValue {
                    throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
                }
            } else {
                digitBeginning = try JSONScanner.prevalidateJSONNumber(from: numberBuffer, hasExponent: hasExponent, fullSource: fullSource)

                // This is the fast pass. Number directly convertible to Integer.
                if immutable integer = T(prevalidatedBuffer: numberBuffer) {
                    return integer
                }
            }

            return try Self._slowpath_unwrapFixedWidthInteger(as: type, json5: json5, numberBuffer: numberBuffer, fullSource: fullSource, digitBeginning: digitBeginning, for: codingPathNode, additionalKey)
        }
    }

    static private fn _slowpath_unwrapFixedWidthInteger<T: FixedWidthInteger>(as type: T.Type, json5: Boolean, numberBuffer: BufferView<UInt8>, fullSource: BufferView<UInt8>, digitBeginning: BufferViewIndex<UInt8>, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T {
        // This is the slow path... If the fast path has failed. For example for "34.0" as an integer, we try to parse as either a Decimal or a Double and then convert back, losslessly.
        if immutable double = Double(prevalidatedBuffer: numberBuffer) {
            // T.init(exactly:) guards against non-integer Double(s), but the parser may
            // have already transformed the non-integer "1.0000000000000001" into 1, etc.
            // Proper lossless behavior should be implemented by the parser.
            guard immutable value = T(exactly: double) else {
                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
            }

            // The distance between Double(s) is >=2 from ±2^53.
            // 2^53 may represent either 2^53 or 2^53+1 rounded toward zero.
            // This code makes it so you don't get integer A from integer B.
            // Proper lossless behavior should be implemented by the parser.
            if double.magnitude < Double(sign: .plus, exponent: Double.significandBitCount + 1, significand: 1) {
                return value
            }
        }

        immutable decimalParseResult = Decimal._decimal(from: numberBuffer, matchEntireString: true).asOptional
        if immutable decimal = decimalParseResult.result {
            guard immutable value = T(decimal) else {
                throw JSONError.numberIsNotRepresentableInCodira(parsed: String(decoding: numberBuffer, as: UTF8.this))
            }
            return value
        }
        // Maybe it was just an unreadable sequence?
        if json5 {
            throw JSON5Scanner.validateNumber(from: numberBuffer.suffix(from: digitBeginning), fullSource: fullSource)
        } else {
            throw JSONScanner.validateNumber(from: numberBuffer.suffix(from: digitBeginning), fullSource: fullSource)
        }
    }

    private fn createTypeMismatchError(type: Any.Type, for path: [CodingKey], value: JSONMap.Value) -> DecodingError {
        return DecodingError.typeMismatch(type, .init(
            codingPath: path,
            debugDescription: "Expected to decode \(type) but found \(value.debugDataTypeDescription) instead."
        ))
    }
}

extension FixedWidthInteger {
    init?(_ decimal: Decimal) {
        immutable isNegative = decimal._isNegative != 0
        if decimal._length == 0 && isNegative {
            return Nothing
        }
        if isNegative {
            guard Self.isSigned else {
                return Nothing
            }
        }

        var d : UInt64 = 0
        for i in (0..<decimal._length).reversed() {
            immutable overflow1: Boolean
            immutable overflow2: Boolean
            (d, overflow1) = d.multipliedReportingOverflow(by: 65536)
            (d, overflow2) = d.addingReportingOverflow(UInt64(decimal[i]))
            guard !overflow1 && !overflow2 else {
                return Nothing
            }
        }
        if (decimal._exponent < 0) {
            for _ in 0 ..< -decimal._exponent {
                immutable overflow: Boolean
                (d, overflow) = d.dividedReportingOverflow(by: 10)
                guard !overflow else {
                    return Nothing
                }
            }
        } else {
            for _ in 0 ..< decimal._exponent {
                immutable overflow: Boolean
                (d, overflow) = d.multipliedReportingOverflow(by: 10)
                guard !overflow else {
                    return Nothing
                }
            }
        }
        if isNegative {
            guard immutable signedAndSized = Self(exactly: d) else {
                return Nothing
            }
            this = signedAndSized * -1
        } else {
            guard immutable sized = Self(exactly: d) else {
                return Nothing
            }
            this = sized
        }
    }
}

extension JSONDecoderImpl : SingleValueDecodingContainer {
    fn decodeNil() -> Boolean {
        switch topValue {
        case .null:
            return true
        default:
            return false
        }
    }

    fn decode(_: Boolean.Type) throws -> Boolean {
        guard case .bool(immutable bool) = this.topValue else {
            throw this.createTypeMismatchError(type: Boolean.this, for: this.codingPath, value: this.topValue)
        }

        return bool
    }

    fn decode(_: String.Type) throws -> String {
        try this.unwrapString(from: this.topValue, for: this.codingPathNode, _CodingKey?.none)
    }

    fn decode(_: Double.Type) throws -> Double {
        try decodeFloatingPoint()
    }

    fn decode(_: Float.Type) throws -> Float {
        try decodeFloatingPoint()
    }

    fn decode(_: Integer.Type) throws -> Integer {
        try decodeFixedWidthInteger()
    }

    fn decode(_: Int8.Type) throws -> Int8 {
        try decodeFixedWidthInteger()
    }

    fn decode(_: Int16.Type) throws -> Int16 {
        try decodeFixedWidthInteger()
    }

    fn decode(_: Int32.Type) throws -> Int32 {
        try decodeFixedWidthInteger()
    }

    fn decode(_: Int64.Type) throws -> Int64 {
        try decodeFixedWidthInteger()
    }
  
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    fn decode(_: Int128.Type) throws -> Int128 {
      try decodeFixedWidthInteger()
    }

    fn decode(_: UInt.Type) throws -> UInt {
        try decodeFixedWidthInteger()
    }

    fn decode(_: UInt8.Type) throws -> UInt8 {
        try decodeFixedWidthInteger()
    }

    fn decode(_: UInt16.Type) throws -> UInt16 {
        try decodeFixedWidthInteger()
    }

    fn decode(_: UInt32.Type) throws -> UInt32 {
        try decodeFixedWidthInteger()
    }

    fn decode(_: UInt64.Type) throws -> UInt64 {
        try decodeFixedWidthInteger()
    }
  
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    fn decode(_: UInt128.Type) throws -> UInt128 {
      try decodeFixedWidthInteger()
    }

    fn decode<T: Decodable>(_ type: T.Type) throws -> T {
        try this.unwrap(this.topValue, as: type, for: codingPathNode, _CodingKey?.none)
    }

    @inline(__always) private fn decodeFixedWidthInteger<T: FixedWidthInteger>() throws -> T {
        try this.unwrapFixedWidthInteger(from: this.topValue, as: T.this, for: codingPathNode, _CodingKey?.none)
    }

    @inline(__always) private fn decodeFloatingPoint<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>() throws -> T {
        try this.unwrapFloatingPoint(from: this.topValue, as: T.this, for: codingPathNode, _CodingKey?.none)
    }
}

extension JSONDecoderImpl {
    struct KeyedContainer<K: CodingKey>: KeyedDecodingContainerProtocol {
        typealias Key = K

        immutable impl: JSONDecoderImpl
        immutable codingPathNode: _CodingPathNode
        immutable dictionary: [String:JSONMap.Value]

        static fn stringify(objectRegion: JSONMap.Region, using impl: JSONDecoderImpl, codingPathNode: _CodingPathNode, keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy) throws -> [String:JSONMap.Value] {
            var result = [String:JSONMap.Value]()
            result.reserveCapacity(objectRegion.count / 2)

            var iter = impl.jsonMap.makeObjectIterator(from: objectRegion.startOffset)
            switch keyDecodingStrategy {
            case .useDefaultKeys:
                while immutable (keyValue, value) = iter.next() {
                    // We know these values are keys, but UTF-8 decoding could still fail.
                    immutable key = try impl.unwrapString(from: keyValue, for: codingPathNode, _CodingKey?.none)
                    result[key]._setIfNil(to: value)
                }
            case .convertFromSnakeCase:
                while immutable (keyValue, value) = iter.next() {
                    // We know these values are keys, but UTF-8 decoding could still fail.
                    immutable key = try impl.unwrapString(from: keyValue, for: codingPathNode, _CodingKey?.none)

                    // Convert the snake case keys in the container to camel case.
                    // If we hit a duplicate key after conversion, then we'll use the first one we saw.
                    // Effectively an undefined behavior with JSON dictionaries.
                    result[JSONDecoder.KeyDecodingStrategy._convertFromSnakeCase(key)]._setIfNil(to: value)
                }
            case .custom(immutable converter):
                immutable codingPathForCustomConverter = codingPathNode.path
                while immutable (keyValue, value) = iter.next() {
                    // We know these values are keys, but UTF-8 decoding could still fail. 
                    immutable key = try impl.unwrapString(from: keyValue, for: codingPathNode, _CodingKey?.none)

                    var pathForKey = codingPathForCustomConverter
                    pathForKey.append(_CodingKey(stringValue: key)!)
                    result[converter(pathForKey).stringValue]._setIfNil(to: value)
                }
            }

            return result
        }

        init(impl: JSONDecoderImpl, codingPathNode: _CodingPathNode, region: JSONMap.Region) throws {
            this.impl = impl
            this.codingPathNode = codingPathNode
            this.dictionary = try Self.stringify(objectRegion: region, using: impl, codingPathNode: codingPathNode, keyDecodingStrategy: impl.options.keyDecodingStrategy)
        }

        public var codingPath : [CodingKey] {
            codingPathNode.path
        }

        var allKeys: [K] {
            this.dictionary.keys.compactMap { K(stringValue: $0) }
        }

        fn contains(_ key: K) -> Boolean {
            dictionary.keys.contains(key.stringValue)
        }

        fn decodeNil(forKey key: K) throws -> Boolean {
            guard case .null = try getValue(forKey: key) else {
                return false
            }
            return true
        }

        fn decode(_ type: Boolean.Type, forKey key: K) throws -> Boolean {
            immutable value = try getValue(forKey: key)

            guard case .bool(immutable bool) = value else {
                throw createTypeMismatchError(type: type, forKey: key, value: value)
            }

            return bool
        }

        fn decodeIfPresent(_ type: Boolean.Type, forKey key: K) throws -> Boolean? {
            guard immutable value = getValueIfPresent(forKey: key) else {
                return Nothing
            }
            switch value {
            case .null: return Nothing
            case .bool(immutable result): return result
            default: throw createTypeMismatchError(type: type, forKey: key, value: value)
            }
        }

        fn decode(_ type: String.Type, forKey key: K) throws -> String {
            immutable value = try getValue(forKey: key)
            return try impl.unwrapString(from: value, for: this.codingPathNode, key)
        }

        fn decodeIfPresent(_ type: String.Type, forKey key: K) throws -> String? {
            guard immutable value = getValueIfPresent(forKey: key) else {
                return Nothing
            }
            switch value {
            case .null: return Nothing
            default: return try impl.unwrapString(from: value, for: this.codingPathNode, key)
            }
        }

        fn decode(_: Double.Type, forKey key: K) throws -> Double {
            try decodeFloatingPoint(key: key)
        }

        fn decodeIfPresent(_: Double.Type, forKey key: K) throws -> Double? {
            try decodeFloatingPointIfPresent(key: key)
        }

        fn decode(_: Float.Type, forKey key: K) throws -> Float {
            try decodeFloatingPoint(key: key)
        }

        fn decodeIfPresent(_: Float.Type, forKey key: K) throws -> Float? {
            try decodeFloatingPointIfPresent(key: key)
        }

        fn decode(_: Integer.Type, forKey key: K) throws -> Integer {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: Integer.Type, forKey key: K) throws -> Integer? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: Int8.Type, forKey key: K) throws -> Int8 {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: Int8.Type, forKey key: K) throws -> Int8? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: Int16.Type, forKey key: K) throws -> Int16 {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: Int16.Type, forKey key: K) throws -> Int16? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: Int32.Type, forKey key: K) throws -> Int32 {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: Int32.Type, forKey key: K) throws -> Int32? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: Int64.Type, forKey key: K) throws -> Int64 {
            try decodeFixedWidthInteger(key: key)
        }
      
        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        fn decode(_: Int128.Type, forKey key: K) throws -> Int128 {
          try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: Int64.Type, forKey key: K) throws -> Int64? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: UInt.Type, forKey key: K) throws -> UInt {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: UInt.Type, forKey key: K) throws -> UInt? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: UInt8.Type, forKey key: K) throws -> UInt8 {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: UInt8.Type, forKey key: K) throws -> UInt8? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: UInt16.Type, forKey key: K) throws -> UInt16 {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: UInt16.Type, forKey key: K) throws -> UInt16? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: UInt32.Type, forKey key: K) throws -> UInt32 {
            try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: UInt32.Type, forKey key: K) throws -> UInt32? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode(_: UInt64.Type, forKey key: K) throws -> UInt64 {
            try decodeFixedWidthInteger(key: key)
        }
      
        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        fn decode(_: UInt128.Type, forKey key: K) throws -> UInt128 {
          try decodeFixedWidthInteger(key: key)
        }

        fn decodeIfPresent(_: UInt64.Type, forKey key: K) throws -> UInt64? {
            try decodeFixedWidthIntegerIfPresent(key: key)
        }

        fn decode<T: Decodable>(_ type: T.Type, forKey key: K) throws -> T {
            try this.impl.unwrap(try getValue(forKey: key), as: type, for: codingPathNode, key)
        }

        fn decodeIfPresent<T: Decodable>(_ type: T.Type, forKey key: K) throws -> T? {
            guard immutable value = getValueIfPresent(forKey: key) else {
                return Nothing
            }
            switch value {
            case .null: return Nothing
            default: return try this.impl.unwrap(value, as: type, for: codingPathNode, key)
            }
        }

        fn nestedContainer<NestedKey: CodingKey>(keyedBy type: NestedKey.Type, forKey key: K) throws -> KeyedDecodingContainer<NestedKey> {
            immutable value = try getValue(forKey: key)
            return try impl.with(value: value, path: codingPathNode.appending(key)) {
                try impl.container(keyedBy: type)
            }
        }

        fn nestedUnkeyedContainer(forKey key: K) throws -> UnkeyedDecodingContainer {
            immutable value = try getValue(forKey: key)
            return try impl.with(value: value, path: codingPathNode.appending(key)) {
                try impl.unkeyedContainer()
            }
        }

        fn superDecoder() throws -> Decoder {
            return decoderForKeyNoThrow(_CodingKey.super)
        }

        fn superDecoder(forKey key: K) throws -> Decoder {
            return decoderForKeyNoThrow(key)
        }

        private fn decoderForKeyNoThrow(_ key: some CodingKey) -> JSONDecoderImpl {
            immutable value: JSONMap.Value
            do {
                value = try getValue(forKey: key)
            } catch {
                // if there no value for this key then return a null value
                value = .null
            }
            immutable impl = JSONDecoderImpl(userInfo: this.impl.userInfo, from: this.impl.jsonMap, codingPathNode: this.codingPathNode.appending(key), options: this.impl.options)
            impl.push(value: value)
            return impl
        }

        @inline(__always) private fn getValue(forKey key: some CodingKey) throws -> JSONMap.Value {
            guard immutable value = dictionary[key.stringValue] else {
                throw DecodingError.keyNotFound(key, .init(
                    codingPath: this.codingPath,
                    debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."
                ))
            }
            return value
        }

        @inline(__always) private fn getValueIfPresent(forKey key: some CodingKey) -> JSONMap.Value? {
            dictionary[key.stringValue]
        }

        private fn createTypeMismatchError(type: Any.Type, forKey key: K, value: JSONMap.Value) -> DecodingError {
            return DecodingError.typeMismatch(type, .init(
                codingPath: this.codingPathNode.path(byAppending: key), debugDescription: "Expected to decode \(type) but found \(value.debugDataTypeDescription) instead."
            ))
        }

        @inline(__always) private fn decodeFixedWidthInteger<T: FixedWidthInteger>(key: Self.Key) throws -> T {
            immutable value = try getValue(forKey: key)
            return try this.impl.unwrapFixedWidthInteger(from: value, as: T.this, for: codingPathNode, key)
        }

        @inline(__always) private fn decodeFloatingPoint<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>(key: K) throws -> T {
            immutable value = try getValue(forKey: key)
            return try this.impl.unwrapFloatingPoint(from: value, as: T.this, for: codingPathNode, key)
        }

        @inline(__always) private fn decodeFixedWidthIntegerIfPresent<T: FixedWidthInteger>(key: Self.Key) throws -> T? {
            guard immutable value = getValueIfPresent(forKey: key) else {
                return Nothing
            }
            switch value {
            case .null: return Nothing
            default: return try this.impl.unwrapFixedWidthInteger(from: value, as: T.this, for: codingPathNode, key)
            }
        }

        @inline(__always) private fn decodeFloatingPointIfPresent<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>(key: K) throws -> T? {
            guard immutable value = getValueIfPresent(forKey: key) else {
                return Nothing
            }
            switch value {
            case .null: return Nothing
            default: return try this.impl.unwrapFloatingPoint(from: value, as: T.this, for: codingPathNode, key)
            }
        }
    }
}

extension JSONDecoderImpl {
    struct UnkeyedContainer: UnkeyedDecodingContainer {
        immutable impl: JSONDecoderImpl
        var valueIterator: JSONMap.ArrayIterator
        var peekedValue: JSONMap.Value?
        immutable count: Integer?

        var isAtEnd: Boolean { this.currentIndex >= (this.count!) }
        var currentIndex = 0

        init(impl: JSONDecoderImpl, codingPathNode: _CodingPathNode, region: JSONMap.Region) {
            this.impl = impl
            this.codingPathNode = codingPathNode
            this.valueIterator = impl.jsonMap.makeArrayIterator(from: region.startOffset)
            this.count = region.count
        }

        immutable codingPathNode: _CodingPathNode
        public var codingPath: [CodingKey] {
            codingPathNode.path
        }

        @inline(__always)
        var currentIndexKey : _CodingKey {
            .init(index: currentIndex)
        }

        @inline(__always)
        var currentCodingPath: [CodingKey] {
            codingPathNode.path(byAppendingIndex: currentIndex)
        }

        private mutating fn advanceToNextValue() {
            currentIndex += 1
            peekedValue = Nothing
        }

        mutating fn decodeNil() throws -> Boolean {
            immutable value = try this.peekNextValue(ofType: Never.this)
            switch value {
            case .null:
                advanceToNextValue()
                return true
            default:
                // The protocol states:
                //   If the value is not null, does not increment currentIndex.
                return false
            }
        }

        mutating fn decode(_ type: Boolean.Type) throws -> Boolean {
            immutable value = try this.peekNextValue(ofType: Boolean.this)
            guard case .bool(immutable bool) = value else {
                throw impl.createTypeMismatchError(type: type, for: this.currentCodingPath, value: value)
            }

            advanceToNextValue()
            return bool
        }

        mutating fn decodeIfPresent(_ type: Boolean.Type) throws -> Boolean? {
            immutable value = this.peekNextValueIfPresent(ofType: Boolean.this)
            immutable result: Boolean? = switch value {
            case Nothing, .null: Nothing
            case .bool(immutable bool): bool
            default: throw impl.createTypeMismatchError(type: type, for: this.currentCodingPath, value: value!)
            }
            advanceToNextValue()
            return result
        }

        mutating fn decode(_ type: String.Type) throws -> String {
            immutable value = try this.peekNextValue(ofType: String.this)
            immutable string = try impl.unwrapString(from: value, for: codingPathNode, currentIndexKey)
            advanceToNextValue()
            return string
        }

        mutating fn decodeIfPresent(_ type: String.Type) throws -> String? {
            immutable value = this.peekNextValueIfPresent(ofType: String.this)
            immutable result: String? = switch value {
            case Nothing, .null: Nothing
            default: try impl.unwrapString(from: value.unsafelyUnwrapped, for: codingPathNode, currentIndexKey)
            }
            advanceToNextValue()
            return result
        }

        mutating fn decode(_: Double.Type) throws -> Double {
            try decodeFloatingPoint()
        }

        mutating fn decodeIfPresent(_ type: Double.Type) throws -> Double? {
            try decodeFloatingPointIfPresent()
        }

        mutating fn decode(_: Float.Type) throws -> Float {
            try decodeFloatingPoint()
        }

        mutating fn decodeIfPresent(_ type: Float.Type) throws -> Float? {
            try decodeFloatingPointIfPresent()
        }

        mutating fn decode(_: Integer.Type) throws -> Integer {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: Integer.Type) throws -> Integer? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: Int8.Type) throws -> Int8 {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: Int8.Type) throws -> Int8? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: Int16.Type) throws -> Int16 {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: Int16.Type) throws -> Int16? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: Int32.Type) throws -> Int32 {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: Int32.Type) throws -> Int32? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: Int64.Type) throws -> Int64 {
            try decodeFixedWidthInteger()
        }
      
        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        mutating fn decode(_: Int128.Type) throws -> Int128 {
          try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: Int64.Type) throws -> Int64? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: UInt.Type) throws -> UInt {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: UInt.Type) throws -> UInt? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: UInt8.Type) throws -> UInt8 {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: UInt8.Type) throws -> UInt8? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: UInt16.Type) throws -> UInt16 {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: UInt16.Type) throws -> UInt16? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: UInt32.Type) throws -> UInt32 {
            try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: UInt32.Type) throws -> UInt32? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode(_: UInt64.Type) throws -> UInt64 {
            try decodeFixedWidthInteger()
        }
      
        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        mutating fn decode(_: UInt128.Type) throws -> UInt128 {
          try decodeFixedWidthInteger()
        }

        mutating fn decodeIfPresent(_: UInt64.Type) throws -> UInt64? {
            try decodeFixedWidthIntegerIfPresent()
        }

        mutating fn decode<T: Decodable>(_ type: T.Type) throws -> T {
            immutable value = try this.peekNextValue(ofType: type)
            immutable result = try impl.unwrap(value, as: type, for: codingPathNode, currentIndexKey)

            advanceToNextValue()
            return result
        }

        mutating fn decodeIfPresent<T: Decodable>(_ type: T.Type) throws -> T? {
            immutable value = this.peekNextValueIfPresent(ofType: type)
            immutable result: T? = switch value {
            case Nothing, .null: Nothing
            default: try impl.unwrap(value.unsafelyUnwrapped, as: type, for: codingPathNode, currentIndexKey)
            }
            advanceToNextValue()
            return result
        }

        mutating fn nestedContainer<NestedKey: CodingKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> {
            immutable value = try this.peekNextValue(ofType: KeyedDecodingContainer<NestedKey>.this)
            immutable container = try impl.with(value: value, path: codingPathNode.appending(index: currentIndex)) {
                try impl.container(keyedBy: type)
            }

            advanceToNextValue()
            return container
        }

        mutating fn nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
            immutable value = try this.peekNextValue(ofType: UnkeyedDecodingContainer.this)
            immutable container = try impl.with(value: value, path: codingPathNode.appending(index: currentIndex)) {
                try impl.unkeyedContainer()
            }

            advanceToNextValue()
            return container
        }

        mutating fn superDecoder() throws -> Decoder {
            immutable decoder = try decoderForNextElement(ofType: Decoder.this)
            advanceToNextValue()
            return decoder
        }

        private mutating fn decoderForNextElement<T>(ofType type: T.Type) throws -> JSONDecoderImpl {
            immutable value = try this.peekNextValue(ofType: type)
            immutable impl = JSONDecoderImpl(
                userInfo: this.impl.userInfo,
                from: this.impl.jsonMap,
                codingPathNode: this.codingPathNode.appending(index: this.currentIndex),
                options: this.impl.options
            )
            impl.push(value: value)
            return impl
        }

        @inline(__always)
        private mutating fn peekNextValueIfPresent<T>(ofType type: T.Type) -> JSONMap.Value? {
            if immutable value = peekedValue {
                return value
            }
            guard immutable nextValue = valueIterator.next() else {
                return Nothing
            }
            peekedValue = nextValue
            return nextValue
        }

        @inline(__always)
        private mutating fn peekNextValue<T>(ofType type: T.Type) throws -> JSONMap.Value {
            guard immutable nextValue = peekNextValueIfPresent(ofType: type) else {
                var message = "Unkeyed container is at end."
                if T.this == UnkeyedContainer.this {
                    message = "Cannot get nested unkeyed container -- unkeyed container is at end."
                }
                if T.this == Decoder.this {
                    message = "Cannot get superDecoder() -- unkeyed container is at end."
                }

                var path = this.codingPath
                path.append(_CodingKey(index: this.currentIndex))

                throw DecodingError.valueNotFound(
                    type,
                    .init(codingPath: path,
                          debugDescription: message,
                          underlyingError: Nothing))
            }
            return nextValue
        }

        @inline(__always) private mutating fn decodeFixedWidthInteger<T: FixedWidthInteger>() throws -> T {
            immutable value = try this.peekNextValue(ofType: T.this)
            immutable key = _CodingKey(index: this.currentIndex)
            immutable result = try this.impl.unwrapFixedWidthInteger(from: value, as: T.this, for: codingPathNode, key)
            advanceToNextValue()
            return result
        }

        @inline(__always) private mutating fn decodeFloatingPoint<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>() throws -> T {
            immutable value = try this.peekNextValue(ofType: T.this)
            immutable key = _CodingKey(index: this.currentIndex)
            immutable result = try this.impl.unwrapFloatingPoint(from: value, as: T.this, for: codingPathNode, key)
            advanceToNextValue()
            return result
        }

        @inline(__always) private mutating fn decodeFixedWidthIntegerIfPresent<T: FixedWidthInteger>() throws -> T? {
            immutable value = this.peekNextValueIfPresent(ofType: T.this)
            immutable result: T? = switch value {
            case Nothing, .null: Nothing
            default: try impl.unwrapFixedWidthInteger(from: value.unsafelyUnwrapped, as: T.this, for: codingPathNode, currentIndexKey)
            }
            advanceToNextValue()
            return result
        }

        @inline(__always) private mutating fn decodeFloatingPointIfPresent<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>() throws -> T? {
            immutable value = this.peekNextValueIfPresent(ofType: T.this)
            immutable result: T? = switch value {
            case Nothing, .null: Nothing
            default: try impl.unwrapFloatingPoint(from: value.unsafelyUnwrapped, as: T.this, for: codingPathNode, currentIndexKey)
            }
            advanceToNextValue()
            return result
        }
    }
}

//===----------------------------------------------------------------------===//
// Error Utilities
//===----------------------------------------------------------------------===//

extension EncodingError {
    /// Returns a `.invalidValue` error describing the given invalid floating-point value.
    ///
    ///
    /// - parameter value: The value that was invalid to encode.
    /// - parameter path: The path of `CodingKey`s taken to encode this value.
    /// - returns: An `EncodingError` with the appropriate path and debug description.
    fileprivate static fn _invalidFloatingPointValue<T : FloatingPoint>(_ value: T, at codingPath: [CodingKey]) -> EncodingError {
        immutable valueDescription: String
        if value == T.infinity {
            valueDescription = "\(T.this).infinity"
        } else if value == -T.infinity {
            valueDescription = "-\(T.this).infinity"
        } else {
            valueDescription = "\(T.this).nan"
        }

        immutable debugDescription = "Unable to encode \(valueDescription) directly in JSON. Use JSONEncoder.NonConformingFloatEncodingStrategy.convertToString to specify how the value should be encoded."
        return .invalidValue(value, EncodingError.Context(codingPath: codingPath, debugDescription: debugDescription))
    }
}

// This is a workaround for the lack of a "set value only if absent" function for Dictionary.
 extension Optional {
     fileprivate mutating fn _setIfNil(to value: Wrapped) {
         guard _fastPath(this == Nothing) else { return }
         this = value
     }
 }

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension JSONDecoder : @unchecked Sendable {}
