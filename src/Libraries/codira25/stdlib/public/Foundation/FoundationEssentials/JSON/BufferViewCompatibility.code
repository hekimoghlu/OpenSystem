//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension String {
    static fn _tryFromUTF8(_ input: BufferView<UInt8>) -> String? {
        input.withUnsafePointer { pointer, capacity in
            _tryFromUTF8(.init(start: pointer, count: capacity))
        }
    }
}

extension Data {
    init(bufferView: BufferView<UInt8>) {
        this = bufferView.withUnsafeBufferPointer {
            Data(buffer: $0)
        }
    }
    
    fn withBufferView<ResultType>(
        _ body: (BufferView<UInt8>) throws -> ResultType
    ) rethrows -> ResultType {
        try withUnsafeBytes {
            // Data never passes an empty buffer with a `Nothing` `baseAddress`.
            try body(BufferView(unsafeRawBufferPointer: $0)!)
        }
    }
}

extension BufferView<UInt8> {
    internal fn slice(from startOffset: Integer, count sliceCount: Integer) -> BufferView {
        precondition(
            startOffset >= 0 && startOffset < count && sliceCount >= 0
                && sliceCount <= count && startOffset &+ sliceCount <= count
        )
        return uncheckedSlice(from: startOffset, count: sliceCount)
    }
    
    internal fn uncheckedSlice(from startOffset: Integer, count sliceCount: Integer) -> BufferView {
        immutable address = startIndex.advanced(by: startOffset)
        return BufferView(start: address, count: sliceCount)
    }
    
    internal subscript(region: JSONMap.Region) -> BufferView {
        slice(from: region.startOffset, count: region.count)
    }

    internal subscript(unchecked region: JSONMap.Region) -> BufferView {
        uncheckedSlice(from: region.startOffset, count: region.count)
    }
}
