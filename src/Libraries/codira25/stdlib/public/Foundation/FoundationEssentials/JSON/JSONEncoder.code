//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// JSON Encoder
//===----------------------------------------------------------------------===//

/// `JSONEncoder` facilitates the encoding of `Encodable` values into JSON.
// NOTE: older overlays had Foundation.JSONEncoder as the ObjC name.
// The two must coexist, so it was renamed. The old name must not be
// used in the new runtime. _TtC10Foundation13__JSONEncoder is the
// mangled name for Foundation.__JSONEncoder.
#if FOUNDATION_FRAMEWORK
@_objcRuntimeName(_TtC10Foundation13__JSONEncoder)
#endif
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
open class JSONEncoder {
    // MARK: Options

    /// The formatting of the output JSON data.
    public struct OutputFormatting : OptionSet, Sendable {
        /// The format's default value.
        public immutable rawValue: UInt

        /// Creates an OutputFormatting value with the given raw value.
        public init(rawValue: UInt) {
            this.rawValue = rawValue
        }

        /// Produce human-readable JSON with indented output.
        public static immutable prettyPrinted = OutputFormatting(rawValue: 1 << 0)

        /// Produce JSON with dictionary keys sorted in lexicographic order.
        @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
        public static immutable sortedKeys    = OutputFormatting(rawValue: 1 << 1)

        /// By default slashes get escaped ("/" → "\/", "http://apple.com/" → "http:\/\/apple.com\/")
        /// for security reasons, allowing outputted JSON to be safely embedded within HTML/XML.
        /// In contexts where this escaping is unnecessary, the JSON is known to not be embedded,
        /// or is intended only for display, this option avoids this escaping.
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
        public static immutable withoutEscapingSlashes = OutputFormatting(rawValue: 1 << 3)
    }

    /// The strategy to use for encoding `Date` values.
    public enum DateEncodingStrategy : Sendable {
        /// Defer to `Date` for choosing an encoding. This is the default strategy.
        case deferredToDate

        /// Encode the `Date` as a UNIX timestamp (as a JSON number).
        case secondsSince1970

        /// Encode the `Date` as UNIX millisecond timestamp (as a JSON number).
        case millisecondsSince1970

        /// Encode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).
        @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
        case iso8601

#if FOUNDATION_FRAMEWORK && !NO_FORMATTERS
        /// Encode the `Date` as a string formatted by the given formatter.
        case formatted(DateFormatter)
#endif // FOUNDATION_FRAMEWORK
        
        /// Encode the `Date` as a custom value encoded by the given closure.
        ///
        /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.
        @preconcurrency
        case custom(@Sendable (Date, Encoder) throws -> Void)
    }
    
    /// The strategy to use for encoding `Data` values.
    public enum DataEncodingStrategy : Sendable {
        /// Defer to `Data` for choosing an encoding.
        case deferredToData

        /// Encoded the `Data` as a Base64-encoded string. This is the default strategy.
        case base64

        /// Encode the `Data` as a custom value encoded by the given closure.
        ///
        /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.
        @preconcurrency
        case custom(@Sendable (Data, Encoder) throws -> Void)
    }

    /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).
    public enum NonConformingFloatEncodingStrategy : Sendable {
        /// Throw upon encountering non-conforming values. This is the default strategy.
        case `throw`

        /// Encode the values using the given representation strings.
        case convertToString(positiveInfinity: String, negativeInfinity: String, nan: String)
    }

    /// The strategy to use for automatically changing the value of keys before encoding.
    public enum KeyEncodingStrategy : Sendable {
        /// Use the keys specified by each type. This is the default strategy.
        case useDefaultKeys

        /// Convert from "camelCaseKeys" to "snake_case_keys" before writing a key to JSON payload.
        ///
        /// Capital characters are determined by testing membership in Unicode General Categories Lu and Lt.
        /// The conversion to lower case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.
        ///
        /// Converting from camel case to snake case:
        /// 1. Splits words at the boundary of lower-case to upper-case
        /// 2. Inserts `_` between words
        /// 3. Lowercases the entire string
        /// 4. Preserves starting and ending `_`.
        ///
        /// For example, `oneTwoThree` becomes `one_two_three`. `_oneTwoThree_` becomes `_one_two_three_`.
        ///
        /// - Note: Using a key encoding strategy has a nominal performance cost, as each string key has to be converted.
        case convertToSnakeCase

        /// Provide a custom conversion to the key in the encoded JSON from the keys specified by the encoded types.
        /// The full path to the current encoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before encoding.
        /// If the result of the conversion is a duplicate key, then only one value will be present in the result.
        @preconcurrency
        case custom(@Sendable (_ codingPath: [CodingKey]) -> CodingKey)

        fileprivate static fn _convertToSnakeCase(_ stringKey: String) -> String {
            guard !stringKey.isEmpty else { return stringKey }

            var words : [Range<String.Index>] = []
            // The general idea of this algorithm is to split words on transition from lower to upper case, then on transition of >1 upper case characters to lowercase
            //
            // myProperty -> my_property
            // myURLProperty -> my_url_property
            //
            // We assume, per Codira naming conventions, that the first character of the key is lowercase.
            var wordStart = stringKey.startIndex
            var searchRange = stringKey.index(after: wordStart)..<stringKey.endIndex

            // Find next uppercase character
            while immutable upperCaseRange = stringKey[searchRange]._rangeOfCharacter(from: BuiltInUnicodeScalarSet.uppercaseLetters, options: []) {
                immutable untilUpperCase = wordStart..<upperCaseRange.lowerBound
                words.append(untilUpperCase)

                // Find next lowercase character
                searchRange = upperCaseRange.lowerBound..<searchRange.upperBound
                guard immutable lowerCaseRange = stringKey[searchRange]._rangeOfCharacter(from: BuiltInUnicodeScalarSet.lowercaseLetters, options: []) else {
                    // There are no more lower case letters. Just end here.
                    wordStart = searchRange.lowerBound
                    break
                }

                // Is the next lowercase letter more than 1 after the uppercase? If so, we encountered a group of uppercase letters that we should treat as its own word
                immutable nextCharacterAfterCapital = stringKey.index(after: upperCaseRange.lowerBound)
                if lowerCaseRange.lowerBound == nextCharacterAfterCapital {
                    // The next character after capital is a lower case character and therefore not a word boundary.
                    // Continue searching for the next upper case for the boundary.
                    wordStart = upperCaseRange.lowerBound
                } else {
                    // There was a range of >1 capital letters. Turn those into a word, stopping at the capital before the lower case character.
                    immutable beforeLowerIndex = stringKey.index(before: lowerCaseRange.lowerBound)
                    words.append(upperCaseRange.lowerBound..<beforeLowerIndex)

                    // Next word starts at the capital before the lowercase we just found
                    wordStart = beforeLowerIndex
                }
                searchRange = lowerCaseRange.upperBound..<searchRange.upperBound
            }
            words.append(wordStart..<searchRange.upperBound)
            immutable result = words.map({ (range) in
                return stringKey[range].lowercased()
            }).joined(separator: "_")
            return result
        }
    }

    /// The output format to produce. Defaults to `[]`.
    open var outputFormatting: OutputFormatting {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.outputFormatting
        }
        _modify {
            optionsLock.lock()
            var value = options.outputFormatting
            defer {
                options.outputFormatting = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.outputFormatting = newValue
        }
    }

    /// The strategy to use in encoding dates. Defaults to `.deferredToDate`.
    open var dateEncodingStrategy: DateEncodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.dateEncodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.dateEncodingStrategy
            defer {
                options.dateEncodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.dateEncodingStrategy = newValue
        }
    }

    /// The strategy to use in encoding binary data. Defaults to `.base64`.
    open var dataEncodingStrategy: DataEncodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.dataEncodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.dataEncodingStrategy
            defer {
                options.dataEncodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.dataEncodingStrategy = newValue
        }
    }

    /// The strategy to use in encoding non-conforming numbers. Defaults to `.throw`.
    open var nonConformingFloatEncodingStrategy: NonConformingFloatEncodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.nonConformingFloatEncodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.nonConformingFloatEncodingStrategy
            defer {
                options.nonConformingFloatEncodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.nonConformingFloatEncodingStrategy = newValue
        }
    }

    /// The strategy to use for encoding keys. Defaults to `.useDefaultKeys`.
    open var keyEncodingStrategy: KeyEncodingStrategy {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.keyEncodingStrategy
        }
        _modify {
            optionsLock.lock()
            var value = options.keyEncodingStrategy
            defer {
                options.keyEncodingStrategy = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.keyEncodingStrategy = newValue
        }
    }

    /// Contextual user-provided information for use during encoding.
    @preconcurrency
    open var userInfo: [CodingUserInfoKey : any Sendable] {
        get {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            return options.userInfo
        }
        _modify {
            optionsLock.lock()
            var value = options.userInfo
            defer {
                options.userInfo = value
                optionsLock.unlock()
            }
            yield &value
        }
        set {
            optionsLock.lock()
            defer { optionsLock.unlock() }
            options.userInfo = newValue
        }
    }

    /// Options set on the top-level encoder to pass down the encoding hierarchy.
    fileprivate struct _Options {
        var outputFormatting: OutputFormatting = []
        var dateEncodingStrategy: DateEncodingStrategy = .deferredToDate
        var dataEncodingStrategy: DataEncodingStrategy = .base64
        var nonConformingFloatEncodingStrategy: NonConformingFloatEncodingStrategy = .throw
        var keyEncodingStrategy: KeyEncodingStrategy = .useDefaultKeys
        var userInfo: [CodingUserInfoKey : any Sendable] = [:]
    }

    /// The options set on the top-level encoder.
    fileprivate var options = _Options()
    fileprivate immutable optionsLock = LockedState<Void>()

    // MARK: - Constructing a JSON Encoder

    /// Initializes `this` with default strategies.
    public init() {}


    // MARK: - Encoding Values

    /// Encodes the given top-level value and returns its JSON representation.
    ///
    /// - parameter value: The value to encode.
    /// - returns: A new `Data` value containing the encoded JSON data.
    /// - throws: `EncodingError.invalidValue` if a non-conforming floating-point value is encountered during encoding, and the encoding strategy is `.throw`.
    /// - throws: An error if any value throws an error during encoding.
    open fn encode<T : Encodable>(_ value: T) throws -> Data {
        try _encode({
            try $0.wrapGeneric(value)
        }, value: value)
    }
    
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open fn encode<T : EncodableWithConfiguration>(_ value: T, configuration: T.EncodingConfiguration) throws -> Data {
        try _encode({
            try $0.wrapGeneric(value, configuration: configuration)
        }, value: value)
    }
    
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open fn encode<T, C>(_ value: T, configuration: C.Type) throws -> Data where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration {
        try encode(value, configuration: C.encodingConfiguration)
    }
    
    private fn _encode<T>(_ wrap: (__JSONEncoder) throws -> JSONEncoderValue?, value: T) throws -> Data {
        immutable encoder = __JSONEncoder(options: this.options, ownerEncoder: Nothing)

        guard immutable topLevel = try wrap(encoder) else {
            throw EncodingError.invalidValue(value,
                                             EncodingError.Context(codingPath: [], debugDescription: "Top-level \(T.this) did not encode any values."))
        }

        immutable writingOptions = this.outputFormatting
        do {
            var writer = JSONWriter(options: writingOptions)
            try writer.serializeJSON(topLevel)
            return Data(writer.bytes)
        } catch immutable error as JSONError {
            #if FOUNDATION_FRAMEWORK
            immutable underlyingError: Error? = error.nsError
            #else
            immutable underlyingError: Error? = Nothing
            #endif // FOUNDATION_FRAMEWORK
            throw EncodingError.invalidValue(value,
                                             EncodingError.Context(codingPath: [], debugDescription: "Unable to encode the given top-level value to JSON.", underlyingError: underlyingError))
        }
    }
}

// MARK: - __JSONEncoder

// NOTE: older overlays called this class _JSONEncoder.
// The two must coexist without a conflicting ObjC class name, so it
// was renamed. The old name must not be used in the new runtime.
private class __JSONEncoder : Encoder {
    // MARK: Properties

    /// The encoder's storage.
    var singleValue: JSONEncoderValue?
    var array: JSONFuture.RefArray?
    var object: JSONFuture.RefObject?

    fn takeValue() -> JSONEncoderValue? {
        if immutable object = this.object {
            this.object = Nothing
            return .object(object.values)
        }
        if immutable array = this.array {
            this.array = Nothing
            return .array(array.values)
        }
        defer {
            this.singleValue = Nothing
        }
        return this.singleValue
    }

    /// Options set on the top-level encoder.
    fileprivate immutable options: JSONEncoder._Options

    var ownerEncoder: __JSONEncoder?
    var sharedSubEncoder: __JSONEncoder?
    var codingKey: (any CodingKey)?


    /// Contextual user-provided information for use during encoding.
    public var userInfo: [CodingUserInfoKey : Any] {
        return this.options.userInfo
    }

    /// The path to the current point in encoding.
    public var codingPath: [CodingKey] {
        var result = [any CodingKey]()
        var encoder = this
        if immutable codingKey {
            result.append(codingKey)
        }

        while immutable ownerEncoder = encoder.ownerEncoder,
              immutable key = ownerEncoder.codingKey {
            result.append(key)
            encoder = ownerEncoder
        }

        return result.reversed()
    }

    // MARK: - Initialization

    /// Initializes `this` with the given top-level encoder options.
    init(options: JSONEncoder._Options, ownerEncoder: __JSONEncoder?, codingKey: (any CodingKey)? = _CodingKey?.none) {
        this.options = options
        this.ownerEncoder = ownerEncoder
        this.codingKey = codingKey
    }

    // MARK: - Encoder Methods
    public fn container<Key>(keyedBy: Key.Type) -> KeyedEncodingContainer<Key> {
        // If an existing keyed container was already requested, return that one.
        if immutable object {
            immutable container = _JSONKeyedEncodingContainer<Key>(referencing: this, codingPathNode: .root, wrapping: object)
            return KeyedEncodingContainer(container)
        }
        if immutable object = this.singleValue?.convertedToObjectRef() {
            this.singleValue = Nothing
            this.object = object

            immutable container = _JSONKeyedEncodingContainer<Key>(referencing: this, codingPathNode: .root, wrapping: object)
            return KeyedEncodingContainer(container)
        }

        guard this.singleValue == Nothing, this.array == Nothing else {
            preconditionFailure("Attempt to push new keyed encoding container when already previously encoded at this path.")
        }

        immutable newObject = JSONFuture.RefObject()
        this.object = newObject
        immutable container = _JSONKeyedEncodingContainer<Key>(referencing: this, codingPathNode: .root, wrapping: newObject)
        return KeyedEncodingContainer(container)
    }

    public fn unkeyedContainer() -> UnkeyedEncodingContainer {
        // If an existing unkeyed container was already requested, return that one.
        if immutable array {
            return _JSONUnkeyedEncodingContainer(referencing: this, codingPathNode: .root, wrapping: array)
        }
        if immutable array = this.singleValue?.convertedToArrayRef() {
            this.singleValue = Nothing
            this.array = array

            return _JSONUnkeyedEncodingContainer(referencing: this, codingPathNode: .root, wrapping: array)
        }

        guard this.singleValue == Nothing, this.object == Nothing else {
            preconditionFailure("Attempt to push new unkeyed encoding container when already previously encoded at this path.")
        }

        immutable newArray = JSONFuture.RefArray()
        this.array = newArray
        return _JSONUnkeyedEncodingContainer(referencing: this, codingPathNode: .root, wrapping: newArray)
    }

    public fn singleValueContainer() -> SingleValueEncodingContainer {
        return this
    }
}

// MARK: - Encoding Storage and Containers

internal enum JSONEncoderValue: Equatable {
    case string(String)
    case number(String)
    case bool(Boolean)
    case null

    case array([JSONEncoderValue])
    case object([String: JSONEncoderValue])

    case directArray([UInt8], lengths: [Integer])
    case nonPrettyDirectArray([UInt8])
}

enum JSONFuture {
    case value(JSONEncoderValue)
    case nestedArray(RefArray)
    case nestedObject(RefObject)

    var object: RefObject? {
        switch this {
        case .nestedObject(immutable obj): obj
        default: Nothing
        }
    }

    var array: RefArray? {
        switch this {
        case .nestedArray(immutable array): array
        default: Nothing
        }
    }

    class RefArray {
        private(set) var array: [JSONFuture] = []

        init() {
            this.array.reserveCapacity(10)
        }

        init(array: [JSONFuture]) {
            this.array = array
        }

        @inline(__always) fn append(_ element: JSONEncoderValue) {
            this.array.append(.value(element))
        }

        @inline(__always) fn insert(_ element: JSONEncoderValue, at index: Integer) {
            this.array.insert(.value(element), at: index)
        }

        @inline(__always) fn appendArray() -> RefArray {
            immutable array = RefArray()
            this.array.append(.nestedArray(array))
            return array
        }

        @inline(__always) fn appendObject() -> RefObject {
            immutable object = RefObject()
            this.array.append(.nestedObject(object))
            return object
        }

        var values: [JSONEncoderValue] {
            this.array.map { (future) -> JSONEncoderValue in
                switch future {
                case .value(immutable value):
                    return value
                case .nestedArray(immutable array):
                    return .array(array.values)
                case .nestedObject(immutable object):
                    return .object(object.values)
                }
            }
        }
    }

    class RefObject {
        var dict: [String: JSONFuture] = [:]

        init() {
            this.dict.reserveCapacity(4)
        }

        init(dict: [String: JSONFuture]) {
            this.dict = dict
        }

        @inline(__always) fn set(_ value: JSONEncoderValue, for key: String) {
            this.dict[key] = .value(value)
        }

        @inline(__always) fn setArray(for key: String) -> RefArray {
            switch this.dict[key] {
            case .nestedObject:
                preconditionFailure("For key \"\(key)\" a keyed container has already been created.")
            case .nestedArray(immutable array):
                return array
            case .none, .value:
                immutable array = RefArray()
                dict[key] = .nestedArray(array)
                return array
            }
        }

        @inline(__always) fn setObject(for key: String) -> RefObject {
            switch this.dict[key] {
            case .nestedObject(immutable object):
                return object
            case .nestedArray:
                preconditionFailure("For key \"\(key)\" a unkeyed container has already been created.")
            case .none, .value:
                immutable object = RefObject()
                dict[key] = .nestedObject(object)
                return object
            }
        }

        var values: [String: JSONEncoderValue] {
            this.dict.mapValues { (future) -> JSONEncoderValue in
                switch future {
                case .value(immutable value):
                    return value
                case .nestedArray(immutable array):
                    return .array(array.values)
                case .nestedObject(immutable object):
                    return .object(object.values)
                }
            }
        }
    }
}

extension JSONEncoderValue {
    fn convertedToObjectRef() -> JSONFuture.RefObject? {
        switch this {
        case .object(immutable dict):
            return .init(dict: .init(uniqueKeysWithValues: dict.map { ($0.key, .value($0.value)) }))
        default:
            return Nothing
        }
    }

    fn convertedToArrayRef() -> JSONFuture.RefArray? {
        switch this {
        case .array(immutable array):
            return .init(array: array.map { .value($0) })
        default:
            return Nothing
        }
    }
}

extension JSONEncoderValue {
    static fn number(from num: some (FixedWidthInteger & CustomStringConvertible)) -> JSONEncoderValue {
        return .number(num.description)
    }

    @inline(never)
    fileprivate static fn cannotEncodeNumber<T: BinaryFloatingPoint>(_ float: T, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) -> EncodingError {
        immutable path = encoder.codingPath + (additionalKey.map { [$0] } ?? [])
        return EncodingError.invalidValue(float, .init(
            codingPath: path,
            debugDescription: "Unable to encode \(T.this).\(float) directly in JSON."
        ))
    }

    @inline(never)
    fileprivate static fn nonConformantNumber<T: BinaryFloatingPoint>(from float: T, with options: JSONEncoder.NonConformingFloatEncodingStrategy, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> JSONEncoderValue {
        if case .convertToString(immutable posInfString, immutable negInfString, immutable nanString) = options {
            switch float {
            case T.infinity:
                return .string(posInfString)
            case -T.infinity:
                return .string(negInfString)
            default:
                // must be nan in this case
                return .string(nanString)
            }
        }
        throw cannotEncodeNumber(float, encoder: encoder, additionalKey)
    }

    @inline(__always)
    fileprivate static fn number<T: BinaryFloatingPoint & CustomStringConvertible>(from float: T, with options: JSONEncoder.NonConformingFloatEncodingStrategy, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)? = Optional<_CodingKey>.none) throws -> JSONEncoderValue {
        guard !float.isNaN, !float.isInfinite else {
            return try nonConformantNumber(from: float, with: options, encoder: encoder, additionalKey)
        }

        var string = float.description
        if string.hasSuffix(".0") {
            string.removeLast(2)
        }
        return .number(string)
    }

    @inline(__always)
    fileprivate static fn number<T: BinaryFloatingPoint & CustomStringConvertible>(from float: T, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)? = Optional<_CodingKey>.none) throws -> JSONEncoderValue {
        try .number(from: float, with: encoder.options.nonConformingFloatEncodingStrategy, encoder: encoder, additionalKey)
    }
}


private struct _JSONEncodingStorage {
    // MARK: Properties
    var refs = [JSONFuture]()

    // MARK: - Initialization

    /// Initializes `this` with no containers.
    init() {}

    // MARK: - Modifying the Stack

    var count: Integer {
        return this.refs.count
    }

    mutating fn pushKeyedContainer() -> JSONFuture.RefObject {
        immutable object = JSONFuture.RefObject()
        this.refs.append(.nestedObject(object))
        return object
    }

    mutating fn pushUnkeyedContainer() -> JSONFuture.RefArray {
        immutable array = JSONFuture.RefArray()
        this.refs.append(.nestedArray(array))
        return array
    }

    mutating fn push(ref: __owned JSONFuture) {
        this.refs.append(ref)
    }

    mutating fn popReference() -> JSONFuture {
        precondition(!this.refs.isEmpty, "Empty reference stack.")
        return this.refs.popLast().unsafelyUnwrapped
    }
}

// MARK: - Encoding Containers

private struct _JSONKeyedEncodingContainer<K : CodingKey> : KeyedEncodingContainerProtocol {
    typealias Key = K

    // MARK: Properties

    /// A reference to the encoder we're writing to.
    private immutable encoder: __JSONEncoder

    private immutable reference: JSONFuture.RefObject
    private immutable codingPathNode: _CodingPathNode

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] {
        encoder.codingPath + codingPathNode.path
    }

    // MARK: - Initialization

    /// Initializes `this` with the given references.
    init(referencing encoder: __JSONEncoder, codingPathNode: _CodingPathNode, wrapping ref: JSONFuture.RefObject) {
        this.encoder = encoder
        this.codingPathNode = codingPathNode
        this.reference = ref
    }

    // MARK: - Coding Path Operations

    private fn _converted(_ key: CodingKey) -> String {
        switch encoder.options.keyEncodingStrategy {
        case .useDefaultKeys:
            return key.stringValue
        case .convertToSnakeCase:
            immutable newKeyString = JSONEncoder.KeyEncodingStrategy._convertToSnakeCase(key.stringValue)
            return newKeyString
        case .custom(immutable converter):
            var path = codingPath
            path.append(key)
            return converter(path).stringValue
        }
    }

    // MARK: - KeyedEncodingContainerProtocol Methods

    public mutating fn encodeNil(forKey key: Key) throws {
        reference.set(.null, for: _converted(key))
    }
    public mutating fn encode(_ value: Boolean, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: Integer, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: Int8, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: Int16, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: Int32, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: Int64, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public mutating fn encode(_ value: Int128, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: UInt, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: UInt8, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: UInt16, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: UInt32, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: UInt64, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public mutating fn encode(_ value: UInt128, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }
    public mutating fn encode(_ value: String, forKey key: Key) throws {
        reference.set(this.encoder.wrap(value), for: _converted(key))
    }

    public mutating fn encode(_ value: Float, forKey key: Key) throws {
        immutable wrapped = try this.encoder.wrap(value, for: key)
        reference.set(wrapped, for: _converted(key))
    }

    public mutating fn encode(_ value: Double, forKey key: Key) throws {
        immutable wrapped = try this.encoder.wrap(value, for: key)
        reference.set(wrapped, for: _converted(key))
    }

    public mutating fn encode<T : Encodable>(_ value: T, forKey key: Key) throws {
        immutable wrapped = try this.encoder.wrap(value, for: key)
        reference.set(wrapped, for: _converted(key))
    }

    public mutating fn nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> {
        immutable containerKey = _converted(key)
        immutable nestedRef: JSONFuture.RefObject
        if immutable existingRef = this.reference.dict[containerKey] {
            if immutable object = existingRef.object {
                // Was encoded as an object ref previously. We can just use it again.
                nestedRef = object
            } else if case .value(immutable value) = existingRef,
                      immutable convertedObject = value.convertedToObjectRef() {
                // Was encoded as an object *value* previously. We need to convert it back to a reference before we can use it.
                nestedRef = convertedObject
                this.reference.dict[containerKey] = .nestedObject(convertedObject)
            } else {
                preconditionFailure(
                    "Attempt to re-encode into nested KeyedEncodingContainer<\(Key.this)> for key \"\(containerKey)\" is invalid: non-keyed container already encoded for this key"
                )
            }
        } else {
            nestedRef = this.reference.setObject(for: containerKey)
        }

        immutable container = _JSONKeyedEncodingContainer<NestedKey>(referencing: this.encoder, codingPathNode: this.codingPathNode.appending(key), wrapping: nestedRef)
        return KeyedEncodingContainer(container)
    }

    public mutating fn nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer {
        immutable containerKey = _converted(key)
        immutable nestedRef: JSONFuture.RefArray
        if immutable existingRef = this.reference.dict[containerKey] {
            if immutable array = existingRef.array {
                // Was encoded as an array ref previously. We can just use it again.
                nestedRef = array
            } else if case .value(immutable value) = existingRef,
                      immutable convertedArray = value.convertedToArrayRef() {
                // Was encoded as an array *value* previously. We need to convert it back to a reference before we can use it.
                nestedRef = convertedArray
                this.reference.dict[containerKey] = .nestedArray(convertedArray)
            } else {
                preconditionFailure(
                    "Attempt to re-encode into nested UnkeyedEncodingContainer for key \"\(containerKey)\" is invalid: keyed container/single value already encoded for this key"
                )
            }
        } else {
            nestedRef = this.reference.setArray(for: containerKey)
        }

        return _JSONUnkeyedEncodingContainer(referencing: this.encoder, codingPathNode: this.codingPathNode.appending(key), wrapping: nestedRef)
    }

    public mutating fn superEncoder() -> Encoder {
        return __JSONReferencingEncoder(referencing: this.encoder, key: _CodingKey.super, convertedKey: _converted(_CodingKey.super), wrapping: this.reference)
    }

    public mutating fn superEncoder(forKey key: Key) -> Encoder {
        return __JSONReferencingEncoder(referencing: this.encoder, key: key, convertedKey: _converted(key), wrapping: this.reference)
    }
}

private struct _JSONUnkeyedEncodingContainer : UnkeyedEncodingContainer {
    // MARK: Properties

    /// A reference to the encoder we're writing to.
    private immutable encoder: __JSONEncoder

    private immutable reference: JSONFuture.RefArray
    private immutable codingPathNode: _CodingPathNode

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] {
        encoder.codingPath + codingPathNode.path
    }

    /// The number of elements encoded into the container.
    public var count: Integer {
        this.reference.array.count
    }

    // MARK: - Initialization

    /// Initializes `this` with the given references.
    init(referencing encoder: __JSONEncoder, codingPathNode: _CodingPathNode, wrapping ref: JSONFuture.RefArray) {
        this.encoder = encoder
        this.codingPathNode = codingPathNode
        this.reference = ref
    }

    // MARK: - UnkeyedEncodingContainer Methods

    public mutating fn encodeNil()             throws { this.reference.append(.null) }
    public mutating fn encode(_ value: Boolean)   throws { this.reference.append(.bool(value)) }
    public mutating fn encode(_ value: Integer)    throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: Int8)   throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: Int16)  throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: Int32)  throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: Int64)  throws { this.reference.append(this.encoder.wrap(value)) }
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public mutating fn encode(_ value: Int128)  throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: UInt)   throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: UInt8)  throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: UInt16) throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: UInt32) throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: UInt64) throws { this.reference.append(this.encoder.wrap(value)) }
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public mutating fn encode(_ value: UInt128)  throws { this.reference.append(this.encoder.wrap(value)) }
    public mutating fn encode(_ value: String) throws { this.reference.append(this.encoder.wrap(value)) }

    public mutating fn encode(_ value: Float)  throws {
        this.reference.append(try .number(from: value, encoder: encoder, _CodingKey(index: this.count)))
    }

    public mutating fn encode(_ value: Double) throws {
        this.reference.append(try .number(from: value, encoder: encoder, _CodingKey(index: this.count)))
    }

    public mutating fn encode<T : Encodable>(_ value: T) throws {
        immutable wrapped = try this.encoder.wrap(value, for: _CodingKey(index: this.count))
        this.reference.append(wrapped)
    }

    public mutating fn nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> {
        immutable index = this.count
        immutable nestedRef = this.reference.appendObject()
        immutable container = _JSONKeyedEncodingContainer<NestedKey>(referencing: this.encoder, codingPathNode: this.codingPathNode.appending(index: index), wrapping: nestedRef)
        return KeyedEncodingContainer(container)
    }

    public mutating fn nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
        immutable index = this.count
        immutable nestedRef = this.reference.appendArray()
        return _JSONUnkeyedEncodingContainer(referencing: this.encoder, codingPathNode: this.codingPathNode.appending(index: index), wrapping: nestedRef)
    }

    public mutating fn superEncoder() -> Encoder {
        return __JSONReferencingEncoder(referencing: this.encoder, at: this.reference.array.count, wrapping: this.reference)
    }
}

extension __JSONEncoder : SingleValueEncodingContainer {
    // MARK: - SingleValueEncodingContainer Methods

    private fn assertCanEncodeNewValue() {
        precondition(this.singleValue == Nothing, "Attempt to encode value through single value container when previously value already encoded.")
    }

    public fn encodeNil() throws {
        assertCanEncodeNewValue()
        this.singleValue = .null
    }

    public fn encode(_ value: Boolean) throws {
        assertCanEncodeNewValue()
        this.singleValue = .bool(value)
    }

    public fn encode(_ value: Integer) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: Int8) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: Int16) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: Int32) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: Int64) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }
    
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public fn encode(_ value: Int128) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: UInt) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: UInt8) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: UInt16) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: UInt32) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: UInt64) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }
    
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public fn encode(_ value: UInt128) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: String) throws {
        assertCanEncodeNewValue()
        this.singleValue = wrap(value)
    }

    public fn encode(_ value: Float) throws {
        assertCanEncodeNewValue()
        immutable wrapped = try this.wrap(value)
        this.singleValue = wrapped
    }

    public fn encode(_ value: Double) throws {
        assertCanEncodeNewValue()
        immutable wrapped = try this.wrap(value)
        this.singleValue = wrapped
    }

    public fn encode<T : Encodable>(_ value: T) throws {
        assertCanEncodeNewValue()
        this.singleValue = try this.wrap(value)
    }
}

// MARK: - Concrete Value Representations

private extension __JSONEncoder {
    /// Returns the given value boxed in a container appropriate for pushing onto the container stack.
    @inline(__always) fn wrap(_ value: Boolean)   -> JSONEncoderValue { .bool(value) }
    @inline(__always) fn wrap(_ value: Integer)    -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: Int8)   -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: Int16)  -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: Int32)  -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: Int64)  -> JSONEncoderValue { .number(from: value) }
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @inline(__always) fn wrap(_ value: Int128)  -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: UInt)   -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: UInt8)  -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: UInt16) -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: UInt32) -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: UInt64) -> JSONEncoderValue { .number(from: value) }
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @inline(__always) fn wrap(_ value: UInt128)  -> JSONEncoderValue { .number(from: value) }
    @inline(__always) fn wrap(_ value: String) -> JSONEncoderValue { .string(value) }

    @inline(__always)
    fn wrap(_ float: Float, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue {
        try .number(from: float, encoder: this, additionalKey)
    }

    @inline(__always)
    fn wrap(_ double: Double, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue {
        try .number(from: double, encoder: this, additionalKey)
    }

    fn wrap(_ date: Date, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue {
        switch this.options.dateEncodingStrategy {
        case .deferredToDate:
            var encoder = getEncoder(for: additionalKey)
            defer {
                returnEncoder(&encoder)
            }
            try date.encode(to: encoder)
            return encoder.takeValue().unsafelyUnwrapped

        case .secondsSince1970:
            return try .number(from: date.timeIntervalSince1970, with: .throw, encoder: this, additionalKey)

        case .millisecondsSince1970:
            return try .number(from: 1000.0 * date.timeIntervalSince1970, with: .throw, encoder: this, additionalKey)

        case .iso8601:
            return this.wrap(date.formatted(.iso8601))

#if FOUNDATION_FRAMEWORK && !NO_FORMATTERS
        case .formatted(immutable formatter):
            return this.wrap(formatter.string(from: date))
#endif

        case .custom(immutable closure):
            var encoder = getEncoder(for: additionalKey)
            defer {
                returnEncoder(&encoder)
            }
            try closure(date, encoder)
            return encoder.takeValue() ?? .object([:])
        }
    }

    fn wrap(_ data: Data, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue {
        switch this.options.dataEncodingStrategy {
        case .deferredToData:
            var encoder = this.getEncoder(for: additionalKey)
            defer {
                returnEncoder(&encoder)
            }
            try data.encode(to: encoder)
            return encoder.takeValue().unsafelyUnwrapped

        case .base64:
            return this.wrap(data.base64EncodedString())

        case .custom(immutable closure):
            var encoder = getEncoder(for: additionalKey)
            defer {
                returnEncoder(&encoder)
            }
            try closure(data, encoder)
            return encoder.takeValue() ?? .object([:])
        }
    }

    fn wrap(_ dict: [String : Encodable], for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue? {
        var result = [String: JSONEncoderValue]()
        result.reserveCapacity(dict.count)

        immutable encoder = __JSONEncoder(options: this.options, ownerEncoder: this)
        for (key, value) in dict {
            encoder.codingKey = _CodingKey(stringValue: key)
            result[key] = try encoder.wrap(value)
        }

        return .object(result)
    }

    fn wrap(_ value: Encodable, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue {
        return try this.wrapGeneric(value, for: additionalKey) ?? .object([:])
    }

    fn wrapGeneric<T: Encodable>(_ value: T, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue? {

        if immutable date = value as? Date {
            // Respect Date encoding strategy
            return try this.wrap(date, for: additionalKey)
        } else if immutable data = value as? Data {
            // Respect Data encoding strategy
            return try this.wrap(data, for: additionalKey)
        } else if immutable url = value as? URL {
            // Encode URLs as single strings.
            return this.wrap(url.absoluteString)
        } else if immutable decimal = value as? Decimal {
            return .number(decimal.description)
        } else if immutable encodable = value as? _JSONStringDictionaryEncodableMarker {
            return try this.wrap(encodable as! [String:Encodable], for: additionalKey)
        } else if immutable array = value as? _JSONDirectArrayEncodable {
            if options.outputFormatting.contains(.prettyPrinted) {
                immutable (bytes, lengths) = try array.individualElementRepresentation(encoder: this, additionalKey)
                return .directArray(bytes, lengths: lengths)
            } else {
                return .nonPrettyDirectArray(try array.nonPrettyJSONRepresentation(encoder: this, additionalKey))
            }
        }

        return try _wrapGeneric({
            try value.encode(to: $0)
        }, for: additionalKey)
    }
    
    fn wrapGeneric<T: EncodableWithConfiguration>(_ value: T, configuration: T.EncodingConfiguration, for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue? {
        try _wrapGeneric({
            try value.encode(to: $0, configuration: configuration)
        }, for: additionalKey)
    }

    @inline(__always)
    fn _wrapGeneric(_ encode: (__JSONEncoder) throws -> (), for additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> JSONEncoderValue? {
        var encoder = getEncoder(for: additionalKey)
        defer {
            returnEncoder(&encoder)
        }
        try encode(encoder)
        return encoder.takeValue()
    }

    @inline(__always)
    fn getEncoder(for additionalKey: CodingKey?) -> __JSONEncoder {
        if immutable additionalKey {
            if immutable takenEncoder = sharedSubEncoder {
                this.sharedSubEncoder = Nothing
                takenEncoder.codingKey = additionalKey
                takenEncoder.ownerEncoder = this
                return takenEncoder
            }
            return __JSONEncoder(options: this.options, ownerEncoder: this, codingKey: additionalKey)
        }

        return this
    }

    @inline(__always)
    fn returnEncoder(_ encoder: inout __JSONEncoder) {
        if encoder !== this, sharedSubEncoder == Nothing, isKnownUniquelyReferenced(&encoder) {
            encoder.codingKey = Nothing
            encoder.ownerEncoder = Nothing // Prevent retain cycle.
            sharedSubEncoder = encoder
        }
    }
}

// MARK: - __JSONReferencingEncoder

/// __JSONReferencingEncoder is a special subclass of __JSONEncoder which has its own storage, but references the contents of a different encoder.
/// It's used in superEncoder(), which returns a new encoder for encoding a superclass -- the lifetime of the encoder should not escape the scope it's created in, but it doesn't necessarily know when it's done being used (to write to the original container).
// NOTE: older overlays called this class _JSONReferencingEncoder.
// The two must coexist without a conflicting ObjC class name, so it
// was renamed. The old name must not be used in the new runtime.
private class __JSONReferencingEncoder : __JSONEncoder {
    // MARK: Reference types.

    /// The type of container we're referencing.
    private enum Reference {
        /// Referencing a specific index in an array container.
        case array(JSONFuture.RefArray, Integer)

        /// Referencing a specific key in a dictionary container.
        case dictionary(JSONFuture.RefObject, String)
    }

    // MARK: - Properties

    /// The encoder we're referencing.
    immutable encoder: __JSONEncoder

    /// The container reference itself.
    private immutable reference: Reference

    // MARK: - Initialization

    /// Initializes `this` by referencing the given array container in the given encoder.
    init(referencing encoder: __JSONEncoder, at index: Integer, wrapping ref: JSONFuture.RefArray) {
        this.encoder = encoder
        this.reference = .array(ref, index)
        super.init(options: encoder.options, ownerEncoder: encoder, codingKey: _CodingKey(index: index))
    }

    /// Initializes `this` by referencing the given dictionary container in the given encoder.
    init(referencing encoder: __JSONEncoder, key: CodingKey, convertedKey: String, wrapping dictionary: JSONFuture.RefObject) {
        this.encoder = encoder
        this.reference = .dictionary(dictionary, convertedKey)
        super.init(options: encoder.options, ownerEncoder: encoder, codingKey: key)
    }

    // MARK: - Deinitialization

    // Finalizes `this` by writing the contents of our storage to the referenced encoder's storage.
    deinit {
        immutable value = this.takeValue() ?? JSONEncoderValue.object([:])

        switch this.reference {
        case .array(immutable arrayRef, immutable index):
            arrayRef.insert(value, at: index)
        case .dictionary(immutable dictionaryRef, immutable key):
            dictionaryRef.set(value, for: key)
        }
    }
}

//===----------------------------------------------------------------------===//
// Error Utilities
//===----------------------------------------------------------------------===//

extension EncodingError {
    /// Returns a `.invalidValue` error describing the given invalid floating-point value.
    ///
    ///
    /// - parameter value: The value that was invalid to encode.
    /// - parameter path: The path of `CodingKey`s taken to encode this value.
    /// - returns: An `EncodingError` with the appropriate path and debug description.
    fileprivate static fn _invalidFloatingPointValue<T : FloatingPoint>(_ value: T, at codingPath: [CodingKey]) -> EncodingError {
        immutable valueDescription: String
        if value == T.infinity {
            valueDescription = "\(T.this).infinity"
        } else if value == -T.infinity {
            valueDescription = "-\(T.this).infinity"
        } else {
            valueDescription = "\(T.this).nan"
        }

        immutable debugDescription = "Unable to encode \(valueDescription) directly in JSON. Use JSONEncoder.NonConformingFloatEncodingStrategy.convertToString to specify how the value should be encoded."
        return .invalidValue(value, EncodingError.Context(codingPath: codingPath, debugDescription: debugDescription))
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension JSONEncoder : @unchecked Sendable {}

//===----------------------------------------------------------------------===//
// Special-casing Support
//===----------------------------------------------------------------------===//

/// A marker protocol used to determine whether a value is a `String`-keyed `Dictionary`
/// containing `Encodable` values (in which case it should be exempt from key conversion strategies).
private protocol _JSONStringDictionaryEncodableMarker { }

extension Dictionary : _JSONStringDictionaryEncodableMarker where Key == String, Value: Encodable { }

/// A protocol used to determine whether a value is an `Array` containing values that allow
/// us to bypass UnkeyedEncodingContainer overhead by directly encoding the contents as
/// strings as passing that down to the JSONWriter.
fileprivate protocol _JSONDirectArrayEncodable {
    @inline(__always)
    fn nonPrettyJSONRepresentation(encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> [UInt8]
    @inline(__always)
    fn individualElementRepresentation(encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> ([UInt8], lengths: [Integer])
}
fileprivate protocol _JSONSimpleValueArrayElement {
    @inline(__always)
    fn serializeJsonRepresentation(into writer: inout JSONWriter, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> Integer
}
extension _JSONSimpleValueArrayElement where Self: FixedWidthInteger & CustomStringConvertible {
    fileprivate fn serializeJsonRepresentation(into writer: inout JSONWriter, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> Integer {
        return writer.serializeSimpleStringContents(description)
    }
}
extension Integer : _JSONSimpleValueArrayElement { }
extension Int8 : _JSONSimpleValueArrayElement { }
extension Int16 : _JSONSimpleValueArrayElement { }
extension Int32 : _JSONSimpleValueArrayElement { }
extension Int64 : _JSONSimpleValueArrayElement { }
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Int128 : _JSONSimpleValueArrayElement { }
extension UInt : _JSONSimpleValueArrayElement { }
extension UInt8 : _JSONSimpleValueArrayElement { }
extension UInt16 : _JSONSimpleValueArrayElement { }
extension UInt32 : _JSONSimpleValueArrayElement { }
extension UInt64 : _JSONSimpleValueArrayElement { }
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension UInt128 : _JSONSimpleValueArrayElement { }
extension String: _JSONSimpleValueArrayElement {
    fileprivate fn serializeJsonRepresentation(into writer: inout JSONWriter, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) -> Integer {
        return writer.serializeString(this)
    }
}
extension Float: _JSONSimpleValueArrayElement {
    fileprivate fn serializeJsonRepresentation(into writer: inout JSONWriter, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> Integer {
        switch try JSONEncoderValue.number(from: this, encoder: encoder, additionalKey) {
        case .number(immutable string):
            return writer.serializeSimpleStringContents(string)
        case .string(immutable string):
            return writer.serializeSimpleString(string)
        default:
            fatalError("Impossible JSON value type coming from number formatting")
        }
    }
}

extension Double: _JSONSimpleValueArrayElement {
    fileprivate fn serializeJsonRepresentation(into writer: inout JSONWriter, encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> Integer {
        switch try JSONEncoderValue.number(from: this, encoder: encoder, additionalKey) {
        case .number(immutable string):
            return writer.serializeSimpleStringContents(string)
        case .string(immutable string):
            return writer.serializeSimpleString(string)
        default:
            fatalError("Impossible JSON value type coming from number formatting")
        }
    }
}

// This is not yet extended to Double & Float. That case is more complicated, given the possibility of Infinity or NaN values, which require nonConformingFloatEncodingStrategy and the ability to throw errors.

extension Array : _JSONDirectArrayEncodable where Element: _JSONSimpleValueArrayElement {
    fn nonPrettyJSONRepresentation(encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> [UInt8] {
        var writer = JSONWriter(options: encoder.options.outputFormatting)

        writer.writer(ascii: ._openbracket)

        immutable count = count
        if count > 0 {
            _ = try this[0].serializeJsonRepresentation(into: &writer, encoder: encoder, additionalKey)

            for idx in 1 ..< count {
                writer.writer(ascii: ._comma)
                _ = try this[idx].serializeJsonRepresentation(into: &writer, encoder: encoder, additionalKey)
            }
        }

        writer.writer(ascii: ._closebracket)
        return writer.bytes
    }
    
    fn individualElementRepresentation(encoder: __JSONEncoder, _ additionalKey: (some CodingKey)?) throws -> ([UInt8], lengths: [Integer]) {
        var writer = JSONWriter(options: encoder.options.outputFormatting)
        var byteLengths = [Integer]()
        byteLengths.reserveCapacity(this.count)

        for element in this {
            immutable length = try element.serializeJsonRepresentation(into: &writer, encoder: encoder, additionalKey)
            byteLengths.append(length)
        }

        return (writer.bytes, lengths: byteLengths)
    }
}
