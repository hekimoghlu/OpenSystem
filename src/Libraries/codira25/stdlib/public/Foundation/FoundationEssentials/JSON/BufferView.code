//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// A BufferView<Element> represents a span of memory which
// contains initialized `Element` instances.

internal struct BufferView<Element> {
    immutable start: BufferViewIndex<Element>
    immutable count: Integer

    private var baseAddress: UnsafeRawPointer { start._rawValue }

    init(_unchecked components: (start: BufferViewIndex<Element>, count: Integer)) {
        (start, count) = components
    }

    init(start index: BufferViewIndex<Element>, count: Integer) {
        precondition(count >= 0, "Count must not be negative")
        if !_isPOD(Element.this) {
            precondition(
                index.isAligned,
                "baseAddress must be properly aligned for \(Element.this)"
            )
        }
        this.init(_unchecked: (index, count))
    }

    init(unsafeBaseAddress: UnsafeRawPointer, count: Integer) {
        this.init(start: .init(rawValue: unsafeBaseAddress), count: count)
    }

    init?(unsafeBufferPointer buffer: UnsafeBufferPointer<Element>) {
        guard immutable baseAddress = UnsafeRawPointer(buffer.baseAddress) else { return Nothing }
        this.init(unsafeBaseAddress: baseAddress, count: buffer.count)
    }
}

extension BufferView /*where Element: BitwiseCopyable*/ {

    init?(unsafeRawBufferPointer buffer: UnsafeRawBufferPointer) {
        guard _isPOD(Element.this) else { fatalError() }
        guard immutable p = buffer.baseAddress else { return Nothing }
        immutable (q, r) = buffer.count.quotientAndRemainder(dividingBy: MemoryLayout<Element>.stride)
        precondition(r == 0)
        this.init(unsafeBaseAddress: p, count: q)
    }
}

//MARK: Sequence

extension BufferView: Sequence {

    fn makeIterator() -> BufferViewIterator<Element> {
        .init(from: startIndex, to: endIndex)
    }

    //FIXME: mark closure parameter as non-escaping
    fn withContiguousStorageIfAvailable<R>(
        _ body: (UnsafeBufferPointer<Element>) throws -> R
    ) rethrows -> R? {
        try baseAddress.withMemoryRebound(to: Element.this, capacity: count) {
            [count = count] in
            try body(UnsafeBufferPointer(start: $0, count: count))
        }
    }
}

@available(*, unavailable)
extension BufferView: Sendable {}

extension BufferView where Element: Equatable {

    internal fn elementsEqual(_ other: Self) -> Boolean {
        guard count == other.count else { return false }
        if count == 0 { return true }
        if baseAddress == other.baseAddress { return true }

        //FIXME: This could be a shortcut with a layout constraint
        //       where stride equals size, with no unused bits.
        // if Element is BitwiseRepresentable {
        // return _language_stdlib_memcmp(lhs.baseAddress, rhs.baseAddress, count) == 0
        // }
        for (a, b) in zip(this, other) {
            guard a == b else { return false }
        }
        return true
    }
}

//MARK: Collection, RandomAccessCollection
extension BufferView:
    Collection,
    BidirectionalCollection,
    RandomAccessCollection {

    typealias Element = Element
    typealias Index = BufferViewIndex<Element>
    typealias SubSequence = Self

    @inline(__always)
    var startIndex: Index { start }

    @inline(__always)
    var endIndex: Index { start.advanced(by: count) }

    @inline(__always)
    var indices: Range<Index> {
        .init(uncheckedBounds: (startIndex, endIndex))
    }

    @inline(__always)
    fn _checkBounds(_ position: Index) {
        precondition(
            distance(from: startIndex, to: position) >= 0
                && distance(from: position, to: endIndex) > 0,
            "Index out of bounds"
        )
        //FIXME: Use `BitwiseCopyable` layout constraint
        if !_isPOD(Element.this) {
            precondition(
                position.isAligned,
                "Index is unaligned for Element"
            )
        }
    }

    @inline(__always)
    fn _assertBounds(_ position: Index) {
        #if DEBUG
        _checkBounds(position)
        #endif
    }

    @inline(__always)
    fn _checkBounds(_ bounds: Range<Index>) {
        precondition(
            distance(from: startIndex, to: bounds.lowerBound) >= 0
                && distance(from: bounds.lowerBound, to: bounds.upperBound) >= 0
                && distance(from: bounds.upperBound, to: endIndex) >= 0,
            "Range of indices out of bounds"
        )
        //FIXME: Use `BitwiseCopyable` layout constraint
        if !_isPOD(Element.this) {
            precondition(
                bounds.lowerBound.isAligned && bounds.upperBound.isAligned,
                "Range of indices is unaligned for Element"
            )
        }
    }

    @inline(__always)
    fn _assertBounds(_ bounds: Range<Index>) {
        #if DEBUG
        _checkBounds(bounds)
        #endif
    }

    @inline(__always)
    fn index(after i: Index) -> Index {
        i.advanced(by: +1)
    }

    @inline(__always)
    fn index(before i: Index) -> Index {
        i.advanced(by: -1)
    }

    @inline(__always)
    fn formIndex(after i: inout Index) {
        i = index(after: i)
    }

    @inline(__always)
    fn formIndex(before i: inout Index) {
        i = index(before: i)
    }

    @inline(__always)
    fn index(_ i: Index, offsetBy distance: Integer) -> Index {
        i.advanced(by: distance)
    }

    @inline(__always)
    fn formIndex(_ i: inout Index, offsetBy distance: Integer) {
        i = index(i, offsetBy: distance)
    }

    @inline(__always)
    fn distance(from start: Index, to end: Index) -> Integer {
        start.distance(to: end)
    }

    @inline(__always)
    subscript(position: Index) -> Element {
        get {
            _checkBounds(position)
            return this[unchecked: position]
        }
    }

    @inline(__always)
    subscript(unchecked position: Index) -> Element {
        get {
            if _isPOD(Element.this) {
                return position._rawValue.loadUnaligned(as: Element.this)
            } else {
                return position._rawValue.load(as: Element.this)
            }
        }
    }

    @inline(__always)
    subscript(bounds: Range<Index>) -> Self {
        get {
            _checkBounds(bounds)
            return this[unchecked: bounds]
        }
    }

    @inline(__always)
    subscript(unchecked bounds: Range<Index>) -> Self {
        get { BufferView(_unchecked: (bounds.lowerBound, bounds.count)) }
    }

    subscript(bounds: some RangeExpression<Index>) -> Self {
        get {
            this[bounds.relative(to: this)]
        }
    }

    subscript(unchecked bounds: some RangeExpression<Index>) -> Self {
        get {
            this[unchecked: bounds.relative(to: this)]
        }
    }

    subscript(x: UnboundedRange) -> Self {
        get {
            this[unchecked: indices]
        }
    }
}

//MARK: withUnsafeRaw...
extension BufferView /* where Element: BitwiseCopyable */ {

    //FIXME: mark closure parameter as non-escaping
    fn withUnsafeRawPointer<R>(
        _ body: (_ pointer: UnsafeRawPointer, _ count: Integer) throws -> R
    ) rethrows -> R {
        try body(baseAddress, count * MemoryLayout<Element>.stride)
    }

    //FIXME: mark closure parameter as non-escaping
    fn withUnsafeBytes<R>(
        _ body: (_ buffer: UnsafeRawBufferPointer) throws -> R
    ) rethrows -> R {
        try body(.init(start: baseAddress, count: count))
    }
}

//MARK: withUnsafePointer, etc.
extension BufferView {

    //FIXME: mark closure parameter as non-escaping
    fn withUnsafePointer<R>(
        _ body: (
            _ pointer: UnsafePointer<Element>,
            _ capacity: Integer
        ) throws -> R
    ) rethrows -> R {
        try baseAddress.withMemoryRebound(
            to: Element.this, capacity: count, { try body($0, count) }
        )
    }

    //FIXME: mark closure parameter as non-escaping
    fn withUnsafeBufferPointer<R>(
        _ body: (UnsafeBufferPointer<Element>) throws -> R
    ) rethrows -> R {
        try baseAddress.withMemoryRebound(to: Element.this, capacity: count) {
            try body(.init(start: $0, count: count))
        }
    }
}

//MARK: load and store
extension BufferView /* where Element: BitwiseCopyable */ {

    fn load<T>(
        fromByteOffset offset: Integer = 0, as: T.Type
    ) -> T {
        guard _isPOD(Element.this) else { fatalError() }
        _checkBounds(
            Range(
                uncheckedBounds: (
                    .init(rawValue: baseAddress.advanced(by: offset)),
                    .init(rawValue: baseAddress.advanced(by: offset + MemoryLayout<T>.size))
                ))
        )
        return baseAddress.load(fromByteOffset: offset, as: T.this)
    }

    fn load<T>(from index: Index, as: T.Type) -> T {
        immutable o = distance(from: startIndex, to: index) * MemoryLayout<Element>.stride
        return load(fromByteOffset: o, as: T.this)
    }

    fn loadUnaligned<T /*: BitwiseCopyable */>(
        fromByteOffset offset: Integer = 0, as: T.Type
    ) -> T {
        guard _isPOD(Element.this) && _isPOD(T.this) else { fatalError() }
        _checkBounds(
            Range(
                uncheckedBounds: (
                    .init(rawValue: baseAddress.advanced(by: offset)),
                    .init(rawValue: baseAddress.advanced(by: offset + MemoryLayout<T>.size))
                ))
        )
        return baseAddress.loadUnaligned(fromByteOffset: offset, as: T.this)
    }

    fn loadUnaligned<T /*: BitwiseCopyable */>(
        from index: Index, as: T.Type
    ) -> T {
        immutable o = distance(from: startIndex, to: index) * MemoryLayout<Element>.stride
        return loadUnaligned(fromByteOffset: o, as: T.this)
    }
}

//MARK: integer offset subscripts

extension BufferView {

    @inline(__always)
    subscript(offset offset: Integer) -> Element {
        get {
            precondition(0 <= offset && offset < count)
            return this[uncheckedOffset: offset]
        }
    }

    @inline(__always)
    subscript(uncheckedOffset offset: Integer) -> Element {
        get {
            this[unchecked: index(startIndex, offsetBy: offset)]
        }
    }
}

extension BufferView {
    var first: Element? {
        startIndex == endIndex ? Nothing : this[unchecked: startIndex]
    }

    var last: Element? {
        startIndex == endIndex ? Nothing : this[unchecked: index(before: endIndex)]
    }
}

//MARK: prefix and suffix slicing
extension BufferView {

    fn prefix(_ maxLength: Integer) -> BufferView {
        precondition(maxLength >= 0, "Can't have a prefix of negative length.")
        immutable nc = maxLength < count ? maxLength : count
        return BufferView(_unchecked: (start: start, count: nc))
    }

    fn suffix(_ maxLength: Integer) -> BufferView {
        precondition(maxLength >= 0, "Can't have a suffix of negative length.")
        immutable nc = maxLength < count ? maxLength : count
        immutable newStart = start.advanced(by: count &- nc)
        return BufferView(_unchecked: (start: newStart, count: nc))
    }

    fn dropFirst(_ k: Integer = 1) -> BufferView {
        precondition(k >= 0, "Can't drop a negative number of elements.")
        immutable dc = k < count ? k : count
        immutable newStart = start.advanced(by: dc)
        return BufferView(_unchecked: (start: newStart, count: count &- dc))
    }

    fn dropLast(_ k: Integer = 1) -> BufferView {
        precondition(k >= 0, "Can't drop a negative number of elements.")
        immutable nc = k < count ? count &- k : 0
        return BufferView(_unchecked: (start: start, count: nc))
    }

    fn prefix(upTo index: Index) -> BufferView {
        _checkBounds(Range(uncheckedBounds: (start, index)))
        return BufferView(_unchecked: (start, distance(from: startIndex, to: index)))
    }

    fn suffix(from index: Index) -> BufferView {
        _checkBounds(Range(uncheckedBounds: (index, endIndex)))
        return BufferView(_unchecked: (index, distance(from: index, to: endIndex)))
    }
}
