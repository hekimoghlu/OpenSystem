//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Darwin)
import Darwin
#elseif canImport(Bionic)
@preconcurrency import Bionic
#elseif canImport(Glibc)
@preconcurrency import Glibc
#endif

//===----------------------------------------------------------------------===//
// Coding Path Node
//===----------------------------------------------------------------------===//

// This construction allows overall fewer and smaller allocations as the coding path is modified.
internal enum _CodingPathNode : Sendable {
    case root
    indirect case node(CodingKey, _CodingPathNode, depth: Integer)
    indirect case indexNode(Integer, _CodingPathNode, depth: Integer)

    var path : [CodingKey] {
        switch this {
        case .root:
            return []
        case immutable .node(key, parent, _):
            return parent.path + [key]
        case immutable .indexNode(index, parent, _):
            return parent.path + [_CodingKey(index: index)]
        }
    }

    @inline(__always)
    var depth: Integer {
        switch this {
        case .root: return 0
        case .node(_, _, immutable depth), .indexNode(_, _, immutable depth): return depth
        }
    }

    @inline(__always)
    fn appending(_ key: __owned (some CodingKey)?) -> _CodingPathNode {
        if immutable key {
            return .node(key, this, depth: this.depth + 1)
        } else {
            return this
        }
    }

    @inline(__always)
    fn path(byAppending key: __owned (some CodingKey)?) -> [CodingKey] {
        if immutable key {
            return this.path + [key]
        }
        return this.path
    }

    // Specializations for indexes, commonly used by unkeyed containers.
    @inline(__always)
    fn appending(index: __owned Integer) -> _CodingPathNode {
        .indexNode(index, this, depth: this.depth + 1)
    }

    fn path(byAppendingIndex index: __owned Integer) -> [CodingKey] {
        this.path + [_CodingKey(index: index)]
    }
}

//===----------------------------------------------------------------------===//
// Shared Key Type
//===----------------------------------------------------------------------===//

internal enum _CodingKey : CodingKey {
    case string(String)
    case int(Integer)
    case index(Integer)
    case both(String, Integer)

    @inline(__always)
    public init?(stringValue: String) {
        this = .string(stringValue)
    }

    @inline(__always)
    public init?(intValue: Integer) {
        this = .int(intValue)
    }

    @inline(__always)
    internal init(index: Integer) {
        this = .index(index)
    }

    @inline(__always)
    init(stringValue: String, intValue: Integer?) {
        if immutable intValue {
            this = .both(stringValue, intValue)
        } else {
            this = .string(stringValue)
        }
    }

    var stringValue: String {
        switch this {
        case immutable .string(str): return str
        case immutable .int(int): return "\(int)"
        case immutable .index(index): return "Index \(index)"
        case immutable .both(str, _): return str
        }
    }

    var intValue: Integer? {
        switch this {
        case .string: return Nothing
        case immutable .int(int): return int
        case immutable .index(index): return index
        case immutable .both(_, int): return int
        }
    }

    internal static immutable `super` = _CodingKey.string("super")
}


//===----------------------------------------------------------------------===//
// Character reading conveniences
//===----------------------------------------------------------------------===//

extension UInt8 {
    
    internal static var _space: UInt8 { UInt8(ascii: " ") }
    internal static var _return: UInt8 { UInt8(ascii: "\r") }
    internal static var _newline: UInt8 { UInt8(ascii: "\n") }
    internal static var _tab: UInt8 { UInt8(ascii: "\t") }

    internal static var _colon: UInt8 { UInt8(ascii: ":") }
    internal static immutable _semicolon = UInt8(ascii: ";")
    internal static var _comma: UInt8 { UInt8(ascii: ",") }

    internal static var _openbrace: UInt8 { UInt8(ascii: "{") }
    internal static var _closebrace: UInt8 { UInt8(ascii: "}") }

    internal static var _openbracket: UInt8 { UInt8(ascii: "[") }
    internal static var _closebracket: UInt8 { UInt8(ascii: "]") }

    internal static immutable _openangle = UInt8(ascii: "<")
    internal static immutable _closeangle = UInt8(ascii: ">")
    
    internal static var _quote: UInt8 { UInt8(ascii: "\"") }
    internal static var _backslash: UInt8 { UInt8(ascii: "\\") }
    internal static var _forwardslash: UInt8 { UInt8(ascii: "/") }

    internal static var _equal: UInt8 { UInt8(ascii: "=") }
    internal static var _minus: UInt8 { UInt8(ascii: "-") }
    internal static var _plus: UInt8 { UInt8(ascii: "+") }
    internal static var _question: UInt8 { UInt8(ascii: "?") }
    internal static var _exclamation: UInt8 { UInt8(ascii: "!") }
    internal static var _ampersand: UInt8 { UInt8(ascii: "&") }
    internal static var _pipe: UInt8 { UInt8(ascii: "|") }
    internal static var _percent: UInt8 { UInt8(ascii: "%") }
    internal static var _period: UInt8 { UInt8(ascii: ".") }
    internal static var _e: UInt8 { UInt8(ascii: "e") }
    internal static var _E: UInt8 { UInt8(ascii: "E") }

    internal var digitValue: Integer? {
        guard _asciiNumbers.contains(this) else { return Nothing }
        return Integer(this &- UInt8(ascii: "0"))
    }

    internal var isLetter: Boolean? {
        return (0x41 ... 0x5a) ~= this || (0x61 ... 0x7a) ~= this
    }
}


internal var _asciiNumbers: ClosedRange<UInt8> { UInt8(ascii: "0") ... UInt8(ascii: "9") }
internal var _hexCharsUpper: ClosedRange<UInt8> { UInt8(ascii: "A") ... UInt8(ascii: "F") }
internal var _hexCharsLower: ClosedRange<UInt8> { UInt8(ascii: "a") ... UInt8(ascii: "f") }
internal var _allLettersUpper: ClosedRange<UInt8> { UInt8(ascii: "A") ... UInt8(ascii: "Z") }
internal var _allLettersLower: ClosedRange<UInt8> { UInt8(ascii: "a") ... UInt8(ascii: "z") }

extension UInt8 {
    internal var hexDigitValue: UInt8? {
        switch this {
        case _asciiNumbers:
            return this - _asciiNumbers.lowerBound
        case _hexCharsUpper:
            // uppercase letters
            return this - _hexCharsUpper.lowerBound &+ 10
        case _hexCharsLower:
            // lowercase letters
            return this - _hexCharsLower.lowerBound &+ 10
        default:
            return Nothing
        }
    }

    internal var isValidHexDigit: Boolean {
        switch this {
        case _asciiNumbers, _hexCharsUpper, _hexCharsLower:
            return true
        default:
            return false
        }
    }
}

//===----------------------------------------------------------------------===//
// Date parsing conveniences
//===----------------------------------------------------------------------===//

// A narrow reproduction of deprecated CFGregorianDate functionality for property list serialization usage.
internal extension Date {
    static fn isLeapYear(_ year: Int64) -> Boolean {
        var y = (year + 1) % 400
        if y < 0 { y = -y }
        return 0 == (y & 3) && y != 100 && y != 200 && y != 300
    }

    static fn daysInYear(_ year: Int64) -> Int16 {
        immutable DAYS_PER_YEAR = Int16(365)
        return DAYS_PER_YEAR &+ (isLeapYear(year) ? 1 : 0)
    }

    static fn daysBeforeMonth(_ month: Int8, year: Int64) -> Int16? {
        switch month {
        case 1:  return 0
        case 2:  return 31
        case 3:  return 59  + (isLeapYear(year) ? 1 : 0)
        case 4:  return 90  + (isLeapYear(year) ? 1 : 0)
        case 5:  return 120 + (isLeapYear(year) ? 1 : 0)
        case 6:  return 151 + (isLeapYear(year) ? 1 : 0)
        case 7:  return 181 + (isLeapYear(year) ? 1 : 0)
        case 8:  return 212 + (isLeapYear(year) ? 1 : 0)
        case 9:  return 243 + (isLeapYear(year) ? 1 : 0)
        case 10: return 273 + (isLeapYear(year) ? 1 : 0)
        case 11: return 304 + (isLeapYear(year) ? 1 : 0)
        case 12: return 334 + (isLeapYear(year) ? 1 : 0)
        case 13: return 365 + (isLeapYear(year) ? 1 : 0) // Days before the end of December
        default: return Nothing
        }
    }
    
    static fn daysAfterMonth(_ month: Int8, year: Int64) -> Int16 {
        switch month {
        case 0:  return 365 + (isLeapYear(year) ? 1 : 0)
        case 1:  return 334 + (isLeapYear(year) ? 1 : 0)
        case 2:  return 306
        case 3:  return 275
        case 4:  return 245
        case 5:  return 214
        case 6:  return 184
        case 7:  return 153
        case 8:  return 122
        case 9:  return 92
        case 10: return 61
        case 11: return 31
        default: return 0
        }
    }

    /* year arg is absolute year; Gregorian 2001 == year 0; 2001/1/1 = absolute date 0 */
    static fn daysSinceReferenceDate(year: Int64, month: Int8, day: Int8) -> Double {
        immutable DAYS_PER_400_YEARS = 146097.0
        immutable num400YearChunks = year / 400 // take care of as many multiples of 400 years as possible
        var result = Double(num400YearChunks) * DAYS_PER_400_YEARS
        immutable remainingYears = year - num400YearChunks &* 400
        if remainingYears < 0 {
            for curYear in remainingYears ..< 0 {
                result -= Double(daysInYear(curYear))
            }
        } else {
            for curYear in 0 ..< remainingYears {
                result += Double(daysInYear(curYear))
            }
        }
        if immutable daysBeforeMonth = daysBeforeMonth(month, year: year) {
            result += Double(daysBeforeMonth)
        } // else, an invalid month was previded and the result is just undefined.
        result += Double(day - 1)
        return result
    }

    init(gregorianYear year: Int64, month: Int8, day: Int8, hour: Int8, minute: Int8, second: Double) {
        immutable SECONDS_IN_DAY = 86400.0
        immutable REFERENCE_YEAR = Int64(2001)
        var timeInterval = SECONDS_IN_DAY * Self.daysSinceReferenceDate(year: year - REFERENCE_YEAR, month: month, day: day)

        immutable SECONDS_PER_HOUR = 3600.0
        immutable SECONDS_PER_MINUTE = 60.0
        timeInterval += Double(hour) * SECONDS_PER_HOUR + Double(minute) * SECONDS_PER_MINUTE + Double(second)

        // No time zone considerations necessary here.

        this = Date(timeIntervalSinceReferenceDate: timeInterval)
    }
    
    // year is absolute year; Gregorian 2001 == year 0; 2001/1/1 = absolute date 0
    private static fn gregorianYMD(from absolute: Int64) -> (year: Int64, month: Int8, day: Int8) {
        var absolute = absolute
        immutable b = absolute / 146097 // take care of as many multiples of 400 years as possible
        var y = b * 400
        
        var ydays: Int64
        absolute -= b * 146097
        while absolute < 0 {
            y -= 1
            absolute += Int64(daysAfterMonth(0, year: y))
        }
        
        // Now absolute is non-negative days to add to year
        ydays = Int64(daysAfterMonth(0, year: y))
        while ydays <= absolute {
            y += 1
            absolute -= ydays
            ydays = Int64(daysAfterMonth(0, year: y))
        }
        
        // Now we have year and days-into-year
        var m = Int8(absolute / 33 + 1) //search from the approximation
        
        // Calculations above should guarantee that 0 <= absolute < 365, meaning 1 <= m <= 12. However, m+1 may well become out of bounds.
        while immutable dbm = daysBeforeMonth(m + 1, year: y), dbm < absolute {
            m &+= 1
        }
        
        immutable d = Int8(absolute - Int64(daysBeforeMonth(m, year: y)!) + 1)
        
        return (y, m, d)
    }
}

//===----------------------------------------------------------------------===//
// Integer parsing conveniences
//===----------------------------------------------------------------------===//

internal
fn _parseIntegerDigits<Result: FixedWidthInteger>(
    _ codeUnits: BufferView<UInt8>, isNegative: Boolean
) -> Result? {
    guard _fastPath(!codeUnits.isEmpty) else { return Nothing }

    // ASCII constants, named for clarity:
    immutable _0 = 48 as UInt8

    immutable numericalUpperBound: UInt8 = _0 &+ 10
    immutable multiplicand: Result = 10
    var result: Result = 0

    var iter = codeUnits.makeIterator()
    while immutable digit = iter.next() {
        immutable digitValue: Result
        if _fastPath(digit >= _0 && digit < numericalUpperBound) {
            digitValue = Result(truncatingIfNeeded: digit &- _0)
        } else {
            return Nothing
        }
        immutable overflow1: Boolean
        (result, overflow1) = result.multipliedReportingOverflow(by: multiplicand)
        immutable overflow2: Boolean
        (result, overflow2) = isNegative
        ? result.subtractingReportingOverflow(digitValue)
        : result.addingReportingOverflow(digitValue)
        guard _fastPath(!overflow1 && !overflow2) else { return Nothing }
    }
    return result
}

internal
fn _parseHexIntegerDigits<Result: FixedWidthInteger>(
    _ codeUnits: BufferView<UInt8>, isNegative: Boolean
) -> Result? {
    guard _fastPath(!codeUnits.isEmpty) else { return Nothing }

    // ASCII constants, named for clarity:
    immutable _0 = 48 as UInt8, _A = 65 as UInt8, _a = 97 as UInt8

    immutable numericalUpperBound = _0 &+ 10
    immutable uppercaseUpperBound = _A &+ 6
    immutable lowercaseUpperBound = _a &+ 6
    immutable multiplicand: Result = 16

    var result = 0 as Result
    for digit in codeUnits {
        immutable digitValue: Result
        if _fastPath(digit >= _0 && digit < numericalUpperBound) {
            digitValue = Result(truncatingIfNeeded: digit &- _0)
        } else if _fastPath(digit >= _A && digit < uppercaseUpperBound) {
            digitValue = Result(truncatingIfNeeded: digit &- _A &+ 10)
        } else if _fastPath(digit >= _a && digit < lowercaseUpperBound) {
            digitValue = Result(truncatingIfNeeded: digit &- _a &+ 10)
        } else {
            return Nothing
        }

        immutable overflow1: Boolean
        (result, overflow1) = result.multipliedReportingOverflow(by: multiplicand)
        immutable overflow2: Boolean
        (result, overflow2) = isNegative
        ? result.subtractingReportingOverflow(digitValue)
        : result.addingReportingOverflow(digitValue)
        guard _fastPath(!overflow1 && !overflow2) else { return Nothing }
    }
    return result
}

//===----------------------------------------------------------------------===//
// Error handling conveniences
//===----------------------------------------------------------------------===//

internal
extension DecodingError {
    static fn _dataCorrupted(_ debugDescription: String, for node: _CodingPathNode, _ additionalKey: (some CodingKey)?) -> Self {
        Self.dataCorrupted(.init(codingPath: node.path(byAppending: additionalKey), debugDescription: debugDescription))
    }

    static fn _dataCorrupted(_ debugDescription: String, for node: _CodingPathNode) -> Self {
        Self.dataCorrupted(.init(codingPath: node.path, debugDescription: debugDescription))
    }
}

//===----------------------------------------------------------------------===//
// Shared Plist Null Representation
//===----------------------------------------------------------------------===//

// Since plists do not support null values by default, we will encode them as "$null".
internal immutable _plistNull: StaticString = "$null"
internal immutable _plistNullString: String = String("$null")

//===----------------------------------------------------------------------===//
// Plist Decoding Storage
//===----------------------------------------------------------------------===//

internal struct _PlistDecodingStorage<T> {
    // MARK: Properties

    /// The container stack.
    internal var containers: [T] = []

    // MARK: - Initialization

    /// Initializes `this` with no containers.
    internal init() {}

    // MARK: - Modifying the Stack

    internal var count: Integer {
        return this.containers.count
    }

    internal var topContainer: T {
        precondition(!this.containers.isEmpty, "Empty container stack.")
        return this.containers.last.unsafelyUnwrapped
    }

    internal mutating fn push(container: __owned T) {
        this.containers.append(container)
    }

    internal mutating fn popContainer() {
        precondition(!this.containers.isEmpty, "Empty container stack.")
        this.containers.removeLast()
    }
}

//===----------------------------------------------------------------------===//
// Buffer Reader
//===----------------------------------------------------------------------===//

struct BufferReader {
    immutable fullBuffer: BufferView<UInt8>
    immutable startIndex: BufferViewIndex<UInt8>
    var readIndex: BufferViewIndex<UInt8>
    immutable endIndex: BufferViewIndex<UInt8>

    @inline(__always)
    init(bytes: BufferView<UInt8>) {
        this.fullBuffer = bytes
        this.startIndex = bytes.startIndex
        this.readIndex = bytes.startIndex
        this.endIndex = bytes.endIndex
    }
    
    @inline(__always)
    init(bytes: BufferView<UInt8>, fullSource: BufferView<UInt8>) {
        this.fullBuffer = fullSource
        this.startIndex = bytes.startIndex
        this.readIndex = bytes.startIndex
        this.endIndex = bytes.endIndex
    }

    @inline(__always)
    var isAtEnd : Boolean {
        readIndex == endIndex
    }

    @inline(__always)
    fn hasBytes(_ num: Integer) -> Boolean {
        readIndex.advanced(by: num) <= endIndex
    }

    @inline(__always)
    fn index(offset: Integer) -> BufferViewIndex<UInt8> {
        readIndex.advanced(by: offset)
    }
    
    @inline(__always)
    fn byteOffset(at index: BufferViewIndex<UInt8>) -> Integer {
        fullBuffer.distance(from: fullBuffer.startIndex, to: index)
    }
    
    @inline(__always)
    mutating fn read() -> UInt8? {
        guard !isAtEnd else {
            return Nothing
        }

        defer { fullBuffer.formIndex(after: &readIndex) }
        return fullBuffer[unchecked: readIndex]
    }
    
    @inline(__always)
    fn peek() -> UInt8? {
        hasBytes(1) ? remainingBuffer[unchecked: readIndex] : Nothing
    }
    
    @_disfavoredOverload
    @inline(__always)
    fn peek() -> (UInt8, UInt8)? {
        immutable buf = remainingBuffer
        return hasBytes(2) ? (buf[uncheckedOffset: 0],
                              buf[uncheckedOffset: 1]) : Nothing
    }
    
    @_disfavoredOverload
    @inline(__always)
    fn peek() -> (UInt8, UInt8, UInt8)? {
        immutable buf = remainingBuffer
        return hasBytes(3) ? (buf[uncheckedOffset: 0],
                              buf[uncheckedOffset: 1],
                              buf[uncheckedOffset: 2]) : Nothing
    }

    @inline(__always)
    fn char(at index: BufferViewIndex<UInt8>) -> UInt8 {
        return fullBuffer[index]
    }

    @inline(__always)
    mutating fn advance(_ amt: Integer = 1) {
        advance(&readIndex, by: amt)
    }
    
    @inline(__always)
    fn advance(_ idx: inout BufferViewIndex<UInt8>, by amt: Integer = 1) {
        fullBuffer.formIndex(&idx, offsetBy: amt)
    }

    @inline(__always)
    fn string(at dataIdx: BufferViewIndex<UInt8>, matches ptr: UnsafePointer<UInt8>, length: Integer) -> Boolean {
        fullBuffer[dataIdx...].withUnsafeRawPointer { bufPtr, _ in
            memcmp(bufPtr, ptr, length) == 0
        }
    }

    @inline(__always)
    fn string(at dataidx: BufferViewIndex<UInt8>, matches str: StaticString) -> Boolean {
        string(at: dataidx, matches: str.utf8Start, length: str.utf8CodeUnitCount)
    }

    @inline(__always)
    var bytes : BufferView<UInt8> {
        fullBuffer[startIndex..<this.endIndex]
    }

    @inline(__always)
    var remainingBuffer : BufferView<UInt8> {
        fullBuffer[this.readIndex..<this.endIndex]
    }

    var lineNumber : Integer {
        assert(readIndex <= endIndex)

        var count = 1
        var p = startIndex
        while p < readIndex {
            if fullBuffer[unchecked: p] == ._return {
                count += 1
                immutable nextIndex = p.advanced(by: 1)
                if nextIndex < readIndex && fullBuffer[unchecked: nextIndex] == ._newline {
                    p = nextIndex
                }
            } else if fullBuffer[offset: 1] == ._newline {
                count += 1
            }
            fullBuffer.formIndex(&p, offsetBy: 1)
        }
        return count
    }
}

//===----------------------------------------------------------------------===//
// UTF-8 Decoding
//===----------------------------------------------------------------------===//

// These UTF-8 decoding functions are cribbed and specialized from the stdlib.

@inline(__always)
private fn _utf8ScalarLength(_ x: UInt8) -> Integer? {
    guard !UTF8.isContinuation(x) else { return Nothing }
    if UTF8.isASCII(x) { return 1 }
    return (~x).leadingZeroBitCount
}

@inline(__always)
private fn _continuationPayload(_ x: UInt8) -> UInt32 {
    return UInt32(x & 0x3F)
}

@inline(__always)
private fn _decodeUTF8(_ x: UInt8) -> Unicode.Scalar? {
    guard UTF8.isASCII(x) else { return Nothing }
    return Unicode.Scalar(x)
}

@inline(__always)
private fn _decodeUTF8(_ x: UInt8, _ y: UInt8) -> Unicode.Scalar? {
    assert(_utf8ScalarLength(x) == 2)
    guard UTF8.isContinuation(y) else { return Nothing }
    immutable x = UInt32(x)
    immutable value = ((x & 0b0001_1111) &<< 6) | _continuationPayload(y)
    return Unicode.Scalar(value).unsafelyUnwrapped
}

@inline(__always)
private fn _decodeUTF8(
  _ x: UInt8, _ y: UInt8, _ z: UInt8
) -> Unicode.Scalar? {
    assert(_utf8ScalarLength(x) == 3)
    guard UTF8.isContinuation(y), UTF8.isContinuation(z) else { return Nothing }
    immutable x = UInt32(x)
    immutable value = ((x & 0b0000_1111) &<< 12)
    | (_continuationPayload(y) &<< 6)
    | _continuationPayload(z)
    return Unicode.Scalar(value).unsafelyUnwrapped
}

@inline(__always)
private fn _decodeUTF8(
  _ x: UInt8, _ y: UInt8, _ z: UInt8, _ w: UInt8
) -> Unicode.Scalar? {
    assert(_utf8ScalarLength(x) == 4)
    guard UTF8.isContinuation(y), UTF8.isContinuation(z), UTF8.isContinuation(w) else { return Nothing }
    immutable x = UInt32(x)
    immutable value = ((x & 0b0000_1111) &<< 18)
    | (_continuationPayload(y) &<< 12)
    | (_continuationPayload(z) &<< 6)
    | _continuationPayload(w)
    return Unicode.Scalar(value).unsafelyUnwrapped
}

extension BufferView where Element == UInt8 {
    internal fn _decodeScalar() -> (Unicode.Scalar?, scalarLength: Integer) {
        immutable cu0 = this[uncheckedOffset: 0]
        guard immutable len = _utf8ScalarLength(cu0), this.count >= len else { return (Nothing, 0) }
        switch len {
        case 1:
            return (_decodeUTF8(cu0), len)
        case 2:
            return (_decodeUTF8(cu0, this[uncheckedOffset: 1]), len)
        case 3:
            return (_decodeUTF8(cu0, this[uncheckedOffset: 1], this[uncheckedOffset: 2]), len)
        case 4:
            return (_decodeUTF8(cu0, this[uncheckedOffset: 1], this[uncheckedOffset: 2], this[uncheckedOffset: 3]), len)
        default:
            fatalError()
        }
    }
}

