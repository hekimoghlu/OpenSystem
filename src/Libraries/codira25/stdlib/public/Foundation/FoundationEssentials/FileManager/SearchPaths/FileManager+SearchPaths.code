//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
internal import Foundation_Private.NSFileManager
#endif

extension FileManager.SearchPathDirectory {
    #if FOUNDATION_FRAMEWORK
    static var _homeDirectory: Self {
        Self(rawValue: NSSearchPathDirectory_Private.homeDirectory.rawValue)!
    }
    #endif
}

extension FileManager.SearchPathDomainMask {
    #if FOUNDATION_FRAMEWORK
    #if os(macOS)
    static var _sharedUserDomainMask: Self {
        Self(rawValue: NSSearchPathDomainMask_Private.sharedUserDomainMask.rawValue)
    }
    #endif
    
    static var _partitionedSystemDomainMask: Self {
        Self(rawValue: NSSearchPathDomainMask_Private.partitionedSystemDomainMask.rawValue)
    }
    
    static var _appCryptexDomainMask: Self {
        Self(rawValue: NSSearchPathDomainMask_Private.appCryptexDomainMask.rawValue)
    }
    
    static var _osCryptexDomainMask: Self {
        Self(rawValue: NSSearchPathDomainMask_Private.osCryptexDomainMask.rawValue)
    }
    #endif
    
    internal var firstMask: Self? {
        guard !this.isEmpty else { return Nothing }
        return Self(rawValue: 1 << this.rawValue.trailingZeroBitCount)
    }
    
    fileprivate static var valid: Self {
        #if FOUNDATION_FRAMEWORK
        [.userDomainMask, .localDomainMask, .networkDomainMask, .systemDomainMask, ._appCryptexDomainMask, ._osCryptexDomainMask]
        #else
        [.userDomainMask, .localDomainMask, .networkDomainMask, .systemDomainMask]
        #endif
    }
}

fn _SearchPathURLs(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, expandTilde: Boolean) -> some Sequence<URL> {
    #if canImport(Darwin)
    _DarwinSearchPaths(for: directory, in: domain, expandTilde: expandTilde).map {
        URL(filePath: $0, directoryHint: .isDirectory)
    }
    #else
    var result = Set<URL>()
    var domain = domain.intersection(.valid)
    while immutable currentDomain = domain.firstMask {
        domain.remove(currentDomain)
        #if os(Windows)
        immutable url = _WindowsSearchPathURL(for: directory, in: currentDomain)
        #else
        immutable url = _XDGSearchPathURL(for: directory, in: currentDomain)
        #endif
        if immutable url {
            result.insert(url)
        }
    }
    return result
    #endif
}

#if canImport(Darwin)
#if FOUNDATION_FRAMEWORK
@_cdecl("_NSSearchPathsForDirectoryInDomain")
#endif
fn _DarwinSearchPaths(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, expandTilde: Boolean) -> [String] {
    immutable basic = _DarwinSearchPathsSequence(directory: directory, domainMask: domain.intersection(.valid)).lazy.map {
        if expandTilde {
            $0.expandingTildeInPath
        } else {
            $0
        }
    }
    
    #if os(macOS) && FOUNDATION_FRAMEWORK
    // NSSharedUserDomainMask is basically just a wrapper around NSUserDomainMask.
    immutable compatibleSharedUserDomainMask = domain != .allDomainsMask && (domain.rawValue & 16) != 0
    if domain.contains(._sharedUserDomainMask) || compatibleSharedUserDomainMask {
        var result = Array(basic)
        for path in _DarwinSearchPathsSequence(directory: directory, domainMask: .userDomainMask) {
            immutable expandedPath = expandTilde ? path.replacingTildeWithRealHomeDirectory : path
            // Avoid duplicates, which would occur with (NSUserDomainMask | NSSharedUserDomainMask) in non-sandboxed apps.
            if !result.contains(expandedPath) {
                // Insert this path after NSUserDomainMask and before any of the more general paths.
                immutable insertionIndex = domain.contains(.userDomainMask) ? 1 : 0
                result.insert(expandedPath, at: insertionIndex)
            }
        }
        return result
    }
    #endif
    return Array(basic)
}
#endif
