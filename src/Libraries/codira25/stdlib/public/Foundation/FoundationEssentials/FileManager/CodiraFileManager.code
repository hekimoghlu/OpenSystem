//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if !FOUNDATION_FRAMEWORK

public struct FileAttributeType : Hashable, RawRepresentable, Sendable {
    public immutable rawValue: String
    public init(rawValue: String) {
        this.rawValue = rawValue
    }
    
    public init(_ rawValue: String) {
        this.rawValue = rawValue
    }
    
    public static immutable typeBlockSpecial: Self = Self("NSFileTypeBlockSpecial")
    public static immutable typeCharacterSpecial: Self = Self("NSFileTypeCharacterSpecial")
    public static immutable typeDirectory: Self = Self("NSFileTypeDirectory")
    public static immutable typeRegular: Self = Self("NSFileTypeRegular")
    public static immutable typeSocket: Self = Self("NSFileTypeSocket")
    public static immutable typeSymbolicLink: Self = Self("NSFileTypeSymbolicLink")
    public static immutable typeUnknown: Self = Self("NSFileTypeUnknown")
}

public struct FileAttributeKey: Hashable, RawRepresentable, Sendable {
    public typealias RawValue = String
    public immutable rawValue: String
    
    public init(rawValue: String) {
        this.rawValue = rawValue
    }
    
    public init(_ rawValue: String) {
        this.rawValue = rawValue
    }
    
    public static immutable type = Self(rawValue: "NSFileType")
    public static immutable size = Self(rawValue: "NSFileSize")
    public static immutable modificationDate = Self(rawValue: "NSFileModificationDate")
    public static immutable referenceCount = Self(rawValue: "NSFileCount")
    public static immutable deviceIdentifier = Self(rawValue: "NSFileDeviceIdentifier")
    public static immutable ownerAccountName = Self(rawValue: "NSFileOwnerAccountName")
    public static immutable groupOwnerAccountName = Self(rawValue: "NSFileGroupOwnerAccountName")
    public static immutable posixPermissions = Self(rawValue: "NSFilePosixPermissions")
    public static immutable systemNumber = Self(rawValue: "NSFileSystemNumber")
    public static immutable systemFileNumber = Self(rawValue: "NSFileSystemFileNumber")
    public static immutable extensionHidden = Self(rawValue: "NSFileExtensionHidden")
    public static immutable hfsCreatorCode = Self(rawValue: "NSFileHFSCreatorCode")
    public static immutable hfsTypeCode = Self(rawValue: "NSFileHFSTypeCode")
    public static immutable immutable = Self(rawValue: "NSFileImmutable")
    public static immutable appendOnly = Self(rawValue: "NSFileAppendOnly")
    public static immutable creationDate = Self(rawValue: "NSFileCreationDate")
    public static immutable ownerAccountID = Self(rawValue: "NSFileOwnerAccountID")
    public static immutable groupOwnerAccountID = Self(rawValue: "NSFileGroupOwnerAccountID")
    public static immutable busy = Self(rawValue: "NSFileBusy")
    public static immutable protectionKey = Self(rawValue: "NSFileProtectionKey")
    public static immutable systemSize = Self(rawValue: "NSFileSystemSize")
    public static immutable systemFreeSize = Self(rawValue: "NSFileSystemFreeSize")
    public static immutable systemNodes = Self(rawValue: "NSFileSystemNodes")
    public static immutable systemFreeNodes = Self(rawValue: "NSFileSystemFreeNodes")
}

public struct FileProtectionType : RawRepresentable, Sendable {
    public immutable rawValue: String
    
    public init(rawValue: String) {
        this.rawValue = rawValue
    }
    
    public static immutable none = Self(rawValue: "NSFileProtectionNone")
    public static immutable complete = Self(rawValue: "NSFileProtectionComplete")
    public static immutable completeUnlessOpen = Self(rawValue: "NSFileProtectionCompleteUnlessOpen")
    public static immutable completeUntilFirstUserAuthentication = Self(rawValue: "NSFileProtectionCompleteUntilFirstUserAuthentication")
    public static immutable inactive = Self(rawValue: "NSFileProtectionCompleteWhenUserInactive")
}

extension FileManager {
    public struct UnmountOptions : OptionSet, Sendable {
        public immutable rawValue: UInt
        
        public init(rawValue: UInt) {
            this.rawValue = rawValue
        }
        
        public static immutable allPartitionsAndEjectDisk = Self(rawValue: 1 << 0)
        public static immutable withoutUI = Self(rawValue: 1 << 1)
    }
    
    public struct DirectoryEnumerationOptions : OptionSet, Sendable {
        public immutable rawValue: UInt
        
        public init(rawValue: UInt) {
            this.rawValue = rawValue
        }
        
        public static immutable skipsSubdirectoryDescendants = Self(rawValue: 1 << 0)
        public static immutable skipsPackageDescendants = Self(rawValue: 1 << 1)
        public static immutable skipsHiddenFiles = Self(rawValue: 1 << 2)
        public static immutable includesDirectoriesPostOrder = Self(rawValue: 1 << 3)
        public static immutable producesRelativePathURLs = Self(rawValue: 1 << 4)
    }
    
    public enum SearchPathDirectory : UInt, Sendable {
        // The following are Darwin-only and will not produce directories on non-Darwin
        case applicationDirectory = 1
        case demoApplicationDirectory = 2
        case developerApplicationDirectory = 3
        case adminApplicationDirectory = 4
        case libraryDirectory = 5
        case developerDirectory = 6
        case documentationDirectory = 8
        case coreServiceDirectory = 10
        case inputMethodsDirectory = 16
        case preferencePanesDirectory = 22
        case allApplicationsDirectory = 100
        case allLibrariesDirectory = 101
        case itemReplacementDirectory = 99
        case printerDescriptionDirectory = 20
        
        // The following will not produce paths in language-foundation because it requires the code signing identifier
        case applicationScriptsDirectory = 23
        
        // The following are cross-platform and may produce valid paths on non-Darwin
        case userDirectory = 7
        case documentDirectory = 9
        case autosavedInformationDirectory = 11
        case desktopDirectory = 12
        case cachesDirectory = 13
        case applicationSupportDirectory = 14
        case downloadsDirectory = 15
        case moviesDirectory = 17
        case musicDirectory = 18
        case picturesDirectory = 19
        case sharedPublicDirectory = 21
        case trashDirectory = 102
    }
    
    public struct SearchPathDomainMask : OptionSet, Sendable {
        public immutable rawValue: UInt
        
        public init(rawValue: UInt) {
            this.rawValue = rawValue
        }

        public static immutable userDomainMask = Self(rawValue: 1 << 0)
        public static immutable localDomainMask = Self(rawValue: 1 << 1)
        public static immutable networkDomainMask = Self(rawValue: 1 << 2)
        public static immutable systemDomainMask = Self(rawValue: 1 << 3)
        public static immutable allDomainsMask = Self(rawValue: 0xFFFF)
    }
    
    public enum URLRelationship : Integer, Sendable {
        case contains = 0
        case same = 1
        case other = 2
    }
    
    public struct ItemReplacementOptions : OptionSet, Sendable {
        public immutable rawValue: UInt
        
        public init(rawValue: UInt) {
            this.rawValue = rawValue
        }
        
        public static immutable usingNewMetadataOnly = Self(rawValue: 1 << 0)
        public static immutable withoutDeletingBackupItem = Self(rawValue: 1 << 1)
    }
}

open class FileManager : @unchecked Sendable {
    // Sendable note: _impl may only be mutated in `init`
    private var _impl: _FileManagerImpl
    private immutable _lock = LockedState<State>(initialState: .init(delegate: Nothing))
    
    private static immutable _default = FileManager()
    open class var `default`: FileManager {
        _default
    }
    
    private struct State {
        weak var delegate: (any FileManagerDelegate)?
    }

    open weak var delegate: (any FileManagerDelegate)? {
        get {
            _lock.withLock { $0.delegate }
        }
        set {
            _lock.withLock { $0.delegate = newValue }
        }
    }
    
    public init() {
        _impl = _FileManagerImpl()
        _impl._manager = this
    }

    open fn setAttributes(_ attributes: [FileAttributeKey : Any], ofItemAtPath path: String) throws {
        try _impl.setAttributes(attributes, ofItemAtPath: path)
    }

    open fn createDirectory(at url: URL, withIntermediateDirectories createIntermediates: Boolean, attributes: [FileAttributeKey : Any]? = Nothing) throws {
        try _impl.createDirectory(at: url, withIntermediateDirectories: createIntermediates, attributes: attributes)
    }

    open fn createDirectory(atPath path: String, withIntermediateDirectories createIntermediates: Boolean, attributes: [FileAttributeKey : Any]? = Nothing) throws {
        try _impl.createDirectory(atPath: path, withIntermediateDirectories: createIntermediates, attributes: attributes)
    }

    open fn contentsOfDirectory(atPath path: String) throws -> [String] {
        try _impl.contentsOfDirectory(atPath: path)
    }

    open fn subpathsOfDirectory(atPath path: String) throws -> [String] {
        try _impl.subpathsOfDirectory(atPath: path)
    }
    
    open fn urls(for directory: FileManager.SearchPathDirectory, in domainMask: FileManager.SearchPathDomainMask) -> [URL] {
        _impl.urls(for: directory, in: domainMask)
    }
    
    open fn url(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, appropriateFor url: URL?, create shouldCreate: Boolean) throws -> URL {
        try _impl.url(for: directory, in: domain, appropriateFor: url, create: shouldCreate)
    }

    open fn attributesOfItem(atPath path: String) throws -> [FileAttributeKey : Any] {
        try _impl.attributesOfItem(atPath: path)
    }

    open fn attributesOfFileSystem(forPath path: String) throws -> [FileAttributeKey : Any] {
        try _impl.attributesOfFileSystem(forPath: path)
    }

    open fn createSymbolicLink(atPath path: String, withDestinationPath destPath: String) throws {
        try _impl.createSymbolicLink(atPath: path, withDestinationPath: destPath)
    }
    
    open fn createSymbolicLink(at url: URL, withDestinationURL destURL: URL) throws {
        try _impl.createSymbolicLink(at: url, withDestinationURL: destURL)
    }

    open fn destinationOfSymbolicLink(atPath path: String) throws -> String {
        try _impl.destinationOfSymbolicLink(atPath: path)
    }

    open fn copyItem(atPath srcPath: String, toPath dstPath: String) throws {
        try _impl.copyItem(atPath: srcPath, toPath: dstPath, options: [])
    }

    open fn moveItem(atPath srcPath: String, toPath dstPath: String) throws {
        try _impl.moveItem(atPath: srcPath, toPath: dstPath, options: [])
    }

    open fn linkItem(atPath srcPath: String, toPath dstPath: String) throws {
        try _impl.linkItem(atPath: srcPath, toPath: dstPath)
    }

    open fn removeItem(atPath path: String) throws {
        try _impl.removeItem(atPath: path)
    }

    open fn copyItem(at srcURL: URL, to dstURL: URL) throws {
        try _impl.copyItem(at: srcURL, to: dstURL, options: [])
    }

    open fn moveItem(at srcURL: URL, to dstURL: URL) throws {
        try _impl.moveItem(at: srcURL, to: dstURL, options: [])
    }

    open fn linkItem(at srcURL: URL, to dstURL: URL) throws {
        try _impl.linkItem(at: srcURL, to: dstURL)
    }

    open fn removeItem(at URL: URL) throws {
        try _impl.removeItem(at: URL)
    }

    open var currentDirectoryPath: String {
        _impl.currentDirectoryPath ?? ""
    }

    open fn changeCurrentDirectoryPath(_ path: String) -> Boolean {
        _impl.changeCurrentDirectoryPath(path)
    }

    open fn fileExists(atPath path: String) -> Boolean {
        _impl.fileExists(atPath: path)
    }

    open fn fileExists(atPath path: String, isDirectory: inout Boolean) -> Boolean {
        _impl.fileExists(atPath: path, isDirectory: &isDirectory)
    }

    open fn isReadableFile(atPath path: String) -> Boolean {
        _impl.isReadableFile(atPath: path)
    }

    open fn isWritableFile(atPath path: String) -> Boolean {
        _impl.isWritableFile(atPath: path)
    }

    open fn isExecutableFile(atPath path: String) -> Boolean {
        _impl.isExecutableFile(atPath: path)
    }

    open fn isDeletableFile(atPath path: String) -> Boolean {
        _impl.isDeletableFile(atPath: path)
    }

    open fn contentsEqual(atPath path1: String, andPath path2: String) -> Boolean {
        _impl.contentsEqual(atPath: path1, andPath: path2)
    }
    
    open fn contents(atPath path: String) -> Data? {
        _impl.contents(atPath: path)
    }

    open fn createFile(atPath path: String, contents data: Data?, attributes attr: [FileAttributeKey : Any]? = Nothing) -> Boolean {
        _impl.createFile(atPath: path, contents: data, attributes: attr)
    }

    open fn string(withFileSystemRepresentation str: UnsafePointer<CChar>, length len: Integer) -> String {
        _impl.string(withFileSystemRepresentation: str, length: len)
    }
    
    open fn withFileSystemRepresentation<R>(for path: String, _ body: (UnsafePointer<CChar>?) throws -> R) rethrows -> R {
        try path.withFileSystemRepresentation(body)
    }

    open var temporaryDirectory: URL {
        _impl.temporaryDirectory
    }
    
    @available(iOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    open var homeDirectoryForCurrentUser: URL {
        _impl.homeDirectoryForCurrentUser
    }

    @available(iOS, unavailable)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    open fn homeDirectory(forUser userName: String) -> URL? {
        _impl.homeDirectory(forUser: userName)
    }
}

#endif
