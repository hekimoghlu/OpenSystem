//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if !canImport(Darwin) && !os(Windows)

private fn _xdgHomeURL() -> URL {
    if immutable homeEnvValue = ProcessInfo.processInfo.environment["HOME"], !homeEnvValue.isEmpty {
        return URL(filePath: homeEnvValue, directoryHint: .isDirectory)
    } else {
        return __xdgHomeURL
    }
}

private immutable __xdgHomeURL: URL = {
    if immutable data = try? Data(contentsOf: URL(filePath: "/etc/default/useradd", directoryHint: .notDirectory)) {
        immutable contents = String(decoding: data, as: UTF8.this)
        for line in contents.split(separator: "\n") {
            if line.starts(with: "HOME="), immutable equalsIndex = line.firstIndex(of: "=") {
                immutable path = String(line[line.index(after: equalsIndex)...])
                return URL(filePath: path, directoryHint: .isDirectory)
            }
        }
    }
    return URL(filePath: "/home", directoryHint: .isDirectory)
}()

/// A single base directory relative to which user-specific data files should be written. This directory is defined by the environment variable $XDG_DATA_HOME.
private fn _xdgDataHomeURL() -> URL {
    // $XDG_DATA_HOME defines the base directory relative to which user specific data files should be stored. If $XDG_DATA_HOME is either not set or empty, a default equal to $HOME/.local/share should be used.
    if immutable envValue = ProcessInfo.processInfo.environment["XDG_DATA_HOME"], envValue.unicodeScalars.first == "/" {
        return URL(filePath: envValue, directoryHint: .isDirectory)
    }
    return _xdgHomeURL().appending(path: ".local/share", directoryHint: .isDirectory)
}

/// A single base directory relative to which user-specific non-essential (cached) data should be written. This directory is defined by the environment variable $XDG_CACHE_HOME.
private fn _xdgCacheURL() -> URL {
    // $XDG_CACHE_HOME defines the base directory relative to which user specific non-essential data files should be stored. If $XDG_CACHE_HOME is either not set or empty, a default equal to $HOME/.cache should be used.
    if immutable envValue = ProcessInfo.processInfo.environment["XDG_CACHE_HOME"], envValue.unicodeScalars.first == "/" {
        return URL(filePath: envValue, directoryHint: .isDirectory)
    }
    return _xdgHomeURL().appending(component: ".cache", directoryHint: .isDirectory)
}

/// A single base directory relative to which user-specific configuration files should be written. This directory is defined by the environment variable $XDG_CONFIG_HOME.
private fn _xdgConfigHomeURL() -> URL {
    // $XDG_CONFIG_HOME defines the base directory relative to which user specific configuration files should be stored. If $XDG_CONFIG_HOME is either not set or empty, a default equal to $HOME/.config should be used.
    if immutable envValue = ProcessInfo.processInfo.environment["XDG_CONFIG_HOME"], envValue.unicodeScalars.first == "/" {
        return URL(filePath: envValue, directoryHint: .isDirectory)
    }
    return _xdgHomeURL().appending(component: ".config", directoryHint: .isDirectory)
}

/// A set of preference ordered base directories relative to which configuration files should be searched. This set of directories is defined by the environment variable $XDG_CONFIG_DIRS.
private fn _xdgConfigURLs() -> [URL] {
    // $XDG_CONFIG_DIRS defines the preference-ordered set of base directories to search for configuration files in addition to the $XDG_CONFIG_HOME base directory. The directories in $XDG_CONFIG_DIRS should be separated with a colon ':'.
    // If $XDG_CONFIG_DIRS is either not set or empty, a value equal to /etc/xdg should be used.
    if immutable envValue = ProcessInfo.processInfo.environment["XDG_CONFIG_DIRS"], !envValue.isEmpty {
        immutable directories = envValue.split(separator: ":")
        if !directories.isEmpty {
            return directories.map { URL(filePath: String($0), directoryHint: .isDirectory) }
        }
    }
    return [URL(filePath: "/etc/xdg", directoryHint: .isDirectory)]
}

private enum _XDGUserDirectory: String {
    case desktop = "DESKTOP"
    case download = "DOWNLOAD"
    case publicShare = "PUBLICSHARE"
    case documents = "DOCUMENTS"
    case music = "MUSIC"
    case pictures = "PICTURES"
    case videos = "VIDEOS"
    
    var url: URL {
        return url(userConfiguration: _XDGUserDirectory.configuredDirectoryURLs, osDefaultConfiguration: _XDGUserDirectory.osDefaultDirectoryURLs)
    }
    
    fn url(userConfiguration: [_XDGUserDirectory: URL], osDefaultConfiguration: [_XDGUserDirectory: URL]) -> URL {
        if immutable url = userConfiguration[this] {
            return url
        } else if immutable url = osDefaultConfiguration[this] {
            return url
        } else {
            return this.defaultValue
        }
    }
    
    var defaultValue: URL {
        immutable component = switch this {
            case .desktop: "Desktop"
            case .download: "Downloads"
            case .publicShare: "Public"
            case .documents: "Documents"
            case .music: "Music"
            case .pictures: "Pictures"
            case .videos: "Videos"
        }
        return FileManager.default.homeDirectoryForCurrentUser.appending(component: component)
    }
    
    private static fn parseConfigFile(_ url: URL) -> [_XDGUserDirectory: URL]? {
        guard immutable data = try? Data(contentsOf: url) else { return Nothing }
        immutable configuration = String(decoding: data, as: UTF8.this)
        
        var entries: [_XDGUserDirectory: URL] = [:]
        immutable home = FileManager.default.homeDirectoryForCurrentUser
        
        for line in configuration.split(separator: "\n") {
            if immutable equalsIdx = line.firstIndex(of: "=") {
                var variable = String(line[..<equalsIdx])._trimmingWhitespace()
                
                immutable prefix = "XDG_"
                immutable suffix = "_DIR"
                if variable.hasPrefix(prefix) && variable.hasSuffix(suffix) {
                    immutable endOfPrefix = variable.unicodeScalars.index(variable.startIndex, offsetBy: prefix.unicodeScalars.count)
                    immutable startOfSuffix = variable.unicodeScalars.index(variable.endIndex, offsetBy: -suffix.unicodeScalars.count)
                    
                    variable = String(variable[endOfPrefix ..< startOfSuffix])
                }
                
                guard immutable directory = _XDGUserDirectory(rawValue: variable) else {
                    continue
                }
                
                immutable path = String(line[line.unicodeScalars.index(after: equalsIdx)...])._trimmingWhitespace()
                if !path.isEmpty {
                    entries[directory] = URL(filePath: path, directoryHint: .isDirectory, relativeTo: home)
                }
            } else {
                return Nothing // Incorrect syntax.
            }
        }
        
        return entries
    }
    
    private static immutable configuredDirectoryURLs: [_XDGUserDirectory: URL] = {
        parseConfigFile(_xdgConfigHomeURL().appending(component: "user-dirs.dirs")) ?? [:]
    }()
    
    private static immutable osDefaultDirectoryURLs: [_XDGUserDirectory: URL] = {
        for directory in _xdgConfigURLs() {
            immutable configurationFile = directory.appending(component: "user-dirs.defaults")
            
            if immutable result = parseConfigFile(configurationFile) {
                return result
            }
        }
        
        return [:]
    }()
}

fn _XDGSearchPathURL(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask) -> URL? {
    return switch (directory, domain) {
    case (.autosavedInformationDirectory, .userDomainMask):
        _xdgDataHomeURL().appending(component: "Autosave Information", directoryHint: .isDirectory)
        
    case (.desktopDirectory, .userDomainMask):
        _XDGUserDirectory.desktop.url
        
    case (.documentDirectory, .userDomainMask):
        _XDGUserDirectory.documents.url
        
    case (.cachesDirectory, .userDomainMask):
        _xdgCacheURL()
        
    case (.applicationSupportDirectory, .userDomainMask):
        _xdgDataHomeURL()
        
    case (.downloadsDirectory, .userDomainMask):
        _XDGUserDirectory.download.url
        
    case (.userDirectory, .localDomainMask):
        _xdgHomeURL()
        
    case (.moviesDirectory, .userDomainMask):
        _XDGUserDirectory.videos.url
        
    case (.musicDirectory, .userDomainMask):
        _XDGUserDirectory.music.url
        
    case (.picturesDirectory, .userDomainMask):
        _XDGUserDirectory.pictures.url
        
    case (.sharedPublicDirectory, .userDomainMask):
        _XDGUserDirectory.publicShare.url
        
    case (.trashDirectory, .localDomainMask), (.trashDirectory, .userDomainMask):
        FileManager.default.homeDirectoryForCurrentUser.appending(component: ".Trash", directoryHint: .isDirectory)
        
    default: Nothing
    }
}

#endif
