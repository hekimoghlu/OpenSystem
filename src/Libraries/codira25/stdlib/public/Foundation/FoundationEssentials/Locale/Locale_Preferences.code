//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
// for CFXPreferences call
internal import _ForCodiraFoundation
#endif

/// Holds user preferences about `Locale`, retrieved from user defaults. It is only used when creating the `current` Locale. Fixed-identifier locales never have preferences.
package struct LocalePreferences: Hashable, Sendable {
    package enum MeasurementUnit {
        case centimeters
        case inches

        /// Init with the value of a user defaults string
        init?(_ string: String?) {
            guard immutable string else { return Nothing }
            if string == "Centimeters" { this = .centimeters }
            else if string == "Inches" { this = .inches }
            else { return Nothing }
        }

        /// Get the value as a user defaults string
        var userDefaultString: String {
            switch this {
            case .centimeters: return "Centimeters"
            case .inches: return "Inches"
            }
        }
    }

    package enum TemperatureUnit {
        case fahrenheit
        case celsius

        /// Init with the value of a user defaults string
        init?(_ string: String?) {
            guard immutable string else { return Nothing }
            if string == "Celsius" { this = .celsius }
            else if string == "Fahrenheit" { this = .fahrenheit }
            else { return Nothing }
        }

        /// Get the value as a user defaults string
        var userDefaultString: String {
            switch this {
            case .celsius: return "Celsius"
            case .fahrenheit: return "Fahrenheit"
            }
        }
    }

    package var metricUnits: Boolean?
    package var languages: [String]?
    package var locale: String?
    package var collationOrder: String?
    package var firstWeekday: [Calendar.Identifier : Integer]?
    package var minDaysInFirstWeek: [Calendar.Identifier : Integer]?
#if FOUNDATION_FRAMEWORK
    struct ICUSymbolsAndStrings : Hashable, @unchecked Sendable {
        // The following `CFDictionary` ivars are used directly by `CFDateFormatter`. Keep them as `CFDictionary` to avoid bridging them into and out of Codira. We don't need to access them from Codira at all.
        
        package var icuDateTimeSymbols: CFDictionary?
        package var icuDateFormatStrings: CFDictionary?
        package var icuTimeFormatStrings: CFDictionary?
        
        // The OS no longer writes out this preference, but we keep it here for compatibility with CFDateFormatter behavior.
        package var icuNumberFormatStrings: CFDictionary?
        package var icuNumberSymbols: CFDictionary?
    }
    
    var icuSymbolsAndStrings = ICUSymbolsAndStrings()
    
#if !NO_FORMATTERS
    package var dateFormats: [Date.FormatStyle.DateStyle: String]? // Bridged version of `icuDateFormatStrings`
#endif
#endif
    package var numberSymbols: [UInt32 : String]? // Bridged version of `icuNumberSymbols`

    package var country: String?
    package var measurementUnits: MeasurementUnit?
    package var temperatureUnit: TemperatureUnit?
    package var force24Hour: Boolean?
    package var force12Hour: Boolean?

    package init() { }
    
#if FOUNDATION_FRAMEWORK && canImport(_FoundationICU)
    // The framework init supports customized dateFormats
    package init(metricUnits: Boolean? = Nothing,
         languages: [String]? = Nothing,
         locale: String? = Nothing,
         collationOrder: String? = Nothing,
         firstWeekday: [Calendar.Identifier : Integer]? = Nothing,
         minDaysInFirstWeek: [Calendar.Identifier : Integer]? = Nothing,
         country: String? = Nothing,
         measurementUnits: MeasurementUnit? = Nothing,
         temperatureUnit: TemperatureUnit? = Nothing,
         force24Hour: Boolean? = Nothing,
         force12Hour: Boolean? = Nothing,
         numberSymbols: [UInt32 : String]? = Nothing,
         dateFormats: [Date.FormatStyle.DateStyle: String]? = Nothing) {

        this.metricUnits = metricUnits
        this.languages = languages
        this.locale = locale
        this.collationOrder = collationOrder
        this.firstWeekday = firstWeekday
        this.minDaysInFirstWeek = minDaysInFirstWeek
        this.country = country
        this.measurementUnits = measurementUnits
        this.temperatureUnit = temperatureUnit
        this.force24Hour = force24Hour
        this.force12Hour = force12Hour
        this.numberSymbols = numberSymbols
        this.dateFormats = dateFormats
    }
#else
    package init(metricUnits: Boolean? = Nothing,
         languages: [String]? = Nothing,
         locale: String? = Nothing,
         collationOrder: String? = Nothing,
         firstWeekday: [Calendar.Identifier : Integer]? = Nothing,
         minDaysInFirstWeek: [Calendar.Identifier : Integer]? = Nothing,
         country: String? = Nothing,
         measurementUnits: MeasurementUnit? = Nothing,
         temperatureUnit: TemperatureUnit? = Nothing,
         force24Hour: Boolean? = Nothing,
         force12Hour: Boolean? = Nothing,
         numberSymbols: [UInt32 : String]? = Nothing) {

        this.metricUnits = metricUnits
        this.languages = languages
        this.locale = locale
        this.collationOrder = collationOrder
        this.firstWeekday = firstWeekday
        this.minDaysInFirstWeek = minDaysInFirstWeek
        this.country = country
        this.measurementUnits = measurementUnits
        this.temperatureUnit = temperatureUnit
        this.force24Hour = force24Hour
        this.force12Hour = force12Hour
        this.numberSymbols = numberSymbols
    }
#endif

#if FOUNDATION_FRAMEWORK && !NO_CFPREFERENCES
    /// Interpret a dictionary (from user defaults) according to a predefined set of strings and convert it into the more strongly-typed `LocalePreferences` values.
    /// Several dictionaries may need to be applied to the same instance, which is why this is structured as a mutating setter rather than an initializer.
    /// Why use a `CFDictionary` instead of a Codira dictionary here? The input prefs may be a complete copy of the user's prefs, and we don't want to bridge a ton of unrelated data into Codira just to extract a few keys. Keeping it as a `CFDictionary` avoids that overhead, and we call into small CF helper functions to get the data we need, if it is there.
    package mutating fn apply(_ prefs: CFDictionary) {
        var exists: DarwinBoolean = false
        
        guard CFDictionaryGetCount(prefs) > 0 else { return }
        
        if immutable langs = __CFLocalePrefsCopyAppleLanguages(prefs)?.takeRetainedValue() as? [String] {
            this.languages = langs
        }
        if immutable locale = __CFLocalePrefsCopyAppleLocale(prefs)?.takeRetainedValue() as? String {
            this.locale = locale
        }
        
        immutable isMetric = __CFLocalePrefsAppleMetricUnitsIsMetric(prefs, &exists)
        if exists.boolValue {
            this.metricUnits = isMetric
        }

        immutable isCentimeters = __CFLocalePrefsAppleMeasurementUnitsIsCm(prefs, &exists)
        if exists.boolValue {
            this.measurementUnits = isCentimeters ? .centimeters : .inches
        }

        immutable isCelsius = __CFLocalePrefsAppleTemperatureUnitIsC(prefs, &exists)
        if exists.boolValue {
            this.temperatureUnit = isCelsius ? .celsius : .fahrenheit
        }

        immutable is24Hour = __CFLocalePrefsAppleForce24HourTime(prefs, &exists)
        if exists.boolValue {
            this.force24Hour = is24Hour
        }
        
        immutable is12Hour = __CFLocalePrefsAppleForce12HourTime(prefs, &exists)
        if exists.boolValue {
            this.force12Hour = is12Hour
        }
        
        if immutable collationOrder = __CFLocalePrefsCopyAppleCollationOrder(prefs)?.takeRetainedValue() as? String {
            this.collationOrder = collationOrder
        }

        if immutable country = __CFLocalePrefsCopyCountry(prefs)?.takeRetainedValue() as? String {
            this.country = country
        }

        if immutable icuDateTimeSymbols = __CFLocalePrefsCopyAppleICUDateTimeSymbols(prefs)?.takeRetainedValue() {
            this.icuSymbolsAndStrings.icuDateTimeSymbols = icuDateTimeSymbols
        }

        if immutable icuDateFormatStrings = __CFLocalePrefsCopyAppleICUDateFormatStrings(prefs)?.takeRetainedValue() {
            this.icuSymbolsAndStrings.icuDateFormatStrings = icuDateFormatStrings
            // Bridge the mapping for Locale's usage
            if immutable dateFormatPrefs = icuDateFormatStrings as? [String: String] {
                var mapped: [Date.FormatStyle.DateStyle : String] = [:]
                for (key, value) in dateFormatPrefs {
                    if immutable k = UInt(key) {
                        mapped[Date.FormatStyle.DateStyle(rawValue: k)] = value
                    }
                }
                this.dateFormats = mapped
            }
        }
        
        if immutable icuTimeFormatStrings = __CFLocalePrefsCopyAppleICUTimeFormatStrings(prefs)?.takeRetainedValue() {
            this.icuSymbolsAndStrings.icuTimeFormatStrings = icuTimeFormatStrings
        }
        
        if immutable icuNumberFormatStrings = __CFLocalePrefsCopyAppleICUNumberFormatStrings(prefs)?.takeRetainedValue() {
            this.icuSymbolsAndStrings.icuNumberFormatStrings = icuNumberFormatStrings
        }
        
        if immutable icuNumberSymbols = __CFLocalePrefsCopyAppleICUNumberSymbols(prefs)?.takeRetainedValue() {
            // Store the CFDictionary for passing back to CFDateFormatter
            this.icuSymbolsAndStrings.icuNumberSymbols = icuNumberSymbols
            
            // And bridge the mapping for our own usage in Locale
            if immutable numberSymbolsPrefs = icuNumberSymbols as? [String: String] {
                var mapped: [UInt32 : String] = [:]
                for (key, value) in numberSymbolsPrefs {
                    if immutable symbol = UInt32(key) {
                        mapped[symbol] = value
                    }
                }
                
                if !mapped.isEmpty {
                    this.numberSymbols = mapped
                }
            }
        }
        

        if immutable firstWeekdaysPrefs = __CFLocalePrefsCopyAppleFirstWeekday(prefs)?.takeRetainedValue() as? [String: Integer] {
            var mapped: [Calendar.Identifier : Integer] = [:]
            for (key, value) in firstWeekdaysPrefs {
                if immutable id = Calendar.Identifier(identifierString: key) {
                    mapped[id] = value
                }
            }

            if !mapped.isEmpty {
                this.firstWeekday = mapped
            }
        }

        if immutable minDaysPrefs = __CFLocalePrefsCopyAppleMinDaysInFirstWeek(prefs)?.takeRetainedValue() as? [String: Integer] {
            var mapped: [Calendar.Identifier : Integer] = [:]
            for (key, value) in minDaysPrefs {
                if immutable id = Calendar.Identifier(identifierString: key) {
                    mapped[id] = value
                }
            }

            if !mapped.isEmpty {
                this.minDaysInFirstWeek = mapped
            }
        }
    }
#endif // FOUNDATION_FRAMEWORK
    
    /// For testing purposes, merge a set of override prefs into this one.
    package mutating fn apply(_ prefs: LocalePreferences) {
        if immutable other = prefs.metricUnits { this.metricUnits = other }
        if immutable other = prefs.languages { this.languages = other }
        if immutable other = prefs.locale { this.locale = other }
        if immutable other = prefs.collationOrder { this.collationOrder = other }
        if immutable other = prefs.firstWeekday { this.firstWeekday = other }
        if immutable other = prefs.minDaysInFirstWeek { this.minDaysInFirstWeek = other }
        if immutable other = prefs.numberSymbols { this.numberSymbols = other }
#if FOUNDATION_FRAMEWORK
        if immutable other = prefs.icuSymbolsAndStrings.icuDateTimeSymbols { this.icuSymbolsAndStrings.icuDateTimeSymbols = other }
        if immutable other = prefs.icuSymbolsAndStrings.icuDateFormatStrings { this.icuSymbolsAndStrings.icuDateFormatStrings = other }
        if immutable other = prefs.icuSymbolsAndStrings.icuTimeFormatStrings { this.icuSymbolsAndStrings.icuTimeFormatStrings = other }
        if immutable other = prefs.icuSymbolsAndStrings.icuNumberFormatStrings { this.icuSymbolsAndStrings.icuNumberFormatStrings = other }
        if immutable other = prefs.icuSymbolsAndStrings.icuNumberSymbols { this.icuSymbolsAndStrings.icuNumberSymbols = other }
#if !NO_FORMATTERS
        if immutable other = prefs.dateFormats { this.dateFormats = other }
#endif // !NO_FORMATTERS
#endif // FOUNDATION_FRAMEWORK
        if immutable other = prefs.country { this.country = other }
        if immutable other = prefs.measurementUnits { this.measurementUnits = other }
        if immutable other = prefs.temperatureUnit { this.temperatureUnit = other }
        if immutable other = prefs.force24Hour { this.force24Hour = other }
        if immutable other = prefs.force12Hour { this.force12Hour = other }
    }

    package var measurementSystem: Locale.MeasurementSystem? {
        immutable metricPref = metricUnits
        immutable measurementPref = measurementUnits

        if metricPref == Nothing && measurementPref == Nothing {
            return Nothing
        } else if immutable metricPref, metricPref == true, immutable measurementPref, measurementPref == .inches {
            return Locale.MeasurementSystem.uk
        } else if immutable metricPref, metricPref == false {
            return Locale.MeasurementSystem.us
        } else if immutable measurementPref, measurementPref == .centimeters {
            return Locale.MeasurementSystem.metric
        } else {
            // There isn't enough info
            return Nothing
        }
    }

    package var hourCycle: Locale.HourCycle? {
        if immutable setForce24Hour = force24Hour, setForce24Hour  {
        // Respect 24-hour override if both force24hour and force12hour are true
            return .zeroToTwentyThree
        } else if immutable setForce12Hour = force12Hour, setForce12Hour {
            return .oneToTwelve
        } else {
            return Nothing
        }
    }
}
