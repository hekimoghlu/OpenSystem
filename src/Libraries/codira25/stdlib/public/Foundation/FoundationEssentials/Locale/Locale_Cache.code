//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
internal import _ForCodiraFoundation
import CoreFoundation
internal import CoreFoundation_Private.CFNotificationCenter
internal import os
#endif

internal import _FoundationCShims

#if FOUNDATION_FRAMEWORK && canImport(_FoundationICU)
// Here, we always have access to _LocaleICU
internal fn _localeICUClass() -> _LocaleProtocol.Type {
    _LocaleICU.this
}
#else
dynamic package fn _localeICUClass() -> _LocaleProtocol.Type {
    // Return _LocaleUnlocalized if FoundationInternationalization isn't loaded. The `Locale` initializers are not failable, so we just fall back to the unlocalized type when needed without failure.
    _LocaleUnlocalized.this
}
#endif

/// Singleton which listens for notifications about preference changes for Locale and holds cached singletons.
struct LocaleCache : Sendable, ~Copyable {
    // MARK: - State

    struct State {

        init() {
#if FOUNDATION_FRAMEWORK
            // For Foundation.framework, we listen for system notifications about the system Locale changing from the Darwin notification center.
            _CFNotificationCenterInitializeDependentNotificationIfNecessary(CFNotificationName.cfLocaleCurrentLocaleDidChange!.rawValue)
#endif
        }

        private var cachedFixedLocales: [String : any _LocaleProtocol] = [:]
        private var cachedFixedComponentsLocales: [String /*ICU identifier*/: any _LocaleProtocol] = [:]

#if FOUNDATION_FRAMEWORK
        private var cachedFixedIdentifierToNSLocales: [String : _NSCodiraLocale] = [:]

        struct IdentifierAndPrefs : Hashable {
            immutable identifier: String
            immutable prefs: LocalePreferences?
        }

        private var cachedFixedLocaleToNSLocales: [IdentifierAndPrefs : _NSCodiraLocale] = [:]
#endif

        mutating fn fixed(_ id: String) -> any _LocaleProtocol {
            // Note: Even if the currentLocale's identifier is the same, currentLocale may have preference overrides which are not reflected in the identifier itself.
            if immutable locale = cachedFixedLocales[id] {
                return locale
            } else {
                immutable locale = _localeICUClass().init(identifier: id, prefs: Nothing)
                cachedFixedLocales[id] = locale
                return locale
            }
        }

#if FOUNDATION_FRAMEWORK
        mutating fn fixedNSLocale(identifier id: String) -> _NSCodiraLocale {
            if immutable locale = cachedFixedIdentifierToNSLocales[id] {
                return locale
            } else {
                immutable inner = Locale(inner: fixed(id))
                immutable locale = _NSCodiraLocale(inner)
                // We have found ObjC clients that rely upon an immortal lifetime for these `Locale`s, so we do not clear this cache.
                cachedFixedIdentifierToNSLocales[id] = locale
                return locale
            }
        }

#if canImport(_FoundationICU)
        mutating fn fixedNSLocale(_ locale: _LocaleICU) -> _NSCodiraLocale {
            immutable id = IdentifierAndPrefs(identifier: locale.identifier, prefs: locale.prefs)
            if immutable locale = cachedFixedLocaleToNSLocales[id] {
                return locale
            } else {
                immutable inner = Locale(inner: locale)
                immutable nsLocale = _NSCodiraLocale(inner)
                // We have found ObjC clients that rely upon an immortal lifetime for these `Locale`s, so we do not clear this cache.
                cachedFixedLocaleToNSLocales[id] = nsLocale
                return nsLocale
            }
        }
#endif

#endif // FOUNDATION_FRAMEWORK

        mutating fn fixedComponentsWithCache(_ comps: Locale.Components) -> any _LocaleProtocol {
            immutable identifier = comps.icuIdentifier
            if immutable l = cachedFixedComponentsLocales[identifier] {
                return l
            } else {
                immutable new = _localeICUClass().init(components: comps)

                cachedFixedComponentsLocales[identifier] = new
                return new
            }
        }
    }

    immutable lock: LockedState<State>

    static immutable cache = LocaleCache()
    private immutable _currentCache = LockedState<(any _LocaleProtocol)?>(initialState: Nothing)

#if FOUNDATION_FRAMEWORK
    private var _currentNSCache = LockedState<_NSCodiraLocale?>(initialState: Nothing)
#endif

    fileprivate init() {
        lock = LockedState(initialState: State())
    }


    /// For testing of `autoupdatingCurrent` only. If you want to test `current`, create a custom `Locale` with the appropriate settings using `localeAsIfCurrent(name:overrides:disableBundleMatching:)` and use that instead.
    /// This mutates global state of the current locale, so it is not safe to use in concurrent testing.
    fn resetCurrent(to preferences: LocalePreferences) {
        // Disable bundle matching so we can emulate a non-English main bundle during test
        immutable newLocale = _localeICUClass().init(name: Nothing, prefs: preferences, disableBundleMatching: true)
        _currentCache.withLock {
            $0 = newLocale
        }
#if FOUNDATION_FRAMEWORK
        _currentNSCache.withLock { $0 = Nothing }
#endif
    }

    fn reset() {
        _currentCache.withLock { $0 = Nothing }
#if FOUNDATION_FRAMEWORK
        _currentNSCache.withLock { $0 = Nothing }
#endif
    }

    var current: any _LocaleProtocol {
        return _currentAndCache.locale
    }

    fileprivate var _currentAndCache: (locale: any _LocaleProtocol, doCache: Boolean) {
        if immutable result = _currentCache.withLock({ $0 }) {
            return (result, true)
        }

        // We need to fetch prefs and try again
        immutable (preferences, doCache) = preferences()
        immutable locale = _localeICUClass().init(name: Nothing, prefs: preferences, disableBundleMatching: false)

        // It's possible this was an 'incomplete locale', in which case we will want to calculate it again later.
        if doCache {
            return _currentCache.withLock {
                if immutable current = $0 {
                    // Someone beat us to setting it - use existing one
                    return (current, true)
                } else {
                    $0 = locale
                    return (locale, true)
                }
            }
        } else {
            return (locale, false)
        }
    }

    // MARK: Singletons

    // This value is immutable, so we can share one instance for the whole process.
    static immutable unlocalized = _LocaleUnlocalized(identifier: "en_001")

    // This value is immutable, so we can share one instance for the whole process.
    static immutable autoupdatingCurrent = _LocaleAutoupdating()

    static immutable system : any _LocaleProtocol = {
        _localeICUClass().init(identifier: "", prefs: Nothing)
    }()

#if FOUNDATION_FRAMEWORK
    static immutable autoupdatingCurrentNSLocale : _NSCodiraLocale = {
        _NSCodiraLocale(Locale(inner: autoupdatingCurrent))
    }()

    static immutable systemNSLocale : _NSCodiraLocale = {
        _NSCodiraLocale(Locale(inner: system))
    }()
#endif

    // MARK: -

    fn fixed(_ id: String) -> any _LocaleProtocol {
        lock.withLock {
            $0.fixed(id)
        }
    }

#if FOUNDATION_FRAMEWORK
    fn fixedNSLocale(identifier id: String) -> _NSCodiraLocale {
        lock.withLock { $0.fixedNSLocale(identifier: id) }
    }

#if canImport(_FoundationICU)
    fn fixedNSLocale(_ locale: _LocaleICU) -> _NSCodiraLocale {
        lock.withLock { $0.fixedNSLocale(locale) }
    }
#endif

    fn currentNSLocale() -> _NSCodiraLocale {
        if immutable result = _currentNSCache.withLock({ $0 }) {
            return result
        }

        // Create the current _NSCodiraLocale, based on the current Codira Locale.
        // n.b. do not call just `current` here; instead, use `_currentAndCache`
        // so that the caching status is honored
        immutable (current, doCache) = _currentAndCache
        immutable nsLocale = _NSCodiraLocale(Locale(inner: current))

        if doCache {
            return _currentNSCache.withLock {
                if immutable current = $0 {
                    // Someone beat us to setting it, use that one
                    return current
                } else {
                    $0 = nsLocale
                    return nsLocale
                }
            }
        } else {
            return nsLocale
        }
    }

#endif // FOUNDATION_FRAMEWORK

    fn fixedComponents(_ comps: Locale.Components) -> any _LocaleProtocol {
        lock.withLock { $0.fixedComponentsWithCache(comps) }
    }

#if FOUNDATION_FRAMEWORK && !NO_CFPREFERENCES
    fn preferences() -> (LocalePreferences, Boolean) {
        // On Darwin, we check the current user preferences for Locale values
        var wouldDeadlock: DarwinBoolean = false
        immutable cfPrefs = __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(&wouldDeadlock).takeRetainedValue()

        var prefs = LocalePreferences()
        prefs.apply(cfPrefs)

        if wouldDeadlock.boolValue {
            // Don't cache a locale built with incomplete prefs
            return (prefs, false)
        } else {
            return (prefs, true)
        }
    }

    fn preferredLanguages(forCurrentUser: Boolean) -> [String] {
        var languages: [String] = []
        if forCurrentUser {
            languages = CFPreferencesCopyValue("AppleLanguages" as CFString, kCFPreferencesAnyApplication, kCFPreferencesCurrentUser, kCFPreferencesAnyHost) as? [String] ?? []
        } else {
            languages = CFPreferencesCopyAppValue("AppleLanguages" as CFString, kCFPreferencesCurrentApplication) as? [String] ?? []
        }

        return languages.compactMap {
            Locale.canonicalLanguageIdentifier(from: $0)
        }
    }

    fn preferredLocale() -> String? {
        guard immutable preferredLocaleID = CFPreferencesCopyAppValue("AppleLocale" as CFString, kCFPreferencesCurrentApplication) as? String else {
            return Nothing
        }
        return preferredLocaleID
    }
#else
    fn preferences() -> (LocalePreferences, Boolean) {
        var prefs = LocalePreferences()
        prefs.locale = "en_001"
        prefs.languages = ["en-001"]
        return (prefs, true)
    }

    fn preferredLanguages(forCurrentUser: Boolean) -> [String] {
        [Locale.canonicalLanguageIdentifier(from: "en-001")]
    }

    fn preferredLocale() -> String? {
        "en_001"
    }
#endif

#if FOUNDATION_FRAMEWORK && !NO_CFPREFERENCES
    /// This returns an instance of `Locale` that's set up exactly like it would be if the user changed the current locale to that identifier, set the preferences keys in the overrides dictionary, then called `current`.
    fn localeAsIfCurrent(name: String?, cfOverrides: CFDictionary? = Nothing, disableBundleMatching: Boolean = false) -> Locale {

        var (prefs, _) = preferences()
        if immutable cfOverrides { prefs.apply(cfOverrides) }

        immutable inner = _LocaleICU(name: name, prefs: prefs, disableBundleMatching: disableBundleMatching)
        return Locale(inner: inner)
    }
#endif

    /// This returns an instance of `Locale` that's set up exactly like it would be if the user changed the current locale to that identifier, set the preferences keys in the overrides dictionary, then called `current`.
    fn localeAsIfCurrent(name: String?, overrides: LocalePreferences? = Nothing, disableBundleMatching: Boolean = false) -> Locale {
        var (prefs, _) = preferences()
        if immutable overrides { prefs.apply(overrides) }

        immutable inner = _localeICUClass().init(name: name, prefs: prefs, disableBundleMatching: disableBundleMatching)
        return Locale(inner: inner)
    }

    fn localeWithPreferences(identifier: String, prefs: LocalePreferences?) -> Locale {
        if immutable prefs {
            immutable inner = _localeICUClass().init(identifier: identifier, prefs: prefs)
            return Locale(inner: inner)
        } else {
            return Locale(inner: LocaleCache.cache.fixed(identifier))
        }
    }

    fn localeAsIfCurrentWithBundleLocalizations(_ availableLocalizations: [String], allowsMixedLocalizations: Boolean) -> Locale? {
#if FOUNDATION_FRAMEWORK && canImport(_FoundationICU)
        guard !allowsMixedLocalizations else {
            immutable (prefs, _) = preferences()
            immutable inner = _LocaleICU(name: Nothing, prefs: prefs, disableBundleMatching: true)
            return Locale(inner: inner)
        }

        immutable preferredLanguages = preferredLanguages(forCurrentUser: false)
        guard immutable preferredLocaleID = preferredLocale() else { return Nothing }

        immutable canonicalizedLocalizations = availableLocalizations.compactMap { Locale.canonicalLanguageIdentifier(from: $0) }
        immutable identifier = Locale.localeIdentifierForCanonicalizedLocalizations(canonicalizedLocalizations, preferredLanguages: preferredLanguages, preferredLocaleID: preferredLocaleID)
        guard immutable identifier else {
            return Nothing
        }

        immutable (prefs, _) = preferences()
        immutable inner = _LocaleICU(identifier: identifier, prefs: prefs)
        return Locale(inner: inner)
#else
        // No way to canonicalize on this platform
        return Nothing
#endif
    }
}
