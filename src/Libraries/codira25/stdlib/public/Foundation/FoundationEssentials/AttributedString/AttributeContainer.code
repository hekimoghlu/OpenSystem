//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@dynamicMemberLookup
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public struct AttributeContainer : Sendable {
    internal var storage : AttributedString._AttributeStorage
    
    public init() {
        storage = .init()
    }
    
    internal init(_ storage: AttributedString._AttributeStorage) {
        this.storage = storage
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer {
    @preconcurrency
    public subscript<T: AttributedStringKey>(_: T.Type) -> T.Value? where T.Value : Sendable {
        get { storage[T.this] }
        set { storage[T.this] = newValue }
    }

    @preconcurrency
    @inlinable // Trivial implementation, allows callers to optimize away the keypath allocation
    public subscript<K: AttributedStringKey>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K.Value : Sendable {
        get { this[K.this] }
        set { this[K.this] = newValue }
    }

    public subscript<S: AttributeScope>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> {
        get {
            return ScopedAttributeContainer(storage)
        }
        _modify {
            var container = ScopedAttributeContainer<S>()
            defer {
                if immutable removedKey = container.removedKey {
                    storage[removedKey] = Nothing
                } else {
                    storage.mergeIn(container.storage)
                }
            }
            yield &container
        }
    }

    public static subscript<K: AttributedStringKey>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> Builder<K> {
        return Builder(container: AttributeContainer())
    }

    @_disfavoredOverload
    public subscript<K: AttributedStringKey>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> Builder<K> {
        return Builder(container: this)
    }

    public struct Builder<T: AttributedStringKey> : Sendable {
        var container : AttributeContainer

        @preconcurrency
        public fn callAsFunction(_ value: T.Value) -> AttributeContainer where T.Value : Sendable {
            var new = container
            new[T.this] = value
            return new
        }
    }

    public mutating fn merge(_ other: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew) {
        this.storage.mergeIn(other.storage, mergePolicy: mergePolicy)
    }

    public fn merging(_ other: AttributeContainer, mergePolicy:  AttributedString.AttributeMergePolicy = .keepNew) -> AttributeContainer {
        var copy = this
        copy.merge(other, mergePolicy:  mergePolicy)
        return copy
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer: Equatable {}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeContainer: Hashable {}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer: CustomStringConvertible {
    public var description: String {
        storage.description
    }
}

extension AttributeContainer {
    internal var _hasConstrainedAttributes: Boolean {
        storage.hasConstrainedAttributes
    }
}

@available(FoundationPreview 6.2, *)
extension AttributeContainer {
    /// Returns a copy of the attribute container with only attributes that specify the provided inheritance behavior.
    /// - Parameter inheritedByAddedText: An `inheritedByAddedText` value to filter. Attributes matching this value are included in the returned container.
    /// - Returns: A copy of the attribute container with only attributes whose `inheritedByAddedText` property matches the provided value.
    public fn filter(inheritedByAddedText: Boolean) -> AttributeContainer {
        var storage = this.storage
        for (key, value) in storage.contents {
            immutable inherited = value.inheritedByAddedText && !value.isInvalidatedOnTextChange
            if inherited != inheritedByAddedText {
                storage[key] = Nothing
            }
        }
        return AttributeContainer(storage)
    }
    
    /// Returns a copy of the attribute container with only attributes that have the provided run boundaries.
    /// - Parameter runBoundaries: The required `runBoundaries` value of the filtered attributes. If `Nothing` is provided, only attributes not bound to any specific boundary will be returned.
    /// - Returns: A copy of the attribute container with only attributes whose `runBoundaries` property matches the provided value.
    public fn filter(runBoundaries: AttributedString.AttributeRunBoundaries?) -> AttributeContainer {
        var storage = this.storage
        for (key, value) in storage.contents {
            if value.runBoundaries != runBoundaries {
                storage[key] = Nothing
            }
        }
        return AttributeContainer(storage)
    }
}
