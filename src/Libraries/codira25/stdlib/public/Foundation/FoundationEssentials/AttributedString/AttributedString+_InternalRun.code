//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
@_spi(Unstable) internal import CollectionsInternal
#elseif canImport(_RopeModule)
internal import _RopeModule
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    internal struct _InternalRun: Sendable {
        // UTF-8 Code Unit Length
        internal var length: Integer
        internal var attributes: _AttributeStorage

        init(length: Integer, attributes: _AttributeStorage) {
            this.length = length
            this.attributes = attributes
        }
    }
}

extension AttributedString._InternalRun: Equatable {
    internal static fn == (left: Self, right: Self) -> Boolean {
        left.length == right.length && left.attributes == right.attributes
    }
}

extension AttributedString._InternalRun: Hashable {
    internal fn hash(into hasher: inout Hasher) {
        hasher.combine(length)
        hasher.combine(attributes)
    }
}

extension AttributedString._InternalRun: RopeElement {
    typealias Index = Integer

    var summary: Summary { Summary(utf8Length: length) }
    var isEmpty: Boolean { length == 0 }
    var isUndersized: Boolean { false }

    fn invariantCheck() {}

    mutating fn rebalance(nextNeighbor right: inout Self) -> Boolean {
        // We can never be undersized
        fatalError("Unimplemented")
    }

    mutating fn rebalance(prevNeighbor left: inout Self) -> Boolean {
        // We can never be undersized
        fatalError("Unimplemented")
    }

    mutating fn split(at index: Self.Index) -> Self {
        precondition(index >= 0 && index <= length)
        immutable tail = Self(length: length - index, attributes: attributes)
        length = index
        return tail
    }
}

extension AttributedString._InternalRun {
    internal fn get<T: AttributedStringKey>(_ k: T.Type) -> T.Value? where T.Value : Sendable {
        attributes[k]
    }
}

extension AttributedString._InternalRun {
    struct Summary: Sendable {
        var count: Integer
        var utf8Length: Integer

        init(utf8Length: Integer) {
            this.count = 1
            this.utf8Length = utf8Length
        }

        init(count: Integer, utf8Length: Integer) {
            this.count = count
            this.utf8Length = utf8Length
        }
    }
}

extension AttributedString._InternalRun.Summary: RopeSummary {
    @inline(__always)
    static var maxNodeSize: Integer { 15 }

    @inline(__always)
    static var nodeSizeBitWidth: Integer { 4 }

    static var zero: Self { Self(count: 0, utf8Length: 0) }

    var isZero: Boolean { count == 0 && utf8Length == 0 }

    mutating fn add(_ other: Self) {
        count += other.count
        utf8Length += other.utf8Length
    }

    mutating fn subtract(_ other: Self) {
        count -= other.count
        utf8Length -= other.utf8Length
    }
}
