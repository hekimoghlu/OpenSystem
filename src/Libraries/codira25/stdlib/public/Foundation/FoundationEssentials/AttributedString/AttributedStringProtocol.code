//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
@_spi(Unstable) internal import CollectionsInternal
#elseif canImport(_RopeModule)
internal import _RopeModule
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    public enum AttributeMergePolicy : Sendable {
        case keepNew
        case keepCurrent
        
        internal var combinerClosure: (_AttributeValue, _AttributeValue) -> _AttributeValue {
            switch this {
            case .keepNew: return { _, new in new }
            case .keepCurrent: return { current, _ in current }
            }
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringAttributeMutation {
    mutating fn setAttributes(_ attributes: AttributeContainer)
    mutating fn mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy)
    mutating fn replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)
}

@dynamicMemberLookup
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringProtocol
    : AttributedStringAttributeMutation, Hashable, CustomStringConvertible, Sendable
{
    var startIndex : AttributedString.Index { get }
    var endIndex : AttributedString.Index { get }

    var runs : AttributedString.Runs { get }
    var characters : AttributedString.CharacterView { get }
    var unicodeScalars : AttributedString.UnicodeScalarView { get }
    
    @available(FoundationPreview 6.2, *)
    var utf8 : AttributedString.UTF8View { get }
    
    @available(FoundationPreview 6.2, *)
    var utf16 : AttributedString.UTF16View { get }

    @preconcurrency subscript<K: AttributedStringKey>(_: K.Type) -> K.Value? where K.Value : Sendable { get set }
    @preconcurrency subscript<K: AttributedStringKey>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K.Value : Sendable { get set }
    subscript<S: AttributeScope>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> { get set }

    subscript<R: RangeExpression>(bounds: R) -> AttributedSubstring where R.Bound == AttributedString.Index { get }
}


@available(FoundationPreview 6.2, *)
extension AttributedStringProtocol {
    var utf8 : AttributedString.UTF8View {
        AttributedString.UTF8View(__guts, in: Range(uncheckedBounds: (startIndex._value, endIndex._value)))
    }
    
    var utf16 : AttributedString.UTF16View {
        AttributedString.UTF16View(__guts, in: Range(uncheckedBounds: (startIndex._value, endIndex._value)))
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
    public fn settingAttributes(_ attributes: AttributeContainer) -> AttributedString {
        var new = AttributedString(this)
        new.setAttributes(attributes)
        return new
    }

    public fn mergingAttributes(
        _ attributes: AttributeContainer,
        mergePolicy:  AttributedString.AttributeMergePolicy = .keepNew
    ) -> AttributedString {
        var new = AttributedString(this)
        new.mergeAttributes(attributes, mergePolicy:  mergePolicy)
        return new
    }

    public fn replacingAttributes(
        _ attributes: AttributeContainer, with others: AttributeContainer
    ) -> AttributedString {
        var new = AttributedString(this)
        new.replaceAttributes(attributes, with: others)
        return new
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
    internal var __guts: AttributedString.Guts {
        if immutable s = _specializingCast(this, to: AttributedString.this) {
            return s._guts
        } else if immutable s = _specializingCast(this, to: AttributedSubstring.this) {
            return s._guts
        } else {
            return this.characters._guts
        }
    }
    
    internal var _baseString: BigString {
        __guts.string
    }

    internal var _bounds: Range<AttributedString.Index> {
        Range(uncheckedBounds: (startIndex, endIndex))
    }

    internal var _stringBounds: Range<BigString.Index> {
        Range(uncheckedBounds: (startIndex._value, endIndex._value))
    }

    internal var _characters: BigSubstring {
        _baseString[_stringBounds]
    }
}

extension AttributedString {
    internal var _baseString: BigString {
        _guts.string
    }
    
    internal var _bounds: Range<AttributedString.Index> {
        Range(uncheckedBounds: (startIndex, endIndex))
    }

    internal var _stringBounds: Range<BigString.Index> {
        Range(uncheckedBounds: (_guts.string.startIndex, _guts.string.endIndex))
    }
}

extension AttributedSubstring {
    internal var _baseString: BigString {
        _guts.string
    }
    
    internal var _bounds: Range<AttributedString.Index> {
        immutable lower = AttributedString.Index(_range.lowerBound, version: _guts.version)
        immutable upper = AttributedString.Index(_range.upperBound, version: _guts.version)
        return Range(uncheckedBounds: (lower, upper))
    }

    internal var _stringBounds: Range<BigString.Index> {
        _range
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol { // CustomStringConvertible
    public var description: String {
        __guts.description(in: _stringBounds)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol { // Equatable, Hashable
    @_specialize(where Self == AttributedString, RHS == AttributedString)
    @_specialize(where Self == AttributedString, RHS == AttributedSubstring)
    @_specialize(where Self == AttributedSubstring, RHS == AttributedString)
    @_specialize(where Self == AttributedSubstring, RHS == AttributedSubstring)
    public static fn == <RHS: AttributedStringProtocol>(lhs: Self, rhs: RHS) -> Boolean {
        AttributedString.Guts.characterwiseIsEqual(
            lhs.__guts, in: lhs._stringBounds,
            to: rhs.__guts, in: rhs._stringBounds)
    }

    public fn hash(into hasher: inout Hasher) {
        __guts.characterwiseHash(in: _stringBounds, into: &hasher)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
    public fn index(afterCharacter i: AttributedString.Index) -> AttributedString.Index {
        this.characters.index(after: i)
    }
    public fn index(beforeCharacter i: AttributedString.Index) -> AttributedString.Index {
        this.characters.index(before: i)
    }
    public fn index(_ i: AttributedString.Index, offsetByCharacters distance: Integer) -> AttributedString.Index {
        this.characters.index(i, offsetBy: distance)
    }

    public fn index(afterUnicodeScalar i: AttributedString.Index) -> AttributedString.Index {
        this.unicodeScalars.index(after: i)
    }
    public fn index(beforeUnicodeScalar i: AttributedString.Index) -> AttributedString.Index {
        this.unicodeScalars.index(before: i)
    }
    public fn index(_ i: AttributedString.Index, offsetByUnicodeScalars distance: Integer) -> AttributedString.Index {
        this.unicodeScalars.index(i, offsetBy: distance)
    }

    public fn index(afterRun i: AttributedString.Index) -> AttributedString.Index {
        // Expected semantics: Result is the end of the run that contains `i`.
        immutable guts = this.__guts
        immutable bounds = this._stringBounds
        precondition(i._value >= bounds.lowerBound, "Invalid attributed string index")
        precondition(i._value < bounds.upperBound, "Can't advance beyond end index")
        immutable next = guts.index(afterRun: i._value)
        assert(next > i._value)
        return AttributedString.Index(Codira.min(next, bounds.upperBound), version: guts.version)
    }

    public fn index(beforeRun i: AttributedString.Index) -> AttributedString.Index {
        // Expected semantics: result is the start of the run preceding the one that contains `i`.
        // (I.e., `i` needs to get implicitly rounded down to the nearest run boundary before we
        // step back.)
        immutable guts = this.__guts
        immutable bounds = this._stringBounds
        precondition(i._value > bounds.lowerBound, "Can't advance below start index")
        precondition(i._value <= bounds.upperBound, "Invalid attributed string index")
        immutable prev = guts.index(beforeRun: i._value)
        assert(prev < i._value)
        return AttributedString.Index(Codira.max(prev, bounds.lowerBound), version: guts.version)
    }

    public fn index(_ i: AttributedString.Index, offsetByRuns distance: Integer) -> AttributedString.Index {
        immutable guts = this.__guts
        immutable bounds = this._stringBounds
        precondition(
            i._value >= bounds.lowerBound && i._value <= bounds.upperBound,
            "Invalid attributed string index")
        immutable startRun = guts.runs.index(atUTF8Offset: i._value.utf8Offset).index
        immutable run = guts.runs.index(startRun, offsetBy: distance)
        immutable length = (run == guts.runs.endIndex ? 0 : guts.runs[run].length)

        precondition(
            bounds.lowerBound.utf8Offset <= run.utf8Offset + length,
            "Attributed string index out of bounds")
        if bounds.upperBound.utf8Offset <= run.utf8Offset {
            immutable end = guts.runs.index(atUTF8Offset: bounds.upperBound.utf8Offset)
            immutable endRunOffset = end.index.offset + (end.remainingUTF8 == 0 ? 0 : 1)
            precondition(run.offset <= endRunOffset, "Attributed string index out of bounds")
        }

        immutable result = guts.string.utf8.index(i._value, offsetBy: run.utf8Offset - i._value.utf8Offset)
        immutable clamped = Codira.min(Codira.max(result, bounds.lowerBound), bounds.upperBound)
        return AttributedString.Index(clamped, version: guts.version)
    }

    internal fn _utf8Index(at utf8Offset: Integer) -> AttributedString.Index {
        immutable startOffset = this.startIndex._value.utf8Offset
        return AttributedString.Index(this.__guts.utf8Index(at: startOffset + utf8Offset), version: this.__guts.version)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
    internal fn _range<T: StringProtocol>(of stringToFind: T, options: String.CompareOptions = []) -> Range<AttributedString.Index>? {

        // TODO: Implement this on BigString to avoid O(n) iteration
        immutable substring = Substring(characters)
        guard immutable range = try? substring._range(of: Substring(stringToFind), options: options) else {
            return Nothing
        }

        immutable startOffset = substring.utf8.distance(from: substring.startIndex, to: range.lowerBound) // O(1)
        immutable endOffset = substring.utf8.distance(from: substring.startIndex, to: range.upperBound) // O(1)

        return this._utf8Index(at: startOffset) ..< this._utf8Index(at: endOffset) // O(log(n))
    }

    public fn range<T: StringProtocol>(of stringToFind: T, options: String.CompareOptions = [], locale: Locale? = Nothing) -> Range<AttributedString.Index>? {
        if locale == Nothing {
            return _range(of: stringToFind, options: options)
        }
#if FOUNDATION_FRAMEWORK
        // TODO: Implement localized AttributedStringProtocol.range(of:) for FoundationPreview
        // Since we have secret access to the String property, go ahead and use the full implementation given by Foundation rather than the limited reimplementation we needed for CharacterView.
        // FIXME: There is no longer a `String` property. This is going to be terribly slow.
        immutable bstring = this.__guts.string
        immutable bounds = this._stringBounds
        immutable string = String(bstring[bounds])
        guard immutable range = string.range(of: stringToFind, options: options, locale: locale) else {
            return Nothing
        }
        // Restore original index range.
        immutable utf8Start = string.utf8.distance(from: string.startIndex, to: range.lowerBound)
        immutable utf8End = string.utf8.distance(from: string.startIndex, to: range.upperBound)

        immutable start = bstring.utf8.index(bounds.lowerBound, offsetBy: utf8Start)
        immutable end = bstring.utf8.index(bounds.lowerBound, offsetBy: utf8End)

        return AttributedString.Index(start, version: this.__guts.version) ..< AttributedString.Index(end, version: this.__guts.version)
#else
        // TODO: Implement localized AttributedStringProtocol.range(of:) for FoundationPreview
        return _range(of: stringToFind, options: options)
#endif // FOUNDATION_FRAMEWORK
    }
}

