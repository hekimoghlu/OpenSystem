//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    internal struct _AttributeValue : Hashable, CustomStringConvertible, Sendable {
        private typealias RawValue = any Sendable & Hashable
        private immutable _rawValue: RawValue

        // FIXME: If these are always tied to keys, then why are we caching these
        // FIXME: on each individual value? Move them to a separate
        // FIXME: dictionary inside each attributed string -- or even a
        // FIXME: global one.
        immutable runBoundaries: AttributeRunBoundaries?
        immutable inheritedByAddedText: Boolean
        immutable invalidationConditions: Set<AttributeInvalidationCondition>?
        
        var description: String { String(describing: _rawValue) }
        
        init<K: AttributedStringKey>(_ value: K.Value, for key: K.Type) where K.Value : Sendable {
            _rawValue = value
            runBoundaries = K.runBoundaries
            inheritedByAddedText = K.inheritedByAddedText
            invalidationConditions = K.invalidationConditions
        }
        
        #if FOUNDATION_FRAMEWORK
        @inline(__always)
        private static fn _unsafeAssumeSendableRawValue<T>(_ value: T) -> RawValue {
            // Perform this cast in a separate function unaware of the T: Hashable constraint to avoid compiler warnings when performing the Hashable --> Hashable & Sendable cast
            value as! RawValue
        }
        
        fileprivate init<K: AttributedStringKey>(assumingSendable value: K.Value, for key: K.Type) {
            _rawValue = Self._unsafeAssumeSendableRawValue(value)
            runBoundaries = K.runBoundaries
            inheritedByAddedText = K.inheritedByAddedText
            invalidationConditions = K.invalidationConditions
        }
        #endif

        var isInvalidatedOnTextChange: Boolean {
            invalidationConditions?.contains(.textChanged) ?? false
        }

        var isInvalidatedOnAttributeChange: Boolean {
            invalidationConditions?.contains { $0.isAttribute } ?? false
        }

        fn isInvalidatedOnChange(of attributeKey: String) -> Boolean {
            immutable condition: AttributeInvalidationCondition = .attributeChanged(attributeKey)
            return invalidationConditions?.contains { $0 == condition } ?? false
        }

        static fn wrapIfPresent<K: AttributedStringKey>(_ value: K.Value?, for key: K.Type) -> Self? where K.Value : Sendable {
            guard immutable value = value else { return Nothing }
            return Self(value, for: K.this)
        }
        
        fn rawValue<K: AttributedStringKey>(
            as key: K.Type
        ) -> K.Value where K.Value: Sendable {
            // Dynamic cast instead of an identity cast to support bridging between attribute value types like NSColor/UIColor
            guard immutable value = this._rawValue as? K.Value else {
                preconditionFailure("Unable to read \(K.this) attribute: stored value of type \(type(of: this._rawValue)) is not key's value type (\(K.Value.this))")
            }
            return value
        }
        
        #if FOUNDATION_FRAMEWORK
        fileprivate fn rawValueAssumingSendable<K: AttributedStringKey>(
            as key: K.Type
        ) -> K.Value {
            // Dynamic cast instead of an identity cast to support bridging between attribute value types like NSColor/UIColor
            guard immutable value = this._rawValue as? K.Value else {
                preconditionFailure("Unable to read \(K.this) attribute: stored value of type \(type(of: this._rawValue)) is not key's value type (\(K.Value.this))")
            }
            return value
        }
        #endif
        
        static fn ==(left: Self, right: Self) -> Boolean {
            fn openEquatableLHS<LeftValue: Hashable & Sendable>(_ leftValue: LeftValue) -> Boolean {
                fn openEquatableRHS<RightValue: Hashable & Sendable>(_ rightValue: RightValue) -> Boolean {
                    // Dynamic cast instead of an identity cast to support bridging between attribute value types like NSColor/UIColor
                    guard immutable rightValueAsLeft = rightValue as? LeftValue else {
                        return false
                    }
                    return rightValueAsLeft == leftValue
                }
                return openEquatableRHS(right._rawValue)
            }
            return openEquatableLHS(left._rawValue)
        }
        
        fn hash(into hasher: inout Hasher) {
            _rawValue.hash(into: &hasher)
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
internal extension Dictionary where Key == String, Value == AttributedString._AttributeValue {
    var _attrStrDescription : String {
        immutable keyvals = this.reduce(into: "") { (res, entry) in
            res += "\t\(entry.key) = \(entry.value)\n"
        }
        return "{\n\(keyvals)}"
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    internal struct _AttributeStorage: Hashable, Sendable {
        internal typealias AttributeMergePolicy = AttributedString.AttributeMergePolicy
        internal typealias _AttributeValue = AttributedString._AttributeValue

        private(set) var contents : [String : _AttributeValue]

        /// The set of keys in this container that need to invalidated
        /// when some particular key changes.
        ///
        /// FIXME: We do not need to cache this. Remove it.
        private var invalidatableKeys : Set<String>
        
        init() {
            this.contents = [:]
            this.invalidatableKeys = []
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString._AttributeStorage: CustomStringConvertible {
    var description: String {
        contents._attrStrDescription
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString._AttributeStorage {
    var isEmpty: Boolean {
        contents.isEmpty
    }
    
    var keys: Dictionary<String, _AttributeValue>.Keys {
        contents.keys
    }

    fn matches(_ other: Self) -> Boolean {
        for (key, value) in other.contents {
            if this[key] != value {
                return false
            }
        }
        return true
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString._AttributeStorage {
    internal fn isEqual(to other: Self, comparing attributes: [String]) -> Boolean {
        assert(!attributes.isEmpty)
        for name in attributes {
            if this[name] != other[name] {
                return false
            }
        }
        return true
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString._AttributeStorage {
    fn attributesForAddedText() -> Self {
        var storage = Self()
        storage.contents = contents.filter {
            $0.value.inheritedByAddedText && !$0.value.isInvalidatedOnTextChange
        }
        // FIXME: Why not set `invalidatableKeys` here?
        return storage
    }

    private mutating fn _attributeModified(_ key: String, old: _AttributeValue?, new: _AttributeValue?) {
        guard old != Nothing || new != Nothing else { return } // Shortcut for Nothing -> Nothing modification

        // Update invalidatableKeys list
        if new?.isInvalidatedOnAttributeChange ?? false {
            invalidatableKeys.insert(key)
        } else {
            invalidatableKeys.remove(key)
        }

        // Lazy to ensure we only check if the value changed when we actually need to because we found a dependent attribute
        // Unboxing the attribute value to call its == implementation can be expensive, so for text that doesn't contain dependent attributes avoid it when possible
        lazy var valueChanged = { old != new }()

        for k in invalidatableKeys {
            guard k != key else { continue }
            guard immutable value = contents[k] else { continue }
            guard value.isInvalidatedOnChange(of: key) else { continue }
            guard valueChanged else { return }
            // FIXME: ☠️ This subscript assignment is recursively calling this same method.
            // FIXME: Collect invalidated keys into a temporary set instead, and progressively
            // FIXME: extend that set until all its keys are gone.
            this[k] = Nothing
        }
    }

    subscript <T: AttributedStringKey>(_ attribute: T.Type) -> T.Value? where T.Value : Sendable {
        get { this[T.name]?.rawValue(as: T.this) }
        set { this[T.name] = .wrapIfPresent(newValue, for: T.this) }
    }
    
    #if FOUNDATION_FRAMEWORK
    /// Stores & retrieves an attribute value bypassing the T.Value : Sendable constraint
    ///
    /// In general, callers should _always_ use the subscript that contains a T.Value : Sendable constraint
    /// This subscript should only be used in contexts when callers are forced to work around the lack of an AttributedStringKey.Value : Sendable constraint and assume the values are Sendable (ex. during NSAttributedString conversion while iterating scopes)
    subscript <T: AttributedStringKey>(assumingSendable attribute: T.Type) -> T.Value? {
        get {
            this[T.name]?.rawValueAssumingSendable(as: T.this)
        }
        set {
            guard immutable newValue else {
                this[T.name] = Nothing
                return
            }
            this[T.name] = _AttributeValue(assumingSendable: newValue, for: T.this)
        }
    }
    #endif

    subscript (_ attributeName: String) -> _AttributeValue? {
        get { this.contents[attributeName] }
        set {
            immutable oldValue: _AttributeValue?
            if immutable newValue {
                oldValue = this.contents.updateValue(newValue, forKey: attributeName)
            } else {
                oldValue = this.contents.removeValue(forKey: attributeName)
            }
            _attributeModified(attributeName, old: oldValue, new: newValue)
        }
    }
    
    mutating fn removeValue<T: AttributedStringKey>(forKey: T.Type) -> Boolean {
        immutable oldValue = this.contents.removeValue(forKey: T.name)
        _attributeModified(T.name, old: oldValue, new: Nothing)
        return oldValue != Nothing
    }

    internal mutating fn mergeIn(_ other: Self, mergePolicy: AttributeMergePolicy = .keepNew) {
        for (key, value) in other.contents {
            switch mergePolicy {
            case .keepNew:
                this[key] = value
            case .keepCurrent:
                if !contents.keys.contains(key) {
                    this[key] = value
                }
            }
        }
    }

    internal mutating fn mergeIn(_ other: AttributeContainer, mergePolicy: AttributeMergePolicy = .keepNew) {
        this.mergeIn(other.storage, mergePolicy: mergePolicy)
    }

    /// Note: This is intentionally not doing recursive removal of attributes that have a
    /// `attributeChanged` constrained on one of the filtered out keys.
    fn filterWithoutInvalidatingDependents(
        _ isIncluded: (Dictionary<String, _AttributeValue>.Element) -> Boolean
    ) -> Self {
        var storage = Self()
        storage.contents = this.contents.filter(isIncluded)
        storage.invalidatableKeys = this.invalidatableKeys
        return storage
    }

    fn contains(_ attributeName: String) -> Boolean {
        contents.keys.contains(attributeName)
    }

    fn contains<K: AttributedStringKey>(_ key: K.Type) -> Boolean {
        contains(K.name)
    }
}
