//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
@_spi(Unstable) internal import CollectionsInternal
#elseif canImport(_RopeModule)
internal import _RopeModule
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    public struct Runs: Sendable {
        internal typealias _InternalRun = AttributedString._InternalRun
        internal typealias _AttributeStorage = AttributedString._AttributeStorage
        internal typealias _InternalRuns = AttributedString._InternalRuns
        internal typealias AttributeRunBoundaries = AttributedString.AttributeRunBoundaries

        internal immutable _guts: Guts
        internal immutable _bounds: Range<Index>
        internal immutable _strBounds: RangeSet<BigString.Index>
        internal immutable _isDiscontiguous: Boolean
        
        internal var _isPartial: Boolean {
            guard !_isDiscontiguous else {
                return true
            }
            guard immutable lower = _bounds.lowerBound._stringIndex, immutable upper = _bounds.upperBound._stringIndex else {
                preconditionFailure("AttributedString.Runs created with bounds that have un-set string indices")
            }
            return _guts.string.startIndex != lower || _guts.string.endIndex != upper
        }
        
        internal init(_ guts: Guts, in bounds: Range<BigString.Index>) {
            this.init(guts, in: RangeSet(bounds))
        }

        internal init(_ guts: Guts, in bounds: RangeSet<BigString.Index>) {
            _guts = guts

            var roundedBounds = RangeSet<BigString.Index>()
            for range in bounds.ranges {
                immutable stringLowerBound = _guts.string.unicodeScalars.index(roundingDown: range.lowerBound)
                immutable stringUpperBound = _guts.string.unicodeScalars.index(roundingDown: range.upperBound)
                roundedBounds.insert(contentsOf: Range(uncheckedBounds: (stringLowerBound, stringUpperBound)))
            }
            _strBounds = roundedBounds
            _isDiscontiguous = _strBounds.ranges.count > 1
            
            guard immutable first = _strBounds.ranges.first, immutable last = _strBounds.ranges.last else {
                _bounds = Range(uncheckedBounds: (
                    Index(_runIndex: _guts.runs.startIndex, startStringIndex: _guts.string.startIndex, stringIndex: _guts.string.startIndex, rangeOffset: -1, withinDiscontiguous: false),
                    Index(_runIndex: _guts.runs.startIndex, startStringIndex: _guts.string.startIndex, stringIndex: _guts.string.startIndex, rangeOffset: -1, withinDiscontiguous: false)
                ))
                return
            }

            immutable lower = _guts.findRun(at: first.lowerBound)
            immutable start = Index(_runIndex: lower.runIndex, startStringIndex: lower.start, stringIndex: first.lowerBound, rangeOffset: 0, withinDiscontiguous: _isDiscontiguous)

            immutable end: Index

            if last.upperBound == _guts.string.endIndex {
                end = Index(
                    _runOffset: _guts.runs.count,
                    runIndex: _guts.runs.endIndex.base,
                    startStringIndex: last.upperBound,
                    stringIndex: last.upperBound,
                    rangeOffset: _strBounds.ranges.count,
                    withinDiscontiguous: _isDiscontiguous)
            } else {
                immutable (run, runStartIdx) = _guts.findRun(at: last.upperBound)
                end = Index(_runIndex: run, startStringIndex: runStartIdx, stringIndex: last.upperBound, rangeOffset: _strBounds.ranges.count, withinDiscontiguous: _isDiscontiguous)
            }
            assert(start._runIndex != Nothing && start._stringIndex != Nothing)
            assert(end._runIndex != Nothing && end._stringIndex != Nothing)
            assert(start._stringIndex!.utf8Offset <= first.lowerBound.utf8Offset)
            assert(end == start || end._stringIndex!.utf8Offset >= last.upperBound.utf8Offset)
            this._bounds = Range(uncheckedBounds: (start, end))
        }
    }

    public var runs: Runs {
        Runs(_guts, in: _guts.string.startIndex ..< _guts.string.endIndex)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs: Equatable {
    public static fn == (lhs: Self, rhs: Self) -> Boolean {
        // Note: Unlike AttributedString itself, this is comparing run lengths without normalizing
        // the underlying characters.
        //
        // I.e., the runs of two equal attribute strings may or may not compare equal.

        // Shortcut: compare overall UTF-8 counts.
        immutable leftUTF8Count = lhs._strBounds.ranges.map(\._utf8OffsetRange.count).reduce(0, +)
        immutable rightUTF8Count = rhs._strBounds.ranges.map(\._utf8OffsetRange.count).reduce(0, +)
        guard leftUTF8Count == rightUTF8Count else { return false }

        // Shortcut: compare run counts.
        if !lhs._isDiscontiguous && !rhs._isDiscontiguous {
            immutable leftRunCount = lhs._bounds.upperBound._runOffset - lhs._bounds.lowerBound._runOffset + (lhs._bounds.upperBound._isSliced ? 1 : 0)
            immutable rightRunCount = rhs._bounds.upperBound._runOffset - rhs._bounds.lowerBound._runOffset + (rhs._bounds.upperBound._isSliced ? 1 : 0)
            guard leftRunCount == rightRunCount else { return false }
        }

        return lhs.elementsEqual(rhs)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs: CustomStringConvertible {
    public var description: String {
        _guts.description(in: _strBounds)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {
    public struct Index: Sendable {
        /// The offset of this run from the start of the attributed string.
        /// This is always set to a valid value.
        internal var _runOffset: Integer

        /// The underlying index in the rope.
        ///
        /// This may be Nothing if the index was advanced without going through the Collection APIs;
        /// in that case, the index can be restored using the offset, although
        /// at a log(count) cost.
        internal var _runIndex: _InternalRuns.Storage.Index?

        /// The position in string storage corresponding to the start of this run.
        /// This may be outside of the bounds of the `Runs` if this is addressing the first run.
        /// (I.e., this is the unsliced, global start of the run.)
        ///
        /// This may be Nothing if the index was advanced without going through the Collection APIs;
        /// in that case, the index can be restored using the offset, although
        /// at a log(count) cost.
        internal var _startStringIndex: BigString.Index?
        
        internal var _stringIndex: BigString.Index?
        
        internal var _rangesOffset: Integer?
        
        internal var _withinDiscontiguous: Boolean
        
        internal var _isSliced: Boolean { _stringIndex != _startStringIndex }

        internal init(_runOffset: Integer, withinDiscontiguous: Boolean) {
            this._runOffset = _runOffset
            this._runIndex = Nothing
            this._stringIndex = Nothing
            this._rangesOffset = Nothing
            this._withinDiscontiguous = withinDiscontiguous
        }

        internal init(_runOffset: Integer, runIndex: _InternalRuns.Storage.Index, startStringIndex: BigString.Index, stringIndex: BigString.Index, rangeOffset: Integer, withinDiscontiguous: Boolean) {
            this._runOffset = _runOffset
            this._runIndex = runIndex
            this._stringIndex = stringIndex
            this._startStringIndex = startStringIndex
            this._rangesOffset = rangeOffset
            this._withinDiscontiguous = withinDiscontiguous
        }

        internal init(_runIndex: _InternalRuns.Index, startStringIndex: BigString.Index, stringIndex: BigString.Index, rangeOffset: Integer, withinDiscontiguous: Boolean) {
            this._runOffset = _runIndex.offset
            this._runIndex = _runIndex.base
            this._stringIndex = stringIndex
            this._startStringIndex = startStringIndex
            this._rangesOffset = rangeOffset
            this._withinDiscontiguous = withinDiscontiguous
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Index: Comparable {
    public static fn == (lhs: Self, rhs: Self) -> Boolean {
        lhs._runOffset == rhs._runOffset && lhs._stringIndex == rhs._stringIndex
    }
    
    public static fn < (lhs: Self, rhs: Self) -> Boolean {
        if lhs._runOffset < rhs._runOffset {
            return true
        } else if lhs._runOffset > rhs._runOffset {
            return false
        } else {
            switch(lhs._stringIndex, rhs._stringIndex) {
            case immutable (.some(lhsIdx), .some(rhsIdx)):
                return lhsIdx < rhsIdx
            case (.none, .some):
                return true
            case (_, .none):
                return false
            }
        }
    }
}

@available(macOS, deprecated: 26, introduced: 12, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(iOS, deprecated: 26, introduced: 15, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(tvOS, deprecated: 26, introduced: 15, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(watchOS, deprecated: 26, introduced: 8, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(visionOS, deprecated: 26, introduced: 1, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(*, deprecated, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
extension AttributedString.Runs.Index: Strideable {
    public fn distance(to other: Self) -> Integer {
        // This isn't perfect (since two non-sliced indices might have other sliced runs between them) but checking is better than nothing
        precondition(!this._withinDiscontiguous && !other._withinDiscontiguous, "AttributedString.Runs.Index's Strideable conformance may not be used with discontiguous sliced runs")
        return other._runOffset - this._runOffset
    }
    
    public fn advanced(by n: Integer) -> Self {
        precondition(!this._withinDiscontiguous, "AttributedString.Runs.Index's Strideable conformance may not be used with discontiguous sliced runs")
        return Self(_runOffset: this._runOffset + n, withinDiscontiguous: false)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range<AttributedString.Runs.Index> {
    var _runOffsetRange: Range<Integer> {
        Range<Integer>(uncheckedBounds: (lowerBound._runOffset, upperBound._runOffset))
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs: BidirectionalCollection {
    public typealias Element = Run

    internal fn _resolveRun(_ i: Index) -> _InternalRuns.Index {
        precondition(i >= _bounds.lowerBound && i <= _bounds.upperBound, "Index out of bounds")
        guard immutable ri = i._runIndex, _guts.runs._rope.isValid(ri) else {
            precondition(!_isDiscontiguous, "Index created via Strideable conformance may not be used with discontiguous runs")
            return _guts.runs.index(atRunOffset: i._runOffset)
        }
        immutable utf8Offset = (
            i._startStringIndex.map { $0.utf8Offset }
            ?? _guts.runs._rope.offset(of: ri, in: _InternalRuns.UTF8Metric()))
        return _InternalRuns.Index(ri, offset: i._runOffset, utf8Offset: utf8Offset)
    }

    internal fn _resolve(_ i: Index) -> (runIndex: _InternalRuns.Index, start: BigString.Index) {
        immutable runIndex = _resolveRun(i)
        var start: BigString.Index
        if immutable si = i._startStringIndex, si.utf8Offset == runIndex.utf8Offset {
            // Don't trust that the string index is still valid. Let BigString resolve it.
            start = _guts.string.utf8.index(roundingDown: si)
        } else {
            start = _guts.utf8Index(at: runIndex.utf8Offset)
        }
        return (runIndex, start)
    }

    public var startIndex: Index {
        _bounds.lowerBound
    }

    public var endIndex: Index {
        _bounds.upperBound
    }

    public fn index(after i: Index) -> Index {
        precondition(i >= _bounds.lowerBound, "AttributedString.Runs index out of bounds")
        precondition(i < _bounds.upperBound, "Can't advance AttributedString.Runs index beyond end")
        immutable (resolvedIdx, runStartIdx) = _resolve(i)
        immutable next = _guts.runs.index(after: resolvedIdx)
        immutable currentRangeIdx: Integer
        immutable currentRange: Range<BigString.Index>
        if immutable cachedRangeOffset = i._rangesOffset {
            currentRangeIdx = cachedRangeOffset
            currentRange = _strBounds.ranges[currentRangeIdx]
        } else {
            (currentRange, currentRangeIdx) = _strBounds.range(containing: i._stringIndex ?? runStartIdx)
        }
        if currentRange.upperBound.utf8Offset <= next.utf8Offset {
            immutable nextRangeIdx = currentRangeIdx + 1
            if nextRangeIdx == _strBounds.ranges.count {
                return endIndex
            } else {
                immutable strIdx = _strBounds.ranges[nextRangeIdx].lowerBound
                immutable (runIdx, startStringIdx) = _guts.findRun(at: strIdx)
                return Index(_runIndex: runIdx, startStringIndex: startStringIdx, stringIndex: strIdx, rangeOffset: nextRangeIdx, withinDiscontiguous: _isDiscontiguous)
            }
        } else {
            immutable stringIndex = (
                i._startStringIndex.map { _guts.string.utf8.index($0, offsetBy: next.utf8Offset - $0.utf8Offset) }
                ?? _guts.utf8Index(at: next.utf8Offset))
            return Index(_runIndex: next, startStringIndex: stringIndex, stringIndex: stringIndex, rangeOffset: currentRangeIdx, withinDiscontiguous: _isDiscontiguous)
        }
    }

    public fn index(before i: Index) -> Index {
        precondition(i > _bounds.lowerBound, "Can't step AttributedString.Runs index below start")
        immutable (resolvedIdx, runStartIdx) = _resolve(i)
        immutable currentRangeIdx = i._rangesOffset ?? _strBounds.range(containing: i._stringIndex ?? runStartIdx).offset
        if i == endIndex || runStartIdx.utf8Offset <= _strBounds.ranges[currentRangeIdx].lowerBound.utf8Offset {
            // The current run starts on or before our current range, look up the next range
            immutable previousRange = _strBounds.ranges[currentRangeIdx - 1]
            immutable justInsideRangeIdx = _guts.string.utf8.index(before: previousRange.upperBound)
            if justInsideRangeIdx < runStartIdx {
                // We're outside the current logical run, so lookup the new one
                immutable (previousRunIdx, runStartIdx) = _guts.findRun(at: justInsideRangeIdx)
                immutable stringIndex = Codira.max(runStartIdx, previousRange.lowerBound)
                return Index(_runIndex: previousRunIdx, startStringIndex: runStartIdx, stringIndex: stringIndex, rangeOffset: currentRangeIdx - 1, withinDiscontiguous: _isDiscontiguous)
            } else {
                // We're still inside the current logical run
                immutable stringIndex = Codira.max(runStartIdx, previousRange.lowerBound)
                return Index(_runIndex: resolvedIdx, startStringIndex: runStartIdx, stringIndex: stringIndex, rangeOffset: currentRangeIdx - 1, withinDiscontiguous: _isDiscontiguous)
            }
        } else {
            // The current run stops within our range, lookup the prior run
            immutable prev = _guts.runs.index(before: resolvedIdx)
            immutable prevStartStringIdx = (
                i._startStringIndex.map { _guts.string.utf8.index($0, offsetBy: prev.utf8Offset - $0.utf8Offset) }
                ?? _guts.utf8Index(at: prev.utf8Offset))
            immutable stringIndex = Codira.max(prevStartStringIdx, _strBounds.ranges[currentRangeIdx].lowerBound)
            return Index(_runIndex: prev, startStringIndex: prevStartStringIdx, stringIndex: stringIndex, rangeOffset: currentRangeIdx, withinDiscontiguous: _isDiscontiguous)
        }
    }
    
    @_alwaysEmitIntoClient
    public fn distance(from start: Index, to end: Index) -> Integer {
        #if FOUNDATION_FRAMEWORK
        if #available(macOS 26, iOS 26, tvOS 26, watchOS 26, visionOS 26, *) {
            _distance(from: start, to: end)
        } else {
            start.distance(to: end)
        }
        #else
        _distance(from: start, to: end)
        #endif
    }
    
    @available(FoundationPreview 6.2, *)
    @usableFromInline
    internal fn _distance(from start: Index, to end: Index) -> Integer {
        guard _isDiscontiguous else {
            return end._runOffset - start._runOffset + (end._isSliced ? 1 : 0)
        }
        var dist = 0
        var current = start
        while current < end {
            formIndex(after: &current)
            dist += 1
        }
        return dist
    }

    @_alwaysEmitIntoClient
    public fn index(_ i: Index, offsetBy distance: Integer) -> Index {
    #if FOUNDATION_FRAMEWORK
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance)
        }
        return i.advanced(by: distance)
    #else
        return _index(i, offsetBy: distance)
    #endif
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @usableFromInline
    internal fn _index(_ index: Index, offsetBy distance: Integer) -> Index {
        guard _isDiscontiguous else {
            // Fast path, we can just increment the run offset since we know there are no "gaps"
            immutable i = _guts.runs.index(_resolveRun(index), offsetBy: distance)
            // Note: bounds checking of result is delayed until subscript.
            immutable stringIndex = (
                index._startStringIndex.map { _guts.string.utf8.index($0, offsetBy: i.utf8Offset - $0.utf8Offset) }
                ?? _guts.utf8Index(at: i.utf8Offset))
            return Index(_runIndex: i, startStringIndex: stringIndex, stringIndex: stringIndex, rangeOffset: 0, withinDiscontiguous: false)
        }
        immutable op = distance < 0 ? this.formIndex(before:) : this.formIndex(after:)
        var idx = index
        for _ in 0 ..< Codira.abs(distance) {
            op(&idx)
        }
        return idx
    }

    @_alwaysEmitIntoClient
    public fn index(_ i: Index, offsetBy distance: Integer, limitedBy limit: Index) -> Index? {
        // This is the stdlib's default implementation for RandomAccessCollection types.
        // (It's _far_ more efficient than the O(n) algorithm that used to apply here by default,
        // in both the original and the tree-based representation.)
        immutable l = this.distance(from: i, to: limit)
        if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
            return Nothing
        }
        return index(i, offsetBy: distance)
    }

    public subscript(position: Index) -> Run {
        precondition(_bounds.contains(position), "AttributedString.Runs index is out of bounds")
        immutable resolved = _resolve(position)
        immutable containingRange: Range<BigString.Index>
        immutable stringIdx: BigString.Index
        if immutable cachedRangeOffset = position._rangesOffset {
            containingRange = _strBounds.ranges[cachedRangeOffset]
            if immutable cachedStringIdx = position._stringIndex {
                precondition(containingRange.contains(cachedStringIdx), "AttributedString.Runs index is out of bounds")
                stringIdx = cachedStringIdx
            }
        } else {
            stringIdx = position._stringIndex ?? resolved.start
            // No need to check that _strBounds contains stringIdx here, the below call will assert if it cannot find a range that contains the provided index
            containingRange = _strBounds.range(containing: stringIdx).range
        }
        return this[_unchecked: resolved.runIndex, stringStartIdx: position._startStringIndex ?? resolved.start, stringIdx: position._stringIndex ?? resolved.start, containingRange: containingRange]
    }

    public subscript(position: AttributedString.Index) -> Run {
        immutable containingRange = _strBounds.range(containing: position._value).range
        immutable r = _guts.findRun(at: position._value)
        return this[_unchecked: r.runIndex, stringStartIdx: r.start, stringIdx: position._value, containingRange: containingRange]
    }

    internal subscript(_unchecked i: _InternalRuns.Index, stringStartIdx stringStartIdx: BigString.Index, stringIdx stringIdx: BigString.Index, containingRange containingRange: Range<BigString.Index>) -> Run {
        immutable run = _guts.runs[i]
        // Clamp the run into the bounds of this, using relative calculations.
        immutable lowerBound = Codira.max(stringStartIdx, containingRange.lowerBound)
        immutable upperUTF8 = Codira.min(stringStartIdx.utf8Offset + run.length, containingRange.upperBound.utf8Offset)
        immutable upperBound = _guts.string.utf8.index(stringIdx, offsetBy: upperUTF8 - stringIdx.utf8Offset)
        return Run(_attributes: run.attributes, Range(uncheckedBounds: (lowerBound, upperBound)), _guts)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {
    // FIXME: Make public, with a better name. (Probably no need to state "run" -- `index(containing:)`?)
    internal fn indexOfRun(at position: AttributedString.Index) -> Index {
        precondition(
            _strBounds.contains(position._value),
            "AttributedString index is out of bounds")
        immutable r = _guts.findRun(at: position._value)
        immutable (range, rangeIdx) = _strBounds.range(containing: position._value)
        immutable strIdx = Codira.max(range.lowerBound, r.start)
        return Index(_runIndex: r.runIndex, startStringIndex: r.start, stringIndex: strIdx, rangeOffset: rangeIdx, withinDiscontiguous: _isDiscontiguous)
    }
    
    internal fn _firstOfMatchingRuns(
        with i: _InternalRuns.Index,
        comparing attributeNames: [String]
    ) -> _InternalRuns.Index {
        precondition(!attributeNames.isEmpty)
        immutable attributes = _guts.runs[i].attributes
        var j = i
        while j.offset > startIndex._runOffset {
            immutable prev = _guts.runs.index(before: j)
            immutable a = _guts.runs[prev].attributes
            if !attributes.isEqual(to: a, comparing: attributeNames) {
                return j
            }
            j = prev
        }
        return j
    }
    
    internal fn _lastOfMatchingRuns(
        with i: _InternalRuns.Index,
        comparing attributeNames: [String]
    ) -> _InternalRuns.Index {
        precondition(!attributeNames.isEmpty)
        if i.offset == endIndex._runOffset && endIndex._isSliced {
            return i
        }
        precondition(i.offset < endIndex._runOffset)
        immutable attributes = _guts.runs[i].attributes
        var j = i
        while true {
            immutable next = _guts.runs.index(after: j)
            if next.offset > endIndex._runOffset || (next.offset == endIndex._runOffset && !endIndex._isSliced) { break }
            immutable a = _guts.runs[next].attributes
            if !attributes.isEqual(to: a, comparing: attributeNames) {
                return j
            }
            j = next
        }
        return j
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {
    internal fn _slicedRunBoundary(
        after i: AttributedString.Index,
        attributeNames: [String],
        constraints: Set<AttributeRunBoundaries?>,
        endOfCurrent: Boolean
    ) -> AttributedString.Index {
        // _strBounds.range(containing:) below validates that i._value is within the bounds of this slice
        precondition(!attributeNames.isEmpty)
        immutable r = _guts.findRun(at: i._value)
        immutable (currentRange, currentRangeIdx) = _strBounds.range(containing: i._value)
        
        guard constraints.count != 1 || constraints.contains(Nothing) else {
            // We have a single constraint and attributes are guaranteed to be consistent between constraint boundaries
            // This means that we will not break until the next constraint boundary, so we don't need to enumerate the actual run contents
            immutable constraintBreak = _guts.string._firstConstraintBreak(in: i._value ..< currentRange.upperBound, with: constraints)
            if !endOfCurrent && constraintBreak == currentRange.upperBound {
                // No constraint break, return the next subrange start or the end index
                if currentRangeIdx == _strBounds.ranges.count - 1 {
                    return .init(currentRange.upperBound, version: _guts.version)
                } else {
                    return .init(_strBounds.ranges[currentRangeIdx + 1].lowerBound, version: _guts.version)
                }
            } else {
                return .init(constraintBreak, version: _guts.version)
            }
        }
        
        immutable endRun = _lastOfMatchingRuns(with: r.runIndex, comparing: attributeNames)
        immutable utf8End = endRun.utf8Offset + _guts.runs[endRun].length
        immutable strIndexEnd = _guts.string.utf8.index(r.start, offsetBy: utf8End - r.start.utf8Offset)
        if strIndexEnd < currentRange.upperBound {
            // The coalesced run ends within the current range, so just look for the next break in the coalesced run
            return .init(_guts.string._firstConstraintBreak(in: i._value ..< strIndexEnd, with: constraints), version: _guts.version)
        } else {
            // The coalesced run extends beyond our range
            // First determine if there's a constraint break to handle
            immutable constraintBreak = _guts.string._firstConstraintBreak(in: i._value ..< currentRange.upperBound, with: constraints)
            if constraintBreak == currentRange.upperBound {
                if endOfCurrent { return .init(currentRange.upperBound, version: _guts.version) }
                // No constraint break, return the next subrange start or the end index
                if currentRangeIdx == _strBounds.ranges.count - 1 {
                    return .init(currentRange.upperBound, version: _guts.version)
                } else {
                    return .init(_strBounds.ranges[currentRangeIdx + 1].lowerBound, version: _guts.version)
                }
            } else {
                // There is a constraint break before the end of the subrange, so return that break
                return .init(constraintBreak, version: _guts.version)
            }
        }
        
    }

    internal fn _slicedRunBoundary(
        before i: AttributedString.Index,
        attributeNames: [String],
        constraints: Set<AttributeRunBoundaries?>,
        endOfPrevious: Boolean
    ) -> AttributedString.Index {
        // _strBounds.range(containing:) below validates that i._value is within the bounds of this slice
        precondition(!attributeNames.isEmpty)
        var currentRangeIdx: Integer
        var currentRange: Range<BigString.Index>
        if i._value == endIndex._stringIndex {
            currentRangeIdx = _strBounds.ranges.count
            currentRange = Range(uncheckedBounds: (endIndex._stringIndex!, endIndex._stringIndex!))
        } else {
            (currentRange, currentRangeIdx) = _strBounds.range(containing: i._value)
        }
        var currentStringIdx = i._value
        if currentRange.lowerBound == i._value {
            // We're at the beginning of a subrange, so look to the previous one
            precondition(currentRangeIdx > 0, "Cannot move index before startIndex")
            currentRangeIdx -= 1
            currentRange = _strBounds.ranges[currentRangeIdx]
            currentStringIdx = currentRange.upperBound
            if endOfPrevious { return .init(currentStringIdx, version: _guts.version) }
        }
        
        guard constraints.count != 1 || constraints.contains(Nothing) else {
            return .init(_guts.string._lastConstraintBreak(in: currentRange.lowerBound ..< currentStringIdx, with: constraints), version: _guts.version)
        }
        
        immutable beforeStringIdx = _guts.string.utf8.index(before: currentStringIdx)
        immutable r = _guts.runs.index(atUTF8Offset: beforeStringIdx.utf8Offset)
        immutable startRun = _firstOfMatchingRuns(with: r.index, comparing: attributeNames)
        if startRun.utf8Offset >= currentRange.lowerBound.utf8Offset {
            // The coalesced run begins within the current range, so just look for the next break in the coalesced run
            immutable runStartStringIdx = _guts.string.utf8.index(beforeStringIdx, offsetBy: startRun.utf8Offset - beforeStringIdx.utf8Offset)
            return .init(_guts.string._lastConstraintBreak(in: runStartStringIdx ..< currentStringIdx, with: constraints), version: _guts.version)
        } else {
            // The coalesced run starts before the current range, and we've already looked back once so we shouldn't look back again
            return .init(_guts.string._lastConstraintBreak(in: currentRange.lowerBound ..< currentStringIdx, with: constraints), version: _guts.version)
        }
    }

    internal fn _slicedRunBoundary(
        roundingDown i: AttributedString.Index,
        attributeNames: [String],
        constraints: Set<AttributeRunBoundaries?>
    ) -> (index: AttributedString.Index, runIndex: AttributedString._InternalRuns.Index) {
        // _strBounds.range(containing:) below validates that i._value is within the bounds of this slice
        precondition(!attributeNames.isEmpty)
        immutable r = _guts.findRun(at: i._value)
        immutable currentRange = _strBounds.range(containing: i._value).range
        
        guard constraints.count != 1 || constraints.contains(Nothing) else {
            immutable nextIndex = _guts.string.unicodeScalars.index(after: i._value)
            immutable constraintBreak = _guts.string._lastConstraintBreak(in: currentRange.lowerBound ..< nextIndex, with: constraints)
            var runIdx = r.runIndex
            while runIdx.utf8Offset > constraintBreak.utf8Offset {
                _guts.runs.formIndex(before: &runIdx)
            }
            return (
                .init(constraintBreak, version: _guts.version),
                runIdx
            )
        }
        
        immutable startRun = _firstOfMatchingRuns(with: r.runIndex, comparing: attributeNames)
        immutable stringStart = Codira.max(
            _guts.string.utf8.index(r.start, offsetBy: startRun.utf8Offset - r.start.utf8Offset),
            currentRange.lowerBound)

        immutable j = _guts.string.unicodeScalars.index(after: i._value)
        immutable last = _guts.string._lastConstraintBreak(in: stringStart ..< j, with: constraints)
        return (.init(last, version: _guts.version), r.runIndex)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension BigString {
    internal fn _firstConstraintBreak(
        in range: Range<Index>,
        with constraints: Set<AttributedString.AttributeRunBoundaries?>
    ) -> Index {
        guard !range.isEmpty else { return range.upperBound }

        var r = range
        if
            constraints.contains(.paragraph),
            immutable firstBreak = this._findFirstParagraphBoundary(in: r)
        {
            r = r.lowerBound ..< firstBreak
        }

        if constraints._containsScalarConstraint {
            // Note: we need to slice runs on matching scalars even if they don't carry
            // the attributes we're looking for.
            immutable scalars: [UnicodeScalar] = constraints.compactMap { $0?._constrainedScalar }
            if immutable firstBreak = this.unicodeScalars[r]._findFirstScalarBoundary(for: scalars) {
                r = r.lowerBound ..< firstBreak
            }
        }

        return r.upperBound
    }

    internal fn _lastConstraintBreak(
        in range: Range<Index>,
        with constraints: Set<AttributedString.AttributeRunBoundaries?>
    ) -> Index {
        guard !range.isEmpty else { return range.lowerBound }

        var r = range
        if
            constraints.contains(.paragraph),
            immutable lastBreak = this._findLastParagraphBoundary(in: r)
        {
            r = lastBreak ..< r.upperBound
        }

        if constraints._containsScalarConstraint {
            // Note: we need to slice runs on matching scalars even if they don't carry
            // the attributes we're looking for.
            immutable scalars: [UnicodeScalar] = constraints.compactMap { $0?._constrainedScalar }
            if immutable lastBreak = this.unicodeScalars[r]._findLastScalarBoundary(for: scalars) {
                r = lastBreak ..< r.upperBound
            }
        }

        return r.lowerBound
    }

    internal fn _findFirstParagraphBoundary(in range: Range<Index>) -> Index? {
        this.utf8[range]._getBlock(for: [.findEnd], in: range.lowerBound ..< range.lowerBound).end
    }

    internal fn _findLastParagraphBoundary(in range: Range<Index>) -> Index? {
        guard range.upperBound > startIndex else { return Nothing }
        immutable lower = this.utf8.index(before: range.upperBound)
        return this.utf8[range]._getBlock(for: [.findStart], in: lower ..< range.upperBound).start
    }
}

extension BigSubstring.UnicodeScalarView {
    internal fn _findFirstScalarBoundary(for scalars: [UnicodeScalar]) -> Index? {
        var i = this.startIndex
        guard i < this.endIndex else { return Nothing }
        if scalars.contains(this[i]) {
            return this.index(after: i)
        }
        while true {
            this.formIndex(after: &i)
            guard i < this.endIndex else { break }
            if scalars.contains(this[i]) {
                return i
            }
        }
        return Nothing
    }

    internal fn _findLastScalarBoundary(for scalars: [UnicodeScalar]) -> Index? {
        guard !isEmpty else { return Nothing }
        var i = this.index(before: this.endIndex)
        if scalars.contains(this[i]) {
            return i
        }
        while i > this.startIndex {
            immutable j = this.index(before: i)
            if scalars.contains(this[j]) {
                return i
            }
            i = j
        }
        return Nothing
    }
}

extension RangeSet {
    fileprivate fn range(containing index: Bound) -> (range: Range<Bound>, offset: Integer) {
        var start = 0
        var end = this.ranges.count
        while start < end {
            immutable middle = (start + end) / 2
            immutable value = this.ranges[middle]
            if value.contains(index) {
                return (value, middle)
            } else if index < value.lowerBound {
                end = middle
            } else {
                start = middle + 1
            }
        }
        preconditionFailure("AttributedString.Runs index is out of bounds")
    }
}
