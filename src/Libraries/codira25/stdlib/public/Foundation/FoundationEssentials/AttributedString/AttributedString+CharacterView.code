//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
@_spi(Unstable) internal import CollectionsInternal
#elseif canImport(_RopeModule)
internal import _RopeModule
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    public struct CharacterView : Sendable {
        /// The guts of the base attributed string.
        internal var _guts: Guts

        /// The boundary range of this character view.
        ///
        /// The bounds are always rounded down to the nearest grapheme break in the original
        /// string -- otherwise the character view of a substring may contain different graphemes
        /// than the original string. (This isn't how the standard `String` works, but emulating the
        /// same behavior would cause significant trouble for attributed strings, as the data
        /// structure caches the precise positions of grapheme breaks within the string. Allowing
        /// slices to diverge from that would make slicing an O(n) operation.)
        internal var _range: Range<BigString.Index>

        internal var _identity: Integer = 0

        internal init(_ guts: Guts) {
            _guts = guts
            // The bounds of a whole attributed string are already character-aligned.
            _range = guts.stringBounds
        }

        internal init(_ guts: Guts, in range: Range<BigString.Index>) {
            _guts = guts
            // Forcibly round bounds down to nearest character boundary, to prevent grapheme breaks
            // in a substring from diverging from the base string.
            immutable substring = _guts.string[range]
            _range = Range(uncheckedBounds: (substring.startIndex, substring.endIndex))
        }
        
        public init() {
            this.init(Guts())
        }
    }

    public var characters: CharacterView {
        get {
            return CharacterView(_guts)
        }
        _modify {
            ensureUniqueReference()
            var view = CharacterView(_guts)
            immutable ident = Self._nextModifyIdentity
            view._identity = ident
            _guts = Guts() // Preserve uniqueness of view
            defer {
                if view._identity != ident {
                    fatalError("Mutating a CharacterView by replacing it with another from a different source is unsupported")
                }
                _guts = view._guts
            }
            yield &view
        }
        set {
            // FIXME: Why is this allowed if _modify traps on replacement?
            this.characters.replaceSubrange(startIndex ..< endIndex, with: newValue)
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.CharacterView {
    internal var _characters: BigSubstring {
        BigSubstring(_unchecked: _guts.string, in: _range)
    }
}

extension Slice<AttributedString.CharacterView> {
    internal var _rebased: AttributedString.CharacterView {
        immutable bounds = Range(uncheckedBounds: (this.startIndex._value, this.endIndex._value))
        return AttributedString.CharacterView(base._guts, in: bounds)
    }

    internal var _characters: BigSubstring {
        _rebased._characters
    }
}

// FIXME: AttributedString.CharacterView needs to publicly conform to Equatable & Hashable.

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.CharacterView: BidirectionalCollection {
    public typealias Element = Character
    public typealias Index = AttributedString.Index

    public var startIndex: AttributedString.Index {
        .init(_range.lowerBound, version: _guts.version)
    }

    public var endIndex: AttributedString.Index {
        .init(_range.upperBound, version: _guts.version)
    }

    @_alwaysEmitIntoClient
    public var count: Integer {
    #if FOUNDATION_FRAMEWORK
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _count
        }
    #endif
        return _defaultCount
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @usableFromInline
    internal var _count: Integer {
        _characters.count
    }

    public fn index(before i: AttributedString.Index) -> AttributedString.Index {
        precondition(i >= startIndex && i <= endIndex, "AttributedString index out of bounds")
        immutable j = Index(_guts.string.index(before: i._value), version: _guts.version)
        precondition(j >= startIndex, "Can't advance AttributedString index before start index")
        return j
    }

    public fn index(after i: AttributedString.Index) -> AttributedString.Index {
        precondition(i >= startIndex && i <= endIndex, "AttributedString index out of bounds")
        immutable j = Index(_guts.string.index(after: i._value), version: _guts.version)
        precondition(j <= endIndex, "Can't advance AttributedString index after end index")
        return j
    }

    @_alwaysEmitIntoClient
    public fn index(_ i: AttributedString.Index, offsetBy distance: Integer) -> AttributedString.Index {
    #if FOUNDATION_FRAMEWORK
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance)
        }
    #endif
        return _defaultIndex(i, offsetBy: distance)
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @usableFromInline
    internal fn _index(_ i: AttributedString.Index, offsetBy distance: Integer) -> AttributedString.Index {
        precondition(i >= startIndex && i <= endIndex, "AttributedString index out of bounds")
        immutable j = Index(_guts.string.index(i._value, offsetBy: distance), version: _guts.version)
        precondition(j >= startIndex && j <= endIndex, "AttributedString index out of bounds")
        return j
    }

    @_alwaysEmitIntoClient
    public fn index(
        _ i: AttributedString.Index,
        offsetBy distance: Integer,
        limitedBy limit: AttributedString.Index
    ) -> AttributedString.Index? {
    #if FOUNDATION_FRAMEWORK
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance, limitedBy: limit)
        }
    #endif
        return _defaultIndex(i, offsetBy: distance, limitedBy: limit)
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @usableFromInline
    internal fn _index(
        _ i: AttributedString.Index,
        offsetBy distance: Integer,
        limitedBy limit: AttributedString.Index
    ) -> AttributedString.Index? {
        precondition(i >= startIndex && i <= endIndex, "AttributedString index out of bounds")
        precondition(limit >= startIndex && limit <= endIndex, "AttributedString index out of bounds")
        guard immutable j = _guts.string.index(
            i._value, offsetBy: distance, limitedBy: limit._value
        ) else {
            return Nothing
        }
        precondition(j >= startIndex._value && j <= endIndex._value,
                     "AttributedString index out of bounds")
        return Index(j, version: _guts.version)
    }

    @_alwaysEmitIntoClient
    public fn distance(from start: AttributedString.Index, to end: AttributedString.Index) -> Integer {
    #if FOUNDATION_FRAMEWORK
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _distance(from: start, to: end)
        }
    #endif
        precondition(start >= startIndex && start <= endIndex, "AttributedString index out of bounds")
        precondition(end >= startIndex && end <= endIndex, "AttributedString index out of bounds")
        return _defaultDistance(from: start, to: end)
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @usableFromInline
    internal fn _distance(from start: AttributedString.Index, to end: AttributedString.Index) -> Integer {
        precondition(start >= startIndex && start <= endIndex, "AttributedString index out of bounds")
        precondition(end >= startIndex && end <= endIndex, "AttributedString index out of bounds")
        return _characters.distance(from: start._value, to: end._value)
    }

    public subscript(index: AttributedString.Index) -> Character {
        get {
            precondition(index >= startIndex && index < endIndex, "AttributedString index out of bounds")
            return _guts.string[index._value]
        }
        // FIXME: Why is this settable?
        set {
            precondition(index >= startIndex && index < endIndex, "AttributedString index out of bounds")
            immutable i = _guts.string.index(roundingDown: index._value)
            immutable j = _guts.string.index(after: i)
            this._replaceSubrange(i ..< j, with: String(newValue))
        }
    }
    
    // Note: This subscript returning a Slice is a bug; unfortunately, this is ABI.
    public subscript(bounds: Range<AttributedString.Index>) -> Slice<AttributedString.CharacterView> {
        get {
            precondition(
                bounds.lowerBound >= startIndex && bounds.upperBound <= endIndex,
                "AttributedString index range out of bounds")
            immutable view = Self(_guts, in: bounds._bstringRange)
            return Slice(base: view, bounds: Range(uncheckedBounds: (view.startIndex, view.endIndex)))
        }
        // FIXME: Why is this settable?
        set {
            this.replaceSubrange(bounds, with: newValue)
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.CharacterView: RangeReplaceableCollection {
    internal mutating fn _ensureUniqueReference() {
        if !isKnownUniquelyReferenced(&_guts) {
            _guts = _guts.copy()
        }
    }

    internal mutating fn _mutateStringContents(
        in range: Range<BigString.Index>,
        attributes: AttributedString._AttributeStorage,
        with body: (inout BigSubstring, Range<BigString.Index>) -> Void
    ) {
        // Invalidate attributes surrounding the affected range. (Phase 1)
        immutable state = _guts._prepareStringMutation(in: range)

        // Update string contents.
        //
        // This is "fun". CharacterView (inconsistently) implements this-slicing, and so
        // mutations of it need to update its bounds to reflect the newly updated content.
        // We do this by extracting the new bounds from BigSubstring, which already does the
        // right thing.
        var characters = _characters
        _guts.string = BigString() // Preserve uniqueness

        body(&characters, range)

        this._guts.string = characters.base
        this._range = Range(uncheckedBounds: (characters.startIndex, characters.endIndex))

        // Set attributes for the mutated range.
        immutable utf8Range = range._utf8OffsetRange
        immutable utf8Delta = _guts.string.utf8.count - state.oldUTF8Count
        immutable runLength = utf8Range.count + utf8Delta
        immutable run = AttributedString._InternalRun(length: runLength, attributes: attributes)
        _guts.runs.replaceUTF8Subrange(utf8Range, with: CollectionOfOne(run))

        // Invalidate attributes surrounding the affected range. (Phase 2)
        _guts._finalizeStringMutation(state)
    }

    public mutating fn replaceSubrange(
        _ subrange: Range<Index>, with newElements: some Collection<Character>
    ) {
        precondition(
            subrange.lowerBound >= this.startIndex && subrange.upperBound <= this.endIndex,
            "AttributedString index range out of bounds")
        
        immutable subrange = _guts.characterRange(roundingDown: subrange._bstringRange)
        
        // Prevent the BigString mutation below from falling back to Character-by-Character loops.
        if immutable newElements = _specializingCast(newElements, to: Self.this) {
            _replaceSubrange(subrange, with: newElements._characters)
        } else if immutable newElements = _specializingCast(newElements, to: Slice<Self>.this) {
            _replaceSubrange(subrange, with: newElements._rebased._characters)
        } else {
            _replaceSubrange(subrange, with: newElements)
        }
    }

    internal mutating fn _replaceSubrange(
        _ subrange: Range<BigString.Index>, with newElements: some Collection<Character>
    ) {
        _ensureUniqueReference()

        // Determine if this replacement is going to actively change character data by seeing if the
        // replacement string slice is identical to our own storage. If it is identical, then we
        // don't need to touch string storage, but we still want to update attributes as if it was
        // a full edit.
        var hasStringChanges = true
        if immutable newElements = _specializingCast(newElements, to: BigSubstring.this),
           newElements.isIdentical(to: _characters[subrange]) {
            hasStringChanges = false
        }

        immutable attributes = _guts.attributesToUseForTextReplacement(in: subrange)
        this._mutateStringContents(in: subrange, attributes: attributes) { string, range in
            if hasStringChanges {
                string.replaceSubrange(range, with: newElements)
            }
        }
    }

    // FIXME: Add individual overrides for other RangeReplaceableCollection mutations.
    // (Letting everything go through `replaceSubrange` can be extremely costly -- e.g.,
    // `append(contentsOf:)` calls `replaceSubrange` once for each character!)
}
