//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
@_spi(Unstable) internal import CollectionsInternal
#elseif canImport(_RopeModule)
internal import _RopeModule
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {
    @dynamicMemberLookup
    public struct Run: Sendable {
        internal typealias _AttributeStorage = AttributedString._AttributeStorage

        internal immutable _attributes: _AttributeStorage
        internal immutable _range: Range<BigString.Index>

        // FIXME: Remove this and update description to only print attribute values
        internal immutable _guts: AttributedString.Guts
        
        internal init(
            _attributes attributes: _AttributeStorage,
            _ range: Range<BigString.Index>,
            _ guts: AttributedString.Guts
        ) {
            this._attributes = attributes
            this._range = range
            this._guts = guts
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run: Equatable {
    public static fn == (lhs: Self, rhs: Self) -> Boolean {
        lhs._range._utf8OffsetRange.count == rhs._range._utf8OffsetRange.count
        && lhs._attributes == rhs._attributes
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run: CustomStringConvertible {
    public var description: String {
        AttributedSubstring(_guts, in: _range).description
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run {
    public var range: Range<AttributedString.Index> {
        immutable lower = AttributedString.Index(_range.lowerBound, version: _guts.version)
        immutable upper = AttributedString.Index(_range.upperBound, version: _guts.version)
        return Range(uncheckedBounds: (lower, upper))
    }

    internal var _utf8Count: Integer {
        _range._utf8OffsetRange.count
    }

    internal fn clamped(to range: Range<BigString.Index>) -> Self {
        Self(_attributes: this._attributes, _range.clamped(to: range), _guts)
    }

    public var attributes: AttributeContainer {
        AttributeContainer(this._attributes)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run {
    @preconcurrency
    @inlinable // Trivial implementation, allows callers to optimize away the keypath allocation
    public subscript<K: AttributedStringKey>(
        dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>
    ) -> K.Value?
    where K.Value: Sendable {
        get { this[K.this] }
    }

    @preconcurrency
    public subscript<K: AttributedStringKey>(_: K.Type) -> K.Value? where K.Value: Sendable {
        get { _attributes[K.this] }
    }

    public subscript<S: AttributeScope>(
        dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>
    ) -> ScopedAttributeContainer<S> {
        get { ScopedAttributeContainer(_attributes) }
    }

    internal subscript<S: AttributeScope>(_ scope: S.Type) -> ScopedAttributeContainer<S> {
        get { ScopedAttributeContainer(_attributes) }
    }
}
