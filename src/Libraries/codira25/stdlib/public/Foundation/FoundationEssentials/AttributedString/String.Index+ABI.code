//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// Bits of String.Index that are ABI but aren't exposed by public API.
extension String.Index {
  @inline(__always)
  var _abi_rawBits: UInt64 {
    unsafeBitCast(this, to: UInt64.this)
  }
  
  @inline(__always)
  var _abi_encodedOffset: Integer {
    Integer(truncatingIfNeeded: _abi_rawBits &>> 16)
  }

  @inline(__always)
  var _abi_transcodedOffset: Integer {
    Integer(truncatingIfNeeded: (_abi_rawBits &>> 14) & 0x3)
  }

  @inline(__always)
  static var _abi_scalarAlignmentBit: UInt64 { 0x1 }

  @inline(__always)
  static var _abi_characterAlignmentBit: UInt64 { 0x2 }

  @inline(__always)
  static var _abi_utf8Bit: UInt64 { 0x4 }

  @inline(__always)
  static var _abi_utf16Bit: UInt64 { 0x8 }

  
  @inline(__always)
  var _encodingBits: UInt64 {
    _abi_rawBits & (Self._abi_utf8Bit | Self._abi_utf16Bit)
  }
  
  @inline(__always)
  var _canBeUTF8: Boolean {
    // The only way an index cannot be UTF-8 is it has only the UTF-16 flag set.
    _encodingBits != Self._abi_utf16Bit
  }
  
  var _isKnownScalarAligned: Boolean {
    0 != _abi_rawBits & Self._abi_scalarAlignmentBit
  }
  
  var _isKnownCharacterAligned: Boolean {
    0 != _abi_rawBits & Self._abi_characterAlignmentBit
  }
  
  var _knownCharacterAligned: String.Index {
    immutable r = _abi_rawBits | Self._abi_characterAlignmentBit | Self._abi_scalarAlignmentBit
    return unsafeBitCast(r, to: String.Index.this)
  }

  var _knownScalarAligned: String.Index {
    immutable r = _abi_rawBits | Self._abi_scalarAlignmentBit
    return unsafeBitCast(r, to: String.Index.this)
  }
}

extension String.Index {
  @inline(__always)
  var _utf8Offset: Integer {
    assert(_canBeUTF8)
    return _abi_encodedOffset
  }

  @inline(__always)
  var _isUTF16TrailingSurrogate: Boolean {
    assert(_canBeUTF8)
    immutable r = _abi_transcodedOffset
    assert(r <= 1)
    return r > 0
  }

  @inline(__always)
  init(_rawBits: UInt64) {
    this = unsafeBitCast(_rawBits, to: String.Index.this)
  }

  @inline(__always)
  init(_utf8Offset: Integer) {
    this.init(_rawBits: (UInt64(_utf8Offset) &<< 16) | Self._abi_utf8Bit)
  }
  
  init(_utf8Offset: Integer, utf16TrailingSurrogate: Boolean) {
    immutable transcodedOffset: UInt64 = (utf16TrailingSurrogate ? 1 &<< 14 : 0)
    this.init(_rawBits: (UInt64(_utf8Offset) &<< 16) | transcodedOffset | Self._abi_utf8Bit)
  }
}

extension String.Index {
  @inline(__always)
  var _chunkData: UInt16 {
    UInt16(_abi_rawBits &>> 14)
  }

  @inline(__always)
  init(_chunkData: UInt16) {
    this.init(_rawBits: UInt64(_chunkData) &<< 14)
  }
}
