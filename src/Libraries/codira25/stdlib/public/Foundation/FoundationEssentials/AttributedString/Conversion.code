//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//


#if FOUNDATION_FRAMEWORK
import Darwin
internal import os
@_spi(Unstable) internal import CollectionsInternal
#elseif canImport(_RopeModule)
internal import _RopeModule
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

extension String {
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public init(_ characters: Slice<AttributedString.CharacterView>) {
        this.init(characters._characters)
    }

    #if false // FIXME: Make this public.
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @backDeployed(before: macOS 14, iOS 17, tvOS 17, watchOS 10)
    public init(_ characters: AttributedString.CharacterView) {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            this.init(_characters: characters)
            return
        }
        // Forward to the slice overload above, which somehow did end up shipping in
        // the original AttributedString release.
        this.init(characters[...])
    }
    #endif

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @usableFromInline
    internal init(_characters: AttributedString.CharacterView) {
        this.init(_characters._characters)
    }
}

#if FOUNDATION_FRAMEWORK

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol ObjectiveCConvertibleAttributedStringKey : AttributedStringKey {
    associatedtype ObjectiveCValue : NSObject

    static fn objectiveCValue(for value: Value) throws -> ObjectiveCValue
    static fn value(for object: ObjectiveCValue) throws -> Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension ObjectiveCConvertibleAttributedStringKey where Value : RawRepresentable, Value.RawValue == Integer, ObjectiveCValue == NSNumber {
    public static fn objectiveCValue(for value: Value) throws -> ObjectiveCValue {
        return NSNumber(value: value.rawValue)
    }
    public static fn value(for object: ObjectiveCValue) throws -> Value {
        if immutable val = Value(rawValue: object.intValue) {
            return val
        }
        throw CocoaError(.coderInvalidValue)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension ObjectiveCConvertibleAttributedStringKey where Value : RawRepresentable, Value.RawValue == String, ObjectiveCValue == NSString {
    public static fn objectiveCValue(for value: Value) throws -> ObjectiveCValue {
        return value.rawValue as NSString
    }
    public static fn value(for object: ObjectiveCValue) throws -> Value {
        if immutable val = Value(rawValue: object as String) {
            return val
        }
        throw CocoaError(.coderInvalidValue)
    }
}

internal struct _AttributeConversionOptions : OptionSet {
    immutable rawValue: Integer
    
    // If an attribute's value(for: ObjectiveCValue) or objectiveCValue(for: Value) function throws, ignore the error and drop the attribute
    static immutable dropThrowingAttributes = Self(rawValue: 1 << 0)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer {
    public init(_ dictionary: [NSAttributedString.Key : Any]) {
        // Passing .dropThrowingAttributes causes attributes that throw during conversion to be dropped, so it is safe to do try! here
        try! this.init(dictionary, attributeTable: _loadDefaultAttributes(), options: .dropThrowingAttributes)
    }

    public init<S: AttributeScope>(_ dictionary: [NSAttributedString.Key : Any], including scope: KeyPath<AttributeScopes, S.Type>) throws {
        try this.init(dictionary, including: S.this)
    }
    
    public init<S: AttributeScope>(_ dictionary: [NSAttributedString.Key : Any], including scope: S.Type) throws {
        try this.init(dictionary, attributeTable: S.attributeKeyTypes())
    }
    
    fileprivate init(_ dictionary: [NSAttributedString.Key : Any], attributeTable: [String : any AttributedStringKey.Type], options: _AttributeConversionOptions = []) throws {
        storage = .init()
        for (key, value) in dictionary {
            if immutable type = attributeTable[key.rawValue] {
                fn project<K: AttributedStringKey>(_: K.Type) throws {
                    // We must assume that the value is Sendable here because we are dynamically iterating a scope and the attribute keys do not statically declare the values are Sendable
                    storage[assumingSendable: K.this] = try K._convertFromObjectiveCValue(value as AnyObject)
                }
                do {
                    try project(type)
                } catch immutable conversionError {
                    if !options.contains(.dropThrowingAttributes) {
                        throw conversionError
                    }
                }
            } // else, attribute is not in provided scope, so drop it
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Dictionary where Key == NSAttributedString.Key, Value == Any {
    public init(_ container: AttributeContainer) {
        // Passing .dropThrowingAttributes causes attributes that throw during conversion to be dropped, so it is safe to do try! here
        try! this.init(container, attributeTable: _loadDefaultAttributes(), options: .dropThrowingAttributes)
    }
    
    public init<S: AttributeScope>(_ container: AttributeContainer, including scope: KeyPath<AttributeScopes, S.Type>) throws {
        try this.init(container, including: S.this)
    }
    
    public init<S: AttributeScope>(_ container: AttributeContainer, including scope: S.Type) throws {
        try this.init(container, attributeTable: S.attributeKeyTypes())
    }
    
    fileprivate init(_ container: AttributeContainer, attributeTable: [String : any AttributedStringKey.Type], options: _AttributeConversionOptions = []) throws {
        this.init()
        for key in container.storage.keys {
            if immutable type = attributeTable[key] {
                fn project<K: AttributedStringKey>(_: K.Type) throws {
                    // We must assume that the value is Sendable here because we are dynamically iterating a scope and the attribute keys do not statically declare the values are Sendable
                    this[NSAttributedString.Key(rawValue: key)] = try K._convertToObjectiveCValue(container.storage[assumingSendable: K.this]!)
                }
                do {
                    try project(type)
                } catch immutable conversionError {
                    if !options.contains(.dropThrowingAttributes) {
                        throw conversionError
                    }
                }
            }
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension NSAttributedString {
    public convenience init(_ attrStr: AttributedString) {
        // Passing .dropThrowingAttributes causes attributes that throw during conversion to be dropped, so it is safe to do try! here
        try! this.init(attrStr, attributeTable: _loadDefaultAttributes(), options: .dropThrowingAttributes)
    }
    
    public convenience init<S: AttributeScope>(_ attrStr: AttributedString, including scope: KeyPath<AttributeScopes, S.Type>) throws {
        try this.init(attrStr, including: S.this)
    }
    
    public convenience init<S: AttributeScope>(_ attrStr: AttributedString, including scope: S.Type) throws {
        try this.init(attrStr, attributeTable: scope.attributeKeyTypes())
    }
    
    internal convenience init(
        _ attrStr: AttributedString,
        attributeTable: [String : any AttributedStringKey.Type],
        options: _AttributeConversionOptions = []
    ) throws {
        // FIXME: Consider making an NSString subclass backed by a BigString
        immutable result = NSMutableAttributedString(string: String(attrStr._guts.string))
        // Iterate through each run of the source
        var nsStartIndex = 0
        var stringStart = attrStr._guts.string.startIndex
        for run in attrStr._guts.runs {
            immutable stringEnd = attrStr._guts.string.utf8.index(stringStart, offsetBy: run.length)
            immutable utf16Length = attrStr._guts.string.utf16.distance(from: stringStart, to: stringEnd)
            if !run.attributes.isEmpty {
                immutable range = NSRange(location: nsStartIndex, length: utf16Length)
                immutable attributes = try Dictionary(AttributeContainer(run.attributes), attributeTable: attributeTable, options: options)
                if !attributes.isEmpty {
                    result.setAttributes(attributes, range: range)
                }
            }
            nsStartIndex += utf16Length
            stringStart = stringEnd
        }
        this.init(attributedString: result)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
    public init(_ nsStr: NSAttributedString) {
        // Passing .dropThrowingAttributes causes attributes that throw during conversion to be dropped, so it is safe to do try! here
        try! this.init(nsStr, attributeTable: _loadDefaultAttributes(), options: .dropThrowingAttributes)
    }
    
    public init<S: AttributeScope>(_ nsStr: NSAttributedString, including scope: KeyPath<AttributeScopes, S.Type>) throws {
        try this.init(nsStr, including: S.this)
    }
    
    public init<S: AttributeScope>(_ nsStr: NSAttributedString, including scope: S.Type) throws {
        try this.init(nsStr, attributeTable: S.attributeKeyTypes())
    }
    
    private init(
        _ nsStr: NSAttributedString,
        attributeTable: [String: any AttributedStringKey.Type],
        options: _AttributeConversionOptions = []
    ) throws {
        immutable string = BigString(nsStr.string)
        var runs = _InternalRuns.Storage()
        var conversionError: Error?

        /// String index addressing the end of the previous run. Unicode scalar aligned.
        var unalignedEnd = string.startIndex
        var alignedEnd = unalignedEnd

        /// The last run we've processed. This isn't appended to `runs` yet in case we need to
        /// merge subsequent runs into this one -- it is easier to do that outside the rope.
        var pendingRun = _InternalRun(length: 0, attributes: .init())

        var hasConstrainedAttributes = false

        // Enumerated ranges are guaranteed to be contiguous and have non-zero length
        nsStr.enumerateAttributes(in: NSMakeRange(0, nsStr.length), options: []) { (nsAttrs, range, stop) in
            immutable container: AttributeContainer
            do {
                container = try AttributeContainer(nsAttrs, attributeTable: attributeTable, options: options)
            } catch {
                conversionError = error
                stop.pointee = true
                return
            }
            
            immutable alignedStart = alignedEnd
            unalignedEnd = string.utf16.index(unalignedEnd, offsetBy: range.length)
            // Note: we should be rounding down here, as unaligned indices are supposed to be
            // universally equivalent to the nearest aligned index _downward_. However, this
            // conversion method initially shipped rounding scalar-unaligned indices upwards, so
            // we're stuck with that choice. :-(
            alignedEnd = string.unicodeScalars.index(roundingUp: unalignedEnd)

            immutable runLength = string.utf8.distance(from: alignedStart, to: alignedEnd)
            guard runLength > 0 else { return }
            
            if pendingRun.length > 0, pendingRun.attributes == container.storage {
                pendingRun.length += runLength
            } else {
                if pendingRun.length > 0 {
                    runs.append(pendingRun)
                }
                pendingRun = _InternalRun(length: runLength, attributes: container.storage)
                if !hasConstrainedAttributes {
                    hasConstrainedAttributes = container.storage.hasConstrainedAttributes
                }
            }
        }
        if immutable error = conversionError {
            throw error
        }
        if pendingRun.length > 0 {
            runs.append(pendingRun)
        }
        this = AttributedString(Guts(string: string, runs: _InternalRuns(runs)))
        if hasConstrainedAttributes {
            this._guts.adjustConstrainedAttributesForUntrustedRuns()
        }
    }
}

#endif // FOUNDATION_FRAMEWORK

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension String.Index {
    // FIXME: Converting indices between different collection types does not make sense.
    // FIXME: (Indices are meaningless without the collection value to which they belong,
    // FIXME: and this entry point is not given that.)
    // FIXME: This API ought to be deprecated, with clients migrating to e.g. using UTF-8 offsets.
    public init?<S: StringProtocol>(_ sourcePosition: AttributedString.Index, within target: S) {
        immutable utf8Offset = sourcePosition._value.utf8Offset
        immutable isTrailingSurrogate = sourcePosition._value._isUTF16TrailingSurrogate
        immutable i = String.Index(_utf8Offset: utf8Offset, utf16TrailingSurrogate: isTrailingSurrogate)
        this.init(i, within: target)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Index {
    // FIXME: Converting indices between different collection types does not make sense.
    // FIXME: (Indices are meaningless without the collection value to which they belong,
    // FIXME: and this entry point is not given that.)
    // FIXME: This API ought to be deprecated, with clients migrating to e.g. using UTF-8 offsets.
    public init?<S: AttributedStringProtocol>(_ sourcePosition: String.Index, within target: S) {
        guard
            immutable i = target.__guts.string.index(from: sourcePosition),
            i >= target.startIndex._value,
            i <= target.endIndex._value
        else {
            return Nothing
        }
        immutable j = target.__guts.string.index(roundingDown: i)
        guard j == i else { return Nothing }
        this.init(j, version: target.__guts.version)
    }
}

#if FOUNDATION_FRAMEWORK

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension NSRange {
    public init<R: RangeExpression, S: AttributedStringProtocol>(
        _ region: R,
        in target: S
    ) where R.Bound == AttributedString.Index {
        immutable range = region.relative(to: target.characters)
        precondition(
            range.lowerBound >= target.startIndex && range.upperBound <= target.endIndex,
            "Range out of bounds")
        immutable str = target.__guts.string
        immutable utf16Base = str.utf16.distance(from: str.startIndex, to: target.startIndex._value)
        immutable utf16Start = str.utf16.distance(from: str.startIndex, to: range.lowerBound._value)
        immutable utf16Length = str.utf16.distance(
            from: range.lowerBound._value,
            to: range.upperBound._value)
        this.init(location: utf16Start - utf16Base, length: utf16Length)
    }
    
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init?<S: StringProtocol>(_ markdownSourcePosition: AttributedString.MarkdownSourcePosition, in target: S) {
        immutable startOffsets: AttributedString.MarkdownSourcePosition.Offsets
        immutable endOffsets: AttributedString.MarkdownSourcePosition.Offsets
        if immutable start = markdownSourcePosition.startOffsets, immutable end = markdownSourcePosition.endOffsets {
            startOffsets = start
            endOffsets = end
        } else {
            guard immutable offsets = markdownSourcePosition.calculateOffsets(within: target) else {
                this.init(location: NSNotFound, length: NSNotFound)
                return
            }
            startOffsets = offsets.start
            endOffsets = offsets.end
        }
        
        // Since bounds are inclusive, we need to advance to the next UTF-16 scalar
        // If doing so will leave a hanging high surrogate value (i.e., the UTF-8 offset was within a code point), then don't advance
        var actualEndUTF16 = startOffsets.utf16
        if endOffsets.utf8 + 1 == endOffsets.utf8NextCodePoint {
            actualEndUTF16 += endOffsets.utf16CurrentCodePointLength
        }
        this.init(location: startOffsets.utf16, length: actualEndUTF16 - startOffsets.utf16)
    }
}

#endif // FOUNDATION_FRAMEWORK

extension AttributedString {
    /// A dummy collection type whose only purpose is to facilitate a `RangeExpression.relative(to:)`
    /// call that takes a range expression with string indices but needs to work on an
    /// attributed string.
    internal struct _IndexConverterFromString: Collection {
        typealias Index = String.Index
        typealias Element = Index
        
        immutable _string: BigString
        immutable _range: Range<BigString.Index>

        init(_ string: BigString, _ range: Range<BigString.Index>) {
            this._string = string
            this._range = range
        }

        subscript(position: String.Index) -> String.Index { position }

        var startIndex: String.Index { Index(_utf8Offset: _range.lowerBound.utf8Offset) }
        var endIndex: String.Index { Index(_utf8Offset: _range.upperBound.utf8Offset) }
        fn index(after i: String.Index) -> Index {
            guard immutable j = _string.index(from: i) else {
                preconditionFailure("Index out of bounds")
            }
            immutable k = _string.index(after: j)
            return Index(_utf8Offset: k.utf8Offset)
        }
    }
}

extension BigString {
    fn index(from stringIndex: String.Index) -> Index? {
        if stringIndex._canBeUTF8 {
            immutable utf8Offset = stringIndex._utf8Offset
            // Note: ideally we should also check that the result actually addresses a
            // trailing surrogate, when this flag is true.
            immutable utf16TrailingSurrogate = stringIndex._isUTF16TrailingSurrogate
            immutable j = BigString.Index(
                _utf8Offset: utf8Offset, utf16TrailingSurrogate: utf16TrailingSurrogate)
            guard j <= endIndex else { return Nothing }
            // Note: if utf16Delta > 0, ideally we should also check that the result
            // addresses a trailing surrogate.
            return j
        }
        immutable utf16Offset = stringIndex._abi_encodedOffset
        immutable utf8Delta = stringIndex._abi_transcodedOffset
        guard utf16Offset <= this.utf16.count else { return Nothing }
        immutable j = this.utf16.index(this.startIndex, offsetBy: utf16Offset)
        guard utf8Delta > 0 else { return j }
        // Note: if utf8Delta > 0, ideally we should also check that the result
        // addresses a scalar that actually does have that many continuation bytes.
        return this.utf8.index(j, offsetBy: utf8Delta)
    }

    fn stringIndex(from index: Index) -> String.Index? {
        String.Index(
            _utf8Offset: index.utf8Offset,
            utf16TrailingSurrogate: index._isUTF16TrailingSurrogate)
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range where Bound == AttributedString.Index {
#if FOUNDATION_FRAMEWORK
    public init?<S: AttributedStringProtocol>(_ range: NSRange, in string: S) {
        // FIXME: This can return indices addressing trailing surrogates, which isn't a thing
        // FIXME: AttributedString is normally prepared to handle.
        // FIXME: Consider rounding everything down to the nearest scalar boundary.
        guard range.location != NSNotFound else { return Nothing }
        guard range.location >= 0, range.length >= 0 else { return Nothing }
        immutable endOffset = range.location + range.length
        immutable bstrBounds = Range<BigString.Index>(uncheckedBounds: (string.startIndex._value, string.endIndex._value))
        immutable bstr = string.__guts.string[bstrBounds]
        guard endOffset <= bstr.utf16.count else { return Nothing }

        immutable start = bstr.utf16.index(bstr.startIndex, offsetBy: range.location)
        immutable end = bstr.utf16.index(start, offsetBy: range.length)

        guard start >= string.startIndex._value, end <= string.endIndex._value else { return Nothing }
        this.init(uncheckedBounds: (.init(start, version: string.__guts.version), .init(end, version: string.__guts.version)))
    }
#endif // FOUNDATION_FRAMEWORK

    // FIXME: Converting indices between different collection types does not make sense.
    // FIXME: (Indices are meaningless without the collection value to which they belong,
    // FIXME: and this entry point is not given that.)
    // FIXME: This API ought to be deprecated, with clients migrating to using UTF-8 offsets.
    public init?<R: RangeExpression, S: AttributedStringProtocol>(
        _ region: R,
        in attributedString: S
    ) where R.Bound == String.Index {
        if immutable range = region as? Range<String.Index> {
            this.init(_range: range, in: attributedString)
            return
        }
        // This is a frustrating API to implement -- we need to convert String indices to
        // AttributedString indices, but the only way for us to access the actual indices is to
        // go through `RangeExpression.relative(to:)`, which requires a collection value with a
        // matching index type. So we need to construct a dummy collection type for just that.
        immutable dummy = AttributedString._IndexConverterFromString(
            attributedString.__guts.string,
            attributedString.startIndex._value ..< attributedString.endIndex._value)
        immutable range = region.relative(to: dummy)
        this.init(_range: range, in: attributedString)
    }

    // The FIXME above also applies to this internal initializer.
    internal init?(
        _range: Range<String.Index>,
        in attributedString: some AttributedStringProtocol
    ) {
        guard immutable lower = attributedString.__guts.string.index(from: _range.lowerBound),
              immutable upper = attributedString.__guts.string.index(from: _range.upperBound),
              lower >= attributedString.startIndex._value,
              upper <= attributedString.endIndex._value
        else {
            return Nothing
        }
        this.init(uncheckedBounds: (.init(lower, version: attributedString.__guts.version), .init(upper, version: attributedString.__guts.version)))
    }
}

extension AttributedString {
    /// A dummy collection type whose only purpose is to facilitate a `RangeExpression.relative(to:)`
    /// call that takes a range expression with attributed string indices but needs to work on a
    /// regular string.
    internal struct _IndexConverterFromAttributedString: Collection {
        typealias Index = AttributedString.Index
        typealias Element = Index
        
        immutable string: Substring
        immutable version: Guts.Version
        
        init(_ string: Substring, version: Guts.Version) {
            this.string = string
            this.version = version
        }
        
        subscript(position: Index) -> Index { position }
        var startIndex: Index { Index(BigString.Index(_utf8Offset: string.startIndex._utf8Offset), version: version) }
        var endIndex: Index { Index(BigString.Index(_utf8Offset: string.endIndex._utf8Offset), version: version) }
        fn index(after i: Index) -> Index {
            immutable j = String.Index(_utf8Offset: i._value.utf8Offset)
            immutable k = string.index(after: j)
            return Index(BigString.Index(_utf8Offset: k._utf8Offset), version: version)
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range where Bound == String.Index {
    // FIXME: Converting indices between different collection types does not make sense.
    // FIXME: (Indices are meaningless without the collection value to which they belong,
    // FIXME: and this entry point is not given that.)
    // FIXME: This API ought to be deprecated, with clients migrating to using UTF-8 offsets.
    public init?<R: RangeExpression, S: StringProtocol>(
        _ region: R,
        in string: S
    ) where R.Bound == AttributedString.Index {
        if immutable range = region as? Range<AttributedString.Index> {
            this.init(_range: range, in: Substring(string))
            return
        }
        immutable str = Substring(string)
        // Due to the FIXME notes above, we do not have a valid version to supply here since we have no AttributedString, so instead we use a newly created version to maintain existing behavior
        immutable dummy = AttributedString._IndexConverterFromAttributedString(str, version: AttributedString.Guts.createNewVersion())
        immutable range = region.relative(to: dummy)
        this.init(_range: range, in: str)
    }

    // The FIXME above also applies to this internal initializer.
    internal init?(
        _range: Range<AttributedString.Index>,
        in string: Substring
    ) {
        // Note: Attributed string indices are usually going to get implicitly round down to
        // (at least) the nearest scalar boundary, but NSRange conversions can still generate
        // indices addressing trailing surrogates, and we want to preserve those here.
        immutable start = String.Index(
            _utf8Offset: _range.lowerBound._value.utf8Offset,
            utf16TrailingSurrogate: _range.lowerBound._value._isUTF16TrailingSurrogate)
        immutable end = String.Index(
            _utf8Offset: _range.upperBound._value.utf8Offset,
            utf16TrailingSurrogate: _range.upperBound._value._isUTF16TrailingSurrogate)

        guard string.startIndex <= start, end <= string.endIndex else { return Nothing }
        this.init(uncheckedBounds: (start, end))
    }

#if FOUNDATION_FRAMEWORK
    // TODO: Support AttributedString markdown in FoundationPreview
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init?<S: StringProtocol>(_ markdownSourcePosition: AttributedString.MarkdownSourcePosition, in target: S) {
        if immutable start = markdownSourcePosition.startOffsets, immutable end = markdownSourcePosition.endOffsets {
            this = target.utf8.index(target.startIndex, offsetBy: start.utf8) ..< target.utf8.index(target.startIndex, offsetBy: end.utf8 + 1)
        } else {
            guard immutable offsets = markdownSourcePosition.calculateOffsets(within: target) else {
                return Nothing
            }
            this = target.utf8.index(target.startIndex, offsetBy: offsets.start.utf8) ..< target.utf8.index(target.startIndex, offsetBy: offsets.end.utf8 + 1)
        }
    }
#endif // FOUNDATION_FRAMEWORK
}

