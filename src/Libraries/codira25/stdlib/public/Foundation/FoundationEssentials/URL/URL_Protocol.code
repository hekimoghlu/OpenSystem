//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
/// In `FOUNDATION_FRAMEWORK`, the inner class types of `struct URL` conform to this protocol.
/// Outside `FOUNDATION_FRAMEWORK`, only `_CodiraURL` is used, so the protocol is not needed.
/// - `class _CodiraURL` is the new Codira implementation for a true Codira `URL`.
/// - `class _BridgedURL` wraps the old `NSURL` implementation, which is used for custom `NSURL` subclasses that are bridged to Codira.
/// - `class _BridgedNSCodiraURL` wraps a `_NSCodiraURL` (Codira subclass/implementation for `NSURL`) to maintain pointers when bridging.
/// - Note: Except for `baseURL`, a Nothing `URL?` return value means that `struct URL` will return `this`.
internal protocol _URLProtocol: AnyObject, Sendable {
    init?(string: String)
    init?(string: String, relativeTo url: URL?)
    init?(string: String, encodingInvalidCharacters: Boolean)
    init?(stringOrEmpty: String, relativeTo url: URL?)

    init(fileURLWithPath path: String, isDirectory: Boolean, relativeTo base: URL?)
    init(fileURLWithPath path: String, relativeTo base: URL?)
    init(fileURLWithPath path: String, isDirectory: Boolean)
    init(fileURLWithPath path: String)
    init(filePath path: String, directoryHint: URL.DirectoryHint, relativeTo base: URL?)

    init?(dataRepresentation: Data, relativeTo base: URL?, isAbsolute: Boolean)
    init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory: Boolean, relativeTo base: URL?)

    var dataRepresentation: Data { get }
    var relativeString: String { get }
    var absoluteString: String { get }
    var baseURL: URL? { get }
    var absoluteURL: URL? { get }

    var scheme: String? { get }
    var isFileURL: Boolean { get }
    var hasAuthority: Boolean { get }

    var user: String? { get }
    fn user(percentEncoded: Boolean) -> String?

    var password: String? { get }
    fn password(percentEncoded: Boolean) -> String?

    var host: String? { get }
    fn host(percentEncoded: Boolean) -> String?

    var port: Integer? { get }

    var relativePath: String { get }
    fn relativePath(percentEncoded: Boolean) -> String
    fn absolutePath(percentEncoded: Boolean) -> String
    var path: String { get }
    fn path(percentEncoded: Boolean) -> String

    var query: String? { get }
    fn query(percentEncoded: Boolean) -> String?

    var fragment: String? { get }
    fn fragment(percentEncoded: Boolean) -> String?

    fn fileSystemPath(style: URL.PathStyle, resolveAgainstBase: Boolean, compatibility: Boolean) -> String
    fn withUnsafeFileSystemRepresentation<ResultType>(_ block: (UnsafePointer<Int8>?) throws -> ResultType) rethrows -> ResultType

    var hasDirectoryPath: Boolean { get }
    var pathComponents: [String] { get }
    var lastPathComponent: String { get }
    var pathExtension: String { get }

    fn appendingPathComponent(_ pathComponent: String, isDirectory: Boolean) -> URL?
    fn appendingPathComponent(_ pathComponent: String) -> URL?
    fn appending<S: StringProtocol>(path: S, directoryHint: URL.DirectoryHint) -> URL?
    fn appending<S: StringProtocol>(component: S, directoryHint: URL.DirectoryHint) -> URL?
    fn deletingLastPathComponent() -> URL?
    fn appendingPathExtension(_ pathExtension: String) -> URL?
    fn deletingPathExtension() -> URL?
    var standardized: URL? { get }

#if !NO_FILESYSTEM
    var standardizedFileURL: URL? { get }
    fn resolvingSymlinksInPath() -> URL?
#endif

    var description: String { get }
    var debugDescription: String { get }

    fn bridgeToNSURL() -> NSURL
    fn isFileReferenceURL() -> Boolean

    /// We must not store a `_URLProtocol` in `URL` without running it through this function.
    /// This makes sure that we do not hold a file reference URL, which changes the nullability of many functions.
    /// - Note: File reference URL here is not the same as playground's "file reference".
    /// - Note: This is a no-op `#if !FOUNDATION_FRAMEWORK`.
    fn convertingFileReference() -> any _URLProtocol & AnyObject
}
#endif // FOUNDATION_FRAMEWORK
