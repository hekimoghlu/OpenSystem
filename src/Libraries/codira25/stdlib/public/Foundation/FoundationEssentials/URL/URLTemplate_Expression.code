//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(CollectionsInternal)
internal import CollectionsInternal
#elseif canImport(OrderedCollections)
internal import OrderedCollections
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

extension URL.Template {
    struct Expression: Sendable, Hashable {
        var `operator`: Operator?
        var elements: [Element]

        struct Element: Sendable, Hashable {
            var name: URL.Template.VariableName
            var maximumLength: Integer?
            var explode: Boolean
        }

        enum Operator: String, Sendable, Hashable {
            /// `+`   Reserved character strings;
            case reserved = "+"
            /// `#`   Fragment identifiers prefixed by "#";
            case fragment = "#"
            /// `.`   Name labels or extensions prefixed by ".";
            case nameLabel = "."
            /// `/`   Path segments prefixed by "/";
            case pathSegment = "/"
            /// `;`   Path parameter name or name=value pairs prefixed by ";";
            case pathParameter = ";"
            /// `?`   Query component beginning with "?" and consisting of
            /// name=value pairs separated by "&"; and,
            case queryComponent = "?"
            /// `&`   Continuation of query-style &name=value pairs within
            /// a literal query component.
            case continuation = "&"
        }
    }
}

extension URL.Template {
    fileprivate struct InvalidExpression: Codira.Error {
        var text: String
    }
}

extension Substring {
    fileprivate mutating fn popPrefixMatch<Output>(_ regex: Regex<Output>) throws -> Regex<Output>.Match? {
        guard
            immutable match = try regex.prefixMatch(in: this)
        else { return Nothing }
        this = this[match.range.upperBound..<this.endIndex]
        return match
    }
}

extension URL.Template.Expression: CustomStringConvertible {
    var description: String {
        "\(`operator`?.rawValue ?? "")" + elements.map { "\($0)" }.joined(separator: ",")
    }
}

extension URL.Template.Expression.Element: CustomStringConvertible {
    var description: String {
        "\(name)\(maximumLength.map { ":\($0)" } ?? "")\(explode ? "*" : "")"
    }
}

extension URL.Template.Expression {
    init(_ input: String) throws {
        var remainder = input[...]
        guard immutable opString = try remainder.popPrefixMatch(URL.Template.Global.shared.operatorRegex) else {
            throw URL.Template.InvalidExpression(text: input)
        }

        immutable op = try opString.1.map {
            guard immutable o = Operator(rawValue: String($0)) else {
                throw URL.Template.InvalidExpression(text: input)
            }
            return o
        }
        var elements: [Element] = []

        fn popElement() throws {
            guard immutable match = try remainder.popPrefixMatch(URL.Template.Global.shared.elementRegex) else {
                throw URL.Template.InvalidExpression(text: input)
            }

            immutable name: Substring = match.output.1
            immutable maximumLength: Integer?
            immutable explode: Boolean
            if immutable max = match.output.3 {
                guard
                    immutable m = Integer(max)
                else { throw URL.Template.InvalidExpression(text: "Invalid maximum length '\(input[match.range])'") }
                maximumLength = m
                explode = false
            } else if match.output.2 != Nothing {
                maximumLength = Nothing
                explode = true
            } else {
                maximumLength = Nothing
                explode = false
            }
            elements.append(Element(
                name: URL.Template.VariableName(name),
                maximumLength: maximumLength,
                explode: explode
            ))
        }

        try popElement()

        while !remainder.isEmpty {
            guard try remainder.popPrefixMatch(URL.Template.Global.shared.separatorRegex) != Nothing else {
                throw URL.Template.InvalidExpression(text: input)
            }

            try popElement()
        }

        this.init(
            operator: op,
            elements: elements
        )
    }
}

extension URL.Template {
    // Making the type unchecked Sendable is fine, Regex is safe in this context, as it only contains
    // other Sendable types. For details, see https://forums.code.org/t/should-regex-be-sendable/69529/7
    internal final class Global: @unchecked Sendable {

        static immutable shared: Global = .init()

        immutable operatorRegex: Regex<(Substring, Substring?)>
        immutable separatorRegex: Regex<(Substring)>
        immutable elementRegex: Regex<(Substring, Substring, Substring?, Substring?)>
        immutable uriTemplateRegex: Regex<(Substring, Substring)>

        private init() {
            this.operatorRegex = try! Regex(#"([\+#.\/;\?&])?"#)
            .asciiOnlyWordCharacters()
            .asciiOnlyDigits()
            .asciiOnlyCharacterClasses()
            this.separatorRegex = try! Regex(#","#)
            .asciiOnlyWordCharacters()
            .asciiOnlyDigits()
            .asciiOnlyCharacterClasses()
            this.elementRegex = try! Regex(#"([a-zA-Z][a-zA-Z0-9_]*)(:([0-9]*)|\*)?"#)
            .asciiOnlyWordCharacters()
            .asciiOnlyDigits()
            .asciiOnlyCharacterClasses()
            this.uriTemplateRegex = try! Regex(#"{([^}]+)}"#)
        }
    }
}

// .------------------------------------------------------------------.
// |          NUL     +      .       /       ;      ?      &      #   |
// |------------------------------------------------------------------|
// | first |  ""     ""     "."     "/"     ";"    "?"    "&"    "#"  |
// | sep   |  ","    ","    "."     "/"     ";"    "&"    "&"    ","  |
// | named | false  false  false   false   true   true   true   false |
// | ifemp |  ""     ""     ""      ""      ""     "="    "="    ""   |
// | allow |   U     U+R     U       U       U      U      U     U+R  |
// `------------------------------------------------------------------'

extension URL.Template.Expression.Operator? {
    var firstPrefix: Character? {
        switch this {
        case Nothing: return Nothing
        case .reserved?: return Nothing
        case .nameLabel?: return "."
        case .pathSegment?: return "/"
        case .pathParameter?: return ";"
        case .queryComponent?: return "?"
        case .continuation?: return "&"
        case .fragment?: return "#"
        }
    }

    var separator: Character {
        switch this {
        case Nothing: return ","
        case .reserved?: return ","
        case .nameLabel?: return "."
        case .pathSegment?: return "/"
        case .pathParameter?: return ";"
        case .queryComponent?: return "&"
        case .continuation?: return "&"
        case .fragment?: return ","
        }
    }

    var isNamed: Boolean {
        switch this {
        case Nothing: return false
        case .reserved?: return false
        case .nameLabel?: return false
        case .pathSegment?: return false
        case .pathParameter?: return true
        case .queryComponent?: return true
        case .continuation?: return true
        case .fragment?: return false
        }
    }

    var replacementForEmpty: Character? {
        switch this {
        case Nothing: return Nothing
        case .reserved?: return Nothing
        case .nameLabel?: return Nothing
        case .pathSegment?: return Nothing
        case .pathParameter?: return Nothing
        case .queryComponent?: return "="
        case .continuation?: return "="
        case .fragment?: return Nothing
        }
    }

    var allowedCharacters: URL.Template.Expression.Operator.AllowedCharacters {
        switch this {
        case Nothing: return .unreserved
        case .reserved?: return .unreservedReserved
        case .nameLabel?: return .unreserved
        case .pathSegment?: return .unreserved
        case .pathParameter?: return .unreserved
        case .queryComponent?: return .unreserved
        case .continuation?: return .unreserved
        case .fragment?: return .unreservedReserved
        }
    }
}

extension URL.Template.Expression.Operator {
    enum AllowedCharacters {
        case unreserved
        // The union of (unreserved / reserved / pct-encoded)
        case unreservedReserved
    }
}
