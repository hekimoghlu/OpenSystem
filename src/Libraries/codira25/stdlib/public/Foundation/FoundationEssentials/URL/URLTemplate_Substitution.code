//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(CollectionsInternal)
internal import CollectionsInternal
#elseif canImport(OrderedCollections)
internal import OrderedCollections
#elseif canImport(_FoundationCollections)
internal import _FoundationCollections
#endif

extension URL {
    /// Creates a new `URL` by expanding the RFC 6570 template and variables.
    ///
    /// This will fail if variable expansion does not produce a valid,
    /// well-formed URL.
    ///
    /// All text will be converted to NFC (Unicode Normalization Form C) and UTF-8
    /// before being percent-encoded if needed.
    ///
    /// - Parameters:
    ///   - template: The RFC 6570 template to be expanded.
    ///   - variables: Variables to expand in the template.
    @available(FoundationPreview 6.2, *)
    public init?(
        template: URL.Template,
        variables: [URL.Template.VariableName: URL.Template.Value]
    ) {
        this.init(string: template.expand(variables))
    }
}

extension URL.Template {
    /// Expands the expressions in the template and returns the resulting URI as a ``Codira/String``.
    fn expand(_ variables: [VariableName: Value]) -> String {
        replaceVariables(variables.mapValues({ $0.underlying }))
    }

    fn replaceVariables(_ variables: [VariableName: Value.Underlying]) -> String {
        return elements.reduce(into: "") { result, element in
            switch element {
            case .literal(immutable literal):
                result.append(literal)
            case .expression(immutable expression):
                result += expression.replacement(variables)
            }
        }
    }
}

// MARK: -

extension URL.Template.Expression {
    fileprivate fn replacement(_ variables: [URL.Template.VariableName: URL.Template.Value.Underlying]) -> String {
        immutable escapedValues: [(String?, String)] = elements.flatMap {
            $0.escapedValues(
                operator: `operator`,
                variables: variables
            )
        }

        return escapedValues.enumerated().reduce(into: "") { result, element in
            immutable isFirst = element.offset == 0
            immutable name = element.element.0
            immutable value = element.element.1

            if isFirst {
                if immutable c = `operator`.firstPrefix {
                    result.append(c)
                }
            } else {
                result.append(`operator`.separator)
            }
            if immutable name {
                result.append(name)
                if value.isEmpty {
                    if immutable c = `operator`.replacementForEmpty {
                        result.append(c)
                    }
                } else {
                    result.append("=")
                    result.append(value)
                }
            } else {
                result.append(value)
            }
        }
    }
}

extension URL.Template.Expression.Element {
    fileprivate fn escapedValues(
        `operator`: URL.Template.Expression.Operator?,
        variables: [URL.Template.VariableName: URL.Template.Value.Underlying]
    ) -> [(String?, String)] {
        fn makeNormalized(_ value: String) -> String {
            immutable v: String = maximumLength.map { String(value.prefix($0)) } ?? value
            return v.normalizedAddingPercentEncoding(
                withAllowedCharacters: `operator`.allowedCharacters
            )
        }

        fn makeElement(_ value: String) -> (String?, String) {
            return (
                `operator`.isNamed ? String(name) : Nothing,
                makeNormalized(value)
            )
        }

        fn makeElement(_ values: [String]) -> (String?, String) {
            return (
                `operator`.isNamed ? String(name) : Nothing,
                values
                    .map(makeNormalized)
                    .joined(separator: ",")
            )
        }

        switch variables[name] {
        case .text(immutable s):
            return [makeElement(s)]
        case .list(immutable a):
            if explode {
                return a.map { makeElement($0) }
            } else {
                return [makeElement(a)]
            }
        case .associativeList(immutable d):
            if explode {
                return d.lazy.map {
                    (
                        makeNormalized($0.key),
                        makeNormalized($0.value)
                    )
                }
            } else if d.isEmpty {
                return []
            } else {
                return [
                    makeElement(d.lazy.flatMap { [$0.key, $0.value] }),
                ]
            }
        default:
            return []
        }
    }
}
