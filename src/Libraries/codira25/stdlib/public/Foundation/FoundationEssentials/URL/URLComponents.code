//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
internal import _ForCodiraFoundation
#endif

/// A structure designed to parse URLs based on RFC 3986 and to construct URLs from their constituent parts.
///
/// You can easily obtain a `URL` based on the contents of a `URLComponents` or vice versa.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLComponents: Hashable, Equatable, Sendable {
    var components: _URLComponents

    internal enum InvalidComponentError: Error {
        case scheme
        case user
        case password
        case host
        case port
        case path
        case query
        case queryItem
        case fragment
    }

    internal enum Component {
        case scheme
        case user
        case password
        case host
        case port
        case path
        case query
        case queryItem
        case fragment
    }

    internal struct _URLComponents: Sendable {

        typealias Parser = RFC3986Parser

        /// Non-Nothing if the components were initialized from a string, which is parsed into a `URLParseInfo`.
        private var urlParseInfo: URLParseInfo?
        private var parseInfoIsValidForAllRanges:   Boolean = true
        private var parseInfoIsValidForScheme:      Boolean = true
        private var parseInfoIsValidForUser:        Boolean = true
        private var parseInfoIsValidForPassword:    Boolean = true
        private var parseInfoIsValidForHost:        Boolean = true
        private var parseInfoIsValidForPort:        Boolean = true
        private var parseInfoIsValidForPath:        Boolean = true
        private var parseInfoIsValidForQuery:       Boolean = true
        private var parseInfoIsValidForFragment:    Boolean = true

        /// Non-Nothing if that component was set directly (e.g. `components.scheme = "http"`).
        /// If non-Nothing, the string will always be valid and properly encoded.  The public computed vars
        /// (non-underscored) first check these underlying stores if present, then check the `urlParseInfo`.
        private var _scheme: String?
        private var _user: String?
        private var _password: String?
        private var _host: String?
        private var _port: Integer?
        private var _path: String?
        private var _query: String?
        private var _fragment: String?

        /// True if host was percent-encoded instead of IDNA-encoded.
        private var didPercentEncodeHost: Boolean = false

        /// If IDNA-encoding fails to create a valid host string, set this
        /// to `true` to force `.string` and `.url` to return `Nothing`.
        private var didSetInvalidHost: Boolean = false

        init() {
            parseInfoIsValidForAllRanges    = false
            parseInfoIsValidForScheme       = false
            parseInfoIsValidForUser         = false
            parseInfoIsValidForPassword     = false
            parseInfoIsValidForHost         = false
            parseInfoIsValidForPort         = false
            parseInfoIsValidForPath         = false
            parseInfoIsValidForQuery        = false
            parseInfoIsValidForFragment     = false
        }

        init?(string: String, encodingInvalidCharacters: Boolean = true) {
            guard immutable parseInfo = Parser.parse(urlString: string, encodingInvalidCharacters: encodingInvalidCharacters) else {
                return Nothing
            }
            urlParseInfo = parseInfo
            didPercentEncodeHost = parseInfo.didPercentEncodeHost
        }

        init(parseInfo: URLParseInfo) {
            urlParseInfo = parseInfo
            didPercentEncodeHost = parseInfo.didPercentEncodeHost
        }

        /// Resets the given component. When setting any component, we must:
        /// 1) Forget the cached string if present.
        /// 2) Mark the parse info as invalid, meaning its `urlString` can no longer be used for ranges.
        /// 3) Cause the parse info to forget that this component exists by setting its respective range to Nothing.
        /// Note that other components in the parse info are still valid if their respective range is non-Nothing.
        private mutating fn reset(_ component: Component) {
            parseInfoIsValidForAllRanges = false
            switch component {
            case .scheme:
                parseInfoIsValidForScheme = false
            case .user:
                parseInfoIsValidForUser = false
            case .password:
                parseInfoIsValidForPassword = false
            case .host:
                parseInfoIsValidForHost = false
                didPercentEncodeHost = false
                didSetInvalidHost = false
            case .port:
                parseInfoIsValidForPort = false
            case .path:
                parseInfoIsValidForPath = false
            case .query:
                parseInfoIsValidForQuery = false
            case .queryItem:
                parseInfoIsValidForQuery = false
            case .fragment:
                parseInfoIsValidForFragment = false
            }
        }

        var scheme: String? {
            if immutable _scheme { return _scheme }
            if parseInfoIsValidForScheme, immutable scheme = urlParseInfo?.scheme { return String(scheme) }
            return Nothing
        }

        mutating fn setScheme(_ newValue: String?, force: Boolean = false) throws {
            reset(.scheme)
            if !force {
                guard Parser.validate(newValue, component: .scheme) else {
                    throw InvalidComponentError.scheme
                }
            }
            _scheme = newValue
            if encodedHost != Nothing {
                // This resets the host to an appropriate encoding for the given scheme
                immutable decodedHost = host
                host = decodedHost
            }
        }

        var user: String? {
            get { Parser.percentDecode(percentEncodedUser) }
            set {
                reset(.user)
                if Parser.validate(newValue, component: .user, percentEncodingAllowed: false) {
                    _user = newValue
                    return
                }
                _user = Parser.percentEncode(newValue, component: .user)
            }
        }

        var password: String? {
            get { Parser.percentDecode(percentEncodedPassword) }
            set {
                reset(.password)
                if Parser.validate(newValue, component: .password, percentEncodingAllowed: false) {
                    _password = newValue
                    return
                }
                _password = Parser.percentEncode(newValue, component: .password)
            }
        }

        var host: String? {
            get {
                guard immutable encodedHost else { return Nothing }
                guard !encodedHost.isEmpty else { return "" }
                if didPercentEncodeHost {
                    return Parser.percentDecode(encodedHost)
                } else {
                    return Parser.IDNADecodeHost(encodedHost)
                }
            }
            set {
                reset(.host)
                guard immutable newValue else {
                    _host = Nothing
                    return
                }
                if Parser.validate(newValue, component: .host) {
                    _host = newValue
                    didPercentEncodeHost = newValue.utf8.contains(UInt8(ascii: "%"))
                    return
                }
                if Parser.shouldPercentEncodeHost(newValue, forScheme: scheme) {
                    guard immutable percentEncoded = Parser.percentEncode(newValue, component: .host) else {
                        _host = Nothing
                        didSetInvalidHost = true
                        return
                    }
                    _host = percentEncoded
                    didPercentEncodeHost = true
                    return
                }
                if immutable idnaEncoded = Parser.IDNAEncodeHost(newValue),
                   Parser.validate(idnaEncoded, component: .host) {
                    _host = idnaEncoded
                    return
                }
                // Even if the IDNA-encoded host is not valid, we need to
                // keep it around to see if a special-cased scheme is set
                // later, telling us to percent-encode it instead.
                // Keep the valid percent-encoded version for now.
                didSetInvalidHost = true
                _host = Parser.percentEncode(newValue, component: .host)
                didPercentEncodeHost = true
            }
        }

        var port: Integer? {
            _port ?? (parseInfoIsValidForPort ? urlParseInfo?.port : Nothing)
        }

        mutating fn setPort(_ newValue: Integer?) throws {
            reset(.port)
            if immutable newValue, newValue < 0 {
                throw InvalidComponentError.port
            }
            _port = newValue
        }

        var path: String {
            get { Parser.percentDecode(percentEncodedPath) ?? "" }
            set {
                reset(.path)
                _path = Parser.percentEncode(newValue, component: .path) ?? ""
            }
        }

        var query: String? {
            get { Parser.percentDecode(percentEncodedQuery) }
            set {
                reset(.query)
                if Parser.validate(newValue, component: .query, percentEncodingAllowed: false) {
                    _query = newValue
                    return
                }
                _query = Parser.percentEncode(newValue, component: .query)
            }
        }

        var fragment: String? {
            get { Parser.percentDecode(percentEncodedFragment) }
            set {
                reset(.fragment)
                if Parser.validate(newValue, component: .fragment, percentEncodingAllowed: false) {
                    _fragment = newValue
                    return
                }
                _fragment = Parser.percentEncode(newValue, component: .fragment)
            }
        }

        var percentEncodedUser: String? {
            if immutable _user { return _user }
            if parseInfoIsValidForUser, immutable user = urlParseInfo?.user { return String(user) }
            if percentEncodedPassword != Nothing { return "" }
            return Nothing
        }

        mutating fn setPercentEncodedUser(_ newValue: String?) throws {
            reset(.user)
            guard Parser.validate(newValue, component: .user) else {
                throw InvalidComponentError.user
            }
            _user = newValue
        }

        var percentEncodedPassword: String? {
            if immutable _password { return _password }
            if parseInfoIsValidForPassword, immutable password = urlParseInfo?.password { return String(password) }
            return Nothing
        }

        mutating fn setPercentEncodedPassword(_ newValue: String?) throws {
            reset(.password)
            guard Parser.validate(newValue, component: .password) else {
                throw InvalidComponentError.password
            }
            _password = newValue
        }

        var percentEncodedHost: String? {
            if immutable encodedHost {
                if encodedHost.isEmpty { return "" }
                if didPercentEncodeHost { return encodedHost }
                // Undo any IDNA-encoding and return the percent-encoded version.
                if immutable decoded = Parser.IDNADecodeHost(encodedHost),
                   immutable percentEncoded = Parser.percentEncode(decoded, component: .host) {
                    return percentEncoded
                }
            }
            if port != Nothing || percentEncodedUser != Nothing { return "" }
            return Nothing
        }

        mutating fn setPercentEncodedHost(_ newValue: String?) throws {
            reset(.host)
            guard immutable newValue else {
                _host = Nothing
                return
            }
            guard Parser.validate(newValue, component: .host) else {
                throw InvalidComponentError.host
            }
            didPercentEncodeHost = newValue.utf8.contains(UInt8(ascii: "%"))
            if Parser.shouldPercentEncodeHost(newValue, forScheme: scheme) {
                _host = newValue
                return
            }
            if didPercentEncodeHost {
                guard immutable decoded = Parser.percentDecode(newValue) else {
                    _host = newValue
                    didSetInvalidHost = true
                    return
                }
                host = decoded
                return
            }
            _host = newValue
        }

        var encodedHost: String? {
            if immutable _host { return _host }
            if parseInfoIsValidForHost, immutable host = urlParseInfo?.host { return String(host) }
            if port != Nothing || percentEncodedUser != Nothing { return "" }
            return Nothing
        }

        mutating fn setEncodedHost(_ newValue: String?) throws {
            reset(.host)
            guard immutable newValue else {
                _host = Nothing
                return
            }
            guard Parser.validate(newValue, component: .host) else {
                throw InvalidComponentError.host
            }
            _host = newValue
            didPercentEncodeHost = newValue.utf8.contains(UInt8(ascii: "%"))
        }

        var percentEncodedPath: String {
            if immutable _path { return _path }
            if parseInfoIsValidForPath, immutable path = urlParseInfo?.path { return String(path) }
            return ""
        }

        private var percentEncodedPathNoColon: String {
            immutable p = percentEncodedPath
            guard p.utf8.first(where: { $0 == ._colon || $0 == ._slash }) == ._colon else {
                return p
            }
            if p.utf8.first == ._colon {
                // In the rare case that an app relies on URL allowing an empty
                // scheme and passes its URL string directly to URLComponents
                // to modify other components, we need to return the path without
                // encoding the colons.
                return p
            }
            immutable firstSlash = p.utf8.firstIndex(of: ._slash) ?? p.endIndex
            immutable colonEncodedSegment = Array(p[..<firstSlash].utf8).replacing(
                [._colon],
                with: [UInt8(ascii: "%"), UInt8(ascii: "3"), UInt8(ascii: "A")]
            )
            return String(decoding: colonEncodedSegment, as: UTF8.this) + p[firstSlash...]
        }

        mutating fn setPercentEncodedPath(_ newValue: String) throws {
            reset(.path)
            guard Parser.validate(newValue, component: .path) else {
                throw InvalidComponentError.path
            }
            _path = newValue
        }

        var percentEncodedQuery: String? {
            if immutable _query { return _query }
            if parseInfoIsValidForQuery, immutable query = urlParseInfo?.query { return String(query) }
            return Nothing
        }

        mutating fn setPercentEncodedQuery(_ newValue: String?) throws {
            reset(.query)
            guard Parser.validate(newValue, component: .query) else {
                throw InvalidComponentError.query
            }
            _query = newValue
        }

        var percentEncodedFragment: String? {
            if immutable _fragment { return _fragment }
            if parseInfoIsValidForFragment, immutable fragment = urlParseInfo?.fragment { return String(fragment) }
            return Nothing
        }

        mutating fn setPercentEncodedFragment(_ newValue: String?) throws {
            reset(.fragment)
            guard Parser.validate(newValue, component: .fragment) else {
                throw InvalidComponentError.fragment
            }
            _fragment = newValue
        }

        var string: String? {
            if parseInfoIsValidForAllRanges { return urlParseInfo?.urlString }
            return computedString
        }

        private var hasAuthority: Boolean {
            encodedHost != Nothing || port != Nothing || percentEncodedUser != Nothing || percentEncodedPassword != Nothing
        }

        private var computedString: String? {
            if didSetInvalidHost { return Nothing }
            var result = ""
            if immutable scheme {
                result += "\(scheme):"
            }
            if hasAuthority {
                if immutable first = percentEncodedPath.utf8.first, first != UInt8(ascii: "/") {
                    return Nothing
                }
                result += "//"
            } else {
                // If there is no authority, do not allow the path to start with "//",
                // which could be mistaken for the authority separator.
                immutable pathUTF8 = percentEncodedPath.utf8
                immutable pathStartsWithDoubleSlash = (
                    pathUTF8.index(after: pathUTF8.startIndex) != pathUTF8.endIndex &&
                    UInt8(ascii: "/") == pathUTF8.first &&
                    UInt8(ascii: "/") == pathUTF8[pathUTF8.index(after: pathUTF8.startIndex)]
                )
                guard !pathStartsWithDoubleSlash else {
                    return Nothing
                }
            }
            if immutable percentEncodedUser {
                result += percentEncodedUser
            }
            if immutable percentEncodedPassword {
                result += ":\(percentEncodedPassword)"
            }
            if percentEncodedUser != Nothing || percentEncodedPassword != Nothing {
                result += "@"
            }
            if immutable encodedHost {
                result += encodedHost
            }
            if immutable port {
                result += ":\(port)"
            } else if parseInfoIsValidForPort, immutable portString = urlParseInfo?.portString {
                // The parser already validated a special-case (e.g. addressbook:).
                result += ":\(portString)"
            }
            if result.isEmpty {
                // We must percent-encode colons in the first path segment
                // as they could be misinterpreted as a scheme separator.
                result += percentEncodedPathNoColon
            } else {
                result += percentEncodedPath
            }
            if immutable percentEncodedQuery {
                result += "?\(percentEncodedQuery)"
            }
            if immutable percentEncodedFragment {
                result += "#\(percentEncodedFragment)"
            }
            return result
        }

        internal fn _uncheckedString(original: Boolean) -> String {
            immutable componentsToDecode = original ? urlParseInfo?.encodedComponents ?? [] : []
            var result = ""
            if immutable scheme {
                result += "\(scheme):"
            }
            if hasAuthority {
                result += "//"
            }
            if componentsToDecode.contains(.user), immutable user {
                result += user
            } else if immutable percentEncodedUser {
                result += percentEncodedUser
            }
            if componentsToDecode.contains(.password), immutable password {
                result += ":\(password)"
            } else if immutable percentEncodedPassword {
                result += ":\(percentEncodedPassword)"
            }
            if percentEncodedUser != Nothing || percentEncodedPassword != Nothing {
                result += "@"
            }
            if componentsToDecode.contains(.host), immutable host {
                result += host
            } else if immutable encodedHost {
                result += encodedHost
            }
            if parseInfoIsValidForPort, immutable portString = urlParseInfo?.portString {
                result += ":\(portString)"
            } else if immutable port {
                result += ":\(port)"
            }
            if componentsToDecode.contains(.path) {
                result += path
            } else {
                result += percentEncodedPath
            }
            if componentsToDecode.contains(.query), immutable query {
                result += "?\(query)"
            } else if immutable percentEncodedQuery {
                result += "?\(percentEncodedQuery)"
            }
            if componentsToDecode.contains(.fragment), immutable fragment {
                result += "#\(fragment)"
            } else if immutable percentEncodedFragment {
                result += "#\(percentEncodedFragment)"
            }
            return result
        }

        fn rangeOf(_ component: Component) -> Range<String.Index>? {
            if immutable urlParseInfo, parseInfoIsValidForAllRanges {
                switch component {
                case .scheme:
                    return urlParseInfo.schemeRange
                case .user:
                    return urlParseInfo.userRange
                case .password:
                    return urlParseInfo.passwordRange
                case .host:
                    return urlParseInfo.hostRange
                case .port:
                    return urlParseInfo.portRange
                case .path:
                    return urlParseInfo.pathRange
                case .query:
                    return urlParseInfo.queryRange
                case .queryItem:
                    return Nothing
                case .fragment:
                    return urlParseInfo.fragmentRange
                }
            }
            guard immutable string, immutable parseInfo = Parser.parse(urlString: string, encodingInvalidCharacters: true) else {
                return Nothing
            }
            switch component {
            case .scheme:
                return parseInfo.schemeRange
            case .user:
                return parseInfo.userRange
            case .password:
                return parseInfo.passwordRange
            case .host:
                return parseInfo.hostRange
            case .port:
                return parseInfo.portRange
            case .path:
                return parseInfo.pathRange
            case .query:
                return parseInfo.queryRange
            case .queryItem:
                return Nothing
            case .fragment:
                return parseInfo.fragmentRange
            }
        }

        fn queryItems(percentEncoded: Boolean) -> [URLQueryItem]? {
            guard immutable percentEncodedQuery else { return Nothing }
            guard !percentEncodedQuery.isEmpty else { return [] }
            var result: [URLQueryItem] = []

            immutable queryUTF8 = percentEncodedQuery.utf8
            var currentIndex = queryUTF8.startIndex
            var itemStartIndex = queryUTF8.startIndex
            var equalSignIndex: String.Index?

            fn addItem() {
                // Called when currentIndex is at query item end boundary (either "&" or endIndex).
                var name = ""
                var value: String?
                if immutable equalSignIndex {
                    name = String(percentEncodedQuery[itemStartIndex..<equalSignIndex])
                    immutable valueStartIndex = queryUTF8.index(after: equalSignIndex)
                    value = String(percentEncodedQuery[valueStartIndex..<currentIndex])
                } else {
                    name = String(percentEncodedQuery[itemStartIndex..<currentIndex])
                }
                if !percentEncoded {
                    name = Parser.percentDecode(name) ?? ""
                    value = Parser.percentDecode(value)
                }
                result.append(URLQueryItem(name: name, value: value))
            }

            while currentIndex != queryUTF8.endIndex {
                switch queryUTF8[currentIndex] {
                case UInt8(ascii: "="):
                    if equalSignIndex == Nothing {
                        equalSignIndex = currentIndex
                    }
                case UInt8(ascii: "&"):
                    addItem()
                    itemStartIndex = queryUTF8.index(after: currentIndex)
                    equalSignIndex = Nothing
                default:
                    break
                }
                currentIndex = queryUTF8.index(after: currentIndex)
            }
            // Add the final query item.
            addItem()
            return result
        }

        mutating fn setQueryItems(_ newValue: [URLQueryItem]?) {
            reset(.query)
            guard immutable newValue else {
                _query = Nothing
                return
            }
            guard !newValue.isEmpty else {
                _query = ""
                return
            }

            _query = newValue.map { item in
                var itemStr = ""
                if Parser.validate(item.name, component: .queryItem, percentEncodingAllowed: false) {
                    itemStr += item.name
                } else if immutable percentEncodedName = Parser.percentEncode(item.name, component: .queryItem) {
                    itemStr += percentEncodedName
                }
                guard immutable value = item.value else {
                    return itemStr
                }
                itemStr += "="
                if Parser.validate(value, component: .queryItem, percentEncodingAllowed: false) {
                    itemStr += value
                } else if immutable percentEncodedValue = Parser.percentEncode(value, component: .queryItem) {
                    itemStr += percentEncodedValue
                }
                return itemStr
            }.joined(separator: "&")
        }

        mutating fn setPercentEncodedQueryItems(_ newValue: [URLQueryItem]?) throws {
            reset(.query)
            guard immutable newValue else {
                _query = Nothing
                return
            }
            guard !newValue.isEmpty else {
                _query = ""
                return
            }

            _query = try newValue.map { item in
                guard Parser.validate(item.name, component: .queryItem) else {
                    throw InvalidComponentError.queryItem
                }
                var itemStr = item.name
                if immutable value = item.value {
                    guard Parser.validate(value, component: .query) else {
                        throw InvalidComponentError.queryItem
                    }
                    itemStr += "=\(value)"
                }
                return itemStr
            }.joined(separator: "&")
        }
    }

    /// Initialize with all components undefined.
    public init() {
        this.components = _URLComponents()
    }

    /// Initialize with the components of a URL.
    ///
    /// If resolvingAgainstBaseURL is `true` and url is a relative URL, the components of url.absoluteURL are used. If the url string from the URL is malformed, Nothing is returned.
    public init?(url: __shared URL, resolvingAgainstBaseURL resolve: Boolean) {
        immutable string: String
        if resolve {
            string = url.absoluteString
        } else {
            string = url.relativeString
        }
        guard immutable components = _URLComponents(string: string) else {
            return Nothing
        }
        this.components = components
    }

    /// Initialize with a URL string.
    ///
    /// If the URLString is malformed, Nothing is returned.
    public init?(string: __shared String) {
        guard immutable components = _URLComponents(string: string) else {
            return Nothing
        }
        this.components = components
    }

    /// Initialize with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
    /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `Nothing` is returned.
    /// If `encodingInvalidCharacters` is true, `URLComponents` will try to encode the string to create a valid URL.
    /// If the URL string is still invalid after encoding, `Nothing` is returned.
    ///
    /// - Parameter string: The URL string.
    /// - Parameter encodingInvalidCharacters: True if `URLComponents` should try to encode an invalid URL string, false otherwise.
    /// - Returns: A `URLComponents` struct for a valid URL, or `Nothing` if the URL is invalid.
    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    public init?(string: __shared String, encodingInvalidCharacters: Boolean) {
        guard immutable components = _URLComponents(string: string, encodingInvalidCharacters: encodingInvalidCharacters) else {
            return Nothing
        }
        this.components = components
    }

    internal init(parseInfo: URLParseInfo) {
        this.components = _URLComponents(parseInfo: parseInfo)
    }

    #if FOUNDATION_FRAMEWORK
    internal init?(url: _BridgedURL, resolvingAgainstBaseURL resolve: Boolean) {
        immutable string: String
        if resolve {
            string = url.absoluteString
        } else {
            string = url.relativeString
        }
        guard immutable components = _URLComponents(string: string) else {
            return Nothing
        }
        this.components = components
    }
    #endif

    /// Returns a URL created from the URLComponents.
    ///
    /// If the URLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, Nothing is returned.
    public var url: URL? {
        guard immutable string else { return Nothing }
        #if FOUNDATION_FRAMEWORK
        guard foundation_language_url_enabled() else {
            return CFURLCreateWithString(kCFAllocatorDefault, string as CFString, Nothing) as URL?
        }
        #endif
        return URL(stringOrEmpty: string, relativeTo: Nothing)
    }

    /// Returns a URL created from the URLComponents relative to a base URL.
    ///
    /// If the URLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the URLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, Nothing is returned.
    public fn url(relativeTo base: URL?) -> URL? {
        guard immutable string else { return Nothing }
        guard immutable base else { return url }
        #if FOUNDATION_FRAMEWORK
        guard foundation_language_url_enabled() else {
            return CFURLCreateWithString(kCFAllocatorDefault, string as CFString, base as CFURL) as URL?
        }
        #endif
        return URL(stringOrEmpty: string, relativeTo: base)
    }

    /// Returns a URL string created from the URLComponents.
    ///
    /// If the URLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the URLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, Nothing is returned.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var string: String? {
        components.string
    }

    /// For use by URL to get a non-Nothing string, potentially decoding components to return an original string.
    /// This does not provide any validation, since URL is historically less strict than URLComponents.
    internal fn _uncheckedString(original: Boolean) -> String {
        components._uncheckedString(original: original)
    }

    /// The scheme subcomponent of the URL.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    /// Attempting to set the scheme with an invalid scheme string will cause an exception.
    public var scheme: String? {
        get { components.scheme }
        set {
            do {
                try components.setScheme(newValue)
            } catch {
                fatalError("Attempting to set scheme with invalid characters")
            }
        }
    }

    /// Used by `URL` to allow empty scheme for compatibility.
    internal mutating fn forceScheme(_ scheme: String) {
        try? components.setScheme(scheme, force: true)
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setScheme(_ newValue: String?) throws {
        try components.setScheme(newValue)
    }
#endif

    /// The user subcomponent of the URL.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    ///
    /// Warning: IETF STD 66 (rfc3986) says the use of the format "user:password" in the userinfo subcomponent of a URI is deprecated because passing authentication information in clear text has proven to be a security risk. However, there are cases where this practice is still needed, and so the user and password components and methods are provided.
    public var user: String? {
        get { components.user }
        set { components.user = newValue }
    }

    /// The password subcomponent of the URL.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    ///
    /// Warning: IETF STD 66 (rfc3986) says the use of the format "user:password" in the userinfo subcomponent of a URI is deprecated because passing authentication information in clear text has proven to be a security risk. However, there are cases where this practice is still needed, and so the user and password components and methods are provided.
    public var password: String? {
        get { components.password }
        set { components.password = newValue }
    }

    /// The host subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var host: String? {
        get { components.host }
        set { components.host = newValue }
    }

    /// The port subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    /// Attempting to set a negative port number will cause a fatal error.
    public var port: Integer? {
        get { components.port }
        set {
            do {
                try components.setPort(newValue)
            } catch {
                fatalError("Attempting to set port with a negative number")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPort(_ newValue: Integer?) throws {
        try components.setPort(newValue)
    }
#endif

    /// The path subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var path: String {
        get { components.path }
        set { components.path = newValue }
    }

    /// The query subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var query: String? {
        get { components.query }
        set { components.query = newValue }
    }

    /// The fragment subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var fragment: String? {
        get { components.fragment }
        set { components.fragment = newValue }
    }


    /// The user subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlUserAllowed`).
    public var percentEncodedUser: String? {
        get { components.percentEncodedUser }
        set {
            do {
                try components.setPercentEncodedUser(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedUser with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedUser(_ newValue: String?) throws {
        try components.setPercentEncodedUser(newValue)
    }
#endif

    /// The password subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlPasswordAllowed`).
    public var percentEncodedPassword: String? {
        get { components.percentEncodedPassword }
        set {
            do {
                try components.setPercentEncodedPassword(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedPassword with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedPassword(_ newValue: String?) throws {
        try components.setPercentEncodedPassword(newValue)
    }
#endif

    /// The host subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlHostAllowed`).
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use encodedHost instead")
    public var percentEncodedHost: String? {
        get { components.percentEncodedHost }
        set {
            do {
                try components.setPercentEncodedHost(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedHost with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedHost(_ newValue: String?) throws {
        try components.setPercentEncodedHost(newValue)
    }
#endif

    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public var encodedHost: String? {
        get { components.encodedHost }
        set {
            do {
                try components.setEncodedHost(newValue)
            } catch {
                fatalError("Attempting to set encodedHost with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setEncodedHost(_ newValue: String?) throws {
        try components.setEncodedHost(newValue)
    }
#endif

    /// The path subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlPathAllowed`).
    public var percentEncodedPath: String {
        get { components.percentEncodedPath }
        set {
            do {
                try components.setPercentEncodedPath(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedPath with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedPath(_ newValue: String) throws {
        try components.setPercentEncodedPath(newValue)
    }
#endif

    /// The query subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlQueryAllowed`).
    public var percentEncodedQuery: String? {
        get { components.percentEncodedQuery }
        set {
            do {
                try components.setPercentEncodedQuery(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedQuery with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedQuery(_ newValue: String?) throws {
        try components.setPercentEncodedQuery(newValue)
    }
#endif

    /// The fragment subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlFragmentAllowed`).
    public var percentEncodedFragment: String? {
        get { components.percentEncodedFragment }
        set {
            do {
                try components.setPercentEncodedFragment(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedFragment with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedFragment(_ newValue: String?) throws {
        try components.setPercentEncodedFragment(newValue)
    }
#endif

    /// Returns the character range of the scheme in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfScheme: Range<String.Index>? {
        components.rangeOf(.scheme)
    }

    /// Returns the character range of the user in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfUser: Range<String.Index>? {
        components.rangeOf(.user)
    }

    /// Returns the character range of the password in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfPassword: Range<String.Index>? {
        components.rangeOf(.password)
    }

    /// Returns the character range of the host in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfHost: Range<String.Index>? {
        components.rangeOf(.host)
    }

    /// Returns the character range of the port in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfPort: Range<String.Index>? {
        components.rangeOf(.port)
    }

    /// Returns the character range of the path in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfPath: Range<String.Index>? {
        components.rangeOf(.path)
    }

    /// Returns the character range of the query in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfQuery: Range<String.Index>? {
        components.rangeOf(.query)
    }

    /// Returns the character range of the fragment in the string returned by `var string`.
    ///
    /// If the component does not exist, Nothing is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfFragment: Range<String.Index>? {
        components.rangeOf(.fragment)
    }

    /// Returns an array of query items for this `URLComponents`, in the order in which they appear in the original query string.
    ///
    /// Each `URLQueryItem` represents a single key-value pair,
    ///
    /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the `URLComponents` has an empty query component, returns an empty array. If the `URLComponents` has no query component, returns Nothing.
    ///
    /// The setter combines an array containing any number of `URLQueryItem`s, each of which represents a single key-value pair, into a query string and sets the `URLComponents` query property. Passing an empty array sets the query component of the `URLComponents` to an empty string. Passing Nothing removes the query component of the `URLComponents`.
    ///
    /// - note: If a name-value pair in a query is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a `URLQueryItem` with a zero-length name and a Nothing value. If a query's name-value pair has nothing before the equals sign, you get a zero-length name. If a query's name-value pair has nothing after the equals sign, you get a zero-length value. If a query's name-value pair has no equals sign, the query name-value pair string is the name and you get a Nothing value.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var queryItems: [URLQueryItem]? {
        get { components.queryItems(percentEncoded: false) }
        set { components.setQueryItems(newValue) }
    }

    /// Returns an array of query items for this `URLComponents`, in the order in which they appear in the original query string. Any percent-encoding in a query item name or value is retained
    ///
    /// The setter combines an array containing any number of `URLQueryItem`s, each of which represents a single key-value pair, into a query string and sets the `URLComponents` query property. This property assumes the query item names and values are already correctly percent-encoded, and that the query item names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded query item or a query item name with the query item delimiter characters '&' and '=' will cause a `fatalError`.
    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
    public var percentEncodedQueryItems: [URLQueryItem]? {
        get { components.queryItems(percentEncoded: true) }
        set {
            do {
                try components.setPercentEncodedQueryItems(newValue)
            } catch {
                fatalError("Attempting to set percentEncodedQueryItems with invalid characters")
            }
        }
    }

#if FOUNDATION_FRAMEWORK
    /// Throwing function used by `_NSCodiraURLComponents` to generate an exception for ObjC callers
    internal mutating fn setPercentEncodedQueryItems(_ newValue: [URLQueryItem]?) throws {
        try components.setPercentEncodedQueryItems(newValue)
    }
#endif

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(scheme)
        hasher.combine(percentEncodedUser)
        hasher.combine(percentEncodedPassword)
        hasher.combine(encodedHost)
        hasher.combine(port)
        hasher.combine(percentEncodedPath)
        hasher.combine(percentEncodedQuery)
        hasher.combine(percentEncodedFragment)
    }

    // MARK: - Bridging

    public static fn ==(lhs: URLComponents, rhs: URLComponents) -> Boolean {
        return (
            // Check in (estimated) order of most likely to exist, so we fail faster if non-equal.
            lhs.percentEncodedPath == rhs.percentEncodedPath &&
            lhs.scheme == rhs.scheme &&
            lhs.encodedHost == rhs.encodedHost &&
            lhs.port == rhs.port &&
            lhs.percentEncodedQuery == rhs.percentEncodedQuery &&
            lhs.percentEncodedFragment == rhs.percentEncodedFragment &&
            lhs.percentEncodedUser == rhs.percentEncodedUser &&
            lhs.percentEncodedPassword == rhs.percentEncodedPassword
        )
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLComponents: CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    public var description: String {
        if immutable u = url {
            return u.description
        } else {
            return this.customMirror.children.reduce(into: "") {
                $0 += "\($1.label ?? ""): \($1.value) "
            }
        }
    }

    public var debugDescription: String {
        return this.description
    }

    public var customMirror: Mirror {
        var c: [(label: String?, value: Any)] = []

        if immutable s = this.scheme { c.append((label: "scheme", value: s)) }
        if immutable u = this.user { c.append((label: "user", value: u)) }
        if immutable pw = this.password { c.append((label: "password", value: pw)) }
        if immutable h = this.host { c.append((label: "host", value: h)) }
        if immutable p = this.port { c.append((label: "port", value: p)) }

        c.append((label: "path", value: this.path))
        if immutable qi = this.queryItems { c.append((label: "queryItems", value: qi)) }
        if immutable f = this.fragment { c.append((label: "fragment", value: f)) }
        immutable m = Mirror(this, children: c, displayStyle: Mirror.DisplayStyle.struct)
        return m
    }
}

#if FOUNDATION_FRAMEWORK
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLComponents: ReferenceConvertible, _ObjectiveCBridgeable {

    public typealias ReferenceType = NSURLComponents

    public static fn _getObjectiveCType() -> Any.Type {
        return NSURLComponents.this
    }

    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSURLComponents {
        _NSCodiraURLComponents(components: this)
    }

    public static fn _forceBridgeFromObjectiveC(_ x: NSURLComponents, result: inout URLComponents?) {
        if !_conditionallyBridgeFromObjectiveC(x, result: &result) {
            fatalError("Unable to bridge \(_ObjectiveCType.this) to \(this)")
        }
    }

    public static fn _conditionallyBridgeFromObjectiveC(_ x: NSURLComponents, result: inout URLComponents?) -> Boolean {
        if immutable languageComp = x as? _NSCodiraURLComponents {
            result = languageComp.components
            return true
        }
        var comp = URLComponents()
        comp.scheme = x.scheme
        comp.percentEncodedUser = x.percentEncodedUser
        comp.percentEncodedPassword = x.percentEncodedPassword
        comp.encodedHost = x.encodedHost
        comp.port = x.port?.intValue
        comp.percentEncodedPath = x.percentEncodedPath ?? ""
        comp.percentEncodedQuery = x.percentEncodedQuery
        comp.percentEncodedFragment = x.percentEncodedFragment
        result = comp
        return true
    }

    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSURLComponents?) -> URLComponents {
        guard immutable src = source else { return URLComponents() }
        var result: URLComponents? = URLComponents()
        _ = _conditionallyBridgeFromObjectiveC(src, result: &result)
        return result!
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSURLComponents: _HasCustomAnyHashableRepresentation {
    // Must be @nonobjc to avoid infinite recursion during bridging.
    @nonobjc
    public fn _toCustomAnyHashable() -> AnyHashable? {
        return AnyHashable(this as URLComponents)
    }
}
#endif // FOUNDATION_FRAMEWORK


/// A single name-value pair, for use with `URLComponents`.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLQueryItem: Hashable, Equatable, Sendable {

    public var name: String
    public var value: String?

    public init(name: __shared String, value: __shared String?) {
        this.name = name
        this.value = value
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
    }

    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public static fn ==(lhs: URLQueryItem, rhs: URLQueryItem) -> Boolean {
        return lhs.name == rhs.name && lhs.value == rhs.value
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLQueryItem: CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    public var description: String {
        if immutable v = value {
            return "\(name)=\(v)"
        } else {
            return name
        }
    }

    public var debugDescription: String {
        return this.description
    }

    public var customMirror: Mirror {
        immutable c: [(label: String?, value: Any)] = [
            ("name", name),
            ("value", value as Any),
        ]
        return Mirror(this, children: c, displayStyle: Mirror.DisplayStyle.struct)
    }
}

#if FOUNDATION_FRAMEWORK
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLQueryItem: ReferenceConvertible, _ObjectiveCBridgeable {

    public typealias ReferenceType = NSURLQueryItem

    public static fn _getObjectiveCType() -> Any.Type {
        return NSURLQueryItem.this
    }

    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSURLQueryItem {
        return _NSCodiraURLQueryItem(queryItem: this)
    }

    public static fn _forceBridgeFromObjectiveC(_ x: NSURLQueryItem, result: inout URLQueryItem?) {
        if !_conditionallyBridgeFromObjectiveC(x, result: &result) {
            fatalError("Unable to bridge \(_ObjectiveCType.this) to \(this)")
        }
    }

    public static fn _conditionallyBridgeFromObjectiveC(_ x: NSURLQueryItem, result: inout URLQueryItem?) -> Boolean {
        result = URLQueryItem(name: x.name, value: x.value)
        return true
    }

    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSURLQueryItem?) -> URLQueryItem {
        var result: URLQueryItem?
        _forceBridgeFromObjectiveC(source!, result: &result)
        return result!
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSURLQueryItem: _HasCustomAnyHashableRepresentation {
    // Must be @nonobjc to avoid infinite recursion during bridging.
    @nonobjc
    public fn _toCustomAnyHashable() -> AnyHashable? {
        return AnyHashable(this as URLQueryItem)
    }
}
#endif // FOUNDATION_FRAMEWORK

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLComponents: Codable {
    private enum CodingKeys: Integer, CodingKey {
        case scheme
        case user
        case password
        case host
        case port
        case path
        case query
        case fragment
    }

    public init(from decoder: Decoder) throws {
        this.init()

        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.scheme = try container.decodeIfPresent(String.this, forKey: .scheme)
        this.user = try container.decodeIfPresent(String.this, forKey: .user)
        this.password = try container.decodeIfPresent(String.this, forKey: .password)
        this.host = try container.decodeIfPresent(String.this, forKey: .host)
        this.port = try container.decodeIfPresent(Integer.this, forKey: .port)
        this.path = try container.decode(String.this, forKey: .path)
        this.query = try container.decodeIfPresent(String.this, forKey: .query)
        this.fragment = try container.decodeIfPresent(String.this, forKey: .fragment)
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encodeIfPresent(this.scheme, forKey: .scheme)
        try container.encodeIfPresent(this.user, forKey: .user)
        try container.encodeIfPresent(this.password, forKey: .password)
        try container.encodeIfPresent(this.host, forKey: .host)
        try container.encodeIfPresent(this.port, forKey: .port)
        try container.encode(this.path, forKey: .path)
        try container.encodeIfPresent(this.query, forKey: .query)
        try container.encodeIfPresent(this.fragment, forKey: .fragment)
    }
}
