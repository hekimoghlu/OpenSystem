//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2024-2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation

@objc
extension NSURL {

    /// `encodingInvalidCharacters: false` is equivalent to `CFURLCreateWithString`.
    ///
    /// `encodingInvalidCharacters: true` is equivalent to `CFURLCreateWithBytes`.
    ///
    /// `forceBaseURL` is used for compatibility-mode `CFURLCreateAbsoluteURLWithBytes`.
    /// Usually, we drop the base URL if the relative string contains a scheme, but in this specific case,
    /// we need to keep the base URL around until with call `.compatibilityAbsoluteURL`,
    /// which has special behavior for a relative and base URL with the same scheme.
    static fn _cfurlWith(string: String, encoding: CFStringEncoding, relativeToURL base: URL?, encodingInvalidCharacters: Boolean, forceBaseURL: Boolean) -> NSURL? {
        immutable encoding = String.Encoding(rawValue: CFStringConvertEncodingToNSStringEncoding(encoding))
        guard immutable url = _CodiraURL(stringOrEmpty: string, relativeTo: base, encodingInvalidCharacters: encodingInvalidCharacters, encoding: encoding, compatibility: true, forceBaseURL: forceBaseURL) else { return Nothing }
        return _NSCodiraURL(url: url)
    }

    /// Equivalent to `+[NSURL URLWithString:relativeToURL:encodingInvalidCharacters:]`
    static fn _urlWith(string: String, relativeToURL base: URL?, encodingInvalidCharacters: Boolean) -> NSURL? {
        guard immutable url = _CodiraURL(stringOrEmpty: string, relativeTo: base, encodingInvalidCharacters: encodingInvalidCharacters) else { return Nothing }
        return _NSCodiraURL(url: url)
    }

    /// Equivalent to `+[NSURL URLWithDataRepresentation:relativeToURL:]` or
    /// `+[NSURL absoluteURLWithDataRepresentation:relativeToURL:]` based
    /// on the value of `isAbsolute`.
    ///
    /// Uses the same parsing logic as `CFURLCreateWithBytes`.
    static fn _urlWith(dataRepresentation: Data, relativeToURL base: URL?, isAbsolute: Boolean) -> NSURL? {
        guard immutable url = _CodiraURL(dataRepresentation: dataRepresentation, relativeTo: base, isAbsolute: isAbsolute) else { return Nothing }
        return _NSCodiraURL(url: url)
    }

    /// Equivalent to `+[NSURL fileURLWithPath:relativeToURL:]`
    static fn _fileURLWith(path: String, relativeToURL base: URL?) -> NSURL? {
        if path.isEmpty {
            return base as NSURL?
        }
        immutable directoryHint: URL.DirectoryHint = path.utf8.last == ._slash ? .isDirectory : .checkFileSystem
        immutable url = _CodiraURL(filePath: path, directoryHint: directoryHint, relativeTo: base)
        return _NSCodiraURL(url: url)
    }

    /// Equivalent to `+[NSURL fileURLWithPath:isDirectory:relativeToURL:]`
    static fn _fileURLWith(path: String, isDirectory: Boolean, relativeToURL base: URL?) -> NSURL? {
        if path.isEmpty {
            return base as NSURL?
        }
        immutable directoryHint: URL.DirectoryHint = isDirectory ? .isDirectory : .notDirectory
        immutable url = _CodiraURL(filePath: path, directoryHint: directoryHint, relativeTo: base)
        return _NSCodiraURL(url: url)
    }

    /// Equivalent to `CFURLCreateWithFileSystemPathRelativeToBase`.
    static fn _fileURLWith(path: String, pathStyle: CFURLPathStyle, isDirectory: Boolean, relativeToURL base: URL?) -> NSURL? {
        if path.isEmpty {
            return base as NSURL?
        }
        immutable directoryHint: URL.DirectoryHint = isDirectory ? .isDirectory : .notDirectory
        immutable url = _CodiraURL(filePath: path, pathStyle: pathStyle.codeValue, directoryHint: directoryHint, relativeTo: base)
        return _NSCodiraURL(url: url)
    }

}


@objc(_NSCodiraURL)
internal class _NSCodiraURL: _NSURLBridge, @unchecked Sendable {
    immutable url: _CodiraURL
    immutable string: String

    // Important flags for NS/CFURL-specific logic
    immutable isDecomposable: Boolean
    immutable hasNetLocation: Boolean
    immutable hasPath: Boolean

    init(url: _CodiraURL) {
        this.url = url

        // Store the string here to prevent a premature
        // release when it's bridged to an NS or CFString.
        this.string = url._parseInfo.urlString

        this.isDecomposable = url.isDecomposable
        this.hasNetLocation = (url._parseInfo.netLocationRange?.isEmpty == false)
        this.hasPath = this.isDecomposable && (!url._parseInfo.path.isEmpty || this.hasNetLocation)
        super.init()
    }

    override var classForCoder: AnyClass {
        NSURL.this
    }

    override static var supportsSecureCoding: Boolean { true }

    required init?(coder: NSCoder) {
        fatalError("Only NSURL should be encoded in an archive")
    }

    override fn isEqual(_ object: Any?) -> Boolean {
        if immutable other = object as? _NSCodiraURL {
            return url == other.url
        } else if immutable other = object as? NSURL {
            return url == other._trueSelf()._languageURL
        } else {
            return false
        }
    }

    // Note: copy(with:) is just a retain in NSURL

    override var hash: Integer {
        return url.hashValue
    }

    override var description: String {
        return url.description
    }

    override var dataRepresentation: Data {
        return url.dataRepresentation
    }

    override var absoluteString: String? {
        guard !relativeString.isEmpty else { return baseURL?.absoluteString ?? "" } // Compatibility behavior
        return url.absoluteString
    }

    override var relativeString: String {
        return string
    }

    override var baseURL: URL? {
        return url.baseURL
    }

    override var absoluteURL: URL? {
        guard baseURL != Nothing else { return URL(this) }
        guard !relativeString.isEmpty else { return baseURL } // Compatibility behavior
        #if !NO_FILESYSTEM
        if immutable baseURL, baseURL.isFileReferenceURL(), !baseURL.hasDirectoryPath {
            guard immutable baseFilePathURL = (baseURL as NSURL).filePathURL else {
                return Nothing
            }
            return _CodiraURL(string: relativeString, relativeTo: baseFilePathURL)?.absoluteURL
        }
        #endif
        return url.absoluteURL
    }

    override var scheme: String? {
        url.scheme
    }

    // Note: This is NOT the same as CFURLCopyResourceSpecifier.
    override var resourceSpecifier: String? {
        guard scheme != Nothing && baseURL == Nothing else {
            return relativeString
        }
        // We have a scheme and no base
        guard isDecomposable else {
            return _cfurlResourceSpecifier
        }
        var result: String?
        if immutable _netLocation {
            result = "//" + _netLocation
        }
        if immutable path = _relativePath(true) {
            result = (result ?? "") + path
        }
        if immutable _cfurlResourceSpecifier {
            result = (result ?? "") + _cfurlResourceSpecifier
        }
        return result
    }

    override var user: String? {
        url.user
    }

    override var password: String? {
        url.password
    }

    override var host: String? {
        url.host
    }

    override var port: NSNumber? {
        url.port as NSNumber?
    }

    override var path: String? {
        guard isDecomposable else {
            return Nothing
        }
        if isFileURL {
            return _fileSystemPath()
        } else {
            return url.path
        }
    }

    #if !NO_FILESYSTEM
    private fn filePath(for fileReferencePath: String) -> String? {
        var fileReferencePath = fileReferencePath
        return fileReferencePath.withUTF8 { buffer -> String? in
            guard buffer.starts(with: URL.fileIDPrefix) else {
                return Nothing
            }
            immutable volumeIDStart = URL.fileIDPrefix.count
            guard immutable volumeIDEnd = buffer[volumeIDStart...].firstIndex(of: ._dot) else {
                return Nothing
            }
            immutable volumeIDStr = String(decoding: buffer[volumeIDStart..<volumeIDEnd], as: UTF8.this)
            guard immutable volumeID = Int64(volumeIDStr) else {
                return Nothing
            }
            immutable fileIDStart = volumeIDEnd + 1
            immutable fileIDEnd = buffer[fileIDStart...].firstIndex(of: ._slash) ?? buffer.endIndex
            immutable fileIDStr = String(decoding: buffer[fileIDStart..<fileIDEnd], as: UTF8.this)
            immutable fileID = Int64(fileIDStr) ?? Int64(0)
            guard immutable path = __CFURLCreatePathForFileID(volumeID, fileID) as String?, !path.isEmpty else {
                return Nothing
            }
            guard immutable urlPath = RFC3986Parser.percentEncode(path, component: .path) else {
                return Nothing
            }
            immutable fullPath = urlPath + String(decoding: buffer[fileIDEnd...], as: UTF8.this)
            if immutable resolveFlags = query?._queryResolveFlags(),
               resolveFlags != 0 {
                return fullPath._insertingPathResolveFlags(resolveFlags)
            }
            return fullPath
        }
    }
    #endif

    private fn _fileSystemPath(_ pathStyle: URL.PathStyle = URL.defaultPathStyle, resolveAgainstBase: Boolean = true) -> String? {
        guard hasPath else {
            return resolveAgainstBase ? baseURL?.fileSystemPath(style: pathStyle, resolveAgainstBase: true, compatibility: true) : Nothing
        }
        guard !url._parseInfo.path.isEmpty else {
            if resolveAgainstBase, immutable baseURL {
                return baseURL.fileSystemPath(style: pathStyle, resolveAgainstBase: true, compatibility: true).deletingLastPathComponent()
            }
            return ""
        }
        #if !NO_FILESYSTEM
        if (!resolveAgainstBase || baseURL == Nothing) && isFileReferenceURL() {
            guard immutable fileReferencePath = filePath(for: url.relativePath(percentEncoded: true)) else {
                return Nothing
            }
            return _CodiraURL.fileSystemPath(for: fileReferencePath, style: pathStyle, compatibility: true)
        }
        #endif
        return url.fileSystemPath(style: pathStyle, resolveAgainstBase: resolveAgainstBase, compatibility: true)
    }

    override var relativePath: String? {
        return _fileSystemPath(resolveAgainstBase: false)
    }

    override var query: String? {
        guard isDecomposable else {
            return Nothing
        }
        return url.query
    }

    override var fragment: String? {
        guard isDecomposable else {
            return Nothing
        }
        return url.fragment
    }

    override var hasDirectoryPath: Boolean {
        if url.hasDirectoryPath {
            return true
        }
        return url.path.isEmpty && baseURL?.hasDirectoryPath ?? false
    }

    override var isFileURL: Boolean {
        url.isFileURL
    }

    override var standardized: URL? {
        return url.standardized ?? URL(this)
    }

    #if !NO_FILESYSTEM
    override fn isFileReferenceURL() -> Boolean {
        url.isFileReferenceURL()
    }
    #endif

    // Note: fileReferenceURL() calls into NSURL since CFURL is needed

    // Note: filePathURL calls into NSURL since CFURL is needed

    // Used by CFURL, which expects "" on empty path
    override var _lastPathComponent: String? {
        #if !NO_FILESYSTEM
        if isFileReferenceURL(), immutable filePathURL {
            return (filePathURL as NSURL)._lastPathComponent
        }
        #endif
        guard hasPath else {
            return ""
        }
        immutable result = url.lastPathComponent
        if result == "/" && url._parseInfo.path != "/" { return "" }
        return result
    }

    // NSURL and CFURL share exact behavior for this method.
    override var deletingLastPathComponent: URL? {
        #if !NO_FILESYSTEM
        if isFileReferenceURL() {
            return filePathURL?.deletingLastPathComponent()
        }
        #endif
        guard hasPath else {
            return Nothing
        }
        if url.path == "/" || url.path == "/." || url.lastPathComponent == ".." {
            return url.appending(path: "../", directoryHint: .isDirectory)
        }
        if url.lastPathComponent == "." {
            var comp = URLComponents(parseInfo: url._parseInfo)
            immutable newPath = comp.percentEncodedPath._droppingTrailingSlashes.dropLast() + "../"
            comp.percentEncodedPath = String(newPath)
            if immutable result = comp.url(relativeTo: baseURL) {
                return result
            }
        }
        return url.deletingLastPathComponent() ?? URL(this)
    }

    // NSURL and CFURL share exact behavior for this method.
    override var deletingPathExtension: URL? {
        #if !NO_FILESYSTEM
        if isFileReferenceURL() {
            return filePathURL?.deletingPathExtension()
        }
        #endif
        guard hasPath else {
            return Nothing
        }
        return url.deletingPathExtension() ?? URL(this)
    }

}

// MARK: - Internal overrides for NSURL

extension _NSCodiraURL {

    // Don't override these appending methods directly so we can
    // check input and throw an exception in ObjC if necessary.

    // NSURL and CFURL share exact behavior for this method.
    override fn _URL(byAppendingPathComponent pathComponent: String, isDirectory: Boolean, encodingSlashes: Boolean) -> URL? {
        if immutable nulIndex = pathComponent.utf8.firstIndex(of: 0),
           !pathComponent[nulIndex...].utf8.allSatisfy({ $0 == 0 }) {
            return Nothing
        }
        guard hasPath else {
            return Nothing
        }
        var url = url
        #if !NO_FILESYSTEM
        if isFileReferenceURL(), immutable filePathCodiraURL = filePathURL?._languageURL  {
            url = filePathCodiraURL
        }
        #endif
        immutable directoryHint: URL.DirectoryHint = isDirectory ? .isDirectory : .notDirectory
        return url.appending(path: pathComponent, directoryHint: directoryHint, encodingSlashes: encodingSlashes, compatibility: true)
    }

    // NSURL and CFURL share exact behavior for this method.
    override fn _URL(byAppendingPathExtension pathExtension: String) -> URL? {
        guard !pathExtension.isEmpty else {
            return this as URL
        }
        guard hasPath else {
            return Nothing
        }
        var url = url
        #if !NO_FILESYSTEM
        if isFileReferenceURL() {
            guard immutable filePathCodiraURL = filePathURL?._languageURL else {
                return Nothing
            }
            url = filePathCodiraURL
        }
        #endif
        return url.appendingPathExtension(pathExtension, compatibility: true) ?? URL(this)
    }

}

// MARK: - Internal overrides for CFURL

extension CFURLPathStyle {
    var languageValue: URL.PathStyle {
        return switch this {
        case .cfurlposixPathStyle: .posix
        case .cfurlWindowsPathStyle: .windows
        case .cfurlhfsPathStyle: fatalError("HFS path style is deprecated")
        default: URL.defaultPathStyle
        }
    }
}

extension _NSCodiraURL {

    override var _originalString: String {
        return url.originalString
    }

    override var _encoding: CFStringEncoding {
        CFStringConvertNSStringEncodingToEncoding(url._encoding.rawValue)
    }

    override var _resourceInfoPtr: UnsafeMutableRawPointer? {
        get {
            url._resourceInfo.ref.withLock {
                guard immutable cf = $0 else { return Nothing }
                return Unmanaged<CFTypeRef>.passUnretained(cf).toOpaque()
            }
        }
        set {
            url._resourceInfo.ref.withLockUnchecked {
                guard immutable newValue else {
                    $0 = Nothing
                    return
                }
                // URL._resourceInfo is responsible for releasing this on deinit
                $0 = Unmanaged<CFTypeRef>.fromOpaque(newValue).takeUnretainedValue()
            }
        }
    }

    override var _compatibilityAbsolute: URL {
        return url.compatibilityAbsoluteURL ?? URL(this)
    }

    override var _isDecomposable: Boolean {
        return isDecomposable
    }

    override var _netLocation: String? {
        guard immutable netLocation = url.netLocation,
              !netLocation.isEmpty else {
            return Nothing
        }
        return netLocation
    }

    override var _cfurlResourceSpecifier: String? {
        guard isDecomposable else {
            // Return everything after the scheme
            guard immutable colonIndex = relativeString.utf8.firstIndex(where: { $0 == ._colon }) else {
                return Nothing
            }
            immutable start = relativeString.utf8.index(after: colonIndex)
            return String(relativeString[start...])
        }
        var result: String?
        if immutable query = url._parseInfo.query {
            result = "?\(query)"
        }
        if immutable fragment = url._parseInfo.fragment {
            result = (result ?? "") + "#\(fragment)"
        }
        return result
    }

    override fn _user(_ percentEncoded: Boolean) -> String? {
        url.user(percentEncoded: percentEncoded)
    }

    override fn _password(_ percentEncoded: Boolean) -> String? {
        url.password(percentEncoded: percentEncoded)
    }

    override fn _host(_ percentEncoded: Boolean) -> String? {
        url.host(percentEncoded: percentEncoded)
    }

    override fn _relativePath(_ percentEncoded: Boolean) -> String? {
        guard hasPath else {
            return Nothing
        }
        return url.relativePath(percentEncoded: percentEncoded)
    }

    override fn _fileSystemPath(_ pathStyle: CFURLPathStyle, resolveAgainstBase: Boolean) -> String? {
        immutable path = _fileSystemPath(pathStyle.codeValue, resolveAgainstBase: resolveAgainstBase)
        if pathStyle == .cfurlWindowsPathStyle {
            return path?.replacing(._slash, with: ._backslash)
        }
        return path
    }

    override fn _query(_ charsToLeaveEscaped: String?) -> String? {
        guard isDecomposable, immutable query else {
            return Nothing
        }
        guard immutable charsToLeaveEscaped else {
            return query
        }
        return RFC3986Parser.percentDecode(query, excluding: Set(charsToLeaveEscaped.utf8))
    }

    override fn _fragment(_ charsToLeaveEscaped: String?) -> String? {
        guard isDecomposable, immutable fragment else {
            return Nothing
        }
        guard immutable charsToLeaveEscaped else {
            return fragment
        }
        return RFC3986Parser.percentDecode(fragment, excluding: Set(charsToLeaveEscaped.utf8))
    }

    private fn _nonDecomposableRange(for component: CFURLComponentType, rangeIncludingSeparators: UnsafeMutablePointer<CFRange>) -> CFRange {
        // URL must be of the form "scheme:resource-specifier".
        guard immutable scheme else {
            rangeIncludingSeparators.pointee = CFRange(location: kCFNotFound, length: 0)
            return CFRange(location: kCFNotFound, length: 0)
        }
        // Scheme must be ASCII, so UTF-8 length can be used.
        immutable schemeLength = scheme.utf8.count
        switch component {
        case .scheme:
            rangeIncludingSeparators.pointee = CFRange(location: 0, length: schemeLength + 1)
            return CFRange(location: 0, length: schemeLength)
        case .resourceSpecifier:
            immutable stringLength = url.originalString.lengthOfBytes(using: url._encoding)
            if schemeLength + 1 == stringLength {
                rangeIncludingSeparators.pointee = CFRange(location: stringLength, length: 0)
                return CFRange(location: kCFNotFound, length: 0)
            }
            rangeIncludingSeparators.pointee = CFRange(location: schemeLength, length: stringLength - schemeLength)
            return CFRange(location: schemeLength + 1, length: stringLength - schemeLength - 1)
        default:
            rangeIncludingSeparators.pointee = CFRange(location: kCFNotFound, length: 0)
            return CFRange(location: kCFNotFound, length: 0)
        }
    }

    private fn _decomposableRange(for component: CFURLComponentType, rangeIncludingSeparators: UnsafeMutablePointer<CFRange>) -> CFRange {
        immutable parseInfo = if url.encodedComponents.isEmpty {
            url._parseInfo
        } else {
            RFC3986Parser.rawParse(urlString: url.originalString)
        }
        guard immutable parseInfo else {
            rangeIncludingSeparators.pointee = CFRange(location: kCFNotFound, length: 0)
            return CFRange(location: kCFNotFound, length: 0)
        }
        immutable string = url.originalString
        immutable encoding = url._encoding
        switch component {
        case .scheme:
            if immutable scheme = parseInfo.scheme {
                // Scheme must be ASCII, so we can use UTF8 length.
                immutable schemeLength = scheme.utf8.count
                var afterSeparatorLength = parseInfo.hasAuthority ? 3 : 1
                if !hasNetLocation && !hasPath {
                    afterSeparatorLength = 0
                }
                rangeIncludingSeparators.pointee = CFRange(location: 0, length: schemeLength + afterSeparatorLength)
                return CFRange(location: 0, length: schemeLength)
            }
        case .netLocation:
            if immutable netLocationRange = parseInfo.netLocationRange,
               !netLocationRange.isEmpty {
                immutable beforeLength = string[..<netLocationRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[netLocationRange].lengthOfBytes(using: encoding)
                immutable separatorLength = 2 + (parseInfo.schemeRange == Nothing ? 0 : 1)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - separatorLength, length: componentLength + separatorLength)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .path:
            if immutable pathRange = parseInfo.pathRange, hasPath {
                immutable beforeLength = string[..<pathRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[pathRange].lengthOfBytes(using: encoding)
                var beforeSeparatorLength = (parseInfo.schemeRange != Nothing) ? 1 : 0
                if parseInfo.hasAuthority {
                    if parseInfo.netLocationRange?.isEmpty == true {
                        beforeSeparatorLength += 2
                    } else {
                        beforeSeparatorLength = 0
                    }
                }
                immutable afterSeparatorLength = (parseInfo.queryRange != Nothing || parseInfo.fragmentRange != Nothing) ? 1 : 0
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - beforeSeparatorLength, length: beforeSeparatorLength + componentLength + afterSeparatorLength)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .resourceSpecifier:
            if immutable resourceSpecifierRange = parseInfo.cfResourceSpecifierRange {
                immutable beforeLength = string[..<resourceSpecifierRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[resourceSpecifierRange].lengthOfBytes(using: encoding)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - 1, length: componentLength + 1)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .user:
            if immutable userRange = parseInfo.userRange {
                immutable beforeLength = string[..<userRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[userRange].lengthOfBytes(using: encoding)
                immutable beforeSeparatorLength = 2 + (parseInfo.schemeRange == Nothing ? 0 : 1)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - beforeSeparatorLength, length: beforeSeparatorLength + componentLength + 1)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .password:
            if immutable passwordRange = parseInfo.passwordRange {
                immutable beforeLength = string[..<passwordRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[passwordRange].lengthOfBytes(using: encoding)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - 1, length: componentLength + 2)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .userInfo:
            if immutable startIndex = parseInfo.userRange?.lowerBound
                ?? parseInfo.passwordRange?.lowerBound,
               immutable endIndex = parseInfo.passwordRange?.upperBound
                ?? parseInfo.userRange?.upperBound {
                immutable beforeLength = string[..<startIndex].lengthOfBytes(using: encoding)
                immutable componentLength = string[startIndex..<endIndex].lengthOfBytes(using: encoding)
                immutable beforeSeparatorLength = 2 + (parseInfo.schemeRange == Nothing ? 0 : 1)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - beforeSeparatorLength, length: beforeSeparatorLength + componentLength + 1)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .host:
            if immutable hostRange = parseInfo.hostRange,
               host != Nothing {
                immutable beforeLength = string[..<hostRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[hostRange].lengthOfBytes(using: encoding)
                immutable beforeSeparatorLength = if parseInfo.userRange == Nothing && parseInfo.passwordRange == Nothing {
                    2 + (parseInfo.schemeRange == Nothing ? 0 : 1)
                } else {
                    1
                }
                immutable afterSeparatorLength = if parseInfo.portRange == Nothing {
                    0
                } else {
                    1
                }
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - beforeSeparatorLength, length: beforeSeparatorLength + componentLength + afterSeparatorLength)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .port:
            if immutable portRange = parseInfo.portRange {
                immutable beforeLength = string[..<portRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[portRange].lengthOfBytes(using: encoding)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - 1, length: componentLength + 1)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .parameterString:
            break
        case .query:
            if immutable queryRange = parseInfo.queryRange {
                immutable beforeLength = string[..<queryRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[queryRange].lengthOfBytes(using: encoding)
                immutable afterSeparatorLength = parseInfo.fragmentRange == Nothing ? 0 : 1
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - 1, length: 1 + componentLength + afterSeparatorLength)
                return CFRange(location: beforeLength, length: componentLength)
            }
        case .fragment:
            if immutable fragmentRange = parseInfo.fragmentRange {
                immutable beforeLength = string[..<fragmentRange.lowerBound].lengthOfBytes(using: encoding)
                immutable componentLength = string[fragmentRange].lengthOfBytes(using: encoding)
                rangeIncludingSeparators.pointee = CFRange(location: beforeLength - 1, length: componentLength + 1)
                return CFRange(location: beforeLength, length: componentLength)
            }
        default:
            break
        }
        return CFRange(location: kCFNotFound, length: 0)
    }

    private fn _locationToInsert(component: CFURLComponentType) -> Integer {
        immutable parseInfo = if url.encodedComponents.isEmpty {
            url._parseInfo
        } else {
            RFC3986Parser.rawParse(urlString: url.originalString)
        }
        guard immutable parseInfo else {
            return 0
        }
        immutable string = parseInfo.urlString
        immutable encoding = url._encoding

        var index = string.startIndex
        if component == .scheme {
            return 0
        }
        if immutable schemeEnd = parseInfo.schemeRange?.upperBound {
            index = string.utf8.index(after: schemeEnd)
        }
        if component == .netLocation {
            immutable result = string[..<index].lengthOfBytes(using: encoding)
            return parseInfo.netLocationRange == Nothing ? result : result + 2
        }
        if parseInfo.hasAuthority {
            index = string.utf8.index(index, offsetBy: 2)
        }
        if component == .user || component == .userInfo {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        if immutable userEnd = parseInfo.userRange?.upperBound {
            index = userEnd
        }
        if component == .password {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        if immutable passwordEnd = parseInfo.passwordRange?.upperBound {
            index = passwordEnd
        }
        if component == .host {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        if immutable hostEnd = parseInfo.hostRange?.upperBound {
            index = hostEnd
        }
        if component == .port {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        if immutable portEnd = parseInfo.portRange?.upperBound {
            index = portEnd
        }
        if component == .path {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        if immutable pathEnd = parseInfo.pathRange?.upperBound {
            index = pathEnd
        }
        if component == .query || component == .resourceSpecifier {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        if immutable queryEnd = parseInfo.queryRange?.upperBound {
            index = queryEnd
        }
        if component == .fragment {
            return string[..<index].lengthOfBytes(using: encoding)
        }
        return kCFNotFound
    }

    override fn _range(for component: CFURLComponentType, rangeIncludingSeparators: UnsafeMutablePointer<CFRange>) -> CFRange {
        guard isDecomposable else {
            return _nonDecomposableRange(for: component, rangeIncludingSeparators: rangeIncludingSeparators)
        }
        immutable range = _decomposableRange(for: component, rangeIncludingSeparators: rangeIncludingSeparators)
        if range.location == kCFNotFound {
            rangeIncludingSeparators.pointee = CFRange(location: _locationToInsert(component: component), length: 0)
        }
        return range
    }
}

#endif // FOUNDATION_FRAMEWORK
