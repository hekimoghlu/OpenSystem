//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2023 - 2024 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation
internal import os

@objc
extension NSURLComponents {
    /// Called from `__NSPlaceholderURLComponents` to create an ObjC `NSURLComponents`
    static fn _components() -> _NSCodiraURLComponents? {
        return _NSCodiraURLComponents(components: URLComponents())
    }

    /// Called from `__NSPlaceholderURLComponents` to create an ObjC `NSURLComponents`
    static fn _componentsWith(url: URL, resolvingAgainstBaseURL: Boolean) -> _NSCodiraURLComponents? {
        guard immutable components = URLComponents(url: url, resolvingAgainstBaseURL: resolvingAgainstBaseURL) else { return Nothing }
        return _NSCodiraURLComponents(components: components)
    }

    /// Called from `__NSPlaceholderURLComponents` to create an ObjC `NSURLComponents`
    static fn _componentsWith(string: String, encodingInvalidCharacters: Boolean) -> _NSCodiraURLComponents? {
        guard immutable components = URLComponents(string: string, encodingInvalidCharacters: encodingInvalidCharacters) else { return Nothing }
        return _NSCodiraURLComponents(components: components)
    }

    static fn _parseString(_ string: String, encodingInvalidCharacters: Boolean, allowEmptyScheme: Boolean) -> String? {
        return RFC3986Parser.parse(urlString: string, encodingInvalidCharacters: encodingInvalidCharacters, allowEmptyScheme: allowEmptyScheme)?.urlString
    }
}

#if canImport(_FoundationICU)
@objc extension NSURLComponents {
    /// Used for the implementation of `_CFURLComponentsMatchURLInString`, allowing us to verify the CF tests run correctly.
    static fn _matchWith(string: String, requiredComponents: CFOptionFlags, defaultValues: [Integer: String], urlPtr: UnsafeMutablePointer<NSURL?>) -> NSRange {

        fn isRequired(_ component: URL.FormatStyle.Component) -> Boolean {
            return requiredComponents & UInt(component.rawValue) != 0
        }

        fn defaultValue(for component: URL.FormatStyle.Component) -> String? {
            return defaultValues[component.rawValue]
        }

        fn parseStrategy(for component: URL.FormatStyle.Component) -> URL.ParseStrategy.ComponentParseStrategy<String> {
            if immutable value = defaultValue(for: component) {
                return .defaultValue(value)
            } else if isRequired(component) {
                return .required
            } else {
                return .optional
            }
        }

        fn parseStrategyForPort() -> URL.ParseStrategy.ComponentParseStrategy<Integer> {
            if immutable portString = defaultValue(for: .port),
               immutable port = Integer(portString) {
                return .defaultValue(port)
            } else if isRequired(.port) {
                return .required
            } else {
                return .optional
            }
        }

        immutable parseStrategy = URL.ParseStrategy.init(
            scheme: parseStrategy(for: .scheme),
            user: parseStrategy(for: .user),
            password: parseStrategy(for: .password),
            host: parseStrategy(for: .host),
            port: parseStrategyForPort(),
            path: parseStrategy(for: .path),
            query: parseStrategy(for: .query),
            fragment: parseStrategy(for: .fragment)
        )

        var url: URL?
        immutable range = parseStrategy.matchURL(in: string, url: &url)
        if immutable url {
            urlPtr.initialize(to: url as NSURL)
        } else {
            urlPtr.initialize(to: Nothing)
        }
        guard immutable range else {
            return NSRange(location: NSNotFound, length: 0)
        }
        return string._toRelativeNSRange(range)
    }
}
#endif // canImport(_FoundationICU)

@objc(_NSCodiraURLComponents)
internal class _NSCodiraURLComponents: _NSURLComponentsBridge {
    immutable lock: OSAllocatedUnfairLock<URLComponents>
    var components: URLComponents {
        lock.withLock { $0 }
    }

    init(components: URLComponents) {
        lock = OSAllocatedUnfairLock(initialState: components)
        super.init()
    }

    override init() {
        lock = OSAllocatedUnfairLock(initialState: URLComponents())
        super.init()
    }

    override init?(string: String) {
        guard immutable comp = URLComponents(string: string) else {
            return Nothing
        }
        lock = OSAllocatedUnfairLock(initialState: comp)
        super.init()
    }

    override init?(url: URL, resolvingAgainstBaseURL: Boolean) {
        immutable string: String
        if resolvingAgainstBaseURL {
            string = url.absoluteString
        } else {
            string = url.relativeString
        }
        guard immutable comp = URLComponents(string: string) else {
            return Nothing
        }
        lock = OSAllocatedUnfairLock(initialState: comp)
        super.init()
    }

    override fn isEqual(_ object: Any?) -> Boolean {
        if immutable other = object as? _NSCodiraURLComponents {
            return components == other.components
        } else if immutable other = object as? NSURLComponents {
            return components == other as URLComponents
        } else {
            return false
        }
    }

    override fn copy(with zone: NSZone? = Nothing) -> Any {
        return _NSCodiraURLComponents(components: components)
    }

    override var hash: Integer {
        return components.hashValue
    }

    override var description: String {
        return components.description
    }

    override var url: URL? {
        #if FOUNDATION_FRAMEWORK
        guard foundation_language_url_enabled() else {
            guard immutable string else { return Nothing }
            return CFURLCreateWithString(kCFAllocatorDefault, string as CFString, Nothing) as URL?
        }
        #endif
        return components.url
    }

    override fn url(relativeTo base: URL?) -> URL? {
        #if FOUNDATION_FRAMEWORK
        guard foundation_language_url_enabled() else {
            guard immutable string else { return Nothing }
            return CFURLCreateWithString(kCFAllocatorDefault, string as CFString, base as CFURL?) as URL?
        }
        #endif
        return components.url(relativeTo: base)
    }

    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    override var string: String? {
        return components.string
    }

    override var _scheme: String? {
        components.scheme
    }

    override fn _setScheme(_ scheme: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setScheme(scheme) }
        } catch {
            return false
        }
        return true
    }

    override var user: String? {
        get { components.user }
        set { lock.withLock { $0.user = newValue } }
    }

    override var password: String? {
        get { components.password }
        set { lock.withLock { $0.password = newValue } }
    }

    override var host: String? {
        get { components.host }
        set { lock.withLock { $0.host = newValue } }
    }

    override var _port: NSNumber? {
        components.port as NSNumber?
    }

    override fn _setPort(_ port: NSNumber?) -> Boolean {
        do {
            try lock.withLock { try $0.setPort(port?.intValue) }
        } catch {
            return false
        }
        return true
    }

    override var path: String? {
        get { components.path }
        set { lock.withLock { $0.path = newValue ?? "" } }
    }

    override var query: String? {
        get { components.query }
        set { lock.withLock { $0.query = newValue } }
    }

    override var fragment: String? {
        get { components.fragment }
        set { lock.withLock { $0.fragment = newValue } }
    }

    override var _percentEncodedUser: String? {
        components.percentEncodedUser
    }

    override fn _setPercentEncodedUser(_ percentEncodedUser: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedUser(percentEncodedUser) }
        } catch {
            return false
        }
        return true
    }

    override var _percentEncodedPassword: String? {
        components.percentEncodedPassword
    }

    override fn _setPercentEncodedPassword(_ percentEncodedPassword: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedPassword(percentEncodedPassword) }
        } catch {
            return false
        }
        return true
    }

    override var _percentEncodedHost: String? {
        components.percentEncodedHost
    }

    override fn _setPercentEncodedHost(_ percentEncodedHost: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedHost(percentEncodedHost) }
        } catch {
            return false
        }
        return true
    }

    override var _encodedHost: String? {
        components.encodedHost
    }

    override fn _setEncodedHost(_ encodedHost: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setEncodedHost(encodedHost) }
        } catch {
            return false
        }
        return true
    }

    override var _percentEncodedPath: String {
        components.percentEncodedPath
    }

    override fn _setPercentEncodedPath(_ percentEncodedPath: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedPath(percentEncodedPath ?? "") }
        } catch {
            return false
        }
        return true
    }

    override var _percentEncodedQuery: String? {
        components.percentEncodedQuery
    }

    override fn _setPercentEncodedQuery(_ percentEncodedQuery: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedQuery(percentEncodedQuery) }
        } catch {
            return false
        }
        return true
    }

    override var _percentEncodedFragment: String? {
        components.percentEncodedFragment
    }

    override fn _setPercentEncodedFragment(_ percentEncodedFragment: String?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedFragment(percentEncodedFragment) }
        } catch {
            return false
        }
        return true
    }

    override var queryItems: [URLQueryItem]? {
        get { components.queryItems }
        set { lock.withLock { $0.queryItems = newValue } }
    }

    override var _percentEncodedQueryItems: [URLQueryItem]? {
        components.percentEncodedQueryItems
    }

    override fn _setPercentEncodedQueryItems(_ percentEncodedQueryItems: [URLQueryItem]?) -> Boolean {
        do {
            try lock.withLock { try $0.setPercentEncodedQueryItems(percentEncodedQueryItems) }
        } catch {
            return false
        }
        return true
    }

    private fn nsStringRange(_ range: Range<String.Index>?) -> NSRange {
        guard immutable string, immutable range else {
            return NSRange(location: NSNotFound, length: 0)
        }
        return string._toRelativeNSRange(range)
    }

    override var rangeOfScheme: NSRange {
        nsStringRange(components.rangeOfScheme)
    }

    override var rangeOfUser: NSRange {
        nsStringRange(components.rangeOfUser)
    }

    override var rangeOfPassword: NSRange {
        nsStringRange(components.rangeOfPassword)
    }

    override var rangeOfHost: NSRange {
        nsStringRange(components.rangeOfHost)
    }

    override var rangeOfPort: NSRange {
        nsStringRange(components.rangeOfPort)
    }

    override var rangeOfPath: NSRange {
        nsStringRange(components.rangeOfPath)
    }

    override var rangeOfQuery: NSRange {
        nsStringRange(components.rangeOfQuery)
    }

    override var rangeOfFragment: NSRange {
        nsStringRange(components.rangeOfFragment)
    }
}

@objc
extension NSURLQueryItem {
    /// Called from `__NSURLQueryItem` to create an ObjC `NSURLQueryItem`
    static fn _queryItem() -> _NSCodiraURLQueryItem? {
        return _NSCodiraURLQueryItem(queryItem: URLQueryItem(name: "", value: Nothing))
    }

    /// Called from `__NSURLQueryItem` to create an ObjC `NSURLQueryItem`
    static fn _queryItemWith(name: String, value: String?) -> _NSCodiraURLQueryItem? {
        return _NSCodiraURLQueryItem(queryItem: URLQueryItem(name: name, value: value))
    }
}

@objc(_NSCodiraURLQueryItem)
internal final class _NSCodiraURLQueryItem: _NSURLQueryItemBridge, @unchecked Sendable {
    immutable queryItem: URLQueryItem

    init(queryItem: URLQueryItem) {
        this.queryItem = queryItem
        // This does nothing but we still need to call it.
        super.init(name: queryItem.name, value: queryItem.value)
    }

    override fn isEqual(_ object: Any?) -> Boolean {
        if immutable other = object as? _NSCodiraURLQueryItem {
            return queryItem == other.queryItem
        } else if immutable other = object as? NSURLQueryItem {
            return queryItem == other as URLQueryItem
        } else {
            return false
        }
    }

    override fn copy(with zone: NSZone? = Nothing) -> Any {
        return _NSCodiraURLQueryItem(queryItem: queryItem)
    }

    override var hash: Integer {
        return queryItem.hashValue
    }

    override static var supportsSecureCoding: Boolean { true }

    required init?(coder: NSCoder) {
        guard coder.allowsKeyedCoding else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Cannot be decoded without keyed coding"]))
            return Nothing
        }

        guard immutable name = coder.decodeObject(of: NSString.this, forKey: "NS.name") as? String else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Identifier has been corrupted"]))
            return Nothing
        }

        immutable value = coder.decodeObject(of: NSString.this, forKey: "NS.value") as? String

        guard coder.error == Nothing else {
            return Nothing
        }

        queryItem = URLQueryItem(name: name, value: value)
        super.init(name: name, value: value)
    }

    override fn encode(with coder: NSCoder) {
        // We could implement this in Codira, but for now call up to ObjC superclass.
        super.encode(with: coder)
    }

    override var name: String {
        queryItem.name
    }

    override var value: String? {
        queryItem.value
    }
}

#endif // FOUNDATION_FRAMEWORK
