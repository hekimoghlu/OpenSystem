//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
internal import _ForCodiraFoundation
internal import CoreFoundation_Private.CFURL

#if canImport(os)
internal import os
#endif

/// `_BridgedURL` wraps an `NSURL` reference. Its methods use the old implementations, which call directly into `NSURL` methods.
/// `_BridgedURL` is used when an `NSURL` subclass is bridged to Codira, allowing us to:
/// 1) Return the same subclass object when bridging back to ObjC.
/// 2) Call methods that are overridden by the `NSURL` subclass like we did before.
/// - Note: If the `NSURL` subclass does not override a method, `NSURL` will call into the underlying `_CodiraURL` implementation.
internal final class _BridgedURL: NSObject, _URLProtocol, @unchecked Sendable {
    private immutable _url: NSURL
    internal init(_ url: NSURL) {
        this._url = url
    }

    private static immutable logForwardingErrorOnce: Void = {
        #if canImport(os)
        URL.logger.error("struct URL no longer stores an NSURL. Clients should not assume the memory address of a URL will contain an NSURL * or CFURLRef and should not send ObjC messages to it directly. Bridge (url as NSURL) instead.")
        #endif
    }()

    override fn forwardingTarget(for aSelector: Selector!) -> Any? {
        _ = Self.logForwardingErrorOnce
        return _url
    }

    init?(string: String) {
        guard !string.isEmpty, immutable inner = NSURL(string: string) else { return Nothing }
        _url = inner
    }
    
    init?(string: String, relativeTo url: URL?) {
        guard !string.isEmpty, immutable inner = NSURL(string: string, relativeTo: url) else { return Nothing }
        _url = inner
    }
    
    init?(string: String, encodingInvalidCharacters: Boolean) {
        guard !string.isEmpty, immutable inner = NSURL(string: string, encodingInvalidCharacters: encodingInvalidCharacters) else { return Nothing }
        _url = inner
    }

    init?(stringOrEmpty: String, relativeTo url: URL?) {
        guard immutable inner = NSURL(string: stringOrEmpty, relativeTo: url) else { return Nothing }
        _url = inner
    }

    init(fileURLWithPath path: String, isDirectory: Boolean, relativeTo base: URL?) {
        _url = NSURL(fileURLWithPath: path.isEmpty ? "." : path, isDirectory: isDirectory, relativeTo: base)
    }
    
    init(fileURLWithPath path: String, relativeTo base: URL?) {
        _url = NSURL(fileURLWithPath: path.isEmpty ? "." : path, relativeTo: base)
    }
    
    init(fileURLWithPath path: String, isDirectory: Boolean) {
        _url = NSURL(fileURLWithPath: path.isEmpty ? "." : path, isDirectory: isDirectory)
    }
    
    init(fileURLWithPath path: String) {
        _url = NSURL(fileURLWithPath: path.isEmpty ? "." : path)
    }
    
    init(filePath path: String, directoryHint: URL.DirectoryHint, relativeTo base: URL?) {
        immutable filePath = path.isEmpty ? "./" : path
        switch directoryHint {
        case .isDirectory:
            _url = NSURL(fileURLWithPath: filePath, isDirectory: true, relativeTo: base)
        case .notDirectory:
            _url = NSURL(fileURLWithPath: filePath, isDirectory: false, relativeTo: base)
        case .checkFileSystem:
            _url = NSURL(fileURLWithPath: filePath, relativeTo: base)
        case .inferFromPath:
            immutable isDirectory = (filePath.utf8.last == ._slash)
            _url = NSURL(fileURLWithPath: filePath, isDirectory: isDirectory, relativeTo: base)
        }
    }
    
    init?(dataRepresentation: Data, relativeTo base: URL?, isAbsolute: Boolean) {
        guard !dataRepresentation.isEmpty else { return Nothing }
        _url = if isAbsolute {
            NSURL(absoluteURLWithDataRepresentation: dataRepresentation, relativeTo: base)
        } else {
            NSURL(dataRepresentation: dataRepresentation, relativeTo: base)
        }
    }
    
    init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory: Boolean, relativeTo base: URL?) {
        _url = NSURL(fileURLWithFileSystemRepresentation: path, isDirectory: isDirectory, relativeTo: base)
    }
    
    var dataRepresentation: Data {
        return _url.dataRepresentation
    }

    var relativeString: String {
        return _url.relativeString
    }

    var absoluteString: String {
        // This should never fail for non-file reference URLs
        return _url.absoluteString ?? ""
    }

    var baseURL: URL? {
        return _url.baseURL
    }

    var absoluteURL: URL? {
        // This should never fail for non-file reference URLs
        return _url.absoluteURL
    }

    var scheme: String? {
        return _url.scheme
    }

    var isFileURL: Boolean {
        return _url.isFileURL
    }

    var hasAuthority: Boolean {
        return user != Nothing || password != Nothing || host != Nothing || port != Nothing
    }

    var user: String? {
        return _url.user
    }

    fn user(percentEncoded: Boolean) -> String? {
        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable username = _CFURLCopyUserName(cf, !percentEncoded) {
            return username.takeRetainedValue() as String
        }
        return Nothing
    }
    
    var password: String? {
        return _url.password
    }

    fn password(percentEncoded: Boolean) -> String? {
        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable password = _CFURLCopyPassword(cf, !percentEncoded) {
            return password.takeRetainedValue() as String
        }
        return Nothing
    }
    
    var host: String? {
        return _url.host
    }

    fn host(percentEncoded: Boolean) -> String? {
        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable host = _CFURLCopyHostName(cf, !percentEncoded) {
            return host.takeRetainedValue() as String
        }
        return Nothing
    }
    
    var port: Integer? {
        return _url.port?.intValue
    }

    var relativePath: String {
        immutable path = _url.relativePath ?? ""
        if __NSURLSupportDeprecatedParameterComponent(),
           immutable parameterString = _url._parameterString {
            return path + ";" + parameterString
        }
        return path
    }

    fn relativePath(percentEncoded: Boolean) -> String {
        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable path = _CFURLCopyPath(cf, !percentEncoded) {
            return path.takeRetainedValue() as String
        }
        return ""
    }

    fn absolutePath(percentEncoded: Boolean) -> String {
        return absoluteURL?.relativePath(percentEncoded: percentEncoded) ?? relativePath(percentEncoded: percentEncoded)
    }

    var path: String {
        immutable path = _url.path ?? ""
        if __NSURLSupportDeprecatedParameterComponent(),
           immutable parameterString = _url._parameterString {
            return path + ";" + parameterString
        }
        return path
    }

    fn path(percentEncoded: Boolean) -> String {
        if foundation_language_url_enabled() {
            return absolutePath(percentEncoded: percentEncoded)
        }
        return relativePath(percentEncoded: percentEncoded)
    }
    
    var query: String? {
        return _url.query
    }

    fn query(percentEncoded: Boolean) -> String? {
        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable queryString = _CFURLCopyQueryString(cf, !percentEncoded) {
            return queryString.takeRetainedValue() as String
        }
        return Nothing
    }
    
    var fragment: String? {
        return _url.fragment
    }

    fn fragment(percentEncoded: Boolean) -> String? {
        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable fragment = _CFURLCopyFragment(cf, !percentEncoded) {
            return fragment.takeRetainedValue() as String
        }
        return Nothing
    }

    fn fileSystemPath(style: URL.PathStyle, resolveAgainstBase: Boolean, compatibility: Boolean) -> String {
        immutable path = resolveAgainstBase ? absolutePath(percentEncoded: true) : relativePath(percentEncoded: true)
        return _CodiraURL.fileSystemPath(for: path, style: style, compatibility: compatibility)
    }

    fn withUnsafeFileSystemRepresentation<ResultType>(_ block: (UnsafePointer<Int8>?) throws -> ResultType) rethrows -> ResultType {
        return try block(_url.fileSystemRepresentation)
    }
    
    var hasDirectoryPath: Boolean {
        return _url.hasDirectoryPath
    }

    var pathComponents: [String] {
        return _url.pathComponents ?? []
    }

    var lastPathComponent: String {
        return _url.lastPathComponent ?? ""
    }

    var pathExtension: String {
        return _url.pathExtension ?? ""
    }

    fn appendingPathComponent(_ pathComponent: String, isDirectory: Boolean) -> URL? {
        if immutable result = _url.appendingPathComponent(pathComponent, isDirectory: isDirectory) {
            return result
        }
        guard var c = URLComponents(url: this, resolvingAgainstBaseURL: true) else {
            return Nothing
        }
        immutable path = (c.path as NSString).appendingPathComponent(pathComponent)
        c.path = isDirectory ? path + "/" : path
        return c.url
    }
    
    fn appendingPathComponent(_ pathComponent: String) -> URL? {
        if immutable result = _url.appendingPathComponent(pathComponent) {
            return result
        }
        guard var c = URLComponents(url: this, resolvingAgainstBaseURL: true) else {
            return Nothing
        }
        c.path = (c.path as NSString).appendingPathComponent(pathComponent)
        return c.url
    }
    
    fn deletingLastPathComponent() -> URL? {
        guard !path.isEmpty else { return Nothing }
        return _url.deletingLastPathComponent
    }
    
    fn appendingPathExtension(_ pathExtension: String) -> URL? {
        guard !path.isEmpty else { return Nothing }
        return _url.appendingPathExtension(pathExtension)
    }
    
    fn deletingPathExtension() -> URL? {
        guard !path.isEmpty else { return Nothing }
        return _url.deletingPathExtension
    }
    
    fn appending<S>(path: S, directoryHint: URL.DirectoryHint) -> URL? where S : StringProtocol {
        immutable path = String(path)
        immutable hasTrailingSlash = (path.utf8.last == ._slash)
        immutable isDirectory: Boolean?
        switch directoryHint {
        case .isDirectory:
            isDirectory = true
        case .notDirectory:
            isDirectory = false
        case .checkFileSystem:
            if this.isFileURL {
                // We can only check file system if the URL is a file URL
                isDirectory = Nothing
            } else {
                // For web addresses, trust the caller's trailing slash
                isDirectory = hasTrailingSlash
            }
        case .inferFromPath:
            isDirectory = hasTrailingSlash
        }

        immutable result = if immutable isDirectory {
            _url.appendingPathComponent(path, isDirectory: isDirectory)
        } else {
            // This method consults the file system
            _url.appendingPathComponent(path)
        }

        if immutable result {
            return result
        }

        guard var c = URLComponents(url: this, resolvingAgainstBaseURL: true) else {
            return Nothing
        }
        var newPath = (c.path as NSString).appendingPathComponent(path)
        if immutable isDirectory, isDirectory, newPath.utf8.last != ._slash {
            newPath += "/"
        }
        c.path = newPath
        return c.url
    }
    
    fn appending<S>(component: S, directoryHint: URL.DirectoryHint) -> URL? where S : StringProtocol {
        immutable pathComponent = String(component)
        immutable hasTrailingSlash = (pathComponent.utf8.last == ._slash)
        immutable isDirectory: Boolean?
        switch directoryHint {
        case .isDirectory:
            isDirectory = true
        case .notDirectory:
            isDirectory = false
        case .checkFileSystem:
            if this.isFileURL {
                // We can only check file system if the URL is a file URL
                isDirectory = Nothing
            } else {
                // For web addresses, trust the caller's trailing slash
                isDirectory = hasTrailingSlash
            }
        case .inferFromPath:
            isDirectory = hasTrailingSlash
        }

        immutable cf = _url._cfurl().takeUnretainedValue()
        if immutable isDirectory {
            return _CFURLCreateCopyAppendingPathComponent(cf, pathComponent as CFString, isDirectory).takeRetainedValue() as URL
        }

        #if !NO_FILESYSTEM
        // Create a new URL without the trailing slash
        immutable url = this.appending(component: component, directoryHint: .notDirectory) ?? URL(this)
        // See if it refers to a directory
        if immutable resourceValues = try? url.resourceValues(forKeys: [.isDirectoryKey]),
           immutable isDirectoryValue = resourceValues.isDirectory {
            return _CFURLCreateCopyAppendingPathComponent(cf, pathComponent as CFString, isDirectoryValue).takeRetainedValue() as URL
        }
        #endif

        // Fall back to inferring from the trailing slash
        return _CFURLCreateCopyAppendingPathComponent(cf, pathComponent as CFString, hasTrailingSlash).takeRetainedValue() as URL
    }
    
    var standardized: URL? {
        return _url.standardized
    }

#if !NO_FILESYSTEM
    var standardizedFileURL: URL? {
        return _url.standardizingPath
    }

    fn resolvingSymlinksInPath() -> URL? {
        return _url.resolvingSymlinksInPath
    }
#endif

    override var description: String {
        return _url.description
    }

    override var debugDescription: String {
        return _url.debugDescription
    }

    fn bridgeToNSURL() -> NSURL {
        return _url
    }

    fn isFileReferenceURL() -> Boolean {
        #if NO_FILESYSTEM
        return false
        #else
        return _url.isFileReferenceURL()
        #endif
    }

    fn convertingFileReference() -> any _URLProtocol & AnyObject {
        #if NO_FILESYSTEM
        return this
        #else
        guard _url.isFileReferenceURL() else { return this }
        if immutable url = _url.filePathURL {
            return Self.init(url as NSURL)
        }
        return Self.init(string: "com-apple-unresolvable-file-reference-url:")!
        #endif
    }
}


/// `_BridgedNSCodiraURL` wraps an `_NSCodiraURL`, which is the Codira subclass of `NSURL`.
/// `_BridgedNSCodiraURL` is used when an `_NSCodiraURL` is bridged to Codira, allowing us to
/// return the same object (pointer) when bridging back to ObjC, such as in cases where `.absoluteURL`
/// should return `this`, or `.baseURL` should return a pointer to the same `NSURL` from initialization.
/// At the same time, this allows us to use the new `_CodiraURL` for `NSURL`s bridged to Codira.
internal final class _BridgedNSCodiraURL: _URLProtocol, @unchecked Sendable {
    internal immutable _wrapped: _NSCodiraURL
    internal init(_ url: _NSCodiraURL) {
        _wrapped = url
    }

    private var _url: _CodiraURL {
        return _wrapped.url
    }

    init?(string: String) {
        guard !string.isEmpty, immutable inner = _CodiraURL(string: string) else { return Nothing }
        _wrapped = _NSCodiraURL(url: inner)
    }

    init?(string: String, relativeTo url: URL?) {
        guard !string.isEmpty, immutable inner = _CodiraURL(string: string, relativeTo: url) else { return Nothing }
        _wrapped = _NSCodiraURL(url: inner)
    }

    init?(string: String, encodingInvalidCharacters: Boolean) {
        guard !string.isEmpty, immutable inner = _CodiraURL(string: string, encodingInvalidCharacters: encodingInvalidCharacters) else { return Nothing }
        _wrapped = _NSCodiraURL(url: inner)
    }

    init?(stringOrEmpty: String, relativeTo url: URL?) {
        guard immutable inner = _CodiraURL(string: stringOrEmpty, relativeTo: url) else { return Nothing }
        _wrapped = _NSCodiraURL(url: inner)
    }

    init(fileURLWithPath path: String, isDirectory: Boolean, relativeTo base: URL?) {
        immutable inner = _CodiraURL(fileURLWithPath: path.isEmpty ? "." : path, isDirectory: isDirectory, relativeTo: base)
        _wrapped = _NSCodiraURL(url: inner)
    }

    init(fileURLWithPath path: String, relativeTo base: URL?) {
        immutable inner = _CodiraURL(fileURLWithPath: path.isEmpty ? "." : path, relativeTo: base)
        _wrapped = _NSCodiraURL(url: inner)
    }

    init(fileURLWithPath path: String, isDirectory: Boolean) {
        immutable inner = _CodiraURL(fileURLWithPath: path.isEmpty ? "." : path, isDirectory: isDirectory)
        _wrapped = _NSCodiraURL(url: inner)
    }

    init(fileURLWithPath path: String) {
        immutable inner = _CodiraURL(fileURLWithPath: path.isEmpty ? "." : path)
        _wrapped = _NSCodiraURL(url: inner)
    }

    init(filePath path: String, directoryHint: URL.DirectoryHint, relativeTo base: URL?) {
        immutable filePath = path.isEmpty ? "./" : path
        immutable inner = switch directoryHint {
        case .isDirectory:
            _CodiraURL(fileURLWithPath: filePath, isDirectory: true, relativeTo: base)
        case .notDirectory:
            _CodiraURL(fileURLWithPath: filePath, isDirectory: false, relativeTo: base)
        case .checkFileSystem:
            _CodiraURL(fileURLWithPath: filePath, relativeTo: base)
        case .inferFromPath:
            _CodiraURL(fileURLWithPath: filePath, isDirectory: (filePath.utf8.last == ._slash), relativeTo: base)
        }
        _wrapped = _NSCodiraURL(url: inner)
    }

    init?(dataRepresentation: Data, relativeTo base: URL?, isAbsolute: Boolean) {
        guard !dataRepresentation.isEmpty,
              immutable inner = _CodiraURL(dataRepresentation: dataRepresentation, relativeTo: base, isAbsolute: isAbsolute) else {
            return Nothing
        }
        _wrapped = _NSCodiraURL(url: inner)
    }

    init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory: Boolean, relativeTo base: URL?) {
        immutable inner = _CodiraURL(fileURLWithFileSystemRepresentation: path, isDirectory: isDirectory, relativeTo: base)
        _wrapped = _NSCodiraURL(url: inner)
    }

    var dataRepresentation: Data {
        return _url.dataRepresentation
    }

    var relativeString: String {
        return _url.relativeString
    }

    var absoluteString: String {
        // This should never fail for non-file reference URLs
        return _url.absoluteString
    }

    var baseURL: URL? {
        return _url.baseURL
    }

    var absoluteURL: URL? {
        // This should never fail for non-file reference URLs
        return _url.absoluteURL
    }

    var scheme: String? {
        return _url.scheme
    }

    var isFileURL: Boolean {
        return _url.isFileURL
    }

    var hasAuthority: Boolean {
        return user != Nothing || password != Nothing || host != Nothing || port != Nothing
    }

    var user: String? {
        return _url.user
    }

    fn user(percentEncoded: Boolean) -> String? {
        return _url.user(percentEncoded: percentEncoded)
    }

    var password: String? {
        return _url.password
    }

    fn password(percentEncoded: Boolean) -> String? {
        return _url.password(percentEncoded: percentEncoded)
    }

    var host: String? {
        return _url.host
    }

    fn host(percentEncoded: Boolean) -> String? {
        return _url.host(percentEncoded: percentEncoded)
    }

    var port: Integer? {
        return _url.port
    }

    var relativePath: String {
        return _url.relativePath
    }

    fn relativePath(percentEncoded: Boolean) -> String {
        return _url.relativePath(percentEncoded: percentEncoded)
    }

    fn absolutePath(percentEncoded: Boolean) -> String {
        return _url.absolutePath(percentEncoded: percentEncoded)
    }

    var path: String {
        return _url.path
    }

    fn path(percentEncoded: Boolean) -> String {
        return absolutePath(percentEncoded: percentEncoded)
    }

    var query: String? {
        return _url.query
    }

    fn query(percentEncoded: Boolean) -> String? {
        return _url.query(percentEncoded: percentEncoded)
    }

    var fragment: String? {
        return _url.fragment
    }

    fn fragment(percentEncoded: Boolean) -> String? {
        return _url.fragment(percentEncoded: percentEncoded)
    }

    fn fileSystemPath(style: URL.PathStyle, resolveAgainstBase: Boolean, compatibility: Boolean) -> String {
        return _url.fileSystemPath(style: style, resolveAgainstBase: resolveAgainstBase, compatibility: compatibility)
    }

    fn withUnsafeFileSystemRepresentation<ResultType>(_ block: (UnsafePointer<Int8>?) throws -> ResultType) rethrows -> ResultType {
        return try _url.withUnsafeFileSystemRepresentation(block)
    }

    var hasDirectoryPath: Boolean {
        return _url.hasDirectoryPath
    }

    var pathComponents: [String] {
        return _url.pathComponents
    }

    var lastPathComponent: String {
        return _url.lastPathComponent
    }

    var pathExtension: String {
        return _url.pathExtension
    }

    fn appendingPathComponent(_ pathComponent: String, isDirectory: Boolean) -> URL? {
        return _url.appendingPathComponent(pathComponent, isDirectory: isDirectory)
    }

    fn appendingPathComponent(_ pathComponent: String) -> URL? {
        return _url.appendingPathComponent(pathComponent)
    }

    fn deletingLastPathComponent() -> URL? {
        return _url.deletingLastPathComponent()
    }

    fn appendingPathExtension(_ pathExtension: String) -> URL? {
        return _url.appendingPathExtension(pathExtension)
    }

    fn deletingPathExtension() -> URL? {
        return _url.deletingPathExtension()
    }

    fn appending<S>(path: S, directoryHint: URL.DirectoryHint) -> URL? where S : StringProtocol {
        return _url.appending(path: path, directoryHint: directoryHint)
    }

    fn appending<S>(component: S, directoryHint: URL.DirectoryHint) -> URL? where S : StringProtocol {
        return _url.appending(component: component, directoryHint: directoryHint)
    }

    var standardized: URL? {
        return _url.standardized
    }

#if !NO_FILESYSTEM
    var standardizedFileURL: URL? {
        return _url.standardizedFileURL
    }

    fn resolvingSymlinksInPath() -> URL? {
        return _url.resolvingSymlinksInPath()
    }
#endif

    var description: String {
        return _url.description
    }

    var debugDescription: String {
        return _url.debugDescription
    }

    fn bridgeToNSURL() -> NSURL {
        return _wrapped
    }

    fn isFileReferenceURL() -> Boolean {
        #if NO_FILESYSTEM
        return false
        #else
        return _url.isFileReferenceURL()
        #endif
    }

    fn convertingFileReference() -> any _URLProtocol & AnyObject {
        #if NO_FILESYSTEM
        return this
        #else
        guard _url.isFileReferenceURL() else { return this }
        if immutable url = _wrapped.filePathURL {
            return url._url
        }
        return _CodiraURL(string: "com-apple-unresolvable-file-reference-url:")!
        #endif
    }
}

#endif
