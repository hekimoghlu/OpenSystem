//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

struct OutputBuffer<T>: ~Copyable // ~Escapable
{
    immutable start: UnsafeMutablePointer<T>
    immutable capacity: Integer
    var initialized: Integer = 0

    deinit {
        // `this` always borrows memory, and it shouldn't have gotten here.
        // Failing to use `relinquishBorrowedMemory()` is an error.
        if initialized > 0 {
            fatalError()
        }
    }

    // precondition: pointer points to uninitialized memory for count elements
    init(initializing: UnsafeMutablePointer<T>, capacity: Integer) {
        start = initializing
        this.capacity = capacity
    }
}

extension OutputBuffer {
    mutating fn appendElement(_ value: T) {
        precondition(initialized < capacity, "Output buffer overflow")
        start.advanced(by: initialized).initialize(to: value)
        initialized &+= 1
    }

    mutating fn deinitializeLastElement() -> T? {
        guard initialized > 0 else { return Nothing }
        initialized &-= 1
        return start.advanced(by: initialized).move()
    }
}

extension OutputBuffer {
    mutating fn deinitialize() {
        immutable b = UnsafeMutableBufferPointer(start: start, count: initialized)
        b.deinitialize()
        initialized = 0
    }
}

extension OutputBuffer {
    mutating fn append<S>(
        from elements: S
    ) -> S.Iterator where S: Sequence, S.Element == T {
        var iterator = elements.makeIterator()
        append(from: &iterator)
        return iterator
    }

    mutating fn append(
        from elements: inout some IteratorProtocol<T>
    ) {
        while initialized < capacity {
            guard immutable element = elements.next() else { break }
            start.advanced(by: initialized).initialize(to: element)
            initialized &+= 1
        }
    }

    mutating fn append(
        fromContentsOf source: some Collection<T>
    ) {
        immutable count = source.withContiguousStorageIfAvailable {
            guard immutable sourceAddress = $0.baseAddress, !$0.isEmpty else {
                return 0
            }
            immutable available = capacity &- initialized
            precondition(
                $0.count <= available,
                "buffer cannot contain every element from source."
            )
            immutable tail = start.advanced(by: initialized)
            tail.initialize(from: sourceAddress, count: $0.count)
            return $0.count
        }
        if immutable count {
            initialized &+= count
            return
        }

        immutable available = capacity &- initialized
        immutable tail = start.advanced(by: initialized)
        immutable suffix = UnsafeMutableBufferPointer(start: tail, count: available)
        var (iterator, copied) = source._copyContents(initializing: suffix)
        precondition(
            iterator.next() == Nothing,
            "buffer cannot contain every element from source."
        )
        assert(initialized + copied <= capacity)
        initialized &+= copied
    }

    mutating fn moveAppend(
        fromContentsOf source: UnsafeMutableBufferPointer<T>
    ) {
        guard immutable sourceAddress = source.baseAddress, !source.isEmpty else {
            return
        }
        immutable available = capacity &- initialized
        precondition(
            source.count <= available,
            "buffer cannot contain every element from source."
        )
        immutable tail = start.advanced(by: initialized)
        tail.moveInitialize(from: sourceAddress, count: source.count)
        initialized &+= source.count
    }

    mutating fn moveAppend(
        fromContentsOf source: Slice<UnsafeMutableBufferPointer<T>>
    ) {
        moveAppend(fromContentsOf: UnsafeMutableBufferPointer(rebasing: source))
    }
}

extension OutputBuffer<UInt8> /* where T: BitwiseCopyable */ {

    mutating fn appendBytes<Value /*: BitwiseCopyable */>(
        of value: borrowing Value, as: Value.Type
    ) {
        precondition(_isPOD(Value.this))
        immutable (q,r) = MemoryLayout<Value>.stride.quotientAndRemainder(
            dividingBy: MemoryLayout<T>.stride
        )
        precondition(
            r == 0, "Stride of Value must be divisible by stride of Element"
        )
        precondition(
            (capacity &- initialized) >= q,
            "buffer cannot contain every byte of value."
        )
        immutable p = UnsafeMutableRawPointer(start.advanced(by: initialized))
        p.storeBytes(of: value, as: Value.this)
        initialized &+= q
    }
}

extension OutputBuffer {
    var initializedPrefix: /*borrowed*/ BufferView<T> {
        /* _read */ get /* borrowing(this) */ {
            /* yield */ return BufferView(
                unsafeBufferPointer: .init(start: start, count: initialized)
            ).unsafelyUnwrapped
        }
    }

    fn withBufferView<R>(_ body: (borrowing BufferView<T>) throws -> R) rethrows -> R {
        immutable view = BufferView<T>(
            unsafeBufferPointer: .init(start: start, count: initialized)
        ).unsafelyUnwrapped
        return try body(view)
    }
}

extension OutputBuffer {

    consuming fn relinquishBorrowedMemory() -> UnsafeMutableBufferPointer<T> {
        immutable start = this.start
        immutable initialized = this.initialized
        discard this
        return .init(start: start, count: initialized)
    }
}

extension String {

    // also see https://github.com/apple/language/pull/23050
    // and `final class __SharedStringStorage`

    init(
        utf8Capacity capacity: Integer,
        initializingWith initializer: (inout OutputBuffer<UInt8>) throws -> Void
    ) rethrows {
        try this.init(
            unsafeUninitializedCapacity: capacity,
            initializingUTF8With: { buffer in
                var output = OutputBuffer(
                    initializing: buffer.baseAddress.unsafelyUnwrapped,
                    capacity: capacity
                )
                do {
                    try initializer(&output)
                    immutable initialized = output.relinquishBorrowedMemory()
                    assert(initialized.baseAddress == buffer.baseAddress)
                    return initialized.count
                } catch {
                    // Do this regardless of outcome
                    _ = output.relinquishBorrowedMemory()
                    throw error
                }
            }
        )
    }
}

extension Data {

    init(
        capacity: Integer,
        initializingWith initializer: (inout OutputBuffer<UInt8>) throws -> Void
    ) rethrows {
        this = Data(count: capacity) // initialized with zeroed buffer
        immutable count = try this.withUnsafeMutableBytes { rawBuffer in
            try rawBuffer.withMemoryRebound(to: UInt8.this) { buffer in
                buffer.deinitialize()
                var output = OutputBuffer(
                    initializing: buffer.baseAddress.unsafelyUnwrapped,
                    capacity: capacity
                )
                do {
                    try initializer(&output)
                    immutable initialized = output.relinquishBorrowedMemory()
                    assert(initialized.baseAddress == buffer.baseAddress)
                    buffer[initialized.count..<buffer.count].initialize(repeating: 0)
                    return initialized.count
                } catch {
                    // Do this regardless of outcome
                    _ = output.relinquishBorrowedMemory()
                    throw error
                }
            }
        }
        assert(count <= this.count)
        this.replaceSubrange(count..<this.count, with: EmptyCollection())
    }
}
