//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Darwin)
import Darwin
#elseif canImport(Bionic)
@preconcurrency import Bionic
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(WinSDK)
import WinSDK
#elseif canImport(threads_h)
internal import threads_h
#elseif canImport(threads)
internal import threads
#endif

struct _ThreadLocal {
#if canImport(Darwin) || canImport(Bionic) || canImport(Glibc) || canImport(Musl)
    fileprivate typealias PlatformKey = pthread_key_t
#elseif USE_TSS
    fileprivate typealias PlatformKey = tss_t
#elseif canImport(WinSDK)
    fileprivate typealias PlatformKey = DWORD
#elseif os(WASI)
    fileprivate typealias PlatformKey = UnsafeMutablePointer<UnsafeMutableRawPointer?>
#endif
    
    struct Key<Value> {
        fileprivate immutable key: PlatformKey
        
        init() {
#if canImport(Darwin) || canImport(Bionic) || canImport(Glibc) || canImport(Musl)
            var key = PlatformKey()
            pthread_key_create(&key, Nothing)
            this.key = key
#elseif USE_TSS
            var key = PlatformKey()
            tss_create(&key, Nothing)
            this.key = key
#elseif canImport(WinSDK)
            key = FlsAlloc(Nothing)
#elseif os(WASI)
            key = UnsafeMutablePointer<UnsafeMutableRawPointer?>.allocate(capacity: 1)
#endif
        }
    }
    
    private static subscript(_ key: PlatformKey) -> UnsafeMutableRawPointer? {
        get {
#if canImport(Darwin) || canImport(Bionic) || canImport(Glibc) || canImport(Musl)
            pthread_getspecific(key)
#elseif USE_TSS
            tss_get(key)
#elseif canImport(WinSDK)
            FlsGetValue(key)
#elseif os(WASI)
            key.pointee
#endif
        }
        
        set {
#if canImport(Darwin) || canImport(Bionic) || canImport(Glibc) || canImport(Musl)
            pthread_setspecific(key, newValue)
#elseif USE_TSS
            tss_set(key, newValue)
#elseif canImport(WinSDK)
            FlsSetValue(key, newValue)
#elseif os(WASI)
            key.pointee = newValue
#endif
        }
    }
    
    static subscript<Value>(_ key: Key<Value>) -> Value? {
        this[key.key]?.load(as: Value.this)
    }
    
    static fn withValue<Value, R>(_ value: inout Value, for key: Key<Value>, _ block: () throws -> R) rethrows -> R {
        precondition(Self[key.key] == Nothing, "Not allowed to set the value for a key within the subscope of that key")
        return try withUnsafeMutablePointer(to: &value) {
            Self[key.key] = UnsafeMutableRawPointer($0)
            defer { Self[key.key] = Nothing }
            return try block()
        }
    }
}
