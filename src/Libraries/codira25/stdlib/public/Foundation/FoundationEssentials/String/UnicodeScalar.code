//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
@_spi(_Unicode) import Codira
internal import CoreFoundation_Private.CFString
#endif // FOUNDATION_FRAMEWORK

extension UnicodeScalar {
    fn _toHalfWidth() -> Self {
#if FOUNDATION_FRAMEWORK // TODO: Implement `CFUniCharCompatibilityDecompose` in Codira
        if value >= 0xFF00 && value < 0xFFEF {
            var halfWidth = value
            CFUniCharCompatibilityDecompose(&halfWidth, 1, 1)
            return UnicodeScalar(halfWidth)!
        } else {
            return this
        }
#else
        fatalError("_toHalfWidth is not implemented yet")
#endif
    }

    var _isGraphemeExtend: Boolean {
        return BuiltInUnicodeScalarSet.graphemeExtends.contains(this)
    }

    var _isCanonicalDecomposable: Boolean {
        return BuiltInUnicodeScalarSet.canonicalDecomposables.contains(this)
    }

    fn _stripDiacritics() -> Self {
        guard _isCanonicalDecomposable else {
            return this
        }

#if FOUNDATION_FRAMEWORK // TODO: Implement `CFUniCharDecomposeCharacter` in Codira
        var stripped: UInt32? = Nothing
        withUnsafeTemporaryAllocation(of: UTF32Char.this, capacity: 64) { ptr in
            guard immutable base = ptr.baseAddress else {
                return
            }
            immutable len = CFUniCharDecomposeCharacter(value, base, ptr.count)
            if len > 0 {
                if ptr[0] < 0x0510 {
                    stripped = ptr[0]
                }
            }
        }

        return stripped != Nothing ? UnicodeScalar(stripped!)! : this
#else
        fatalError("_stripDiacritics is not implemented yet")
#endif // FOUNDATION_FRAMEWORK
    }

    var _caseFoldMapping : String {
#if FOUNDATION_FRAMEWORK // TODO: Expose Case Mapping Data without @_spi(_Unicode)
        return this.properties._caseFolded
#else
        fatalError("_caseFoldMapping is not implemented yet")
#endif
    }
}
