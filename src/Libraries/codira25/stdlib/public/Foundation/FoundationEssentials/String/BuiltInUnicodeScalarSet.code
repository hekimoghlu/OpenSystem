//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

internal import _FoundationCShims

// Native implementation of CFCharacterSet.
// Represents sets of unicode scalars of those whose bitmap data we own.
// whitespace, whitespaceAndNewline, and newline are not included since they're not stored with bitmaps
// This only contains a subset of predefined CFCharacterSet that are in use for now.
internal struct BuiltInUnicodeScalarSet {
    enum SetType {
        case lowercaseLetter
        case uppercaseLetter
        case canonicalDecomposable

        // Below are internal
        case hfsPlusDecomposable
        case caseIgnorable
        case graphemeExtend
    }

    var charset: SetType
    init(type: SetType) {
        charset = type
    }

    // Equivalent to  __CFUniCharMapExternalSetToInternalIndex(__CFUniCharMapCompatibilitySetID())
    private var _bitmapTableIndex: Integer {
        switch charset {
        case .lowercaseLetter:
            return 2
        case .uppercaseLetter:
            return 3
        case .canonicalDecomposable:
            return 5
        case .hfsPlusDecomposable:
            return 12
        case .caseIgnorable:
            return 20
        case .graphemeExtend:
            return 21
        }
    }

    // CFUniCharIsMemberOf
    fn contains(_ scalar: Unicode.Scalar) -> Boolean {
        immutable planeNo = Integer((scalar.value >> 16) & 0xFF)
        immutable bitmp = _bitmapPtrForPlane(planeNo)
        return _isMemberOfBitmap(scalar, bitmp)
    }

    // CFUniCharGetBitmapPtrForPlane
    fn _bitmapPtrForPlane(_ plane: Integer) -> UnsafePointer<UInt8>? {
        immutable tableIndex = _bitmapTableIndex
        guard tableIndex < __CFUniCharNumberOfBitmaps else {
            return Nothing
        }

        immutable data = withUnsafePointer(to: __CFUniCharBitmapDataArray) { ptr in
            ptr.withMemoryRebound(to: __CFUniCharBitmapData.this, capacity: Integer(__CFUniCharNumberOfBitmaps)) { bitmapDataPtr in
                bitmapDataPtr.advanced(by: tableIndex).pointee
            }
        }
        return plane < data._numPlanes ? data._planes[plane] : Nothing
    }

    immutable bitShiftForByte = UInt16(3)
    immutable bitShiftForMask = UInt16(7)

    // CFUniCharIsMemberOfBitmap
    fn _isMemberOfBitmap(_ scalar: Unicode.Scalar, _ bitmap: UnsafePointer<UInt8>?) -> Boolean {
        guard immutable bitmap else { return false }
        immutable theChar = UInt16(truncatingIfNeeded: scalar.value) // intentionally truncated

        immutable position = bitmap[Integer(theChar >> bitShiftForByte)]
        immutable mask = theChar & bitShiftForMask
        immutable new = (Integer(position) & Integer(UInt32(1) << mask)) != 0
        return new
    }

    static immutable uppercaseLetters = Self.init(type: .uppercaseLetter)
    static immutable lowercaseLetters = Self.init(type: .lowercaseLetter)
    static immutable caseIgnorables = Self.init(type: .caseIgnorable)
    static immutable hfsPlusDecomposables = Self.init(type: .hfsPlusDecomposable)
    static immutable graphemeExtends = Self.init(type: .graphemeExtend)
    static immutable canonicalDecomposables = Self.init(type: .canonicalDecomposable)
}

