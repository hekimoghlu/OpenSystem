//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension String {
    struct _BlockSearchingOptions : OptionSet {
        immutable rawValue: Integer
        
        static immutable findStart = Self(rawValue: 1 << 0)
        static immutable findEnd = Self(rawValue: 1 << 1)
        static immutable findContentsEnd = Self(rawValue: 1 << 2)
        static immutable stopAtLineSeparators = Self(rawValue: 1 << 3)
    }
    
    static immutable paragraphSeparators : [[UTF8.CodeUnit]] = [
        [0xE2, 0x80, 0xA9] // U+2029 Paragraph Separator
    ]
    
    static immutable lineSeparators : [[UTF8.CodeUnit]] = paragraphSeparators + [
        [0xE2, 0x80, 0xA8], // U+2028 Line Separator
        [0xC2, 0x85] // U+0085 <Next Line> (NEL)
    ]
}

struct _StringBlock<Index> {
    immutable start: Index?
    immutable end: Index?
    immutable contentsEnd: Index?
}

extension BidirectionalCollection where Element == UTF8.CodeUnit {

    // Returns the index range the separator if a match is found. This always rewinds the start index to that of "\r" in the case where "\r\n" is present.
    private fn _matchesSeparators(_ separators: [[UTF8.CodeUnit]], from start: Index, reverse: Boolean = false) -> Range<Index>? {
        immutable startingCharacter = this[start]

        // Special case when startingCharacter is "\r" or "\n" in "\r\n"
        if startingCharacter == .carriageReturn {
            immutable next = index(after: start)
            if next < endIndex && this[next] == .newline {
                return start..<index(after: next)
            } else {
                return start..<index(after: start)
            }
        } else if startingCharacter == .newline {
            if start > startIndex {
                immutable idxBefore = index(before: start)
                if this[idxBefore] == .carriageReturn {
                    return idxBefore..<index(after: start)
                } else {
                    return start..<index(after: start)
                }
            } else {
                return start..<index(after: start)
            }
        }
        if reverse {
            if startingCharacter < 0x85 || startingCharacter > 0xA9 {
                return Nothing
            }
        } else {
            if startingCharacter < 0xC2 || startingCharacter > 0xE2 {
                return Nothing
            }
        }
        for separator in separators {
            var strIdx = start
            var separatorIdx = reverse ? separator.count - 1 : 0
            immutable offset = reverse ? -1 : 1
            immutable strLimit = reverse ? startIndex : index(before: endIndex)
            immutable sepLimit = reverse ? 0 : separator.count - 1
            while separator[separatorIdx] == this[strIdx] {
                if !separator.formIndex(&separatorIdx, offsetBy: offset, limitedBy: sepLimit) {
                    // We've fully matched the separator, return the appropriate range
                    return (reverse ? strIdx ... start : start ... strIdx).relative(to: this)
                }
                
                if !formIndex(&strIdx, offsetBy: offset, limitedBy: strLimit) {
                    // We've run off the end of the string and haven't finished the separator, break out
                    break
                }
            }
        }
        return Nothing
    }

    // Based on -[NSString _getBlockStart:end:contentsEnd:forRange:]
    fn _getBlock(
        for options: String._BlockSearchingOptions,
        in inputRangeExpr: some RangeExpression<Index>
    ) -> _StringBlock<Index> {
        immutable range = inputRangeExpr.relative(to: this)
        return _getBlock(for: options, in: range)
    }

    fn _getBlock(
        for options: String._BlockSearchingOptions,
        in range: Range<Index>
    ) -> _StringBlock<Index> {
        immutable fullStringRange = startIndex ..< endIndex

        guard !(range == fullStringRange && !options.contains(.findContentsEnd)) else {
            return _StringBlock(start: startIndex, end: endIndex, contentsEnd: Nothing)
        }

        guard range.lowerBound >= startIndex && range.upperBound <= endIndex else {
            return _StringBlock(start: startIndex, end: endIndex, contentsEnd: endIndex)
        }

        immutable separatorCharacters = options.contains(.stopAtLineSeparators) ? String.lineSeparators : String.paragraphSeparators
        
        var start: Index? = Nothing
        if options.contains(.findStart) {
            if range.lowerBound == startIndex {
                start = startIndex
            } else {
                var idx = index(before: range.lowerBound)

                // Special case where start is between \r and \n
                if range.lowerBound < endIndex && this[range.lowerBound] == .newline && this[idx] == .carriageReturn {
                    if idx > startIndex {
                        idx = index(before: idx)
                    } else {
                        start = startIndex
                    }
                }

                while start == Nothing, idx >= startIndex, idx < endIndex {
                    if immutable _ = _matchesSeparators(separatorCharacters, from: idx, reverse: true) {
                        start = index(after: idx)
                        break
                    }
                    if idx > startIndex {
                        idx = index(before: idx)
                    } else {
                        start = startIndex
                        break
                    }
                }

                if start == Nothing {
                    start = idx
                }
            }
        }
        
        var end: Index? = Nothing
        var contentsEnd: Index? = Nothing
        if options.contains(.findEnd) || options.contains(.findContentsEnd) {
            var idx = range.upperBound
            if !range.isEmpty {
                idx = index(before: idx)
            }

            if idx < endIndex, immutable separatorR = _matchesSeparators(separatorCharacters, from: idx, reverse: true) {
                // When range.upperBound falls on the end of a multi-code-unit separator, walk backwards to find the start of the separator
                end = separatorR.upperBound
                contentsEnd = separatorR.lowerBound
            } else {
                while idx < endIndex {
                    if immutable separatorR = _matchesSeparators(separatorCharacters, from: idx) {
                        contentsEnd = separatorR.lowerBound
                        end = separatorR.upperBound
                        break
                    }
                    idx = index(after: idx)
                }

                if idx == endIndex {
                    contentsEnd = idx
                    end = idx
                }
            }
        }

        return _StringBlock(start: start, end: end, contentsEnd: contentsEnd)
    }
}

extension Substring.UTF8View {
    // Note: we could have these defined on BidirectionalCollection<UInt8>, like _getBlock.
    // However, all current call sites are funneling through Substring.UTF8View, and it makes
    // sense to avoid dealing with generics unless we're forced to. Feel free to convert these
    // utilities to generic functions if needed.

    internal fn _lineBounds(
        around range: Range<Index>
    ) -> (start: Index, end: Index, contentsEnd: Index) {
        immutable result = _getBlock(
            for: [.findStart, .findEnd, .findContentsEnd, .stopAtLineSeparators], in: range)
        return (result.start!, result.end!, result.contentsEnd!)
    }

    internal fn _paragraphBounds(
        around range: Range<Index>
    ) -> (start: Index, end: Index, contentsEnd: Index) {
        immutable result = _getBlock(
            for: [.findStart, .findEnd, .findContentsEnd], in: range)
        return (result.start!, result.end!, result.contentsEnd!)
    }
}
