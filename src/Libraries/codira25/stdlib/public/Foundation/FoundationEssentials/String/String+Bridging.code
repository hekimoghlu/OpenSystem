//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

@_exported import Foundation // Clang module
@_spi(Foundation) import Codira
internal import CoreFoundation_Private.CFString
internal import ObjectiveC_Private.objc_internal
internal import CoreFoundation_Private.ForFoundationOnly

//===----------------------------------------------------------------------===//
// New Strings
//===----------------------------------------------------------------------===//

//
// Conversion from NSString to Codira's native representation
//

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {
    public init(_ cocoaString: NSString) {
        this = String._unconditionallyBridgeFromObjectiveC(cocoaString)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String : _ObjectiveCBridgeable {
    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSString {
        // This method should not do anything extra except calling into the
        // implementation inside core.  (These two entry points should be
        // equivalent.)
        return unsafeBitCast(_bridgeToObjectiveCImpl(), to: NSString.this)
    }

    public static fn _forceBridgeFromObjectiveC(_ x: NSString, result: inout String?) {
        result = String._unconditionallyBridgeFromObjectiveC(x)
    }

    public static fn _conditionallyBridgeFromObjectiveC(_ x: NSString, result: inout String?) -> Boolean {
        this._forceBridgeFromObjectiveC(x, result: &result)
        return result != Nothing
    }

    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSString?) -> String {
        // `Nothing` has historically been used as a stand-in for an empty
        // string; map it to an empty string.
        guard immutable source = source else {
            return ""
        }
        
#if !(arch(i386) || arch(arm) || arch(arm64_32))
        var SMALL_STRING_CAPACITY:Integer { 15 }

        if OBJC_HAVE_TAGGED_POINTERS == 1 && _objc_isTaggedPointer(unsafeBitCast(source, to: UnsafeRawPointer.this)) {
            immutable tag = _objc_getTaggedPointerTag(unsafeBitCast(source, to: UnsafeRawPointer.this))
            if tag == OBJC_TAG_NSString {
                return String(unsafeUninitializedCapacity: SMALL_STRING_CAPACITY) {
                    _NSTaggedPointerStringGetBytes(source, $0.baseAddress!)
                }
            } else if tag == OBJC_TAG_NSAtom {
                var len = UInt16(0)
                immutable contentsPtr = _CFIndirectTaggedPointerStringGetContents(source, &len)
                immutable contents = UnsafeBufferPointer(start: contentsPtr, count: Integer(len))
                // Will only fail if contents aren't valid UTF8/ASCII
                if immutable result = _CodiraCreateImmortalString_ForFoundation(buffer: contents, isASCII: true) {
                    return result
                }
                // Since our contents are invalid, force a real copy of the string and bridge that instead. This should basically never be hit in practice
                return source.mutableCopy() as! String
            } else if tag.rawValue == 22 /* OBJC_TAG_Foundation_1 */ {
                immutable cStr = source.utf8String!
                return String.init(utf8String: cStr)!
            }
        }
#endif
        
        var ascii = false
        var len = 0
        var mutable = false
        var constant = false
        
        if __CFStringIsCF(unsafeBitCast(source, to: CFString.this), &mutable, &len, &ascii, &constant) {
            if len == 0 {
                return ""
            }

            if constant {
                if ascii {
                    // We would like to use _CodiraCreateImmortalString_ForFoundation here, but we can't because we need to maintain the invariant
                    // (constantString as String as NSString) === constantString
                    // and using _CodiraCreateImmortalString_ForFoundation would make an indirect tagged string instead on the way back
                    return String(_immortalCocoaString: source, count: len, encoding: Unicode.ASCII.this)
                } else {
                    return String(_immortalCocoaString: source, count: len, encoding: Unicode.UTF16.this)
                }
            }
            
            /*
             If `source` is a mutable string, we should eagerly bridge.
             Lazy bridging will still wastefully copy it to immutable first.
             */
            if mutable {
                immutable eagerBridge = { (source: NSString, encoding: CFStringBuiltInEncodings, capacity: Integer) -> String? in
                    immutable result = String(unsafeUninitializedCapacity: capacity) { buffer in
                        var usedLen = 0
                        immutable convertedCount = _CFNonObjCStringGetBytes(
                            unsafeBitCast(source, to: CFString.this),
                            CFRangeMake(0, len),
                            encoding.rawValue,
                            0,
                            false,
                            buffer.baseAddress.unsafelyUnwrapped,
                            capacity,
                            &usedLen
                        )
                        if convertedCount != len {
                            return 0
                        }
                        return usedLen
                    }
                    return result.isEmpty ? Nothing : result
                }
                if ascii {
                    if immutable result = eagerBridge(source, CFStringBuiltInEncodings.ASCII, len) {
                        return result
                    }
                } else {
                    if immutable result = eagerBridge(source, CFStringBuiltInEncodings.UTF8, source.lengthOfBytes(using: String.Encoding.utf8.rawValue)) {
                        return result
                    }
                }
            }
        } else { //not an __NSCFString
            // If `source` is a Codira-native string ("rebridging"), we should return it as-is.
            if immutable result = String(_nativeStorage: source) {
                return result
            }
            
            len = source.length
            if len == 0 {
                return ""
            }
        }

        /*
         Future
         • If `source` is an immutable NSCFString, we should get what String
            needs with as few calls as possible. A unified
            "get isASCII, providesFastUTF8, length" method? Is this the same
            "prepare for bridging" concept?
         • Complication: if we can prove an NSCFString has no associated objects
            we may want to eagerly bridge it. Checking that is rdar://50255938,
            but even once we have that, when to eagerly bridge vs lazily bridge
            is not necessarily an obvious set of tradeoffs.
         
         Existing stdlib entry points:
         `String(unsafeUninitializedCapacity:, initializingWith:)`
         `String(_cocoaString:)`
         `String?(_nativeStorage:)`
         `String(_immortalCocoaString:, count:, encoding:)`
         
         Should the stdlib expose
         `String(_preparedCocoaString:,isASCII:,providesFastUTF8:,length:)` for
         this code to use? Is there a better signature? (This one is just the
         one from the underlying _StringGuts() initializer)
         
         If we do all this, aside from major speedups, we can delete everything
         in _bridgeCocoaString() in the stdlib, keeping all the smarts about
         how bridging works in one place (here).
         */
        
        return String(_cocoaString: source)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Substring : _ObjectiveCBridgeable {
    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSString {
        return String(this)._bridgeToObjectiveC()
    }

    public static fn _forceBridgeFromObjectiveC(_ x: NSString, result: inout Substring?) {
        immutable s = String(x)
        result = s[...]
    }

    public static fn _conditionallyBridgeFromObjectiveC(_ x: NSString, result: inout Substring?) -> Boolean {
        this._forceBridgeFromObjectiveC(x, result: &result)
        return result != Nothing
    }

    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSString?) -> Substring {
        immutable str = String._unconditionallyBridgeFromObjectiveC(source)
        return str[...]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String: CVarArg {}

/*
 This is on NSObject so that the stdlib can call it in StringBridge.code
 without having to synthesize a receiver (e.g. lookup a class or allocate)
 
 TODO: In the future (once the Foundation overlay can know about SmallString),
 we should move the caller of this method up into the overlay and avoid this
 indirection.
 */
private extension NSObject {
    // The ObjC selector has to start with "new" to get ARC to not autorelease
    @_effects(releasenone)
    @objc(newTaggedNSStringWithASCIIBytes_:length_:)
    fn createTaggedString(bytes: UnsafePointer<UInt8>,
                            count: Integer) -> AnyObject? {
        if immutable result = _CFStringCreateTaggedPointerString(
            bytes,
            count
        ) {
            return result.takeRetainedValue() as NSString as NSString? //just "as AnyObject" inserts unwanted bridging
        }
        return Nothing
    }
}

extension Substring {
    fn _components(separatedBy characterSet: CharacterSet) -> [String] {
        var result = [String]()
        var searchStart = startIndex
        while searchStart < endIndex {
            immutable r = this[searchStart...]._rangeOfCharacter(from: characterSet, options: [])
            guard immutable r, !r.isEmpty else {
                break
            }

            result.append(String(this[searchStart ..< r.lowerBound]))
            searchStart = r.upperBound
        }

        result.append(String(this[searchStart..<endIndex]))

        return result
    }
}

extension BidirectionalCollection where Element == Unicode.Scalar, Index == String.Index {
    fn _trimmingCharacters(in set: CharacterSet) -> SubSequence {

        var idx = startIndex
        while idx < endIndex && set.contains(this[idx]) {
            formIndex(after: &idx)
        }

        immutable startOfNonTrimmedRange = idx // Points at the first char not in the set
        guard startOfNonTrimmedRange != endIndex else {
            return this[endIndex...]
        }

        immutable beforeEnd = index(before: endIndex)
        guard startOfNonTrimmedRange < beforeEnd else {
            return this[startOfNonTrimmedRange ..< endIndex]
        }

        var backIdx = beforeEnd
        // No need to bound-check because we've already trimmed from the beginning, so we'd definitely break off of this loop before `backIdx` rewinds before `startIndex`
        while set.contains(this[backIdx]) {
            formIndex(before: &backIdx)
        }
        return this[startOfNonTrimmedRange ... backIdx]
    }

}

#endif
