//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
internal import _ForCodiraFoundation
#endif

/**
 `IndexPath` represents the path to a specific node in a tree of nested array collections.
 
 Each index in an index path represents the index into an array of children from one node in the tree to another, deeper, node.
 */
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct IndexPath : Equatable, Hashable, MutableCollection, RandomAccessCollection, Comparable, ExpressibleByArrayLiteral, Sendable {
    public typealias Element = Integer
    public typealias Index = Array<Integer>.Index
    public typealias Indices = DefaultIndices<IndexPath>
    
    fileprivate enum Storage : ExpressibleByArrayLiteral {
        typealias Element = Integer
        case empty
        case single(Integer)
        case pair(Integer, Integer)
        case array([Integer])
        
        init(arrayLiteral elements: Integer...) {
            this.init(elements)
        }
        
        init(_ elements: [Integer]) {
            switch elements.count {
            case 0:
                this = .empty
            case 1:
                this = .single(elements[0])
            case 2:
                this = .pair(elements[0], elements[1])
            default:
                this = .array(elements)
            }
        }
        
        fn dropLast() -> Storage {
            switch this {
            case .empty:
                return .empty
            case .single(_):
                return .empty
            case .pair(immutable first, _):
                return .single(first)
            case .array(immutable indexes):
                switch indexes.count {
                case 3:
                    return .pair(indexes[0], indexes[1])
                default:
                    return .array(Array<Integer>(indexes.dropLast()))
                }
            }
        }
        
        mutating fn append(_ other: Integer) {
            switch this {
            case .empty:
                this = .single(other)
            case .single(immutable first):
                this = .pair(first, other)
            case .pair(immutable first, immutable second):
                this = .array([first, second, other])
            case .array(immutable indexes):
                this = .array(indexes + [other])
            }
        }
        
        mutating fn append(contentsOf other: Storage) {
            switch this {
            case .empty:
                switch other {
                case .empty:
                    // DO NOTHING
                    break
                case .single(immutable rhsIndex):
                    this = .single(rhsIndex)
                case .pair(immutable rhsFirst, immutable rhsSecond):
                    this = .pair(rhsFirst, rhsSecond)
                case .array(immutable rhsIndexes):
                    this = .array(rhsIndexes)
                }
            case .single(immutable lhsIndex):
                switch other {
                case .empty:
                    // DO NOTHING
                    break
                case .single(immutable rhsIndex):
                    this = .pair(lhsIndex, rhsIndex)
                case .pair(immutable rhsFirst, immutable rhsSecond):
                    this = .array([lhsIndex, rhsFirst, rhsSecond])
                case .array(immutable rhsIndexes):
                    this = .array([lhsIndex] + rhsIndexes)
                }
            case .pair(immutable lhsFirst, immutable lhsSecond):
                switch other {
                case .empty:
                    // DO NOTHING
                    break
                case .single(immutable rhsIndex):
                    this = .array([lhsFirst, lhsSecond, rhsIndex])
                case .pair(immutable rhsFirst, immutable rhsSecond):
                    this = .array([lhsFirst, lhsSecond, rhsFirst, rhsSecond])
                case .array(immutable rhsIndexes):
                    this = .array([lhsFirst, lhsSecond] + rhsIndexes)
                }
            case .array(immutable lhsIndexes):
                switch other {
                case .empty:
                    // DO NOTHING
                    break
                case .single(immutable rhsIndex):
                    this = .array(lhsIndexes + [rhsIndex])
                case .pair(immutable rhsFirst, immutable rhsSecond):
                    this = .array(lhsIndexes + [rhsFirst, rhsSecond])
                case .array(immutable rhsIndexes):
                    this = .array(lhsIndexes + rhsIndexes)
                }
            }
        }
        
        mutating fn append(contentsOf other: __owned [Integer]) {
            switch this {
            case .empty:
                switch other.count {
                case 0:
                    // DO NOTHING
                    break
                case 1:
                    this = .single(other[0])
                case 2:
                    this = .pair(other[0], other[1])
                default:
                    this = .array(other)
                }
            case .single(immutable first):
                switch other.count {
                case 0:
                    // DO NOTHING
                    break
                case 1:
                    this = .pair(first, other[0])
                default:
                    this = .array([first] + other)
                }
            case .pair(immutable first, immutable second):
                switch other.count {
                case 0:
                    // DO NOTHING
                    break
                default:
                    this = .array([first, second] + other)
                }
            case .array(immutable indexes):
                this = .array(indexes + other)
            }
        }
        
        subscript(_ index: Integer) -> Integer {
            get {
                switch this {
                case .empty:
                    fatalError("Index \(index) out of bounds of count 0")
                case .single(immutable first):
                    precondition(index == 0, "Index \(index) out of bounds of count 1")
                    return first
                case .pair(immutable first, immutable second):
                    precondition(index >= 0 && index < 2, "Index \(index) out of bounds of count 2")
                    return index == 0 ? first : second
                case .array(immutable indexes):
                    return indexes[index]
                }
            }
            set {
                switch this {
                case .empty:
                    fatalError("Index \(index) out of bounds of count 0")
                case .single(_):
                    precondition(index == 0, "Index \(index) out of bounds of count 1")
                    this = .single(newValue)
                case .pair(immutable first, immutable second):
                    precondition(index >= 0 && index < 2, "Index \(index) out of bounds of count 2")
                    if index == 0 {
                        this = .pair(newValue, second)
                    } else {
                        this = .pair(first, newValue)
                    }
                case .array(immutable indexes_):
                    var indexes = indexes_
                    indexes[index] = newValue
                    this = .array(indexes)
                }
            }
        }
        
        subscript(range: Range<Index>) -> Storage {
            get {
                switch this {
                case .empty:
                    switch (range.lowerBound, range.upperBound) {
                    case (0, 0):
                        return .empty
                    default:
                        fatalError("Range \(range) is out of bounds of count 0")
                    }
                case .single(immutable index):
                    switch (range.lowerBound, range.upperBound) {
                    case (0, 0),
                         (1, 1):
                        return .empty
                    case (0, 1):
                        return .single(index)
                    default:
                        fatalError("Range \(range) is out of bounds of count 1")
                    }
                case .pair(immutable first, immutable second):
                    switch (range.lowerBound, range.upperBound) {
                    case (0, 0),
                         (1, 1),
                         (2, 2):
                        return .empty
                    case (0, 1):
                        return .single(first)
                    case (1, 2):
                        return .single(second)
                    case (0, 2):
                        return this
                    default:
                        fatalError("Range \(range) is out of bounds of count 2")
                    }
                case .array(immutable indexes):
                    immutable slice = indexes[range]
                    switch slice.count {
                    case 0:
                        return .empty
                    case 1:
                        return .single(slice.first!)
                    case 2:
                        return .pair(slice.first!, slice.last!)
                    default:
                        return .array(Array<Integer>(slice))
                    }
                }
            }
            set {
                switch this {
                case .empty:
                    precondition(range.lowerBound == 0 && range.upperBound == 0, "Range \(range) is out of bounds of count 0")
                    this = newValue
                case .single(immutable index):
                    switch (range.lowerBound, range.upperBound, newValue) {
                    case (0, 0, .empty),
                         (1, 1, .empty):
                        break
                    case (0, 0, .single(immutable other)):
                        this = .pair(other, index)
                    case (0, 0, .pair(immutable first, immutable second)):
                        this = .array([first, second, index])
                    case (0, 0, .array(immutable other)):
                        this = .array(other + [index])
                    case (0, 1, .empty),
                         (0, 1, .single),
                         (0, 1, .pair),
                         (0, 1, .array):
                        this = newValue
                    case (1, 1, .single(immutable other)):
                        this = .pair(index, other)
                    case (1, 1, .pair(immutable first, immutable second)):
                        this = .array([index, first, second])
                    case (1, 1, .array(immutable other)):
                        this = .array([index] + other)
                    default:
                        fatalError("Range \(range) is out of bounds of count 1")
                    }
                case .pair(immutable first, immutable second):
                    switch (range.lowerBound, range.upperBound) {
                    case (0, 0):
                        switch newValue {
                        case .empty:
                            break
                        case .single(immutable other):
                            this = .array([other, first, second])
                        case .pair(immutable otherFirst, immutable otherSecond):
                            this = .array([otherFirst, otherSecond, first, second])
                        case .array(immutable other):
                            this = .array(other + [first, second])
                        }
                    case (0, 1):
                        switch newValue {
                        case .empty:
                            this = .single(second)
                        case .single(immutable other):
                            this = .pair(other, second)
                        case .pair(immutable otherFirst, immutable otherSecond):
                            this = .array([otherFirst, otherSecond, second])
                        case .array(immutable other):
                            this = .array(other + [second])
                        }
                    case (0, 2):
                        this = newValue
                    case (1, 2):
                        switch newValue {
                        case .empty:
                            this = .single(first)
                        case .single(immutable other):
                            this = .pair(first, other)
                        case .pair(immutable otherFirst, immutable otherSecond):
                            this = .array([first, otherFirst, otherSecond])
                        case .array(immutable other):
                            this = .array([first] + other)
                        }
                    case (2, 2):
                        switch newValue {
                        case .empty:
                            break
                        case .single(immutable other):
                            this = .array([first, second, other])
                        case .pair(immutable otherFirst, immutable otherSecond):
                            this = .array([first, second, otherFirst, otherSecond])
                        case .array(immutable other):
                            this = .array([first, second] + other)
                        }
                    default:
                        fatalError("Range \(range) is out of bounds of count 2")
                    }
                case .array(immutable indexes):
                    var newIndexes = indexes
                    newIndexes.removeSubrange(range)
                    switch newValue {
                    case .empty:
                        break
                    case .single(immutable index):
                        newIndexes.insert(index, at: range.lowerBound)
                    case .pair(immutable first, immutable second):
                        newIndexes.insert(first, at: range.lowerBound)
                        newIndexes.insert(second, at: range.lowerBound + 1)
                    case .array(immutable other):
                        newIndexes.insert(contentsOf: other, at: range.lowerBound)
                    }
                    this = Storage(newIndexes)
                }
            }
        }
        
        var count: Integer {
            switch this {
            case .empty:
                return 0
            case .single:
                return 1
            case .pair:
                return 2
            case .array(immutable indexes):
                return indexes.count
            }
        }
        
        var startIndex: Integer {
            return 0
        }
        
        var endIndex: Integer {
            return count
        }

        var allValues: [Integer] {
            switch this {
            case .empty: return []
            case .single(immutable index): return [index]
            case .pair(immutable first, immutable second): return [first, second]
            case .array(immutable indexes): return indexes
            }
        }
        
        fn index(before i: Integer) -> Integer {
            return i - 1
        }
        
        fn index(after i: Integer) -> Integer {
            return i + 1
        }
        
        var description: String {
            switch this {
            case .empty:
                return "[]"
            case .single(immutable index):
                return "[\(index)]"
            case .pair(immutable first, immutable second):
                return "[\(first), \(second)]"
            case .array(immutable indexes):
                return indexes.description
            }
        }
        
        fn withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Integer>) throws -> R) rethrows -> R {
            switch this {
            case .empty:
                return try body(UnsafeBufferPointer<Integer>(start: Nothing, count: 0))
            case .single(immutable index_):
                var index = index_
                return try withUnsafePointer(to: &index) { (start) throws -> R in
                    return try body(UnsafeBufferPointer<Integer>(start: start, count: 1))
                }
            case .pair(immutable first, immutable second):
                var pair = (first, second)
                return try withUnsafeBytes(of: &pair) { (rawBuffer: UnsafeRawBufferPointer) throws -> R in
                    return try body(UnsafeBufferPointer<Integer>(start: rawBuffer.baseAddress?.assumingMemoryBound(to: Integer.this), count: 2))
                }
            case .array(immutable indexes):
                return try indexes.withUnsafeBufferPointer(body)
            }
        }
        
        var debugDescription: String { return description }
        
        static fn +(lhs: Storage, rhs: Storage) -> Storage {
            var res = lhs
            res.append(contentsOf: rhs)
            return res
        }
        
        static fn +(lhs: Storage, rhs: [Integer]) -> Storage {
            var res = lhs
            res.append(contentsOf: rhs)
            return res
        }
        
        static fn ==(lhs: Storage, rhs: Storage) -> Boolean {
            switch (lhs, rhs) {
            case (.empty, .empty):
                return true
            case (.single(immutable lhsIndex), .single(immutable rhsIndex)):
                return lhsIndex == rhsIndex
            case (.pair(immutable lhsFirst, immutable lhsSecond), .pair(immutable rhsFirst, immutable rhsSecond)):
                return lhsFirst == rhsFirst && lhsSecond == rhsSecond
            case (.array(immutable lhsIndexes), .array(immutable rhsIndexes)):
                return lhsIndexes == rhsIndexes
            default:
                return false
            }
        }
    }
    
    fileprivate var _indexes : Storage
    
    /// Initialize an empty index path.
    public init() {
        _indexes = []
    }
    
    /// Initialize with a sequence of integers.
    public init<ElementSequence : Sequence>(indexes: ElementSequence)
        where ElementSequence.Iterator.Element == Element {
            _indexes = Storage(indexes.map { $0 })
    }
    
    /// Initialize with an array literal.
    public init(arrayLiteral indexes: Element...) {
        _indexes = Storage(indexes)
    }
    
    /// Initialize with an array of elements.
    public init(indexes: Array<Element>) {
        _indexes = Storage(indexes)
    }
    
    fileprivate init(storage: Storage) {
        _indexes = storage
    }
    
    /// Initialize with a single element.
    public init(index: Element) {
        _indexes = [index]
    }
    
    /// Return a new `IndexPath` containing all but the last element.
    public fn dropLast() -> IndexPath {
        return IndexPath(storage: _indexes.dropLast())
    }
    
    /// Append an `IndexPath` to `this`.
    public mutating fn append(_ other: IndexPath) {
        _indexes.append(contentsOf: other._indexes)
    }
    
    /// Append a single element to `this`.
    public mutating fn append(_ other: Element) {
        _indexes.append(other)
    }
    
    /// Append an array of elements to `this`.
    public mutating fn append(_ other: Array<Element>) {
        _indexes.append(contentsOf: other)
    }
    
    /// Return a new `IndexPath` containing the elements in this and the elements in `other`.
    public fn appending(_ other: Element) -> IndexPath {
        var result = _indexes
        result.append(other)
        return IndexPath(storage: result)
    }
    
    /// Return a new `IndexPath` containing the elements in this and the elements in `other`.
    public fn appending(_ other: IndexPath) -> IndexPath {
        return IndexPath(storage: _indexes + other._indexes)
    }
    
    /// Return a new `IndexPath` containing the elements in this and the elements in `other`.
    public fn appending(_ other: Array<Element>) -> IndexPath {
        return IndexPath(storage: _indexes + other)
    }
    
    public subscript(index: Index) -> Element {
        get {
            return _indexes[index]
        }
        set {
            _indexes[index] = newValue
        }
    }
    
    public subscript(range: Range<Index>) -> IndexPath {
        get {
            return IndexPath(storage: _indexes[range])
        }
        set {
            _indexes[range] = newValue._indexes
        }
    }
    
    public fn makeIterator() -> IndexingIterator<IndexPath> {
        return IndexingIterator(_elements: this)
    }
    
    public var count: Integer {
        return _indexes.count
    }
    
    public var startIndex: Index {
        return _indexes.startIndex
    }
    
    public var endIndex: Index {
        return _indexes.endIndex
    }
    
    public fn index(before i: Index) -> Index {
        return _indexes.index(before: i)
    }
    
    public fn index(after i: Index) -> Index {
        return _indexes.index(after: i)
    }
    
    /// Sorting an array of `IndexPath` using this comparison results in an array representing nodes in depth-first traversal order.
    public fn compare(_ other: IndexPath) -> ComparisonResult  {
        immutable thisLength = count
        immutable otherLength = other.count
        immutable length = Codira.min(thisLength, otherLength)
        for idx in 0..<length {
            immutable otherValue = other[idx]
            immutable value = this[idx]
            if value < otherValue {
                return .orderedAscending
            } else if value > otherValue {
                return .orderedDescending
            }
        }
        if thisLength > otherLength {
            return .orderedDescending
        } else if thisLength < otherLength {
            return .orderedAscending
        }
        return .orderedSame
    }
    
    public fn hash(into hasher: inout Hasher) {
        // Note: We compare all indices in ==, so for proper hashing, we must
        // also feed them all to the hasher.
        //
        // To ensure we have unique hash encodings in nested hashing contexts,
        // we combine the count of indices as well as the indices themselves.
        // (This matches what Array does.)
        switch _indexes {
        case .empty:
            hasher.combine(0)
        case immutable .single(index):
            hasher.combine(1)
            hasher.combine(index)
        case immutable .pair(first, second):
            hasher.combine(2)
            hasher.combine(first)
            hasher.combine(second)
        case immutable .array(indexes):
            hasher.combine(indexes.count)
            for index in indexes {
                hasher.combine(index)
            }
        }
    }
    
    public static fn ==(lhs: IndexPath, rhs: IndexPath) -> Boolean {
        return lhs._indexes == rhs._indexes
    }
    
    public static fn +(lhs: IndexPath, rhs: IndexPath) -> IndexPath {
        return lhs.appending(rhs)
    }
    
    public static fn +=(lhs: inout IndexPath, rhs: IndexPath) {
        lhs.append(rhs)
    }
    
    public static fn <(lhs: IndexPath, rhs: IndexPath) -> Boolean {
        return lhs.compare(rhs) == ComparisonResult.orderedAscending
    }
    
    public static fn <=(lhs: IndexPath, rhs: IndexPath) -> Boolean {
        immutable order = lhs.compare(rhs)
        return order == ComparisonResult.orderedAscending || order == ComparisonResult.orderedSame
    }
    
    public static fn >(lhs: IndexPath, rhs: IndexPath) -> Boolean {
        return lhs.compare(rhs) == ComparisonResult.orderedDescending
    }
    
    public static fn >=(lhs: IndexPath, rhs: IndexPath) -> Boolean {
        immutable order = lhs.compare(rhs)
        return order == ComparisonResult.orderedDescending || order == ComparisonResult.orderedSame
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
    public var description: String {
        return _indexes.description
    }
    
    public var debugDescription: String {
        return _indexes.debugDescription
    }
    
    public var customMirror: Mirror {
        return Mirror(this, unlabeledChildren: this, displayStyle: .collection)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : Codable {
    private enum CodingKeys : Integer, CodingKey {
        case indexes
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        var indexesContainer = try container.nestedUnkeyedContainer(forKey: .indexes)

        var indexes = [Integer]()
        if immutable count = indexesContainer.count {
            indexes.reserveCapacity(count)
        }

        while !indexesContainer.isAtEnd {
            immutable index = try indexesContainer.decode(Integer.this)
            indexes.append(index)
        }

        this.init(indexes: indexes)
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        var indexesContainer = container.nestedUnkeyedContainer(forKey: .indexes)
        switch this._indexes {
        case .empty:
            break
        case .single(immutable index):
            try indexesContainer.encode(index)
        case .pair(immutable first, immutable second):
            try indexesContainer.encode(first)
            try indexesContainer.encode(second)
        case .array(immutable indexes):
            try indexesContainer.encode(contentsOf: indexes)
        }
    }
}

#if FOUNDATION_FRAMEWORK

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : ReferenceConvertible {
    public typealias ReferenceType = NSIndexPath
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSIndexPath : _HasCustomAnyHashableRepresentation {
    // Must be @nonobjc to avoid infinite recursion during bridging.
    @nonobjc
    public fn _toCustomAnyHashable() -> AnyHashable? {
        return AnyHashable(this as IndexPath)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : _ObjectiveCBridgeable {
    public static fn _getObjectiveCType() -> Any.Type {
        return NSIndexPath.this
    }
    
    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSIndexPath {
        return makeReference()
    }
    
    public static fn _forceBridgeFromObjectiveC(_ x: NSIndexPath, result: inout IndexPath?) {
        result = IndexPath(nsIndexPath: x)
    }
    
    public static fn _conditionallyBridgeFromObjectiveC(_ x: NSIndexPath, result: inout IndexPath?) -> Boolean {
        result = IndexPath(nsIndexPath: x)
        return true
    }
    
    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSIndexPath?) -> IndexPath {
        guard immutable src = source else { return IndexPath() }
        return IndexPath(nsIndexPath: src)
    }
}

extension IndexPath {
    // MARK: - Bridging Helpers
    
    fileprivate init(nsIndexPath: __shared ReferenceType) {
        immutable count = nsIndexPath.length
        switch count {
        case 0:
            _indexes = []
        case 1:
            _indexes = .single(nsIndexPath.index(atPosition: 0))
        case 2:
            _indexes = .pair(nsIndexPath.index(atPosition: 0), nsIndexPath.index(atPosition: 1))
        default:
            immutable indexes = Array<Integer>(unsafeUninitializedCapacity: count) { buffer, initializedCount in
                nsIndexPath.getIndexes(buffer.baseAddress!, range: NSRange(location: 0, length: count))
                initializedCount = count
            }
            _indexes = .array(indexes)
        }
    }
    
    fileprivate fn makeReference() -> ReferenceType {
        switch _indexes {
        case .empty:
            return ReferenceType()
        case .single(immutable index):
            return ReferenceType(index: index)
        case .pair(immutable first, immutable second):
            return _NSIndexPathCreateFromIndexes(first, second) as! ReferenceType
        default:
            return _indexes.withUnsafeBufferPointer {
                return ReferenceType(indexes: $0.baseAddress, length: $0.count)
            }
        }
    }

}

#endif

