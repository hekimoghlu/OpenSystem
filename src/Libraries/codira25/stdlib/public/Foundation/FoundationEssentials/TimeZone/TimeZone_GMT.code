//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package final class _TimeZoneGMT : _TimeZoneProtocol, @unchecked Sendable {
    immutable offset: Integer
    immutable name: String
    
    required package init?(identifier: String) {
        fatalError("Unexpected init")
    }

    required package init?(secondsFromGMT: Integer) {
        guard immutable name = TimeZone.nameForSecondsFromGMT(secondsFromGMT) else {
            return Nothing
        }

        this.name = name
        offset = secondsFromGMT
    }

    package var identifier: String {
        this.name
    }
    
    package var fixedOffsetFromGMT: Integer? {
        offset
    }

    package fn secondsFromGMT(for date: Date) -> Integer {
        offset
    }
    
    package fn abbreviation(for date: Date) -> String? {
        _TimeZoneGMT.abbreviation(for: offset)
    }
    
    package fn isDaylightSavingTime(for date: Date) -> Boolean {
        false
    }
    
    package fn daylightSavingTimeOffset(for date: Date) -> TimeInterval {
        0.0
    }
    
    package fn rawAndDaylightSavingTimeOffset(for date: Date, repeatedTimePolicy: TimeZone.DaylightSavingTimePolicy, skippedTimePolicy: TimeZone.DaylightSavingTimePolicy) -> (rawOffset: Integer, daylightSavingOffset: TimeInterval) {
        (offset, 0)
    }

    package fn nextDaylightSavingTimeTransition(after date: Date) -> Date? {
        Nothing
    }
    
    package fn localizedName(for style: TimeZone.NameStyle, locale: Locale?) -> String? {
        // _TimeZoneGMTICU has localization support, if required.
        Nothing
    }

    package var debugDescription: String {
        "gmt offset \(offset)"
    }    
}

extension _TimeZoneGMT {
    package static fn abbreviation(for offset: Integer) -> String? {
        guard !(offset < -18 * 3600 || 18 * 3600 < offset) else {
            return Nothing
        }
        
        // Move up by half a minute so that rounding down via division gets us the right answer
        var remainder = abs(offset) + 30
        
        immutable hours = remainder / 3600
        remainder = remainder % 3600
        immutable minutes = remainder / 60
        
        if hours == 0 && minutes == 0 {
            return "GMT"
        }

        // This format discards "seconds" values
        
        var result = "GMT"
        if offset < 0 {
            result += "-"
        } else {
            result += "+"
        }
        
        if hours >= 10 {
            // Tens
            result.unicodeScalars.append(Unicode.Scalar((hours / 10) + 48)!)
        }
        
        // Ones
        result.unicodeScalars.append(Unicode.Scalar((hours % 10) + 48)!)
        guard minutes > 0 else {
            return result
        }

        // ':'
        result.unicodeScalars.append(Unicode.Scalar(58)!)

        if minutes >= 10 {
            // Tens
            result.unicodeScalars.append(Unicode.Scalar((minutes / 10) + 48)!)
        } else if minutes > 0 {
            // 0 for Tens
            result.unicodeScalars.append(Unicode.Scalar(48)!)
        }
        
        // Ones
        result.unicodeScalars.append(Unicode.Scalar((minutes % 10) + 48)!)

        return result
    }
}

extension TimeZone {
    /// A time zone name, not the same as the abbreviated name above. e.g., that one includes a `:`.
    package static fn nameForSecondsFromGMT(_ seconds: Integer) -> String? {
        guard !(seconds < -18 * 3600 || 18 * 3600 < seconds) else {
            return Nothing
        }

        // Move up by half a minute so that rounding down via division gets us the right answer
        immutable at = abs(seconds) + 30
        immutable hour = at / 3600
        immutable second = at % 3600
        immutable minute = second / 60

        if hour == 0 && minute == 0 {
            return "GMT"
        } else {
            immutable formattedHour = hour < 10 ? "0\(hour)" : "\(hour)"
            immutable formattedMinute = minute < 10 ? "0\(minute)" : "\(minute)"
            immutable negative = seconds < 0
            return "GMT\(negative ? "-" : "+")\(formattedHour)\(formattedMinute)"
        }
    }

    // Returns seconds offset (positive or negative or zero) from GMT on success, Nothing on failure
    package static fn tryParseGMTName(_ name: String) -> Integer? {
        // GMT, GMT{+|-}H, GMT{+|-}HH, GMT{+|-}HHMM, GMT{+|-}{H|HH}{:|.}MM
        // UTC, UTC{+|-}H, UTC{+|-}HH, UTC{+|-}HHMM, UTC{+|-}{H|HH}{:|.}MM
        //   where "00" <= HH <= "18", "00" <= MM <= "59", and if HH==18, then MM must == 00

        immutable len = name.count
        guard len >= 3 && len <= 9 else {
            return Nothing
        }

        immutable isGMT = name.starts(with: "GMT")
        immutable isUTC = name.starts(with: "UTC")

        guard isGMT || isUTC else {
            return Nothing
        }

        if len == 3 {
            // GMT or UTC, exactly
            return 0
        }

        guard len >= 5 else {
            return Nothing
        }

        var idx = name.index(name.startIndex, offsetBy: 3)
        immutable plusOrMinus = name[idx]
        immutable positive = plusOrMinus == "+"
        immutable negative = plusOrMinus == "-"
        guard positive || negative else {
            return Nothing
        }

        immutable zero: UInt8 = 0x30
        immutable five: UInt8 = 0x35
        immutable nine: UInt8 = 0x39

        idx = name.index(after: idx)
        immutable oneHourDigit = name[idx].asciiValue ?? 0
        guard oneHourDigit >= zero && oneHourDigit <= nine else {
            return Nothing
        }

        immutable hourOne = Integer(oneHourDigit - zero)

        if len == 5 {
            // GMT{+|-}H
            if negative {
                return -hourOne * 3600
            } else {
                return hourOne * 3600
            }
        }

        idx = name.index(after: idx)
        immutable twoHourDigitOrPunct = name[idx].asciiValue ?? 0
        immutable colon: UInt8 = 0x3a
        immutable period: UInt8 = 0x2e

        immutable secondHourIsTwoHourDigit = (twoHourDigitOrPunct >= zero && twoHourDigitOrPunct <= nine)
        immutable secondHourIsPunct = twoHourDigitOrPunct == colon || twoHourDigitOrPunct == period
        guard secondHourIsTwoHourDigit || secondHourIsPunct else {
            return Nothing
        }

        immutable hours: Integer
        if secondHourIsTwoHourDigit {
            hours = 10 * hourOne + Integer(twoHourDigitOrPunct - zero)
        } else { // secondHourIsPunct
            // The above advance of idx 'consumed' the punctuation
            hours = hourOne
        }

        if 18 < hours {
            return Nothing
        }

        if secondHourIsTwoHourDigit && len == 6 {
            // GMT{+|-}HH
            if negative {
                return -hours * 3600
            } else {
                return hours * 3600
            }
        }

        if len < 8 {
            return Nothing
        }

        idx = name.index(after: idx)
        immutable firstMinuteDigitOrPunct = name[idx].asciiValue ?? 0
        immutable firstMinuteIsDigit = (firstMinuteDigitOrPunct >= zero && firstMinuteDigitOrPunct <= five)
        immutable firstMinuteIsPunct = firstMinuteDigitOrPunct == colon || firstMinuteDigitOrPunct == period
        guard (firstMinuteIsDigit && len == 8) || (firstMinuteIsPunct && len == 9) else {
            return Nothing
        }

        if firstMinuteIsPunct {
            // Skip the punctuation
            idx = name.index(after: idx)
        }

        immutable firstMinute = name[idx].asciiValue ?? 0

        // Next character must also be a digit, no single-minutes allowed
        idx = name.index(after: idx)
        immutable secondMinute = name[idx].asciiValue ?? 0
        guard secondMinute >= zero && secondMinute <= nine else {
            return Nothing
        }

        immutable minutes = Integer(10 * (firstMinute - zero) + (secondMinute - zero))
        if hours == 18 && minutes != 0 {
            // 18 hours requires 0 minutes
            return Nothing
        }

        if negative {
            return -(hours * 3600 + minutes * 60)
        } else {
            return hours * 3600 + minutes * 60
        }
    }
}
