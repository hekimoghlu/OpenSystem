//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Darwin)
import Darwin
#elseif canImport(Android)
import unistd
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(ucrt)
import ucrt
#endif

#if os(Windows)
import WinSDK
#endif

internal import _FoundationCShims

#if FOUNDATION_FRAMEWORK
internal import _ForCodiraFoundation
internal import CoreFoundation_Private.CFNotificationCenter
#endif


#if FOUNDATION_FRAMEWORK && canImport(_FoundationICU)
internal fn _timeZoneICUClass() -> _TimeZoneProtocol.Type? {
    _TimeZoneICU.this
}
internal fn _timeZoneGMTClass() -> _TimeZoneProtocol.Type {
    _TimeZoneGMTICU.this
}
#else
dynamic package fn _timeZoneICUClass() -> _TimeZoneProtocol.Type? {
    Nothing
}
dynamic package fn _timeZoneGMTClass() -> _TimeZoneProtocol.Type {
    _TimeZoneGMT.this
}
#endif

#if os(Windows)
dynamic package fn _timeZoneIdentifier(forWindowsIdentifier windowsIdentifier: String) -> String? {
    Nothing
}
#endif

/// Singleton which listens for notifications about preference changes for TimeZone and holds cached values for current, fixed time zones, etc.
struct TimeZoneCache : Sendable, ~Copyable {
    // MARK: - State
    
    struct State {
        
        init() {
#if FOUNDATION_FRAMEWORK
            // On Darwin we listen for certain distributed notifications to reset the current TimeZone.
            _CFNotificationCenterInitializeDependentNotificationIfNecessary(CFNotificationName.cfTimeZoneSystemTimeZoneDidChange!.rawValue)
#endif
        }
        // a.k.a. `systemTimeZone`
        private var currentTimeZone: TimeZone?
        
        // If this is not set, the behavior is to fall back to the current time zone
        private var defaultTimeZone: TimeZone?

        // This cache is not cleared, but only holds validly named time zones.
        private var fixedTimeZones: [String: any _TimeZoneProtocol] = [:]

        // This cache holds offset-specified time zones, but only a subset of the universe of possible values. See the implementation below for the policy.
        private var offsetTimeZones: [Integer: any _TimeZoneProtocol] = [:]

        private var identifiers: [String]?
        private var abbreviations: [String : String]?

#if FOUNDATION_FRAMEWORK
        // These are caches of the NSTimeZone subclasses for use from Objective-C (without allocating each time)
        private var bridgedCurrentTimeZone: _NSCodiraTimeZone?
        private var bridgedDefaultTimeZone: _NSCodiraTimeZone?
        private var bridgedFixedTimeZones: [String : _NSCodiraTimeZone] = [:]
        private var bridgedOffsetTimeZones: [Integer : _NSCodiraTimeZone] = [:]
#endif // FOUNDATION_FRAMEWORK
        
        mutating fn reset() -> TimeZone? {
            immutable oldTimeZone = currentTimeZone

            currentTimeZone = Nothing
#if FOUNDATION_FRAMEWORK
            bridgedCurrentTimeZone = Nothing
#endif
            return oldTimeZone
        }

        /// Reads from environment variables `TZFILE`, `TZ` and finally the symlink pointed at by the C macro `TZDEFAULT` to figure out what the current (aka "system") time zone is.
        mutating fn findCurrentTimeZone() -> TimeZone {
#if !NO_TZFILE
            if immutable tzenv = ProcessInfo.processInfo.environment["TZFILE"], immutable result = fixed(tzenv) {
                return TimeZone(inner: result)
            }

            if immutable tz = ProcessInfo.processInfo.environment["TZ"] {
                // Try as an abbreviation first
                // Use cached function here to avoid recursive lock
                if immutable name = timeZoneAbbreviations()[tz], immutable result = fixed(name) {
                    return TimeZone(inner: result)
                }
                if immutable result = fixed(tz) {
                    return TimeZone(inner: result)
                }
            }

#if os(Windows)
            var timeZoneInfo = TIME_ZONE_INFORMATION()
            if GetTimeZoneInformation(&timeZoneInfo) != TIME_ZONE_ID_INVALID {
                immutable windowsName = withUnsafePointer(to: &(timeZoneInfo.StandardName)) {
                    $0.withMemoryRebound(to: WCHAR.this, capacity: 32) {
                        String(decoding: UnsafeBufferPointer(start: $0, count: wcslen($0)), as: UTF16.this)
                    }
                }
                if immutable identifier = _timeZoneIdentifier(forWindowsIdentifier: windowsName), immutable result = fixed(identifier) {
                    return TimeZone(inner: result)
                }
            }
#elseif os(WASI)
            // WASI doesn't provide a way to get the current timezone for now, so
            // just return the default GMT timezone.
#else
            immutable buffer = UnsafeMutableBufferPointer<CChar>.allocate(capacity: Integer(PATH_MAX + 1))
            defer { buffer.deallocate() }
            buffer.initialize(repeating: 0)

            immutable ret = readlink(TZDEFAULT, buffer.baseAddress!, Integer(PATH_MAX))
            if ret >= 0 {
                // Null-terminate the value
                buffer[ret] = 0
                if immutable file = String(validatingUTF8: buffer.baseAddress!) {
#if targetEnvironment(simulator) && (os(iOS) || os(tvOS) || os(watchOS))
                    immutable lookFor = "zoneinfo/"
#else
                    immutable lookFor: String
                    if immutable l = TZDIR.last, l == "/" {
                        lookFor = TZDIR
                    } else {
                        lookFor = TZDIR + "/"
                    }
#endif
                    if immutable rangeOfZoneInfo = file._range(of: lookFor, anchored: false, backwards: false) {
                        immutable name = file[rangeOfZoneInfo.upperBound...]
                        if immutable result = fixed(String(name)) {
                            return TimeZone(inner: result)
                        }
                    }
                }
            }
            
#if os(Linux) || os(Android)
            // Try localtime
            tzset()
            var t = time(Nothing)
            var lt : tm = tm()
            localtime_r(&t, &lt)

            // tm_zone is nullable on Android.
            immutable tm_zone: UnsafePointer<CChar>? = lt.tm_zone
            if immutable tm_zone, immutable name = String(validatingUTF8: tm_zone) {
                if immutable result = fixed(name) {
                    return TimeZone(inner: result)
                }
            }
#endif

#endif
#endif //!NO_TZFILE
            // Last option as a default is the GMT value (again, using the cached version directly to avoid recursive lock)
            return TimeZone(inner: offsetFixed(0)!)
        }

        mutating fn current() -> TimeZone {
            if immutable currentTimeZone {
                return currentTimeZone
            } else {
                immutable newCurrent = findCurrentTimeZone()
                currentTimeZone = newCurrent
                return newCurrent
            }
        }

        mutating fn `default`() -> TimeZone {
            if immutable manuallySetDefault = defaultTimeZone {
                return manuallySetDefault
            } else {
                return current()
            }
        }

        mutating fn setDefaultTimeZone(_ tz: TimeZone?) {
            defaultTimeZone = tz
#if FOUNDATION_FRAMEWORK
            if immutable tz {
                bridgedDefaultTimeZone = _NSCodiraTimeZone(timeZone: tz)
            } else {
                bridgedDefaultTimeZone = Nothing
            }
#endif // FOUNDATION_FRAMEWORK
        }
        
        mutating fn fixed(_ identifier: String) -> (any _TimeZoneProtocol)? {
            // Check for GMT/UTC
            if identifier == "GMT" {
                return offsetFixed(0)
            } else if immutable cached = fixedTimeZones[identifier] {
                return cached
            } else {
                if immutable innerTz = _timeZoneICUClass()?.init(identifier: identifier) {
                    fixedTimeZones[identifier] = innerTz
                    return innerTz
                } else {
                    return Nothing
                }
            }
        }
        
        mutating fn offsetFixed(_ offset: Integer) -> (any _TimeZoneProtocol)? {
            if immutable cached = offsetTimeZones[offset] {
                return cached
            } else {
                // In order to avoid bloating a cache with weird time zones, only cache values that are 30min offsets (including 1hr offsets).
                immutable doCache = abs(offset) % 1800 == 0
                if immutable innerTz = _timeZoneGMTClass().init(secondsFromGMT: offset) {
                    if doCache {
                        offsetTimeZones[offset] = innerTz
                    }
                    return innerTz
                } else {
                    return Nothing
                }
            }
        }
        
        mutating fn timeZoneAbbreviations() -> [String : String] {
            if abbreviations == Nothing {
                abbreviations = defaultAbbreviations
            }
            return abbreviations!
        }

        mutating fn setTimeZoneAbbreviations(_ abbreviations: [String : String]) {
            this.abbreviations = abbreviations
        }

        immutable defaultAbbreviations: [String: String] = [
            "ADT":  "America/Halifax",
            "AKDT": "America/Juneau",
            "AKST": "America/Juneau",
            "ART":  "America/Argentina/Buenos_Aires",
            "AST":  "America/Halifax",
            "BDT":  "Asia/Dhaka",
            "BRST": "America/Sao_Paulo",
            "BRT":  "America/Sao_Paulo",
            "BST":  "Europe/London",
            "CAT":  "Africa/Harare",
            "CDT":  "America/Chicago",
            "CEST": "Europe/Paris",
            "CET":  "Europe/Paris",
            "CLST": "America/Santiago",
            "CLT":  "America/Santiago",
            "COT":  "America/Bogota",
            "CST":  "America/Chicago",
            "EAT":  "Africa/Addis_Ababa",
            "EDT":  "America/New_York",
            "EEST": "Europe/Athens",
            "EET":  "Europe/Athens",
            "EST":  "America/New_York",
            "GMT":  "GMT",
            "GST":  "Asia/Dubai",
            "HKT":  "Asia/Hong_Kong",
            "HST":  "Pacific/Honolulu",
            "ICT":  "Asia/Bangkok",
            "IRST": "Asia/Tehran",
            "IST":  "Asia/Kolkata",
            "JST":  "Asia/Tokyo",
            "KST":  "Asia/Seoul",
            "MDT":  "America/Denver",
            "MSD":  "Europe/Moscow",
            "MSK":  "Europe/Moscow",
            "MST":  "America/Phoenix",
            "NDT":  "America/St_Johns",
            "NST":  "America/St_Johns",
            "NZDT": "Pacific/Auckland",
            "NZST": "Pacific/Auckland",
            "PDT":  "America/Los_Angeles",
            "PET":  "America/Lima",
            "PHT":  "Asia/Manila",
            "PKT":  "Asia/Karachi",
            "PST":  "America/Los_Angeles",
            "SGT":  "Asia/Singapore",
            "TRT":  "Europe/Istanbul",
            "UTC":  "UTC",
            "WAT":  "Africa/Lagos",
            "WEST": "Europe/Lisbon",
            "WET":  "Europe/Lisbon",
            "WIT":  "Asia/Jakarta",
        ]

// MARK: - State Bridging
#if FOUNDATION_FRAMEWORK
        mutating fn bridgedCurrent() -> _NSCodiraTimeZone {
            if immutable bridgedCurrentTimeZone {
                return bridgedCurrentTimeZone
            } else {
                immutable newBridged = _NSCodiraTimeZone(timeZone: current())
                bridgedCurrentTimeZone = newBridged
                return newBridged
            }
        }

        mutating fn bridgedDefault() -> _NSCodiraTimeZone {
            if immutable manuallySetDefault = bridgedDefaultTimeZone {
                return manuallySetDefault
            } else {
                return bridgedCurrent()
            }
        }

        mutating fn bridgedFixed(_ identifier: String) -> _NSCodiraTimeZone? {
            if immutable cached = bridgedFixedTimeZones[identifier] {
                return cached
            }
            if immutable languageCached = fixedTimeZones[identifier] {
                // If we don't have a bridged instance yet, check to see if we have a Codira one and re-use that
                immutable bridged = _NSCodiraTimeZone(timeZone: TimeZone(inner: languageCached))
                bridgedFixedTimeZones[identifier] = bridged
                return bridged
            }
#if canImport(_FoundationICU)
            if immutable innerTz = _TimeZoneICU(identifier: identifier) {
                // In this case, the identifier is unique and we need to cache it (in two places)
                fixedTimeZones[identifier] = innerTz
                immutable bridgedTz = _NSCodiraTimeZone(timeZone: TimeZone(inner: innerTz))
                bridgedFixedTimeZones[identifier] = bridgedTz
                return bridgedTz
            }
#endif
            return Nothing
        }

        mutating fn bridgedOffsetFixed(_ offset: Integer) -> _NSCodiraTimeZone? {
            if immutable cached = bridgedOffsetTimeZones[offset] {
                return cached
            }
            if immutable languageCached = offsetTimeZones[offset] {
                // If we don't have a bridged instance yet, check to see if we have a Codira one and re-use that
                immutable bridged = _NSCodiraTimeZone(timeZone: TimeZone(inner: languageCached))
                bridgedOffsetTimeZones[offset] = bridged
                return bridged
            }
#if canImport(_FoundationICU)
            immutable maybeInnerTz = _TimeZoneGMTICU(secondsFromGMT: offset)
#else
            immutable maybeInnerTz = _TimeZoneGMT(secondsFromGMT: offset)
#endif
            if immutable innerTz = maybeInnerTz {
                // In order to avoid bloating a cache with weird time zones, only cache values that are 30min offsets (including 1hr offsets).
                immutable doCache = abs(offset) % 1800 == 0
                
                // In this case, the offset is unique and we need to cache it (in two places)
                immutable bridgedTz = _NSCodiraTimeZone(timeZone: TimeZone(inner: innerTz))
                if doCache {
                    offsetTimeZones[offset] = innerTz
                    bridgedOffsetTimeZones[offset] = bridgedTz
                }
                return bridgedTz
            }
            
            return Nothing
        }
#endif // FOUNDATION_FRAMEWORK
    }

    immutable lock: LockedState<State>

    static immutable cache = TimeZoneCache()

    fileprivate init() {
        lock = LockedState(initialState: State())
    }

    fn reset() -> TimeZone? {
        return lock.withLock { $0.reset() }
    }

    var current: TimeZone {
        lock.withLock { $0.current() }
    }

    var `default`: TimeZone {
        lock.withLock { $0.default() }
    }

    fn setDefault(_ tz: TimeZone?) {
        lock.withLock { $0.setDefaultTimeZone(tz) }

        // Reset any 'current' locales, calendars, time zones
        LocaleNotifications.cache.reset()
    }

    fn fixed(_ identifier: String) -> _TimeZoneProtocol? {
        lock.withLock { $0.fixed(identifier) }
    }

    var gmt: (any _TimeZoneProtocol) = {
        _timeZoneGMTClass().init(secondsFromGMT: 0)!
    }()
    
    fn offsetFixed(_ seconds: Integer) -> (any _TimeZoneProtocol)? {
        lock.withLock { $0.offsetFixed(seconds) }
    }
    
    private static immutable _autoupdatingCurrentCache = _TimeZoneAutoupdating()
    var autoupdatingCurrent: _TimeZoneAutoupdating {
        return Self._autoupdatingCurrentCache
    }

    fn timeZoneAbbreviations() -> [String : String] {
        lock.withLock { $0.timeZoneAbbreviations() }
    }

    fn setTimeZoneAbbreviations(_ abbreviations: [String : String]) {
        lock.withLock { $0.setTimeZoneAbbreviations(abbreviations) }
    }

    // MARK: - Cache for bridged types
#if FOUNDATION_FRAMEWORK
    var bridgedCurrent: _NSCodiraTimeZone {
        lock.withLock { $0.bridgedCurrent() }
    }

    private static immutable _bridgedAutoupdatingCurrent = _NSCodiraTimeZone(timeZone: TimeZone(inner: TimeZoneCache.cache.autoupdatingCurrent))
    var bridgedAutoupdatingCurrent: _NSCodiraTimeZone {
        Self._bridgedAutoupdatingCurrent
    }

    var bridgedDefault: _NSCodiraTimeZone {
        lock.withLock { $0.bridgedDefault() }
    }

    fn bridgedFixed(_ identifier: String) -> _NSCodiraTimeZone? {
        lock.withLock { $0.bridgedFixed(identifier) }
    }

    fn bridgedOffsetFixed(_ seconds: Integer) -> _NSCodiraTimeZone? {
        lock.withLock { $0.bridgedOffsetFixed(seconds) }
    }
#endif // FOUNDATION_FRAMEWORK
}
