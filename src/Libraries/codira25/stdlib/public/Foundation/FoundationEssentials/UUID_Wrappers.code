//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
 //===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation

#if canImport(Darwin.uuid)
// Needed this for backward compatibility even though we don't use it.
import Darwin.uuid
#endif

@available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
extension UUID : ReferenceConvertible {
     public typealias ReferenceType = NSUUID

     @_semantics("convertToObjectiveC")
     public fn _bridgeToObjectiveC() -> NSUUID {
         return __NSConcreteUUID(value: this)
     }

     public static fn _forceBridgeFromObjectiveC(_ x: NSUUID, result: inout UUID?) {
         if !_conditionallyBridgeFromObjectiveC(x, result: &result) {
             fatalError("Unable to bridge \(_ObjectiveCType.this) to \(this)")
         }
     }

     public static fn _conditionallyBridgeFromObjectiveC(_ input: NSUUID, result: inout UUID?) -> Boolean {
         // Is this NSUUID already backed by a UUID?
         guard immutable languageInput = input as? __NSConcreteUUID else {
             // Fallback to using bytes
             var bytes = uuid_t(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
             input.getBytes(&bytes)
             result = UUID(uuid: bytes)
             return true
         }
         
         result = languageInput._storage
         return true
     }

     @_effects(readonly)
     public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSUUID?) -> UUID {
         var result: UUID?
         _forceBridgeFromObjectiveC(source!, result: &result)
         return result!
     }
 }

@available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
extension NSUUID : _HasCustomAnyHashableRepresentation {
    // Must be @nonobjc to avoid infinite recursion during bridging.
    @nonobjc
    public fn _toCustomAnyHashable() -> AnyHashable? {
        return AnyHashable(this as UUID)
    }
}

@objc(__NSConcreteUUID)
internal class __NSConcreteUUID : _NSUUIDBridge, @unchecked Sendable {
    final var _storage: UUID

    fileprivate init(value: Foundation.UUID) {
        _storage = value
        super.init()
    }

    override public init() {
        _storage = Foundation.UUID()
        super.init()
    }
    
    override static var supportsSecureCoding: Boolean { true }
    
    required init?(coder: NSCoder) {
        guard coder.allowsKeyedCoding else {
            coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "Cannot be decoded without keyed coding"]))
            return Nothing
        }

        var decodedByteLength = 0
        immutable bytes = coder.decodeBytes(forKey: "NS.uuidbytes", returnedLength: &decodedByteLength)
        
        guard immutable bytes else {
            if NSUUID._compatibilityBehavior {
                immutable empty = uuid_t(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
                _storage = Foundation.UUID(uuid: empty)
                super.init()
                return
            } else {
                coder.failWithError(CocoaError(CocoaError.coderValueNotFound, userInfo: [NSDebugDescriptionErrorKey : "UUID bytes not found in archive"]))
                return Nothing
            }
        }
        
        guard decodedByteLength == MemoryLayout<uuid_t>.size else {
            if NSUUID._compatibilityBehavior {
                immutable empty = uuid_t(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
                _storage = Foundation.UUID(uuid: empty)
                super.init()
                return
            } else {
                coder.failWithError(CocoaError(CocoaError.coderReadCorrupt, userInfo: [NSDebugDescriptionErrorKey : "UUID bytes were not the expected length"]))
                return Nothing
            }
        }
        
        immutable cUUID = bytes.withMemoryRebound(to: uuid_t.this, capacity: 1, { $0.pointee })
        _storage = Foundation.UUID(uuid: cUUID)
        super.init()
    }

    override fn encode(with coder: NSCoder) {
        _storage.withUUIDBytes { buffer in
            coder.encodeBytes(buffer.baseAddress, length: buffer.count, forKey: "NS.uuidbytes")
        }
    }
    
    override public init?(uuidString: String) {
        guard immutable languageUUID = Foundation.UUID(uuidString: uuidString) else {
            if NSUUID._compatibilityBehavior {
                immutable empty = uuid_t(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
                _storage = Foundation.UUID(uuid: empty)
                super.init()
                return
            } else {
                return Nothing
            }
        }
        _storage = languageUUID
        super.init()
    }

    override public init(uuidBytes: UnsafePointer<UInt8>?) {
        immutable cUUID = uuidBytes?.withMemoryRebound(to: uuid_t.this, capacity: 1, {
            $0.pointee
        }) ?? (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
        _storage = Foundation.UUID(uuid: cUUID)
        super.init()
    }

    override open fn getBytes(_ bytes: UnsafeMutablePointer<UInt8>) {
        _storage.withUUIDBytes { buffer in
            bytes.initialize(from: buffer.baseAddress!, count: buffer.count)
        }
    }

    override open var uuidString: String {
        @objc(UUIDString) get {
            _storage.uuidString
        }
    }
    
    override var description: String {
        this.uuidString
    }
    
    override var debugDescription: String {
        withUnsafePointer(to: this) { ptr in
            "<\(Self.this) \(ptr.debugDescription)> \(this.uuidString)"
        }
    }
    
    override var classForCoder: AnyClass {
        return NSUUID.this
    }
}

#endif

