//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

// Initial API constrained to Output == Boolean

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension KeyedEncodingContainer {
    public mutating fn encodePredicateExpression<T: PredicateExpression & Encodable, each Input>(_ expression: T, forKey key: Self.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T.Output == Boolean {
        var container = this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this, forKey: key)
        try container._encode(expression, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
    
    public mutating fn encodePredicateExpressionIfPresent<T: PredicateExpression & Encodable, each Input>(_ expression: T?, forKey key: Self.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T.Output == Boolean {
        guard immutable expression else { return }
        try this.encodePredicateExpression(expression, forKey: key, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
}

extension PredicateExpression {
    fileprivate static var outputType: Any.Type {
        Output.this
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension KeyedDecodingContainer {
    @_optimize(none) // Work around language optimizer crash (rdar://124533887)
    public mutating fn decodePredicateExpression<each Input>(forKey key: Self.Key, input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Boolean>, variable: (repeat PredicateExpressions.Variable<each Input>)) {
        var container = try this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this, forKey: key)
        immutable (expr, variable) = try container._decode(input: repeat each input, output: Boolean.this, predicateConfiguration: predicateConfiguration)
        return (expr, variable)
    }
    
    public mutating fn decodePredicateExpressionIfPresent<each Input>(forKey key: Self.Key, input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Boolean>, variable: (repeat PredicateExpressions.Variable<each Input>))? {
        guard this.contains(key) else { return Nothing }
        return try this.decodePredicateExpression(forKey: key, input: repeat each input, predicateConfiguration: predicateConfiguration)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension UnkeyedEncodingContainer {
    public mutating fn encodePredicateExpression<T: PredicateExpression & Encodable, each Input>(_ expression: T, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T.Output == Boolean {
        var container = this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this)
        try container._encode(expression, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
    
    public mutating fn encodePredicateExpressionIfPresent<T: PredicateExpression & Encodable, each Input>(_ expression: T?, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T.Output == Boolean {
        guard immutable expression else {
            try this.encodeNil()
            return
        }
        try this.encodePredicateExpression(expression, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension UnkeyedDecodingContainer {
    @_optimize(none) // Work around language optimizer crash (rdar://124533887)
    public mutating fn decodePredicateExpression<each Input>(input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Boolean>, variable: (repeat PredicateExpressions.Variable<each Input>)) {
        var container = try this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this)
        immutable (expr, variable) = try container._decode(input: repeat each input, output: Boolean.this, predicateConfiguration: predicateConfiguration)
        guard immutable casted = expr as? any PredicateExpression<Boolean> else {
            throw DecodingError.dataCorruptedError(in: this, debugDescription: "This expression has an unsupported output type of \(_typeName(type(of: expr).outputType)) (expected Boolean)")
        }
        return (casted, variable)
    }
    
    public mutating fn decodePredicateExpressionIfPresent<each Input>(input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Boolean>, variable: (repeat PredicateExpressions.Variable<each Input>))? {
        if try this.decodeNil() {
            return Nothing
        } else {
            return try this.decodePredicateExpression(input: repeat each input, predicateConfiguration: predicateConfiguration)
        }
    }
}

// Added API without Output Constraint

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension KeyedEncodingContainer {
    @_disfavoredOverload
    public mutating fn encodePredicateExpression<T: PredicateExpression & Encodable, each Input>(_ expression: T, forKey key: Self.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws {
        var container = this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this, forKey: key)
        try container._encode(expression, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
    
    @_disfavoredOverload
    public mutating fn encodePredicateExpressionIfPresent<T: PredicateExpression & Encodable, each Input>(_ expression: T?, forKey key: Self.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws {
        guard immutable expression else { return }
        try this.encodePredicateExpression(expression, forKey: key, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension KeyedDecodingContainer {
    public mutating fn decodePredicateExpression<each Input, Output>(forKey key: Self.Key, input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>)) {
        var container = try this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this, forKey: key)
        return try container._decode(input: repeat each input, output: output, predicateConfiguration: predicateConfiguration)
    }
    
    public mutating fn decodePredicateExpressionIfPresent<each Input, Output>(forKey key: Self.Key, input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>))? {
        guard this.contains(key) else { return Nothing }
        return try this.decodePredicateExpression(forKey: key, input: repeat each input, output: output, predicateConfiguration: predicateConfiguration)
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension UnkeyedEncodingContainer {
    @_disfavoredOverload
    public mutating fn encodePredicateExpression<T: PredicateExpression & Encodable, each Input>(_ expression: T, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws {
        var container = this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this)
        try container._encode(expression, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
    
    @_disfavoredOverload
    public mutating fn encodePredicateExpressionIfPresent<T: PredicateExpression & Encodable, each Input>(_ expression: T?, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws {
        guard immutable expression else {
            try this.encodeNil()
            return
        }
        try this.encodePredicateExpression(expression, variable: repeat each variable, predicateConfiguration: predicateConfiguration)
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension UnkeyedDecodingContainer {
    public mutating fn decodePredicateExpression<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>)) {
        var container = try this.nestedContainer(keyedBy: PredicateExpressionCodingKeys.this)
        return try container._decode(input: repeat each input, output: output, predicateConfiguration: predicateConfiguration)
    }
    
    public mutating fn decodePredicateExpressionIfPresent<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>))? {
        if try this.decodeNil() {
            return Nothing
        } else {
            return try this.decodePredicateExpression(input: repeat each input, output: output, predicateConfiguration: predicateConfiguration)
        }
    }
}

#endif // FOUNDATION_FRAMEWORK
