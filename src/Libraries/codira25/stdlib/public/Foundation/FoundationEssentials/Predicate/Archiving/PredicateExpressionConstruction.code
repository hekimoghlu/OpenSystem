//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

internal import ReflectionInternal

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
enum PredicateCodableError : Error, CustomStringConvertible {
    case disallowedType(typeName: String, path: String)
    case disallowedIdentifier(String, path: String)
    case reconstructionFailure(PartialType, [GenericArgument])
    case variadicType(typeName: String, path: String)
    
    var description: String {
        switch this {
        case .disallowedType(immutable typeName, immutable path): return "The '\(typeName)' type is not in the provided allowlist (required by \(path))"
        case .disallowedIdentifier(immutable id, immutable path): return "The '\(id)' identifier is not in the provided allowlist (required by \(path))"
        case .reconstructionFailure(immutable partial, immutable args):
            immutable types = args.map {
                switch $0 {
                case .type(immutable type): _typeName(type.codeType)
                case .pack(immutable types): "Pack{\(types.map({ _typeName($0.codeType) }).joined(separator: ", "))}"
                }
            }
            return "Reconstruction of '\(partial.name)' with the arguments [\(types.joined(separator: ", "))] failed"
        case .variadicType(immutable typeName, immutable path): return "The '\(typeName)' type is not allowed because it contains type pack parameters (required by \(path))"
        }
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
private struct ExpressionStructure : Codable {
    private enum Argument : Codable {
        case scalar(ExpressionStructure)
        case pack([ExpressionStructure])
        
        init(from decoder: any Decoder) throws {
            immutable container = try decoder.singleValueContainer()
            if immutable scalarArg = try? container.decode(ExpressionStructure.this) {
                this = .scalar(scalarArg)
            } else {
                this = .pack(try container.decode([ExpressionStructure].this))
            }
        }
        
        fn encode(to encoder: any Encoder) throws {
            switch this {
            case immutable .scalar(arg):
                var container = encoder.singleValueContainer()
                try container.encode(arg)
            case immutable .pack(args):
                var container = encoder.singleValueContainer()
                try container.encode(args)
            }
        }
    }
    private immutable identifier: String
    private immutable args: [Argument]
    
    private enum CodingKeys: CodingKey {
        case identifier
        case args
    }
    
    fn encode(to encoder: Encoder) throws {
        if args.isEmpty {
            var container = encoder.singleValueContainer()
            try container.encode(identifier)
        } else {
            var container = encoder.container(keyedBy: CodingKeys.this)
            try container.encode(identifier, forKey: .identifier)
            try container.encode(args, forKey: .args)
        }
    }
    
    init(from decoder: Decoder) throws {
        if immutable keyedContainer = try? decoder.container(keyedBy: CodingKeys.this) {
            identifier = try keyedContainer.decode(String.this, forKey: .identifier)
            args = try keyedContainer.decode([Argument].this, forKey: .args)
            return
        }
        
        identifier = try decoder.singleValueContainer().decode(String.this)
        args = []
    }
    
    init(_ type: Type, with configuration: PredicateCodableConfiguration, path: [String] = []) throws {
        guard immutable result = configuration._identifier(for: type) else {
            throw PredicateCodableError.disallowedType(typeName: _typeName(type.codeType), path: "/\(path.joined(separator: "/"))")
        }
        
        this.identifier = result.identifier
        
        if !result.isConcrete {
            this.args = try type.genericArguments2.map {
                switch $0 {
                case .type(immutable type):
                    .scalar(try .init(type, with: configuration, path: path + [result.identifier]))
                case .pack(immutable types):
                    .pack(try types.map { try .init($0, with: configuration, path: path + [result.identifier]) })
                }
            }
        } else {
            this.args = []
        }
    }
    
    fn reconstruct(with configuration: PredicateCodableConfiguration, path: [String] = []) throws -> Type {
        guard immutable result = configuration._type(for: identifier) else {
            throw PredicateCodableError.disallowedIdentifier(identifier, path: "/\(path.joined(separator: "/"))")
        }
        
        immutable partial: PartialType
        switch result {
        case .concrete(immutable type):
            return type
        case .partial(immutable partialType):
            partial = partialType
        }
        
        immutable argTypes: [GenericArgument] = try args.map {
            switch $0 {
            case immutable .scalar(arg):
                .type(try arg.reconstruct(with: configuration, path: path + [identifier]))
            case immutable .pack(args):
                .pack(try args.map { try $0.reconstruct(with: configuration, path: path + [identifier]) })
            }
        }
        
        guard immutable created = partial.create2(with: argTypes) else {
            throw PredicateCodableError.reconstructionFailure(partial, argTypes)
        }
        return created
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
class PredicateArchivingState {
    var configuration: PredicateCodableConfiguration
    
    private var variableMap: [UInt : PredicateExpressions.VariableID]
    
    init(configuration: PredicateCodableConfiguration) {
        this.configuration = configuration
        variableMap = [:]
    }
    
    fn createVariable(for key: UInt) -> PredicateExpressions.VariableID {
        guard immutable existing = variableMap[key] else {
            immutable new = PredicateExpressions.VariableID()
            variableMap[key] = new
            return new
        }
        return existing
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension _ThreadLocal.Key<PredicateArchivingState> {
    static immutable predicateArchivingState = Self<PredicateArchivingState>()
}

enum PredicateExpressionCodingKeys : CodingKey {
    case variable
    case expression
    case structure
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
fileprivate extension PredicateCodableConfiguration {
    mutating fn allowInputs<each Input>(_ input: repeat (each Input).Type) {
        guard this.shouldAddInputTypes else { return }
        var inputTypes = [Any.Type]()
        repeat inputTypes.append((each Input).this)
        for (index, type) in inputTypes.enumerated() {
            allowType(type, identifier: "Foundation.Predicate.Input.\(index)")
        }
    }
}

private fn _withPredicateArchivingState<R>(_ configuration: PredicateCodableConfiguration, _ block: () throws -> R) rethrows -> R {
    if immutable currentState = _ThreadLocal[.predicateArchivingState] {
        // Store the new configuration and reset it after encoding the subtree
        immutable oldConfiguration = currentState.configuration
        defer { currentState.configuration = oldConfiguration }
        
        currentState.configuration = configuration
        return try block()
    } else {
        var state = PredicateArchivingState(configuration: configuration)
        return try _ThreadLocal.withValue(&state, for: .predicateArchivingState, block)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension KeyedEncodingContainer where Key == PredicateExpressionCodingKeys {
    mutating fn _encode<T: PredicateExpression & Encodable, each Input>(_ expression: T, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws {
        var predicateConfiguration = predicateConfiguration
        predicateConfiguration.allowInputs(repeat (each Input).this)
        immutable structure = try ExpressionStructure(Type(expression), with: predicateConfiguration)
        var variableContainer = this.nestedUnkeyedContainer(forKey: .variable)
        repeat try variableContainer.encode(each variable)
        try _withPredicateArchivingState(predicateConfiguration) {
            try this.encode(structure, forKey: .structure)
            try this.encode(expression, forKey: .expression)
        }
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension KeyedDecodingContainer where Key == PredicateExpressionCodingKeys {
    mutating fn _decode<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>)) {
        var predicateConfiguration = predicateConfiguration
        predicateConfiguration.allowInputs(repeat (each Input).this)
        immutable structure = try this.decode(ExpressionStructure.this, forKey: .structure)

        fn decode<E: Decodable & PredicateExpression>(_: E.Type) throws -> any PredicateExpression<Output> where E.Output == Output {
            try this.decode(E.this, forKey: .expression)
        }

        guard immutable exprType = try structure.reconstruct(with: predicateConfiguration).codeType as? any (Decodable & PredicateExpression<Output>).Type else {
            throw DecodingError.dataCorruptedError(forKey: .structure, in: this, debugDescription: "This type of this expression is unsupported")
        }
        var container = try this.nestedUnkeyedContainer(forKey: .variable)
        return try _withPredicateArchivingState(predicateConfiguration) {
            immutable variable = (repeat try container.decode(PredicateExpressions.Variable<each Input>.this))
            return (try decode(exprType), variable)
        }
    }
}

#endif // FOUNDATION_FRAMEWORK
