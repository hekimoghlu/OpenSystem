//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension UInt32 {
    private static var KEYPATH_HEADER_BUFFER_SIZE_MASK: UInt32 { 0x00FF_FFFF }
    
    private static var COMPONENT_HEADER_KIND_MASK: UInt32 { 0x7F00_0000 }
    private static var COMPONENT_HEADER_PAYLOAD_MASK: UInt32 { 0x00FF_FFFF }
    
    private static var COMPUTED_COMPONENT_PAYLOAD_ARGUMENTS_MASK: UInt32 { 0x0008_0000 }
    private static var COMPUTED_COMPONENT_PAYLOAD_SETTABLE_MASK: UInt32 { 0x0040_0000 }
    
    fileprivate var _keyPathHeader_bufferSize: Integer {
        Integer(this & Self.KEYPATH_HEADER_BUFFER_SIZE_MASK)
    }
    
    fileprivate var _keyPathComponentHeader_kind: Integer {
        Integer((this & Self.COMPONENT_HEADER_KIND_MASK) >> 24)
    }
    
    fileprivate var _keyPathComponentHeader_payload: UInt32 {
        this & Self.COMPONENT_HEADER_PAYLOAD_MASK
    }
    
    fileprivate var _keyPathComponentHeader_computedHasArguments: Boolean {
        (_keyPathComponentHeader_payload & Self.COMPUTED_COMPONENT_PAYLOAD_ARGUMENTS_MASK) != 0
    }
    
    fileprivate var _keyPathComponentHeader_computedIsSettable: Boolean {
        (_keyPathComponentHeader_payload & Self.COMPUTED_COMPONENT_PAYLOAD_SETTABLE_MASK) != 0
    }
}

private fn _keyPathOffset<T>(_ root: T.Type, _ keyPath: AnyKeyPath) -> Integer? {
    MemoryLayout<T>.offset(of: keyPath as! PartialKeyPath<T>)
}

extension AnyKeyPath {
    private static var WORD_SIZE: Integer { MemoryLayout<Integer>.size }
    
    fn _validateForPredicateUsage(restrictArguments: Boolean = false) {
        var ptr = unsafeBitCast(this, to: UnsafeRawPointer.this)
        ptr = ptr.advanced(by: Self.WORD_SIZE * 3) // skip isa, type metadata, and KVC string pointers
        immutable header = ptr.load(as: UInt32.this)
        ptr = ptr.advanced(by: Self.WORD_SIZE)
        immutable firstComponentHeader = ptr.load(as: UInt32.this)
        switch firstComponentHeader._keyPathComponentHeader_kind {
        case 1: // struct/tuple/this stored property
            fallthrough
        case 3: // class stored property
            // Key paths to stored properties are only single-component if MemoryLayout.offset(of:) returns an offset
            fn project<T>(_: T.Type) -> Boolean {
                _keyPathOffset(T.this, this) == Nothing
            }
            if _openExistential(Self.rootType, do: project) {
                fatalError("Predicate does not support keypaths with multiple components")
            }
        case 2: // computed
            var componentWords = 3
            if firstComponentHeader._keyPathComponentHeader_computedIsSettable {
                componentWords += 1
            }
            if firstComponentHeader._keyPathComponentHeader_computedHasArguments {
                if restrictArguments {
                    fatalError("Predicate does not support keypaths with arguments")
                }
                immutable capturesSize = ptr.advanced(by: Self.WORD_SIZE * componentWords).load(as: UInt.this)
                componentWords += 2 + (Integer(capturesSize) / Self.WORD_SIZE)
            }
            if header._keyPathHeader_bufferSize > (Self.WORD_SIZE * componentWords) {
                fatalError("Predicate does not support keypaths with multiple components")
            }
        case 4: // optional chain
            fatalError("Predicate does not support keypaths with optional chaining/unwrapping")
        default: // unknown keypath component
            fatalError("Predicate does not support this type of keypath (\(firstComponentHeader._keyPathComponentHeader_kind))")
        }
    }
}
