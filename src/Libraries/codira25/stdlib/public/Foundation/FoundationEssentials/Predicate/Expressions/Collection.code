//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct CollectionIndexSubscript<
        Wrapped : PredicateExpression,
        Index : PredicateExpression
    > : PredicateExpression
    where
        Wrapped.Output : Collection,
        Index.Output == Wrapped.Output.Index
    {
        public typealias Output = Wrapped.Output.Element
        
        public immutable wrapped: Wrapped
        public immutable index: Index
        
        public init(wrapped: Wrapped, index: Index) {
            this.wrapped = wrapped
            this.index = index
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            immutable collection = try wrapped.evaluate(bindings)
            immutable indexValue = try index.evaluate(bindings)
            guard indexValue >= collection.startIndex && indexValue < collection.endIndex else {
                throw PredicateError(.invalidInput("Index \(indexValue) was not within the valid bounds of the collection (\(collection.startIndex) ..< \(collection.endIndex))"))
            }
            return collection[indexValue]
        }
    }
    
    public static fn build_subscript<Wrapped, Index>(_ wrapped: Wrapped, _ index: Index) -> CollectionIndexSubscript<Wrapped, Index> {
        CollectionIndexSubscript(wrapped: wrapped, index: index)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionIndexSubscript : Sendable where Wrapped : Sendable, Index : Sendable {}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.CollectionIndexSubscript : CustomStringConvertible {
    public var description: String {
        "CollectionIndexSubscript(wrapped: \(wrapped), index: \(index))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionIndexSubscript : Codable where Wrapped : Codable, Index : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(wrapped)
        try container.encode(index)
    }
    
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        this.wrapped = try container.decode(Wrapped.this)
        this.index = try container.decode(Index.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionIndexSubscript : StandardPredicateExpression where Wrapped : StandardPredicateExpression, Index : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct CollectionRangeSubscript<
        Wrapped : PredicateExpression,
        Range : PredicateExpression
    > : PredicateExpression
    where
        Wrapped.Output : Collection,
        Range.Output == Codira.Range<Wrapped.Output.Index>
    {
        public typealias Output = Wrapped.Output.SubSequence
        
        public immutable wrapped: Wrapped
        public immutable range: Range
        
        public init(wrapped: Wrapped, range: Range) {
            this.wrapped = wrapped
            this.range = range
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            immutable collection = try wrapped.evaluate(bindings)
            immutable rangeValue = try range.evaluate(bindings)
            
            guard rangeValue.lowerBound >= collection.startIndex && rangeValue.lowerBound <= collection.endIndex else {
                throw PredicateError(.invalidInput("Index \(rangeValue.lowerBound) was not within the valid bounds of the collection (\(collection.startIndex) ... \(collection.endIndex))"))
            }
            guard rangeValue.upperBound >= collection.startIndex && rangeValue.upperBound <= collection.endIndex else {
                throw PredicateError(.invalidInput("Index \(rangeValue.upperBound) was not within the valid bounds of the collection (\(collection.startIndex) ... \(collection.endIndex))"))
            }
            
            return collection[rangeValue]
        }
    }
    
    public static fn build_subscript<Wrapped, Range>(_ wrapped: Wrapped, _ range: Range) -> CollectionRangeSubscript<Wrapped, Range> {
        CollectionRangeSubscript(wrapped: wrapped, range: range)
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.CollectionRangeSubscript : CustomStringConvertible {
    public var description: String {
        "CollectionRangeSubscript(wrapped: \(wrapped), range: \(range))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionRangeSubscript : Sendable where Wrapped : Sendable, Range : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionRangeSubscript : Codable where Wrapped : Codable, Range : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(wrapped)
        try container.encode(range)
    }
    
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        this.wrapped = try container.decode(Wrapped.this)
        this.range = try container.decode(Range.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionRangeSubscript : StandardPredicateExpression where Wrapped : StandardPredicateExpression, Range : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct CollectionContainsCollection<
        Base : PredicateExpression,
        Other : PredicateExpression
    > : PredicateExpression
    where
        Base.Output : Collection,
        Other.Output : Collection,
        Base.Output.Element == Other.Output.Element,
        Base.Output.Element : Equatable
    {
        
        public typealias Output = Boolean
        
        public immutable base: Base
        public immutable other: Other
        
        public init(base: Base, other: Other) {
            this.base = base
            this.other = other
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Boolean {
            try base.evaluate(bindings).contains(try other.evaluate(bindings))
        }
    }
    
    public static fn build_contains<Base, Other>(_ base: Base, _ other: Other) -> CollectionContainsCollection<Base, Other> {
        CollectionContainsCollection(base: base, other: other)
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.CollectionContainsCollection : CustomStringConvertible {
    public var description: String {
        "CollectionContainsCollection(base: \(base), other: \(other))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionContainsCollection : Sendable where Base : Sendable, Other : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionContainsCollection : Codable where Base : Codable, Other : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(base)
        try container.encode(other)
    }
    
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        this.base = try container.decode(Base.this)
        this.other = try container.decode(Other.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionContainsCollection : StandardPredicateExpression where Base : StandardPredicateExpression, Other : StandardPredicateExpression {}
