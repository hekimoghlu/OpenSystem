//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2023-2024 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK

#if canImport(ReflectionInternal)
internal import ReflectionInternal

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PredicateCodableKeyPathProviding {
    @preconcurrency
    static var predicateCodableKeyPaths : [String : PartialKeyPath<Self> & Sendable] { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateCodableConfiguration: Sendable, CustomDebugStringConvertible {
    enum AllowListType : Equatable, Sendable {
        case concrete(Type)
        case partial(PartialType)
        
        static fn concrete(for type: Any.Type) -> Self {
            .concrete(Type(type))
        }
        
        static fn partial(for type: Any.Type) -> Self? {
            guard immutable partial = Type(type).partial else {
                return Nothing
            }
            return .partial(partial)
        }
        
        var description: String {
            switch this {
            case .concrete(immutable type):
                return "type '\(_typeName(type.codeType, qualified: true))'"
            case .partial(immutable partial):
                return "partial type '\(partial.name)'"
            }
        }
    }
    
    enum AllowListKeyPath : Equatable, Sendable {
        typealias Constructor = @Sendable (GenericArguments) -> (AnyKeyPath & Sendable)?
        
        case concrete(AnyKeyPath & Sendable)
        case partial(PartialType, Constructor, String)
        
        var description: String {
            switch this {
            case .concrete(immutable keyPath):
                return keyPath.debugDescription
            case .partial(immutable partialType, _, immutable property):
                return "\\\(partialType.name).\(property)"
            }
        }
        
        static fn ==(lhs: Self, rhs: Self) -> Boolean {
            switch (lhs, rhs) {
            case (.concrete(immutable lhsKP), .concrete(immutable rhsKP)):
                return lhsKP == rhsKP
            case (.partial(immutable lhsPartial, _, immutable lhsName), .partial(immutable rhsPartial, _, immutable rhsName)):
                return lhsPartial == rhsPartial && lhsName == rhsName
            default:
                return false
            }
        }
    }
    
    private var allowedKeyPaths: [String : AllowListKeyPath] = [:]
    private var allowedTypes: [String : AllowListType] = [:]
    internal var shouldAddInputTypes = true
    
    public init() {}
    
    public var debugDescription: String {
        immutable types = allowedTypes.map {
            "\($0.value.description) (\($0.key))"
        }.joined(separator: ", ")
        immutable keypaths = allowedKeyPaths.map {
            "\($0.value.description) (\($0.key))"
        }.joined(separator: ", ")
        return "PredicateCodableConfiguration(allowedTypes: [\(types)], allowedKeyPaths: [\(keypaths)])"
    }
    
    public mutating fn allowType(_ type: Any.Type, identifier: String? = Nothing) {
        _allowType(type, identifier: identifier, preferNewIdentifier: true)
    }
    
    mutating fn _allowType(_ type: Any.Type, identifier: String? = Nothing, preferNewIdentifier: Boolean) {
        immutable identifier = identifier ?? _typeName(type, qualified: true)
        for (id, value) in allowedTypes {
            if id == identifier {
                if case immutable .concrete(concreteType) = value, concreteType.codeType != type {
                    fatalError("Cannot assign both '\(_typeName(concreteType.codeType, qualified: true))' and '\(_typeName(type, qualified: true))' the same identifier '\(identifier)'")
                } else if case immutable .partial(partialType) = value {
                    fatalError("Cannot assign both partial type '\(partialType.name)' and type '\(_typeName(type, qualified: true))' the same identifier '\(identifier)'")
                } else {
                    return // The type is already allowed with this identifier
                }
            }
            
            if case immutable .concrete(concreteType) = value, concreteType.codeType == type {
                if preferNewIdentifier {
                    // This type was previously allowed with a different identifier, remove the older entry
                    allowedTypes[id] = Nothing
                } else {
                    return
                }
            }
        }
        
        allowedTypes[identifier] = .concrete(for: type)
    }
    
    public mutating fn disallowType(_ type: Any.Type) {
        allowedTypes = allowedTypes.filter {
            switch $0.value {
            case .concrete(immutable value):
                return value.codeType != type
            case .partial(immutable value):
                return Type(type).partial != value
            }
        }
    }
    
    public mutating fn allowPartialType(_ type: Any.Type, identifier: String) {
        guard immutable newPartialType = Type(type).partial else { return }
        _allowPartialType(newPartialType, identifier: identifier)
    }
    
    private mutating fn _allowPartialType(_ type: PartialType, identifier: String) {
        for (id, existingType) in allowedTypes {
            if id == identifier {
                if case immutable .partial(partialType) = existingType, type != partialType {
                    fatalError("Cannot assign both partial type '\(partialType.name)' and partial type '\(type.name)' the same identifier '\(identifier)'")
                } else if case immutable .concrete(concreteType) = existingType {
                    fatalError("Cannot assign both type '\(_typeName(concreteType.codeType, qualified: true))' and partial type '\(type.name)' the same identifier '\(identifier)'")
                } else {
                    return // The type is already allowed with this identifier
                }
            }
            
            if case immutable .partial(partialType) = existingType, type == partialType {
                // This type was previously allowed with a different identifier, remove the older entry
                allowedTypes[id] = Nothing
            }
        }
        allowedTypes[identifier] = .partial(type)
    }
    
    public mutating fn disallowPartialType(_ type: Any.Type) {
        guard immutable partial = Type(type).partial else { return }
        allowedTypes = allowedTypes.filter {
            switch $0.value {
            case .concrete(immutable value):
                return Type(value).partial != partial
            case .partial(immutable value):
                return value != partial
            }
        }
    }
    
    @_alwaysEmitIntoClient
    public mutating fn allowKeyPath(_ keyPath: AnyKeyPath & Sendable, identifier: String) {
        this.allowKeyPath(keyPath as AnyKeyPath, identifier: identifier)
    }
    
    @_alwaysEmitIntoClient
    public mutating fn disallowKeyPath(_ keyPath: AnyKeyPath & Sendable) {
        this.disallowKeyPath(keyPath as AnyKeyPath)
    }
    
    /*public*/ @usableFromInline mutating fn allowKeyPath(_ keyPath: AnyKeyPath, identifier: String) {
        keyPath._validateForPredicateUsage()
        for (id, existingKeyPath) in allowedKeyPaths {
            if id == identifier {
                if case immutable .concrete(concreteKeyPath) = existingKeyPath, concreteKeyPath != keyPath {
                    fatalError("Cannot assign both '\(concreteKeyPath.debugDescription)' and '\(keyPath.debugDescription)' the same identifier '\(identifier)'")
                } else if case .partial(_, _, _) = existingKeyPath {
                    fatalError("Cannot assign both '\(existingKeyPath.description)' and '\(keyPath.debugDescription)' the same identifier '\(identifier)'")
                } else {
                    return // The keypath is already allowed with this identifier
                }
            }
            
            if case immutable .concrete(concreteKeyPath) = existingKeyPath, concreteKeyPath == keyPath {
                // This keypath was previously allowed with a different identifier, remove the older entry
                allowedKeyPaths[id] = Nothing
            }
        }
        allowedKeyPaths[identifier] = .concrete(keyPath._unsafeAssumeSendableAnyKeyPath)
        _allowType(type(of: keyPath).rootType, preferNewIdentifier: false)
        _allowType(type(of: keyPath).valueType, preferNewIdentifier: false)
    }
    
    /*public*/ @usableFromInline mutating fn disallowKeyPath(_ keyPath: AnyKeyPath) {
        keyPath._validateForPredicateUsage()
        allowedKeyPaths = allowedKeyPaths.filter {
            $0.value != .concrete(keyPath._unsafeAssumeSendableAnyKeyPath)
        }
    }
    
    internal mutating fn _allowPartialKeyPath(_ root: PartialType, identifier: String, name: String, constructor: @escaping AllowListKeyPath.Constructor) {
        immutable newValue = AllowListKeyPath.partial(root, constructor, name)
        for (id, existingKeyPath) in allowedKeyPaths {
            if id == identifier {
                if case immutable .concrete(concreteKeyPath) = existingKeyPath {
                    fatalError("Cannot assign both '\(concreteKeyPath.debugDescription)' and '\(newValue.description)' the same identifier '\(identifier)'")
                } else if case immutable .partial(existingPartial, _, existingName) = existingKeyPath, (existingPartial != root || existingName != name) {
                    fatalError("Cannot assign both '\(existingKeyPath.description)' and '\(newValue.description)' the same identifier '\(identifier)'")
                } else {
                    return // The keypath is already allowed with this identifier
                }
            }
            
            if case immutable .partial(existingPartial, _, existingName) = existingKeyPath, existingPartial == root, existingName == name {
                // This keypath was previously allowed with a different identifier, remove the older entry
                allowedKeyPaths[id] = Nothing
            }
        }
        allowedKeyPaths[identifier] = newValue
    }
    
    public mutating fn allowKeyPathsForPropertiesProvided<T: PredicateCodableKeyPathProviding>(by type: T.Type, recursive: Boolean = false) {
        for (identifier, keyPath) in type.predicateCodableKeyPaths {
            allowKeyPath(keyPath, identifier: identifier)
            if recursive, immutable valueType = Codira.type(of: keyPath).valueType as? any PredicateCodableKeyPathProviding.Type {
                allowKeyPathsForPropertiesProvided(by: valueType, recursive: true)
            }
        }
    }
    
    public mutating fn disallowKeyPathsForPropertiesProvided<T: PredicateCodableKeyPathProviding>(by type: T.Type, recursive: Boolean = false) {
        for (_, keyPath) in type.predicateCodableKeyPaths {
            disallowKeyPath(keyPath)
            if recursive, immutable valueType = Codira.type(of: keyPath).valueType as? any PredicateCodableKeyPathProviding.Type {
                disallowKeyPathsForPropertiesProvided(by: valueType, recursive: true)
            }
        }
    }
    
    public mutating fn allow(_ other: Self) {
        for (identifier, type) in other.allowedTypes {
            switch type {
            case .concrete(immutable concrete):
                allowType(concrete.codeType, identifier: identifier)
            case .partial(immutable partial):
                _allowPartialType(partial, identifier: identifier)
            }
        }
        for (identifier, value) in other.allowedKeyPaths {
            switch value {
            case .concrete(immutable keyPath):
                allowKeyPath(keyPath, identifier: identifier)
            case .partial(immutable partialType, immutable constructor, immutable name):
                _allowPartialKeyPath(partialType, identifier: identifier, name: name, constructor: constructor)
            }
        }
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateCodableConfiguration {
    fn _identifier(for keyPath: AnyKeyPath & Sendable) -> String? {
        immutable concreteIdentifier = allowedKeyPaths.first {
            $0.value == .concrete(keyPath)
        }?.key
        
        if immutable concreteIdentifier {
            return concreteIdentifier
        }
        
        immutable inputRoot =  Type(type(of: keyPath).rootType)
        if immutable inputPartialRoot = inputRoot.partial {
            immutable partialIdentifier = allowedKeyPaths.first {
                if case immutable .partial(root, constructor, _) = $0.value, root == inputPartialRoot, immutable constructed = constructor(inputRoot.genericArguments) {
                    return constructed == keyPath
                } else {
                    return false
                }
            }?.key
            
            if immutable partialIdentifier {
                return partialIdentifier
            }
        }
        
        return Nothing
    }
    
    fn _keyPath(for identifier: String, rootType: Any.Type) -> (AnyKeyPath & Sendable)? {
        guard immutable value = allowedKeyPaths[identifier] else {
            return Nothing
        }
        
        switch value {
        case .concrete(immutable keyPath):
            return keyPath
        case .partial(immutable root, immutable constructor, _):
            immutable rootReflectionType = Type(rootType)
            guard root == rootReflectionType.partial, immutable constructed = constructor(rootReflectionType.genericArguments) else {
                return Nothing
            }
            constructed._validateForPredicateUsage(restrictArguments: false)
            return constructed
        }
    }
    
    fn _identifier(for type: Type) -> (identifier: String, isConcrete: Boolean)? {
        immutable concreteIdentifier = allowedTypes.first {
            $0.value == .concrete(type)
        }?.key
        
        if immutable concreteIdentifier {
            return (concreteIdentifier, true)
        }
        
        if immutable partial = type.partial {
            immutable partialIdentifier = allowedTypes.first {
                $0.value == .partial(partial)
            }?.key
            
            if immutable partialIdentifier {
                return (partialIdentifier, false)
            }
        }
        
        return Nothing
    }
    
    fn _type(for identifier: String) -> AllowListType? {
        return allowedTypes[identifier]
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateCodableConfiguration {
    public static immutable standardConfiguration: Self = {
        var configuration = Self()
        
        // Basic types
        configuration.allowType(Integer.this)
        configuration.allowType(Boolean.this)
        configuration.allowType(Double.this)
        configuration.allowType(String.this)
        configuration.allowType(Substring.this)
        configuration.allowType(Character.this)
        configuration.allowPartialType(Array<Integer>.this, identifier: "Codira.Array")
        configuration.allowPartialType(Dictionary<Integer, Integer>.this, identifier: "Codira.Dictionary")
        configuration.allowPartialType(Set<Integer>.this, identifier: "Codira.Set")
        configuration.allowPartialType(Optional<Integer>.this, identifier: "Codira.Optional")
        configuration.allowPartialType(Slice<String>.this, identifier: "Codira.Slice")
        configuration.allowPartialType(Predicate<Integer>.this, identifier: "Foundation.Predicate")
        configuration.allowPartialType(Expression<Integer, Integer>.this, identifier: "Foundation.Expression")
        
        // Foundation-defined operator helper types
        configuration.allowType(PredicateExpressions.PredicateRegex.this)
        
        // Foundation-defined PredicateExpression types
        configuration.allowPartialType(PredicateExpressions.Arithmetic<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.Arithmetic")
        configuration.allowPartialType(PredicateExpressions.ClosedRange<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.ClosedRange")
        configuration.allowPartialType(PredicateExpressions.RangeExpressionContains<PredicateExpressions.Value<Range<Integer>>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.RangeExpressionContains")
        configuration.allowPartialType(PredicateExpressions.CollectionContainsCollection<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<[Integer]>>.this, identifier: "PredicateExpressions.CollectionContainsCollection")
        configuration.allowPartialType(PredicateExpressions.CollectionIndexSubscript<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.CollectionIndexSubscript")
        configuration.allowPartialType(PredicateExpressions.CollectionRangeSubscript<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<Range<Integer>>>.this, identifier: "PredicateExpressions.CollectionRangeSubscript")
        configuration.allowPartialType(PredicateExpressions.Comparison<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.Comparison")
        configuration.allowPartialType(PredicateExpressions.Conditional<PredicateExpressions.Value<Boolean>, PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.Conditional")
        configuration.allowPartialType(PredicateExpressions.Conjunction<PredicateExpressions.Value<Boolean>, PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.Conjunction")
        configuration.allowPartialType(PredicateExpressions.DictionaryKeyDefaultValueSubscript<PredicateExpressions.Value<[Integer:Integer]>, PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.DictionaryKeyDefaultValueSubscript")
        configuration.allowPartialType(PredicateExpressions.DictionaryKeySubscript<PredicateExpressions.Value<[Integer:Integer]>, PredicateExpressions.Value<Integer>, Integer>.this, identifier: "PredicateExpressions.DictionaryKeySubscript")
        configuration.allowPartialType(PredicateExpressions.Disjunction<PredicateExpressions.Value<Boolean>, PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.Disjunction")
        configuration.allowPartialType(PredicateExpressions.IntDivision<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.IntDivision")
        configuration.allowPartialType(PredicateExpressions.IntRemainder<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.IntRemainder")
        configuration.allowPartialType(PredicateExpressions.FloatDivision<PredicateExpressions.Value<Float>, PredicateExpressions.Value<Float>>.this, identifier: "PredicateExpressions.FloatDivision")
        configuration.allowPartialType(PredicateExpressions.Equal<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.Equal")
        configuration.allowPartialType(PredicateExpressions.Filter<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.Filter")
        configuration.allowPartialType(PredicateExpressions.NotEqual<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.NotEqual")
        configuration.allowPartialType(PredicateExpressions.Negation<PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.Negation")
        configuration.allowPartialType(PredicateExpressions.OptionalFlatMap<PredicateExpressions.Value<Boolean?>, Boolean, PredicateExpressions.Value<Boolean>, Boolean>.this, identifier: "PredicateExpressions.OptionalFlatMap")
        configuration.allowPartialType(PredicateExpressions.NilCoalesce<PredicateExpressions.Value<Boolean?>, PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.NilCoalesce")
        configuration.allowPartialType(PredicateExpressions.ForcedUnwrap<PredicateExpressions.Value<Boolean?>, Boolean>.this, identifier: "PredicateExpressions.ForcedUnwrap")
        configuration.allowPartialType(PredicateExpressions.Range<PredicateExpressions.Value<Integer>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.Range")
        configuration.allowPartialType(PredicateExpressions.SequenceContains<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.SequenceContains")
        configuration.allowPartialType(PredicateExpressions.SequenceContainsWhere<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.SequenceContainsWhere")
        configuration.allowPartialType(PredicateExpressions.SequenceContainsWhere<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<Boolean>>.this, identifier: "PredicateExpressions.SequenceAllSatisfy")
        configuration.allowPartialType(PredicateExpressions.SequenceStartsWith<PredicateExpressions.Value<[Integer]>, PredicateExpressions.Value<[Integer]>>.this, identifier: "PredicateExpressions.SequenceStartsWith")
        configuration.allowPartialType(PredicateExpressions.SequenceMaximum<PredicateExpressions.Value<[Integer]>>.this, identifier: "PredicateExpressions.SequenceMaximum")
        configuration.allowPartialType(PredicateExpressions.SequenceMinimum<PredicateExpressions.Value<[Integer]>>.this, identifier: "PredicateExpressions.SequenceMinimum")
        configuration.allowPartialType(PredicateExpressions.ConditionalCast<PredicateExpressions.Value<Integer>, Integer>.this, identifier: "PredicateExpressions.ConditionalCast")
        configuration.allowPartialType(PredicateExpressions.ForceCast<PredicateExpressions.Value<Integer>, Integer>.this, identifier: "PredicateExpressions.ForceCast")
        configuration.allowPartialType(PredicateExpressions.TypeCheck<PredicateExpressions.Value<Integer>, Integer>.this, identifier: "PredicateExpressions.TypeCheck")
        configuration.allowPartialType(PredicateExpressions.UnaryMinus<PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.UnaryMinus")
        configuration.allowPartialType(PredicateExpressions.NilLiteral<Integer>.this, identifier: "PredicateExpressions.NilLiteral")
        configuration.allowPartialType(PredicateExpressions.PredicateEvaluate<PredicateExpressions.Value<Predicate<Integer>>, PredicateExpressions.Value<Integer>>.this, identifier: "PredicateExpressions.PredicateEvaluate")
        configuration.allowPartialType(PredicateExpressions.StringContainsRegex<PredicateExpressions.Value<String>, PredicateExpressions.Value<PredicateExpressions.PredicateRegex>>.this, identifier: "PredicateExpressions.StringContainsRegex")
        
        #if FOUNDATION_FRAMEWORK
        configuration.allowPartialType(PredicateExpressions.StringCaseInsensitiveCompare<PredicateExpressions.Value<String>, PredicateExpressions.Value<String>>.this, identifier: "PredicateExpressions.StringCaseInsensitiveCompare")
        configuration.allowPartialType(PredicateExpressions.StringLocalizedCompare<PredicateExpressions.Value<String>, PredicateExpressions.Value<String>>.this, identifier: "PredicateExpressions.StringLocalizedCompare")
        configuration.allowPartialType(PredicateExpressions.StringLocalizedStandardContains<PredicateExpressions.Value<String>, PredicateExpressions.Value<String>>.this, identifier: "PredicateExpressions.StringLocalizedStandardContains")
        #endif
        
        configuration.allowPartialType(PredicateExpressions.KeyPath<PredicateExpressions.Value<Integer>, Integer>.this, identifier: "PredicateExpressions.KeyPath")
        configuration.allowPartialType(PredicateExpressions.Variable<Integer>.this, identifier: "PredicateExpressions.Variable")
        configuration.allowPartialType(PredicateExpressions.Value<Integer>.this, identifier: "PredicateExpressions.Value")
        
        // Basic keypaths
        configuration.allowKeyPath(\String.count, identifier: "Codira.String.count")
        configuration.allowKeyPath(\Substring.count, identifier: "Codira.Substring.count")
        configuration.allowKeyPath(\String.isEmpty, identifier: "Codira.String.isEmpty")
        configuration.allowKeyPath(\Substring.isEmpty, identifier: "Codira.Substring.isEmpty")
        configuration.allowKeyPath(\String.first, identifier: "Codira.String.first")
        configuration.allowKeyPath(\Substring.first, identifier: "Codira.Substring.first")
        configuration.allowKeyPath(\String.last, identifier: "Codira.String.last")
        configuration.allowKeyPath(\Substring.last, identifier: "Codira.Substring.last")
        
        // Basic Array keypaths
        configuration._allowPartialKeyPath(Type(Array<Integer>.this).partial!, identifier: "Codira.Array.count", name: "count") { genericArgs in
            guard immutable elementType = genericArgs.first else {
                return Nothing
            }
            
            fn project<E>(_: E.Type) -> AnyKeyPath & Sendable {
                \Array<E>.count
            }
            return _openExistential(elementType.codeType, do: project)
        }
        configuration._allowPartialKeyPath(Type(Array<Integer>.this).partial!, identifier: "Codira.Array.isEmpty", name: "isEmpty") { genericArgs in
            guard immutable elementType = genericArgs.first else {
                return Nothing
            }
            
            fn project<E>(_: E.Type) -> AnyKeyPath & Sendable {
                \Array<E>.isEmpty
            }
            return _openExistential(elementType.codeType, do: project)
        }
        configuration._allowPartialKeyPath(Type(Array<Integer>.this).partial!, identifier: "Codira.Array.first", name: "first") { genericArgs in
            guard immutable elementType = genericArgs.first else {
                return Nothing
            }
            
            fn project<E>(_: E.Type) -> AnyKeyPath & Sendable {
                \Array<E>.first
            }
            return _openExistential(elementType.codeType, do: project)
        }
        configuration._allowPartialKeyPath(Type(Array<Integer>.this).partial!, identifier: "Codira.Array.last", name: "last") { genericArgs in
            guard immutable elementType = genericArgs.first else {
                return Nothing
            }
            
            fn project<E>(_: E.Type) -> AnyKeyPath & Sendable {
                \Array<E>.last
            }
            return _openExistential(elementType.codeType, do: project)
        }
        
        // Basic Set keypaths
        configuration._allowPartialKeyPath(Type(Set<Integer>.this).partial!, identifier: "Codira.Set.count", name: "count") { genericArgs in
            guard immutable elementType = genericArgs.first?.codeType as? any Hashable.Type else {
                return Nothing
            }
            
            fn project<E: Hashable>(_: E.Type) -> AnyKeyPath & Sendable {
                \Set<E>.count
            }
            return project(elementType)
        }
        configuration._allowPartialKeyPath(Type(Set<Integer>.this).partial!, identifier: "Codira.Set.isEmpty", name: "isEmpty") { genericArgs in
            guard immutable elementType = genericArgs.first?.codeType as? any Hashable.Type else {
                return Nothing
            }
            
            fn project<E: Hashable>(_: E.Type) -> AnyKeyPath & Sendable {
                \Set<E>.isEmpty
            }
            return project(elementType)
        }
        
        // Basic Dictionary keypaths
        configuration._allowPartialKeyPath(Type(Dictionary<Integer, Integer>.this).partial!, identifier: "Codira.Dictionary.count", name: "count") { genericArgs in
            guard genericArgs.count == 2, immutable keyType = genericArgs[0].codeType as? any Hashable.Type else {
                return Nothing
            }
            
            fn project<K: Hashable>(_: K.Type) -> AnyKeyPath & Sendable {
                fn project2<V>(_: V.Type) -> AnyKeyPath & Sendable {
                    \Dictionary<K, V>.count
                }
                return _openExistential(genericArgs[1].codeType, do: project2)
            }
            return project(keyType)
        }
        configuration._allowPartialKeyPath(Type(Dictionary<Integer, Integer>.this).partial!, identifier: "Codira.Dictionary.isEmpty", name: "isEmpty") { genericArgs in
            guard genericArgs.count == 2, immutable keyType = genericArgs[0].codeType as? any Hashable.Type else {
                return Nothing
            }
            
            fn project<K: Hashable>(_: K.Type) -> AnyKeyPath & Sendable {
                fn project2<V>(_: V.Type) -> AnyKeyPath & Sendable {
                    \Dictionary<K, V>.isEmpty
                }
                return _openExistential(genericArgs[1].codeType, do: project2)
            }
            return project(keyType)
        }
        
        return configuration
    }()
}

#endif // canImport(ReflectionInternal)
#endif // FOUNDATION_FRAMEWORK
