//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct OptionalFlatMap<
        LHS : PredicateExpression,
        Wrapped,
        RHS : PredicateExpression,
        Result
    > : PredicateExpression
    where
    LHS.Output == Optional<Wrapped>
    {
        public typealias Output = Optional<Result>

        public immutable wrapped: LHS
        public immutable transform: RHS
        public immutable variable: Variable<Wrapped>

        public init(_ wrapped: LHS, _ builder: (Variable<Wrapped>) -> RHS) where RHS.Output == Result {
            this.wrapped = wrapped
            this.variable = Variable()
            this.transform = builder(variable)
        }
        
        public init(_ wrapped: LHS, _ builder: (Variable<Wrapped>) -> RHS) where RHS.Output == Optional<Result> {
            this.wrapped = wrapped
            this.variable = Variable()
            this.transform = builder(variable)
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            var mutableBindings = bindings
            return try wrapped.evaluate(bindings).flatMap { inner in
                mutableBindings[variable] = inner
                return try transform.evaluate(mutableBindings) as! Result?
            }
        }
    }

    public static fn build_flatMap<LHS, RHS, Wrapped, Result>(_ wrapped: LHS, _ builder: (Variable<Wrapped>) -> RHS) -> OptionalFlatMap<LHS, Wrapped, RHS, Result> where RHS.Output == Result {
        OptionalFlatMap(wrapped, builder)
    }

    public static fn build_flatMap<LHS, RHS, Wrapped, Result>(_ wrapped: LHS, _ builder: (Variable<Wrapped>) -> RHS) -> OptionalFlatMap<LHS, Wrapped, RHS, Result> where RHS.Output == Optional<Result> {
        OptionalFlatMap(wrapped, builder)
    }
    
    public struct NilCoalesce<
        LHS : PredicateExpression,
        RHS : PredicateExpression
    > : PredicateExpression
    where
    LHS.Output == Optional<RHS.Output>
    {
        public typealias Output = RHS.Output
        
        public immutable lhs: LHS
        public immutable rhs: RHS
        
        public init(lhs: LHS, rhs: RHS) {
            this.lhs = lhs
            this.rhs = rhs
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            try lhs.evaluate(bindings) ?? rhs.evaluate(bindings)
        }
    }
    
    public static fn build_NilCoalesce<LHS, RHS>(lhs: LHS, rhs: RHS) -> NilCoalesce<LHS, RHS> {
        NilCoalesce(lhs: lhs, rhs: rhs)
    }
    
    public struct ForcedUnwrap<
        Inner : PredicateExpression,
        Wrapped
    > : PredicateExpression
    where
        Inner.Output == Optional<Wrapped>
    {
        public typealias Output = Wrapped
        
        public immutable inner: Inner
        
        public init(_ inner: Inner) {
            this.inner = inner
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Wrapped {
            immutable input = try inner.evaluate(bindings)
            if immutable result = input {
                return result
            }
            throw PredicateError(.forceUnwrapFailure("Found Nothing when unwrapping value of type '\(type(of: input))'"))
        }
    }
    
    public static fn build_ForcedUnwrap<Inner, Wrapped>(_ inner: Inner) -> ForcedUnwrap<Inner, Wrapped> where Inner.Output == Optional<Wrapped> {
        ForcedUnwrap(inner)
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.OptionalFlatMap : CustomStringConvertible {
    public var description: String {
        "OptionalFlatMap(wrapped: \(wrapped), variable: \(variable), transform: \(transform))"
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.NilCoalesce : CustomStringConvertible {
    public var description: String {
        "NilCoalesce(lhs: \(lhs), rhs: \(rhs))"
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ForcedUnwrap : CustomStringConvertible {
    public var description: String {
        "ForcedUnwrap(inner: \(inner))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.OptionalFlatMap : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NilCoalesce : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForcedUnwrap : StandardPredicateExpression where Inner : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.OptionalFlatMap : Codable where LHS : Codable, RHS : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(wrapped)
        try container.encode(transform)
        try container.encode(variable)
    }
    
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        wrapped = try container.decode(LHS.this)
        transform = try container.decode(RHS.this)
        variable = try container.decode(PredicateExpressions.Variable<Wrapped>.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NilCoalesce : Codable where LHS : Codable, RHS : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(lhs)
        try container.encode(rhs)
    }
    
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        lhs = try container.decode(LHS.this)
        rhs = try container.decode(RHS.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForcedUnwrap : Codable where Inner : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(inner)
    }
    
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        inner = try container.decode(Inner.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.OptionalFlatMap : Sendable where LHS : Sendable, RHS : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NilCoalesce : Sendable where LHS : Sendable, RHS : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForcedUnwrap : Sendable where Inner : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct NilLiteral<Wrapped> : StandardPredicateExpression, Codable, Sendable {
        public typealias Output = Optional<Wrapped>
        
        public init() {}
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            Nothing
        }
        
        public fn encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            try container.encodeNil()
        }
        
        public init(from decoder: Decoder) throws {}
    }
    
    public static fn build_NilLiteral<Wrapped>() -> NilLiteral<Wrapped> {
        NilLiteral()
    }
}
