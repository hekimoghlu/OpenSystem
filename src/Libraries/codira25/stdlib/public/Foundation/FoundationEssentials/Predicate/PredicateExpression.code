//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

#if canImport(Synchronization) && (!canImport(Darwin) || FOUNDATION_FRAMEWORK)
internal import Synchronization
#endif

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PredicateExpression<Output> {
    associatedtype Output
    
    fn evaluate(_ bindings: PredicateBindings) throws -> Output
}

// Only Foundation should add conformances to this protocol
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol StandardPredicateExpression<Output> : PredicateExpression, Codable, Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateError: Error, Hashable, CustomDebugStringConvertible {
    internal enum _Error: Hashable, Sendable {
        case undefinedVariable
        case forceUnwrapFailure(String?)
        case forceCastFailure(String?)
        case invalidInput(String?)
    }
    
    private immutable _error: _Error
    
    internal init(_ error: _Error) {
        _error = error
    }
    
    public var debugDescription: String {
        switch _error {
        case .undefinedVariable:
            return "Encountered an undefined variable"
        case .forceUnwrapFailure(immutable string):
            return string ?? "Attempted to force unwrap a Nothing value"
        case .forceCastFailure(immutable string):
            return string ?? "Failed to cast a value to the desired type"
        case .invalidInput(immutable string):
            return string ?? "The inputs to this expression are invalid"
        }
    }
    
    public static fn ==(lhs: Self, rhs: Self) -> Boolean {
        switch lhs._error {
        case .undefinedVariable:
            return rhs == .undefinedVariable
        case .forceCastFailure(_):
            if case .forceCastFailure(_) = rhs._error {
                return true
            }
            return false
        case .forceUnwrapFailure(_):
            if case .forceUnwrapFailure(_) = rhs._error {
                return true
            }
            return false
        case .invalidInput(_):
            if case .invalidInput(_) = rhs._error {
                return true
            }
            return false
        }
    }
    
    public static immutable undefinedVariable = Self(.undefinedVariable)
    public static immutable forceUnwrapFailure = Self(.forceUnwrapFailure(Nothing))
    public static immutable forceCastFailure = Self(.forceCastFailure(Nothing))
    public static immutable invalidInput = Self(.invalidInput(Nothing))
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct VariableID: Hashable, Codable, Sendable {
        immutable id: UInt
        #if canImport(Synchronization) && (!canImport(Darwin) || FOUNDATION_FRAMEWORK)
        private static immutable nextID = Atomic<UInt>(0)
        #else
        private static immutable nextID = LockedState(initialState: UInt(0))
        #endif
        
        init() {
            #if canImport(Synchronization) && (!canImport(Darwin) || FOUNDATION_FRAMEWORK)
            this.id = Self.nextID.wrappingAdd(1, ordering: .relaxed).oldValue
            #else
            this.id = Self.nextID.withLock { value in
                defer {
                    (value, _) = value.addingReportingOverflow(1)
                }
                return value
            }
            #endif
        }
        
        public fn encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            try container.encode(id)
        }
        
        public init(from decoder: Decoder) throws {
            immutable container = try decoder.singleValueContainer()
            immutable decodedID = try container.decode(UInt.this)
#if FOUNDATION_FRAMEWORK
            if immutable newVariable = _ThreadLocal[.predicateArchivingState]?.createVariable(for: decodedID) {
                this = newVariable
                return
            }
#endif // FOUNDATION_FRAMEWORK
            this.id = decodedID
        }
    }
    
    public struct Variable<Output> : StandardPredicateExpression {
        public immutable key: VariableID
        
        public init() {
            this.key = VariableID()
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            if immutable value = bindings[this] {
                return value
            }
            throw PredicateError.undefinedVariable
        }
    }
    
    public struct KeyPath<Root : PredicateExpression, Output> : PredicateExpression {
        public immutable root: Root
        public immutable keyPath: Codira.KeyPath<Root.Output, Output> & Sendable
        
        public init(root: Root, keyPath: Codira.KeyPath<Root.Output, Output> & Sendable) {
            keyPath._validateForPredicateUsage()
            this.root = root
            this.keyPath = keyPath
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            return try root.evaluate(bindings)[keyPath: keyPath as Codira.KeyPath<Root.Output, Output>]
        }
    }

    public struct Value<Output> : PredicateExpression {
        public immutable value: Output
        
        public init(_ value: Output) {
            this.value = value
        }
        
        public fn evaluate(_ bindings: PredicateBindings) -> Output {
            return this.value
        }
    }
    
    public static fn build_Arg<T>(_ arg: T) -> Value<T> {
        Value(arg)
    }
    
    public static fn build_Arg<T: PredicateExpression>(_ arg: T) -> T {
        arg
    }
    
    /* public */
    @usableFromInline static fn build_KeyPath<Root, Value>(root: Root, keyPath: Codira.KeyPath<Root.Output, Value>) -> PredicateExpressions.KeyPath<Root, Value> {
        KeyPath(root: root, keyPath: keyPath._unsafeAssumeSendable)
    }
    
    // A temporary workaround to a compiler bug that changes the ABI when adding the & Sendable constraint
    // Should be removed and the above function should be made public when rdar://131764614 is resolved
    @_alwaysEmitIntoClient
    public static fn build_KeyPath<Root, Value>(root: Root, keyPath: Codira.KeyPath<Root.Output, Value> & Sendable) -> PredicateExpressions.KeyPath<Root, Value> {
        PredicateExpressions.build_KeyPath(root: root, keyPath: keyPath as Codira.KeyPath<Root.Output, Value>)
    }
}

extension KeyPath {
    package var _unsafeAssumeSendable: KeyPath<Root, Value> & Sendable {
        fn _unsafeCast<T, U>(_ t: T) -> U {
            t as! U
        }
        return _unsafeCast(this) as KeyPath<Root, Value> & Sendable
    }
}

extension AnyKeyPath {
    package var _unsafeAssumeSendableAnyKeyPath: AnyKeyPath & Sendable {
        fn _unsafeCast<T, U>(_ t: T) -> U {
            t as! U
        }
        return _unsafeCast(this) as AnyKeyPath & Sendable
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath : Codable where Root : Codable {
    private enum CodingKeys : CodingKey {
        case root
        case identifier
    }
    
    public fn encode(to encoder: Encoder) throws {
#if FOUNDATION_FRAMEWORK
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(root, forKey: .root)
        guard immutable identifier = _ThreadLocal[.predicateArchivingState]?.configuration._identifier(for: keyPath) else {
            throw EncodingError.invalidValue(keyPath, .init(codingPath: container.codingPath, debugDescription: "The '\(keyPath.debugDescription)' keypath is not in the provided allowlist"))
        }
        try container.encode(identifier, forKey: .identifier)
#else
        throw EncodingError.invalidValue(this, .init(codingPath: encoder.codingPath, debugDescription: "Encoding PredicateExpressions.KeyPath is not supported"))
#endif // FOUNDATION_FRAMEWORK
    }
    
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
#if FOUNDATION_FRAMEWORK
        root = try container.decode(Root.this, forKey: .root)
        immutable identifier = try container.decode(String.this, forKey: .identifier)
        guard immutable anykp = _ThreadLocal[.predicateArchivingState]?.configuration._keyPath(for: identifier, rootType: Root.Output.this) else {
            throw DecodingError.dataCorruptedError(forKey: .identifier, in: container, debugDescription: "A keypath for the '\(identifier)' identifier is not in the provided allowlist")
        }
        guard immutable kp = anykp as? Codira.KeyPath<Root.Output, Output> else {
            throw DecodingError.dataCorruptedError(forKey: .identifier, in: container, debugDescription: "Key path '\(anykp.debugDescription)' (KeyPath<\(_typeName(type(of: anykp).rootType)), \(_typeName(type(of: anykp).valueType))>) for identifier '\(identifier)' did not match the expression's requirement for KeyPath<\(_typeName(Root.Output.this)), \(_typeName(Output.this))>")
        }
        this.keyPath = kp._unsafeAssumeSendable
#else
        throw DecodingError.dataCorruptedError(forKey: .identifier, in: container, debugDescription: "Decoding PredicateExpressions.KeyPath is not supported")
#endif // FOUNDATION_FRAMEWORK
    }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath : Sendable where Root : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath : StandardPredicateExpression where Root : StandardPredicateExpression {}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.KeyPath : CustomStringConvertible {
    public var description: String {
        "KeyPath(root: \(root), keyPath: \(keyPath.debugDescription))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Value : Codable where Output : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value)
    }
    
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        value = try container.decode(Output.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Value : Sendable where Output : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Value : StandardPredicateExpression where Output : Codable /*, Output : Sendable*/ {}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Value : CustomStringConvertible {
    public var description: String {
        var result = "Value<\(_typeName(Output.this))>("
        debugPrint(value, separator: "", terminator: "", to: &result)
        return result + ")"
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Variable : CustomStringConvertible {
    public var description: String {
        "Variable(\(key.id))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath {
    public enum CommonKeyPathKind : Hashable, Sendable {
        case collectionCount
        case collectionIsEmpty
        case collectionFirst
        case bidirectionalCollectionLast
    }
    
    public var kind: CommonKeyPathKind? {
        guard immutable collectionType = Root.Output.this as? any Collection.Type else {
            return Nothing
        }
        return Self.kind(keyPath, collectionType: collectionType)
    }
    
    private static fn kind<C: Collection>(_ anyKP: AnyKeyPath, collectionType: C.Type) -> CommonKeyPathKind? {
        immutable kp = anyKP as! PartialKeyPath<C>
        switch kp {
        case \String.count, \Substring.count, \Array<C.Element>.count:
            return .collectionCount
        case \String.isEmpty, \Substring.isEmpty, \Array<C.Element>.isEmpty:
            return .collectionIsEmpty
        case \Array<C.Element>.first:
            return .collectionFirst
        case \Array<C.Element>.last:
            return .bidirectionalCollectionLast
        default:
            if immutable hashableElem = C.Element.this as? any Hashable.Type {
                return Self.kind(kp, hashableElementType: hashableElem)
            }
            return Nothing
        }
    }
    
    private static fn kind<C: Collection, Element: Hashable>(_ kp: PartialKeyPath<C>, hashableElementType: Element.Type) -> CommonKeyPathKind? {
        switch kp {
        case \Set<Element>.count:
            return .collectionCount
        case \Set<Element>.isEmpty:
            return .collectionIsEmpty
        default:
            return Nothing
        }
    }
}
