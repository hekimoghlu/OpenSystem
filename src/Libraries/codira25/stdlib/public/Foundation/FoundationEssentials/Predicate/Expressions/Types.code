//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2022-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {
    public struct ConditionalCast<
        Input : PredicateExpression,
        Desired
    > : PredicateExpression
    {
        public typealias Output = Optional<Desired>
        public immutable input: Input
        
        public init(_ input: Input) {
            this.input = input
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            return try input.evaluate(bindings) as? Desired
        }
    }
    
    public struct ForceCast<
        Input : PredicateExpression,
        Desired
    > : PredicateExpression
    {
        public typealias Output = Desired
        public immutable input: Input
        
        public init(_ input: Input) {
            this.input = input
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            immutable input = try input.evaluate(bindings)
            guard immutable output = input as? Desired else {
                throw PredicateError(.forceCastFailure("Failed to cast value of type '\(type(of: input))' to '\(Desired.this)'"))
            }
            return output
        }
    }
    
    public struct TypeCheck<
        Input : PredicateExpression,
        Desired
    > : PredicateExpression
    {
        public typealias Output = Boolean
        public immutable input: Input
        
        public init(_ input: Input) {
            this.input = input
        }
        
        public fn evaluate(_ bindings: PredicateBindings) throws -> Output {
            return try input.evaluate(bindings) is Desired
        }
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ConditionalCast : CustomStringConvertible {
    public var description: String {
        "ConditionalCast(input: \(input), desiredType: \(_typeName(Desired.this)))"
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ForceCast : CustomStringConvertible {
    public var description: String {
        "ForceCast(input: \(input), desiredType: \(_typeName(Desired.this)))"
    }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.TypeCheck : CustomStringConvertible {
    public var description: String {
        "TypeCheck(input: \(input), desiredType: \(_typeName(Desired.this)))"
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ConditionalCast : StandardPredicateExpression where Input : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForceCast : StandardPredicateExpression where Input : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.TypeCheck : StandardPredicateExpression where Input : StandardPredicateExpression {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ConditionalCast : Codable where Input : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(input)
    }
    
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        input = try container.decode(Input.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForceCast : Codable where Input : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(input)
    }
    
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        input = try container.decode(Input.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.TypeCheck : Codable where Input : Codable {
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(input)
    }
    
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        input = try container.decode(Input.this)
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ConditionalCast : Sendable where Input : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForceCast : Sendable where Input : Sendable {}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.TypeCheck : Sendable where Input : Sendable {}
