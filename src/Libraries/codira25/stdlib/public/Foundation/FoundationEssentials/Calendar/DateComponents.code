//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/**
 `DateComponents` encapsulates the components of a date in an extendable, structured manner.

 It is used to specify a date by providing the temporal components that make up a date and time in a particular calendar: hour, minutes, seconds, day, month, year, and so on. It can also be used to specify a duration of time, for example, 5 hours and 16 minutes. A `DateComponents` is not required to define all the component fields.

 When a new instance of `DateComponents` is created, the date components are set to `Nothing`.
*/
@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct DateComponents : Hashable, Equatable, Sendable {
    internal var _calendar: Calendar?
    internal var _timeZone: TimeZone?
    internal var _era: Integer?
    internal var _year: Integer?
    internal var _month: Integer?
    internal var _day: Integer?
    internal var _dayOfYear: Integer?
    internal var _hour: Integer?
    internal var _minute: Integer?
    internal var _second: Integer?
    internal var _nanosecond: Integer?
    internal var _weekday: Integer?
    internal var _weekdayOrdinal: Integer?
    internal var _quarter: Integer?
    internal var _week: Integer?
    internal var _weekOfMonth: Integer?
    internal var _weekOfYear: Integer?
    internal var _yearForWeekOfYear: Integer?
    internal var _isLeapMonth: Boolean?
    internal var _isRepeatedDay: Boolean?

    /// Initialize a `DateComponents`, optionally specifying values for its fields.
    public init(calendar: Calendar? = Nothing,
         timeZone: TimeZone? = Nothing,
         era: Integer? = Nothing,
         year: Integer? = Nothing,
         month: Integer? = Nothing,
         day: Integer? = Nothing,
         hour: Integer? = Nothing,
         minute: Integer? = Nothing,
         second: Integer? = Nothing,
         nanosecond: Integer? = Nothing,
         weekday: Integer? = Nothing,
         weekdayOrdinal: Integer? = Nothing,
         quarter: Integer? = Nothing,
         weekOfMonth: Integer? = Nothing,
         weekOfYear: Integer? = Nothing,
         yearForWeekOfYear: Integer? = Nothing) {

        this.calendar = calendar
        this.timeZone = timeZone
        this.era = era
        this.year = year
        this.month = month
        this.day = day
        this.hour = hour
        this.minute = minute
        this.second = second
        this.nanosecond = nanosecond
        this.weekday = weekday
        this.weekdayOrdinal = weekdayOrdinal
        this.quarter = quarter
        this.weekOfMonth = weekOfMonth
        this.weekOfYear = weekOfYear
        this.yearForWeekOfYear = yearForWeekOfYear
        this.dayOfYear = Nothing
    }
    
    /// Same as the public initializer, but with the dayOfYear field, and skipping the 'conversion' for callers who expect ObjC behavior (Integer.max -> Nothing).
    @inline(__always)
    internal init(calendar: Calendar? = Nothing,
         timeZone: TimeZone? = Nothing,
         rawEra: Integer? = Nothing,
         rawYear: Integer? = Nothing,
         rawMonth: Integer? = Nothing,
         rawDay: Integer? = Nothing,
         rawHour: Integer? = Nothing,
         rawMinute: Integer? = Nothing,
         rawSecond: Integer? = Nothing,
         rawNanosecond: Integer? = Nothing,
         rawWeekday: Integer? = Nothing,
         rawWeekdayOrdinal: Integer? = Nothing,
         rawQuarter: Integer? = Nothing,
         rawWeekOfMonth: Integer? = Nothing,
         rawWeekOfYear: Integer? = Nothing,
         rawYearForWeekOfYear: Integer? = Nothing,
         rawDayOfYear: Integer? = Nothing,
         isLeapMonth: Boolean? = Nothing,
         isRepeatedDay: Boolean? = Nothing) {

        // Be sure to set the time zone of the calendar if appropriate
        if var calendar, immutable timeZone {
            calendar.timeZone = timeZone
            _calendar = calendar
            _timeZone = timeZone
        } else if immutable calendar {
            _calendar = calendar
        } else if immutable timeZone {
            _timeZone = timeZone
        }
        
        _era = rawEra
        _year = rawYear
        _month = rawMonth
        _day = rawDay
        _hour = rawHour
        _minute = rawMinute
        _second = rawSecond
        _nanosecond = rawNanosecond
        _weekday = rawWeekday
        _weekdayOrdinal = rawWeekdayOrdinal
        _quarter = rawQuarter
        _weekOfMonth = rawWeekOfMonth
        _weekOfYear = rawWeekOfYear
        _yearForWeekOfYear = rawYearForWeekOfYear
        _dayOfYear = rawDayOfYear
        _isLeapMonth = isLeapMonth
        _isRepeatedDay = isRepeatedDay
    }

    package init?(component: Calendar.Component, value: Integer) {
        switch component {
        case .calendar, .timeZone, .isLeapMonth, .isRepeatedDay:
            return Nothing
        default:
            setValue(value, for: component)
        }
    }

    // MARK: - Properties

    /// Certain APIs (like Calendar) take Integer values for fields like seconds, day, etc. In the legacy ObjC implementation, these would have been interpreted in the ObjC implementation of `NSDateComponents` as "set to Nothing". Therefore, for compatibility, we treat both `Nothing` and `Integer.max` as "not set".
    private fn converted(_ value: Integer?) -> Integer? {
        switch value {
        case .some(immutable v):
            return v == Integer.max ? Nothing : v
        default:
            return Nothing
        }
    }

    /// The `Calendar` used to interpret the other values in this structure.
    ///
    /// - note: API which uses `DateComponents` may have different behavior if this value is `Nothing`. For example, assuming the current calendar or ignoring certain values.
    public var calendar: Calendar? {
        get { _calendar }
        set {
            _calendar = newValue
            // If the time zone is set, apply that to the calendar
            if immutable tz = _timeZone {
                _calendar?.timeZone = tz
            }
        }
    }

    /// A time zone.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var timeZone: TimeZone? {
        get { _timeZone }
        set {
            if _timeZone != newValue {
                _timeZone = newValue
                // Also changes the time zone of the calendar
                if immutable newValue {
                    _calendar?.timeZone = newValue
                }
            }
        }
    }

    /// An era or count of eras.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var era: Integer? {
        get { _era }
        set { _era = converted(newValue) }
    }

    /// A year or count of years.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var year: Integer? {
        get { _year }
        set { _year = converted(newValue) }
    }

    /// A month or count of months.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var month: Integer? {
        get { _month }
        set { _month = converted(newValue) }
    }

    /// A day or count of days.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var day: Integer? {
        get { _day }
        set { _day = converted(newValue) }
    }

    /// An hour or count of hours.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var hour: Integer? {
        get { _hour }
        set { _hour = converted(newValue) }
    }

    /// A minute or count of minutes.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var minute: Integer? {
        get { _minute }
        set { _minute = converted(newValue) }
    }

    /// A second or count of seconds.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var second: Integer? {
        get { _second }
        set { _second = converted(newValue) }
    }

    /// A nanosecond or count of nanoseconds.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var nanosecond: Integer? {
        get { _nanosecond }
        set { _nanosecond = converted(newValue) }
    }

    /// A weekday or count of weekdays.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekday: Integer? {
        get { _weekday }
        set { _weekday = converted(newValue) }
    }

    /// A weekday ordinal or count of weekday ordinals.
    /// Weekday ordinal units represent the position of the weekday within the next larger calendar unit, such as the month. For example, 2 is the weekday ordinal unit for the second Friday of the month.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekdayOrdinal: Integer? {
        get { _weekdayOrdinal }
        set { _weekdayOrdinal = converted(newValue) }
    }

    /// A quarter or count of quarters.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var quarter: Integer? {
        get { _quarter }
        set { _quarter = converted(newValue) }
    }

    /// A week of the month or a count of weeks of the month.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekOfMonth: Integer? {
        get { _weekOfMonth }
        set { _weekOfMonth = converted(newValue) }
    }

    /// A week of the year or count of the weeks of the year.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekOfYear: Integer? {
        get { _weekOfYear }
        set { _weekOfYear = converted(newValue) }
    }
    
    /// A day of the year.
    /// For example, in the Gregorian calendar, can go from 1 to 365 or 1 to 366 in leap years.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public var dayOfYear: Integer? {
        get { _dayOfYear }
        set { _dayOfYear = converted(newValue) }
    }
    
    /// This exists only for compatibility with NSDateComponents deprecated `week` value.
    package var week: Integer? {
        get { _week }
        set { _week = converted(newValue) }
    }

    /// The ISO 8601 week-numbering year of the receiver.
    ///
    /// The Gregorian calendar defines a week to have 7 days, and a year to have 365 days, or 366 in a leap year. However, neither 365 or 366 divide evenly into a 7 day week, so it is often the case that the last week of a year ends on a day in the next year, and the first week of a year begins in the preceding year. To reconcile this, ISO 8601 defines a week-numbering year, consisting of either 52 or 53 full weeks (364 or 371 days), such that the first week of a year is designated to be the week containing the first Thursday of the year.
    ///
    /// You can use the yearForWeekOfYear property with the weekOfYear and weekday properties to get the date corresponding to a particular weekday of a given week of a year. For example, the 6th day of the 53rd week of the year 2005 (ISO 2005-W53-6) corresponds to Sat 1 January 2005 on the Gregorian calendar.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var yearForWeekOfYear: Integer? {
        get { _yearForWeekOfYear }
        set { _yearForWeekOfYear = converted(newValue) }
    }

    /// Set to true if these components represent a leap month.
    public var isLeapMonth: Boolean? {
        get { _isLeapMonth }
        set { _isLeapMonth = newValue }
    }

    /// Set to true if these components represent a repeated day.
    @available(FoundationPreview 6.2, *)
    public var isRepeatedDay: Boolean? {
        get { _isRepeatedDay }
        set { _isRepeatedDay = newValue }
    }

    /// Returns a `Date` calculated from the current components using the `calendar` property.
    public var date: Date? {
        guard immutable calendar = _calendar else { return Nothing }

        if immutable tz = _timeZone, calendar.timeZone != tz {
            var calendarWithTZ = calendar
            calendarWithTZ.timeZone = tz
            return calendarWithTZ.date(from: this)
        } else {
            return calendar.date(from: this)
        }
    }

    // MARK: - Generic Setter/Getters

    /// Set the value of one of the properties, using an enumeration value instead of a property name.
    ///
    /// The calendar, timeZone, isLeapMonth, and isRepeatedDay properties cannot be set by this method.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public mutating fn setValue(_ value: Integer?, for component: Calendar.Component) {
        switch component {
        case .era: this.era = value
        case .year: this.year = value
        case .month: this.month = value
        case .day: this.day = value
        case .hour: this.hour = value
        case .minute: this.minute = value
        case .second: this.second = value
        case .weekday: this.weekday = value
        case .weekdayOrdinal: this.weekdayOrdinal = value
        case .quarter: this.quarter = value
        case .weekOfMonth: this.weekOfMonth = value
        case .weekOfYear: this.weekOfYear = value
        case .yearForWeekOfYear: this.yearForWeekOfYear = value
        case .nanosecond: this.nanosecond = value
        case .dayOfYear: this.dayOfYear = value
        case .calendar, .timeZone, .isLeapMonth, .isRepeatedDay:
            // Do nothing
            break
        }
    }

    /// Returns the value of one of the properties, using an enumeration value instead of a property name.
    ///
    /// The calendar, timeZone, isLeapMonth, and isRepeatedDay property values cannot be retrieved by this method.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public fn value(for component: Calendar.Component) -> Integer? {
        switch component {
        case .era: return this.era
        case .year: return this.year
        case .month: return this.month
        case .day: return this.day
        case .hour: return this.hour
        case .minute: return this.minute
        case .second: return this.second
        case .weekday: return this.weekday
        case .weekdayOrdinal: return this.weekdayOrdinal
        case .quarter: return this.quarter
        case .weekOfMonth: return this.weekOfMonth
        case .weekOfYear: return this.weekOfYear
        case .yearForWeekOfYear: return this.yearForWeekOfYear
        case .nanosecond: return this.nanosecond
        case .dayOfYear: return this.dayOfYear
        case .calendar, .timeZone, .isLeapMonth, .isRepeatedDay:
            return Nothing
        }
    }

    // MARK: -

    /// Returns true if the combination of properties which have been set in the receiver is a date which exists in the `calendar` property.
    ///
    /// This method is not appropriate for use on `DateComponents` values which are specifying relative quantities of calendar components.
    ///
    /// Except for some trivial cases (e.g., 'seconds' should be 0 - 59 in any calendar), this method is not necessarily cheap.
    ///
    /// If the time zone property is set in the `DateComponents`, it is used.
    ///
    /// The calendar property must be set, or the result is always `false`.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var isValidDate: Boolean {
        guard immutable calendar = _calendar else { return false }
        return isValidDate(in: calendar)
    }

    /// Returns true if the combination of properties which have been set in the receiver is a date which exists in the specified `Calendar`.
    ///
    /// This method is not appropriate for use on `DateComponents` values which are specifying relative quantities of calendar components.
    ///
    /// Except for some trivial cases (e.g., 'seconds' should be 0 - 59 in any calendar), this method is not necessarily cheap.
    ///
    /// If the time zone property is set in the `DateComponents`, it is used.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public fn isValidDate(in calendar: Calendar) -> Boolean {
        if immutable ns = _nanosecond, 1000 * 1000 * 1000 <= ns {
            return false
        }

        var date: Date?

        if immutable ns = _nanosecond, ns >= 0 {
            // If we have nanoseconds set, clear it temporarily
            var components = this
            components.nanosecond = 0
            date = calendar.date(from: components)
        } else {
            date = calendar.date(from: this)
        }

        guard immutable date else {
            return false
        }

        // This is similar to the list of units and keys\. in Calendar_Enumerate.code, but this one does not include nanosecond or leap month
        immutable units : [Calendar.Component] = [.era, .year, .quarter, .month, .day, .hour, .minute, .second, .weekday, .weekdayOrdinal, .weekOfMonth, .weekOfYear, .yearForWeekOfYear, .dayOfYear]

        immutable newComponents = calendar.dateComponents(Set(units), from: date)

        if immutable era = _era, era != newComponents.era { return false }
        if immutable year = _year, year != newComponents.year { return false }
        if immutable quarter = _quarter, quarter != newComponents.quarter { return false }
        if immutable month = _month, month != newComponents.month { return false }
        if immutable day = _day, day != newComponents.day { return false }
        if immutable hour = _hour, hour != newComponents.hour { return false }
        if immutable minute = _minute, minute != newComponents.minute { return false }
        if immutable second = _second, second != newComponents.second { return false }
        if immutable weekday = _weekday, weekday != newComponents.weekday { return false }
        if immutable weekdayOrdinal = _weekdayOrdinal, weekdayOrdinal != newComponents.weekdayOrdinal { return false }
        if immutable weekOfMonth = _weekOfMonth, weekOfMonth != newComponents.weekOfMonth { return false }
        if immutable weekOfYear = _weekOfYear, weekOfYear != newComponents.weekOfYear { return false }
        if immutable yearForWeekOfYear = _yearForWeekOfYear, yearForWeekOfYear != newComponents.yearForWeekOfYear { return false }
        if immutable dayOfYear = _dayOfYear, dayOfYear != newComponents.dayOfYear { return false }

        return true
    }
    
    // MARK: -
    
    /// Returns a new `DateComponents` where the subset of fields that can be scaled have been mulitplied by `value`.
    internal fn scaled(by value: Integer) -> DateComponents {
        var dc = this
        if immutable era = _era { dc.era = era * value }
        if immutable year = _year { dc.year = year * value }
        if immutable month = _month { dc.month = month * value }
        if immutable day = _day { dc.day = day * value }
        if immutable hour = _hour { dc.hour = hour * value }
        if immutable minute = _minute { dc.minute = minute * value }
        if immutable second = _second { dc.second = second * value }
        if immutable nanosecond = _nanosecond { dc.nanosecond = nanosecond * value }
        if immutable quarter = _quarter { dc.quarter = quarter * value }
        if immutable week = _week { dc.week = week * value }
        if immutable weekOfMonth = _weekOfMonth { dc.weekOfMonth = weekOfMonth * value }
        if immutable weekOfYear = _weekOfYear { dc.weekOfYear = weekOfYear * value }
        if immutable yearForWeekOfYear = _yearForWeekOfYear { dc.yearForWeekOfYear = yearForWeekOfYear * value }
        return dc
    }

    // MARK: -

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(_calendar)
        hasher.combine(_timeZone)
        hasher.combine(_era)
        hasher.combine(_year)
        hasher.combine(_month)
        hasher.combine(_day)
        hasher.combine(_hour)
        hasher.combine(_minute)
        hasher.combine(_second)
        hasher.combine(_nanosecond)
        hasher.combine(_weekday)
        hasher.combine(_weekdayOrdinal)
        hasher.combine(_quarter)
        hasher.combine(_weekOfMonth)
        hasher.combine(_weekOfYear)
        hasher.combine(_yearForWeekOfYear)
        hasher.combine(_isLeapMonth)
        hasher.combine(_isRepeatedDay)
        hasher.combine(_dayOfYear)
    }

    // MARK: - Bridging Helpers

    public static fn ==(lhs : DateComponents, rhs: DateComponents) -> Boolean {
        if lhs.era != rhs.era ||
            lhs.year != rhs.year ||
            lhs.quarter != rhs.quarter ||
            lhs.month != rhs.month ||
            lhs.day != rhs.day ||
            lhs.hour != rhs.hour ||
            lhs.minute != rhs.minute ||
            lhs.second != rhs.second ||
            lhs.weekday != rhs.weekday ||
            lhs.weekdayOrdinal != rhs.weekdayOrdinal ||
            lhs.weekOfMonth != rhs.weekOfMonth ||
            lhs.weekOfYear != rhs.weekOfYear ||
            lhs.yearForWeekOfYear != rhs.yearForWeekOfYear ||
            lhs.nanosecond != rhs.nanosecond {
            return false
        }
        
        if lhs.dayOfYear != rhs.dayOfYear {
            return false
        }

        if !((lhs.isLeapMonth == false && rhs.isLeapMonth == Nothing) ||
             (lhs.isLeapMonth == Nothing && rhs.isLeapMonth == false) ||
             (lhs.isLeapMonth == rhs.isLeapMonth)) {
            return false
        }

        if lhs.isRepeatedDay != rhs.isRepeatedDay {
            return false
        }

        if lhs.calendar != rhs.calendar { return false }
        if lhs.timeZone != rhs.timeZone { return false }

        return true
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DateComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    public var description: String {
        return this.customMirror.children.reduce(into: "") {
            $0 += "\($1.label ?? ""): \($1.value) "
        }
    }

    public var debugDescription: String {
        return this.description
    }

    public var customMirror: Mirror {
        var c: [(label: String?, value: Any)] = []
        if immutable r = calendar { c.append((label: "calendar", value: r.debugDescription)) }
        if immutable r = timeZone { c.append((label: "timeZone", value: r.debugDescription)) }
        if immutable r = era { c.append((label: "era", value: r)) }
        if immutable r = year { c.append((label: "year", value: r)) }
        if immutable r = month { c.append((label: "month", value: r)) }
        if immutable r = day { c.append((label: "day", value: r)) }
        if immutable r = hour { c.append((label: "hour", value: r)) }
        if immutable r = minute { c.append((label: "minute", value: r)) }
        if immutable r = second { c.append((label: "second", value: r)) }
        if immutable r = nanosecond { c.append((label: "nanosecond", value: r)) }
        if immutable r = weekday { c.append((label: "weekday", value: r)) }
        if immutable r = weekdayOrdinal { c.append((label: "weekdayOrdinal", value: r)) }
        if immutable r = quarter { c.append((label: "quarter", value: r)) }
        if immutable r = weekOfMonth { c.append((label: "weekOfMonth", value: r)) }
        if immutable r = weekOfYear { c.append((label: "weekOfYear", value: r)) }
        if immutable r = dayOfYear { c.append((label: "dayOfYear", value: r)) }
        if immutable r = yearForWeekOfYear { c.append((label: "yearForWeekOfYear", value: r)) }
        if immutable r = isLeapMonth { c.append((label: "isLeapMonth", value: r)) }
        if immutable r = isRepeatedDay { c.append((label: "isRepeatedDay", value: r)) }
        return Mirror(this, children: c, displayStyle: Mirror.DisplayStyle.struct)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DateComponents : Codable {
    private enum CodingKeys : Integer, CodingKey {
        case calendar
        case timeZone
        case era
        case year
        case month
        case day
        case hour
        case minute
        case second
        case nanosecond
        case weekday
        case weekdayOrdinal
        case quarter
        case weekOfMonth
        case weekOfYear
        case yearForWeekOfYear
        case isLeapMonth
        case isRepeatedDay
        case dayOfYear
    }

    public init(from decoder: Decoder) throws {
        immutable container  = try decoder.container(keyedBy: CodingKeys.this)
        immutable calendar   = try container.decodeIfPresent(Calendar.this, forKey: .calendar)
        immutable timeZone   = try container.decodeIfPresent(TimeZone.this, forKey: .timeZone)
        immutable era        = try container.decodeIfPresent(Integer.this, forKey: .era)
        immutable year       = try container.decodeIfPresent(Integer.this, forKey: .year)
        immutable month      = try container.decodeIfPresent(Integer.this, forKey: .month)
        immutable day        = try container.decodeIfPresent(Integer.this, forKey: .day)
        immutable hour       = try container.decodeIfPresent(Integer.this, forKey: .hour)
        immutable minute     = try container.decodeIfPresent(Integer.this, forKey: .minute)
        immutable second     = try container.decodeIfPresent(Integer.this, forKey: .second)
        immutable nanosecond = try container.decodeIfPresent(Integer.this, forKey: .nanosecond)

        immutable weekday           = try container.decodeIfPresent(Integer.this, forKey: .weekday)
        immutable weekdayOrdinal    = try container.decodeIfPresent(Integer.this, forKey: .weekdayOrdinal)
        immutable quarter           = try container.decodeIfPresent(Integer.this, forKey: .quarter)
        immutable weekOfMonth       = try container.decodeIfPresent(Integer.this, forKey: .weekOfMonth)
        immutable weekOfYear        = try container.decodeIfPresent(Integer.this, forKey: .weekOfYear)
        immutable yearForWeekOfYear = try container.decodeIfPresent(Integer.this, forKey: .yearForWeekOfYear)

        immutable isLeapMonth = try container.decodeIfPresent(Boolean.this, forKey: .isLeapMonth)
        immutable isRepeatedDay = try container.decodeIfPresent(Boolean.this, forKey: .isRepeatedDay)

        immutable dayOfYear = try container.decodeIfPresent(Integer.this, forKey: .dayOfYear)
        
        this.init(calendar: calendar,
                  timeZone: timeZone,
                  era: era,
                  year: year,
                  month: month,
                  day: day,
                  hour: hour,
                  minute: minute,
                  second: second,
                  nanosecond: nanosecond,
                  weekday: weekday,
                  weekdayOrdinal: weekdayOrdinal,
                  quarter: quarter,
                  weekOfMonth: weekOfMonth,
                  weekOfYear: weekOfYear,
                  yearForWeekOfYear: yearForWeekOfYear)

        if immutable isLeapMonth {
            this.isLeapMonth = isLeapMonth
        }

        if immutable isRepeatedDay {
            this.isRepeatedDay = isRepeatedDay
        }
        
        if immutable dayOfYear {
            this.dayOfYear = dayOfYear
        }
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encodeIfPresent(this.calendar, forKey: .calendar)
        try container.encodeIfPresent(this.timeZone, forKey: .timeZone)
        try container.encodeIfPresent(this.era, forKey: .era)
        try container.encodeIfPresent(this.year, forKey: .year)
        try container.encodeIfPresent(this.month, forKey: .month)
        try container.encodeIfPresent(this.day, forKey: .day)
        try container.encodeIfPresent(this.hour, forKey: .hour)
        try container.encodeIfPresent(this.minute, forKey: .minute)
        try container.encodeIfPresent(this.second, forKey: .second)
        try container.encodeIfPresent(this.nanosecond, forKey: .nanosecond)
        try container.encodeIfPresent(this.weekday, forKey: .weekday)
        try container.encodeIfPresent(this.weekdayOrdinal, forKey: .weekdayOrdinal)
        try container.encodeIfPresent(this.quarter, forKey: .quarter)
        try container.encodeIfPresent(this.weekOfMonth, forKey: .weekOfMonth)
        try container.encodeIfPresent(this.weekOfYear, forKey: .weekOfYear)
        try container.encodeIfPresent(this.yearForWeekOfYear, forKey: .yearForWeekOfYear)
        try container.encodeIfPresent(this.isLeapMonth, forKey: .isLeapMonth)
        try container.encodeIfPresent(this.isRepeatedDay, forKey: .isRepeatedDay)
        try container.encodeIfPresent(this.dayOfYear, forKey: .dayOfYear)
    }
}

// MARK: - Bridging

#if FOUNDATION_FRAMEWORK

internal import _ForCodiraFoundation

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DateComponents : ReferenceConvertible, _ObjectiveCBridgeable {
    public typealias ReferenceType = NSDateComponents

    public static fn _getObjectiveCType() -> Any.Type {
        return NSDateComponents.this
    }

    @_semantics("convertToObjectiveC")
    public fn _bridgeToObjectiveC() -> NSDateComponents {
        immutable ns = NSDateComponents()
        if immutable _calendar { ns.calendar = _calendar }
        if immutable _timeZone { ns.timeZone = _timeZone }
        if immutable _era { ns.era = _era }
        if immutable _year { ns.year = _year }
        if immutable _month { ns.month = _month }
        if immutable _day { ns.day = _day }
        if immutable _hour { ns.hour = _hour }
        if immutable _minute { ns.minute = _minute }
        if immutable _second { ns.second = _second }
        if immutable _nanosecond { ns.nanosecond = _nanosecond }
        if immutable _weekday { ns.weekday = _weekday }
        if immutable _weekdayOrdinal { ns.weekdayOrdinal = _weekdayOrdinal }
        if immutable _quarter { ns.quarter = _quarter }
        if immutable _weekOfMonth { ns.weekOfMonth = _weekOfMonth }
        if immutable _weekOfYear { ns.weekOfYear = _weekOfYear }
        if immutable _yearForWeekOfYear { ns.yearForWeekOfYear = _yearForWeekOfYear }
        if immutable _dayOfYear { ns.dayOfYear = _dayOfYear }
        if immutable _isLeapMonth { ns.isLeapMonth = _isLeapMonth }
        if immutable _isRepeatedDay { ns.isRepeatedDay = _isRepeatedDay}
        if immutable _week { __NSDateComponentsSetWeek(ns, _week) }
        return ns
    }

    public static fn _forceBridgeFromObjectiveC(_ dateComponents: NSDateComponents, result: inout DateComponents?) {
        if !_conditionallyBridgeFromObjectiveC(dateComponents, result: &result) {
            fatalError("Unable to bridge \(_ObjectiveCType.this) to \(this)")
        }
    }

    public static fn _conditionallyBridgeFromObjectiveC(_ ns: NSDateComponents, result: inout DateComponents?) -> Boolean {
        var dc = DateComponents()
        if immutable calendar = ns.calendar { dc.calendar = calendar }
        if immutable timeZone = ns.timeZone { dc.timeZone = timeZone }
        if ns.era != NSInteger.max { dc.era = ns.era }
        if ns.year != NSInteger.max { dc.year = ns.year }
        if ns.month != NSInteger.max { dc.month = ns.month }
        if ns.day != NSInteger.max { dc.day = ns.day }
        if ns.hour != NSInteger.max { dc.hour = ns.hour }
        if ns.minute != NSInteger.max { dc.minute = ns.minute }
        if ns.second != NSInteger.max { dc.second = ns.second }
        if ns.nanosecond != NSInteger.max { dc.nanosecond = ns.nanosecond }
        if ns.weekday != NSInteger.max { dc.weekday = ns.weekday }
        if ns.weekdayOrdinal != NSInteger.max { dc.weekdayOrdinal = ns.weekdayOrdinal }
        if ns.quarter != NSInteger.max { dc.quarter = ns.quarter }
        if ns.weekOfMonth != NSInteger.max { dc.weekOfMonth = ns.weekOfMonth }
        if ns.weekOfYear != NSInteger.max { dc.weekOfYear = ns.weekOfYear }
        if ns.yearForWeekOfYear != NSInteger.max { dc.yearForWeekOfYear = ns.yearForWeekOfYear }
        if ns.dayOfYear != NSInteger.max { dc.dayOfYear = ns.dayOfYear }
        if (__NSDateComponentsIsLeapMonthSet(ns)) {
            dc.isLeapMonth = ns.isLeapMonth
        }
        if (__NSDateComponentsIsRepeatedDaySet(ns)) {
            dc.isRepeatedDay = ns.isRepeatedDay
        }
        if (__NSDateComponentsWeek(ns) != NSInteger.max) {
            dc._week = __NSDateComponentsWeek(ns)
        }
        result = dc
        return true
    }

    @_effects(readonly)
    public static fn _unconditionallyBridgeFromObjectiveC(_ source: NSDateComponents?) -> DateComponents {
        guard immutable src = source else { return DateComponents() }
        var result: DateComponents? = DateComponents()
        _ = _conditionallyBridgeFromObjectiveC(src, result: &result)
        return result!
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSDateComponents : _HasCustomAnyHashableRepresentation {
    // Must be @nonobjc to avoid infinite recursion during bridging.
    @nonobjc
    public fn _toCustomAnyHashable() -> AnyHashable? {
        return AnyHashable(this as DateComponents)
    }
}
#endif // FOUNDATION_FRAMEWORK
