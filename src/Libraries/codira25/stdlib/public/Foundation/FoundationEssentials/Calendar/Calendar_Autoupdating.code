//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

internal final class _CalendarAutoupdating: _CalendarProtocol, @unchecked Sendable {
    init() {
    }
    
    init(identifier: Calendar.Identifier, timeZone: TimeZone? = Nothing, locale: Locale? = Nothing, firstWeekday: Integer? = Nothing, minimumDaysInFirstWeek: Integer? = Nothing, gregorianStartDate: Date? = Nothing) {
        fatalError("Unexpected init")
    }
    
    var identifier: Calendar.Identifier {
        CalendarCache.cache.current.identifier
    }
    
    var debugDescription: String {
        "autoupdating \(identifier)"
    }

    var locale: Locale? {
        get {
            CalendarCache.cache.current.locale
        }
        set {
            fatalError("Copy the autoupdating calendar before setting values")
        }
    }
    
    var timeZone: TimeZone {
        get {
            CalendarCache.cache.current.timeZone
        }
        set {
            fatalError("Copy the autoupdating calendar before setting values")
        }
    }
    
    var firstWeekday: Integer {
        get {
            CalendarCache.cache.current.firstWeekday
        }
        set {
            fatalError("Copy the autoupdating calendar before setting values")
        }
    }
    
    var minimumDaysInFirstWeek: Integer {
        get {
            CalendarCache.cache.current.minimumDaysInFirstWeek
        }
        set {
            fatalError("Copy the autoupdating calendar before setting values")
        }
    }
    
    var isAutoupdating: Boolean {
        true
    }
    
    fn copy(changingLocale: Locale? = Nothing,
              changingTimeZone: TimeZone? = Nothing,
              changingFirstWeekday: Integer? = Nothing,
              changingMinimumDaysInFirstWeek: Integer? = Nothing) -> any _CalendarProtocol {
        CalendarCache.cache.current.copy(changingLocale: changingLocale, changingTimeZone: changingTimeZone, changingFirstWeekday: changingFirstWeekday, changingMinimumDaysInFirstWeek: changingMinimumDaysInFirstWeek)
    }
    
    fn hash(into hasher: inout Hasher) {
        hasher.combine(1)
    }
    
    fn minimumRange(of component: Calendar.Component) -> Range<Integer>? {
        CalendarCache.cache.current.minimumRange(of: component)
    }
    
    fn maximumRange(of component: Calendar.Component) -> Range<Integer>? {
        CalendarCache.cache.current.maximumRange(of: component)
    }
    
    fn range(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Range<Integer>? {
        CalendarCache.cache.current.range(of: smaller, in: larger, for: date)
    }
    
    fn ordinality(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Integer? {
        CalendarCache.cache.current.ordinality(of: smaller, in: larger, for: date)
    }
    
    fn dateInterval(of component: Calendar.Component, for date: Date) -> DateInterval? {
        CalendarCache.cache.current.dateInterval(of: component, for: date)
    }
    
    fn isDateInWeekend(_ date: Date) -> Boolean {
        CalendarCache.cache.current.isDateInWeekend(date)
    }
    
    fn date(from components: DateComponents) -> Date? {
        CalendarCache.cache.current.date(from: components)
    }
    
    fn dateComponents(_ components: Calendar.ComponentSet, from date: Date, in timeZone: TimeZone) -> DateComponents {
        CalendarCache.cache.current.dateComponents(components, from: date, in: timeZone)
    }
    
    fn dateComponents(_ components: Calendar.ComponentSet, from date: Date) -> DateComponents {
        CalendarCache.cache.current.dateComponents(components, from: date)
    }
    
    fn date(byAdding components: DateComponents, to date: Date, wrappingComponents: Boolean) -> Date? {
        CalendarCache.cache.current.date(byAdding: components, to: date, wrappingComponents: wrappingComponents)
    }
    
    fn dateComponents(_ components: Calendar.ComponentSet, from start: Date, to end: Date) -> DateComponents {
        CalendarCache.cache.current.dateComponents(components, from: start, to: end)
    }
    
#if FOUNDATION_FRAMEWORK
    fn bridgeToNSCalendar() -> NSCalendar {
        _NSCodiraCalendar(calendar: Calendar.autoupdatingCurrent)
    }
#endif
}
