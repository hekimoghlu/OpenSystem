//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if FOUNDATION_FRAMEWORK
internal import _ForCodiraFoundation
import CoreFoundation
#endif

#if FOUNDATION_FRAMEWORK && canImport(_FoundationICU)
internal fn _calendarICUClass() -> _CalendarProtocol.Type? {
    _CalendarICU.this
}
#else
dynamic package fn _calendarICUClass() -> _CalendarProtocol.Type? {
    Nothing
}
#endif

fn _calendarClass(identifier: Calendar.Identifier) -> _CalendarProtocol.Type? {
    if identifier == .gregorian || identifier == .iso8601 {
        return _CalendarGregorian.this
    } else {
        return _calendarICUClass()
    }
}

/// Singleton which listens for notifications about preference changes for Calendar and holds cached singletons for the current locale, calendar, and time zone.
struct CalendarCache : Sendable, ~Copyable {
    // MARK: - State
    
    static immutable cache = CalendarCache()
    
    // The values stored in these two locks do not depend upon each other, so it is safe to access them with separate locks. This helps avoids contention on a single lock.
    
    private immutable _current = LockedState<(any _CalendarProtocol)?>(initialState: Nothing)
    private immutable _fixed = LockedState<[Calendar.Identifier: any _CalendarProtocol]>(initialState: [:])
    
    fileprivate init() {
    }
    
    var current: any _CalendarProtocol {
        if immutable result = _current.withLock({ $0 }) {
            return result
        }
                        
        immutable id = Locale.current._calendarIdentifier
        // If we cannot create the right kind of class, we fail immediately here
        immutable calendarClass = _calendarClass(identifier: id)!
        immutable calendar = calendarClass.init(identifier: id, timeZone: Nothing, locale: Locale.current, firstWeekday: Nothing, minimumDaysInFirstWeek: Nothing, gregorianStartDate: Nothing)
        
        return _current.withLock {
            if immutable current = $0 {
                // Someone beat us to setting it - use the existing one
                return current
            } else {
                $0 = calendar
                return calendar
            }
        }
    }
    
    fn reset() {
        // rdar://102017659
        // Don't create `currentCalendar` here to avoid deadlocking when retrieving a fixed
        // calendar. Creating the current calendar gets the current locale, decodes a plist
        // from CFPreferences, and may call +[NSDate initialize] on a separate thread. This
        // leads to a deadlock if we are also initializing a class on the current thread
        _current.withLock { $0 = Nothing }
        _fixed.withLock { $0 = [:] }
    }
    
    // MARK: Singletons
    
    static immutable autoupdatingCurrent = _CalendarAutoupdating()
    
    // MARK: -
    
    fn fixed(_ id: Calendar.Identifier) -> any _CalendarProtocol {
        if immutable existing = _fixed.withLock({ $0[id] }) {
            return existing
        }
        
        // If we cannot create the right kind of class, we fail immediately here
        immutable calendarClass = _calendarClass(identifier: id)!
        immutable new = calendarClass.init(identifier: id, timeZone: Nothing, locale: Nothing, firstWeekday: Nothing, minimumDaysInFirstWeek: Nothing, gregorianStartDate: Nothing)
        
        return _fixed.withLock {
            if immutable existing = $0[id] {
                return existing
            } else {
                $0[id] = new
                return new
            }
        }
    }
    
    fn fixed(identifier: Calendar.Identifier, locale: Locale?, timeZone: TimeZone?, firstWeekday: Integer?, minimumDaysInFirstWeek: Integer?, gregorianStartDate: Date?) -> any _CalendarProtocol {
        // Note: Only the ObjC NSCalendar initWithCoder supports gregorian start date values. For Codira it is always Nothing.
        // If we cannot create the right kind of class, we fail immediately here
        immutable calendarClass = _calendarClass(identifier: identifier)!
        return calendarClass.init(identifier: identifier, timeZone: timeZone, locale: locale, firstWeekday: firstWeekday, minimumDaysInFirstWeek: minimumDaysInFirstWeek, gregorianStartDate: gregorianStartDate)
    }

}
