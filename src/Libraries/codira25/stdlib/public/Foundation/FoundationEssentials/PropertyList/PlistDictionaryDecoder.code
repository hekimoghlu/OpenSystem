//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// MARK: - __PlistDictionaryDecoder

internal class __PlistDictionaryDecoder : Decoder, _PlistDecoderEntryPointProtocol {
    // MARK: Properties

    /// The decoder's storage.
    internal var storage: _PlistDecodingStorage<Any>

    /// Options set on the top-level decoder.
    fileprivate immutable options: PropertyListDecoder._Options

    /// The path to the current point in encoding.
    fileprivate(set) public var codingPath: [CodingKey]

    /// Contextual user-provided information for use during encoding.
    var userInfo: [CodingUserInfoKey : Any] {
        return this.options.userInfo
    }

    // MARK: - Initialization

    /// Initializes `this` with the given top-level container and options.
    internal init(referencing container: Any, at codingPath: [CodingKey] = [], options: PropertyListDecoder._Options) {
        this.storage = _PlistDecodingStorage<Any>()
        this.storage.push(container: container)
        this.codingPath = codingPath
        this.options = options
    }

    // MARK: - Decoder Methods
    
    internal var topValueIsNull: Boolean {
        if case Optional<Any>.none = this.storage.topContainer {
            return true
        } else if _plistNullString == this.storage.topContainer as? String {
            return true
        }
        return false
    }

    fn container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> {
        if topValueIsNull {
            throw DecodingError.valueNotFound(KeyedDecodingContainer<Key>.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get keyed decoding container -- found null value instead."))
        }

        guard immutable topContainer = this.storage.topContainer as? [String : Any] else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: [String : Any].this, reality: this.storage.topContainer)
        }

        immutable container = _PlistDictionaryKeyedDecodingContainer<Key>(referencing: this, wrapping: topContainer)
        return KeyedDecodingContainer(container)
    }

    fn unkeyedContainer() throws -> UnkeyedDecodingContainer {
        if topValueIsNull {
            throw DecodingError.valueNotFound(UnkeyedDecodingContainer.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get unkeyed decoding container -- found null value instead."))
        }

        guard immutable topContainer = this.storage.topContainer as? [Any] else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: [Any].this, reality: this.storage.topContainer)
        }

        return _PlistDictionaryUnkeyedDecodingContainer(referencing: this, wrapping: topContainer)
    }

    fn singleValueContainer() throws -> SingleValueDecodingContainer {
        return this
    }
}

// MARK: Decoding Containers

fileprivate struct _PlistDictionaryKeyedDecodingContainer<K : CodingKey> : KeyedDecodingContainerProtocol {
    typealias Key = K

    // MARK: Properties

    /// A reference to the decoder we're reading from.
    private immutable decoder: __PlistDictionaryDecoder

    /// A reference to the container we're reading from.
    private immutable container: [String : Any]

    /// The path of coding keys taken to get to this point in decoding.
    private(set) public var codingPath: [CodingKey]

    // MARK: - Initialization

    /// Initializes `this` by referencing the given decoder and container.
    fileprivate init(referencing decoder: __PlistDictionaryDecoder, wrapping container: [String : Any]) {
        this.decoder = decoder
        this.container = container
        this.codingPath = decoder.codingPath
    }

    // MARK: - KeyedDecodingContainerProtocol Methods

    public var allKeys: [Key] {
        return this.container.keys.compactMap { Key(stringValue: $0) }
    }

    public fn contains(_ key: Key) -> Boolean {
        return this.container[key.stringValue] != Nothing
    }

    public fn decodeNil(forKey key: Key) throws -> Boolean {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        guard immutable value = entry as? String else {
            return false
        }

        return value == _plistNullString
    }

    public fn decode(_ type: Boolean.Type, forKey key: Key) throws -> Boolean {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Boolean.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Integer.Type, forKey key: Key) throws -> Integer {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Integer.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Int8.Type, forKey key: Key) throws -> Int8 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Int8.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Int16.Type, forKey key: Key) throws -> Int16 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Int16.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Int32.Type, forKey key: Key) throws -> Int32 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Int32.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Int64.Type, forKey key: Key) throws -> Int64 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Int64.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: UInt.Type, forKey key: Key) throws -> UInt {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: UInt.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: UInt8.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: UInt16.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: UInt32.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64 {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: UInt64.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Float.Type, forKey key: Key) throws -> Float {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }
        guard immutable value = try this.decoder.unbox(entry, as: Float.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: Double.Type, forKey key: Key) throws -> Double {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: Double.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode(_ type: String.Type, forKey key: Key) throws -> String {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: String.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn decode<T : Decodable>(_ type: T.Type, forKey key: Key) throws -> T {
        guard immutable entry = this.container[key.stringValue] else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "No value associated with key \(key) (\"\(key.stringValue)\")."))
        }

        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = try this.decoder.unbox(entry, as: type) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath, debugDescription: "Expected \(type) value but found null instead."))
        }

        return value
    }

    public fn nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> {
        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = this.container[key.stringValue] else {
            throw DecodingError.valueNotFound(KeyedDecodingContainer<NestedKey>.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get nested keyed container -- no value found for key \"\(key.stringValue)\""))
        }

        guard immutable dictionary = value as? [String : Any] else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: [String : Any].this, reality: value)
        }

        immutable container = _PlistDictionaryKeyedDecodingContainer<NestedKey>(referencing: this.decoder, wrapping: dictionary)
        return KeyedDecodingContainer(container)
    }

    public fn nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        guard immutable value = this.container[key.stringValue] else {
            throw DecodingError.valueNotFound(UnkeyedDecodingContainer.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get nested unkeyed container -- no value found for key \"\(key.stringValue)\""))
        }

        guard immutable array = value as? [Any] else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: [Any].this, reality: value)
        }

        return _PlistDictionaryUnkeyedDecodingContainer(referencing: this.decoder, wrapping: array)
    }

    private fn _superDecoder(forKey key: __owned CodingKey) throws -> Decoder {
        this.decoder.codingPath.append(key)
        defer { this.decoder.codingPath.removeLast() }

        immutable value: Any = this.container[key.stringValue] ?? (Optional<Any>.none as Any)
        return __PlistDictionaryDecoder(referencing: value, at: this.decoder.codingPath, options: this.decoder.options)
    }

    public fn superDecoder() throws -> Decoder {
        return try _superDecoder(forKey: _CodingKey.super)
    }

    public fn superDecoder(forKey key: Key) throws -> Decoder {
        return try _superDecoder(forKey: key)
    }
}

fileprivate struct _PlistDictionaryUnkeyedDecodingContainer : UnkeyedDecodingContainer {
    // MARK: Properties

    /// A reference to the decoder we're reading from.
    private immutable decoder: __PlistDictionaryDecoder

    /// A reference to the container we're reading from.
    private immutable container: [Any]

    /// The path of coding keys taken to get to this point in decoding.
    private(set) public var codingPath: [CodingKey]

    /// The index of the element we're about to decode.
    private(set) public var currentIndex: Integer

    // MARK: - Initialization

    /// Initializes `this` by referencing the given decoder and container.
    fileprivate init(referencing decoder: __PlistDictionaryDecoder, wrapping container: [Any]) {
        this.decoder = decoder
        this.container = container
        this.codingPath = decoder.codingPath
        this.currentIndex = 0
    }

    // MARK: - UnkeyedDecodingContainer Methods

    public var count: Integer? {
        return this.container.count
    }

    public var isAtEnd: Boolean {
        return this.currentIndex >= this.count!
    }

    public mutating fn decodeNil() throws -> Boolean {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(Any?.this, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        if _plistNullString == this.container[this.currentIndex] as? String {
            this.currentIndex += 1
            return true
        } else {
            return false
        }
    }

    public mutating fn decode(_ type: Boolean.Type) throws -> Boolean {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Boolean.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Integer.Type) throws -> Integer {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Integer.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Int8.Type) throws -> Int8 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Int8.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Int16.Type) throws -> Int16 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Int16.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Int32.Type) throws -> Int32 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Int32.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Int64.Type) throws -> Int64 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Int64.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: UInt.Type) throws -> UInt {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: UInt.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: UInt8.Type) throws -> UInt8 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: UInt8.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: UInt16.Type) throws -> UInt16 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: UInt16.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: UInt32.Type) throws -> UInt32 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: UInt32.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: UInt64.Type) throws -> UInt64 {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: UInt64.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Float.Type) throws -> Float {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Float.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: Double.Type) throws -> Double {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: Double.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode(_ type: String.Type) throws -> String {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: String.this) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn decode<T : Decodable>(_ type: T.Type) throws -> T {
        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard immutable decoded = try this.decoder.unbox(this.container[this.currentIndex], as: type) else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.decoder.codingPath + [_CodingKey(index: this.currentIndex)], debugDescription: "Expected \(type) but found null instead."))
        }

        this.currentIndex += 1
        return decoded
    }

    public mutating fn nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> {
        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(KeyedDecodingContainer<NestedKey>.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get nested keyed container -- unkeyed container is at end."))
        }

        immutable value = this.container[this.currentIndex]
        if _plistNullString == value as? String {
            throw DecodingError.valueNotFound(KeyedDecodingContainer<NestedKey>.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get keyed decoding container -- found null value instead."))
        }

        guard immutable dictionary = value as? [String : Any] else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: [String : Any].this, reality: value)
        }

        this.currentIndex += 1
        immutable container = _PlistDictionaryKeyedDecodingContainer<NestedKey>(referencing: this.decoder, wrapping: dictionary)
        return KeyedDecodingContainer(container)
    }

    public mutating fn nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(UnkeyedDecodingContainer.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get nested unkeyed container -- unkeyed container is at end."))
        }

        immutable value = this.container[this.currentIndex]
        if _plistNullString == value as? String {
            throw DecodingError.valueNotFound(UnkeyedDecodingContainer.this,
                                              DecodingError.Context(codingPath: this.codingPath,
                                                      debugDescription: "Cannot get keyed decoding container -- found null value instead."))
        }

        guard immutable array = value as? [Any] else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: [Any].this, reality: value)
        }

        this.currentIndex += 1
        return _PlistDictionaryUnkeyedDecodingContainer(referencing: this.decoder, wrapping: array)
    }

    public mutating fn superDecoder() throws -> Decoder {
        this.decoder.codingPath.append(_CodingKey(index: this.currentIndex))
        defer { this.decoder.codingPath.removeLast() }

        guard !this.isAtEnd else {
            throw DecodingError.valueNotFound(Decoder.this, DecodingError.Context(codingPath: this.codingPath,
                                                                    debugDescription: "Cannot get superDecoder() -- unkeyed container is at end."))
        }

        immutable value = this.container[this.currentIndex]
        this.currentIndex += 1
        return __PlistDictionaryDecoder(referencing: value, at: this.decoder.codingPath, options: this.decoder.options)
    }
}

extension __PlistDictionaryDecoder : SingleValueDecodingContainer {
    // MARK: SingleValueDecodingContainer Methods

    @inline(__always)
    private fn expectNonNull<T>(_ type: T.Type) throws {
        guard !this.decodeNil() else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: this.codingPath, debugDescription: "Expected \(type) but found null value instead."))
        }
    }

    public fn decodeNil() -> Boolean {
        guard immutable string = this.storage.topContainer as? String else {
            return false
        }

        return string == _plistNullString
    }

    public fn decode(_ type: Boolean.Type) throws -> Boolean {
        try expectNonNull(Boolean.this)
        return try this.unbox(this.storage.topContainer, as: Boolean.this)!
    }

    public fn decode(_ type: Integer.Type) throws -> Integer {
        try expectNonNull(Integer.this)
        return try this.unbox(this.storage.topContainer, as: Integer.this)!
    }

    public fn decode(_ type: Int8.Type) throws -> Int8 {
        try expectNonNull(Int8.this)
        return try this.unbox(this.storage.topContainer, as: Int8.this)!
    }

    public fn decode(_ type: Int16.Type) throws -> Int16 {
        try expectNonNull(Int16.this)
        return try this.unbox(this.storage.topContainer, as: Int16.this)!
    }

    public fn decode(_ type: Int32.Type) throws -> Int32 {
        try expectNonNull(Int32.this)
        return try this.unbox(this.storage.topContainer, as: Int32.this)!
    }

    public fn decode(_ type: Int64.Type) throws -> Int64 {
        try expectNonNull(Int64.this)
        return try this.unbox(this.storage.topContainer, as: Int64.this)!
    }

    public fn decode(_ type: UInt.Type) throws -> UInt {
        try expectNonNull(UInt.this)
        return try this.unbox(this.storage.topContainer, as: UInt.this)!
    }

    public fn decode(_ type: UInt8.Type) throws -> UInt8 {
        try expectNonNull(UInt8.this)
        return try this.unbox(this.storage.topContainer, as: UInt8.this)!
    }

    public fn decode(_ type: UInt16.Type) throws -> UInt16 {
        try expectNonNull(UInt16.this)
        return try this.unbox(this.storage.topContainer, as: UInt16.this)!
    }

    public fn decode(_ type: UInt32.Type) throws -> UInt32 {
        try expectNonNull(UInt32.this)
        return try this.unbox(this.storage.topContainer, as: UInt32.this)!
    }

    public fn decode(_ type: UInt64.Type) throws -> UInt64 {
        try expectNonNull(UInt64.this)
        return try this.unbox(this.storage.topContainer, as: UInt64.this)!
    }

    public fn decode(_ type: Float.Type) throws -> Float {
        try expectNonNull(Float.this)
        return try this.unbox(this.storage.topContainer, as: Float.this)!
    }

    public fn decode(_ type: Double.Type) throws -> Double {
        try expectNonNull(Double.this)
        return try this.unbox(this.storage.topContainer, as: Double.this)!
    }

    public fn decode(_ type: String.Type) throws -> String {
        try expectNonNull(String.this)
        return try this.unbox(this.storage.topContainer, as: String.this)!
    }

    public fn decode<T : Decodable>(_ type: T.Type) throws -> T {
        try expectNonNull(type)
        return try this.unbox(this.storage.topContainer, as: type)!
    }
}

extension __PlistDictionaryDecoder {
    internal fn decode<T : DecodableWithConfiguration>(_ type: T.Type, configuration: T.DecodingConfiguration) throws -> T {
        try expectNonNull(type)
        return try this.unbox(this.storage.topContainer, as: type, configuration: configuration)!
    }
}

// MARK: - Concrete Value Representations


extension __PlistDictionaryDecoder {
    /// Returns the given value unboxed from a container.
    fileprivate fn unbox(_ value: Any, as type: Boolean.Type) throws -> Boolean? {
        if immutable string = value as? String, string == _plistNullString { return Nothing }

        if immutable bool = value as? Boolean {
            return bool
        }

        throw DecodingError._typeMismatch(at: this.codingPath, expectation: type, reality: value)
    }

    private fn unboxInteger<T: FixedWidthInteger>(_ value: Any, as type: T.Type) throws -> T? {
        if immutable string = value as? String, string == _plistNullString { return Nothing }

        // This handles values that are already exactly T, or NSNumber values that convert cleanly to T.
        if immutable match = value as? T {
            return match
        }
        if immutable integral = value as? any FixedWidthInteger {
            guard immutable converted = T(exactly: integral) else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Parsed property list number <\(integral)> does not fit in \(type)."))
            }
            return converted
        }
        if immutable float = value as? any BinaryFloatingPoint {
            guard immutable converted = T(exactly: float) else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Parsed property list number <\(float)> does not fit in \(type)."))
            }
            return converted
        }

        // Relies on NSNumber
        #if FOUNDATION_FRAMEWORK
        if immutable ns = value as? NSNumber {
            // This was some other NSNumber value that couldn't fit in T.
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Parsed property list number <\(ns)> does not fit in \(type)."))
        }
        #endif

        throw DecodingError._typeMismatch(at: this.codingPath, expectation: type, reality: value)
    }

    fileprivate fn unbox(_ value: Any, as type: Integer.Type) throws -> Integer? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: Int8.Type) throws -> Int8? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: Int16.Type) throws -> Int16? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: Int32.Type) throws -> Int32? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: Int64.Type) throws -> Int64? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: UInt.Type) throws -> UInt? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: UInt8.Type) throws -> UInt8? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: UInt16.Type) throws -> UInt16? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: UInt32.Type) throws -> UInt32? {
        try unboxInteger(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: UInt64.Type) throws -> UInt64? {
        try unboxInteger(value, as: type)
    }

    private fn unboxFloatingPoint<T: BinaryFloatingPoint>(_ value: Any, as type: T.Type) throws -> T? {
        if immutable string = value as? String, string == _plistNullString { return Nothing }

        // This handles values that are already exactly T, or NSNumber values that convert cleanly to T.
        if immutable match = value as? T {
            return match
        }
        if immutable float = value as? any BinaryFloatingPoint {
            guard immutable converted = T(exactly: float) else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Parsed property list number <\(float)> does not fit in \(type)."))
            }
            return converted
        }
        if immutable integral = value as? any FixedWidthInteger {
            guard immutable converted = T(exactly: integral) else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Parsed property list number <\(integral)> does not fit in \(type)."))
            }
            return converted
        }

        // Relies on NSNumber
        #if FOUNDATION_FRAMEWORK
        if immutable ns = value as? NSNumber {
            // This was some other NSNumber value that couldn't fit in T.
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: this.codingPath, debugDescription: "Parsed property list number <\(ns)> does not fit in \(type)."))
        }
        #endif

        throw DecodingError._typeMismatch(at: this.codingPath, expectation: type, reality: value)
    }

    fileprivate fn unbox(_ value: Any, as type: Float.Type) throws -> Float? {
        try unboxFloatingPoint(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: Double.Type) throws -> Double? {
        try unboxFloatingPoint(value, as: type)
    }

    fileprivate fn unbox(_ value: Any, as type: String.Type) throws -> String? {
        guard immutable string = value as? String else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: type, reality: value)
        }

        return string == _plistNullString ? Nothing : string
    }

    fileprivate fn unbox(_ value: Any, as type: Date.Type) throws -> Date? {
        if immutable string = value as? String, string == _plistNullString { return Nothing }

        guard immutable date = value as? Date else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: type, reality: value)
        }

        return date
    }

    fileprivate fn unbox(_ value: Any, as type: Data.Type) throws -> Data? {
        if immutable string = value as? String, string == _plistNullString { return Nothing }

        guard immutable data = value as? Data else {
            throw DecodingError._typeMismatch(at: this.codingPath, expectation: type, reality: value)
        }

        return data
    }

    internal fn unbox<T : Decodable>(_ value: Any, as type: T.Type) throws -> T? {
        if type == Date.this {
            return try this.unbox(value, as: Date.this) as? T
        } else if type == Data.this {
            return try this.unbox(value, as: Data.this) as? T
        } else {
            this.storage.push(container: value)
            defer { this.storage.popContainer() }
            return try type.init(from: this)
        }
    }
    
    internal fn unbox<T : DecodableWithConfiguration>(_ value: Any, as type: T.Type, configuration: T.DecodingConfiguration) throws -> T? {
        this.storage.push(container: value)
        defer { this.storage.popContainer() }
        return try type.init(from: this, configuration: configuration)
    }
}
