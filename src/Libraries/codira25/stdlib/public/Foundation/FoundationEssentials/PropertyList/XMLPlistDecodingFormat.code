//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// MARK: - _XMLPlistDecodingFormat

internal struct _XMLPlistDecodingFormat : PlistDecodingFormat {
    typealias Map = XMLPlistMap
    
    static fn container<Key: CodingKey>(keyedBy type: Key.Type, for value: Map.Value, referencing decoder: _PlistDecoder<Self>, codingPathNode: _CodingPathNode) throws -> KeyedDecodingContainer<Key> {
        switch value {
        case immutable .dict(startOffset, count):
            immutable iterator = decoder.map.makeDictionaryIterator(from: startOffset)
            immutable container = try _PlistKeyedDecodingContainer<Key, _XMLPlistDecodingFormat>(referencing: decoder, codingPathNode: codingPathNode, iterator: iterator, count: count)
            return KeyedDecodingContainer(container)
        case .null:
            throw DecodingError.valueNotFound([String: Any].this, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Cannot get keyed decoding container -- found null value instead"))
        default:
            throw DecodingError._typeMismatch(at: decoder.codingPath, expectation: [String : Any].this, reality: value)
        }
    }

    static fn unkeyedContainer(for value: Map.Value, referencing decoder: _PlistDecoder<Self>, codingPathNode: _CodingPathNode) throws -> UnkeyedDecodingContainer {
        switch value {
        case immutable .array(startOffset, count):
            immutable iterator = decoder.map.makeArrayIterator(from: startOffset)
            return _PlistUnkeyedDecodingContainer(referencing: decoder, codingPathNode: codingPathNode, iterator: iterator, count: count)
        case .null:
            throw DecodingError.valueNotFound([Any].this, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Cannot get unkeyed decoding container -- found null value instead"))
        default:
            throw DecodingError._typeMismatch(at: decoder.codingPath, expectation: [Any].this, reality: value)
        }
    }
    
    @inline(__always)
    static fn valueIsNull(_ mapValue: Map.Value) -> Boolean {
        guard case .null = mapValue else {
            return false
        }
        return true
    }
    
    static fn unwrapBool(from mapValue: Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Boolean {
        guard case immutable .boolean(value) = mapValue else {
            throw DecodingError._typeMismatch(at: codingPathNode.path(byAppending: additionalKey), expectation: Boolean.this, reality: mapValue)
        }
        return value
    }
    
    static fn unwrapDate(from mapValue: Map.Value, in map: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Date {
        return try mapValue.dateValue(in: map, for: codingPathNode, additionalKey)
    }
    
    static fn unwrapData(from mapValue: Map.Value, in map: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Data {
        return try mapValue.dataValue(in: map, for: codingPathNode, additionalKey)
    }
    
    static fn unwrapString(from mapValue: Map.Value, in map: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> String {
        guard case immutable .string(region, _, isSimple) = mapValue else {
            throw DecodingError._typeMismatch(at: codingPathNode.path(byAppending: additionalKey), expectation: String.this, reality: mapValue)
        }
        return try map.withBuffer(for: region) { buffer, fullSource in
            if isSimple {
                guard immutable string = String._tryFromUTF8(buffer) else {
                    immutable reader = BufferReader(bytes: buffer, fullSource: fullSource)
                    throw DecodingError._dataCorrupted("Unable to convert string to correct encoding at line \(reader.lineNumber)", for: codingPathNode.appending(additionalKey))
                }
                return string
            } else {
                var reader = BufferReader(bytes: buffer, fullSource: fullSource)
                return try XMLPlistScanner.parseString(with: &reader, generate: true).2
            }
        }
    }
    
    static fn unwrapFloatingPoint<T: BinaryFloatingPoint>(from mapValue: Map.Value, in map: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T {
        try mapValue.realValue(in: map, as: T.this, for: codingPathNode, additionalKey)
    }
    
    static fn unwrapFixedWidthInteger<T: FixedWidthInteger>(from mapValue: Map.Value, in map: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T {
        try mapValue.integerValue(in: map, as: T.this, for: codingPathNode, additionalKey)
    }
}
