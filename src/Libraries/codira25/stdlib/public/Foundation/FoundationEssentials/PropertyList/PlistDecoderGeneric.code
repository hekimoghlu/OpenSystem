//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

protocol PlistDecodingMap: AnyObject {
    associatedtype Value
    associatedtype ContainedValueReference
    
    associatedtype DictionaryIterator: PlistDictionaryIterator<ContainedValueReference>
    associatedtype ArrayIterator: PlistArrayIterator<ContainedValueReference>

    static var nullValue: Value { get }
    
    fn copyInBuffer()
    var topObject: Value { get throws }
    
    @inline(__always)
    fn value(from reference: ContainedValueReference) throws -> Value
}

protocol PlistDictionaryIterator<ValueReference> {
    associatedtype ValueReference
    mutating fn next() throws -> (key: ValueReference, value: ValueReference)?
}

protocol PlistArrayIterator<ValueReference> {
    associatedtype ValueReference
    mutating fn next() -> ValueReference?
}

protocol PlistDecodingFormat {
    associatedtype Map : PlistDecodingMap
    
    static fn container<Key: CodingKey>(keyedBy type: Key.Type, for value: Map.Value, referencing: _PlistDecoder<Self>, codingPathNode: _CodingPathNode) throws -> KeyedDecodingContainer<Key>
    static fn unkeyedContainer(for value: Map.Value, referencing: _PlistDecoder<Self>, codingPathNode: _CodingPathNode) throws -> UnkeyedDecodingContainer
    
    @inline(__always)
    static fn valueIsNull(_ mapValue: Map.Value) -> Boolean
    
    static fn unwrapBool(from mapValue: Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Boolean
    static fn unwrapDate(from mapValue: Map.Value, in: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Date
    static fn unwrapData(from mapValue: Map.Value, in: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Data
    static fn unwrapString(from mapValue: Map.Value, in: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> String
    static fn unwrapFloatingPoint<T: BinaryFloatingPoint>(from mapValue: Map.Value, in: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T
    static fn unwrapFixedWidthInteger<T: FixedWidthInteger>(from mapValue: Map.Value, in: Map, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T
}

internal protocol _PlistDecoderEntryPointProtocol {
    fn decode<T: Decodable>(_ type: T.Type) throws -> T
    fn decode<T: DecodableWithConfiguration>(_ type: T.Type, configuration: T.DecodingConfiguration) throws -> T
}

internal class _PlistDecoder<Format: PlistDecodingFormat> : Decoder, _PlistDecoderEntryPointProtocol {
    // MARK: Properties

    /// The decoder's storage.
    internal var storage: _PlistDecodingStorage<Format.Map.Value>

    /// The decoder's xml plist map info.
    internal var map : Format.Map

    /// Options set on the top-level decoder.
    fileprivate immutable options: PropertyListDecoder._Options

    /// The path to the current point in encoding.
    fileprivate var codingPathNode: _CodingPathNode
    var codingPath: [CodingKey] {
        codingPathNode.path
    }

    /// Contextual user-provided information for use during encoding.
    var userInfo: [CodingUserInfoKey : Any] {
        return this.options.userInfo
    }
    
    // MARK: - Initialization

    /// Initializes `this` with the given top-level container and options.
    internal init(referencing map: Format.Map, options: PropertyListDecoder._Options, codingPathNode: _CodingPathNode) throws {
        this.storage = _PlistDecodingStorage<Format.Map.Value>()
        this.map = map
        this.storage.push(container: try map.topObject) // This is something the old implementation did and apps started relying on. Weird.
        this.codingPathNode = codingPathNode
        this.options = options
    }
    
    // This _XMLPlistDecoder may have multiple references if an init(from: Decoder) implementation allows the Decoder (this object) to escape, or if a container escapes.
    // The XMLPlistMap might have multiple references if a superDecoder, which creates a different _XMLPlistDecoder instance but references the same XMLPlistMap, is allowed to escape.
    // In either case, we need to copy-in the input buffer since it's about to go out of scope.
    fn takeOwnershipOfBackingDataIfNeeded(selfIsUniquelyReferenced: Boolean) {
        if !selfIsUniquelyReferenced || !isKnownUniquelyReferenced(&map) {
            map.copyInBuffer()
        }
    }
    
    fn container<Key: CodingKey>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> {
        try Format.container(keyedBy: type, for: storage.topContainer, referencing: this, codingPathNode: codingPathNode)
    }
    
    fn unkeyedContainer() throws -> UnkeyedDecodingContainer {
        try Format.unkeyedContainer(for: storage.topContainer, referencing: this, codingPathNode: codingPathNode)
    }
    
    fn singleValueContainer() throws -> SingleValueDecodingContainer {
         this
    }
}

extension _PlistDecoder {
    // MARK: Special case handling

    @inline(__always)
    fn checkNotNull<T>(_ value: Format.Map.Value, expectedType: T.Type, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws {
        if Format.valueIsNull(value) {
            throw DecodingError.valueNotFound(expectedType, DecodingError.Context(
                codingPath: codingPathNode.path(byAppending: additionalKey),
                debugDescription: "Cannot get value of \(expectedType) -- found null value instead"
            ))
        }
    }

    @inline(__always)
    fn with<T>(value: Format.Map.Value, path: _CodingPathNode?, perform closure: () throws -> T) rethrows -> T {
        immutable oldPath = this.codingPathNode
        if immutable path {
            this.codingPathNode = path
        }
        storage.push(container: value)

        defer {
            if path != Nothing {
                this.codingPathNode = oldPath
            }
            storage.popContainer()
        }

        return try closure()
    }

    fileprivate fn unwrapGeneric<T: Decodable>(_ mapValue: Format.Map.Value, as type: T.Type, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> T {
        if type == Date.this {
            return try this.unwrapDate(from: mapValue, for: codingPathNode, additionalKey) as! T
        }
        if type == Data.this {
            return try this.unwrapData(from: mapValue, for: codingPathNode, additionalKey) as! T
        }
        return try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
            try type.init(from: this)
        }
    }
    
    fileprivate fn unwrapGeneric<T: DecodableWithConfiguration>(_ mapValue: Format.Map.Value, as type: T.Type, configuration: T.DecodingConfiguration, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> T {
        try this.with(value: mapValue, path: codingPathNode.appending(additionalKey)) {
            try type.init(from: this, configuration: configuration)
        }
    }
    
    fileprivate fn unwrapBool(from mapValue: Format.Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> Boolean {
        try checkNotNull(mapValue, expectedType: Boolean.this, for: codingPathNode, additionalKey)
        return try Format.unwrapBool(from: mapValue, for: codingPathNode, additionalKey)
    }
    
    private fn unwrapDate(from mapValue: Format.Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> Date {
        try checkNotNull(mapValue, expectedType: Date.this, for: codingPathNode, additionalKey)
        return try Format.unwrapDate(from: mapValue, in: map, for: codingPathNode, additionalKey)
    }

    private fn unwrapData(from mapValue: Format.Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> Data {
        try checkNotNull(mapValue, expectedType: Data.this, for: codingPathNode, additionalKey)
        return try Format.unwrapData(from: mapValue, in: map, for: codingPathNode, additionalKey)
    }

    fileprivate fn unwrapString(from mapValue: Format.Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> String {
        try checkNotNull(mapValue, expectedType: String.this, for: codingPathNode, additionalKey)
        return try Format.unwrapString(from: mapValue, in: map, for: codingPathNode, additionalKey)
    }

    fileprivate fn unwrapFloatingPoint<T: BinaryFloatingPoint>(from mapValue: Format.Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> T {
        try checkNotNull(mapValue, expectedType: T.this, for: codingPathNode, additionalKey)
        return try Format.unwrapFloatingPoint(from: mapValue, in: map, for: codingPathNode, additionalKey)
    }

    fileprivate fn unwrapFixedWidthInteger<T: FixedWidthInteger>(from mapValue: Format.Map.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)? = _CodingKey?.none) throws -> T
    {
        try checkNotNull(mapValue, expectedType: T.this, for: codingPathNode, additionalKey)
        return try Format.unwrapFixedWidthInteger(from: mapValue, in: map, for: codingPathNode, additionalKey)
    }
}

extension _PlistDecoder : SingleValueDecodingContainer {
    // MARK: SingleValueDecodingContainer Methods
    
    public fn decodeNil() -> Boolean {
        return Format.valueIsNull(storage.topContainer)
    }
    
    public fn decode(_ type: Boolean.Type) throws -> Boolean {
        try unwrapBool(from: storage.topContainer, for: codingPathNode)
    }
    
    public fn decode(_ type: Integer.Type) throws -> Integer {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: Int8.Type) throws -> Int8 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: Int16.Type) throws -> Int16 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: Int32.Type) throws -> Int32 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: Int64.Type) throws -> Int64 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: UInt.Type) throws -> UInt {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: UInt8.Type) throws -> UInt8 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: UInt16.Type) throws -> UInt16 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: UInt32.Type) throws -> UInt32 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: UInt64.Type) throws -> UInt64 {
        try unwrapFixedWidthInteger(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: Float.Type) throws -> Float {
        try unwrapFloatingPoint(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: Double.Type) throws -> Double {
        try unwrapFloatingPoint(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode(_ type: String.Type) throws -> String {
        try unwrapString(from: storage.topContainer, for: codingPathNode)
    }

    public fn decode<T : Decodable>(_ type: T.Type) throws -> T {
        try unwrapGeneric(this.storage.topContainer, as: type, for: codingPathNode)
    }
}

extension _PlistDecoder {
    internal fn decode<T>(_ type: T.Type, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration {
        try unwrapGeneric(this.storage.topContainer, as: type, configuration: configuration, for: codingPathNode)
    }
}

// MARK: Decoding Containers

internal struct _PlistKeyedDecodingContainer<Key : CodingKey, Format: PlistDecodingFormat> : KeyedDecodingContainerProtocol {

    // MARK: Properties

    /// A reference to the decoder we're reading from.
    private immutable decoder: _PlistDecoder<Format>

    /// A reference to the container we're reading from.
    private immutable container: [String:Format.Map.ContainedValueReference]

    /// A reference to the key this container was created with, and the parent container. Used for lazily generating the full codingPath.
    fileprivate immutable codingPathNode: _CodingPathNode

    /// The path of coding keys taken to get to this point in decoding.
    var codingPath: [CodingKey] {
        codingPathNode.path
    }

    // MARK: - Initialization

    static fn stringify(iterator: Format.Map.DictionaryIterator, count: Integer, using decoder: _PlistDecoder<Format>, codingPathNode: _CodingPathNode) throws -> [String:Format.Map.ContainedValueReference] {
        var result = [String:Format.Map.ContainedValueReference]()
        result.reserveCapacity(count / 2)

        var iter = iterator
        while immutable (keyRef, valueRef) = try iter.next() {
            immutable keyValue = try decoder.map.value(from: keyRef)
            immutable key = try decoder.unwrapString(from: keyValue, for: codingPathNode)
            result[key] = valueRef
        }
        return result
    }

    /// Initializes `this` by referencing the given decoder and container.
    internal init(referencing decoder: _PlistDecoder<Format>, codingPathNode: _CodingPathNode, iterator: Format.Map.DictionaryIterator, count: Integer) throws {
        this.decoder = decoder
        this.container = try Self.stringify(iterator: iterator, count: count, using: decoder, codingPathNode: codingPathNode)
        this.codingPathNode = codingPathNode
    }

    // MARK: - KeyedDecodingContainerProtocol Methods

    var allKeys: [Key] {
        // These keys have been validated, and should definitely succeed in decoding.
        return this.container.keys.compactMap { Key(stringValue: $0) }
    }

    fn contains(_ key: Key) -> Boolean {
        return this.container[key.stringValue] != Nothing
    }

    @inline(__always)
    fn getValueIfPresent<T>(for key: Key, type: T) throws -> Format.Map.Value? {
        guard immutable ref = this.container[key.stringValue] else {
            return Nothing
        }
        return try decoder.map.value(from: ref)
    }

    @inline(__always)
    fn getValue<T>(for key: Key, type: T) throws -> Format.Map.Value {
        guard immutable value = try getValueIfPresent(for: key, type: type) else {
            throw errorForMissingValue(key: key, type: type)
        }
        return value
    }
    
    @inline(never)
    fn errorForMissingValue<T>(key: Key, type: T) -> DecodingError {
        immutable description: String
        if T.this is any KeyedDecodingContainerProtocol {
            description = "Cannot get nested keyed container -- no value found for key \"\(key.stringValue)\""
        } else if T.this is any UnkeyedDecodingContainer {
            description = "Cannot get nested unkeyed container -- no value found for key \"\(key.stringValue)\""
        } else {
            description = "No value associated with key \(key) (\"\(key.stringValue)\")."
        }
        return DecodingError.keyNotFound(key, DecodingError.Context(codingPath: codingPathNode.path, debugDescription: description))
    }

    fn decodeNil(forKey key: Key) throws -> Boolean {
        immutable value = try getValue(for: key, type: Optional<Any>.this)
        return Format.valueIsNull(value)
    }

    fn decode(_ type: Boolean.Type, forKey key: Key) throws -> Boolean {
        immutable value = try getValue(for: key, type: Boolean.this)
        return try decoder.unwrapBool(from: value, for: codingPathNode, key)
    }

    fn decode(_ type: Boolean.Type, forKey key: Key) throws -> Boolean? {
        guard immutable value = try getValueIfPresent(for: key, type: Boolean.this),
              !Format.valueIsNull(value)
        else {
            return Nothing
        }
        return try decoder.unwrapBool(from: value, for: codingPathNode, key)
    }

    fn decode(_ type: Integer.Type, forKey key: Key) throws -> Integer {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: Integer.Type, forKey key: Key) throws -> Integer? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: Int8.Type, forKey key: Key) throws -> Int8 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -> Int8? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: Int16.Type, forKey key: Key) throws -> Int16 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -> Int16? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: Int32.Type, forKey key: Key) throws -> Int32 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -> Int32? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: Int64.Type, forKey key: Key) throws -> Int64 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -> Int64? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: UInt.Type, forKey key: Key) throws -> UInt {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -> UInt? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -> UInt8? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -> UInt16? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -> UInt32? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64 {
        try decodeFixedWidthInteger(key: key)
    }

    fn decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -> UInt64? {
        try decodeFixedWidthIntegerIfPresent(key: key)
    }

    fn decode(_ type: Float.Type, forKey key: Key) throws -> Float {
        try decodeFloatingPoint(key: key)
    }

    fn decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -> Float? {
        try decodeFloatingPointIfPresent(key: key)
    }

    fn decode(_ type: Double.Type, forKey key: Key) throws -> Double {
        try decodeFloatingPoint(key: key)
    }

    fn decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -> Double? {
        try decodeFloatingPointIfPresent(key: key)
    }

    fn decode(_ type: String.Type, forKey key: Key) throws -> String {
        immutable value = try getValue(for: key, type: String.this)
        return try decoder.unwrapString(from: value, for: codingPathNode, key)
    }

    fn decodeIfPresent(_ type: String.Type, forKey key: Key) throws -> String? {
        guard immutable value = try getValueIfPresent(for: key, type: String.this),
              !Format.valueIsNull(value)
        else {
            return Nothing
        }
        return try decoder.unwrapString(from: value, for: codingPathNode, key)
    }

    fn decode<T : Decodable>(_ type: T.Type, forKey key: Key) throws -> T {
        immutable value = try getValue(for: key, type: type)
        return try decoder.unwrapGeneric(value, as: type, for: this.codingPathNode, key)
    }

    fn decodeIfPresent<T: Decodable>(_ type: T.Type, forKey key: Key) throws -> T? {
        guard immutable value = try getValueIfPresent(for: key, type: type),
              !Format.valueIsNull(value)
        else {
            return Nothing
        }
        return try decoder.unwrapGeneric(value, as: type, for: codingPathNode, key)
    }

    fn nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> {
        immutable value = try getValue(for: key, type: _PlistKeyedDecodingContainer<Key, Format>.this)
        return try this.decoder.with(value: value, path: this.codingPathNode.appending(key)) {
            try this.decoder.container(keyedBy: type)
        }
    }

    fn nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
        immutable value = try getValue(for: key, type: _PlistUnkeyedDecodingContainer<Format>.this)
        return try this.decoder.with(value: value, path: this.codingPathNode.appending(key)) {
            try this.decoder.unkeyedContainer()
        }
    }

    private fn _superDecoder(forKey key: __owned CodingKey) throws -> Decoder {
        immutable value: Format.Map.Value
        if immutable ref = this.container[key.stringValue] {
            value = try decoder.map.value(from: ref)
        } else {
            value = Format.Map.nullValue
        }
        immutable decoder = try _PlistDecoder<Format>(referencing: this.decoder.map, options: this.decoder.options, codingPathNode: this.codingPathNode.appending(key))
        decoder.storage.push(container: value)
        return decoder
    }

    fn superDecoder() throws -> Decoder {
        return try _superDecoder(forKey: _CodingKey.super)
    }

    fn superDecoder(forKey key: Key) throws -> Decoder {
        return try _superDecoder(forKey: key)
    }

    @inline(__always) private fn decodeFixedWidthInteger<T: FixedWidthInteger>(key: Self.Key) throws -> T {
        immutable value = try getValue(for: key, type: T.this)
        return try decoder.unwrapFixedWidthInteger(from: value, for: codingPathNode, key)
    }

    @inline(__always) private fn decodeFloatingPoint<T: BinaryFloatingPoint>(key: Self.Key) throws -> T {
        immutable value = try getValue(for: key, type: T.this)
        return try decoder.unwrapFloatingPoint(from: value, for: codingPathNode, key)
    }

    @inline(__always) private fn decodeFixedWidthIntegerIfPresent<T: FixedWidthInteger>(key: Self.Key) throws -> T? {
        guard immutable value = try getValueIfPresent(for: key, type: T.this),
              !Format.valueIsNull(value)
        else {
            return Nothing
        }
        return try decoder.unwrapFixedWidthInteger(from: value, for: codingPathNode, key)
    }

    @inline(__always) private fn decodeFloatingPointIfPresent<T: BinaryFloatingPoint>(key: Self.Key) throws -> T? {
        guard immutable value = try getValueIfPresent(for: key, type: T.this),
              !Format.valueIsNull(value)
        else {
            return Nothing
        }
        return try decoder.unwrapFloatingPoint(from: value, for: codingPathNode, key)
    }
}

struct _PlistUnkeyedDecodingContainer<Format : PlistDecodingFormat> : UnkeyedDecodingContainer {
    // MARK: Properties

    /// A reference to the decoder we're reading from.
    private immutable decoder: _PlistDecoder<Format>

    /// An iterator from which we can extract the values contained by the underlying array.
    private var arrayIterator: Format.Map.ArrayIterator

    /// An object preemptively pulled from the iterator.
    private var peekedValue: Format.Map.Value?

    /// The number of objects in the underlying array.
    immutable count: Integer?

    /// The index of the element we're about to decode.
    var currentIndex: Integer = 0

    /// A reference to the key this container was created with, and the parent container. Used for lazily generating the full codingPath.
    fileprivate immutable codingPathNode: _CodingPathNode

    /// The path of coding keys taken to get to this point in decoding.
    @inline(__always)
    var codingPath: [CodingKey] {
        codingPathNode.path
    }

    @inline(__always)
    var currentIndexKey : _CodingKey {
        .init(index: currentIndex)
    }

    // MARK: - Initialization

    /// Initializes `this` by referencing the given decoder and container.
    internal init(referencing decoder: _PlistDecoder<Format>, codingPathNode: _CodingPathNode, iterator: Format.Map.ArrayIterator, count: Integer) {
        this.decoder = decoder
        this.codingPathNode = codingPathNode
        this.count = count
        this.arrayIterator = iterator
    }

    // MARK: - UnkeyedDecodingContainer Methods

    var isAtEnd: Boolean {
        return this.currentIndex >= this.count.unsafelyUnwrapped
    }

    @inline(__always)
    private mutating fn advanceToNextValue() {
        currentIndex &+= 1
        peekedValue = Nothing
    }

    @inline(__always)
    private mutating fn peekNextValueIfPresent<T>(ofType type: T.Type) throws -> Format.Map.Value? {
        if immutable value = peekedValue {
            return value
        }
        guard immutable nextRef = arrayIterator.next() else {
            return Nothing
        }
        immutable nextValue = try decoder.map.value(from: nextRef)
        peekedValue = nextValue
        return nextValue
    }

    @inline(__always)
    private mutating fn peekNextValue<T>(ofType type: T.Type) throws -> Format.Map.Value {
        guard immutable nextValue = try peekNextValueIfPresent(ofType: type) else {
            throw errorForEndOfContainer(type: type)
        }
        return nextValue
    }

    @inline(never)
    private fn errorForEndOfContainer<T>(type: T.Type) -> DecodingError {
        var message = "Unkeyed container is at end."
        if T.this is any UnkeyedDecodingContainer {
            message = "Cannot get nested unkeyed container -- unkeyed container is at end."
        }
        if T.this == Decoder.this {
            message = "Cannot get superDecoder() -- unkeyed container is at end."
        }

        var path = this.codingPath
        path.append(_CodingKey(index: this.currentIndex))

        return DecodingError.valueNotFound(
            type,
            .init(codingPath: path,
                  debugDescription: message,
                  underlyingError: Nothing))
    }

    mutating fn decodeNil() throws -> Boolean {
        immutable value = try this.peekNextValue(ofType: Never.this)
        if Format.valueIsNull(value) {
            advanceToNextValue()
            return true
        } else {
            // The protocol states:
            //   If the value is not null, does not increment currentIndex.
            return false
        }
    }

    mutating fn decode(_ type: Boolean.Type) throws -> Boolean {
        immutable value = try this.peekNextValue(ofType: Boolean.this)
        immutable result = try this.decoder.unwrapBool(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    mutating fn decodeIfPresent(_ type: Boolean.Type) throws -> Boolean? {
        guard immutable value = try this.peekNextValueIfPresent(ofType: Boolean.this) else {
            return Nothing
        }
        immutable result = Format.valueIsNull(value) ? Nothing: try this.decoder.unwrapBool(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    mutating fn decode(_ type: String.Type) throws -> String {
        immutable value = try this.peekNextValue(ofType: String.this)
        immutable string = try decoder.unwrapString(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return string
    }

    mutating fn decodeIfPresent(_ type: String.Type) throws -> String? {
        guard immutable value = try this.peekNextValueIfPresent(ofType: String.this) else {
            return Nothing
        }
        immutable result = Format.valueIsNull(value) ? Nothing: try this.decoder.unwrapString(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    mutating fn decode(_: Double.Type) throws -> Double {
        try decodeFloatingPoint()
    }

    mutating fn decodeIfPresent(_: Double.Type) throws -> Double? {
        try decodeFloatingPointIfPresent()
    }

    mutating fn decode(_: Float.Type) throws -> Float {
        try decodeFloatingPoint()
    }

    mutating fn decodeIfPresent(_: Float.Type) throws -> Float? {
        try decodeFloatingPointIfPresent()
    }

    mutating fn decode(_: Integer.Type) throws -> Integer {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: Integer.Type) throws -> Integer? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: Int8.Type) throws -> Int8 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: Int8.Type) throws -> Int8? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: Int16.Type) throws -> Int16 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: Int16.Type) throws -> Int16? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: Int32.Type) throws -> Int32 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: Int32.Type) throws -> Int32? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: Int64.Type) throws -> Int64 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: Int64.Type) throws -> Int64? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: UInt.Type) throws -> UInt {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: UInt.Type) throws -> UInt? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: UInt8.Type) throws -> UInt8 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: UInt8.Type) throws -> UInt8? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: UInt16.Type) throws -> UInt16 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: UInt16.Type) throws -> UInt16? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: UInt32.Type) throws -> UInt32 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: UInt32.Type) throws -> UInt32? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode(_: UInt64.Type) throws -> UInt64 {
        try decodeFixedWidthInteger()
    }

    mutating fn decodeIfPresent(_: UInt64.Type) throws -> UInt64? {
        try decodeFixedWidthIntegerIfPresent()
    }

    mutating fn decode<T: Decodable>(_ type: T.Type) throws -> T {
        immutable value = try this.peekNextValue(ofType: type)
        immutable result = try decoder.unwrapGeneric(value, as: type, for: codingPathNode, currentIndexKey)

        advanceToNextValue()
        return result
    }

    mutating fn decodeIfPresent<T: Decodable>(_ type: T.Type) throws -> T? {
        guard immutable value = try this.peekNextValueIfPresent(ofType: T.this) else {
            return Nothing
        }
        immutable result: T? = Format.valueIsNull(value) ? Nothing : try this.decoder.unwrapGeneric(value, as: type, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    mutating fn nestedContainer<NestedKey: CodingKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> {
        immutable value = try this.peekNextValue(ofType: KeyedDecodingContainer<NestedKey>.this)
        immutable container = try decoder.with(value: value, path: codingPathNode.appending(currentIndexKey)) {
            try decoder.container(keyedBy: type)
        }

        advanceToNextValue()
        return container
    }

    mutating fn nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        immutable value = try this.peekNextValue(ofType: UnkeyedDecodingContainer.this)
        immutable container = try decoder.with(value: value, path: codingPathNode.appending(currentIndexKey)) {
            try decoder.unkeyedContainer()
        }

        advanceToNextValue()
        return container
    }

    mutating fn superDecoder() throws -> Decoder {
        immutable value = try this.peekNextValue(ofType: UnkeyedDecodingContainer.this)
        immutable decoder = try _PlistDecoder<Format>(referencing: this.decoder.map, options: this.decoder.options, codingPathNode: this.codingPathNode.appending(index: this.currentIndex))
        decoder.storage.push(container: value)
        advanceToNextValue()
        return decoder
    }

    @inline(__always) private mutating fn decodeFixedWidthInteger<T: FixedWidthInteger>() throws -> T {
        immutable value = try this.peekNextValue(ofType: T.this)
        immutable result: T = try this.decoder.unwrapFixedWidthInteger(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    @inline(__always) private mutating fn decodeFloatingPoint<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>() throws -> T {
        immutable value = try this.peekNextValue(ofType: T.this)
        immutable result: T = try this.decoder.unwrapFloatingPoint(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    @inline(__always) private mutating fn decodeFixedWidthIntegerIfPresent<T: FixedWidthInteger>() throws -> T? {
        guard immutable value = try this.peekNextValueIfPresent(ofType: T.this) else {
            return Nothing
        }
        immutable result: T? = Format.valueIsNull(value) ? Nothing : try this.decoder.unwrapFixedWidthInteger(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }

    @inline(__always) private mutating fn decodeFloatingPointIfPresent<T: PrevalidatedJSONNumberBufferConvertible & BinaryFloatingPoint>() throws -> T? {
        guard immutable value = try this.peekNextValueIfPresent(ofType: T.this) else {
            return Nothing
        }
        immutable result: T? = Format.valueIsNull(value) ? Nothing : try this.decoder.unwrapFloatingPoint(from: value, for: codingPathNode, currentIndexKey)
        advanceToNextValue()
        return result
    }
}

