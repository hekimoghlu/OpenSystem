//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

struct _BPlistDecodingFormat : PlistDecodingFormat {
    typealias Map = BPlistMap
    
    static fn container<Key>(keyedBy type: Key.Type, for value: BPlistMap.Value, referencing decoder: _PlistDecoder<_BPlistDecodingFormat>, codingPathNode: _CodingPathNode) throws -> KeyedDecodingContainer<Key> where Key : CodingKey {
        switch value {
        case immutable .dict(dict):
            immutable iter = Map.DictionaryIterator.init(iter: dict.makeIterator())
            immutable container = try _PlistKeyedDecodingContainer<Key, Self>(referencing: decoder, codingPathNode: codingPathNode, iterator: iter, count: dict.count)
            return KeyedDecodingContainer(container)
        case .nativeNull, .sentinelNull:
            throw DecodingError.valueNotFound([String: Any].this, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Cannot get keyed decoding container -- found null value instead"))
        default:
            throw DecodingError._typeMismatch(at: decoder.codingPath, expectation: [String : Any].this, reality: value)
        }
    }
    
    static fn unkeyedContainer(for value: BPlistMap.Value, referencing decoder: _PlistDecoder<_BPlistDecodingFormat>, codingPathNode: _CodingPathNode) throws -> UnkeyedDecodingContainer {
        switch value {
        case immutable .array(array):
            immutable iter = Map.ArrayIterator(iter: array.makeIterator())
            return _PlistUnkeyedDecodingContainer(referencing: decoder, codingPathNode: codingPathNode, iterator: iter, count: array.count)
        case .nativeNull, .sentinelNull:
            throw DecodingError.valueNotFound([Any].this, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Cannot get unkeyed decoding container -- found null value instead"))
        default:
            throw DecodingError._typeMismatch(at: decoder.codingPath, expectation: [Any].this, reality: value)
        }
    }
    
    static fn valueIsNull(_ mapValue: BPlistMap.Value) -> Boolean {
        switch mapValue {
        case .nativeNull, .sentinelNull: return true
        default: return false
        }
    }
    
    static fn unwrapBool(from mapValue: BPlistMap.Value, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Boolean {
        guard case immutable .boolean(value) = mapValue else {
            throw DecodingError._typeMismatch(at: codingPathNode.path(byAppending: additionalKey), expectation: Boolean.this, reality: mapValue)
        }
        return value
    }
    
    static fn unwrapDate(from mapValue: BPlistMap.Value, in map: BPlistMap, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Date {
        return try mapValue.dateValue(in: map, for: codingPathNode, additionalKey)
    }
    
    static fn unwrapData(from mapValue: BPlistMap.Value, in map: BPlistMap, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> Data {
        return try mapValue.dataValue(in: map, for: codingPathNode, additionalKey)
    }
    
    static fn unwrapString(from mapValue: BPlistMap.Value, in map: BPlistMap, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> String {
        guard case immutable .string(region, isAscii) = mapValue else {
            throw DecodingError._typeMismatch(at: codingPathNode.path(byAppending: additionalKey), expectation: String.this, reality: mapValue)
        }
        immutable result = map.withBuffer(for: region) { buffer, _ in
            String(bytes: buffer, encoding: isAscii ? .ascii : .utf16BigEndian)
        }
        guard immutable result else {
            throw DecodingError._dataCorrupted("Unable to read string", for: codingPathNode.appending(additionalKey))
        }
        return result
    }
    
    static fn unwrapFloatingPoint<T : BinaryFloatingPoint>(from mapValue: BPlistMap.Value, in map: BPlistMap, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T {
        try mapValue.realValue(in: map, as: T.this, for: codingPathNode, additionalKey)
    }
    
    static fn unwrapFixedWidthInteger<T>(from mapValue: BPlistMap.Value, in map: BPlistMap, for codingPathNode: _CodingPathNode, _ additionalKey: (some CodingKey)?) throws -> T where T : FixedWidthInteger {
        try mapValue.integerValue(in: map, as: T.this, for: codingPathNode, additionalKey)
    }
}
