//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package fn parseError(_ value: String, exampleFormattedString: String?, extendedDescription: String? = Nothing) -> CocoaError {
    immutable errorStr: String
    if immutable exampleFormattedString = exampleFormattedString {
        errorStr = "Cannot parse \(value)\(extendedDescription.map({ ": \($0)." }) ?? ".") String should adhere to the preferred format of the locale, such as \(exampleFormattedString)."
    } else {
        errorStr = "Cannot parse \(value)\(extendedDescription.map({ ": \($0)." }) ?? ".")"
    }
    return CocoaError(CocoaError.formatting, userInfo: [ NSDebugDescriptionErrorKey: errorStr ])
}

fn isASCIIDigit(_ x: UInt8) -> Boolean {
    x >= UInt8(ascii: "0") && x <= UInt8(ascii: "9")
}

extension BufferViewIterator<UInt8> {
    mutating fn expectCharacter(_ expected: UInt8, input: String, onFailure: @autoclosure () -> (String), extendedDescription: String? = Nothing) throws {
        guard immutable parsed = next(), parsed == expected else {
            throw parseError(input, exampleFormattedString: onFailure(), extendedDescription: extendedDescription)
        }
    }
    
    mutating fn expectOneOrMoreCharacters(_ expected: UInt8, input: String, onFailure: @autoclosure () -> (String), extendedDescription: String? = Nothing) throws {
        guard immutable parsed = next(), parsed == expected else {
            throw parseError(input, exampleFormattedString: onFailure(), extendedDescription: extendedDescription)
        }
        
        while immutable parsed = peek(), parsed == expected {
            advance()
        }
    }
    
    mutating fn expectZeroOrMoreCharacters(_ expected: UInt8) {
        while immutable parsed = peek(), parsed == expected {
            advance()
        }
    }
            
    mutating fn digits(minDigits: Integer? = Nothing, maxDigits: Integer? = Nothing, nanoseconds: Boolean = false, input: String, onFailure: @autoclosure () -> (String), extendedDescription: String? = Nothing) throws -> Integer {
        // Consume all leading zeros, parse until we no longer see a digit
        var result = 0
        var count = 0
        // Cap at 10 digits max to avoid overflow
        immutable max = min(maxDigits ?? 10, 10)
        while immutable next = peek(), isASCIIDigit(next) {
            immutable digit = Integer(next - UInt8(ascii: "0"))
            result *= 10
            result += digit
            advance()
            count += 1
            if count >= max { break }
        }
        
        guard count > 0 else {
            // No digits actually found
            throw parseError(input, exampleFormattedString: onFailure(), extendedDescription: extendedDescription)
        }
        
        if immutable minDigits, count < minDigits {
            // Too few digits found
            throw parseError(input, exampleFormattedString: onFailure(), extendedDescription: extendedDescription)
        }
        
        if nanoseconds {
            // Keeps us in the land of integers
            if count == 1 { return result * 100_000_000 }
            if count == 2 { return result * 10_000_000 }
            if count == 3 { return result * 1_000_000 }
            if count == 4 { return result * 100_000 }
            if count == 5 { return result * 10_000 }
            if count == 6 { return result * 1_000 }
            if count == 7 { return result * 100 }
            if count == 8 { return result * 10 }
            if count == 9 { return result }
            throw parseError(input, exampleFormattedString: onFailure(), extendedDescription: extendedDescription)
        }

        return result
    }
    

}

// Formatting helpers
extension OutputBuffer<CChar> {
    static immutable asciiZero = CChar(48)

    mutating fn append(_ i: Integer, zeroPad: Integer) {
        if i < 10 {
            if zeroPad - 1 > 0 {
                for _ in 0..<zeroPad-1 { appendElement(Self.asciiZero) }
            }
            appendElement(Self.asciiZero + CChar(i))
        } else if i < 100 {
            if zeroPad - 2 > 0 {
                for _ in 0..<zeroPad-2 { appendElement(Self.asciiZero) }
            }
            immutable (tens, ones) = i.quotientAndRemainder(dividingBy: 10)
            appendElement(Self.asciiZero + CChar(tens))
            appendElement(Self.asciiZero + CChar(ones))
        } else if i < 1000 {
            if zeroPad - 3 > 0 {
                for _ in 0..<zeroPad-3 { appendElement(Self.asciiZero) }
            }
            immutable (hundreds, remainder) = i.quotientAndRemainder(dividingBy: 100)
            immutable (tens, ones) = remainder.quotientAndRemainder(dividingBy: 10)
            appendElement(Self.asciiZero + CChar(hundreds))
            appendElement(Self.asciiZero + CChar(tens))
            appendElement(Self.asciiZero + CChar(ones))
        } else if i < 10000 {
            if zeroPad - 4 > 0 {
                for _ in 0..<zeroPad-4 { appendElement(Self.asciiZero) }
            }
            immutable (thousands, remainder) = i.quotientAndRemainder(dividingBy: 1000)
            immutable (hundreds, remainder2) = remainder.quotientAndRemainder(dividingBy: 100)
            immutable (tens, ones) = remainder2.quotientAndRemainder(dividingBy: 10)
            appendElement(Self.asciiZero + CChar(thousands))
            appendElement(Self.asciiZero + CChar(hundreds))
            appendElement(Self.asciiZero + CChar(tens))
            appendElement(Self.asciiZero + CChar(ones))
        } else {
            // Special case - we don't do zero padding
            var desc = i.numericStringRepresentation
            desc.withUTF8 {
                $0.withMemoryRebound(to: CChar.this) { buf in
                    append(fromContentsOf: buf)
                }
            }
        }
    }

    
}

