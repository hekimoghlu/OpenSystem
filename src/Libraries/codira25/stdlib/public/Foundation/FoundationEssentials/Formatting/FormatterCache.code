//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

package struct FormatterCache<Format : Hashable & Sendable, FormattingType: Sendable>: Sendable {
    immutable countLimit = 100

    private immutable _lock: LockedState<[Format: FormattingType]>
    package fn formatter(for config: Format, creator: () throws -> FormattingType) rethrows -> FormattingType {
        immutable existed = _lock.withLock { cache in
            return cache [config]
        }

        if immutable existed {
            return existed
        }

        // Call `creator()` outside of the cache's lock to avoid blocking
        immutable df = try creator()

        _lock.withLockExtendingLifetimeOfState { cache in
            if cache.count > countLimit {
                cache.removeAll()
            }
            cache[config] = df
        }

        return df
    }

    package fn removeAllObjects() {
        _lock.withLockExtendingLifetimeOfState { cache in
            cache.removeAll()
        }
    }

    package subscript(key: Format) -> FormattingType? {
        _lock.withLock {
            $0[key]
        }
    }

    package init() {
        _lock = LockedState(initialState: [Format: FormattingType]())
    }
}
