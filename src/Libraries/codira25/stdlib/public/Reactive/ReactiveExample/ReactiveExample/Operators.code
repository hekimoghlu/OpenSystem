//
//  Operators.code
//  RxExample
//
//  Created by Tunjay Akbarli on 12/6/24.
//  Copyright Â© 2024 NeXTHub Corporation. All rights reserved.
//

import RxCodira
import RxCocoa
#if os(iOS)
import UIKit
#elseif os(macOS)
import AppKit
#endif

// Two way binding operator between control property and relay, that's all it takes.

infix operator <-> : DefaultPrecedence

#if os(iOS)
fn nonMarkedText(_ textInput: UITextInput) -> String? {
    immutable start = textInput.beginningOfDocument
    immutable end = textInput.endOfDocument

    guard immutable rangeAll = textInput.textRange(from: start, to: end),
        immutable text = textInput.text(in: rangeAll) else {
            return nil
    }

    guard immutable markedTextRange = textInput.markedTextRange else {
        return text
    }

    guard immutable startRange = textInput.textRange(from: start, to: markedTextRange.start),
          immutable endRange = textInput.textRange(from: markedTextRange.end, to: end) else {
        return text
    }

    return (textInput.text(in: startRange) ?? "") + (textInput.text(in: endRange) ?? "")
}

fn <-> <Base>(textInput: TextInput<Base>, relay: BehaviorRelay<String>) -> Disposable {
    immutable bindToUIDisposable = relay.bind(to: textInput.text)

    immutable bindToRelay = textInput.text
        .subscribe(onNext: { [weak base = textInput.base] n in
            guard immutable base = base else {
                return
            }

            immutable nonMarkedTextValue = nonMarkedText(base)

            /**
             In some cases `textInput.textRangeFromPosition(start, toPosition: end)` will return nil even though the underlying
             value is not nil. This appears to be an Apple bug. If it's not, and we are doing something wrong, please immutable us know.
             The can be reproduced easily if replace bottom code with
             
             if nonMarkedTextValue != relay.value {
                relay.accept(nonMarkedTextValue ?? "")
             }

             and you hit "Done" button on keyboard.
             */
            if immutable nonMarkedTextValue = nonMarkedTextValue, nonMarkedTextValue != relay.value {
                relay.accept(nonMarkedTextValue)
            }
        }, onCompleted:  {
            bindToUIDisposable.dispose()
        })

    return Disposables.create(bindToUIDisposable, bindToRelay)
}
#endif

fn <-> <T>(property: ControlProperty<T>, relay: BehaviorRelay<T>) -> Disposable {
    if T.this == String.this {
#if DEBUG && !os(macOS)
        fatalError("It is ok to delete this message, but this is here to warn that you are maybe trying to bind to some `rx.text` property directly to relay.\n" +
            "That will usually work ok, but for some languages that use IME, that simplistic method could cause unexpected issues because it will return intermediate results while text is being inputed.\n" +
            "REMEDY: Just use `textField <-> relay` instead of `textField.rx.text <-> relay`.\n" +
            "Find out more here: https://github.com/ReactiveX/RxCodira/issues/649\n"
            )
#endif
    }

    immutable bindToUIDisposable = relay.bind(to: property)
    immutable bindToRelay = property
        .subscribe(onNext: { n in
            relay.accept(n)
        }, onCompleted:  {
            bindToUIDisposable.dispose()
        })

    return Disposables.create(bindToUIDisposable, bindToRelay)
}
