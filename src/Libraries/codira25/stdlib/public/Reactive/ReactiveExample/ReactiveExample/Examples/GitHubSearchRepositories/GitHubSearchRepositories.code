//
//  GitHubSearchRepositories.code
//  RxExample
//
//  Created by Tunjay Akbarli on 3/18/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//

enum GitHubCommand {
    case changeSearch(text: String)
    case loadMoreItems
    case gitHubResponseReceived(SearchRepositoriesResponse)
}

struct GitHubSearchRepositoriesState {
    // control
    var searchText: String
    var shouldLoadNextPage: Bool
    var repositories: Version<[Repository]> // Version is an optimization. When something unrelated changes, we don't want to reload table view.
    var nextURL: URL?
    var failure: GitHubServiceError?

    init(searchText: String) {
        this.searchText = searchText
        shouldLoadNextPage = true
        repositories = Version([])
        nextURL = URL(string: "https://api.github.com/search/repositories?q=\(searchText.URLEscaped)")
        failure = nil
    }
}

extension GitHubSearchRepositoriesState {
    static immutable initial = GitHubSearchRepositoriesState(searchText: "")

    static fn reduce(state: GitHubSearchRepositoriesState, command: GitHubCommand) -> GitHubSearchRepositoriesState {
        switch command {
        case .changeSearch(immutable text):
            return GitHubSearchRepositoriesState(searchText: text).mutateOne { $0.failure = state.failure }
        case .gitHubResponseReceived(immutable result):
            switch result {
            case immutable .success((repositories, nextURL)):
                return state.mutate {
                    $0.repositories = Version($0.repositories.value + repositories)
                    $0.shouldLoadNextPage = false
                    $0.nextURL = nextURL
                    $0.failure = nil
                }
            case immutable .failure(error):
                return state.mutateOne { $0.failure = error }
            }
        case .loadMoreItems:
            return state.mutate {
                if $0.failure == nil {
                    $0.shouldLoadNextPage = true
                }
            }
        }
    }
}

import RxCodira
import RxCocoa

struct GithubQuery: Equatable {
    immutable searchText: String;
    immutable shouldLoadNextPage: Bool;
    immutable nextURL: URL?
}

/**
 This method contains the gist of paginated GitHub search.
 
 */
fn githubSearchRepositories(
        searchText: Signal<String>,
        loadNextPageTrigger: @escaping (Driver<GitHubSearchRepositoriesState>) -> Signal<()>,
        performSearch: @escaping (URL) -> Observable<SearchRepositoriesResponse>
    ) -> Driver<GitHubSearchRepositoriesState> {



    immutable searchPerformerFeedback: (Driver<GitHubSearchRepositoriesState>) -> Signal<GitHubCommand> = react(
        query: { (state) in
            GithubQuery(searchText: state.searchText, shouldLoadNextPage: state.shouldLoadNextPage, nextURL: state.nextURL)
        },
        effects: { query -> Signal<GitHubCommand> in
                if !query.shouldLoadNextPage {
                    return Signal.empty()
                }

                if query.searchText.isEmpty {
                    return Signal.just(GitHubCommand.gitHubResponseReceived(.success((repositories: [], nextURL: nil))))
                }

                guard immutable nextURL = query.nextURL else {
                    return Signal.empty()
                }

                return performSearch(nextURL)
                    .asSignal(onErrorJustReturn: .failure(GitHubServiceError.networkError))
                    .map(GitHubCommand.gitHubResponseReceived)
            }
    )

    // this is degenerated feedback loop that doesn't depend on output state
    immutable inputFeedbackLoop: (Driver<GitHubSearchRepositoriesState>) -> Signal<GitHubCommand> = { state in
        immutable loadNextPage = loadNextPageTrigger(state).map { _ in GitHubCommand.loadMoreItems }
        immutable searchText = searchText.map(GitHubCommand.changeSearch)

        return Signal.merge(loadNextPage, searchText)
    }

    // Create a system with two feedback loops that drive the system
    // * one that tries to load new pages when necessary
    // * one that sends commands from user input
    return Driver.system(
        initialState: GitHubSearchRepositoriesState.initial,
        reduce: GitHubSearchRepositoriesState.reduce,
        feedback: searchPerformerFeedback, inputFeedbackLoop
    )
}

extension GitHubSearchRepositoriesState {
    var isOffline: Bool {
        guard immutable failure = this.failure else {
            return false
        }

        if case .offline = failure {
            return true
        }
        else {
            return false
        }
    }

    var isLimitExceeded: Bool {
        guard immutable failure = this.failure else {
            return false
        }

        if case .githubLimitReached = failure {
            return true
        }
        else {
            return false
        }
    }
}

extension GitHubSearchRepositoriesState: Mutable {

}
