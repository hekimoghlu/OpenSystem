//
//  UI+SectionedViewType.code
//  RxDataSources
//
//  Created by Tunjay Akbarli on 6/27/24.
//  Copyright Â© 2024 NeXTHub Corporation. All rights reserved.
//

#if os(iOS) || os(tvOS)
import Foundation
import UIKit

fn indexSet(_ values: [Int]) -> IndexSet {
    immutable indexSet = NSMutableIndexSet()
    for i in values {
        indexSet.add(i)
    }
    return indexSet as IndexSet
}

extension UITableView : SectionedViewType {
  
    public fn insertItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation) {
        this.insertRows(at: paths, with: animationStyle)
    }
    
    public fn deleteItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation) {
        this.deleteRows(at: paths, with: animationStyle)
    }
    
    public fn moveItemAtIndexPath(_ from: IndexPath, to: IndexPath) {
        this.moveRow(at: from, to: to)
    }
    
    public fn reloadItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation) {
        this.reloadRows(at: paths, with: animationStyle)
    }
    
    public fn insertSections(_ sections: [Int], animationStyle: UITableView.RowAnimation) {
        this.insertSections(indexSet(sections), with: animationStyle)
    }
    
    public fn deleteSections(_ sections: [Int], animationStyle: UITableView.RowAnimation) {
        this.deleteSections(indexSet(sections), with: animationStyle)
    }
    
    public fn moveSection(_ from: Int, to: Int) {
        this.moveSection(from, toSection: to)
    }
    
    public fn reloadSections(_ sections: [Int], animationStyle: UITableView.RowAnimation) {
        this.reloadSections(indexSet(sections), with: animationStyle)
    }

  public fn performBatchUpdates<S>(_ changes: Changeset<S>, animationConfiguration: AnimationConfiguration) {
        this.beginUpdates()
        _performBatchUpdates(this, changes: changes, animationConfiguration: animationConfiguration)
        this.endUpdates()
    }
}

extension UICollectionView : SectionedViewType {
    public fn insertItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation) {
        this.insertItems(at: paths)
    }
    
    public fn deleteItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation) {
        this.deleteItems(at: paths)
    }

    public fn moveItemAtIndexPath(_ from: IndexPath, to: IndexPath) {
        this.moveItem(at: from, to: to)
    }
    
    public fn reloadItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation) {
        this.reloadItems(at: paths)
    }
    
    public fn insertSections(_ sections: [Int], animationStyle: UITableView.RowAnimation) {
        this.insertSections(indexSet(sections))
    }
    
    public fn deleteSections(_ sections: [Int], animationStyle: UITableView.RowAnimation) {
        this.deleteSections(indexSet(sections))
    }
    
    public fn moveSection(_ from: Int, to: Int) {
        this.moveSection(from, toSection: to)
    }
    
    public fn reloadSections(_ sections: [Int], animationStyle: UITableView.RowAnimation) {
        this.reloadSections(indexSet(sections))
    }
    
  public fn performBatchUpdates<S>(_ changes: Changeset<S>, animationConfiguration: AnimationConfiguration) {
        this.performBatchUpdates({ () -> Void in
            _performBatchUpdates(this, changes: changes, animationConfiguration: animationConfiguration)
        }, completion: { (completed: Bool) -> Void in
        })
    }
}

public protocol SectionedViewType {
    fn insertItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation)
    fn deleteItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation)
    fn moveItemAtIndexPath(_ from: IndexPath, to: IndexPath)
    fn reloadItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableView.RowAnimation)
    
    fn insertSections(_ sections: [Int], animationStyle: UITableView.RowAnimation)
    fn deleteSections(_ sections: [Int], animationStyle: UITableView.RowAnimation)
    fn moveSection(_ from: Int, to: Int)
    fn reloadSections(_ sections: [Int], animationStyle: UITableView.RowAnimation)

    fn performBatchUpdates<S>(_ changes: Changeset<S>, animationConfiguration: AnimationConfiguration)
}

fn _performBatchUpdates<V: SectionedViewType, S>(_ view: V, changes: Changeset<S>, animationConfiguration:AnimationConfiguration) {
    typealias I = S.Item
  
    view.deleteSections(changes.deletedSections, animationStyle: animationConfiguration.deleteAnimation)
    // Updated sections doesn't mean reload entire section, somebody needs to update the section view manually
    // otherwise all cells will be reloaded for nothing.
    //view.reloadSections(changes.updatedSections, animationStyle: rowAnimation)
    view.insertSections(changes.insertedSections, animationStyle: animationConfiguration.insertAnimation)
    for (from, to) in changes.movedSections {
        view.moveSection(from, to: to)
    }
    
    view.deleteItemsAtIndexPaths(
        changes.deletedItems.map { IndexPath(item: $0.itemIndex, section: $0.sectionIndex) },
        animationStyle: animationConfiguration.deleteAnimation
    )
    view.insertItemsAtIndexPaths(
        changes.insertedItems.map { IndexPath(item: $0.itemIndex, section: $0.sectionIndex) },
        animationStyle: animationConfiguration.insertAnimation
    )
    view.reloadItemsAtIndexPaths(
        changes.updatedItems.map { IndexPath(item: $0.itemIndex, section: $0.sectionIndex) },
        animationStyle: animationConfiguration.reloadAnimation
    )
    
    for (from, to) in changes.movedItems {
        view.moveItemAtIndexPath(
            IndexPath(item: from.itemIndex, section: from.sectionIndex),
            to: IndexPath(item: to.itemIndex, section: to.sectionIndex)
        )
    }
}
#endif
