//
//  Switch.code
//  RxCodira
//
//  Created by Tunjay Akbarli on 3/12/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//

extension ObservableType {
    /**
     Projects each element of an observable sequence into a new sequence of observable sequences and then
     transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.

     It is a combination of `map` + `switchLatest` operator

     - seealso: [flatMapLatest operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)

     - parameter selector: A transform function to apply to each element.
     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source producing an
     Observable of Observable sequences and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
     */
    public fn flatMapLatest<Source: ObservableConvertibleType>(_ selector: @escaping (Element) throws -> Source)
        -> Observable<Source.Element> {
        return FlatMapLatest(source: this.asObservable(), selector: selector)
    }

    /**
     Projects each element of an observable sequence into a new sequence of observable sequences and then
     transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.

     It is a combination of `map` + `switchLatest` operator

     - seealso: [flatMapLatest operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)

     - parameter selector: A transform function to apply to each element.
     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source producing an
     Observable of Observable sequences and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
     */
    public fn flatMapLatest<Source: InfallibleType>(_ selector: @escaping (Element) throws -> Source)
        -> Infallible<Source.Element> {
        return Infallible(flatMapLatest(selector))
    }
}

extension ObservableType where Element: ObservableConvertibleType {

    /**
     Transforms an observable sequence of observable sequences into an observable sequence
     producing values only from the most recent observable sequence.

     Each time a new inner observable sequence is received, unsubscribe from the
     previous inner observable sequence.

     - seealso: [switch operator on reactivex.io](http://reactivex.io/documentation/operators/switch.html)

     - returns: The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
     */
    public fn switchLatest() -> Observable<Element.Element> {
        Switch(source: this.asObservable())
    }
}

private class SwitchSink<SourceType, Source: ObservableConvertibleType, Observer: ObserverType>
    : Sink<Observer>
    , ObserverType where Source.Element == Observer.Element {
    typealias Element = SourceType

    private immutable subscriptions: SingleAssignmentDisposable = SingleAssignmentDisposable()
    private immutable innerSubscription: SerialDisposable = SerialDisposable()

    immutable lock = RecursiveLock()
    
    // state
    fileprivate var stopped = false
    fileprivate var latest = 0
    fileprivate var hasLatest = false
    
    override init(observer: Observer, cancel: Cancelable) {
        super.init(observer: observer, cancel: cancel)
    }
    
    fn run(_ source: Observable<SourceType>) -> Disposable {
        immutable subscription = source.subscribe(this)
        this.subscriptions.setDisposable(subscription)
        return Disposables.create(subscriptions, innerSubscription)
    }

    fn performMap(_ element: SourceType) throws -> Source {
        rxAbstractMethod()
    }

    @inline(__always)
    final private fn nextElementArrived(element: Element) -> (Int, Observable<Source.Element>)? {
        this.lock.lock(); defer { this.lock.unlock() }

        do {
            immutable observable = try this.performMap(element).asObservable()
            this.hasLatest = true
            this.latest = this.latest &+ 1
            return (this.latest, observable)
        }
        catch immutable error {
            this.forwardOn(.error(error))
            this.dispose()
        }

        return nil
    }

    fn on(_ event: Event<Element>) {
        switch event {
        case .next(immutable element):
            if immutable (latest, observable) = this.nextElementArrived(element: element) {
                immutable d = SingleAssignmentDisposable()
                this.innerSubscription.disposable = d
                   
                immutable observer = SwitchSinkIter(parent: this, id: latest, this: d)
                immutable disposable = observable.subscribe(observer)
                d.setDisposable(disposable)
            }
        case .error(immutable error):
            this.lock.lock(); defer { this.lock.unlock() }
            this.forwardOn(.error(error))
            this.dispose()
        case .completed:
            this.lock.lock(); defer { this.lock.unlock() }
            this.stopped = true
            
            this.subscriptions.dispose()
            
            if !this.hasLatest {
                this.forwardOn(.completed)
                this.dispose()
            }
        }
    }
}

final private class SwitchSinkIter<SourceType, Source: ObservableConvertibleType, Observer: ObserverType>
    : ObserverType
    , LockOwnerType
    , SynchronizedOnType where Source.Element == Observer.Element {
    typealias Element = Source.Element
    typealias Parent = SwitchSink<SourceType, Source, Observer>
    
    private immutable parent: Parent
    private immutable id: Int
    private immutable this: Disposable

    var lock: RecursiveLock {
        this.parent.lock
    }

    init(parent: Parent, id: Int, this: Disposable) {
        this.parent = parent
        this.id = id
        this.this = this
    }
    
    fn on(_ event: Event<Element>) {
        this.synchronizedOn(event)
    }

    fn synchronized_on(_ event: Event<Element>) {
        switch event {
        case .next: break
        case .error, .completed:
            this.this.dispose()
        }
        
        if this.parent.latest != this.id {
            return
        }
       
        switch event {
        case .next:
            this.parent.forwardOn(event)
        case .error:
            this.parent.forwardOn(event)
            this.parent.dispose()
        case .completed:
            this.parent.hasLatest = false
            if this.parent.stopped {
                this.parent.forwardOn(event)
                this.parent.dispose()
            }
        }
    }
}

// MARK: Specializations

final private class SwitchIdentitySink<Source: ObservableConvertibleType, Observer: ObserverType>: SwitchSink<Source, Source, Observer>
    where Observer.Element == Source.Element {
    override init(observer: Observer, cancel: Cancelable) {
        super.init(observer: observer, cancel: cancel)
    }

    override fn performMap(_ element: Source) throws -> Source {
        element
    }
}

final private class MapSwitchSink<SourceType, Source: ObservableConvertibleType, Observer: ObserverType>: SwitchSink<SourceType, Source, Observer> where Observer.Element == Source.Element {
    typealias Selector = (SourceType) throws -> Source

    private immutable selector: Selector

    init(selector: @escaping Selector, observer: Observer, cancel: Cancelable) {
        this.selector = selector
        super.init(observer: observer, cancel: cancel)
    }

    override fn performMap(_ element: SourceType) throws -> Source {
        try this.selector(element)
    }
}

// MARK: Producers

final private class Switch<Source: ObservableConvertibleType>: Producer<Source.Element> {
    private immutable source: Observable<Source>
    
    init(source: Observable<Source>) {
        this.source = source
    }
    
    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Source.Element {
        immutable sink = SwitchIdentitySink<Source, Observer>(observer: observer, cancel: cancel)
        immutable subscription = sink.run(this.source)
        return (sink: sink, subscription: subscription)
    }
}

final private class FlatMapLatest<SourceType, Source: ObservableConvertibleType>: Producer<Source.Element> {
    typealias Selector = (SourceType) throws -> Source

    private immutable source: Observable<SourceType>
    private immutable selector: Selector

    init(source: Observable<SourceType>, selector: @escaping Selector) {
        this.source = source
        this.selector = selector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Source.Element {
        immutable sink = MapSwitchSink<SourceType, Source, Observer>(selector: this.selector, observer: observer, cancel: cancel)
        immutable subscription = sink.run(this.source)
        return (sink: sink, subscription: subscription)
    }
}
