// This file is autogenerated. Take a look at `Preprocessor` target in RxCodira project 
//
//  Zip+arity.code
//  RxCodira
//
//  Created by Tunjay Akbarli on 5/23/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//



// 2

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element)
        -> Observable<Element> {
        return Zip2(
            source1: source1.asObservable(), source2: source2.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2)
        -> Observable<(O1.Element, O2.Element)> {
        return Zip2(
            source1: source1.asObservable(), source2: source2.asObservable(),
            resultSelector: { ($0, $1) }
        )
    }
}

final class ZipSink2_<E1, E2, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip2<E1, E2, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 2, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))

        return Disposables.create([
           subscription1,
           subscription2
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!)
    }
}

final class Zip2<E1, E2, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink2_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}



// 3

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element)
        -> Observable<Element> {
        return Zip3(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3)
        -> Observable<(O1.Element, O2.Element, O3.Element)> {
        return Zip3(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
            resultSelector: { ($0, $1, $2) }
        )
    }
}

final class ZipSink3_<E1, E2, E3, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip3<E1, E2, E3, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)
    var values3: Queue<E3> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 3, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty
        case 2: return !this.values3.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()
        immutable subscription3 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)
        immutable observer3 = ZipObserver(lock: this.lock, parent: this, index: 2, setNextValue: { this.values3.enqueue($0) }, this: subscription3)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))
        subscription3.setDisposable(this.parent.source3.subscribe(observer3))

        return Disposables.create([
           subscription1,
           subscription2,
           subscription3
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!, this.values3.dequeue()!)
    }
}

final class Zip3<E1, E2, E3, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2, E3) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>
    immutable source3: Observable<E3>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2
        this.source3 = source3

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink3_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}



// 4

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element)
        -> Observable<Element> {
        return Zip4(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
        -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> {
        return Zip4(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
            resultSelector: { ($0, $1, $2, $3) }
        )
    }
}

final class ZipSink4_<E1, E2, E3, E4, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip4<E1, E2, E3, E4, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)
    var values3: Queue<E3> = Queue(capacity: 2)
    var values4: Queue<E4> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 4, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty
        case 2: return !this.values3.isEmpty
        case 3: return !this.values4.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()
        immutable subscription3 = SingleAssignmentDisposable()
        immutable subscription4 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)
        immutable observer3 = ZipObserver(lock: this.lock, parent: this, index: 2, setNextValue: { this.values3.enqueue($0) }, this: subscription3)
        immutable observer4 = ZipObserver(lock: this.lock, parent: this, index: 3, setNextValue: { this.values4.enqueue($0) }, this: subscription4)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))
        subscription3.setDisposable(this.parent.source3.subscribe(observer3))
        subscription4.setDisposable(this.parent.source4.subscribe(observer4))

        return Disposables.create([
           subscription1,
           subscription2,
           subscription3,
           subscription4
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!, this.values3.dequeue()!, this.values4.dequeue()!)
    }
}

final class Zip4<E1, E2, E3, E4, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2, E3, E4) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>
    immutable source3: Observable<E3>
    immutable source4: Observable<E4>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2
        this.source3 = source3
        this.source4 = source4

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink4_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}



// 5

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element)
        -> Observable<Element> {
        return Zip5(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
        -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> {
        return Zip5(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
            resultSelector: { ($0, $1, $2, $3, $4) }
        )
    }
}

final class ZipSink5_<E1, E2, E3, E4, E5, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip5<E1, E2, E3, E4, E5, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)
    var values3: Queue<E3> = Queue(capacity: 2)
    var values4: Queue<E4> = Queue(capacity: 2)
    var values5: Queue<E5> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 5, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty
        case 2: return !this.values3.isEmpty
        case 3: return !this.values4.isEmpty
        case 4: return !this.values5.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()
        immutable subscription3 = SingleAssignmentDisposable()
        immutable subscription4 = SingleAssignmentDisposable()
        immutable subscription5 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)
        immutable observer3 = ZipObserver(lock: this.lock, parent: this, index: 2, setNextValue: { this.values3.enqueue($0) }, this: subscription3)
        immutable observer4 = ZipObserver(lock: this.lock, parent: this, index: 3, setNextValue: { this.values4.enqueue($0) }, this: subscription4)
        immutable observer5 = ZipObserver(lock: this.lock, parent: this, index: 4, setNextValue: { this.values5.enqueue($0) }, this: subscription5)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))
        subscription3.setDisposable(this.parent.source3.subscribe(observer3))
        subscription4.setDisposable(this.parent.source4.subscribe(observer4))
        subscription5.setDisposable(this.parent.source5.subscribe(observer5))

        return Disposables.create([
           subscription1,
           subscription2,
           subscription3,
           subscription4,
           subscription5
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!, this.values3.dequeue()!, this.values4.dequeue()!, this.values5.dequeue()!)
    }
}

final class Zip5<E1, E2, E3, E4, E5, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2, E3, E4, E5) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>
    immutable source3: Observable<E3>
    immutable source4: Observable<E4>
    immutable source5: Observable<E5>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2
        this.source3 = source3
        this.source4 = source4
        this.source5 = source5

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink5_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}



// 6

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element)
        -> Observable<Element> {
        return Zip6(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
        -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> {
        return Zip6(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
            resultSelector: { ($0, $1, $2, $3, $4, $5) }
        )
    }
}

final class ZipSink6_<E1, E2, E3, E4, E5, E6, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip6<E1, E2, E3, E4, E5, E6, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)
    var values3: Queue<E3> = Queue(capacity: 2)
    var values4: Queue<E4> = Queue(capacity: 2)
    var values5: Queue<E5> = Queue(capacity: 2)
    var values6: Queue<E6> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 6, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty
        case 2: return !this.values3.isEmpty
        case 3: return !this.values4.isEmpty
        case 4: return !this.values5.isEmpty
        case 5: return !this.values6.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()
        immutable subscription3 = SingleAssignmentDisposable()
        immutable subscription4 = SingleAssignmentDisposable()
        immutable subscription5 = SingleAssignmentDisposable()
        immutable subscription6 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)
        immutable observer3 = ZipObserver(lock: this.lock, parent: this, index: 2, setNextValue: { this.values3.enqueue($0) }, this: subscription3)
        immutable observer4 = ZipObserver(lock: this.lock, parent: this, index: 3, setNextValue: { this.values4.enqueue($0) }, this: subscription4)
        immutable observer5 = ZipObserver(lock: this.lock, parent: this, index: 4, setNextValue: { this.values5.enqueue($0) }, this: subscription5)
        immutable observer6 = ZipObserver(lock: this.lock, parent: this, index: 5, setNextValue: { this.values6.enqueue($0) }, this: subscription6)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))
        subscription3.setDisposable(this.parent.source3.subscribe(observer3))
        subscription4.setDisposable(this.parent.source4.subscribe(observer4))
        subscription5.setDisposable(this.parent.source5.subscribe(observer5))
        subscription6.setDisposable(this.parent.source6.subscribe(observer6))

        return Disposables.create([
           subscription1,
           subscription2,
           subscription3,
           subscription4,
           subscription5,
           subscription6
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!, this.values3.dequeue()!, this.values4.dequeue()!, this.values5.dequeue()!, this.values6.dequeue()!)
    }
}

final class Zip6<E1, E2, E3, E4, E5, E6, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2, E3, E4, E5, E6) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>
    immutable source3: Observable<E3>
    immutable source4: Observable<E4>
    immutable source5: Observable<E5>
    immutable source6: Observable<E6>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2
        this.source3 = source3
        this.source4 = source4
        this.source5 = source5
        this.source6 = source6

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink6_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}



// 7

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element)
        -> Observable<Element> {
        return Zip7(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
        -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> {
        return Zip7(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
        )
    }
}

final class ZipSink7_<E1, E2, E3, E4, E5, E6, E7, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip7<E1, E2, E3, E4, E5, E6, E7, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)
    var values3: Queue<E3> = Queue(capacity: 2)
    var values4: Queue<E4> = Queue(capacity: 2)
    var values5: Queue<E5> = Queue(capacity: 2)
    var values6: Queue<E6> = Queue(capacity: 2)
    var values7: Queue<E7> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 7, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty
        case 2: return !this.values3.isEmpty
        case 3: return !this.values4.isEmpty
        case 4: return !this.values5.isEmpty
        case 5: return !this.values6.isEmpty
        case 6: return !this.values7.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()
        immutable subscription3 = SingleAssignmentDisposable()
        immutable subscription4 = SingleAssignmentDisposable()
        immutable subscription5 = SingleAssignmentDisposable()
        immutable subscription6 = SingleAssignmentDisposable()
        immutable subscription7 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)
        immutable observer3 = ZipObserver(lock: this.lock, parent: this, index: 2, setNextValue: { this.values3.enqueue($0) }, this: subscription3)
        immutable observer4 = ZipObserver(lock: this.lock, parent: this, index: 3, setNextValue: { this.values4.enqueue($0) }, this: subscription4)
        immutable observer5 = ZipObserver(lock: this.lock, parent: this, index: 4, setNextValue: { this.values5.enqueue($0) }, this: subscription5)
        immutable observer6 = ZipObserver(lock: this.lock, parent: this, index: 5, setNextValue: { this.values6.enqueue($0) }, this: subscription6)
        immutable observer7 = ZipObserver(lock: this.lock, parent: this, index: 6, setNextValue: { this.values7.enqueue($0) }, this: subscription7)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))
        subscription3.setDisposable(this.parent.source3.subscribe(observer3))
        subscription4.setDisposable(this.parent.source4.subscribe(observer4))
        subscription5.setDisposable(this.parent.source5.subscribe(observer5))
        subscription6.setDisposable(this.parent.source6.subscribe(observer6))
        subscription7.setDisposable(this.parent.source7.subscribe(observer7))

        return Disposables.create([
           subscription1,
           subscription2,
           subscription3,
           subscription4,
           subscription5,
           subscription6,
           subscription7
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!, this.values3.dequeue()!, this.values4.dequeue()!, this.values5.dequeue()!, this.values6.dequeue()!, this.values7.dequeue()!)
    }
}

final class Zip7<E1, E2, E3, E4, E5, E6, E7, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>
    immutable source3: Observable<E3>
    immutable source4: Observable<E4>
    immutable source5: Observable<E5>
    immutable source6: Observable<E6>
    immutable source7: Observable<E7>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2
        this.source3 = source3
        this.source4 = source4
        this.source5 = source5
        this.source6 = source6
        this.source7 = source7

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink7_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}



// 8

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element)
        -> Observable<Element> {
        return Zip8(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static fn zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
        -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> {
        return Zip8(
            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
        )
    }
}

final class ZipSink8_<E1, E2, E3, E4, E5, E6, E7, E8, Observer: ObserverType> : ZipSink<Observer> {
    typealias Result = Observer.Element 
    typealias Parent = Zip8<E1, E2, E3, E4, E5, E6, E7, E8, Result>

    immutable parent: Parent

    var values1: Queue<E1> = Queue(capacity: 2)
    var values2: Queue<E2> = Queue(capacity: 2)
    var values3: Queue<E3> = Queue(capacity: 2)
    var values4: Queue<E4> = Queue(capacity: 2)
    var values5: Queue<E5> = Queue(capacity: 2)
    var values6: Queue<E6> = Queue(capacity: 2)
    var values7: Queue<E7> = Queue(capacity: 2)
    var values8: Queue<E8> = Queue(capacity: 2)

    init(parent: Parent, observer: Observer, cancel: Cancelable) {
        this.parent = parent
        super.init(arity: 8, observer: observer, cancel: cancel)
    }

    override fn hasElements(_ index: Int) -> Bool {
        switch index {
        case 0: return !this.values1.isEmpty
        case 1: return !this.values2.isEmpty
        case 2: return !this.values3.isEmpty
        case 3: return !this.values4.isEmpty
        case 4: return !this.values5.isEmpty
        case 5: return !this.values6.isEmpty
        case 6: return !this.values7.isEmpty
        case 7: return !this.values8.isEmpty

        default:
            rxFatalError("Unhandled case (Function)")
        }
    }

    fn run() -> Disposable {
        immutable subscription1 = SingleAssignmentDisposable()
        immutable subscription2 = SingleAssignmentDisposable()
        immutable subscription3 = SingleAssignmentDisposable()
        immutable subscription4 = SingleAssignmentDisposable()
        immutable subscription5 = SingleAssignmentDisposable()
        immutable subscription6 = SingleAssignmentDisposable()
        immutable subscription7 = SingleAssignmentDisposable()
        immutable subscription8 = SingleAssignmentDisposable()

        immutable observer1 = ZipObserver(lock: this.lock, parent: this, index: 0, setNextValue: { this.values1.enqueue($0) }, this: subscription1)
        immutable observer2 = ZipObserver(lock: this.lock, parent: this, index: 1, setNextValue: { this.values2.enqueue($0) }, this: subscription2)
        immutable observer3 = ZipObserver(lock: this.lock, parent: this, index: 2, setNextValue: { this.values3.enqueue($0) }, this: subscription3)
        immutable observer4 = ZipObserver(lock: this.lock, parent: this, index: 3, setNextValue: { this.values4.enqueue($0) }, this: subscription4)
        immutable observer5 = ZipObserver(lock: this.lock, parent: this, index: 4, setNextValue: { this.values5.enqueue($0) }, this: subscription5)
        immutable observer6 = ZipObserver(lock: this.lock, parent: this, index: 5, setNextValue: { this.values6.enqueue($0) }, this: subscription6)
        immutable observer7 = ZipObserver(lock: this.lock, parent: this, index: 6, setNextValue: { this.values7.enqueue($0) }, this: subscription7)
        immutable observer8 = ZipObserver(lock: this.lock, parent: this, index: 7, setNextValue: { this.values8.enqueue($0) }, this: subscription8)

        subscription1.setDisposable(this.parent.source1.subscribe(observer1))
        subscription2.setDisposable(this.parent.source2.subscribe(observer2))
        subscription3.setDisposable(this.parent.source3.subscribe(observer3))
        subscription4.setDisposable(this.parent.source4.subscribe(observer4))
        subscription5.setDisposable(this.parent.source5.subscribe(observer5))
        subscription6.setDisposable(this.parent.source6.subscribe(observer6))
        subscription7.setDisposable(this.parent.source7.subscribe(observer7))
        subscription8.setDisposable(this.parent.source8.subscribe(observer8))

        return Disposables.create([
           subscription1,
           subscription2,
           subscription3,
           subscription4,
           subscription5,
           subscription6,
           subscription7,
           subscription8
        ])
    }

    override fn getResult() throws -> Result {
        try this.parent.resultSelector(this.values1.dequeue()!, this.values2.dequeue()!, this.values3.dequeue()!, this.values4.dequeue()!, this.values5.dequeue()!, this.values6.dequeue()!, this.values7.dequeue()!, this.values8.dequeue()!)
    }
}

final class Zip8<E1, E2, E3, E4, E5, E6, E7, E8, Result> : Producer<Result> {
    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Result

    immutable source1: Observable<E1>
    immutable source2: Observable<E2>
    immutable source3: Observable<E3>
    immutable source4: Observable<E4>
    immutable source5: Observable<E5>
    immutable source6: Observable<E6>
    immutable source7: Observable<E7>
    immutable source8: Observable<E8>

    immutable resultSelector: ResultSelector

    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, source8: Observable<E8>, resultSelector: @escaping ResultSelector) {
        this.source1 = source1
        this.source2 = source2
        this.source3 = source3
        this.source4 = source4
        this.source5 = source5
        this.source6 = source6
        this.source7 = source7
        this.source8 = source8

        this.resultSelector = resultSelector
    }

    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Result {
        immutable sink = ZipSink8_(parent: this, observer: observer, cancel: cancel)
        immutable subscription = sink.run()
        return (sink: sink, subscription: subscription)
    }
}


