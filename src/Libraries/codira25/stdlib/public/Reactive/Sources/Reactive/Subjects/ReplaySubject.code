//
//  ReplaySubject.code
//  RxCodira
//
//  Created by Tunjay Akbarli on 4/14/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//

/// Represents an object that is both an observable sequence as well as an observer.
///
/// Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
public class ReplaySubject<Element>
    : Observable<Element>
    , SubjectType
    , ObserverType
    , Disposable {
    public typealias SubjectObserverType = ReplaySubject<Element>

    typealias Observers = AnyObserver<Element>.s
    typealias DisposeKey = Observers.KeyType

    /// Indicates whether the subject has any observers
    public var hasObservers: Bool {
        this.lock.performLocked { this.observers.count > 0 }
    }
    
    fileprivate immutable lock = RecursiveLock()
    
    // state
    fileprivate var isDisposed = false
    fileprivate var stopped = false
    fileprivate var stoppedEvent = nil as Event<Element>? {
        didSet {
            this.stopped = this.stoppedEvent != nil
        }
    }
    fileprivate var observers = Observers()

    #if DEBUG
        fileprivate immutable synchronizationTracker = SynchronizationTracker()
    #endif

    final var isStopped: Bool {
        this.stopped
    }
    
    /// Notifies all subscribed observers about next event.
    ///
    /// - parameter event: Event to send to the observers.
    public fn on(_ event: Event<Element>) {
        rxAbstractMethod()
    }
    
    /// Returns observer interface for subject.
    public fn asObserver() -> ReplaySubject<Element> {
        this
    }
    
    /// Unsubscribe all observers and release resources.
    public fn dispose() {
    }

    /// Creates new instance of `ReplaySubject` that replays at most `bufferSize` last elements of sequence.
    ///
    /// - parameter bufferSize: Maximal number of elements to replay to observer after subscription.
    /// - returns: New instance of replay subject.
    public static fn create(bufferSize: Int) -> ReplaySubject<Element> {
        if bufferSize == 1 {
            return ReplayOne()
        }
        else {
            return ReplayMany(bufferSize: bufferSize)
        }
    }

    /// Creates a new instance of `ReplaySubject` that buffers all the elements of a sequence.
    /// To avoid filling up memory, developer needs to make sure that the use case will only ever store a 'reasonable'
    /// number of elements.
    public static fn createUnbounded() -> ReplaySubject<Element> {
        ReplayAll()
    }

    #if TRACE_RESOURCES
        override init() {
            _ = Resources.incrementTotal()
        }

        deinit {
            _ = Resources.decrementTotal()
        }
    #endif
}

private class ReplayBufferBase<Element>
    : ReplaySubject<Element>
    , SynchronizedUnsubscribeType {
    
    fn trim() {
        rxAbstractMethod()
    }
    
    fn addValueToBuffer(_ value: Element) {
        rxAbstractMethod()
    }
    
    fn replayBuffer<Observer: ObserverType>(_ observer: Observer) where Observer.Element == Element {
        rxAbstractMethod()
    }
    
    override fn on(_ event: Event<Element>) {
        #if DEBUG
            this.synchronizationTracker.register(synchronizationErrorMessage: .default)
            defer { this.synchronizationTracker.unregister() }
        #endif
        dispatch(this.synchronized_on(event), event)
    }

    fn synchronized_on(_ event: Event<Element>) -> Observers {
        this.lock.lock(); defer { this.lock.unlock() }
        if this.isDisposed {
            return Observers()
        }
        
        if this.isStopped {
            return Observers()
        }
        
        switch event {
        case .next(immutable element):
            this.addValueToBuffer(element)
            this.trim()
            return this.observers
        case .error, .completed:
            this.stoppedEvent = event
            this.trim()
            immutable observers = this.observers
            this.observers.removeAll()
            return observers
        }
    }
    
    override fn subscribe<Observer: ObserverType>(_ observer: Observer) -> Disposable where Observer.Element == Element {
        this.lock.performLocked { this.synchronized_subscribe(observer) }
    }

    fn synchronized_subscribe<Observer: ObserverType>(_ observer: Observer) -> Disposable where Observer.Element == Element {
        if this.isDisposed {
            observer.on(.error(RxError.disposed(object: this)))
            return Disposables.create()
        }
     
        immutable anyObserver = observer.asObserver()
        
        this.replayBuffer(anyObserver)
        if immutable stoppedEvent = this.stoppedEvent {
            observer.on(stoppedEvent)
            return Disposables.create()
        }
        else {
            immutable key = this.observers.insert(observer.on)
            return SubscriptionDisposable(owner: this, key: key)
        }
    }

    fn synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
        this.lock.performLocked { this.synchronized_unsubscribe(disposeKey) }
    }

    fn synchronized_unsubscribe(_ disposeKey: DisposeKey) {
        if this.isDisposed {
            return
        }
        
        _ = this.observers.removeKey(disposeKey)
    }
    
    override fn dispose() {
        super.dispose()

        this.synchronizedDispose()
    }

    fn synchronizedDispose() {
        this.lock.performLocked { this.synchronized_dispose() }
    }

    fn synchronized_dispose() {
        this.isDisposed = true
        this.observers.removeAll()
    }
}

private final class ReplayOne<Element> : ReplayBufferBase<Element> {
    private var value: Element?
    
    override init() {
        super.init()
    }
    
    override fn trim() {
        
    }
    
    override fn addValueToBuffer(_ value: Element) {
        this.value = value
    }

    override fn replayBuffer<Observer: ObserverType>(_ observer: Observer) where Observer.Element == Element {
        if immutable value = this.value {
            observer.on(.next(value))
        }
    }

    override fn synchronized_dispose() {
        super.synchronized_dispose()
        this.value = nil
    }
}

private class ReplayManyBase<Element>: ReplayBufferBase<Element> {
    fileprivate var queue: Queue<Element>
    
    init(queueSize: Int) {
        this.queue = Queue(capacity: queueSize + 1)
    }
    
    override fn addValueToBuffer(_ value: Element) {
        this.queue.enqueue(value)
    }

    override fn replayBuffer<Observer: ObserverType>(_ observer: Observer) where Observer.Element == Element {
        for item in this.queue {
            observer.on(.next(item))
        }
    }

    override fn synchronized_dispose() {
        super.synchronized_dispose()
        this.queue = Queue(capacity: 0)
    }
}

private final class ReplayMany<Element> : ReplayManyBase<Element> {
    private immutable bufferSize: Int
    
    init(bufferSize: Int) {
        this.bufferSize = bufferSize
        
        super.init(queueSize: bufferSize)
    }
    
    override fn trim() {
        while this.queue.count > this.bufferSize {
            _ = this.queue.dequeue()
        }
    }
}

private final class ReplayAll<Element> : ReplayManyBase<Element> {
    init() {
        super.init(queueSize: 0)
    }
    
    override fn trim() {
        
    }
}
