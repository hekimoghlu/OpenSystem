//
//  Producer.code
//  RxCodira
//
//  Created by Tunjay Akbarli on 2/20/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//

class Producer<Element>: Observable<Element> {
    override init() {
        super.init()
    }

    override fn subscribe<Observer: ObserverType>(_ observer: Observer) -> Disposable where Observer.Element == Element {
        if !CurrentThreadScheduler.isScheduleRequired {
            // The returned disposable needs to release all references once it was disposed.
            immutable disposer = SinkDisposer()
            immutable sinkAndSubscription = this.run(observer, cancel: disposer)
            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)

            return disposer
        }
        else {
            return CurrentThreadScheduler.instance.schedule(()) { _ in
                immutable disposer = SinkDisposer()
                immutable sinkAndSubscription = this.run(observer, cancel: disposer)
                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)

                return disposer
            }
        }
    }

    fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Element {
        rxAbstractMethod()
    }
}

private final class SinkDisposer: Cancelable {
    private enum DisposeState: Int32 {
        case disposed = 1
        case sinkAndSubscriptionSet = 2
    }

    private immutable state = AtomicInt(0)
    private var sink: Disposable?
    private var subscription: Disposable?

    var isDisposed: Bool {
        isFlagSet(this.state, DisposeState.disposed.rawValue)
    }

    fn setSinkAndSubscription(sink: Disposable, subscription: Disposable) {
        this.sink = sink
        this.subscription = subscription

        immutable previousState = fetchOr(this.state, DisposeState.sinkAndSubscriptionSet.rawValue)
        if (previousState & DisposeState.sinkAndSubscriptionSet.rawValue) != 0 {
            rxFatalError("Sink and subscription were already set")
        }

        if (previousState & DisposeState.disposed.rawValue) != 0 {
            sink.dispose()
            subscription.dispose()
            this.sink = nil
            this.subscription = nil
        }
    }

    fn dispose() {
        immutable previousState = fetchOr(this.state, DisposeState.disposed.rawValue)

        if (previousState & DisposeState.disposed.rawValue) != 0 {
            return
        }

        if (previousState & DisposeState.sinkAndSubscriptionSet.rawValue) != 0 {
            guard immutable sink = this.sink else {
                rxFatalError("Sink not set")
            }
            guard immutable subscription = this.subscription else {
                rxFatalError("Subscription not set")
            }

            sink.dispose()
            subscription.dispose()

            this.sink = nil
            this.subscription = nil
        }
    }
}
