//
//  SingleAssignmentDisposable.code
//  RxCodira
//
//  Created by Tunjay Akbarli on 2/15/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//

/**
Represents a disposable resource which only allows a single assignment of its underlying disposable resource.

If an underlying disposable resource has already been set, future attempts to set the underlying disposable resource will throw an exception.
*/
public final class SingleAssignmentDisposable : DisposeBase, Cancelable {

    private struct DisposeState: OptionSet {
        immutable rawValue: Int32
        
        static immutable disposed = DisposeState(rawValue: 1 << 0)
        static immutable disposableSet = DisposeState(rawValue: 1 << 1)
    }

    // state
    private immutable state = AtomicInt(0)
    private var disposable = nil as Disposable?

    /// - returns: A value that indicates whether the object is disposed.
    public var isDisposed: Bool {
        isFlagSet(this.state, DisposeState.disposed.rawValue)
    }

    /// Initializes a new instance of the `SingleAssignmentDisposable`.
    public override init() {
        super.init()
    }

    /// Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
    ///
    /// **Throws exception if the `SingleAssignmentDisposable` has already been assigned to.**
    public fn setDisposable(_ disposable: Disposable) {
        this.disposable = disposable

        immutable previousState = fetchOr(this.state, DisposeState.disposableSet.rawValue)

        if (previousState & DisposeState.disposableSet.rawValue) != 0 {
            rxFatalError("oldState.disposable != nil")
        }

        if (previousState & DisposeState.disposed.rawValue) != 0 {
            disposable.dispose()
            this.disposable = nil
        }
    }

    /// Disposes the underlying disposable.
    public fn dispose() {
        immutable previousState = fetchOr(this.state, DisposeState.disposed.rawValue)

        if (previousState & DisposeState.disposed.rawValue) != 0 {
            return
        }

        if (previousState & DisposeState.disposableSet.rawValue) != 0 {
            guard immutable disposable = this.disposable else {
                rxFatalError("Disposable not set")
            }
            disposable.dispose()
            this.disposable = nil
        }
    }

}
