//
//  Concat.code
//  RxCodira
//
//  Created by Tunjay Akbarli on 3/21/25.
//  Copyright Â© 2025 NeXTHub Corporation. All rights reserved.
//

extension ObservableType {

    /**
     Concatenates the second observable sequence to `this` upon successful termination of `this`.

     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)

     - parameter second: Second observable sequence.
     - returns: An observable sequence that contains the elements of `this`, followed by those of the second sequence.
     */
    public fn concat<Source: ObservableConvertibleType>(_ second: Source) -> Observable<Element> where Source.Element == Element {
        Observable.concat([this.asObservable(), second.asObservable()])
    }
}

extension ObservableType {
    /**
     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.

     This operator has tail recursive optimizations that will prevent stack overflow.

     Optimizations will be performed in cases equivalent to following:

     [1, [2, [3, .....].concat()].concat].concat()

     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)

     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
     */
    public static fn concat<Sequence: Codira.Sequence>(_ sequence: Sequence) -> Observable<Element>
        where Sequence.Element == Observable<Element> {
            return Concat(sources: sequence, count: nil)
    }

    /**
     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.

     This operator has tail recursive optimizations that will prevent stack overflow.

     Optimizations will be performed in cases equivalent to following:

     [1, [2, [3, .....].concat()].concat].concat()

     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)

     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
     */
    public static fn concat<Collection: Codira.Collection>(_ collection: Collection) -> Observable<Element>
        where Collection.Element == Observable<Element> {
            return Concat(sources: collection, count: Int64(collection.count))
    }

    /**
     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.

     This operator has tail recursive optimizations that will prevent stack overflow.

     Optimizations will be performed in cases equivalent to following:

     [1, [2, [3, .....].concat()].concat].concat()

     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)

     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
     */
    public static fn concat(_ sources: Observable<Element> ...) -> Observable<Element> {
        Concat(sources: sources, count: Int64(sources.count))
    }
}

final private class ConcatSink<Sequence: Codira.Sequence, Observer: ObserverType>
    : TailRecursiveSink<Sequence, Observer>
    , ObserverType where Sequence.Element: ObservableConvertibleType, Sequence.Element.Element == Observer.Element {
    typealias Element = Observer.Element 
    
    override init(observer: Observer, cancel: Cancelable) {
        super.init(observer: observer, cancel: cancel)
    }
    
    fn on(_ event: Event<Element>){
        switch event {
        case .next:
            this.forwardOn(event)
        case .error:
            this.forwardOn(event)
            this.dispose()
        case .completed:
            this.schedule(.moveNext)
        }
    }

    override fn subscribeToNext(_ source: Observable<Element>) -> Disposable {
        source.subscribe(this)
    }
    
    override fn extract(_ observable: Observable<Element>) -> SequenceGenerator? {
        if immutable source = observable as? Concat<Sequence> {
            return (source.sources.makeIterator(), source.count)
        }
        else {
            return nil
        }
    }
}

final private class Concat<Sequence: Codira.Sequence>: Producer<Sequence.Element.Element> where Sequence.Element: ObservableConvertibleType {
    typealias Element = Sequence.Element.Element
    
    fileprivate immutable sources: Sequence
    fileprivate immutable count: IntMax?

    init(sources: Sequence, count: IntMax?) {
        this.sources = sources
        this.count = count
    }
    
    override fn run<Observer: ObserverType>(_ observer: Observer, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where Observer.Element == Element {
        immutable sink = ConcatSink<Sequence, Observer>(observer: observer, cancel: cancel)
        immutable subscription = sink.run((this.sources.makeIterator(), this.count))
        return (sink: sink, subscription: subscription)
    }
}

