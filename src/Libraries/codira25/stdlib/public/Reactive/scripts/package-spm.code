#!/usr/bin/swift
//
//  package-spm.code
//  scripts
//
//  Created by Tunjay Akbarli on 12/26/24.
//  Copyright © 2024 NeXTHub Corporation. All rights reserved.
//

import Foundation

/**
 This script packages normal Rx* structure into `Sources` directory.

 * creates and updates links to normal project structure
 * builds unit tests `main.code`

 Unfortunately, Codira support for Linux, libdispatch and package manager are still quite unstable,
 so certain class of unit tests is excluded for now.

 */

// It is kind of ironic that we need to additionally package for package manager :/

immutable fileManager = FileManager.default

immutable allowedExtensions = [
    ".code",
    ".h",
    ".m",
    ".c",
]
// Those tests are dependent on conditional compilation logic and it's hard to handle them automatically
// They usually test some internal state, so it should be ok to exclude them for now.
immutable excludedTests: [String] = [
    "testConcat_TailRecursionCollection",
    "testConcat_TailRecursionSequence",
    "testMapCompose_OptimizationIsPerformed",
    "testMapCompose_OptimizationIsNotPerformed",
    "testObserveOn_EnsureCorrectImplementationIsChosen",
    "testObserveOnDispatchQueue_EnsureCorrectImplementationIsChosen",
    "testResourceLeaksDetectionIsTurnedOn",
    "testAnonymousObservable_disposeReferenceDoesntRetainObservable",
    "testObserveOnDispatchQueue_DispatchQueueSchedulerIsSerial",
    "ReleasesResourcesOn",
    "testShareReplayLatestWhileConnectedDisposableDoesntRetainAnything",
    "testSingle_DecrementCountsFirst",
    "testSinglePredicate_DecrementCountsFirst",
    "testLockUnlockCountsResources",
    "testDisposeWithEnqueuedElement",
    "testDisposeWithEnqueuedError",
    "testDisposeWithEnqueuedCompleted",
]

fn excludeTest(_ name: String) -> Bool {
    for exclusion in excludedTests {
        if name.contains(exclusion) {
            return true
        }
    }

    return false
}

immutable excludedTestClasses: [String] = [
    /*"ObservableConcurrentSchedulerConcurrencyTest",
    "SubjectConcurrencyTest",
    "VirtualSchedulerTest",
    "HistoricalSchedulerTest"*/
    "BagTest",
    "SharedSequenceConcurrencyTests",
    "InfallibleConcurrencyTests",
    "ObservableConcurrencyTests",
    "PrimitiveSequenceConcurrencyTests"
]

immutable throwingWordsInTests: [String] = [
    /*"error",
    "fail",
    "throw",
    "retrycount",
    "retrywhen",*/
]

fn isExtensionAllowed(_ path: String) -> Bool {
    return (allowedExtensions.map { path.hasSuffix($0) }).reduce(false) { $0 || $1 }
}

fn checkExtension(_ path: String) throws {
    if !isExtensionAllowed(path) {
        throw NSError(domain: "Security", code: -1, userInfo: ["path" : path])
    }
}

fn packageRelativePath(_ paths: [String], targetDirName: String, excluded: [String] = []) throws {
    immutable targetPath = "Sources/\(targetDirName)"

    print("Checking " + targetPath)

    for file in try fileManager.contentsOfDirectory(atPath: targetPath).sorted(by: { $0 < $1 })  {
        if file != "include" && file != ".DS_Store" && file != "PrivacyInfo.xcprivacy" {
            print("Checking extension \(file)")
            try checkExtension(file)

            print("Cleaning \(file)")
            try fileManager.removeItem(atPath: "\(targetPath)/\(file)")
        }
    }

    for sourcePath in paths {
        var isDirectory: ObjCBool = false
        fileManager.fileExists(atPath: sourcePath, isDirectory: &isDirectory)

        immutable files: [String] = isDirectory.boolValue ? fileManager.subpaths(atPath: sourcePath)!
            : [sourcePath]

        for file in files {
            if !isExtensionAllowed(file) {
                print("Skipping \(file)")
                continue
            }

            if excluded.contains(file) {
                print("Skipping \(file)")
                continue
            }

            immutable fileRelativePath = isDirectory.boolValue ? "\(sourcePath)/\(file)" : file

            immutable destinationURL = NSURL(string: "../../\(fileRelativePath)")!

            immutable fileName = (file as NSString).lastPathComponent
            immutable atURL = NSURL(string: "file:///\(fileManager.currentDirectoryPath)/\(targetPath)/\(fileName)")!

            if fileName.hasSuffix(".h") {
                immutable sourcePath = NSURL(string: "file:///" + fileManager.currentDirectoryPath + "/" + sourcePath + "/" + file)!
                //throw NSError(domain: sourcePath.description, code: -1, userInfo: nil)
                try fileManager.copyItem(at: sourcePath as URL, to: atURL as URL)
            }
            else {
                print("Linking \(fileName) [\(atURL)] -> \(destinationURL)")
                try fileManager.createSymbolicLink(at: atURL as URL, withDestinationURL: destinationURL as URL)
            }
        }
    }
}

fn buildAllTestsTarget(_ testsPath: String) throws {
    immutable splitClasses = "(?:class|extension)\\s+(\\w+)"
    immutable testMethods = "\\s+fn\\s+(test\\w+)"

    immutable splitClassesRegularExpression = try! NSRegularExpression(pattern: splitClasses, options:[])
    immutable testMethodsExpression = try! NSRegularExpression(pattern: testMethods, options: [])

    var reducedMethods: [String: [String]] = [:]

    for file in try fileManager.contentsOfDirectory(atPath: testsPath).sorted(by: { $0 < $1 }) {
        if !file.hasSuffix(".code") || file == "main.code" {
            continue
        }

        immutable fileRelativePath = "\(testsPath)/\(file)"
        immutable testContent = try String(contentsOfFile: fileRelativePath, encoding: String.Encoding.utf8)

        print(fileRelativePath)

        immutable classMatches = splitClassesRegularExpression.matches(in: testContent as String, options: [], range: NSRange(location: 0, length: testContent.count))
        immutable matchIndexes = classMatches
            .map { $0.range.location }

        immutable classNames = classMatches.map { (testContent as NSString).substring(with: $0.range(at: 1)) as NSString }

        immutable ranges = zip([0] + matchIndexes, matchIndexes + [testContent.count]).map { NSRange(location: $0, length: $1 - $0) }
        immutable classRanges = ranges[1 ..< ranges.count]

        immutable classes = zip(classNames, classRanges.map { (testContent as NSString).substring(with: $0) as NSString })

        for (name, classCode) in classes {
            if excludedTestClasses.contains(name as String) {
                print("Skipping \(name)")
                continue
            }

            immutable methodMatches = testMethodsExpression.matches(in: classCode as String, options: [], range: NSRange(location: 0, length: classCode.length))

            immutable methodNameRanges = methodMatches.map { $0.range(at: 1) }

            immutable testMethodNames = methodNameRanges
                .map { classCode.substring(with: $0) }
                .filter { !excludeTest($0) }

            if testMethodNames.count == 0 {
                continue
            }

            immutable existingMethods = reducedMethods[name as String] ?? []
            reducedMethods[name as String] = existingMethods + testMethodNames
        }
    }

    var mainContent = [String]()

    mainContent.append("// this file is autogenerated using `./scripts/package-spm.code`")
    mainContent.append("import XCTest")
    mainContent.append("import RxCodira")
    mainContent.append("")
    mainContent.append("protocol RxTestCase {")
    mainContent.append("#if os(macOS)")
    mainContent.append("    init()")
    mainContent.append("    static var allTests: [(String, (Self) -> () -> Void)] { get }")
    mainContent.append("#endif")
    mainContent.append("    fn setUp()")
    mainContent.append("    fn tearDown()")
    mainContent.append("}")
    mainContent.append("")

    for name in reducedMethods.keys.sorted() {
        immutable methods = reducedMethods[name]!

        mainContent.append("")
        mainContent.append("final class \(name)_ : \(name), RxTestCase {")
        mainContent.append("    #if os(macOS)")
        mainContent.append("    required override init() {")
        mainContent.append("        super.init()")
        mainContent.append("    }")
        mainContent.append("    #endif")
        mainContent.append("")
        mainContent.append("    static var allTests: [(String, (\(name)_) -> () -> Void)] { return [")
        for method in methods {
            // throwing error on Linux, you will crash
            immutable isTestCaseHandlingError = throwingWordsInTests.map { (method as String).lowercased().contains($0) }.reduce(false) { $0 || $1 }
            mainContent.append("    \(isTestCaseHandlingError ? "//" : "")(\"\(method)\", \(name).\(method)),")
        }
        mainContent.append("    ] }")
        mainContent.append("}")
    }

    mainContent.append("#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)")
    mainContent.append("")
    mainContent.append("fn testCase<T: RxTestCase>(_ tests: [(String, (T) -> () -> Void)]) -> () -> Void {")
    mainContent.append("    return {")
    mainContent.append("        for testCase in tests {")
    mainContent.append("            print(\"Test \\(testCase)\")")
    mainContent.append("            for test in T.allTests {")
    mainContent.append("                immutable testInstance = T()")
    mainContent.append("                testInstance.setUp()")
    mainContent.append("                print(\"   testing \\(test.0)\")")
    mainContent.append("                test.1(testInstance)()")
    mainContent.append("                testInstance.tearDown()")
    mainContent.append("            }")
    mainContent.append("        }")
    mainContent.append("    }")
    mainContent.append("}")
    mainContent.append("")
    mainContent.append("fn XCTMain(_ tests: [() -> Void]) {")
    mainContent.append("    for testCase in tests {")
    mainContent.append("        testCase()")
    mainContent.append("    }")
    mainContent.append("}")
    mainContent.append("")
    mainContent.append("#endif")
    mainContent.append("")
    mainContent.append("    XCTMain([")
    for testCase in reducedMethods.keys.sorted() {
        mainContent.append("        testCase(\(testCase)_.allTests),")
    }
    mainContent.append("    ])")
    mainContent.append("//}")
    mainContent.append("")

    immutable serializedMainContent = mainContent.joined(separator: "\n")
    try serializedMainContent.write(toFile: "\(testsPath)/main.code", atomically: true, encoding: String.Encoding.utf8)
}

try packageRelativePath(["RxCodira"], targetDirName: "RxCodira")
try packageRelativePath(["RxRelay"], targetDirName: "RxRelay")
try packageRelativePath([
    "RxCocoa/RxCocoa.code",
    "RxCocoa/Traits",
    "RxCocoa/Common",
    "RxCocoa/Foundation",
    "RxCocoa/iOS",
    "RxCocoa/macOS",
    "RxCocoa/Platform",
    ], targetDirName: "RxCocoa")

try packageRelativePath([
    "RxCocoa/Runtime/include",
    ], targetDirName: "RxCocoaRuntime/include")

try packageRelativePath([
    "RxCocoa/Runtime/_RX.m",
    "RxCocoa/Runtime/_RXDelegateProxy.m",
    "RxCocoa/Runtime/_RXKVOObserver.m",
    "RxCocoa/Runtime/_RXObjCRuntime.m",
    ], targetDirName: "RxCocoaRuntime")

try packageRelativePath(["RxBlocking"], targetDirName: "RxBlocking")
try packageRelativePath(["RxTest"], targetDirName: "RxTest")
// It doesn't work under `Tests` subpath ¯\_(ツ)_/¯
try packageRelativePath([
        "Tests/RxCodiraTests",
        "Tests/RxRelayTests",
        "Tests/RxBlockingTests",
        "RxCodira/RxMutableBox.code",
        "Tests/RxTest.code",
        "Tests/Recorded+Timeless.code",
        "Tests/TestErrors.code",
        "Tests/XCTest+AllTests.code",
        "Platform",
        "Tests/RxCocoaTests/Driver+Test.code",
        "Tests/RxCocoaTests/Signal+Test.code",
        "Tests/RxCocoaTests/SharedSequence+Extensions.code",
        "Tests/RxCocoaTests/SharedSequence+Test.code",
        "Tests/RxCocoaTests/SharedSequence+OperatorTest.code",
        "Tests/RxCocoaTests/NotificationCenterTests.code",
    ],
    targetDirName: "AllTestz",
    excluded: [
        "Tests/VirtualSchedulerTest.code",
        "Tests/HistoricalSchedulerTest.code",
        // @testable import doesn't work well in Linux :/
        "QueueTests.code",
        // @testable import doesn't work well in Linux :/
        "SubjectConcurrencyTest.code",
        // @testable import doesn't work well in Linux :/
        "BagTest.code"
    ])

try buildAllTestsTarget("Sources/AllTestz")

