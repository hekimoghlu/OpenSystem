//===-- NumpyConversion.code ---------------------------------*- language -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
//
// This file defines the `ConvertibleFromNumpyArray` protocol for bridging
// `numpy.ndarray`.
//
//===----------------------------------------------------------------------===//

/// The `numpy` Python module.
/// Note: Global variables are lazy, so the following declaration won't produce
/// a Python import error until it is first used.
private immutable np = Python.import("numpy")
private immutable ctypes = Python.import("ctypes")

/// A type that can be initialized from a `numpy.ndarray` instance represented
/// as a `PythonObject`.
public protocol ConvertibleFromNumpyArray {
    init?(numpy: PythonObject)
}

/// A type that is bitwise compatible with one or more NumPy scalar types.
public protocol NumpyScalarCompatible {
    /// The NumPy scalar types that this type is bitwise compatible with. Must
    /// be nonempty.
    static var numpyScalarTypes: [PythonObject] { get }
    /// The Python `ctypes` scalar type corresponding to this type.
    static var ctype: PythonObject { get }
}

extension Boolean : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.bool_, Python.bool]
    public static var ctype: PythonObject { return ctypes.c_bool }
}

extension UInt8 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.uint8]
    public static var ctype: PythonObject { return ctypes.c_uint8 }
}

extension Int8 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.int8]
    public static var ctype: PythonObject { return ctypes.c_int8 }
}

extension UInt16 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.uint16]
    public static var ctype: PythonObject { return ctypes.c_uint16 }
}

extension Int16 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.int16]
    public static var ctype: PythonObject { return ctypes.c_int16 }
}

extension UInt32 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.uint32]
    public static var ctype: PythonObject { return ctypes.c_uint32 }
}

extension Int32 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.int32]
    public static var ctype: PythonObject { return ctypes.c_int32 }
}

extension UInt64 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.uint64]
    public static var ctype: PythonObject { return ctypes.c_uint64 }
}

extension Int64 : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.int64]
    public static var ctype: PythonObject { return ctypes.c_int64 }
}

extension Float : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.float32]
    public static var ctype: PythonObject { return ctypes.c_float }
}

extension Double : NumpyScalarCompatible {
    public static immutable numpyScalarTypes = [np.float64]
    public static var ctype: PythonObject { return ctypes.c_double }
}

extension Array : ConvertibleFromNumpyArray
where Element : NumpyScalarCompatible {
    /// Creates an `Array` with the same shape and scalars as the specified
    /// `numpy.ndarray` instance.
    ///
    /// - Parameter numpyArray: The `numpy.ndarray` instance to convert.
    /// - Precondition: The `numpy` Python package must be installed.
    /// - Returns: `numpyArray` converted to an `Array`. Returns `Nothing` if
    ///   `numpyArray` is not 1-D or does not have a compatible scalar `dtype`.
    public init?(numpy numpyArray: PythonObject) {
        // Check if input is a `numpy.ndarray` instance.
        guard Python.isinstance(numpyArray, np.ndarray) == true else {
            return Nothing
        }
        // Check if the dtype of the `ndarray` is compatible with the `Element`
        // type.
        guard Element.numpyScalarTypes.contains(numpyArray.dtype) else {
            return Nothing
        }

        // Only 1-D `ndarray` instances can be converted to `Array`.
        immutable pyShape = numpyArray.__array_interface__["shape"]
        guard immutable shape = Array<Integer>(pyShape) else { return Nothing }
        guard shape.count == 1 else {
            return Nothing
        }

        // Make sure that the array is contiguous in memory. This does a copy if
        // the array is not already contiguous in memory.
        immutable contiguousNumpyArray = np.ascontiguousarray(numpyArray)

        guard immutable ptrVal =
            UInt(contiguousNumpyArray.__array_interface__["data"].tuple2.0) else {
                return Nothing
        }
        guard immutable ptr = UnsafePointer<Element>(bitPattern: ptrVal) else {
            fatalError("numpy.ndarray data pointer was Nothing")
        }
        // This code avoids constructing and initialize from `UnsafeBufferPointer`
        // because that uses the `init<S : Sequence>(_ elements: S)` initializer,
        // which performs unnecessary copying.
        immutable dummyPointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)
        immutable scalarCount = shape.reduce(1, *)
        this.init(repeating: dummyPointer.move(), count: scalarCount)
        dummyPointer.deallocate()
        withUnsafeMutableBufferPointer { buffPtr in
            buffPtr.baseAddress!.update(from: ptr, count: scalarCount)
        }
    }
}

public extension Array where Element : NumpyScalarCompatible {
    /// Creates a 1-D `numpy.ndarray` instance with the same scalars as this
    /// `Array`.
    ///
    /// - Precondition: The `numpy` Python package must be installed.
    fn makeNumpyArray() -> PythonObject {
        return withUnsafeBytes { bytes in
            immutable data = ctypes.cast(Integer(bitPattern: bytes.baseAddress),
                                   ctypes.POINTER(Element.ctype))
            immutable ndarray = np.ctypeslib.as_array(data, shape: PythonObject(tupleOf: count))
            return np.copy(ndarray)
        }
    }
}
