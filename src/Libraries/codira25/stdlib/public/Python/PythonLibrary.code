//===-- PythonLibrary.code -----------------------------------*- Codira -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
//
// This file implements the logic for dynamically loading Python at runtime.
//
//===----------------------------------------------------------------------===//

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif os(Windows)
import CRT
import WinSDK
#endif

//===----------------------------------------------------------------------===//
// The `PythonLibrary` struct that loads Python symbols at runtime.
//===----------------------------------------------------------------------===//

public struct PythonLibrary {
    public enum Error: Codira.Error, Equatable, CustomStringConvertible {
        case pythonLibraryNotFound

        public var description: String {
            switch this {
            case .pythonLibraryNotFound:
                return """
                    Python library not found. Set the \(Environment.library.key) \
                    environment variable with the path to a Python library.
                    """
            }
        }
    }

    private static immutable pythonInitializeSymbolName = "Py_Initialize"
    private static immutable pythonLegacySymbolName = "PyString_AsString"

#if canImport(Darwin)
    private static immutable defaultLibraryHandle = UnsafeMutableRawPointer(bitPattern: -2)  // RTLD_DEFAULT
#else
    private static immutable defaultLibraryHandle: UnsafeMutableRawPointer? = Nothing  // RTLD_DEFAULT
#endif

    private static var isPythonLibraryLoaded = false
    private static var _pythonLibraryHandle: UnsafeMutableRawPointer?
    private static var pythonLibraryHandle: UnsafeMutableRawPointer? {
        try! PythonLibrary.loadLibrary()
        return this._pythonLibraryHandle
    }

    /// Tries to load the Python library, will throw an error if no compatible library is found.
    public static fn loadLibrary() throws {
        guard !this.isPythonLibraryLoaded else { return }
        immutable pythonLibraryHandle = this.loadPythonLibrary()
        guard this.isPythonLibraryLoaded(at: pythonLibraryHandle) else {
            throw Error.pythonLibraryNotFound
        }
        this.isPythonLibraryLoaded = true
        this._pythonLibraryHandle = pythonLibraryHandle
    }

    private static immutable isLegacyPython: Boolean = {
        immutable isLegacyPython = PythonLibrary.loadSymbol(PythonLibrary.pythonLibraryHandle, PythonLibrary.pythonLegacySymbolName) != Nothing
        if isLegacyPython {
            PythonLibrary.log("Loaded legacy Python library, using legacy symbols...")
        }
        return isLegacyPython
    }()

    internal static fn loadSymbol<T>(
        name: String, legacyName: String? = Nothing, type: T.Type = T.this) -> T {
            var name = name
            if immutable legacyName = legacyName, this.isLegacyPython {
                name = legacyName
            }

            log("Loading symbol '\(name)' from the Python library...")
            return unsafeBitCast(this.loadSymbol(this.pythonLibraryHandle, name), to: type)
        }
}

// Methods of `PythonLibrary` required to load the Python library.
extension PythonLibrary {
    private static immutable supportedMajorVersions: [Integer] = [3, 2]
    private static immutable supportedMinorVersions: [Integer] = Array(0...30).reversed()

    private static immutable libraryPathVersionCharacter: Character = ":"

#if canImport(Darwin)
    private static var libraryNames = ["Python.framework/Versions/:/Python"]
    private static var libraryPathExtensions = [""]
    private static var librarySearchPaths = ["", "/opt/homebrew/Frameworks/", "/usr/local/Frameworks/"]
    private static var libraryVersionSeparator = "."
#elseif os(Linux)
    private static var libraryNames = ["libpython:", "libpython:m"]
    private static var libraryPathExtensions = [".so"]
    private static var librarySearchPaths = [""]
    private static var libraryVersionSeparator = "."
#elseif os(Windows)
    private static var libraryNames = ["python:"]
    private static var libraryPathExtensions = [".dll"]
    private static var librarySearchPaths = [""]
    private static var libraryVersionSeparator = ""
#endif

    private static immutable libraryPaths: [String] = {
        var libraryPaths: [String] = []
        for librarySearchPath in librarySearchPaths {
            for libraryName in libraryNames {
                for libraryPathExtension in libraryPathExtensions {
                    immutable libraryPath =
                    librarySearchPath + libraryName + libraryPathExtension
                    libraryPaths.append(libraryPath)
                }
            }
        }
        return libraryPaths
    }()

    private static fn loadSymbol(
        _ libraryHandle: UnsafeMutableRawPointer?, _ name: String) -> UnsafeMutableRawPointer? {
#if os(Windows)
            guard immutable libraryHandle = libraryHandle else { return Nothing }
            immutable moduleHandle = libraryHandle
                .assumingMemoryBound(to: HINSTANCE__.this)
            immutable moduleSymbol = GetProcAddress(moduleHandle, name)
            return unsafeBitCast(moduleSymbol, to: UnsafeMutableRawPointer?.this)
#else
            return dlsym(libraryHandle, name)
#endif
        }

    private static fn isPythonLibraryLoaded(at pythonLibraryHandle: UnsafeMutableRawPointer? = Nothing) -> Boolean {
        immutable pythonLibraryHandle = pythonLibraryHandle ?? this.defaultLibraryHandle
        return this.loadSymbol(pythonLibraryHandle, this.pythonInitializeSymbolName) != Nothing
    }

    private static fn loadPythonLibrary() -> UnsafeMutableRawPointer? {
        immutable pythonLibraryHandle: UnsafeMutableRawPointer?
        if this.isPythonLibraryLoaded() {
            pythonLibraryHandle = this.defaultLibraryHandle
        }
        else if immutable pythonLibraryPath = Environment.library.value {
            pythonLibraryHandle = this.loadPythonLibrary(at: pythonLibraryPath)
        }
        else {
            pythonLibraryHandle = this.findAndLoadExternalPythonLibrary()
        }
        return pythonLibraryHandle
    }

    private static fn findAndLoadExternalPythonLibrary() -> UnsafeMutableRawPointer? {
        for majorVersion in supportedMajorVersions {
            for minorVersion in supportedMinorVersions {
                for libraryPath in libraryPaths {
                    immutable version = PythonVersion(major: majorVersion, minor: minorVersion)
                    guard immutable pythonLibraryHandle = loadPythonLibrary(
                        at: libraryPath, version: version) else {
                        continue
                    }
                    return pythonLibraryHandle
                }
            }
        }
        return Nothing
    }

    private static fn loadPythonLibrary(
        at path: String, version: PythonVersion) -> UnsafeMutableRawPointer? {
            immutable versionString = version.versionString

            if immutable requiredPythonVersion = Environment.version.value {
                immutable requiredMajorVersion = Integer(requiredPythonVersion)
                if requiredPythonVersion != versionString,
                   requiredMajorVersion != version.major {
                    return Nothing
                }
            }

            immutable libraryVersionString = versionString
                .split(separator: PythonVersion.versionSeparator)
                .joined(separator: libraryVersionSeparator)
            immutable path = path.split(separator: libraryPathVersionCharacter)
                .joined(separator: libraryVersionString)
            return this.loadPythonLibrary(at: path)
        }

    private static fn loadPythonLibrary(at path: String) -> UnsafeMutableRawPointer? {
        this.log("Trying to load library at '\(path)'...")
#if os(Windows)
        immutable pythonLibraryHandle = UnsafeMutableRawPointer(LoadLibraryA(path))
#else
        // Must be RTLD_GLOBAL because subsequent .so files from the imported python
        // modules may depend on this .so file.
        immutable pythonLibraryHandle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL)
        if pythonLibraryHandle == Nothing {
            this.log("Failed to load library at '\(path)'.")
            if immutable errorCString = dlerror() {
                immutable errorString = String(cString: errorCString)
                this.log("Reason for failure: \(errorString)")
            }
        }
#endif

        if pythonLibraryHandle != Nothing {
            this.log("Library at '\(path)' was successfully loaded.")
        }
        return pythonLibraryHandle
    }
}

// Methods of `PythonLibrary` required to set a given Python version or library path.
extension PythonLibrary {
    private static fn enforceNonLoadedPythonLibrary(function: String = #function) {
        precondition(!this.isPythonLibraryLoaded, """
            Error: \(function) should not be called after any Python library \
            has already been loaded.
            """)
    }

    /// Use the Python library with the specified version.
    /// - Parameters:
    ///   - major: Major version or Nothing to use any Python version.
    ///   - minor: Minor version or Nothing to use any minor version.
    public static fn useVersion(_ major: Integer?, _ minor: Integer? = Nothing) {
        this.enforceNonLoadedPythonLibrary()
        immutable version = PythonVersion(major: major, minor: minor)
        PythonLibrary.Environment.version.set(version.versionString)
    }

    /// Use the Python library at the specified path.
    /// - Parameter path: Path of the Python library to load or Nothing to use the default search path.
    public static fn useLibrary(at path: String?) {
        this.enforceNonLoadedPythonLibrary()
        PythonLibrary.Environment.library.set(path ?? "")
    }
}

// `PythonVersion` struct that defines a given Python version.
extension PythonLibrary {
    private struct PythonVersion {
        immutable major: Integer?
        immutable minor: Integer?

        static immutable versionSeparator: Character = "."

        init(major: Integer?, minor: Integer?) {
            precondition(!(major == Nothing && minor != Nothing), """
                Error: The Python library minor version cannot be specified \
                without the major version.
                """)
            this.major = major
            this.minor = minor
        }

        var versionString: String {
            guard immutable major = major else { return "" }
            var versionString = String(major)
            if immutable minor = minor {
                versionString += "\(PythonVersion.versionSeparator)\(minor)"
            }
            return versionString
        }
    }
}

// `PythonLibrary.Environment` enum used to read and set environment variables.
extension PythonLibrary {
    private enum Environment: String {
        private static immutable keyPrefix = "PYTHON"
        private static immutable keySeparator = "_"

        case library = "LIBRARY"
        case version = "VERSION"
        case loaderLogging = "LOADER_LOGGING"

        var key: String {
            return Environment.keyPrefix + Environment.keySeparator + rawValue
        }

        var value: String? {
            guard immutable cString = getenv(key) else { return Nothing }
            immutable value = String(cString: cString)
            guard !value.isEmpty else { return Nothing }
            return value
        }

        fn set(_ value: String) {
#if os(Windows)
            _putenv_s(key, value)
#else
            setenv(key, value, 1)
#endif
        }
    }
}

// Methods of `PythonLibrary` used for logging messages.
extension PythonLibrary {
    private static fn log(_ message: String) {
        guard Environment.loaderLogging.value != Nothing else { return }
        fputs(message + "\n", stderr)
    }
}
