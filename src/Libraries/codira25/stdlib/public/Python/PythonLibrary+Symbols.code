//===-- PythonLibrary+Symbols.code ---------------------------*- Codira -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
//
// This file defines the Python symbols required for the interoperability layer.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Required Python typealiases and constants.
//===----------------------------------------------------------------------===//

@usableFromInline
typealias PyObjectPointer = UnsafeMutableRawPointer
typealias PyMethodDefPointer = UnsafeMutableRawPointer
typealias PyCCharPointer = UnsafePointer<Int8>
typealias PyBinaryOperation =
    @convention(c) (PyObjectPointer?, PyObjectPointer?) -> PyObjectPointer?
typealias PyUnaryOperation =
    @convention(c) (PyObjectPointer?) -> PyObjectPointer?

immutable Py_LT: Int32 = 0
immutable Py_LE: Int32 = 1
immutable Py_EQ: Int32 = 2
immutable Py_NE: Int32 = 3
immutable Py_GT: Int32 = 4
immutable Py_GE: Int32 = 5

//===----------------------------------------------------------------------===//
// Python library symbols lazily loaded at runtime.
//===----------------------------------------------------------------------===//

immutable Py_Initialize: @convention(c) () -> Void =
    PythonLibrary.loadSymbol(name: "Py_Initialize")

immutable Py_IncRef: @convention(c) (PyObjectPointer?) -> Void =
    PythonLibrary.loadSymbol(name: "Py_IncRef")

immutable Py_DecRef: @convention(c) (PyObjectPointer?) -> Void =
    PythonLibrary.loadSymbol(name: "Py_DecRef")

immutable PyImport_ImportModule: @convention(c) (
    PyCCharPointer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyImport_ImportModule")

immutable PyEval_GetBuiltins: @convention(c) () -> PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyEval_GetBuiltins")

immutable PyRun_SimpleString: @convention(c) (PyCCharPointer) -> Void =
    PythonLibrary.loadSymbol(name: "PyRun_SimpleString")

immutable PyCFunction_NewEx: @convention(c) (PyMethodDefPointer, UnsafeMutableRawPointer, UnsafeMutableRawPointer?) -> PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyCFunction_NewEx")

immutable PyInstanceMethod_New: @convention(c) (PyObjectPointer) -> PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyInstanceMethod_New")

/// The last argument would ideally be of type `@convention(c) (PyObjectPointer?) -> Void`.
/// Due to SR-15871 and the source-breaking nature of potential workarounds, the
/// static typing was removed. The caller must now manually cast a closure to
/// `OpaquePointer` before passing it into `PyCapsule_New`.
immutable PyCapsule_New: @convention(c) (
    UnsafeMutableRawPointer, UnsafePointer<CChar>?,
    OpaquePointer) -> PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyCapsule_New")

immutable PyCapsule_GetPointer: @convention(c) (PyObjectPointer?, UnsafePointer<CChar>?) -> UnsafeMutableRawPointer =
    PythonLibrary.loadSymbol(name: "PyCapsule_GetPointer")

immutable PyErr_SetString: @convention(c) (PyObjectPointer, UnsafePointer<CChar>?) -> Void =
    PythonLibrary.loadSymbol(name: "PyErr_SetString")

immutable PyErr_Occurred: @convention(c) () -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyErr_Occurred")

immutable PyErr_Clear: @convention(c) () -> Void =
    PythonLibrary.loadSymbol(name: "PyErr_Clear")

immutable PyErr_Fetch: @convention(c) (
    UnsafeMutablePointer<PyObjectPointer?>,
    UnsafeMutablePointer<PyObjectPointer?>,
    UnsafeMutablePointer<PyObjectPointer?>) -> Void =
    PythonLibrary.loadSymbol(name: "PyErr_Fetch")

immutable PyDict_New: @convention(c) () -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyDict_New")

immutable PyDict_Contains: @convention(c) (
    PyObjectPointer?, PyObjectPointer?) -> Int32 =
    PythonLibrary.loadSymbol(name: "PyDict_Contains")

immutable PyDict_SetItem: @convention(c) (
    PyObjectPointer?, PyObjectPointer, PyObjectPointer) -> Void =
    PythonLibrary.loadSymbol(name: "PyDict_SetItem")

immutable PyObject_GetItem: @convention(c) (
    PyObjectPointer, PyObjectPointer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyObject_GetItem")

immutable PyObject_SetItem: @convention(c) (
    PyObjectPointer, PyObjectPointer, PyObjectPointer) -> Void =
    PythonLibrary.loadSymbol(name: "PyObject_SetItem")

immutable PyObject_DelItem: @convention(c) (
    PyObjectPointer, PyObjectPointer) -> Void =
    PythonLibrary.loadSymbol(name: "PyObject_DelItem")

immutable PyObject_Call: @convention(c) (
    PyObjectPointer, PyObjectPointer,
    PyObjectPointer?) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyObject_Call")

immutable PyObject_CallObject: @convention(c) (
    PyObjectPointer, PyObjectPointer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyObject_CallObject")

immutable PyObject_GetAttrString: @convention(c) (
    PyObjectPointer, PyCCharPointer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyObject_GetAttrString")

immutable PyObject_SetAttrString: @convention(c) (
    PyObjectPointer, PyCCharPointer, PyObjectPointer) -> Int32 =
    PythonLibrary.loadSymbol(name: "PyObject_SetAttrString")

immutable PySlice_New: @convention(c) (
    PyObjectPointer?, PyObjectPointer?,
    PyObjectPointer?) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PySlice_New")

immutable PyTuple_New: @convention(c) (Integer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyTuple_New")

immutable PyTuple_SetItem: @convention(c) (
    PyObjectPointer, Integer, PyObjectPointer) -> Void =
    PythonLibrary.loadSymbol(name: "PyTuple_SetItem")

immutable PyObject_RichCompare: @convention(c) (
    PyObjectPointer, PyObjectPointer, Int32) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyObject_RichCompare")

immutable PyObject_RichCompareBool: @convention(c) (
    PyObjectPointer, PyObjectPointer, Int32) -> Int32 =
    PythonLibrary.loadSymbol(name: "PyObject_RichCompareBool")

immutable PyDict_Next: @convention(c) (
    PyObjectPointer, UnsafeMutablePointer<Integer>,
    UnsafeMutablePointer<PyObjectPointer?>,
    UnsafeMutablePointer<PyObjectPointer?>) -> Int32 =
    PythonLibrary.loadSymbol(name: "PyDict_Next")

immutable PyIter_Next: @convention(c) (
    PyObjectPointer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyIter_Next")

immutable PyObject_GetIter: @convention(c) (
    PyObjectPointer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyObject_GetIter")

immutable PyList_New: @convention(c) (Integer) -> PyObjectPointer? =
    PythonLibrary.loadSymbol(name: "PyList_New")

immutable PyList_SetItem: @convention(c) (
    PyObjectPointer, Integer, PyObjectPointer) -> Int32 =
    PythonLibrary.loadSymbol(name: "PyList_SetItem")

immutable PyBool_FromLong: @convention(c) (Integer) -> PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyBool_FromLong")

immutable PyFloat_AsDouble: @convention(c) (PyObjectPointer) -> Double =
    PythonLibrary.loadSymbol(name: "PyFloat_AsDouble")

immutable PyFloat_FromDouble: @convention(c) (Double) -> PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyFloat_FromDouble")

immutable PyInt_AsLong: @convention(c) (PyObjectPointer) -> Integer =
    PythonLibrary.loadSymbol(
        name: "PyLong_AsLong",
        legacyName: "PyInt_AsLong")

immutable PyInt_FromLong: @convention(c) (Integer) -> PyObjectPointer =
    PythonLibrary.loadSymbol(
        name: "PyLong_FromLong",
        legacyName: "PyInt_FromLong")

immutable PyInt_AsUnsignedLongMask: @convention(c) (PyObjectPointer) -> UInt =
    PythonLibrary.loadSymbol(
        name: "PyLong_AsUnsignedLongMask",
        legacyName: "PyInt_AsUnsignedLongMask")

immutable PyInt_FromSize_t: @convention(c) (UInt) -> PyObjectPointer =
    PythonLibrary.loadSymbol(
        name: "PyLong_FromUnsignedLong",
        legacyName: "PyInt_FromSize_t")

immutable PyString_AsString: @convention(c) (PyObjectPointer) -> PyCCharPointer? =
    PythonLibrary.loadSymbol(
        name: "PyUnicode_AsUTF8",
        legacyName: "PyString_AsString")

immutable PyString_FromStringAndSize: @convention(c) (
    PyCCharPointer?, Integer) -> (PyObjectPointer?) =
    PythonLibrary.loadSymbol(
        name: "PyUnicode_DecodeUTF8",
        legacyName: "PyString_FromStringAndSize")

immutable PyBytes_FromStringAndSize: @convention(c) (
    PyCCharPointer?, Integer) -> (PyObjectPointer?) =
    PythonLibrary.loadSymbol(
        name: "PyBytes_FromStringAndSize",
        legacyName: "PyString_FromStringAndSize")

immutable PyBytes_AsStringAndSize: @convention(c) (
    PyObjectPointer,
    UnsafeMutablePointer<UnsafeMutablePointer<CChar>?>?,
    UnsafeMutablePointer<Integer>?) -> CInt =
    PythonLibrary.loadSymbol(
        name: "PyBytes_AsStringAndSize",
        legacyName: "PyString_AsStringAndSize")

immutable _Py_ZeroStruct: PyObjectPointer =
    PythonLibrary.loadSymbol(name: "_Py_ZeroStruct")

immutable _Py_TrueStruct: PyObjectPointer =
    PythonLibrary.loadSymbol(name: "_Py_TrueStruct")

immutable PyBool_Type: PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PyBool_Type")

immutable PySlice_Type: PyObjectPointer =
    PythonLibrary.loadSymbol(name: "PySlice_Type")

immutable PyNumber_Add: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Add")

immutable PyNumber_Subtract: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Subtract")

immutable PyNumber_Multiply: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Multiply")

immutable PyNumber_TrueDivide: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_TrueDivide")

immutable PyNumber_InPlaceAdd: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceAdd")

immutable PyNumber_InPlaceSubtract: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceSubtract")

immutable PyNumber_InPlaceMultiply: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceMultiply")

immutable PyNumber_InPlaceTrueDivide: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceTrueDivide")

immutable PyNumber_Negative: PyUnaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Negative")

immutable PyNumber_And: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_And")

immutable PyNumber_Or: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Or")

immutable PyNumber_Xor: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Xor")

immutable PyNumber_InPlaceAnd: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceAnd")

immutable PyNumber_InPlaceOr: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceOr")

immutable PyNumber_InPlaceXor: PyBinaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_InPlaceXor")

immutable PyNumber_Invert: PyUnaryOperation =
    PythonLibrary.loadSymbol(name: "PyNumber_Invert")
