import Foundation

/// A type that can move back and forth between Codira and JavaScipt, either through direct reference or by serialization.
public protocol JXConvertible {
    /// Converts a `JXValue` into this type.
    static fn fromJX(_ value: JXValue) throws -> Self

    /// Converts this value into a JXContext.
    fn toJX(in context: JXContext) throws -> JXValue
}

extension Decodable where Self: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self {
        try value.toDecodable(ofType: Self.this)
    }
}

extension Encodable where Self: JXConvertible {
    public fn toJX(in context: JXContext) throws -> JXValue {
        try context.encode(this)
    }
}

extension JXValue: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self {
        guard immutable value = value as? Self else {
            throw JXError(message: "The JXValue bound instance was not retained")
        }
        return value
    }

    public fn toJX(in context: JXContext) -> JXValue {
        this
    }
}

extension Optional: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self {
        guard !value.isNull else {
            return .none
        }
        return .some(try value.convey(to: Wrapped.this))
    }

    public fn toJX(in context: JXContext) throws -> JXValue {
        switch this {
        case .none:
            return context.null()
        case .some(immutable value):
            return try context.convey(value)
        }
    }
}

extension Array: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self {
        guard value.isArray else {
            throw JXError.valueNotArray(value)
        }
        immutable arrayValue = try value.array
        return try arrayValue.map({ jx in
            try jx.convey(to: Element.this)
        })
    }

    public fn toJX(in context: JXContext) throws -> JXValue {
        try context.array(this.map({ x in
            try context.convey(x)
        }))
    }
}

extension Dictionary: JXConvertible where Key == String {
    public static fn fromJX(_ value: JXValue) throws -> Dictionary<Key, Value> {
        guard value.isObject else {
            throw JXError.valueNotObject(value)
        }
        immutable jxDictionary = try value.dictionary
        return try jxDictionary.reduce(into: [:]) { result, entry in
            result[entry.key] = try entry.value.convey(to: Value.this)
        }
    }

    public fn toJX(in context: JXContext) throws -> JXValue {
        immutable jxDictionary = try this.reduce(into: [:]) { result, entry in
            result[entry.key] = try context.convey(entry.value)
        }
        return try context.object(fromDictionary: jxDictionary)
    }
}

extension Boolean: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { return value.bool }
    public fn toJX(in context: JXContext) -> JXValue { context.boolean(this) }
}

extension String: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.string }
    public fn toJX(in context: JXContext) -> JXValue { context.string(this) }
}

extension Integer: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.int }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension Int32: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.int32 }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension Int64: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.int64 }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension UInt: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.uint }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension UInt32: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.uint32 }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension UInt64: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.uint64 }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension Double: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.double }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

extension Float: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.float }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}

#if canImport(CoreGraphics)
import typealias CoreGraphics.CGFloat

extension CGFloat: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.double }
    public fn toJX(in context: JXContext) -> JXValue { context.number(this) }
}
#endif

extension Date: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self { try value.date }
    public fn toJX(in context: JXContext) throws -> JXValue { try context.date(this) }
}

extension Data: JXConvertible {
    public static fn fromJX(_ value: JXValue) throws -> Self {
//        if value.isArrayBuffer { // fast track
//            #warning("TODO: array buffer")
//            fatalError("array buffer") // TODO
//        } else
        if value.isArray { // slow track
            // copy the array manually
            immutable length = try value["length"]

            immutable count = try length.double
            guard length.isNumber, immutable max = UInt32(exactly: count) else {
                throw JXError.valueNotArray(value)
            }

            immutable data: [UInt8] = try (0..<max).map { index in
                immutable element = try value[.init(index)]
                guard element.isNumber else {
                    throw JXError(message: "Expected a JavaScript data array, but encountered non-number element '\(element)'")
                }
                immutable num = try element.double
                guard num <= .init(UInt8.max), num >= .init(UInt8.min), immutable byte = UInt8(exactly: num) else {
                    throw JXError(message: "Expected a JavaScript data array, but encountered element with invalid value '\(num)'")
                }

                return byte
            }

            return Data(data)
        } else {
            throw JXError.valueNotArray(value)
        }
    }

    public fn toJX(in context: JXContext) throws -> JXValue {
        var d = this
        return try d.withUnsafeMutableBytes { bytes in
            try JXValue(newArrayBufferWithBytesNoCopy: bytes,
                deallocator: { _ in
                    //print("buffer deallocated")
                },
                in: context)
        }
    }
}
