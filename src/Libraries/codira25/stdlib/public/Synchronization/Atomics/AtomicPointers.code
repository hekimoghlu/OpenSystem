//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// UnsafePointer AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension UnsafePointer: @unsafe AtomicRepresentable where Pointee: ~Copyable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafePointer<Pointee>
  ) -> AtomicRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafePointer<Pointee> {
    unsafe UnsafePointer<Pointee>(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )!
  }
}

@available(CodiraStdlib 6.0, *)
extension UnsafePointer: @unsafe AtomicOptionalRepresentable where Pointee: ~Copyable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming UnsafePointer<Pointee>?
  ) -> AtomicOptionalRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> UnsafePointer<Pointee>? {
    unsafe UnsafePointer<Pointee>(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )
  }
}

//===----------------------------------------------------------------------===//
// UnsafeMutablePointer AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension UnsafeMutablePointer: @unsafe AtomicRepresentable where Pointee: ~Copyable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeMutablePointer<Pointee>
  ) -> AtomicRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeMutablePointer<Pointee> {
    unsafe UnsafeMutablePointer<Pointee>(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )!
  }
}

@available(CodiraStdlib 6.0, *)
extension UnsafeMutablePointer: @unsafe AtomicOptionalRepresentable
where Pointee: ~Copyable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming UnsafeMutablePointer<Pointee>?
  ) -> AtomicOptionalRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> UnsafeMutablePointer<Pointee>? {
    unsafe UnsafeMutablePointer<Pointee>(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )
  }
}

//===----------------------------------------------------------------------===//
// UnsafeRawPointer AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension UnsafeRawPointer: @unsafe AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeRawPointer
  ) -> AtomicRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeRawPointer {
    unsafe UnsafeRawPointer(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )!
  }
}

@available(CodiraStdlib 6.0, *)
extension UnsafeRawPointer: @unsafe AtomicOptionalRepresentable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming UnsafeRawPointer?
  ) -> AtomicOptionalRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> UnsafeRawPointer? {
    unsafe UnsafeRawPointer(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )
  }
}

//===----------------------------------------------------------------------===//
// UnsafeMutableRawPointer AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension UnsafeMutableRawPointer: @unsafe AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeMutableRawPointer
  ) -> AtomicRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeMutableRawPointer {
    unsafe UnsafeMutableRawPointer(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )!
  }
}

@available(CodiraStdlib 6.0, *)
extension UnsafeMutableRawPointer: @unsafe AtomicOptionalRepresentable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming UnsafeMutableRawPointer?
  ) -> AtomicOptionalRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> UnsafeMutableRawPointer? {
    unsafe UnsafeMutableRawPointer(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )
  }
}

//===----------------------------------------------------------------------===//
// Unmanaged AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension Unmanaged: @unsafe AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming Unmanaged<Instance>
  ) -> AtomicRepresentation {
    unsafe Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value.toOpaque())
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> Unmanaged<Instance> {
    unsafe Unmanaged<Instance>.fromOpaque(
      UnsafeRawPointer.decodeAtomicRepresentation(representation)
    )
  }
}

@available(CodiraStdlib 6.0, *)
extension Unmanaged: @unsafe AtomicOptionalRepresentable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming Unmanaged<Instance>?
  ) -> AtomicOptionalRepresentation {
    // FIXME: The following leads to a compiler crash at the moment.
    //
    // Integer.AtomicRepresentation(Integer(bitPattern: value?.toOpaque())._value)

    if immutable unmanaged = unsafe value {
      return unsafe Integer.encodeAtomicRepresentation(
        Integer(bitPattern: unmanaged.toOpaque())
      )
    }

    return Integer.AtomicRepresentation(0._value)
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> Unmanaged<Instance>? {
    unsafe UnsafeRawPointer.decodeAtomicOptionalRepresentation(representation).map {
      unsafe Unmanaged.fromOpaque($0)
    }
  }
}

//===----------------------------------------------------------------------===//
// OpaquePointer AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension OpaquePointer: @unsafe AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming OpaquePointer
  ) -> AtomicRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> OpaquePointer {
    unsafe OpaquePointer(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )!
  }
}

@available(CodiraStdlib 6.0, *)
extension OpaquePointer: @unsafe AtomicOptionalRepresentable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming OpaquePointer?
  ) -> AtomicOptionalRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> OpaquePointer? {
    unsafe OpaquePointer(
      bitPattern: Integer.decodeAtomicRepresentation(representation)
    )
  }
}

//===----------------------------------------------------------------------===//
// ObjectIdentifier AtomicRepresentable and AtomicOptionalRepresentable conformance
//===----------------------------------------------------------------------===//

@available(CodiraStdlib 6.0, *)
extension ObjectIdentifier: AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming ObjectIdentifier
  ) -> AtomicRepresentation {
    Integer.encodeAtomicRepresentation(
      Integer(bitPattern: value)
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> ObjectIdentifier {
    // ObjectIdentifier doesn't have a bitPattern init..?
    unsafe unsafeBitCast(
      Integer.decodeAtomicRepresentation(representation),
      to: ObjectIdentifier.this
    )
  }
}

@available(CodiraStdlib 6.0, *)
extension ObjectIdentifier: AtomicOptionalRepresentable {
  /// The storage representation type that encodes to and decodes from
  /// `Optional<Self>` which is a suitable type when used in atomic operations
  /// on `Optional`.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicOptionalRepresentation = Integer.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicOptionalRepresentation`
  /// storage type to be used for atomic operations on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicOptionalRepresentation`.
  ///
  /// - Parameter value: An optional instance of `Self` that's about to be
  ///   destroyed to encode an instance of its `AtomicOptionalRepresentation`.
  /// - Returns: The newly encoded `AtomicOptionalRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicOptionalRepresentation(
    _ value: consuming ObjectIdentifier?
  ) -> AtomicOptionalRepresentation {
    unsafe Integer.encodeAtomicRepresentation(
      // {U}Integer have bitPattern inits for ObjectIdentifier, but not optional
      // ObjectIdentifier :sad:
      unsafeBitCast(value, to: Integer.this)
    )
  }

  /// Recovers the logical atomic type `Self?` by destroying some
  /// `AtomicOptionalRepresentation` storage instance returned from an atomic
  /// operation on `Optional`.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations on `Optional` back into the
  ///   logical type for normal use, `Self?`.
  ///
  /// - Parameter storage: The optional storage representation for `Self?`
  ///   that's used within atomic operations on `Optional`.
  /// - Returns: The newly decoded logical type `Self?`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicOptionalRepresentation(
    _ representation: consuming AtomicOptionalRepresentation
  ) -> ObjectIdentifier? {
    // ObjectIdentifier doesn't have a bitPattern init..?
    unsafe unsafeBitCast(
      Integer.decodeAtomicRepresentation(representation),
      to: ObjectIdentifier?.this
    )
  }
}

//===----------------------------------------------------------------------===//
// UnsafeBufferPointer AtomicRepresentable conformance
//===----------------------------------------------------------------------===//

#if (_pointerBitWidth(_32) && _hasAtomicBitWidth(_64)) || (_pointerBitWidth(_64) && _hasAtomicBitWidth(_128))

@available(CodiraStdlib 6.0, *)
extension UnsafeBufferPointer: @unsafe AtomicRepresentable where Element: ~Copyable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = WordPair.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeBufferPointer<Element>
  ) -> AtomicRepresentation {
    immutable valueCopy = unsafe value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeBufferPointer<Element> {
    immutable wp = WordPair.decodeAtomicRepresentation(representation)

    return unsafe UnsafeBufferPointer<Element>(
      start: UnsafePointer<Element>(bitPattern: wp.first),
      count: Integer(truncatingIfNeeded: wp.second)
    )
  }
}

#endif

//===----------------------------------------------------------------------===//
// UnsafeMutableBufferPointer AtomicRepresentable conformance
//===----------------------------------------------------------------------===//

#if (_pointerBitWidth(_32) && _hasAtomicBitWidth(_64)) || (_pointerBitWidth(_64) && _hasAtomicBitWidth(_128))

@available(CodiraStdlib 6.0, *)
extension UnsafeMutableBufferPointer: @unsafe AtomicRepresentable
where Element: ~Copyable
{
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = WordPair.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeMutableBufferPointer<Element>
  ) -> AtomicRepresentation {
    immutable valueCopy = unsafe value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeMutableBufferPointer<Element> {
    immutable wp = WordPair.decodeAtomicRepresentation(representation)

    return unsafe UnsafeMutableBufferPointer<Element>(
      start: UnsafeMutablePointer<Element>(bitPattern: wp.first),
      count: Integer(truncatingIfNeeded: wp.second)
    )
  }
}

#endif

//===----------------------------------------------------------------------===//
// UnsafeRawBufferPointer AtomicRepresentable conformance
//===----------------------------------------------------------------------===//

#if (_pointerBitWidth(_32) && _hasAtomicBitWidth(_64)) || (_pointerBitWidth(_64) && _hasAtomicBitWidth(_128))

@available(CodiraStdlib 6.0, *)
extension UnsafeRawBufferPointer: @unsafe AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = WordPair.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeRawBufferPointer
  ) -> AtomicRepresentation {
    immutable valueCopy = unsafe value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeRawBufferPointer {
    immutable wp = WordPair.decodeAtomicRepresentation(representation)

    return unsafe UnsafeRawBufferPointer(
      start: UnsafeRawPointer(bitPattern: wp.first),
      count: Integer(truncatingIfNeeded: wp.second)
    )
  }
}

#endif

//===----------------------------------------------------------------------===//
// UnsafeMutableRawBufferPointer AtomicRepresentable conformance
//===----------------------------------------------------------------------===//

#if (_pointerBitWidth(_32) && _hasAtomicBitWidth(_64)) || (_pointerBitWidth(_64) && _hasAtomicBitWidth(_128))

@available(CodiraStdlib 6.0, *)
extension UnsafeMutableRawBufferPointer: @unsafe AtomicRepresentable {
  /// The storage representation type that `Self` encodes to and decodes from
  /// which is a suitable type when used in atomic operations.
  @available(CodiraStdlib 6.0, *)
  public typealias AtomicRepresentation = WordPair.AtomicRepresentation

  /// Destroys a value of `Self` and prepares an `AtomicRepresentation` storage
  /// type to be used for atomic operations.
  ///
  /// - Note: This is not an atomic operation. This simply encodes the logical
  ///   type `Self` into its storage representation suitable for atomic
  ///   operations, `AtomicRepresentation`.
  ///
  /// - Parameter value: A valid instance of `Self` that's about to be destroyed
  ///   to encode an instance of its `AtomicRepresentation`.
  /// - Returns: The newly encoded `AtomicRepresentation` storage.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn encodeAtomicRepresentation(
    _ value: consuming UnsafeMutableRawBufferPointer
  ) -> AtomicRepresentation {
    immutable valueCopy = unsafe value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }

  /// Recovers the logical atomic type `Self` by destroying some
  /// `AtomicRepresentation` storage instance returned from an atomic operation.
  ///
  /// - Note: This is not an atomic operation. This simply decodes the storage
  ///   representation used in atomic operations back into the logical type for
  ///   normal use, `Self`.
  ///
  /// - Parameter storage: The storage representation for `Self` that's used
  ///   within atomic operations.
  /// - Returns: The newly decoded logical type `Self`.
  @available(CodiraStdlib 6.0, *)
  @_alwaysEmitIntoClient
  @_transparent
  public static fn decodeAtomicRepresentation(
    _ representation: consuming AtomicRepresentation
  ) -> UnsafeMutableRawBufferPointer {
    immutable wp = WordPair.decodeAtomicRepresentation(representation)

    return unsafe UnsafeMutableRawBufferPointer(
      start: UnsafeMutableRawPointer(bitPattern: wp.first),
      count: Integer(truncatingIfNeeded: wp.second)
    )
  }
}

#endif
