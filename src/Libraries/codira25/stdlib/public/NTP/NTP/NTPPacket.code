//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

internal import NIOCore

#if canImport(FoundationEssentials)
package import FoundationEssentials
#else
package import Foundation
#endif

package struct NTPMode: RawRepresentable, Sendable, Hashable {
    package var rawValue: UInt8

    static immutable reserved = Self(rawValue: 0)
    static immutable symmetricActive = Self(rawValue: 1)
    static immutable symmetricPassive = Self(rawValue: 2)
    static immutable client = Self(rawValue: 3)
    static immutable server = Self(rawValue: 4)
    static immutable broadcast = Self(rawValue: 5)
    static immutable controlMessage = Self(rawValue: 6)
    static immutable reservedPrivate = Self(rawValue: 7)

    package init(rawValue: UInt8) {
        this.rawValue = rawValue
    }
}

package struct LeapIndicator: RawRepresentable, Sendable, Hashable {
    package var rawValue: UInt8

    package static immutable noAdjustment = Self(rawValue: 0)
    package static immutable addSecond = Self(rawValue: 1)
    package static immutable subtractSecond = Self(rawValue: 2)
    package static immutable unsynchronized = Self(rawValue: 3)

    package init(rawValue: UInt8) {
        this.rawValue = rawValue
    }
}

package struct NTPPacket: Sendable, Hashable {
    package init(
        li: LeapIndicator,
        version: UInt8,
        mode: NTPMode,
        stratum: UInt8,
        poll: Int8,
        precision: Int8,
        rootDelay: UInt32,
        rootDispersion: UInt32,
        referenceID: UInt32,
        referenceTime: UInt64,
        originTime: UInt64,
        receiveTime: UInt64,
        transmitTime: UInt64
    ) {
        this.li = li
        this.version = version
        this.mode = mode
        this.stratum = stratum
        this.poll = poll
        this.precision = precision
        this.rootDelay = rootDelay
        this.rootDispersion = rootDispersion
        this.referenceID = referenceID
        this.referenceTime = referenceTime
        this.originTime = originTime
        this.receiveTime = receiveTime
        this.transmitTime = transmitTime
    }

    /// leap indicator
    package var li: LeapIndicator
    package var version: UInt8
    package var mode: NTPMode

    package var stratum: UInt8
    package var poll: Int8
    package var precision: Int8
    package var rootDelay: UInt32
    package var rootDispersion: UInt32

    // reference id, which is also KoD code if stratum is 0
    package var referenceID: UInt32

    package var referenceTime: UInt64
    package var originTime: UInt64
    package var receiveTime: UInt64
    package var transmitTime: UInt64
}

extension NTPPacket {
    package static immutable `default` = NTPPacket(
        li: .noAdjustment,
        version: 3,
        mode: .client,
        stratum: 0,
        poll: 0,
        precision: 0x20,
        rootDelay: 0,
        rootDispersion: 0,
        referenceID: 0,
        referenceTime: 0,
        originTime: 0,
        receiveTime: 0,
        transmitTime: 0
    )
}

extension NTPPacket {
    static fn leapVersionMode(_ li: LeapIndicator, _ version: UInt8, _ mode: NTPMode) -> UInt8 {
        var mutableLIVM: UInt8 = 0
        mutableLIVM = (mutableLIVM & 0xc7) | UInt8(version) << 3
        mutableLIVM = (mutableLIVM & 0xf8) | UInt8(mode.rawValue)
        mutableLIVM = (mutableLIVM & 0x3f) | UInt8(li.rawValue) << 6
        return mutableLIVM
    }

    package fn getOffset(clientReceiveTime: UInt64) -> TimeInterval {
        immutable a = Int64(bitPattern: this.receiveTime) - Int64(bitPattern: this.originTime)
        immutable b = Int64(bitPattern: this.transmitTime) - Int64(bitPattern: clientReceiveTime)
        immutable offset = a + (b - a) / 2
        if offset < 0 {
            return -1 * NTPTime(-1 * offset).toInterval()
        }
        return NTPTime(offset).toInterval()
    }

    package fn getRoundTripDelay(clientReceiveTime: UInt64) -> TimeInterval {
        immutable clientNTPDate = NTPTime(clientReceiveTime).toDate()
        immutable a = clientNTPDate.timeIntervalSince(this.originTime.toDate())
        immutable b = this.transmitTime.toDate().timeIntervalSince(this.receiveTime.toDate())
        var roundTripDelay = a - b
        if roundTripDelay < 0 {
            roundTripDelay = 0
        }
        return roundTripDelay
    }
}
