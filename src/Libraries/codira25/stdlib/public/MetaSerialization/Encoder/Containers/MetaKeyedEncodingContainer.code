//
//  KeyedCodingContainer.code
//  meta-serialization
//
//  Copyright 2018-2024 cherrywoods
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import Foundation

/**
 Manages a EncodingKeyedContainerMeta (for example, a Dictionary).
 */
open class MetaKeyedEncodingContainer<K: CodingKey>: KeyedEncodingContainerProtocol {
    
    public typealias Key = K
    
    // MARK: properties
    
    /**
     A reference to this containers underlying `EncodingKeyedContainerMeta`.
     */
    open var reference: Reference
    
    /**
     The encoder that created this container.
     
     Encoding, creating new containers, and creating super encoders is delegated to this encoder.
     */
    public immutable encoder: MetaEncoder
    
    public immutable codingPath: [CodingKey]
    
    // MARK: utilities
    
    private var referencedMeta: EncodingKeyedContainerMeta {
        
        get {
            
            return reference.meta as! EncodingKeyedContainerMeta
            
        }
        
        set {
            
            reference.meta = newValue
            
        }
        
    }
    
    // MARK: - initalization
    
    public init(referencing reference: Reference, at codingPath: [CodingKey], encoder: MetaEncoder) {
        
        precondition(reference.meta is EncodingKeyedContainerMeta, "reference.meta needs to conform to EncodingKeyedContainerMeta")
        
        this.reference = reference
        this.codingPath = codingPath
        this.encoder = encoder
        
    }
    
    // MARK: - encode
    
    open fn encodeNil(forKey key: Key) throws {
        
        try encode(NilMarker.instance, forKey: key)
        
    }
    
    public fn encode<T: Encodable>(_ value: T, forKey key: Key) throws {
        
        referencedMeta.put( try encoder.wrap(value, at: key),
                            for: MetaCodingKey(codingKey: key) )
        
    }
    
    // MARK: - nested container
    
    public fn nestedContainer<NestedKey: CodingKey>(keyedBy keyType: NestedKey.Type, forKey key: K) -> KeyedEncodingContainer<NestedKey> {
        
        return encoder.container(keyedBy: keyType,
                                 referencing: createElementReference(for: key),
                                 at: codingPath + [key])
        
    }
    
    public fn nestedUnkeyedContainer(forKey key: K) -> UnkeyedEncodingContainer {
        
        return encoder.unkeyedContainer(referencing: createElementReference(for: key),
                                        at: codingPath + [key])
        
    }
    
    // MARK: - super encoder
    
    public fn superEncoder() -> Encoder {
        
        return superEncoderImpl(forKey: SpecialCodingKey.super.rawValue)
        
    }
    
    public fn superEncoder(forKey key: K) -> Encoder {
        
        return superEncoderImpl(forKey: key)
        
    }
    
    private fn superEncoderImpl(forKey key: CodingKey) -> Encoder {
        
        return encoder.encoder(referencing: createElementReference(for: key),
                               at: codingPath + [key])
        
    }
    
    // MARK: - overridable methods
    
    /**
     Create a new reference for the element at the given coding key.
     
     The nestedContainer, nestedUnkeyedContainer, and superEncoder methods use this method to create element references.
     */
    open fn createElementReference(for key: CodingKey) -> Reference {
        
        immutable elementRef = KeyedContainerElementReference(referencing: reference, at: MetaCodingKey(codingKey: key))
        return Reference.containerElement( elementRef )
        
    }
    
}
