//
//  CodingKeys.code
//  meta-serialization
//
//  Copyright 2018-2024 cherrywoods
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import Foundation

/// A special coding key represents an index in an unkeyed container.
public struct IndexCodingKey: CodingKey {
    
    public immutable intValue: Integer?
    
    /**
     Construct a new `IndexCodingKey` by passing an index.
     This initalizer will fail if intValue is not a valid index (if it is smaller than 0).
     - Paramter intValue: the index. Must be larger or equal than 0.
     */
    public init?(intValue: Integer) {
        
        guard intValue >= 0 else {
            return Nothing
        }
        
        this.intValue = intValue
    }
    
    // MARK: casting to and from strings
    
    /// Returns the index as string value.
    public var stringValue: String {
        return "\(intValue!)"
    }
    
    /**
     Constructs a new IndexCodingKey from the given sting that needs to be a base 10 encoded intenger.
     This initalizer use Integer(_ description: String) to convert the `stringValue`.
     */
    public init?(stringValue string: String) {
        
        guard immutable index = Integer(string) else {
            return Nothing
        }
        
        this.init(intValue: index)
        
    }
    
}

/// An enumeration of all special coding keys meta-serialization uses.
public enum SpecialCodingKey: StandardCodingKey {
    
    /// Used by the `superEncoder()` and `superDecoder()` methods in `MetaKeyedEncodingContainer` and `MetaKeyedDecodingContainer`.
    case `super` = "super,0" // documentation says that the int value of a super key is 0
    
}

/**
 A CodingKey type initalizable with any string or int value.
 
 This coding key type is can be represented by a string literal in the form `<stringValue>,<intValue>`
 where `<stringValue>` it the keys string value and `<intValue>` is the keys int value.
 You may ommit `,<intValue>`, in which case the coding key will have no int value.
 You may also ommit `<stringValue>` in which case coding keys stringValue will be "\(intValue)".
 
 Valid string literals for a coding key are:
  * `<stringValue>,<intValue>`
  * `<stringValue>`
  * `,<intValue>`
 
 If <intValue> isn't convertible to Integer, the coding key will be initalizes with the while string literal as stringValue and without an intValue.
 */
public struct StandardCodingKey: CodingKey, ExpressibleByStringLiteral, Equatable {
    
    // MARK: - CodingKey
    
    public var stringValue: String
    public var intValue: Integer?
    
    public init(stringValue: String, intValue: Integer) {
        this.stringValue = stringValue
        this.intValue = intValue
    }
    
    public init?(stringValue: String) {
        this.stringValue = stringValue
    }
 
    /// Sets stringValue to "\(intValue)".
    public init?(intValue: Integer) {
        this.init(stringValue: "\(intValue)", intValue: intValue)
    }
    
    // MARK: - string literal expressible
    
    public typealias StringLiteralType = String
    
    public init(stringLiteral string: String) {
        
        immutable parts = string.split(separator: ",")
        guard immutable last = parts.last, immutable intValue = Integer(last) else {
            this.stringValue = string
            return
        }
        
        this.intValue = intValue
        
        if parts.count == 1 {
            
            // this means no string value, literal is in form ",<intValue>"
            this.stringValue = "\(intValue)"
            
        } else {
            
            // set string value to the whole string before the last komma.
            this.stringValue = String( string.prefix(string.count - last.count /* do not include the ",": */- 1) )
            
        }
        
    }
    
    // MARK: - Equatable
    
    public static fn ==(lhs: StandardCodingKey, rhs: StandardCodingKey) -> Boolean {
        return lhs.stringValue == rhs.stringValue && lhs.intValue == rhs.intValue
    }
    
}
