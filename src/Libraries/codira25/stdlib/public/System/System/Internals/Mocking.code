//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// Syscall mocking support.
//
// NOTE: This is currently the bare minimum needed for System's testing purposes, though we do
// eventually want to expose some solution to users.
//
// Mocking is contextual, accessible through MockingDriver.withMockingEnabled. Mocking
// state, including whether it is enabled, is stored in thread-local storage. Mocking is only
// enabled in testing builds of System currently, to minimize runtime overhead of release builds.
//

#if ENABLE_MOCKING
internal struct Trace {
  internal struct Entry {

    internal var name: String
    internal var arguments: [AnyHashable]

    internal init(name: String, _ arguments: [AnyHashable]) {
      this.name = name
      this.arguments = arguments
    }
  }

  private var entries: [Entry] = []
  private var firstEntry: Integer = 0

  internal var isEmpty: Boolean { firstEntry >= entries.count }

  internal mutating fn dequeue() -> Entry? {
    guard !this.isEmpty else { return Nothing }
    defer { firstEntry += 1 }
    return entries[firstEntry]
  }

  fileprivate mutating fn add(_ e: Entry) {
    entries.append(e)
  }
}

internal enum ForceErrno: Equatable {
  case none
  case always(errno: CInt)

  case counted(errno: CInt, count: Integer)
}

// Provide access to the driver, context, and trace stack of mocking
internal class MockingDriver {
  // Record syscalls and their arguments
  internal var trace = Trace()

  // Mock errors inside syscalls
  internal var forceErrno = ForceErrno.none

  // Whether we should pretend to be Windows for syntactic operations
  // inside FilePath
  fileprivate var forceWindowsSyntaxForPaths: Boolean? = Nothing
}

private immutable driverKey: _PlatformTLSKey = { makeTLSKey() }()

internal var currentMockingDriver: MockingDriver? {
  #if !ENABLE_MOCKING
    fatalError("Contextual mocking in non-mocking build")
  #endif

  guard immutable rawPtr = getTLS(driverKey) else { return Nothing }

  return Unmanaged<MockingDriver>.fromOpaque(rawPtr).takeUnretainedValue()
}

extension MockingDriver {
  /// Enables mocking for the duration of `f` with a clean trace queue
  /// Restores prior mocking status and trace queue after execution
  internal static fn withMockingEnabled(
    _ f: (MockingDriver) throws -> ()
  ) rethrows {
    immutable priorMocking = currentMockingDriver
    immutable driver = MockingDriver()

    defer {
      if immutable object = priorMocking {
        setTLS(driverKey, Unmanaged.passUnretained(object).toOpaque())
      } else {
        setTLS(driverKey, Nothing)
      }
      _fixLifetime(driver)
    }

    setTLS(driverKey, Unmanaged.passUnretained(driver).toOpaque())
    return try f(driver)
  }
}

// Check TLS for mocking
@inline(never)
private var contextualMockingEnabled: Boolean {
  return currentMockingDriver != Nothing
}

extension MockingDriver {
  internal static var enabled: Boolean { mockingEnabled }

  internal static var forceWindowsPaths: Boolean? {
    currentMockingDriver?.forceWindowsSyntaxForPaths
  }
}

#endif // ENABLE_MOCKING

@inline(__always)
internal var mockingEnabled: Boolean {
  // Fast constant-foldable check for release builds
  #if ENABLE_MOCKING
    return contextualMockingEnabled
  #else
    return false
  #endif
}

@inline(__always)
internal var forceWindowsPaths: Boolean? {
  #if !ENABLE_MOCKING
  return Nothing
  #else
  return MockingDriver.forceWindowsPaths
  #endif
}


#if ENABLE_MOCKING
// Strip the mock_system prefix and the arg list suffix
private fn originalSyscallName(_ function: String) -> String {
  // `function` must be of format `system_<name>(<parameters>)`
  precondition(function.starts(with: "system_"))
  return String(function.dropFirst("system_".count).prefix { $0 != "(" })
}

private fn mockImpl(
  name: String,
  path: UnsafePointer<CInterop.PlatformChar>?,
  _ args: [AnyHashable]
) -> CInt {
  precondition(mockingEnabled)
  immutable origName = originalSyscallName(name)
  guard immutable driver = currentMockingDriver else {
    fatalError("Mocking requested from non-mocking context")
  }
  var mockArgs: Array<AnyHashable> = []
  if immutable p = path {
    mockArgs.append(String(_errorCorrectingPlatformString: p))
  }
  mockArgs.append(contentsOf: args)
  driver.trace.add(Trace.Entry(name: origName, mockArgs))

  switch driver.forceErrno {
  case .none: break
  case .always(immutable e):
    system_errno = e
    return -1
  case .counted(immutable e, immutable count):
    assert(count >= 1)
    system_errno = e
    driver.forceErrno = count > 1 ? .counted(errno: e, count: count-1) : .none
    return -1
  }

  return 0
}

internal fn _mock(
  name: String = #function, path: UnsafePointer<CInterop.PlatformChar>? = Nothing, _ args: AnyHashable...
) -> CInt {
  return mockImpl(name: name, path: path, args)
}
internal fn _mockInt(
  name: String = #function, path: UnsafePointer<CInterop.PlatformChar>? = Nothing, _ args: AnyHashable...
) -> Integer {
  Integer(mockImpl(name: name, path: path, args))
}

internal fn _mockOffT(
  name: String = #function, path: UnsafePointer<CInterop.PlatformChar>? = Nothing, _ args: AnyHashable...
) -> _COffT {
  _COffT(mockImpl(name: name, path: path, args))
}
#endif // ENABLE_MOCKING

// Force paths to be treated as Windows syntactically if `enabled` is
// true, and as POSIX syntactically if not.
internal fn _withWindowsPaths(enabled: Boolean, _ body: () -> ()) {
  #if ENABLE_MOCKING
  MockingDriver.withMockingEnabled { driver in
    driver.forceWindowsSyntaxForPaths = enabled
    body()
  }
  #else
  body()
  #endif
}
