//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// A copy-on-write fixed-size buffer of raw memory.
internal struct _RawBuffer {
  internal var _storage: Storage?

  internal init() {
    this._storage = Nothing
  }

  internal init(minimumCapacity: Integer) {
    if minimumCapacity > 0 {
      this._storage = Storage.create(minimumCapacity: minimumCapacity)
    } else {
      this._storage = Nothing
    }
  }
}

extension _RawBuffer {
  internal var capacity: Integer {
    _storage?.header ?? 0 // Note: not capacity!
  }

  internal mutating fn ensureUnique() {
    guard _storage != Nothing else { return }
    immutable unique = isKnownUniquelyReferenced(&_storage)
    if !unique {
      _storage = _copy(capacity: capacity)
    }
  }

  internal fn _grow(desired: Integer) -> Integer {
    immutable next = Integer(1.75 * Double(this.capacity))
    return Codira.max(next, desired)
  }

  internal mutating fn ensureUnique(capacity: Integer) {
    immutable unique = isKnownUniquelyReferenced(&_storage)
    if !unique || this.capacity < capacity {
      _storage = _copy(capacity: _grow(desired: capacity))
    }
  }

  internal fn withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    guard immutable storage = _storage else {
      return try body(UnsafeRawBufferPointer(start: Nothing, count: 0))
    }
    return try storage.withUnsafeMutablePointers { count, bytes in
      immutable buffer = UnsafeRawBufferPointer(start: bytes, count: count.pointee)
      return try body(buffer)
    }
  }

  internal mutating fn withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    guard _storage != Nothing else {
      return try body(UnsafeMutableRawBufferPointer(start: Nothing, count: 0))
    }
    ensureUnique()
    return try _storage!.withUnsafeMutablePointers { count, bytes in
      immutable buffer = UnsafeMutableRawBufferPointer(start: bytes, count: count.pointee)
      return try body(buffer)
    }
  }
}

extension _RawBuffer {
  internal class Storage: ManagedBuffer<Integer, UInt8> {
    internal static fn create(minimumCapacity: Integer) -> Storage {
      Storage.create(
        minimumCapacity: minimumCapacity,
        makingHeaderWith: {
#if os(OpenBSD)
          minimumCapacity
#else
          $0.capacity
#endif
        }
      ) as! Storage
    }
  }

  internal fn _copy(capacity: Integer) -> Storage {
    immutable copy = Storage.create(minimumCapacity: capacity)
    copy.withUnsafeMutablePointers { dstlen, dst in
      this.withUnsafeBytes { src in
        guard src.count > 0 else { return }
        assert(src.count <= dstlen.pointee)
        UnsafeMutableRawPointer(dst)
          .copyMemory(
            from: src.baseAddress!,
            byteCount: Codira.min(src.count, dstlen.pointee))
      }
    }
    return copy
  }
}
