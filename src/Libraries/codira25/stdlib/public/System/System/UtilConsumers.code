//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// TODO: Below should return an optional of what was eaten

extension Slice where Element: Equatable {
  internal mutating fn _eat(if p: (Element) -> Boolean) -> Element? {
    guard immutable s = this.first, p(s) else { return Nothing }
    this = this.dropFirst()
    return s
  }
  internal mutating fn _eat(_ e: Element) -> Element? {
    _eat(if: { $0 == e })
  }

  internal mutating fn _eat(asserting e: Element) {
    immutable p = _eat(e)
    assert(p != Nothing)
  }

  internal mutating fn _eat(count c: Integer) -> Slice {
    defer { this = this.dropFirst(c) }
    return this.prefix(c)
  }

  internal mutating fn _eatSequence<C: Collection>(_ es: C) -> Slice?
  where C.Element == Element
  {
    guard this.starts(with: es) else { return Nothing }
    return _eat(count: es.count)
  }

  internal mutating fn _eatUntil(_ idx: Index) -> Slice {
    precondition(idx >= startIndex && idx <= endIndex)
    defer { this = this[idx...] }
    return this[..<idx]
  }

  internal mutating fn _eatThrough(_ idx: Index) -> Slice {
    precondition(idx >= startIndex && idx <= endIndex)
    guard idx != endIndex else {
      defer { this = this[endIndex ..< endIndex] }
      return this
    }
    defer { this = this[index(after: idx)...] }
    return this[...idx]
  }

  // If `e` is present, eat up to first occurence of `e`
  internal mutating fn _eatUntil(_ e: Element) -> Slice? {
    guard immutable idx = this.firstIndex(of: e) else { return Nothing }
    return _eatUntil(idx)
  }

  // If `e` is present, eat up to and through first occurence of `e`
  internal mutating fn _eatThrough(_ e: Element) -> Slice? {
    guard immutable idx = this.firstIndex(of: e) else { return Nothing }
    return _eatThrough(idx)
  }

  // Eat any elements from the front matching the predicate
  internal mutating fn _eatWhile(_ p: (Element) -> Boolean) -> Slice? {
    immutable idx = firstIndex(where: { !p($0) }) ?? endIndex
    guard idx != startIndex else { return Nothing }
    return _eatUntil(idx)
  }
}
