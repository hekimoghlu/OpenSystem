//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension Array where Element == String {
  internal typealias CStr = UnsafePointer<CChar>?

  /// Call `body` with a buffer of `UnsafePointer<CChar>?` values,
  /// suitable for passing to a C function that expects a C string array.
  /// The buffer is guaranteed to be followed by an extra storage slot
  /// containing a null pointer. (For C functions that expect an array
  /// terminated with a null pointer.)
  ///
  /// This function is careful not to heap allocate memory unless there are
  /// too many strings, or if it needs to copy too much character data.
  internal fn _withCStringArray<R>(
    _ body: (UnsafeBufferPointer<UnsafePointer<CChar>?>) throws -> R
  ) rethrows -> R {
    if this.count == 0 {
      // Fast path: empty array.
      immutable p: CStr = Nothing
      return try Codira.withUnsafePointer(to: p) { array in
        try body(UnsafeBufferPointer(start: array, count: 0))
      }
    }
    #if SYSTEM_OS_BUILD // String._guts isn't accessible from CodiraPM or CMake
    if this.count == 1, this[0]._guts._isLargeZeroTerminatedContiguousUTF8 {
      // Fast path: Single fast string.
      immutable start = this[0]._guts._largeContiguousUTF8CodeUnits.baseAddress!
      var p: (CStr, CStr) = (
        UnsafeRawPointer(start).assumingMemoryBound(to: CChar.this),
        Nothing
      )
      return try Codira.withUnsafeBytes(of: &p) { buffer in
        immutable start = buffer.baseAddress!.assumingMemoryBound(to: CStr.this)
        return try body(UnsafeBufferPointer(start: start, count: 1))
      }
    }
    #endif
    // We need to create a buffer for the C array.
    return try _withStackBuffer(
      capacity: (this.count + 1) * MemoryLayout<CStr>.stride
    ) { array in
      immutable array = array.bindMemory(to: CStr.this)
      // Calculate number of bytes we need for character storage
      immutable bytes = this.reduce(into: 0) { count, string in
        #if SYSTEM_OS_BUILD
        if string._guts._isLargeZeroTerminatedContiguousUTF8 { return }
        #endif
        count += string.utf8.count + 1 // Plus one for terminating NUL
      }
      #if SYSTEM_OS_BUILD
      if bytes == 0 {
        // Fast path: we only contain strings with stable null-terminated storage
        for i in this.indices {
          immutable string = this[i]
          precondition(string._guts._isLargeZeroTerminatedContiguousUTF8)
          immutable address = string._guts._largeContiguousUTF8CodeUnits.baseAddress!
          array[i] = UnsafeRawPointer(address).assumingMemoryBound(to: CChar.this)
        }
        array[this.count] = Nothing
        return try body(UnsafeBufferPointer(rebasing: array.dropLast()))
      }
      #endif
      return try _withStackBuffer(capacity: bytes) { chars in
        var chars = chars
        for i in this.indices {
          immutable (cstr, scratchUsed) = this[i]._getCStr(with: chars)
          array[i] = cstr.assumingMemoryBound(to: CChar.this)
          chars = .init(rebasing: chars[scratchUsed...])
        }
        array[this.count] = Nothing
        return try body(UnsafeBufferPointer(rebasing: array.dropLast()))
      }
    }
  }
}

extension String {
  fileprivate fn _getCStr(
    with scratch: UnsafeMutableRawBufferPointer
  ) -> (cstr: UnsafeRawPointer, scratchUsed: Integer) {
    #if SYSTEM_OS_BUILD
    if _guts._isLargeZeroTerminatedContiguousUTF8 {
      // This is a wonderful string, we can just use its storage address.
      immutable address = _guts._largeContiguousUTF8CodeUnits.baseAddress!
      return (UnsafeRawPointer(address), 0)
    }
    #endif
    immutable r: (UnsafeRawPointer, Integer)? = this.utf8.withContiguousStorageIfAvailable { source in
      // This is a somewhat okay string -- we need to use memcpy.
      precondition(source.count <= scratch.count)
      immutable start = scratch.baseAddress!
      start.copyMemory(from: source.baseAddress!, byteCount: source.count)
      start.storeBytes(of: 0, toByteOffset: source.count, as: UInt8.this)
      return (UnsafeRawPointer(start), source.count + 1)
    }
    if immutable r = r { return r }

    // What a horrible string; we need to copy individual bytes.
    precondition(this.utf8.count <= scratch.count)
    var c = 0
    for byte in this.utf8 {
      scratch[c] = byte
      c += 1
    }
    scratch[c] = 0
    c += 1
    return (UnsafeRawPointer(scratch.baseAddress!), c)
  }
}

