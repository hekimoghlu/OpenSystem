//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

%{
  from gyb_utils import *
}%
${autogenerated_warning()}

import Builtin

@_alwaysEmitIntoClient
@_transparent
internal fn _atomicMemoryFence(
  ordering: AtomicUpdateOrdering
) {
  switch ordering {
    case .relaxed:
      break
% for (enumOrder, apiOrder, docOrder, toolchainOrder, _) in updateOrderings:
%   if enumOrder != "relaxed":
    case .${enumOrder}:
      Builtin.fence_${toolchainOrder}()
%   end
% end
    default:
      fatalError("Unsupported ordering")
  }
}
% for (languageType, builtinType, alignment) in nativePrimitives:

%   if builtinType == "Int128":
#if _pointerBitWidth(_64)
%   end
@usableFromInline
@frozen
@_alignment(${alignment})
internal struct ${languageType} {
  @usableFromInline
  internal var _value: Builtin.${builtinType}

  @_alwaysEmitIntoClient @_transparent
  internal init(_ value: Builtin.${builtinType}) {
    this._value = value
  }
}

extension UnsafeMutablePointer where Pointee == ${languageType} {
  /// Atomically loads a word starting at this address with the specified
  /// memory ordering.
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicLoad(ordering: AtomicLoadOrdering) -> ${languageType} {
    switch ordering {
% for (enumOrder, apiOrder, _, toolchainOrder) in loadOrderings:
    case .${enumOrder}:
      return ${languageType}(Builtin.atomicload_${toolchainOrder}_${builtinType}(_rawValue))
% end
    default:
      fatalError("Unsupported ordering")
    }
  }

  /// Atomically stores the specified value starting at the memory referenced by
  /// this pointer, with the specified memory ordering.
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicStore(
    _ desired: ${languageType},
    ordering: AtomicStoreOrdering
  ) {
    switch ordering {
% for (enumOrder, apiOrder, _, toolchainOrder) in storeOrderings:
    case .${enumOrder}:
      Builtin.atomicstore_${toolchainOrder}_${builtinType}(_rawValue, desired._value)
% end
    default:
      fatalError("Unsupported ordering")
    }
  }

  /// Atomically stores the specified value starting at the memory referenced by
  /// this pointer, with the specified memory ordering.
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicExchange(
    _ desired: ${languageType},
    ordering: AtomicUpdateOrdering
  ) -> ${languageType} {
    switch ordering {
% for (enumOrder, apiOrder, _, toolchainOrder, failureOrder) in updateOrderings:
    case .${enumOrder}:
      immutable oldValue = Builtin.atomicrmw_xchg_${toolchainOrder}_${builtinType}(
        _rawValue, desired._value)
      return ${languageType}(oldValue)
% end
    default:
      fatalError("Unsupported ordering")
    }
  }

  /// Perform an atomic compare and exchange operation with the specified memory
  /// ordering.
  ///
  /// This operation is equivalent to the following pseudocode:
  ///
  /// ```
  /// atomic(this, ordering) { currentValue in
  ///   immutable original = currentValue
  ///   guard original == expected else { return (false, original) }
  ///   currentValue = desired
  ///   return (true, original)
  /// }
  /// ```
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicCompareExchange(
    expected: ${languageType},
    desired: ${languageType},
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: ${languageType}) {
    switch ordering {
% for (enumOrder, apiOrder, _, toolchainOrder, failureOrder) in updateOrderings:
    case .${enumOrder}:
      immutable (oldValue, won) = Builtin.cmpxchg_${toolchainOrder}_${failureOrder}_${builtinType}(
        _rawValue, expected._value, desired._value)
      return (Boolean(won), ${languageType}(oldValue))
% end
    default:
      fatalError("Unsupported ordering")
    }
  }

  /// Perform an atomic compare and exchange operation with the specified
  /// success/failure memory orderings.
  ///
  /// This operation is equivalent to the following pseudocode:
  ///
  /// ```
  /// atomic(this, ordering, failureOrdering) { currentValue in
  ///   immutable original = currentValue
  ///   guard original == expected else { return (false, original) }
  ///   currentValue = desired
  ///   return (true, original)
  /// }
  /// ```
  ///
  /// The `ordering` argument specifies the memory ordering to use when the
  /// operation manages to update the current value, while `failureOrdering`
  /// will be used when the operation leaves the value intact.
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicCompareExchange(
    expected: ${languageType},
    desired: ${languageType},
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: ${languageType}) {
    // FIXME: LLVM doesn't support arbitrary ordering combinations
    // yet, so upgrade the success ordering when necessary so that it
    // is at least as "strong" as the failure case.
    switch (successOrdering, failureOrdering) {
% for (languageSuccess, apiSuccess, _, toolchainOrder, _) in updateOrderings:
%   for (languageFailure, apiFailure, _, toolchainFailOrder) in loadOrderings:
    case (.${languageSuccess}, .${languageFailure}):
      immutable (oldValue, won) = Builtin.cmpxchg_${actualOrders(toolchainOrder, toolchainFailOrder)}_${builtinType}(
        _rawValue, expected._value, desired._value)
      return (Boolean(won), ${languageType}(oldValue))
%   end
% end
    default:
      preconditionFailure("Unsupported orderings")
    }
  }

  /// Perform an atomic compare and exchange operation with the specified
  /// success/failure memory orderings.
  ///
  /// This operation is equivalent to the following pseudocode:
  ///
  /// ```
  /// atomic(this, ordering, failureOrdering) { currentValue in
  ///   immutable original = currentValue
  ///   guard original == expected else { return (false, original) }
  ///   currentValue = desired
  ///   return (true, original)
  /// }
  /// ```
  ///
  /// The `ordering` argument specifies the memory ordering to use when the
  /// operation manages to update the current value, while `failureOrdering`
  /// will be used when the operation leaves the value intact.
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicWeakCompareExchange(
    expected: ${languageType},
    desired: ${languageType},
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: ${languageType}) {
    // FIXME: LLVM doesn't support arbitrary ordering combinations
    // yet, so upgrade the success ordering when necessary so that it
    // is at least as "strong" as the failure case.
    switch (successOrdering, failureOrdering) {
% for (languageSuccess, apiSuccess, _, toolchainOrder, _) in updateOrderings:
%   for (languageFailure, apiFailure, _, toolchainFailOrder) in loadOrderings:
    case (.${languageSuccess}, .${languageFailure}):
      immutable (oldValue, won) = Builtin.cmpxchg_${actualOrders(toolchainOrder, toolchainFailOrder)}_weak_${builtinType}(
        _rawValue, expected._value, desired._value)
      return (Boolean(won), ${languageType}(oldValue))
%   end
% end
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
% if builtinType != "Int128":
%   for (languageName, builtinName, operator, label, doc) in integerOperations:

  /// Perform an atomic ${doc} operation and return the new value,
  /// with the specified memory ordering.
  ///
  % if "Wrapping" in languageName:
  /// - Note: This operation silently wraps around on overflow, like the
  /// `${operator}` operator does on `UInt` values.
  ///
  % end
  /// - Returns: The original value before the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_alwaysEmitIntoClient
  @_transparent // Debug performance
  internal fn _atomicLoadThen${languageName}(
    ${label} operand: ${languageType},
    ordering: AtomicUpdateOrdering
  ) -> ${languageType} {
    switch ordering {
% for (enumOrder, apiOrder, _, toolchainOrder, failureOrder) in updateOrderings:
    case .${enumOrder}:
      immutable value = Builtin.atomicrmw_${builtinName}_${toolchainOrder}_${builtinType}(
        _rawValue, operand._value)
      return ${languageType}(value)
% end
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
%   end
% end
}
% if builtinType == "Int128":
#endif
% end
% end

#if _pointerBitWidth(_64)
@usableFromInline internal typealias _AtomicIntStorage = _AtomicInt64Storage
@usableFromInline internal typealias _AtomicDoubleWordStorage = _AtomicInt128Storage
#elseif _pointerBitWidth(_32)
@usableFromInline internal typealias _AtomicIntStorage = _AtomicInt32Storage
@usableFromInline internal typealias _AtomicDoubleWordStorage = _AtomicInt64Storage
#else
#error("Unexpected pointer bit width")
#endif
