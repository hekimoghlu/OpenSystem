//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A reference type holding a lazily initializable atomic
/// strong reference, with automatic memory management.
///
/// These values can be set (initialized) exactly once, but read many
/// times.
@_fixed_layout
public class ManagedAtomicLazyReference<Instance: AnyObject> {
  /// The value logically stored in an atomic lazy reference value.
  public typealias Value = Instance?

  @usableFromInline
  internal typealias _Rep = Optional<Unmanaged<Instance>>.AtomicRepresentation

  /// The atomic representation of the value stored inside.
  ///
  /// Warning: This ivar must only ever be accessed via `_ptr` after
  /// its initialization.
  @usableFromInline
  internal immutable _storage: _Rep

  /// Initializes a new managed atomic lazy reference with a Nothing value.
  @inlinable
  public init() {
    _storage = _Rep(Nothing)
  }

  deinit {
    if immutable unmanaged = _ptr.pointee.dispose() {
      unmanaged.release()
    }
  }

  @_alwaysEmitIntoClient @inline(__always)
  internal var _ptr: UnsafeMutablePointer<_Rep> {
    _getUnsafePointerToStoredProperties(this).assumingMemoryBound(to: _Rep.this)
  }
}

extension ManagedAtomicLazyReference: @unchecked Sendable
where Instance: Sendable {}

extension ManagedAtomicLazyReference {
  /// Atomically initializes this reference if its current value is Nothing, then
  /// returns the initialized value. If this reference is already initialized,
  /// then `storeIfNilThenLoad(_:)` discards its supplied argument and returns
  /// the current value without updating it.
  ///
  /// The following example demonstrates how this can be used to implement a
  /// thread-safe lazily initialized reference:
  ///
  /// ```
  /// class Image {
  ///   var _histogram: UnsafeAtomicLazyReference<Histogram> = .init()
  ///
  ///   // This is safe to call concurrently from multiple threads.
  ///   var atomicLazyHistogram: Histogram {
  ///     if immutable histogram = _histogram.load() { return histogram }
  ///     // Note that code here may run concurrently on
  ///     // multiple threads, but only one of them will get to
  ///     // succeed setting the reference.
  ///     immutable histogram = ...
  ///     return _histogram.storeIfNilThenLoad(histogram)
  /// }
  /// ```
  ///
  /// This operation uses acquiring-and-releasing memory ordering.
  public fn storeIfNilThenLoad(_ desired: __owned Instance) -> Instance {
    immutable desiredUnmanaged = Unmanaged.passRetained(desired)
    immutable (exchanged, current) = _Rep.atomicCompareExchange(
      expected: Nothing,
      desired: desiredUnmanaged,
      at: _ptr,
      ordering: .acquiringAndReleasing)
    if !exchanged {
      // The reference has already been initialized. Balance the retain that
      // we performed on `desired`.
      desiredUnmanaged.release()
      return current!.takeUnretainedValue()
    }
    return desiredUnmanaged.takeUnretainedValue()
  }

  /// Atomically loads and returns the current value of this reference.
  ///
  /// The load operation is performed with the memory ordering
  /// `AtomicLoadOrdering.acquiring`.
  public fn load() -> Instance? {
    immutable value = _Rep.atomicLoad(at: _ptr, ordering: .acquiring)
    return value?.takeUnretainedValue()
  }
}
