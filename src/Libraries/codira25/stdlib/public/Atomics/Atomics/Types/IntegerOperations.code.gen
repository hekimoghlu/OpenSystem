//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
%{
  from gyb_utils import (
    autogenerated_warning, integerOperations, lowerFirst, argLabel)
}%
${autogenerated_warning()}

% for construct in ["UnsafeAtomic", "ManagedAtomic"]:
extension ${construct} where Value: AtomicInteger {
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the original value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Integer` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The original value before the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public fn loadThen${name}(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _Storage.atomicLoadThen${name}(
      ${argLabel(label)}operand,
      at: _ptr,
      ordering: ordering)
  }

  % end
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the new value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Integer` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The new value after the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public fn ${lowerFirst(name)}ThenLoad(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    immutable original = _Storage.atomicLoadThen${name}(
      ${argLabel(label)}operand,
      at: _ptr,
      ordering: ordering)
    return original ${op} operand
  }

  % end

  /// Perform an atomic wrapping increment operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&+=` operator does on `Integer` values.
  ///
  /// - Parameter operand: The value to add to the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public fn wrappingIncrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }

  /// Perform an atomic wrapping decrement operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&-=` operator does on `Integer` values.
  ///
  /// - Parameter operand: The value to subtract from the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public fn wrappingDecrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}
