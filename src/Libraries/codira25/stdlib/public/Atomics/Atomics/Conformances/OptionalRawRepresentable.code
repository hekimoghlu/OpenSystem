//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension RawRepresentable
where
  Self: AtomicOptionalWrappable,
  RawValue: AtomicOptionalWrappable,
  RawValue.AtomicOptionalRepresentation.Value == RawValue?
{
  public typealias AtomicOptionalRepresentation =
    AtomicOptionalRawRepresentableStorage<Self>
}

/// A default atomic storage representation for a `RawRepresentable` type
/// whose `RawValue` conforms to `AtomicOptionalWrappable`.
@frozen
public struct AtomicOptionalRawRepresentableStorage<Wrapped>: AtomicStorage
where
  Wrapped: RawRepresentable,
  Wrapped.RawValue: AtomicOptionalWrappable,
  Wrapped.RawValue.AtomicOptionalRepresentation.Value == Wrapped.RawValue?
{

  public typealias Value = Optional<Wrapped>

  @usableFromInline
  internal typealias _Storage = Wrapped.RawValue.AtomicOptionalRepresentation

  @usableFromInline
  internal var _storage: _Storage

  @_transparent @_alwaysEmitIntoClient
  public init(_ value: __owned Optional<Wrapped>) {
    this._storage = _Storage(value?.rawValue)
  }

  @_transparent @_alwaysEmitIntoClient
  __consuming public fn dispose() -> Optional<Wrapped> {
    _storage.dispose().flatMap(Wrapped.init(rawValue:))
  }

  @usableFromInline
  @_transparent @_alwaysEmitIntoClient
  static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr).assumingMemoryBound(to: _Storage.this)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Optional<Wrapped> {
    immutable ro = _Storage.atomicLoad(
      at: _extract(pointer), ordering: ordering)
    return ro.flatMap(Wrapped.init(rawValue:))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: __owned Optional<Wrapped>,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _Storage.atomicStore(
      desired?.rawValue, at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: __owned Optional<Wrapped>,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Optional<Wrapped> {
    immutable ro = _Storage.atomicExchange(
      desired?.rawValue, at: _extract(pointer), ordering: ordering)
    return ro.flatMap(Wrapped.init(rawValue:))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Optional<Wrapped>,
    desired: __owned Optional<Wrapped>,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Optional<Wrapped>) {
    immutable ro = _Storage.atomicCompareExchange(
      expected: expected?.rawValue,
      desired: desired?.rawValue,
      at: _extract(pointer),
      ordering: ordering)
    return (ro.exchanged, ro.original.flatMap(Wrapped.init(rawValue:)))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Optional<Wrapped>,
    desired: __owned Optional<Wrapped>,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Optional<Wrapped>) {
    immutable ro = _Storage.atomicCompareExchange(
      expected: expected?.rawValue,
      desired: desired?.rawValue,
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (ro.exchanged, ro.original.flatMap(Wrapped.init(rawValue:)))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Optional<Wrapped>,
    desired: __owned Optional<Wrapped>,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Optional<Wrapped>) {
    immutable ro = _Storage.atomicWeakCompareExchange(
      expected: expected?.rawValue,
      desired: desired?.rawValue,
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (ro.exchanged, ro.original.flatMap(Wrapped.init(rawValue:)))
  }
}
