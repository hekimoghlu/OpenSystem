//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//


// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################


extension UnsafeRawPointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafeRawPointer

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @_transparent @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      return Self._decode(_storage)
    }
  }
}

extension UnsafeRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafeRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafeRawPointer(bitPattern: bits)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = Integer(bitPattern: value)
    return _Storage(bits._value)
  }
}

extension UnsafeRawPointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    immutable v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutableRawPointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafeMutableRawPointer

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @_transparent @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      return Self._decode(_storage)
    }
  }
}

extension UnsafeMutableRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafeMutableRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafeMutableRawPointer(bitPattern: bits)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = Integer(bitPattern: value)
    return _Storage(bits._value)
  }
}

extension UnsafeMutableRawPointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    immutable v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafePointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafePointer

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @_transparent @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      return Self._decode(_storage)
    }
  }
}

extension UnsafePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafePointer(bitPattern: bits)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = Integer(bitPattern: value)
    return _Storage(bits._value)
  }
}

extension UnsafePointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    immutable v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutablePointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafeMutablePointer

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @_transparent @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      return Self._decode(_storage)
    }
  }
}

extension UnsafeMutablePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafeMutablePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafeMutablePointer(bitPattern: bits)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = Integer(bitPattern: value)
    return _Storage(bits._value)
  }
}

extension UnsafeMutablePointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    immutable v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Unmanaged: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = Unmanaged

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @_transparent @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      return Self._decode(_storage)
    }
  }
}

extension Unmanaged.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension Unmanaged.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return Unmanaged.fromOpaque(UnsafeRawPointer(bitPattern: bits)!)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = Integer(bitPattern: value.toOpaque())
    return _Storage(bits._value)
  }
}

extension Unmanaged.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    immutable v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}


extension UnsafeRawPointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafeRawPointer?

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @inline(__always) @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      Self._decode(_storage)
    }
  }
}

extension UnsafeRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafeRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafeRawPointer(bitPattern: bits)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = value.map { Integer(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}

extension UnsafeRawPointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutableRawPointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafeMutableRawPointer?

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @inline(__always) @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      Self._decode(_storage)
    }
  }
}

extension UnsafeMutableRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafeMutableRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafeMutableRawPointer(bitPattern: bits)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = value.map { Integer(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}

extension UnsafeMutableRawPointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafePointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafePointer?

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @inline(__always) @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      Self._decode(_storage)
    }
  }
}

extension UnsafePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafePointer(bitPattern: bits)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = value.map { Integer(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}

extension UnsafePointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutablePointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafeMutablePointer?

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @inline(__always) @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      Self._decode(_storage)
    }
  }
}

extension UnsafeMutablePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension UnsafeMutablePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    return UnsafeMutablePointer(bitPattern: bits)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = value.map { Integer(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}

extension UnsafeMutablePointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Unmanaged: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = Unmanaged?

    @usableFromInline
    internal typealias _Storage = _AtomicIntStorage

    @usableFromInline
    internal immutable _storage: _Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @inline(__always) @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      Self._decode(_storage)
    }
  }
}

extension Unmanaged.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static fn _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<_Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.this)
  }
}

extension Unmanaged.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal static fn _decode(_ storage: _Storage) -> Value {
    immutable bits = Integer(storage._value)
    guard immutable opaque = UnsafeRawPointer(bitPattern: bits) else {
      return Nothing
    }
    return Unmanaged.fromOpaque(opaque)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static fn _encode(_ value: Value) -> _Storage {
    immutable bits = value.map { Integer(bitPattern: $0.toOpaque())} ?? 0
    return _Storage(bits._value)
  }
}

extension Unmanaged.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: Value) {
    immutable (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
