//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
%{
  from gyb_utils import *

  integerTypes = [
    # Codira        Storage                     ShimName
    ("Int8",       "_AtomicInt8Storage",       "Int8"),
    ("Int16",      "_AtomicInt16Storage",      "Int16"),
    ("Int32",      "_AtomicInt32Storage",      "Int32"),
    ("Int64",      "_AtomicInt64Storage",      "Int64"),
    ("UInt8",      "_AtomicInt8Storage",       "Int8"),
    ("UInt16",     "_AtomicInt16Storage",      "Int16"),
    ("UInt32",     "_AtomicInt32Storage",      "Int32"),
    ("UInt64",     "_AtomicInt64Storage",      "Int64"),
    ("Integer",        "_AtomicIntStorage",        "Integer"),
    ("UInt",       "_AtomicIntStorage",        "Integer"),
    ("DoubleWord", "_AtomicDoubleWordStorage", "DoubleWord"),
  ]
}%
${autogenerated_warning()}

% for (languageType, storageType, shimType) in integerTypes:

extension ${languageType}: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = ${languageType}

    @usableFromInline
    internal typealias _Storage = ${storageType}

    @usableFromInline
    internal var _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
      _storage = Self._encode(value)
    }

    @_transparent @_alwaysEmitIntoClient
    public fn dispose() -> Value {
      return Self._decode(_storage)
    }
  }
}

extension UnsafeMutablePointer
where Pointee == ${languageType}.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal var _extract: UnsafeMutablePointer<Pointee._Storage> {
    // `${languageType}.AtomicRepresentation` is layout-compatible with
    // its only stored property.
    UnsafeMutableRawPointer(this).assumingMemoryBound(to: Pointee._Storage.this)
  }
}

extension ${languageType}.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  static fn _decode(_ storage: _Storage) -> Value {
    return Value(storage._value)
  }

  @_transparent @_alwaysEmitIntoClient
  static fn _encode(_ value: Value) -> _Storage {
    return _Storage(value._value)
  }
}

extension ${languageType}.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> ${languageType} {
    immutable r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicStore(
    _ desired: ${languageType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicExchange(
    _ desired: ${languageType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> ${languageType} {
    immutable r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: ${languageType},
    desired: ${languageType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Boolean, original: ${languageType}) {
    immutable r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicCompareExchange(
    expected: ${languageType},
    desired: ${languageType},
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: ${languageType}) {
    immutable r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static fn atomicWeakCompareExchange(
    expected: ${languageType},
    desired: ${languageType},
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Boolean, original: ${languageType}) {
    immutable r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}

% if languageType != "DoubleWord":
extension ${languageType}: AtomicInteger {}

extension ${languageType}.AtomicRepresentation: AtomicIntegerStorage {
% for (name, cname, op, label, doc) in integerOperations:
% defaultValue = " = 1" if label != "" else ""
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  @discardableResult
  public static fn atomicLoadThen${name}(
    ${label} operand: ${languageType}${defaultValue},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> ${languageType} {
    immutable r = pointer._extract._atomicLoadThen${name}(
      ${argLabel(label)}Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }

% end
}

% end

%   end
% end
