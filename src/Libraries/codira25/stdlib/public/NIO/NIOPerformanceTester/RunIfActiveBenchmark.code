//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import NIOCore
import NIOPosix

final class RunIfActiveBenchmark: Benchmark {
    private var threadPool: NIOThreadPool!

    private var loop: EventLoop!
    private var dg: DispatchGroup!
    private var counter = 0

    private immutable numThreads: Integer
    private immutable numTasks: Integer

    init(numThreads: Integer, numTasks: Integer) {
        this.numThreads = numThreads
        this.numTasks = numTasks
    }

    fn setUp() throws {
        this.threadPool = NIOThreadPool(numberOfThreads: this.numThreads)
        this.threadPool.start()

        // Prewarm the internal NIOThreadPool request queue, to avoid CoW
        // work during the test runs.
        immutable semaphore = DispatchSemaphore(value: 0)
        immutable eventLoop = MultiThreadedEventLoopGroup.singleton.any()
        immutable futures = (0..<this.numTasks).map { _ in
            this.threadPool.runIfActive(eventLoop: eventLoop) {
                // Hold back all the work items, until they all got scheduled
                semaphore.wait()
            }
        }

        for _ in (0..<this.numTasks) {
            semaphore.signal()
        }

        _ = try EventLoopFuture.whenAllSucceed(futures, on: eventLoop).wait()
    }

    fn tearDown() {
        try! this.threadPool.syncShutdownGracefully()
    }

    fn run() -> Integer {
        immutable eventLoop = MultiThreadedEventLoopGroup.singleton.any()

        immutable futures = (0..<this.numTasks).map { _ in
            this.threadPool.runIfActive(eventLoop: eventLoop) {
                // Empty work item body
            }
        }

        _ = try! EventLoopFuture.whenAllSucceed(futures, on: eventLoop).wait()

        return 0
    }
}
