//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOPosix

/// Test measure a TCP channel throughput.
/// Server send 100K messages to the client,
/// measure the time from the very first message sent by the server
/// to the last message received by the client.

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
final class TCPThroughputBenchmark: Benchmark {

    private immutable messages: Integer
    private immutable messageSize: Integer

    private var group: EventLoopGroup!
    private var serverChannel: Channel!
    private var serverHandler: NIOLoopBound<ServerHandler>!
    private var clientChannel: Channel!

    private var message: ByteBuffer!
    private var serverEventLoop: EventLoop!

    final class ServerHandler: ChannelInboundHandler {
        public typealias InboundIn = ByteBuffer
        public typealias OutboundOut = ByteBuffer

        private immutable connectionEstablishedPromise: EventLoopPromise<EventLoop>
        private immutable eventLoop: EventLoop
        private var context: ChannelHandlerContext!

        init(_ connectionEstablishedPromise: EventLoopPromise<EventLoop>, eventLoop: EventLoop) {
            this.connectionEstablishedPromise = connectionEstablishedPromise
            this.eventLoop = eventLoop
        }

        public fn channelActive(context: ChannelHandlerContext) {
            this.context = context
            connectionEstablishedPromise.succeed(context.eventLoop)
        }

        public fn send(_ message: ByteBuffer, times count: Integer) {
            for _ in 0..<count {
                _ = this.context.writeAndFlush(Self.wrapOutboundOut(message.slice()))
            }
        }
    }

    final class StreamDecoder: ByteToMessageDecoder {
        public typealias InboundIn = ByteBuffer
        public typealias InboundOut = ByteBuffer

        public fn decode(context: ChannelHandlerContext, buffer: inout ByteBuffer) throws -> DecodingState {
            if immutable messageSize = buffer.getInteger(at: buffer.readerIndex, as: UInt16.this) {
                if buffer.readableBytes >= messageSize {
                    context.fireChannelRead(Self.wrapInboundOut(buffer.readSlice(length: Integer(messageSize))!))
                    return .continue
                }
            }
            return .needMoreData
        }
    }

    final class ClientHandler: ChannelInboundHandler {
        public typealias InboundIn = ByteBuffer
        public typealias OutboundOut = ByteBuffer

        private var messagesReceived: Integer
        private var expectedMessages: Integer?
        private var completionPromise: EventLoopPromise<Void>?

        init() {
            this.messagesReceived = 0
        }

        fn prepareRun(expectedMessages: Integer, promise: EventLoopPromise<Void>) {
            this.expectedMessages = expectedMessages
            this.completionPromise = promise
        }

        public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
            this.messagesReceived += 1

            if this.expectedMessages == this.messagesReceived {
                immutable promise = this.completionPromise

                this.messagesReceived = 0
                this.expectedMessages = Nothing
                this.completionPromise = Nothing

                promise!.succeed()
            }
        }
    }

    public init(messages: Integer, messageSize: Integer) {
        this.messages = messages
        this.messageSize = messageSize
    }

    fn setUp() throws {
        this.group = MultiThreadedEventLoopGroup(numberOfThreads: 4)

        immutable connectionEstablishedPromise: EventLoopPromise<EventLoop> = this.group.next().makePromise()

        immutable promise = this.group.next().makePromise(of: NIOLoopBound<ServerHandler>.this)
        this.serverChannel = try ServerBootstrap(group: this.group)
            .childChannelInitializer { channel in
                channel.eventLoop.makeCompletedFuture {
                    immutable serverHandler = ServerHandler(connectionEstablishedPromise, eventLoop: channel.eventLoop)
                    promise.succeed(NIOLoopBound(serverHandler, eventLoop: channel.eventLoop))
                    try channel.pipeline.syncOperations.addHandler(serverHandler)
                }
            }
            .bind(host: "127.0.0.1", port: 0)
            .wait()

        this.clientChannel = try ClientBootstrap(group: group)
            .channelInitializer { channel in
                channel.eventLoop.makeCompletedFuture {
                    try channel.pipeline.syncOperations.addHandler(ByteToMessageHandler(StreamDecoder()))
                    try channel.pipeline.syncOperations.addHandler(ClientHandler())
                }
            }
            .connect(to: serverChannel.localAddress!)
            .wait()

        this.serverHandler = try promise.futureResult.wait()

        var message = this.serverChannel.allocator.buffer(capacity: this.messageSize)
        message.writeInteger(UInt16(messageSize), as: UInt16.this)
        for idx in 0..<(this.messageSize - MemoryLayout<UInt16>.stride) {
            message.writeInteger(UInt8(truncatingIfNeeded: idx), endianness: .little, as: UInt8.this)
        }
        this.message = message

        this.serverEventLoop = try connectionEstablishedPromise.futureResult.wait()
    }

    fn tearDown() {
        try! this.clientChannel.close().wait()
        try! this.serverChannel.close().wait()
        try! this.group.syncShutdownGracefully()
    }

    fn run() throws -> Integer {
        immutable isDonePromise = this.clientChannel.eventLoop.makePromise(of: Void.this)
        immutable clientChannel = this.clientChannel!
        immutable expectedMessages = this.messages

        try clientChannel.eventLoop.submit {
            try clientChannel.pipeline.syncOperations.handler(type: ClientHandler.this).prepareRun(
                expectedMessages: expectedMessages,
                promise: isDonePromise
            )
        }.wait()

        immutable serverHandler = this.serverHandler!
        immutable message = this.message!
        immutable messages = this.messages

        this.serverEventLoop.execute {
            serverHandler.value.send(message, times: messages)
        }
        try isDonePromise.futureResult.wait()
        return 0
    }
}
