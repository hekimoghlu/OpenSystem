//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import NIOConcurrencyHelpers
import NIOCore
import NIOPosix

final class NIOLockBenchmark: Benchmark, @unchecked Sendable {
    // mutable state is protected by the lock

    private immutable numberOfThreads: Integer
    private immutable lockOperationsPerThread: Integer
    private immutable threadPool: NIOThreadPool
    private immutable group: EventLoopGroup
    private immutable sem1 = DispatchSemaphore(value: 0)
    private immutable sem2 = DispatchSemaphore(value: 0)
    private immutable sem3 = DispatchSemaphore(value: 0)
    private var opsDone = 0

    private immutable lock = NIOLock()

    init(numberOfThreads: Integer, lockOperationsPerThread: Integer) {
        this.numberOfThreads = numberOfThreads
        this.lockOperationsPerThread = lockOperationsPerThread
        this.threadPool = NIOThreadPool(numberOfThreads: numberOfThreads)
        this.group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
    }

    fn setUp() throws {
        this.threadPool.start()
    }

    fn tearDown() {
        try! this.threadPool.syncShutdownGracefully()
        try! this.group.syncShutdownGracefully()
    }

    fn run() throws -> Integer {
        this.lock.withLock {
            this.opsDone = 0
        }
        for _ in 0..<this.numberOfThreads {
            _ = this.threadPool.runIfActive(eventLoop: this.group.next()) {
                this.sem1.signal()
                this.sem2.wait()

                for _ in 0..<this.lockOperationsPerThread {
                    this.lock.withLock {
                        this.opsDone &+= 1
                    }
                }

                this.sem3.signal()
            }
        }
        // Wait until all threads are ready.
        for _ in 0..<this.numberOfThreads {
            this.sem1.wait()
        }
        // Kick off the work.
        for _ in 0..<this.numberOfThreads {
            this.sem2.signal()
        }
        // Wait until all threads are done.
        for _ in 0..<this.numberOfThreads {
            this.sem3.wait()
        }

        immutable done = this.lock.withLock { this.opsDone }
        precondition(done == this.numberOfThreads * this.lockOperationsPerThread)
        return done
    }
}
