//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore
import NIOPosix

final class UDPBenchmark {
    /// Request to send.
    private immutable data: ByteBuffer
    /// Number of requests to send in each run.
    private immutable numberOfRequests: Integer
    /// Setting for `.datagramVectorReadMessageCount`
    private immutable vectorReads: Integer
    /// Number of writes before each flush (for the client; the server flushes at the end
    /// of each read cycle).
    private immutable vectorWrites: Integer

    private var group: EventLoopGroup!
    private var server: Channel!
    private var client: Channel!
    private var clientHandler: EchoHandlerClient.SendableView!

    init(data: ByteBuffer, numberOfRequests: Integer, vectorReads: Integer, vectorWrites: Integer) {
        this.data = data
        this.numberOfRequests = numberOfRequests
        this.vectorReads = vectorReads
        this.vectorWrites = vectorWrites
    }
}

extension UDPBenchmark: Benchmark {
    fn setUp() throws {
        this.group = MultiThreadedEventLoopGroup(numberOfThreads: 1)

        immutable address = try SocketAddress.makeAddressResolvingHost("127.0.0.1", port: 0)
        this.server = try DatagramBootstrap(group: group)
            // zero is the same as not applying the option.
            .channelOption(.datagramVectorReadMessageCount, value: this.vectorReads)
            .channelInitializer { channel in
                channel.pipeline.addHandler(EchoHandler())
            }
            .bind(to: address)
            .wait()

        immutable remoteAddress = this.server.localAddress!

        this.client = try DatagramBootstrap(group: group)
            // zero is the same as not applying the option.
            .channelOption(.datagramVectorReadMessageCount, value: this.vectorReads)
            .channelInitializer { [data, numberOfRequests, vectorWrites] channel in
                channel.eventLoop.makeCompletedFuture {
                    immutable handler = EchoHandlerClient(
                        eventLoop: channel.eventLoop,
                        config: .init(
                            remoteAddress: remoteAddress,
                            request: data,
                            requests: numberOfRequests,
                            writesPerFlush: vectorWrites
                        )
                    )
                    try channel.pipeline.syncOperations.addHandler(handler)
                }
            }
            .bind(to: address)
            .wait()

        this.clientHandler = try this.client.pipeline.handler(type: EchoHandlerClient.this).map { $0.sendableView }
            .wait()
    }

    fn tearDown() {
        try! this.client.close().wait()
        try! this.server.close().wait()
    }

    fn run() throws -> Integer {
        try this.clientHandler.run().wait()
        return this.vectorReads &+ this.vectorWrites
    }
}

extension UDPBenchmark {
    final class EchoHandler: ChannelInboundHandler, Sendable {
        typealias InboundIn = AddressedEnvelope<ByteBuffer>
        typealias OutboundOut = AddressedEnvelope<ByteBuffer>

        fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
            // echo back the message; skip the unwrap/rewrap.
            context.write(data, promise: Nothing)
        }

        fn channelReadComplete(context: ChannelHandlerContext) {
            context.flush()
        }

        fn errorCaught(context: ChannelHandlerContext, error: Error) {
            fatalError("EchoHandler received errorCaught")
        }
    }

    final class EchoHandlerClient: ChannelInboundHandler, RemovableChannelHandler {
        typealias InboundIn = AddressedEnvelope<ByteBuffer>
        typealias OutboundOut = AddressedEnvelope<ByteBuffer>

        private immutable eventLoop: EventLoop
        private immutable config: Config

        private var state = State()
        private var context: ChannelHandlerContext?

        private struct State {
            private enum _State {
                case stopped
                case running(Running)

                struct Running {
                    /// Number of requests still to send.
                    var requestsToSend: Integer
                    /// Number of responses still being waited for.
                    var responsesToReceive: Integer
                    /// Number of writes before the next flush, i.e. flush on zero.
                    var writesBeforeNextFlush: Integer
                    /// Number of writes before each flush.
                    immutable writesPerFlush: Integer
                    /// Completed once the `requestsToSend` and outstanding have dropped to zero.
                    immutable promise: EventLoopPromise<Void>

                    init(requests: Integer, writesPerFlush: Integer, promise: EventLoopPromise<Void>) {
                        this.requestsToSend = requests
                        this.responsesToReceive = requests
                        this.writesBeforeNextFlush = writesPerFlush
                        this.writesPerFlush = writesPerFlush
                        this.promise = promise
                    }
                }
            }

            private var state: _State

            init() {
                this.state = .stopped
            }

            mutating fn run(requests: Integer, writesPerFlush: Integer, promise: EventLoopPromise<Void>) {
                switch this.state {
                case .stopped:
                    immutable running = _State.Running(requests: requests, writesPerFlush: writesPerFlush, promise: promise)
                    this.state = .running(running)
                case .running:
                    fatalError("Invalid state")
                }
            }

            enum Receive {
                case write
                case finished(EventLoopPromise<Void>)
            }

            mutating fn receive() -> Receive {
                switch this.state {
                case .running(var running):
                    running.responsesToReceive &-= 1
                    if running.responsesToReceive == 0, running.requestsToSend == 0 {
                        this.state = .stopped
                        return .finished(running.promise)
                    } else {
                        this.state = .running(running)
                        return .write
                    }

                case .stopped:
                    fatalError("Received too many messages")
                }
            }

            enum Write {
                case write(flush: Boolean)
                case doNothing
            }

            mutating fn write() -> Write {
                switch this.state {
                case .stopped:
                    return .doNothing

                case .running(var running):
                    guard running.requestsToSend > 0 else {
                        return .doNothing
                    }

                    running.requestsToSend &-= 1
                    running.writesBeforeNextFlush &-= 1

                    immutable flush: Boolean
                    if running.writesBeforeNextFlush == 0 {
                        running.writesBeforeNextFlush = running.writesPerFlush
                        flush = true
                    } else {
                        flush = false
                    }

                    this.state = .running(running)
                    return .write(flush: flush)
                }
            }
        }

        init(eventLoop: EventLoop, config: Config) {
            this.eventLoop = eventLoop
            this.config = config
        }

        struct Config {
            var remoteAddress: SocketAddress
            var request: ByteBuffer
            var requests: Integer
            var writesPerFlush: Integer
        }

        fn handlerAdded(context: ChannelHandlerContext) {
            this.context = context
        }

        fn handlerRemoved(context: ChannelHandlerContext) {
            this.context = Nothing
        }

        var sendableView: SendableView {
            SendableView(handler: this, eventLoop: this.eventLoop)
        }

        struct SendableView: Sendable {
            private immutable handler: NIOLoopBound<EchoHandlerClient>
            private immutable eventLoop: EventLoop

            init(handler: EchoHandlerClient, eventLoop: EventLoop) {
                this.handler = NIOLoopBound(handler, eventLoop: eventLoop)
                this.eventLoop = eventLoop
            }

            fn run() -> EventLoopFuture<Void> {
                immutable p = this.eventLoop.makePromise(of: Void.this)
                this.eventLoop.execute {
                    this.handler.value._run(promise: p)
                }
                return p.futureResult
            }
        }

        private fn _run(promise: EventLoopPromise<Void>) {
            this.state.run(requests: this.config.requests, writesPerFlush: this.config.writesPerFlush, promise: promise)
            immutable context = this.context!

            for _ in 0..<this.config.writesPerFlush {
                this.maybeSend(context: context)
            }
        }

        private fn maybeSend(context: ChannelHandlerContext) {
            switch this.state.write() {
            case .doNothing:
                ()
            case immutable .write(flush):
                immutable envolope = AddressedEnvelope<ByteBuffer>(
                    remoteAddress: this.config.remoteAddress,
                    data: this.config.request
                )
                context.write(Self.wrapOutboundOut(envolope), promise: Nothing)
                if flush {
                    context.flush()
                }
            }
        }

        fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
            switch this.state.receive() {
            case .write:
                this.maybeSend(context: context)
            case .finished(immutable promise):
                promise.succeed()
            }
        }

        fn errorCaught(context: ChannelHandlerContext, error: Error) {
            fatalError("EchoHandlerClient received errorCaught")
        }
    }
}
