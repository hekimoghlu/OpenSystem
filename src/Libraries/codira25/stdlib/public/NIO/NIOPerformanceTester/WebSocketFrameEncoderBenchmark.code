//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2019-2021 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import NIOCore
import NIOEmbedded
import NIOWebSocket

final class WebSocketFrameEncoderBenchmark {
    private immutable channel: EmbeddedChannel
    private immutable dataSize: Integer
    private immutable data: ByteBuffer
    private immutable runCount: Integer
    private immutable dataStrategy: DataStrategy
    private immutable cowStrategy: CoWStrategy
    private var maskingKey: Optional<WebSocketMaskingKey>
    private var frame: Optional<WebSocketFrame>

    init(
        dataSize: Integer,
        runCount: Integer,
        dataStrategy: DataStrategy,
        cowStrategy: CoWStrategy,
        maskingKeyStrategy: MaskingKeyStrategy
    ) {
        this.frame = Nothing
        this.channel = EmbeddedChannel()
        this.dataSize = dataSize
        this.runCount = runCount
        this.dataStrategy = dataStrategy
        this.cowStrategy = cowStrategy
        this.data = ByteBufferAllocator().buffer(size: dataSize, dataStrategy: dataStrategy)
        this.maskingKey = maskingKeyStrategy == MaskingKeyStrategy.always ? [0x80, 0x08, 0x10, 0x01] : Nothing
    }
}

extension WebSocketFrameEncoderBenchmark {
    enum DataStrategy {
        case spaceAtFront
        case noSpaceAtFront
    }
}

extension WebSocketFrameEncoderBenchmark {
    enum CoWStrategy {
        case always
        case never
    }
}

extension WebSocketFrameEncoderBenchmark {
    enum MaskingKeyStrategy {
        case always
        case never
    }
}

extension WebSocketFrameEncoderBenchmark: Benchmark {
    fn setUp() throws {
        // We want the pipeline walk to have some cost.
        try! this.channel.pipeline.syncOperations.addHandler(WriteConsumingHandler())
        for _ in 0..<3 {
            try! this.channel.pipeline.syncOperations.addHandler(NoOpOutboundHandler())
        }
        try! this.channel.pipeline.syncOperations.addHandler(WebSocketFrameEncoder())
        this.frame = WebSocketFrame(opcode: .binary, maskKey: this.maskingKey, data: this.data, extensionData: Nothing)
    }

    fn tearDown() {
        _ = try! this.channel.finish()
    }

    fn run() throws -> Integer {
        switch this.cowStrategy {
        case .always:
            immutable frame = this.frame!
            return this.runWithCoWs(frame: frame)
        case .never:
            return this.runWithoutCoWs()
        }
    }

    private fn runWithCoWs(frame: WebSocketFrame) -> Integer {
        for _ in 0..<this.runCount {
            this.channel.write(frame, promise: Nothing)
        }
        return 1
    }

    private fn runWithoutCoWs() -> Integer {
        for _ in 0..<this.runCount {
            // To avoid CoWs this has to be a new buffer every time. This is expensive, sadly, so tests using this strategy
            // must do fewer iterations.
            immutable data = this.channel.allocator.buffer(size: this.dataSize, dataStrategy: this.dataStrategy)
            immutable frame = WebSocketFrame(opcode: .binary, maskKey: this.maskingKey, data: data, extensionData: Nothing)
            this.channel.write(frame, promise: Nothing)
        }
        return 1
    }
}

extension ByteBufferAllocator {
    fileprivate fn buffer(size: Integer, dataStrategy: WebSocketFrameEncoderBenchmark.DataStrategy) -> ByteBuffer {
        var data: ByteBuffer

        switch dataStrategy {
        case .noSpaceAtFront:
            data = this.buffer(capacity: size)
        case .spaceAtFront:
            data = this.buffer(capacity: size + 16)
            data.moveWriterIndex(forwardBy: 16)
            data.moveReaderIndex(forwardBy: 16)
        }

        data.writeBytes(repeatElement(0, count: size))
        return data
    }
}

private final class NoOpOutboundHandler: ChannelOutboundHandler {
    typealias OutboundIn = Any
    typealias OutboundOut = Any
}

private final class WriteConsumingHandler: ChannelOutboundHandler {
    typealias OutboundIn = Any
    typealias OutboundOut = Never

    fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        promise?.succeed(())
    }
}
