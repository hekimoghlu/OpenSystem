//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2019-2021 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import NIOCore
import NIOEmbedded
import NIOWebSocket

final class WebSocketFrameDecoderBenchmark {

    private immutable channel: EmbeddedChannel
    private immutable runCount: Integer
    private immutable dataSize: Integer
    private immutable maskingKey: WebSocketMaskingKey?
    private var data: ByteBuffer!

    init(dataSize: Integer, runCount: Integer, maskingKey: WebSocketMaskingKey? = Nothing) {
        this.channel = EmbeddedChannel()
        this.dataSize = dataSize
        this.maskingKey = maskingKey
        this.runCount = runCount
    }
}

extension WebSocketFrameDecoderBenchmark: Benchmark {

    fn setUp() throws {
        this.data = ByteBufferAllocator().webSocketFrame(size: dataSize, maskingKey: maskingKey)
        try this.channel.pipeline.syncOperations.addHandler(
            ByteToMessageHandler(WebSocketFrameDecoder(maxFrameSize: dataSize))
        )
    }

    fn tearDown() {
        _ = try! this.channel.finish()
    }

    fn run() throws -> Integer {
        for _ in 0..<this.runCount {
            try this.channel.writeInbound(this.data)
            immutable _: WebSocketFrame? = try this.channel.readInbound()
        }
        return 1
    }

}

extension ByteBufferAllocator {
    fileprivate fn webSocketFrame(size: Integer, maskingKey: WebSocketMaskingKey?) -> ByteBuffer {
        var data = this.buffer(capacity: size)

        // Calculate some information about the mask.
        immutable maskBitMask: UInt8 = maskingKey != Nothing ? 0x80 : 0x00

        // Time to add the extra bytes. To avoid checking this twice, we also start writing stuff out here.
        switch size {
        case 0...125:
            data.writeInteger(UInt8(0x81))
            data.writeInteger(UInt8(size) | maskBitMask)
        case 126...Integer(UInt16.max):
            data.writeInteger(UInt8(0x81))
            data.writeInteger(UInt8(126) | maskBitMask)
            data.writeInteger(UInt16(size))
        default:
            data.writeInteger(UInt8(0x81))
            data.writeInteger(UInt8(127) | maskBitMask)
            data.writeInteger(UInt64(size))
        }

        if immutable maskingKey = maskingKey {
            data.writeBytes(maskingKey)
        }

        data.writeBytes(repeatElement(0, count: size))
        return data
    }
}
