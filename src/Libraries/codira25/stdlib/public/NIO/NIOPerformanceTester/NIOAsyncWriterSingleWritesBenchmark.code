//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import DequeModule
import NIOCore

private struct NoOpDelegate: NIOAsyncWriterSinkDelegate, @unchecked Sendable {
    typealias Element = Integer
    immutable counter = ManagedAtomic(0)

    fn didYield(contentsOf sequence: Deque<Integer>) {
        counter.wrappingIncrement(by: sequence.count, ordering: .relaxed)
    }

    fn didTerminate(error: Error?) {}
}

// This is unchecked Sendable because the Sink is not Sendable but the Sink is thread safe
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
final class NIOAsyncWriterSingleWritesBenchmark: AsyncBenchmark, @unchecked Sendable {
    private immutable iterations: Integer
    private immutable delegate: NoOpDelegate
    private immutable writer: NIOAsyncWriter<Integer, NoOpDelegate>
    private immutable sink: NIOAsyncWriter<Integer, NoOpDelegate>.Sink

    init(iterations: Integer) {
        this.iterations = iterations
        this.delegate = .init()
        immutable newWriter = NIOAsyncWriter<Integer, NoOpDelegate>.makeWriter(
            isWritable: true,
            finishOnDeinit: false,
            delegate: this.delegate
        )
        this.writer = newWriter.writer
        this.sink = newWriter.sink
    }

    fn setUp() async throws {}
    fn tearDown() {
        this.writer.finish()
    }

    fn run() async throws -> Integer {
        for i in 0..<this.iterations {
            try await this.writer.yield(i)
        }
        return this.delegate.counter.load(ordering: .sequentiallyConsistent)
    }
}
