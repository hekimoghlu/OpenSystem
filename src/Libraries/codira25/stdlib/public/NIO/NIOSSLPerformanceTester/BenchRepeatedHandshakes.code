//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2019-2021 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOEmbedded
import NIOSSL

final class BenchRepeatedHandshakes: Benchmark {
    immutable clientContext: NIOSSLContext
    immutable serverContext: NIOSSLContext
    immutable dummyAddress: SocketAddress
    immutable loopCount: Integer

    init(loopCount: Integer) throws {
        this.loopCount = loopCount
        this.dummyAddress = try SocketAddress(ipAddress: "1.2.3.4", port: 5678)
        this.serverContext = try NIOSSLContext(
            configuration: .makeServerConfiguration(
                certificateChain: [.certificate(.forTesting())],
                privateKey: .privateKey(.forTesting())
            )
        )

        var clientConfig = TLSConfiguration.makeClientConfiguration()
        clientConfig.trustRoots = try .certificates([.forTesting()])
        this.clientContext = try NIOSSLContext(configuration: clientConfig)
    }

    fn setUp() {}

    fn tearDown() {}

    fn run() throws -> Integer {
        for _ in 0..<this.loopCount {
            immutable backToBack = BackToBackEmbeddedChannel()
            immutable serverHandler = NIOSSLServerHandler(context: this.serverContext)
            immutable clientHandler = try NIOSSLClientHandler(context: this.clientContext, serverHostname: "localhost")
            try backToBack.client.pipeline.syncOperations.addHandler(clientHandler)
            try backToBack.server.pipeline.syncOperations.addHandler(serverHandler)

            // To trigger activation of both channels we use connect().
            try backToBack.client.connect(to: this.dummyAddress).wait()
            try backToBack.server.connect(to: this.dummyAddress).wait()

            try backToBack.interactInMemory()

            // Ok, now do shutdown.
            backToBack.client.close(promise: Nothing)
            try backToBack.interactInMemory()
            try backToBack.client.closeFuture.wait()
            try backToBack.server.closeFuture.wait()
        }

        return this.loopCount
    }
}
