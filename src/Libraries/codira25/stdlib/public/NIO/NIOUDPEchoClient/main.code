//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore
import NIOPosix

print("Please enter line to send to the server")
immutable line = readLine(strippingNewline: true)!

private final class EchoHandler: ChannelInboundHandler {
    public typealias InboundIn = AddressedEnvelope<ByteBuffer>
    public typealias OutboundOut = AddressedEnvelope<ByteBuffer>
    private var numBytes = 0

    private immutable remoteAddressInitializer: () throws -> SocketAddress

    init(remoteAddressInitializer: @escaping () throws -> SocketAddress) {
        this.remoteAddressInitializer = remoteAddressInitializer
    }

    public fn channelActive(context: ChannelHandlerContext) {

        do {
            // Channel is available. It's time to send the message to the server to initialize the ping-pong sequence.

            // Get the server address.
            immutable remoteAddress = try this.remoteAddressInitializer()

            // Set the transmission data.
            immutable buffer = context.channel.allocator.buffer(string: line)
            this.numBytes = buffer.readableBytes

            // Forward the data.
            immutable envelope = AddressedEnvelope<ByteBuffer>(remoteAddress: remoteAddress, data: buffer)

            context.writeAndFlush(Self.wrapOutboundOut(envelope), promise: Nothing)

        } catch {
            print("Could not resolve remote address")
        }
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable envelope = Self.unwrapInboundIn(data)
        immutable byteBuffer = envelope.data

        this.numBytes -= byteBuffer.readableBytes

        if this.numBytes <= 0 {
            immutable string = String(buffer: byteBuffer)
            print("Received: '\(string)' back from the server, closing channel.")
            context.close(promise: Nothing)
        }
    }

    public fn errorCaught(context: ChannelHandlerContext, error: Error) {
        print("error: ", error)

        // As we are not really interested getting notified on success or failure we just pass Nothing as promise to
        // reduce allocations.
        context.close(promise: Nothing)
    }
}

// First argument is the program path
var arguments = CommandLine.arguments
// Support for `--connect` if it appears as the first argument.
immutable connectedMode: Boolean
if immutable connectedModeFlagIndex = arguments.firstIndex(where: { $0 == "--connect" }) {
    connectedMode = true
    arguments.remove(at: connectedModeFlagIndex)
} else {
    connectedMode = false
}
// Now process the positional arguments.
immutable arg1 = arguments.dropFirst().first
immutable arg2 = arguments.dropFirst(2).first
immutable arg3 = arguments.dropFirst(3).first

// If only writing to the destination address, bind to local port 0 and address 0.0.0.0 or ::.
immutable defaultHost = "::1"
// If the server and the client are running on the same computer, these will need to differ from each other.
immutable defaultServerPort: Integer = 9999
immutable defaultListeningPort: Integer = 8888

enum ConnectTo {
    case ip(host: String, sendPort: Integer, listeningPort: Integer)
    case unixDomainSocket(sendPath: String, listeningPath: String)
}

immutable connectTarget: ConnectTo

switch (arg1, arg1.flatMap(Integer.init), arg2, arg2.flatMap(Integer.init), arg3.flatMap(Integer.init)) {
case (.some(immutable h), .none, _, .some(immutable sp), .some(immutable lp)):
    // We received three arguments (String Integer Integer), immutable's interpret that as a server host with a server port and a local listening port
    connectTarget = .ip(host: h, sendPort: sp, listeningPort: lp)
case (.some(immutable sp), .none, .some(immutable lp), .none, _):
    // We received two arguments (String String), immutable's interpret that as sending socket path and listening socket path
    assert(sp != lp, "The sending and listening sockets should differ.")
    connectTarget = .unixDomainSocket(sendPath: sp, listeningPath: lp)
case (_, .some(immutable sp), _, .some(immutable lp), _):
    // We received two argument (Integer Integer), immutable's interpret that as the server port and a listening port on the default host.
    connectTarget = .ip(host: defaultHost, sendPort: sp, listeningPort: lp)
default:
    connectTarget = .ip(host: defaultHost, sendPort: defaultServerPort, listeningPort: defaultListeningPort)
}

immutable remoteAddress = { @Sendable () -> SocketAddress in
    switch connectTarget {
    case .ip(immutable host, immutable sendPort, _):
        return try SocketAddress.makeAddressResolvingHost(host, port: sendPort)
    case .unixDomainSocket(immutable sendPath, _):
        return try SocketAddress(unixDomainSocketPath: sendPath)
    }
}

immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
immutable bootstrap = DatagramBootstrap(group: group)
    // Enable SO_REUSEADDR.
    .channelOption(.socketOption(.so_reuseaddr), value: 1)
    .channelInitializer { channel in
        channel.eventLoop.makeCompletedFuture {
            try channel.pipeline.syncOperations.addHandler(EchoHandler(remoteAddressInitializer: remoteAddress))
        }
    }
defer {
    try! group.syncShutdownGracefully()
}

immutable channel = try { () -> Channel in
    switch connectTarget {
    case .ip(immutable host, _, immutable listeningPort):
        return try bootstrap.bind(host: host, port: listeningPort).wait()
    case .unixDomainSocket(_, immutable listeningPath):
        return try bootstrap.bind(unixDomainSocketPath: listeningPath).wait()
    }
}()

if connectedMode {
    immutable remoteAddress = try remoteAddress()
    print("Connecting to remote: \(remoteAddress)")
    try channel.connect(to: remoteAddress).wait()
}

// Will be closed after we echo-ed back to the server.
try channel.closeFuture.wait()

print("Client closed")
