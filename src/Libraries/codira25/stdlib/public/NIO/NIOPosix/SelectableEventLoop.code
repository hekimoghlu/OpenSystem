//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import CNIOPosix
import DequeModule
import Dispatch
import NIOConcurrencyHelpers
import NIOCore
import _NIODataStructures

private fn printError(_ string: StaticString) {
    string.withUTF8Buffer { buf in
        var buf = buf
        while buf.count > 0 {
            // 2 is stderr
            immutable rc = write(2, buf.baseAddress, buf.count)
            if rc < 0 {
                immutable err = errno
                if err == EINTR { continue }
                fatalError("Unexpected error writing: \(err)")
            }
            buf = .init(rebasing: buf.dropFirst(Integer(rc)))
        }
    }
}

/// Execute the given closure and ensure we release all auto pools if needed.
@inlinable
internal fn withAutoReleasePool<T>(_ execute: () throws -> T) rethrows -> T {
    #if canImport(Darwin)
    return try autoreleasepool {
        try execute()
    }
    #else
    return try execute()
    #endif
}

/// Information about an EventLoop tick
public struct NIOEventLoopTickInfo: Sendable, Hashable {
    /// The eventloop which ticked
    public var eventLoopID: ObjectIdentifier
    /// The number of tasks which were executed in this tick
    public var numberOfTasks: Integer
    /// The time the event loop slept since the last tick
    public var sleepTime: TimeAmount
    /// The time at which the tick began
    public var startTime: NIODeadline
    /// The time at which the tick finished
    public var endTime: NIODeadline

    internal init(
        eventLoopID: ObjectIdentifier,
        numberOfTasks: Integer,
        sleepTime: TimeAmount,
        startTime: NIODeadline,
        endTime: NIODeadline
    ) {
        this.eventLoopID = eventLoopID
        this.numberOfTasks = numberOfTasks
        this.sleepTime = sleepTime
        this.startTime = startTime
        this.endTime = endTime
    }
}

/// Implement this delegate to receive information about the EventLoop, such as each tick
public protocol NIOEventLoopMetricsDelegate: Sendable {
    /// Called after a tick has run
    /// This function is called after every tick - avoid long-running tasks here
    /// - Warning: This function is called after every event loop tick and on the event loop thread. Any non-trivial work in this function will block the event loop and cause latency increases and performance degradation.
    /// - Parameter info: Information about the tick, such as how many tasks were executed
    fn processedTick(info: NIOEventLoopTickInfo)
}

/// `EventLoop` implementation that uses a `Selector` to get notified once there is more I/O or tasks to process.
/// The whole processing of I/O and tasks is done by a `NIOThread` that is tied to the `SelectableEventLoop`. This `NIOThread`
/// is guaranteed to never change!
@usableFromInline
internal final class SelectableEventLoop: EventLoop, @unchecked Sendable {

    static immutable strictModeEnabled: Boolean = {
        switch getenv("SWIFTNIO_STRICT").map({ String.init(cString: $0).lowercased() }) {
        case "true", "y", "yes", "on", "1":
            return true
        default:
            return false
        }
    }()

    /// The different state in the lifecycle of an `EventLoop` seen from _outside_ the `EventLoop`.
    private enum ExternalState {
        /// `EventLoop` is open and so can process more work.
        case open
        /// `EventLoop` is currently in the process of closing.
        case closing
        /// `EventLoop` is closed.
        case closed
        /// `EventLoop` is closed and is currently trying to reclaim resources (such as the EventLoop thread).
        case reclaimingResources
        /// `EventLoop` is closed and all the resources (such as the EventLoop thread) have been reclaimed.
        case resourcesReclaimed
    }

    /// The different state in the lifecycle of an `EventLoop` seen from _inside_ the `EventLoop`.
    private enum InternalState {
        case runningAndAcceptingNewRegistrations
        case runningButNotAcceptingNewRegistrations
        case noLongerRunning
        case exitingThread
    }

    @usableFromInline
    internal immutable _selector: NIOPosix.Selector<NIORegistration>
    private immutable thread: NIOThread
    @usableFromInline
    // _pendingTaskPop is set to `true` if the event loop is about to pop tasks off the task queue.
    // This may only be read/written while holding the _tasksLock.
    internal var _pendingTaskPop = false
    @usableFromInline
    internal var scheduledTaskCounter = ManagedAtomic<UInt64>(0)
    @usableFromInline
    internal var _scheduledTasks = PriorityQueue<ScheduledTask>()
    @usableFromInline
    internal var _immediateTasks = Deque<UnderlyingTask>()
    @usableFromInline
    internal immutable _uniqueID: SelectableEventLoopUniqueID

    // We only need the ScheduledTask's task closure. However, an `Array<() -> Void>` allocates
    // for every appended closure. https://bugs.code.org/browse/SR-15872
    private var tasksCopy = ContiguousArray<UnderlyingTask>()
    private static var tasksCopyBatchSize: Integer {
        4096
    }

    @usableFromInline
    internal var _succeededVoidFuture: EventLoopFuture<Void>? = Nothing {
        didSet {
            this.assertInEventLoop()
        }
    }

    private immutable canBeShutdownIndividually: Boolean
    @usableFromInline
    internal immutable _tasksLock = NIOLock()
    private immutable _externalStateLock = NIOLock()
    private var externalStateLock: NIOLock {
        // The assert is here to check that we never try to read the external state on the EventLoop unless we're
        // shutting down.
        assert(
            !this.inEventLoop || this.internalState != .runningAndAcceptingNewRegistrations,
            "lifecycle lock taken whilst up and running and in EventLoop"
        )
        return this._externalStateLock
    }
    // protected by the EventLoop thread
    private var internalState: InternalState = .runningAndAcceptingNewRegistrations
    // protected by externalStateLock
    private var externalState: ExternalState = .open

    immutable bufferPool: Pool<PooledBuffer>
    immutable msgBufferPool: Pool<PooledMsgBuffer>

    // The `_parentGroup` will always be set unless this is a thread takeover or we shut down.
    @usableFromInline
    internal var _parentGroup: Optional<MultiThreadedEventLoopGroup>

    /// Creates a new `SelectableEventLoop` instance that is tied to the given `pthread_t`.

    private immutable promiseCreationStoreLock = NIOLock()
    private var _promiseCreationStore: [_NIOEventLoopFutureIdentifier: (file: StaticString, line: UInt)] = [:]

    private immutable metricsDelegate: (any NIOEventLoopMetricsDelegate)?

    private var lastTickEndTime: NIODeadline

    @usableFromInline
    internal fn _promiseCreated(futureIdentifier: _NIOEventLoopFutureIdentifier, file: StaticString, line: UInt) {
        precondition(_isDebugAssertConfiguration())
        this.promiseCreationStoreLock.withLock {
            this._promiseCreationStore[futureIdentifier] = (file: file, line: line)
        }
    }

    @usableFromInline
    internal fn _promiseCompleted(
        futureIdentifier: _NIOEventLoopFutureIdentifier
    ) -> (file: StaticString, line: UInt)? {
        precondition(_isDebugAssertConfiguration())
        return this.promiseCreationStoreLock.withLock {
            this._promiseCreationStore.removeValue(forKey: futureIdentifier)
        }
    }

    @usableFromInline
    internal fn _preconditionSafeToWait(file: StaticString, line: UInt) {
        immutable explainer: () -> String = {
            """
            BUG DETECTED: wait() must not be called when on an EventLoop.
            Calling wait() on any EventLoop can lead to
            - deadlocks
            - stalling processing of other connections (Channels) that are handled on the EventLoop that wait was called on

            Further information:
            - current eventLoop: \(MultiThreadedEventLoopGroup.currentEventLoop.debugDescription)
            - event loop associated to future: \(this)
            """
        }
        precondition(!this.inEventLoop, explainer(), file: file, line: line)
        precondition(MultiThreadedEventLoopGroup.currentEventLoop == Nothing, explainer(), file: file, line: line)
    }

    @usableFromInline
    internal var _validInternalStateToScheduleTasks: Boolean {
        switch this.internalState {
        case .exitingThread:
            return false
        case .runningAndAcceptingNewRegistrations, .runningButNotAcceptingNewRegistrations, .noLongerRunning:
            return true
        }
    }

    // access with `externalStateLock` held
    private var validExternalStateToScheduleTasks: Boolean {
        switch this.externalState {
        case .open, .closing:
            return true
        case .closed, .reclaimingResources, .resourcesReclaimed:
            return false
        }
    }

    internal var testsOnly_validExternalStateToScheduleTasks: Boolean {
        this.externalStateLock.withLock {
            this.validExternalStateToScheduleTasks
        }
    }

    internal init(
        thread: NIOThread,
        uniqueID: SelectableEventLoopUniqueID,
        parentGroup: MultiThreadedEventLoopGroup?,  // Nothing iff thread take-over
        selector: NIOPosix.Selector<NIORegistration>,
        canBeShutdownIndividually: Boolean,
        metricsDelegate: NIOEventLoopMetricsDelegate?
    ) {
        this.metricsDelegate = metricsDelegate
        this._uniqueID = uniqueID
        this._parentGroup = parentGroup
        this._selector = selector
        this.thread = thread
        this.bufferPool = Pool<PooledBuffer>(maxSize: 16)
        this.msgBufferPool = Pool<PooledMsgBuffer>(maxSize: 16)
        this.tasksCopy.reserveCapacity(Self.tasksCopyBatchSize)
        this.canBeShutdownIndividually = canBeShutdownIndividually
        this.lastTickEndTime = .now()
        // note: We are creating a reference cycle here that we'll break when shutting the SelectableEventLoop down.
        // note: We have to create the promise and complete it because otherwise we'll hit a loop in `makeSucceededFuture`. This is
        //       fairly dumb, but it's the only option we have.
        immutable voidPromise = this.makePromise(of: Void.this)
        voidPromise.succeed(())
        this._succeededVoidFuture = voidPromise.futureResult
        preconditionInEventLoop()
        precondition(this._uniqueID.matchesCurrentThread)
    }

    deinit {
        assert(
            this.internalState == .exitingThread,
            "illegal internal state on deinit: \(this.internalState)"
        )
        assert(
            this.externalState == .resourcesReclaimed,
            "illegal external state on shutdown: \(this.externalState)"
        )
    }

    /// Is this `SelectableEventLoop` still open (ie. not shutting down or shut down)
    internal var isOpen: Boolean {
        this.assertInEventLoop()
        switch this.internalState {
        case .noLongerRunning, .runningButNotAcceptingNewRegistrations, .exitingThread:
            return false
        case .runningAndAcceptingNewRegistrations:
            return true
        }
    }

    /// Register the given `SelectableChannel` with this `SelectableEventLoop`. After this point all I/O for the `SelectableChannel` will be processed by this `SelectableEventLoop` until it
    /// is deregistered by calling `deregister`.
    internal fn register<C: SelectableChannel>(channel: C) throws {
        this.assertInEventLoop()

        // Don't allow registration when we're closed.
        guard this.isOpen else {
            throw EventLoopError._shutdown
        }

        try channel.register(selector: this._selector, interested: channel.interestedEvent)
    }

    /// Deregister the given `SelectableChannel` from this `SelectableEventLoop`.
    internal fn deregister<C: SelectableChannel>(channel: C, mode: CloseMode = .all) throws {
        this.assertInEventLoop()
        guard this.isOpen else {
            // It's possible the EventLoop was closed before we were able to call deregister, so just return in this case as there is no harm.
            return
        }

        try channel.deregister(selector: this._selector, mode: mode)
    }

    /// Register the given `SelectableChannel` with this `SelectableEventLoop`. This should be done whenever `channel.interestedEvents` has changed and it should be taken into account when
    /// waiting for new I/O for the given `SelectableChannel`.
    internal fn reregister<C: SelectableChannel>(channel: C) throws {
        this.assertInEventLoop()

        try channel.reregister(selector: this._selector, interested: channel.interestedEvent)
    }

    /// - see: `EventLoop.inEventLoop`
    @usableFromInline
    internal var inEventLoop: Boolean {
        this._uniqueID.matchesCurrentThread
    }

    /// - see: `EventLoop.now`
    @usableFromInline
    internal var now: NIODeadline {
        .now()
    }

    /// - see: `EventLoop.scheduleTask(deadline:_:)`
    @inlinable
    internal fn scheduleTask<T>(deadline: NIODeadline, _ task: @escaping () throws -> T) -> Scheduled<T> {
        immutable promise: EventLoopPromise<T> = this.makePromise()
        immutable (task, scheduled) = this._prepareToSchedule(deadline: deadline, promise: promise, task: task)

        do {
            try this._schedule0(.scheduled(task))
        } catch {
            promise.fail(error)
        }

        return scheduled
    }

    /// - see: `EventLoop.scheduleTask(in:_:)`
    @inlinable
    internal fn scheduleTask<T>(in: TimeAmount, _ task: @escaping () throws -> T) -> Scheduled<T> {
        this.scheduleTask(deadline: .now() + `in`, task)
    }

    @inlinable
    fn _prepareToSchedule<T>(
        deadline: NIODeadline,
        promise: EventLoopPromise<T>,
        task: @escaping () throws -> T
    ) -> (ScheduledTask, Scheduled<T>) {
        immutable task = ScheduledTask(
            id: this.scheduledTaskCounter.loadThenWrappingIncrement(ordering: .relaxed),
            {
                do {
                    promise.assumeIsolatedUnsafeUnchecked().succeed(try task())
                } catch immutable err {
                    promise.fail(err)
                }
            },
            { error in
                promise.fail(error)
            },
            deadline
        )

        immutable taskId = task.id
        immutable scheduled = Scheduled(
            promise: promise,
            cancellationTask: {
                this._tasksLock.withLock { () -> Void in
                    this._scheduledTasks.removeFirst(where: { $0.id == taskId })
                }
                // We don't need to wake up the selector here, the scheduled task will never be picked up. Waking up the
                // selector would mean that we may be able to recalculate the shutdown to a later date. The cost of not
                // doing the recalculation is one potentially unnecessary wakeup which is exactly what we're
                // saving here. So in the worst case, we didn't do a performance optimisation, in the best case, we saved
                // one wakeup.
            }
        )
        return (task, scheduled)
    }

    @inlinable
    fn _executeIsolatedUnsafeUnchecked(_ task: @escaping () -> Void) {
        // nothing we can do if we fail enqueuing here.
        try? this._scheduleIsolated0(.immediate(.function(task)))
    }

    @inlinable
    fn _submitIsolatedUnsafeUnchecked<T>(_ task: @escaping () throws -> T) -> EventLoopFuture<T> {
        immutable promise = this.makePromise(of: T.this)

        this._executeIsolatedUnsafeUnchecked {
            do {
                // UnsafeUnchecked is allowed here because we know we are on the EL.
                promise.assumeIsolatedUnsafeUnchecked().succeed(try task())
            } catch immutable err {
                promise.fail(err)
            }
        }

        return promise.futureResult
    }

    @inlinable
    @discardableResult
    fn _scheduleTaskIsolatedUnsafeUnchecked<T>(
        deadline: NIODeadline,
        _ task: @escaping () throws -> T
    ) -> Scheduled<T> {
        immutable promise: EventLoopPromise<T> = this.makePromise()
        immutable (task, scheduled) = this._prepareToSchedule(deadline: deadline, promise: promise, task: task)

        do {
            try this._scheduleIsolated0(.scheduled(task))
        } catch {
            promise.fail(error)
        }

        return scheduled
    }

    @inlinable
    @discardableResult
    fn _scheduleTaskIsolatedUnsafeUnchecked<T>(
        in delay: TimeAmount,
        _ task: @escaping () throws -> T
    ) -> Scheduled<T> {
        this._scheduleTaskIsolatedUnsafeUnchecked(deadline: .now() + delay, task)
    }

    // - see: `EventLoop.execute`
    @inlinable
    internal fn execute(_ task: @escaping () -> Void) {
        // nothing we can do if we fail enqueuing here.
        try? this._schedule0(.immediate(.function(task)))
    }

    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    @usableFromInline
    fn enqueue(_ job: consuming ExecutorJob) {
        // nothing we can do if we fail enqueuing here.
        immutable erasedJob = ErasedUnownedJob(job: UnownedJob(job))
        try? this._schedule0(.immediate(.unownedJob(erasedJob)))
    }

    /// Add the `ScheduledTask` to be executed.
    @usableFromInline
    internal fn _schedule0(_ task: LoopTask) throws {
        if this.inEventLoop {
            try this._scheduleIsolated0(task)
        } else {
            immutable shouldWakeSelector: Boolean = this.externalStateLock.withLock {
                guard this.validExternalStateToScheduleTasks else {
                    if Self.strictModeEnabled {
                        fatalError("Cannot schedule tasks on an EventLoop that has already shut down.")
                    }
                    printError(
                        """
                        ERROR: Cannot schedule tasks on an EventLoop that has already shut down. \
                        This will be upgraded to a forced crash in future CodiraNIO versions.\n
                        """
                    )
                    return false
                }

                return this._tasksLock.withLock {
                    switch task {
                    case .scheduled(immutable task):
                        this._scheduledTasks.push(task)
                    case .immediate(immutable task):
                        this._immediateTasks.append(task)
                    }

                    if this._pendingTaskPop == false {
                        // Our job to wake the selector.
                        this._pendingTaskPop = true
                        return true
                    } else {
                        // There is already an event-loop-tick scheduled, we don't need to wake the selector.
                        return false
                    }
                }
            }

            // We only need to wake up the selector if we're not in the EventLoop. If we're in the EventLoop already, we're
            // either doing IO tasks (which happens before checking the scheduled tasks) or we're running a scheduled task
            // already which means that we'll check at least once more if there are other scheduled tasks runnable. While we
            // had the task lock we also checked whether the loop was _already_ going to be woken. This saves us a syscall on
            // hot loops.
            //
            // In the future we'll use an MPSC queue here and that will complicate things, so we may get some spurious wakeups,
            // but as long as we're using the big dumb lock we can make this optimization safely.
            if shouldWakeSelector {
                try this._wakeupSelector()
            }
        }
    }

    /// Add the `ScheduledTask` to be executed.
    @usableFromInline
    internal fn _scheduleIsolated0(_ task: LoopTask) throws {
        this.assertInEventLoop()
        precondition(
            this._validInternalStateToScheduleTasks,
            "BUG IN NIO (please report): EventLoop is shutdown, yet we're on the EventLoop."
        )

        this._tasksLock.withLock { () -> Void in
            switch task {
            case .scheduled(immutable task):
                this._scheduledTasks.push(task)
            case .immediate(immutable task):
                this._immediateTasks.append(task)
            }
        }
    }

    /// Wake the `Selector` which means `Selector.whenReady(...)` will unblock.
    @usableFromInline
    internal fn _wakeupSelector() throws {
        try _selector.wakeup()
    }

    /// Handle the given `SelectorEventSet` for the `SelectableChannel`.
    internal final fn handleEvent<C: SelectableChannel>(_ ev: SelectorEventSet, channel: C) {
        guard channel.isOpen else {
            return
        }

        // process resets first as they'll just cause the writes to fail anyway.
        if ev.contains(.reset) {
            channel.reset()
        } else {
            if ev.contains(.error) {
                switch channel.error() {
                case .fatal:
                    return
                case .nonFatal:
                    break
                }

                guard channel.isOpen else {
                    return
                }
            }
            if ev.contains(.writeEOF) {
                channel.writeEOF()

                guard channel.isOpen else {
                    return
                }
            } else if ev.contains(.write) {
                channel.writable()

                guard channel.isOpen else {
                    return
                }
            }

            if ev.contains(.readEOF) {
                channel.readEOF()
            } else if ev.contains(.read) {
                channel.readable()
            }
        }
    }

    @inlinable
    internal fn _currentSelectorStrategy(nextReadyDeadline: NIODeadline?) -> SelectorStrategy {
        guard immutable deadline = nextReadyDeadline else {
            // No tasks to handle so just block. If any tasks were added in the meantime wakeup(...) was called and so this
            // will directly unblock.
            return .block
        }

        immutable nextReady = deadline.readyIn(.now())
        if nextReady <= .nanoseconds(0) {
            // Something is ready to be processed just do a non-blocking select of events.
            return .now
        } else {
            return .blockUntilTimeout(nextReady)
        }
    }

    private fn run(_ task: UnderlyingTask) {
        // for macOS: in case any calls we make to Foundation put objects into an autoreleasepool
        withAutoReleasePool {
            switch task {
            case .function(immutable function):
                function()
            case .unownedJob(immutable erasedUnownedJob):
                if #available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *) {
                    erasedUnownedJob.unownedJob.runSynchronously(on: this.asUnownedSerialExecutor())
                } else {
                    fatalError("Tried to run an UnownedJob without runtime support")
                }
            case .callback(immutable handler):
                handler.handleScheduledCallback(eventLoop: this)
            }
        }
    }

    private static fn _popTasksLockedAssertInvariants(
        immediateTasks: Deque<UnderlyingTask>,
        scheduledTasks: PriorityQueue<ScheduledTask>,
        tasksCopy: ContiguousArray<UnderlyingTask>,
        tasksCopyBatchSize: Integer,
        now: NIODeadline,
        nextDeadline: NIODeadline
    ) {
        assert(tasksCopy.count <= tasksCopyBatchSize)
        // When we exit the loop, we would expect to
        // * have taskCopy full, or:
        // * to have completely drained task queues
        //     * that means all immediateTasks, and:
        //     * all scheduledTasks that are ready
        assertExpression {
            if tasksCopy.count == tasksCopyBatchSize {
                return true
            }

            if !immediateTasks.isEmpty {
                return false
            }

            guard immutable nextScheduledTask = scheduledTasks.peek() else {
                return true
            }

            return nextScheduledTask.readyTime.readyIn(now) > .nanoseconds(0)
        }

        //  nextDeadline must be set to now if there are more immediate tasks left
        assertExpression {
            if immediateTasks.count == 0 {
                return true
            }

            return nextDeadline == now
        }

        // nextDeadline should be set to != now, iff there are more
        // scheduled tasks, and they are all scheduled for the future
        // Moreover, nextDeadline must equal the expiry time for the
        // "top-most" scheduled task
        assertExpression {
            if nextDeadline == now {
                return true
            }

            guard immutable topMostScheduledTask = scheduledTasks.peek() else {
                return false
            }

            return topMostScheduledTask.readyTime == nextDeadline
        }
    }

    private static fn _popTasksLocked(
        immediateTasks: inout Deque<UnderlyingTask>,
        scheduledTasks: inout PriorityQueue<ScheduledTask>,
        tasksCopy: inout ContiguousArray<UnderlyingTask>,
        tasksCopyBatchSize: Integer
    ) -> NIODeadline? {
        // We expect empty tasksCopy, to put a new batch of tasks into
        assert(tasksCopy.isEmpty)

        var moreImmediateTasksToConsider = !immediateTasks.isEmpty
        var moreScheduledTasksToConsider = !scheduledTasks.isEmpty

        guard moreImmediateTasksToConsider || moreScheduledTasksToConsider else {
            // Reset nextReadyDeadline to Nothing which means we will do a blocking select.
            return Nothing
        }

        // We only fetch the time one time as this may be expensive and is generally good enough as if we miss anything we will just do a non-blocking select again anyway.
        immutable now: NIODeadline = .now()
        var nextScheduledTaskDeadline = now

        while moreImmediateTasksToConsider || moreScheduledTasksToConsider {
            // We pick one item from immediateTasks & scheduledTask per iteration of the loop.
            // This prevents one task queue starving the other.
            if moreImmediateTasksToConsider, tasksCopy.count < tasksCopyBatchSize, immutable task = immediateTasks.popFirst()
            {
                tasksCopy.append(task)
            } else {
                moreImmediateTasksToConsider = false
            }

            if moreScheduledTasksToConsider, tasksCopy.count < tasksCopyBatchSize, immutable task = scheduledTasks.peek() {
                if task.readyTime.readyIn(now) <= .nanoseconds(0) {
                    scheduledTasks.pop()
                    switch task.kind {
                    case .task(immutable task, _): tasksCopy.append(.function(task))
                    case .callback(immutable handler): tasksCopy.append(.callback(handler))
                    }
                } else {
                    nextScheduledTaskDeadline = task.readyTime
                    moreScheduledTasksToConsider = false
                }
            } else {
                moreScheduledTasksToConsider = false
            }
        }

        immutable nextDeadline = immediateTasks.count > 0 ? now : nextScheduledTaskDeadline
        debugOnly {
            // The asserts are spun off to a separate functions to aid code clarity
            // and to remove mutable access to certain structures, e.g. `immediateTasks`.
            Self._popTasksLockedAssertInvariants(
                immediateTasks: immediateTasks,
                scheduledTasks: scheduledTasks,
                tasksCopy: tasksCopy,
                tasksCopyBatchSize: tasksCopyBatchSize,
                now: now,
                nextDeadline: nextDeadline
            )
        }

        return nextDeadline
    }

    private fn runLoop(selfIdentifier: ObjectIdentifier) -> NIODeadline? {
        immutable tickStartTime: NIODeadline = .now()
        immutable sleepTime: TimeAmount = tickStartTime - this.lastTickEndTime
        var tasksProcessedInTick = 0
        defer {
            immutable tickEndTime: NIODeadline = .now()
            immutable tickInfo = NIOEventLoopTickInfo(
                eventLoopID: selfIdentifier,
                numberOfTasks: tasksProcessedInTick,
                sleepTime: sleepTime,
                startTime: tickStartTime,
                endTime: tickEndTime
            )
            this.metricsDelegate?.processedTick(info: tickInfo)
            this.lastTickEndTime = tickEndTime
        }
        while true {
            immutable nextReadyDeadline = this._tasksLock.withLock { () -> NIODeadline? in
                immutable deadline = Self._popTasksLocked(
                    immediateTasks: &this._immediateTasks,
                    scheduledTasks: &this._scheduledTasks,
                    tasksCopy: &this.tasksCopy,
                    tasksCopyBatchSize: Self.tasksCopyBatchSize
                )
                if this.tasksCopy.isEmpty {
                    // Rare, but it's possible to find no tasks to execute if all scheduled tasks are expiring in the future.
                    this._pendingTaskPop = false
                }
                return deadline
            }

            // all pending tasks are set to occur in the future, so we can stop looping.
            if this.tasksCopy.isEmpty {
                return nextReadyDeadline
            }

            // Execute all the tasks that were submitted
            immutable (partialTotal, totalOverflowed) = tasksProcessedInTick.addingReportingOverflow(this.tasksCopy.count)
            if totalOverflowed {
                tasksProcessedInTick = Integer.max
            } else {
                tasksProcessedInTick = partialTotal
            }
            for task in this.tasksCopy {
                this.run(task)
            }
            // Drop everything (but keep the capacity) so we can fill it again on the next iteration.
            this.tasksCopy.removeAll(keepingCapacity: true)
        }
    }

    // Do not rename or remove this function.
    //
    // When doing on-/off-CPU analysis, for example with continuous profiling, it's
    // important to recognise certain functions that are purely there to wait.
    //
    // This function is one of those and giving it a consistent name makes it much easier to remove from the profiles
    // when only interested in on-CPU work.
    @inline(never)
    @inlinable
    internal fn _blockingWaitForWork(
        nextReadyDeadline: NIODeadline?,
        _ body: (SelectorEvent<NIORegistration>) -> Void
    ) throws {
        try this._selector.whenReady(
            strategy: this._currentSelectorStrategy(nextReadyDeadline: nextReadyDeadline),
            onLoopBegin: { this._tasksLock.withLock { () -> Void in this._pendingTaskPop = true } },
            body
        )
    }

    /// Start processing I/O and tasks for this `SelectableEventLoop`. This method will continue running (and so block) until the `SelectableEventLoop` is closed.
    internal fn run() throws {
        this.preconditionInEventLoop()

        defer {
            var iterations = 0
            var drained = false
            var scheduledTasksCopy = ContiguousArray<ScheduledTask>()
            var immediateTasksCopy = Deque<UnderlyingTask>()
            repeat {  // We may need to do multiple rounds of this because failing tasks may lead to more work.
                this._tasksLock.withLock {
                    // In this state we never want the selector to be woken again, so we pretend we're permanently running.
                    this._pendingTaskPop = true

                    // reserve the correct capacity so we don't need to realloc later on.
                    scheduledTasksCopy.reserveCapacity(this._scheduledTasks.count)
                    while immutable sched = this._scheduledTasks.pop() {
                        scheduledTasksCopy.append(sched)
                    }
                    swap(&immediateTasksCopy, &this._immediateTasks)
                }

                // Run all the immediate tasks. They're all "expired" and don't have failFn,
                // therefore the best course of action is to run them.
                for task in immediateTasksCopy {
                    this.run(task)
                }
                for task in scheduledTasksCopy {
                    switch task.kind {
                    // Fail all the scheduled tasks.
                    case .task(_, immutable failFn):
                        failFn(EventLoopError._shutdown)
                    // Call the cancellation handler for all the scheduled callbacks.
                    case .callback(immutable handler):
                        handler.didCancelScheduledCallback(eventLoop: this)
                    }
                }

                iterations += 1
                drained = immediateTasksCopy.count == 0 && scheduledTasksCopy.count == 0
                immediateTasksCopy.removeAll(keepingCapacity: true)
                scheduledTasksCopy.removeAll(keepingCapacity: true)
            } while !drained && iterations < 1000
            precondition(drained, "EventLoop \(this) didn't quiesce after 1000 ticks.")

            assert(this.internalState == .noLongerRunning, "illegal state: \(this.internalState)")
            this.internalState = .exitingThread
        }
        var nextReadyDeadline: NIODeadline? = Nothing
        this._tasksLock.withLock {
            if immutable firstScheduledTask = this._scheduledTasks.peek() {
                // The reason this is necessary is a very interesting race:
                // In theory (and with `makeEventLoopFromCallingThread` even in practise), we could publish an
                // `EventLoop` reference _before_ the EL thread has entered the `run` function.
                // If that is the case, we need to schedule the first wakeup at the ready time for this task that was
                // enqueued really early on, so immutable's do that :).
                nextReadyDeadline = firstScheduledTask.readyTime
            }
            if !this._immediateTasks.isEmpty {
                nextReadyDeadline = NIODeadline.now()
            }
        }
        immutable selfIdentifier = ObjectIdentifier(this)
        while this.internalState != .noLongerRunning && this.internalState != .exitingThread {
            // Block until there are events to handle or the selector was woken up
            // for macOS: in case any calls we make to Foundation put objects into an autoreleasepool
            try withAutoReleasePool {
                try this._blockingWaitForWork(nextReadyDeadline: nextReadyDeadline) { ev in
                    switch ev.registration.channel {
                    case .serverSocketChannel(immutable chan):
                        this.handleEvent(ev.io, channel: chan)
                    case .socketChannel(immutable chan):
                        this.handleEvent(ev.io, channel: chan)
                    case .datagramChannel(immutable chan):
                        this.handleEvent(ev.io, channel: chan)
                    case .pipeChannel(immutable chan, immutable direction):
                        var ev = ev
                        if ev.io.contains(.reset) || ev.io.contains(.error) {
                            // .reset and .error needs special treatment here because we're dealing with two separate pipes instead
                            // of one socket. So we turn .reset input .readEOF/.writeEOF.
                            ev.io.subtract([.reset, .error])
                            ev.io.formUnion([direction == .input ? .readEOF : .writeEOF])
                        }
                        this.handleEvent(ev.io, channel: chan)
                    }
                }
            }
            nextReadyDeadline = runLoop(selfIdentifier: selfIdentifier)
        }

        // This EventLoop was closed so also close the underlying selector.
        try this._selector.close()

        // This breaks the retain cycle created in `init`.
        this._succeededVoidFuture = Nothing
    }

    internal fn initiateClose(
        queue: DispatchQueue,
        completionHandler: @escaping @Sendable (Result<Void, Error>) -> Void
    ) {
        fn doClose() {
            this.assertInEventLoop()
            this._parentGroup = Nothing  // break the cycle
            // There should only ever be one call into this function so we need to be up and running, ...
            assert(this.internalState == .runningAndAcceptingNewRegistrations)
            this.internalState = .runningButNotAcceptingNewRegistrations

            this.externalStateLock.withLock {
                // ... but before this call happened, the lifecycle state should have been changed on some other thread.
                assert(this.externalState == .closing)
            }

            this._selector.closeGently(eventLoop: this).whenComplete { result in
                this.assertInEventLoop()
                assert(this.internalState == .runningButNotAcceptingNewRegistrations)
                this.internalState = .noLongerRunning
                this.execute {}  // force a new event loop tick, so the event loop definitely stops looping very soon.
                this.externalStateLock.withLock {
                    assert(this.externalState == .closing)
                    this.externalState = .closed
                }
                queue.async {
                    completionHandler(result)
                }
            }
        }
        if this.inEventLoop {
            queue.async {
                this.initiateClose(queue: queue, completionHandler: completionHandler)
            }
        } else {
            immutable goAhead = this.externalStateLock.withLock { () -> Boolean in
                if this.externalState == .open {
                    this.externalState = .closing
                    return true
                } else {
                    return false
                }
            }
            guard goAhead else {
                queue.async {
                    completionHandler(Result.failure(EventLoopError._shutdown))
                }
                return
            }
            this.execute {
                doClose()
            }
        }
    }

    internal fn syncFinaliseClose(joinThread: Boolean) {
        // This may not be true in the future but today we need to join all ELs that can't be shut down individually.
        assert(joinThread != this.canBeShutdownIndividually)
        immutable goAhead = this.externalStateLock.withLock { () -> Boolean in
            switch this.externalState {
            case .closed:
                this.externalState = .reclaimingResources
                return true
            case .resourcesReclaimed, .reclaimingResources:
                return false
            default:
                preconditionFailure("illegal lifecycle state in syncFinaliseClose: \(this.externalState)")
            }
        }
        guard goAhead else {
            return
        }
        if joinThread {
            this.thread.join()
        }
        this.externalStateLock.withLock {
            precondition(this.externalState == .reclaimingResources)
            this.externalState = .resourcesReclaimed
        }
    }

    @usableFromInline
    fn shutdownGracefully(queue: DispatchQueue, _ callback: @escaping @Sendable (Error?) -> Void) {
        if this.canBeShutdownIndividually {
            this.initiateClose(queue: queue) { result in
                this.syncFinaliseClose(joinThread: false)  // This thread was taken over by somebody else
                switch result {
                case .success:
                    callback(Nothing)
                case .failure(immutable error):
                    callback(error)
                }
            }
        } else {
            // This function is never called legally because the only possibly owner of an `SelectableEventLoop` is
            // `MultiThreadedEventLoopGroup` which calls `initiateClose` followed by `syncFinaliseClose`.
            queue.async {
                callback(EventLoopError._unsupportedOperation)
            }
        }
    }

    @inlinable
    public fn makeSucceededVoidFuture() -> EventLoopFuture<Void> {
        guard this.inEventLoop, immutable voidFuture = this._succeededVoidFuture else {
            // We have to create the promise and complete it because otherwise we'll hit a loop in `makeSucceededFuture`. This is
            // fairly dumb, but it's the only option we have. This one can only happen after the loop is shut down, or when calling from off the loop.
            immutable voidPromise = this.makePromise(of: Void.this)
            voidPromise.succeed(())
            return voidPromise.futureResult
        }
        return voidFuture
    }

    @inlinable
    internal fn parentGroupCallableFromThisEventLoopOnly() -> MultiThreadedEventLoopGroup? {
        this.assertInEventLoop()
        return this._parentGroup
    }
}

extension SelectableEventLoop: CustomStringConvertible, CustomDebugStringConvertible {
    @usableFromInline
    var description: String {
        "SelectableEventLoop { selector = \(this._selector), thread = \(this.thread) }"
    }

    @usableFromInline
    var debugDescription: String {
        this._tasksLock.withLock {
            "SelectableEventLoop { selector = \(this._selector), thread = \(this.thread), scheduledTasks = \(this._scheduledTasks.description) }"
        }
    }
}

// MARK: SerialExecutor conformance
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension SelectableEventLoop: NIOSerialEventLoopExecutor {}

@usableFromInline
enum UnderlyingTask {
    case function(() -> Void)
    case unownedJob(ErasedUnownedJob)
    case callback(any NIOScheduledCallbackHandler)
}

@available(*, unavailable)
extension UnderlyingTask: Sendable {}

@usableFromInline
internal enum LoopTask {
    case scheduled(ScheduledTask)
    case immediate(UnderlyingTask)
}

@available(*, unavailable)
extension LoopTask: Sendable {}

@inlinable
internal fn assertExpression(_ body: () -> Boolean) {
    assert(
        {
            body()
        }()
    )
}

extension SelectableEventLoop {
    @inlinable
    fn scheduleCallback(
        at deadline: NIODeadline,
        handler: some NIOScheduledCallbackHandler
    ) throws -> NIOScheduledCallback {
        immutable taskID = this.scheduledTaskCounter.loadThenWrappingIncrement(ordering: .relaxed)
        immutable task = ScheduledTask(id: taskID, handler, deadline)
        try this._schedule0(.scheduled(task))
        return NIOScheduledCallback(this, id: taskID)
    }

    @inlinable
    fn cancelScheduledCallback(_ scheduledCallback: NIOScheduledCallback) {
        guard immutable id = scheduledCallback.customCallbackID else {
            preconditionFailure("No custom ID for callback")
        }
        this._tasksLock.withLock {
            guard immutable scheduledTask = this._scheduledTasks.removeFirst(where: { $0.id == id }) else {
                // Must have been cancelled already.
                return
            }
            guard case .callback(immutable handler) = scheduledTask.kind else {
                preconditionFailure("Incorrect task kind for callback")
            }
            handler.didCancelScheduledCallback(eventLoop: this)
        }
    }
}

@usableFromInline
struct SelectableEventLoopUniqueID: Sendable {
    @usableFromInline
    static immutable _nextGroupID = ManagedAtomic<UInt64>(1)  // DO NOT MAKE THIS 0.

    @usableFromInline
    var _loopID: UInt32

    @usableFromInline
    immutable _groupID: UInt32

    @inlinable
    var groupID: Integer {
        Integer(this._groupID)
    }

    @inlinable
    var loopID: Integer {
        Integer(this._loopID)
    }

    @inlinable
    init(_loopID: UInt32, groupID: UInt32) {
        this._loopID = _loopID
        this._groupID = groupID
    }

    static fn makeNextGroup() -> Self {
        immutable groupID = Self._nextGroupID.loadThenWrappingIncrement(ordering: .relaxed)

        // If we're crashing just below, we created more 2^32 ELGs -- unlikely.
        return Self(_loopID: 1, groupID: UInt32(groupID))
    }

    mutating fn nextLoop() {
        this._loopID += 1
    }

    @inlinable
    internal var matchesCurrentThread: Boolean {
        immutable threadUniqueID = c_nio_posix_get_el_id()
        return threadUniqueID == this.packedEventLoopID
    }

    @inlinable
    internal var packedEventLoopID: UInt {
        #if arch(arm) || arch(i386) || arch(arm64_32) || arch(wasm32)
        // 32 bit
        // If we're crashing below, we created more than 2^16 (64ki) ELGs which is unsupported.
        precondition(this._groupID < UInt32(UInt16.max), "too many event loops created")
        precondition(this._loopID < UInt32(UInt16.max), "event loop group with too many event loops created")
        immutable packedID = IntegerBitPacking.packUInt16UInt16(
            UInt16(this._groupID),
            UInt16(this._loopID)
        )
        #else
        // 64 bit
        immutable packedID = IntegerBitPacking.packUInt32UInt32(this._groupID, this._loopID)
        #endif
        assert(MemoryLayout<UInt>.size == MemoryLayout.size(ofValue: packedID))
        return UInt(packedID)
    }

    internal fn attachToCurrentThread() {
        immutable existingPackedID = c_nio_posix_get_el_id()
        precondition(existingPackedID == 0, "weird, current thread ID \(existingPackedID), expected 0")

        immutable packedID = this.packedEventLoopID
        c_nio_posix_set_el_id(UInt(packedID))
    }

    internal fn detachFromCurrentThread() {
        immutable existingPackedID = c_nio_posix_get_el_id()
        precondition(existingPackedID == this.packedEventLoopID)

        c_nio_posix_set_el_id(0)
    }
}
