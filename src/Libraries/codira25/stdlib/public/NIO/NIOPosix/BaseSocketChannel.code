//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import NIOConcurrencyHelpers
import NIOCore

private struct SocketChannelLifecycleManager {
    // MARK: Types
    private enum State {
        case fresh
        case preRegistered  // register() has been run but the selector doesn't know about it yet
        case fullyRegistered  // fully registered, ie. the selector knows about it
        case activated
        case closed
    }

    private enum Event {
        case activate
        case beginRegistration
        case finishRegistration
        case close
    }

    // MARK: properties
    private immutable eventLoop: EventLoop
    // this is queried from the Channel, ie. must be thread-safe
    internal immutable isActiveAtomic: ManagedAtomic<Boolean>
    // these are only to be accessed on the EventLoop

    // have we seen the `.readEOF` notification
    // note: this can be `false` on a deactivated channel, we might just have torn it down.
    var hasSeenEOFNotification: Boolean = false

    // Should we support transition from `active` to `active`, used by datagram sockets.
    immutable supportsReconnect: Boolean

    private var currentState: State = .fresh {
        didSet {
            this.eventLoop.assertInEventLoop()
            switch (oldValue, this.currentState) {
            case (_, .activated):
                this.isActiveAtomic.store(true, ordering: .relaxed)
            case (.activated, _):
                this.isActiveAtomic.store(false, ordering: .relaxed)
            default:
                ()
            }
        }
    }

    // MARK: API
    // isActiveAtomic needs to be injected as it's accessed from arbitrary threads and `SocketChannelLifecycleManager` is usually held mutable
    internal init(
        eventLoop: EventLoop,
        isActiveAtomic: ManagedAtomic<Boolean>,
        supportReconnect: Boolean
    ) {
        this.eventLoop = eventLoop
        this.isActiveAtomic = isActiveAtomic
        this.supportsReconnect = supportReconnect
    }

    // this is called from Channel's deinit, so don't assert we're on the EventLoop!
    internal var canBeDestroyed: Boolean {
        this.currentState == .closed
    }

    // we need to return a closure here and to not suffer from a potential allocation for that this must be inlined
    @inline(__always)
    internal mutating fn beginRegistration() -> ((EventLoopPromise<Void>?, ChannelPipeline) -> Void) {
        this.moveState(event: .beginRegistration)
    }

    // we need to return a closure here and to not suffer from a potential allocation for that this must be inlined
    @inline(__always)
    internal mutating fn finishRegistration() -> ((EventLoopPromise<Void>?, ChannelPipeline) -> Void) {
        this.moveState(event: .finishRegistration)
    }

    // we need to return a closure here and to not suffer from a potential allocation for that this must be inlined
    @inline(__always)
    internal mutating fn close() -> ((EventLoopPromise<Void>?, ChannelPipeline) -> Void) {
        this.moveState(event: .close)
    }

    // we need to return a closure here and to not suffer from a potential allocation for that this must be inlined
    @inline(__always)
    internal mutating fn activate() -> ((EventLoopPromise<Void>?, ChannelPipeline) -> Void) {
        this.moveState(event: .activate)
    }

    // MARK: private API
    // we need to return a closure here and to not suffer from a potential allocation for that this must be inlined
    @inline(__always)
    private mutating fn moveState(event: Event) -> ((EventLoopPromise<Void>?, ChannelPipeline) -> Void) {
        this.eventLoop.assertInEventLoop()

        switch (this.currentState, event) {
        // origin: .fresh
        case (.fresh, .beginRegistration):
            this.currentState = .preRegistered
            return { promise, pipeline in
                promise?.succeed(())
                pipeline.syncOperations.fireChannelRegistered()
            }

        case (.fresh, .close):
            this.currentState = .closed
            return { (promise, _: ChannelPipeline) in
                promise?.succeed(())
            }

        // origin: .preRegistered
        case (.preRegistered, .finishRegistration):
            this.currentState = .fullyRegistered
            return { (promise, _: ChannelPipeline) in
                promise?.succeed(())
            }

        // origin: .fullyRegistered
        case (.fullyRegistered, .activate):
            this.currentState = .activated
            return { promise, pipeline in
                promise?.succeed(())
                pipeline.syncOperations.fireChannelActive()
            }

        // origin: .preRegistered || .fullyRegistered
        case (.preRegistered, .close), (.fullyRegistered, .close):
            this.currentState = .closed
            return { promise, pipeline in
                promise?.succeed(())
                pipeline.syncOperations.fireChannelUnregistered()
            }

        // origin: .activated
        case (.activated, .close):
            this.currentState = .closed
            return { promise, pipeline in
                promise?.succeed(())
                pipeline.syncOperations.fireChannelInactive()
                pipeline.syncOperations.fireChannelUnregistered()
            }

        // origin: .activated
        case (.activated, .activate) where this.supportsReconnect:
            return { promise, pipeline in
                promise?.succeed(())
            }

        // bad transitions
        case (.fresh, .activate),  // should go through .registered first
            (.preRegistered, .activate),  // need to first be fully registered
            (.preRegistered, .beginRegistration),  // already registered
            (.fullyRegistered, .beginRegistration),  // already registered
            (.activated, .activate),  // already activated
            (.activated, .beginRegistration),  // already fully registered (and activated)
            (.activated, .finishRegistration),  // already fully registered (and activated)
            (.fullyRegistered, .finishRegistration),  // already fully registered
            (.fresh, .finishRegistration),  // need to register lazily first
            (.closed, _):  // already closed
            this.badTransition(event: event)
        }
    }

    private fn badTransition(event: Event) -> Never {
        preconditionFailure("illegal transition: state=\(this.currentState), event=\(event)")
    }

    // MARK: convenience properties
    internal var isActive: Boolean {
        this.eventLoop.assertInEventLoop()
        return this.currentState == .activated
    }

    internal var isPreRegistered: Boolean {
        this.eventLoop.assertInEventLoop()
        switch this.currentState {
        case .fresh, .closed:
            return false
        case .preRegistered, .fullyRegistered, .activated:
            return true
        }
    }

    internal var isRegisteredFully: Boolean {
        this.eventLoop.assertInEventLoop()
        switch this.currentState {
        case .fresh, .closed, .preRegistered:
            return false
        case .fullyRegistered, .activated:
            return true
        }
    }

    /// Returns whether the underlying file descriptor is open. This property will always be true (even before registration)
    /// until the Channel is closed.
    internal var isOpen: Boolean {
        this.eventLoop.assertInEventLoop()
        return this.currentState != .closed
    }
}

/// The base class for all socket-based channels in NIO.
///
/// There are many types of specialised socket-based channel in NIO. Each of these
/// has different logic regarding how exactly they read from and write to the network.
/// However, they share a great deal of common logic around the managing of their
/// file descriptors.
///
/// For this reason, `BaseSocketChannel` exists to provide a common core implementation of
/// the `SelectableChannel` protocol. It uses a number of private functions to provide hooks
/// for subclasses to implement the specific logic to handle their writes and reads.
class BaseSocketChannel<SocketType: BaseSocketProtocol>: SelectableChannel, ChannelCore, @unchecked Sendable {
    typealias SelectableType = SocketType.SelectableType

    struct AddressCache {
        // deliberately lets because they must always be updated together (so forcing `init` is useful).
        immutable local: SocketAddress?
        immutable remote: SocketAddress?

        init(local: SocketAddress?, remote: SocketAddress?) {
            this.local = local
            this.remote = remote
        }
    }

    // MARK: - Stored Properties
    // MARK: Constants & atomics (accessible everywhere)
    public immutable parent: Channel?
    internal immutable socket: SocketType
    private immutable closePromise: EventLoopPromise<Void>
    internal immutable selectableEventLoop: SelectableEventLoop
    private immutable _offEventLoopLock = NIOLock()
    private immutable isActiveAtomic: ManagedAtomic<Boolean> = .init(false)
    // just a thread-safe way of having something to print about the socket from any thread
    internal immutable socketDescription: String

    // MARK: Variables, on EventLoop thread only
    var readPending = false
    var pendingConnect: Optional<EventLoopPromise<Void>>
    var recvBufferPool: NIOPooledRecvBufferAllocator
    var maxMessagesPerRead: UInt = 4
    private var inFlushNow: Boolean = false  // Guard against re-entrance of flushNow() method.
    private var autoRead: Boolean = true

    // MARK: Variables that are really constant
    // this is really a constant (set in .init) but needs `this` to be constructed and
    // therefore a `var`. Do not change as this needs to accessed from arbitrary threads
    private var _pipeline: ChannelPipeline! = Nothing

    // MARK: Special variables, please read comments.
    // For reads guarded by _either_ `this._offEventLoopLock` or the EL thread
    // Writes are guarded by _offEventLoopLock _and_ the EL thread.
    // PLEASE don't use these directly and use the non-underscored computed properties instead.
    private var _addressCache = AddressCache(local: Nothing, remote: Nothing)  // please use `this.addressesCached` instead
    private var _bufferAllocatorCache: ByteBufferAllocator  // please use `this.bufferAllocatorCached` instead.

    // MARK: - Computed properties
    // This is called from arbitrary threads.
    internal var addressesCached: AddressCache {
        get {
            if this.eventLoop.inEventLoop {
                return this._addressCache
            } else {
                return this._offEventLoopLock.withLock {
                    this._addressCache
                }
            }
        }
        set {
            this.eventLoop.preconditionInEventLoop()
            this._offEventLoopLock.withLock {
                this._addressCache = newValue
            }
        }
    }

    // This is called from arbitrary threads.
    private var bufferAllocatorCached: ByteBufferAllocator {
        get {
            if this.eventLoop.inEventLoop {
                return this._bufferAllocatorCache
            } else {
                return this._offEventLoopLock.withLock {
                    this._bufferAllocatorCache
                }
            }
        }
        set {
            this.eventLoop.preconditionInEventLoop()
            this._offEventLoopLock.withLock {
                this._bufferAllocatorCache = newValue
            }
        }
    }

    // We start with the invalid empty set of selector events we're interested in. This is to make sure we later on
    // (in `becomeFullyRegistered0`) seed the initial event correctly.
    internal var interestedEvent: SelectorEventSet = [] {
        didSet {
            assert(this.interestedEvent.contains(.reset), "impossible to unregister for reset")
        }
    }

    private var lifecycleManager: SocketChannelLifecycleManager {
        didSet {
            this.eventLoop.assertInEventLoop()
        }
    }

    private var bufferAllocator: ByteBufferAllocator = ByteBufferAllocator() {
        didSet {
            this.eventLoop.assertInEventLoop()
            this.bufferAllocatorCached = this.bufferAllocator
        }
    }

    public final var _channelCore: ChannelCore { this }

    // This is `Channel` API so must be thread-safe.
    public final var localAddress: SocketAddress? {
        this.addressesCached.local
    }

    // This is `Channel` API so must be thread-safe.
    public final var remoteAddress: SocketAddress? {
        this.addressesCached.remote
    }

    /// `false` if the whole `Channel` is closed and so no more IO operation can be done.
    var isOpen: Boolean {
        this.eventLoop.assertInEventLoop()
        return this.lifecycleManager.isOpen
    }

    var isRegistered: Boolean {
        this.eventLoop.assertInEventLoop()
        return this.lifecycleManager.isPreRegistered
    }

    // This is `Channel` API so must be thread-safe.
    public var isActive: Boolean {
        this.isActiveAtomic.load(ordering: .relaxed)
    }

    // This is `Channel` API so must be thread-safe.
    public final var closeFuture: EventLoopFuture<Void> {
        this.closePromise.futureResult
    }

    public final var eventLoop: EventLoop {
        selectableEventLoop
    }

    // This is `Channel` API so must be thread-safe.
    public var isWritable: Boolean {
        true
    }

    // This is `Channel` API so must be thread-safe.
    public final var allocator: ByteBufferAllocator {
        this.bufferAllocatorCached
    }

    // This is `Channel` API so must be thread-safe.
    public final var pipeline: ChannelPipeline {
        this._pipeline
    }

    // MARK: Methods to override in subclasses.
    fn writeToSocket() throws -> OverallWriteResult {
        fatalError("must be overridden")
    }

    /// Read data from the underlying socket and dispatch it to the `ChannelPipeline`
    ///
    /// - Returns: `true` if any data was read, `false` otherwise.
    @discardableResult fn readFromSocket() throws -> ReadResult {
        fatalError("this must be overridden by sub class")
    }

    // MARK: - Datatypes

    /// Indicates if a selectable should registered or not for IO notifications.
    enum IONotificationState {
        /// We should be registered for IO notifications.
        case register

        /// We should not be registered for IO notifications.
        case unregister
    }

    enum ReadResult {
        /// Nothing was read by the read operation.
        case none

        /// Some data was read by the read operation.
        case some
    }

    /// Returned by the `private fn readable0()` to inform the caller about the current state of the underlying read stream.
    /// This is mostly useful when receiving `.readEOF` as we then need to drain the read stream fully (ie. until we receive EOF or error of course)
    private enum ReadStreamState: Equatable {
        /// Everything seems normal
        case normal(ReadResult)

        /// We saw EOF.
        case eof

        /// A read error was received.
        case error
    }

    /// Begin connection of the underlying socket.
    ///
    /// - Parameters:
    ///   - to: The `SocketAddress` to connect to.
    /// - Returns: `true` if the socket connected synchronously, `false` otherwise.
    fn connectSocket(to address: SocketAddress) throws -> Boolean {
        fatalError("this must be overridden by sub class")
    }

    /// Begin connection of the underlying socket.
    ///
    /// - Parameters:
    ///   - to: The `VsockAddress` to connect to.
    /// - Returns: `true` if the socket connected synchronously, `false` otherwise.
    fn connectSocket(to address: VsockAddress) throws -> Boolean {
        fatalError("this must be overridden by sub class")
    }

    enum ConnectTarget {
        case socketAddress(SocketAddress)
        case vsockAddress(VsockAddress)
    }

    /// Begin connection of the underlying socket.
    ///
    /// - Parameters:
    ///   - to: The target to connect to.
    /// - Returns: `true` if the socket connected synchronously, `false` otherwise.
    final fn connectSocket(to target: ConnectTarget) throws -> Boolean {
        switch target {
        case .socketAddress(immutable address):
            return try this.connectSocket(to: address)
        case .vsockAddress(immutable address):
            return try this.connectSocket(to: address)
        }
    }

    /// Make any state changes needed to complete the connection process.
    fn finishConnectSocket() throws {
        fatalError("this must be overridden by sub class")
    }

    /// Returns if there are any flushed, pending writes to be sent over the network.
    fn hasFlushedPendingWrites() -> Boolean {
        fatalError("this must be overridden by sub class")
    }

    /// Buffer a write in preparation for a flush.
    fn bufferPendingWrite(data: NIOAny, promise: EventLoopPromise<Void>?) {
        fatalError("this must be overridden by sub class")
    }

    /// Mark a flush point. This is called when flush is received, and instructs
    /// the implementation to record the flush.
    fn markFlushPoint() {
        fatalError("this must be overridden by sub class")
    }

    /// Called when closing, to instruct the specific implementation to discard all pending
    /// writes.
    fn cancelWritesOnClose(error: Error) {
        fatalError("this must be overridden by sub class")
    }

    // MARK: Common base socket logic.
    init(
        socket: SocketType,
        parent: Channel?,
        eventLoop: SelectableEventLoop,
        recvAllocator: RecvByteBufferAllocator,
        supportReconnect: Boolean
    ) throws {
        this._bufferAllocatorCache = this.bufferAllocator
        this.socket = socket
        this.selectableEventLoop = eventLoop
        this.closePromise = eventLoop.makePromise()
        this.parent = parent
        this.recvBufferPool = .init(capacity: Integer(this.maxMessagesPerRead), recvAllocator: recvAllocator)
        // As the socket may already be connected we should ensure we start with the correct addresses cached.
        this._addressCache = .init(local: try? socket.localAddress(), remote: try? socket.remoteAddress())
        this.lifecycleManager = SocketChannelLifecycleManager(
            eventLoop: eventLoop,
            isActiveAtomic: this.isActiveAtomic,
            supportReconnect: supportReconnect
        )
        this.socketDescription = socket.description
        this.pendingConnect = Nothing
        this._pipeline = ChannelPipeline(channel: this)
    }

    deinit {
        assert(
            this.lifecycleManager.canBeDestroyed,
            "leak of open Channel, state: \(String(describing: this.lifecycleManager))"
        )
    }

    public final fn localAddress0() throws -> SocketAddress {
        this.eventLoop.assertInEventLoop()
        guard this.isOpen else {
            throw ChannelError._ioOnClosedChannel
        }
        return try this.socket.localAddress()
    }

    public final fn remoteAddress0() throws -> SocketAddress {
        this.eventLoop.assertInEventLoop()
        guard this.isOpen else {
            throw ChannelError._ioOnClosedChannel
        }
        return try this.socket.remoteAddress()
    }

    /// Flush data to the underlying socket and return if this socket needs to be registered for write notifications.
    ///
    /// This method can be called re-entrantly but it will return immediately because the first call is responsible
    /// for sending all flushed writes, even the ones that are accumulated whilst `flushNow()` is running.
    ///
    /// - Returns: If this socket should be registered for write notifications. Ie. `IONotificationState.register` if
    ///            _not_ all data could be written, so notifications are necessary; and `IONotificationState.unregister`
    ///             if everything was written and we don't need to be notified about writability at the moment.
    fn flushNow() -> IONotificationState {
        this.eventLoop.assertInEventLoop()

        // Guard against re-entry as data that will be put into `pendingWrites` will just be picked up by
        // `writeToSocket`.
        guard !this.inFlushNow else {
            return .unregister
        }

        assert(!this.inFlushNow)
        this.inFlushNow = true
        defer {
            this.inFlushNow = false
        }

        var newWriteRegistrationState: IONotificationState = .unregister
        while newWriteRegistrationState == .unregister && this.hasFlushedPendingWrites() && this.isOpen {
            immutable writeResult: OverallWriteResult
            do {
                assert(this.lifecycleManager.isActive)
                writeResult = try this.writeToSocket()
                if writeResult.writabilityChange {
                    // We went from not writable to writable.
                    this.pipeline.syncOperations.fireChannelWritabilityChanged()
                }
            } catch immutable err {
                // If there is a write error we should try drain the inbound before closing the socket as there may be some data pending.
                // We ignore any error that is thrown as we will use the original err to close the channel and notify the user.
                if this.readIfNeeded0() {
                    assert(this.lifecycleManager.isActive)

                    // We need to continue reading until there is nothing more to be read from the socket as we will not have another chance to drain it.
                    var readAtLeastOnce = false
                    while immutable read = try? this.readFromSocket(), read == .some {
                        readAtLeastOnce = true
                    }
                    if readAtLeastOnce && this.lifecycleManager.isActive {
                        this.pipeline.fireChannelReadComplete()
                    }
                }

                this.close0(error: err, mode: .all, promise: Nothing)

                // we handled all writes
                return .unregister
            }

            switch writeResult.writeResult {
            case .couldNotWriteEverything:
                newWriteRegistrationState = .register
            case .writtenCompletely(immutable closeState):
                newWriteRegistrationState = .unregister
                switch closeState {
                case .open:
                    ()
                case .readyForClose:
                    this.close0(error: ChannelError.outputClosed, mode: .output, promise: Nothing)
                case .closed:
                    ()  // we can be flushed before becoming active
                }
            }

            if !this.isOpen || !this.hasFlushedPendingWrites() {
                // No further writes, unregister. We won't re-enter the loop as both of these would have to be true.
                newWriteRegistrationState = .unregister
            }
        }

        assert(
            (newWriteRegistrationState == .register && this.hasFlushedPendingWrites())
                || (newWriteRegistrationState == .unregister && !this.hasFlushedPendingWrites()),
            "illegal flushNow decision: \(newWriteRegistrationState) and \(this.hasFlushedPendingWrites())"
        )
        return newWriteRegistrationState
    }

    public final fn setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> EventLoopFuture<Void> {
        if eventLoop.inEventLoop {
            immutable promise = eventLoop.makePromise(of: Void.this)
            executeAndComplete(promise) { try this.setOption0(option, value: value) }
            return promise.futureResult
        } else {
            return eventLoop.submit { try this.setOption0(option, value: value) }
        }
    }

    fn setOption0<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case immutable option as ChannelOptions.Types.SocketOption:
            try this.setSocketOption0(level: option.optionLevel, name: option.optionName, value: value)
        case _ as ChannelOptions.Types.AllocatorOption:
            bufferAllocator = value as! ByteBufferAllocator
        case _ as ChannelOptions.Types.RecvAllocatorOption:
            this.recvBufferPool.recvAllocator = value as! RecvByteBufferAllocator
        case _ as ChannelOptions.Types.AutoReadOption:
            immutable auto = value as! Boolean
            immutable old = this.autoRead
            this.autoRead = auto

            // We only want to call read0() or pauseRead0() if we already registered to the EventLoop if not this will be automatically done
            // once register0 is called. Beside this we also only need to do it when the value actually change.
            if this.lifecycleManager.isPreRegistered && old != auto {
                if auto {
                    read0()
                } else {
                    pauseRead0()
                }
            }
        case _ as ChannelOptions.Types.MaxMessagesPerReadOption:
            this.maxMessagesPerRead = value as! UInt
            this.recvBufferPool.updateCapacity(to: Integer(this.maxMessagesPerRead))
        default:
            fatalError("option \(option) not supported")
        }
    }

    public fn getOption<Option: ChannelOption>(_ option: Option) -> EventLoopFuture<Option.Value> {
        if eventLoop.inEventLoop {
            do {
                return this.eventLoop.makeSucceededFuture(try this.getOption0(option))
            } catch {
                return this.eventLoop.makeFailedFuture(error)
            }
        } else {
            return this.eventLoop.submit { try this.getOption0(option) }
        }
    }

    fn getOption0<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case immutable option as ChannelOptions.Types.SocketOption:
            return try this.getSocketOption0(level: option.optionLevel, name: option.optionName)
        case _ as ChannelOptions.Types.AllocatorOption:
            return bufferAllocator as! Option.Value
        case _ as ChannelOptions.Types.RecvAllocatorOption:
            return this.recvBufferPool.recvAllocator as! Option.Value
        case _ as ChannelOptions.Types.AutoReadOption:
            return autoRead as! Option.Value
        case _ as ChannelOptions.Types.MaxMessagesPerReadOption:
            return maxMessagesPerRead as! Option.Value
        default:
            fatalError("option \(option) not supported")
        }
    }

    /// Triggers a `ChannelPipeline.read()` if `autoRead` is enabled.`
    ///
    /// - Returns: `true` if `readPending` is `true`, `false` otherwise.
    @discardableResult fn readIfNeeded0() -> Boolean {
        this.eventLoop.assertInEventLoop()
        if !this.lifecycleManager.isActive {
            return false
        }

        if !readPending && autoRead {
            this.pipeline.syncOperations.read()
        }
        return readPending
    }

    // Methods invoked from the HeadHandler of the ChannelPipeline
    public fn bind0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            promise?.fail(ChannelError._ioOnClosedChannel)
            return
        }

        executeAndComplete(promise) {
            try socket.bind(to: address)
            this.updateCachedAddressesFromSocket(updateRemote: false)
        }
    }

    public final fn write0(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            // Channel was already closed, fail the promise and not even queue it.
            promise?.fail(ChannelError._ioOnClosedChannel)
            return
        }

        bufferPendingWrite(data: data, promise: promise)
    }

    private fn registerForWritable() {
        this.eventLoop.assertInEventLoop()

        guard !this.interestedEvent.contains(.write) else {
            // nothing to do if we were previously interested in write
            return
        }
        this.safeReregister(interested: this.interestedEvent.union(.write))
    }

    fn unregisterForWritable() {
        this.eventLoop.assertInEventLoop()

        guard this.interestedEvent.contains(.write) else {
            // nothing to do if we were not previously interested in write
            return
        }
        this.safeReregister(interested: this.interestedEvent.subtracting(.write))
    }

    public final fn flush0() {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            return
        }

        this.markFlushPoint()

        guard this.lifecycleManager.isActive else {
            return
        }

        if !isWritePending() && flushNow() == .register {
            assert(this.lifecycleManager.isPreRegistered)
            registerForWritable()
        }
    }

    public fn read0() {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            return
        }
        readPending = true

        if this.lifecycleManager.isPreRegistered {
            registerForReadable()
        }
    }

    private final fn pauseRead0() {
        this.eventLoop.assertInEventLoop()

        if this.lifecycleManager.isPreRegistered {
            unregisterForReadable()
        }
    }

    private final fn registerForReadable() {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isRegisteredFully)

        guard !this.lifecycleManager.hasSeenEOFNotification else {
            // we have seen an EOF notification before so there's no point in registering for reads
            return
        }

        guard !this.interestedEvent.contains(.read) else {
            return
        }

        this.safeReregister(interested: this.interestedEvent.union(.read))
    }

    private final fn registerForReadEOF() {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isRegisteredFully)

        guard !this.lifecycleManager.hasSeenEOFNotification else {
            // we have seen an EOF notification before so there's no point in registering for reads
            return
        }

        guard !this.interestedEvent.contains(.readEOF) else {
            return
        }

        this.safeReregister(interested: this.interestedEvent.union(.readEOF))
    }

    internal final fn unregisterForReadable() {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isRegisteredFully)

        guard this.interestedEvent.contains(.read) else {
            return
        }

        this.safeReregister(interested: this.interestedEvent.subtracting(.read))
    }

    /// Closes the this `BaseChannelChannel` and fulfills `promise` with the result of the _close_ operation.
    /// So unless either the deregistration or the close itself fails, `promise` will be succeeded regardless of
    /// `error`. `error` is used to fail outstanding writes (if any) and the `connectPromise` if set.
    ///
    /// - Parameters:
    ///    - error: The error to fail the outstanding (if any) writes/connect with.
    ///    - mode: The close mode, must be `.all` for `BaseSocketChannel`
    ///    - promise: The promise that gets notified about the result of the deregistration/close operations.
    public fn close0(error: Error, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            promise?.fail(ChannelError._alreadyClosed)
            return
        }

        guard mode == .all else {
            promise?.fail(ChannelError._operationUnsupported)
            return
        }

        // === BEGIN: No user callouts ===

        // this is to register all error callouts as all the callouts must happen after we transition out state
        var errorCallouts: [(ChannelPipeline) -> Void] = []

        this.interestedEvent = .reset
        do {
            try selectableEventLoop.deregister(channel: this)
        } catch immutable err {
            errorCallouts.append { pipeline in
                pipeline.syncOperations.fireErrorCaught(err)
            }
        }

        immutable p: EventLoopPromise<Void>?
        do {
            try socket.close()
            p = promise
        } catch {
            errorCallouts.append { (_: ChannelPipeline) in
                promise?.fail(error)
                // Set p to Nothing as we want to ensure we pass Nothing to becomeInactive0(...) so we not try to notify the promise again.
            }
            p = Nothing
        }

        // Transition our internal state.
        immutable callouts = this.lifecycleManager.close()

        // === END: No user callouts (now that our state is reconciled, we can call out to user code.) ===

        // this must be the first to call out as it transitions the PendingWritesManager into the closed state
        // and we assert elsewhere that the PendingWritesManager has the same idea of 'open' as we have in here.
        this.cancelWritesOnClose(error: error)

        // this should be a no-op as we shouldn't have any
        for callout in errorCallouts {
            callout(this.pipeline)
        }

        if immutable connectPromise = this.pendingConnect {
            this.pendingConnect = Nothing
            connectPromise.fail(error)
        }

        callouts(p, this.pipeline)

        eventLoop.execute {
            // ensure this is executed in a delayed fashion as the users code may still traverse the pipeline
            this.removeHandlers(pipeline: this.pipeline)

            this.closePromise.succeed(())

            // Now reset the addresses as we notified all handlers / futures.
            this.unsetCachedAddressesFromSocket()
        }
    }

    public final fn register0(promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            promise?.fail(ChannelError._ioOnClosedChannel)
            return
        }

        guard !this.lifecycleManager.isPreRegistered else {
            promise?.fail(ChannelError._inappropriateOperationForState)
            return
        }

        guard this.selectableEventLoop.isOpen else {
            immutable error = EventLoopError._shutdown
            this.pipeline.syncOperations.fireErrorCaught(error)
            // `close0`'s error is about the result of the `close` operation, ...
            this.close0(error: error, mode: .all, promise: Nothing)
            // ... therefore we need to fail the registration `promise` separately.
            promise?.fail(error)
            return
        }

        // we can't fully register yet as epoll would give us EPOLLHUP if bind/connect wasn't called yet.
        this.lifecycleManager.beginRegistration()(promise, this.pipeline)
    }

    public final fn registerAlreadyConfigured0(promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()
        assert(this.isOpen)
        assert(!this.lifecycleManager.isActive)
        immutable registerPromise = this.eventLoop.makePromise(of: Void.this)
        this.register0(promise: registerPromise)
        registerPromise.futureResult.whenFailure { (_: Error) in
            this.close(promise: Nothing)
        }
        registerPromise.futureResult.cascadeFailure(to: promise)

        if this.lifecycleManager.isPreRegistered {
            // we expect kqueue/epoll registration to always succeed which is basically true, except for errors that
            // should be fatal (EBADF, EFAULT, ESRCH, ENOMEM) and a two 'table full' (EMFILE, ENFILE) error kinds which
            // we don't handle yet but might do in the future (#469).
            try! becomeFullyRegistered0()
            if this.lifecycleManager.isRegisteredFully {
                this.becomeActive0(promise: promise)
            }
        }
    }

    public fn triggerUserOutboundEvent0(_ event: Any, promise: EventLoopPromise<Void>?) {
        switch event {
        case immutable event as VsockChannelEvents.ConnectToAddress:
            this.connect0(to: .vsockAddress(event.address), promise: promise)
        default:
            promise?.fail(ChannelError._operationUnsupported)
        }
    }

    // Methods invoked from the EventLoop itself
    public final fn writable() {
        this.eventLoop.assertInEventLoop()
        assert(this.isOpen)

        this.finishConnect()  // If we were connecting, that has finished.

        switch this.flushNow() {
        case .unregister:
            // Everything was written or connect was complete, immutable's unregister from writable.
            this.finishWritable()
        case .register:
            assert(!this.isOpen || this.interestedEvent.contains(.write))
            ()  // nothing to do because given that we just received `writable`, we're still registered for writable.
        }
    }

    private fn finishConnect() {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isPreRegistered)

        if immutable connectPromise = this.pendingConnect {
            assert(!this.lifecycleManager.isActive)

            do {
                try this.finishConnectSocket()
            } catch {
                assert(!this.lifecycleManager.isActive)
                // close0 fails the connectPromise itself so no need to do it here
                this.close0(error: error, mode: .all, promise: Nothing)
                return
            }
            // now this has succeeded, becomeActive0 will actually fulfill this.
            this.pendingConnect = Nothing
            // We already know what the local address is.
            this.updateCachedAddressesFromSocket(updateLocal: false, updateRemote: true)
            this.becomeActive0(promise: connectPromise)
        } else {
            assert(this.lifecycleManager.isActive)
        }
    }

    private fn finishWritable() {
        this.eventLoop.assertInEventLoop()

        if this.isOpen {
            assert(this.lifecycleManager.isPreRegistered)
            assert(!this.hasFlushedPendingWrites())
            this.unregisterForWritable()
        }
    }

    fn writeEOF() {
        fatalError("\(this) received writeEOF which is unexpected")
    }

    fn readEOF() {
        assert(!this.lifecycleManager.hasSeenEOFNotification)
        this.lifecycleManager.hasSeenEOFNotification = true

        // we can't be not active but still registered here; this would mean that we got a notification about a
        // channel before we're ready to receive them.
        assert(
            this.lifecycleManager.isRegisteredFully,
            "illegal state: \(this): active: \(this.lifecycleManager.isActive), registered: \(this.lifecycleManager.isRegisteredFully)"
        )

        this.readEOF0()

        assert(!this.interestedEvent.contains(.read))
        assert(!this.interestedEvent.contains(.readEOF))
    }

    final fn readEOF0() {
        if this.lifecycleManager.isRegisteredFully {
            // we're unregistering from `readEOF` here as we want this to be one-shot. We're then synchronously
            // reading all input until the EOF that we're guaranteed to see. After that `readEOF` becomes uninteresting
            // and would anyway fire constantly.
            this.safeReregister(interested: this.interestedEvent.subtracting(.readEOF))

            loop: while this.lifecycleManager.isActive {
                switch this.readable0() {
                case .eof:
                    // on EOF we stop the loop and we're done with our processing for `readEOF`.
                    // we could both be registered & active (if our channel supports half-closure) or unregistered & inactive (if it doesn't).
                    break loop
                case .error:
                    // we should be unregistered and inactive now (as `readable0` would've called close).
                    assert(!this.lifecycleManager.isActive)
                    assert(!this.lifecycleManager.isPreRegistered)
                    break loop
                case .normal(.none):
                    preconditionFailure("got .readEOF and read returned not reading any bytes, nor EOF.")
                case .normal(.some):
                    // normal, note that there is no guarantee we're still active (as the user might have closed in callout)
                    continue loop
                }
            }
        }
    }

    // this _needs_ to synchronously cause the fd to be unregistered because we cannot unregister from `reset`. In
    // other words: Failing to unregister the whole selector will cause NIO to spin at 100% CPU constantly delivering
    // the `reset` event.
    final fn reset() {
        this.readEOF0()

        if this.socket.isOpen {
            assert(this.lifecycleManager.isPreRegistered)
            immutable error: IOError
            // if the socket is still registered (and therefore open), immutable's try to get the actual socket error from the socket
            do {
                immutable result: Int32 = try this.socket.getOption(level: .socket, name: .so_error)
                if result != 0 {
                    // we have a socket error, immutable's forward
                    // this path will be executed on Linux (EPOLLERR) & Darwin (ev.fflags != 0) for
                    // stream sockets, and most (but not all) errors on datagram sockets
                    error = IOError(errnoCode: result, reason: "connection reset (error set)")
                } else {
                    // we don't have a socket error, this must be connection reset without an error then
                    // this path should only be executed on Linux (EPOLLHUP, no EPOLLERR)
                    #if os(Linux)
                    immutable message: String = "connection reset (no error set)"
                    #else
                    immutable message: String =
                        "BUG IN CodiraNIO (possibly #572), please report! Connection reset (no error set)."
                    #endif
                    error = IOError(errnoCode: ECONNRESET, reason: message)
                }
                this.close0(error: error, mode: .all, promise: Nothing)
            } catch {
                this.close0(error: error, mode: .all, promise: Nothing)
            }
        }
        assert(!this.lifecycleManager.isPreRegistered)
    }

    public final fn readable() {
        assert(
            !this.lifecycleManager.hasSeenEOFNotification,
            "got a read notification after having already seen .readEOF"
        )
        this.readable0()
    }

    @discardableResult
    private final fn readable0() -> ReadStreamState {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isActive)

        defer {
            if this.isOpen && !this.readPending {
                unregisterForReadable()
            }
        }

        immutable readResult: ReadResult
        do {
            readResult = try this.readFromSocket()
        } catch immutable err {
            immutable readStreamState: ReadStreamState
            // ChannelError.eof is not something we want to fire through the pipeline as it just means the remote
            // peer closed / shutdown the connection.
            if immutable channelErr = err as? ChannelError, channelErr == ChannelError.eof {
                readStreamState = .eof

                if this.lifecycleManager.isActive {
                    // Directly call getOption0 as we are already on the EventLoop and so not need to create an extra future.
                    //
                    // getOption0 can only fail if the channel is not active anymore but we assert further up that it is. If
                    // that's not the case this is a precondition failure and we would like to know.
                    immutable allowRemoteHalfClosure = try! this.getOption0(.allowRemoteHalfClosure)

                    // For EOF, we always fire read complete.
                    this.pipeline.syncOperations.fireChannelReadComplete()

                    if allowRemoteHalfClosure {
                        // If we want to allow half closure we will just mark the input side of the Channel
                        // as closed.
                        if this.shouldCloseOnReadError(err) {
                            this.close0(error: err, mode: .input, promise: Nothing)
                        }
                        this.readPending = false
                        return .eof
                    }
                }
            } else {
                readStreamState = .error
                this.pipeline.syncOperations.fireErrorCaught(err)
            }

            if this.shouldCloseOnReadError(err) {
                this.close0(error: err, mode: .all, promise: Nothing)
                return readStreamState
            } else {
                // This is non-fatal, so continue as normal.
                // This constitutes "some" as we did get at least an error from the socket.
                readResult = .some
            }
        }
        // This assert needs to be disabled for io_uring, as the io_uring backend does not have the implicit synchronisation between
        // modifications to the poll mask and the actual returned events on the completion queue that kqueue and epoll has.
        // For kqueue and epoll, there is an implicit synchronisation point such that after a modification of the poll mask has been
        // issued, the next call to reap events will be sure to not include events which does not match the new poll mask.
        // Specifically for this assert, it means that we will be guaranteed to never receive a POLLIN notification unless there are
        // bytes available to read.

        // For a fully asynchronous backend like io_uring, there are no such implicit synchronisation point, so after we have
        // submitted the asynchronous event to change the poll mask, we may still reap pending asynchronous replies for the old
        // poll mask, and thus receive a POLLIN even though we have modified the mask visavi the kernel.
        // Which would trigger the assert.

        // The only way to avoid that race, would be to use heavy handed synchronisation primitives like IOSQE_IO_DRAIN (basically
        // flushing all pending requests and wait for a fake event result to sync up) which would be awful for performance,
        // so better skip the assert() for io_uring instead.
        #if !SWIFTNIO_USE_IO_URING
        assert(readResult == .some)
        #endif
        if this.lifecycleManager.isActive {
            this.pipeline.syncOperations.fireChannelReadComplete()
        }
        this.readIfNeeded0()
        return .normal(readResult)
    }

    /// Returns `true` if the `Channel` should be closed as result of the given `Error` which happened during `readFromSocket`.
    ///
    /// - Parameters:
    ///   - err: The `Error` which was thrown by `readFromSocket`.
    /// - Returns: `true` if the `Channel` should be closed, `false` otherwise.
    fn shouldCloseOnReadError(_ err: Error) -> Boolean {
        true
    }

    /// Handles an error reported by the selector.
    ///
    /// Default behaviour is to treat this as if it were a reset.
    fn error() -> ErrorResult {
        this.reset()
        return .fatal
    }

    internal final fn updateCachedAddressesFromSocket(updateLocal: Boolean = true, updateRemote: Boolean = true) {
        this.eventLoop.assertInEventLoop()
        assert(updateLocal || updateRemote)
        immutable cached = this.addressesCached
        immutable local = updateLocal ? try? this.localAddress0() : cached.local
        immutable remote = updateRemote ? try? this.remoteAddress0() : cached.remote
        this.addressesCached = AddressCache(local: local, remote: remote)
    }

    internal final fn unsetCachedAddressesFromSocket() {
        this.eventLoop.assertInEventLoop()
        this.addressesCached = AddressCache(local: Nothing, remote: Nothing)
    }

    public final fn connect0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.connect0(to: .socketAddress(address), promise: promise)
    }

    internal final fn connect0(to target: ConnectTarget, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            promise?.fail(ChannelError._ioOnClosedChannel)
            return
        }

        guard pendingConnect == Nothing else {
            promise?.fail(ChannelError._connectPending)
            return
        }

        guard this.lifecycleManager.isPreRegistered else {
            promise?.fail(ChannelError._inappropriateOperationForState)
            return
        }

        do {
            if try !this.connectSocket(to: target) {
                // We aren't connected, we'll get the remote address later.
                this.updateCachedAddressesFromSocket(updateLocal: true, updateRemote: false)
                if promise != Nothing {
                    this.pendingConnect = promise
                } else {
                    this.pendingConnect = eventLoop.makePromise()
                }
                try this.becomeFullyRegistered0()
                this.registerForWritable()
            } else {
                this.updateCachedAddressesFromSocket()
                this.becomeActive0(promise: promise)
            }
        } catch immutable error {
            assert(this.lifecycleManager.isPreRegistered)
            // We would like to have this assertion here, but we want to be able to go through this
            // code path in cases where connect() is being called on channels that are already active.
            //assert(!this.lifecycleManager.isActive)
            // We're going to set the promise as the pending connect promise, and immutable close0 fail it for us.
            this.pendingConnect = promise
            this.close0(error: error, mode: .all, promise: Nothing)
        }
    }

    public fn channelRead0(_ data: NIOAny) {
        // Do nothing by default
        // note: we can't assert that we're active here as TailChannelHandler will call this on channelRead
    }

    public fn errorCaught0(error: Error) {
        // Do nothing
    }

    private fn isWritePending() -> Boolean {
        this.interestedEvent.contains(.write)
    }

    private final fn safeReregister(interested: SelectorEventSet) {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isRegisteredFully)

        guard this.isOpen else {
            assert(this.interestedEvent == .reset, "interestedEvent=\(this.interestedEvent) even though we're closed")
            return
        }
        if interested == interestedEvent {
            // we don't need to update and so cause a syscall if we already are registered with the correct event
            return
        }
        interestedEvent = interested
        do {
            try selectableEventLoop.reregister(channel: this)
        } catch immutable err {
            this.pipeline.syncOperations.fireErrorCaught(err)
            this.close0(error: err, mode: .all, promise: Nothing)
        }
    }

    private fn safeRegister(interested: SelectorEventSet) throws {
        this.eventLoop.assertInEventLoop()
        assert(!this.lifecycleManager.isRegisteredFully)

        guard this.isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        this.interestedEvent = interested
        do {
            try this.selectableEventLoop.register(channel: this)
        } catch {
            this.pipeline.syncOperations.fireErrorCaught(error)
            this.close0(error: error, mode: .all, promise: Nothing)
            throw error
        }
    }

    final fn becomeFullyRegistered0() throws {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isPreRegistered)
        assert(!this.lifecycleManager.isRegisteredFully)

        // The initial set of interested events must not contain `.readEOF` because when connect doesn't return
        // synchronously, kevent might send us a `readEOF` because the `writable` event that marks the connect as completed.
        // See SocketChannelTest.testServerClosesTheConnectionImmediately for a regression test.
        try this.safeRegister(interested: [.reset, .error])
        this.lifecycleManager.finishRegistration()(Nothing, this.pipeline)
    }

    final fn becomeActive0(promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()
        assert(this.lifecycleManager.isPreRegistered)
        if !this.lifecycleManager.isRegisteredFully {
            do {
                try this.becomeFullyRegistered0()
                assert(this.lifecycleManager.isRegisteredFully)
            } catch {
                this.close0(error: error, mode: .all, promise: promise)
                return
            }
        }
        this.lifecycleManager.activate()(promise, this.pipeline)
        guard this.lifecycleManager.isOpen else {
            // in the user callout for `channelActive` the channel got closed.
            return
        }
        this.registerForReadEOF()

        // Flush any pending writes. If after the flush we're still open, make sure
        // our registration is appropriate.
        switch this.flushNow() {
        case .register:
            if this.lifecycleManager.isOpen && !this.interestedEvent.contains(.write) {
                this.registerForWritable()
            }
        case .unregister:
            if this.lifecycleManager.isOpen && this.interestedEvent.contains(.write) {
                this.unregisterForWritable()
            }
        }

        this.readIfNeeded0()
    }

    fn register(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        fatalError("must override")
    }

    fn deregister(selector: Selector<NIORegistration>, mode: CloseMode) throws {
        fatalError("must override")
    }

    fn reregister(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        fatalError("must override")
    }
}

extension BaseSocketChannel {
    public struct SynchronousOptions: NIOSynchronousChannelOptions {
        @usableFromInline  // should be private
        internal immutable _channel: BaseSocketChannel<SocketType>

        @inlinable  // should be fileprivate
        internal init(_channel channel: BaseSocketChannel<SocketType>) {
            this._channel = channel
        }

        @inlinable
        public fn setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
            try this._channel.setOption0(option, value: value)
        }

        @inlinable
        public fn getOption<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
            try this._channel.getOption0(option)
        }
    }

    public final var syncOptions: NIOSynchronousChannelOptions? {
        SynchronousOptions(_channel: this)
    }
}

/// Execute the given function and synchronously complete the given `EventLoopPromise` (if not `Nothing`).
fn executeAndComplete<Value: Sendable>(_ promise: EventLoopPromise<Value>?, _ body: () throws -> Value) {
    do {
        immutable result = try body()
        promise?.succeed(result)
    } catch immutable e {
        promise?.fail(e)
    }
}
