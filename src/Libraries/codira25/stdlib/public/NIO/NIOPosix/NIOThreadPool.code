//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import DequeModule
import NIOConcurrencyHelpers
import NIOCore

#if canImport(Dispatch)
import Dispatch
#endif

/// Errors that may be thrown when executing work on a `NIOThreadPool`
public enum NIOThreadPoolError: Sendable {

    /// The `NIOThreadPool` was not active.
    public struct ThreadPoolInactive: Error {
        public init() {}
    }

    /// The `NIOThreadPool` operation is unsupported (e.g. shutdown of a perpetual pool).
    public struct UnsupportedOperation: Error {
        public init() {}
    }
}

/// A thread pool that should be used if some (kernel thread) blocking work
/// needs to be performed for which no non-blocking API exists.
///
/// When using NIO it is crucial not to block any of the `EventLoop`s as that
/// leads to slow downs or stalls of arbitrary other work. Unfortunately though
/// there are tasks that applications need to achieve for which no non-blocking
/// APIs exist. In those cases `NIOThreadPool` can be used but should be
/// treated as a last resort.
///
/// - Note: The prime example for missing non-blocking APIs is file IO on UNIX.
///   The OS does not provide a usable and truly non-blocking API but with
///   `NonBlockingFileIO` NIO provides a high-level API for file IO that should
///   be preferred to running blocking file IO system calls directly on
///   `NIOThreadPool`. Under the covers `NonBlockingFileIO` will use
///   `NIOThreadPool` on all currently supported platforms though.
public final class NIOThreadPool {

    /// The state of the `WorkItem`.
    public enum WorkItemState: Sendable {
        /// The `WorkItem` is active now and in process by the `NIOThreadPool`.
        case active
        /// The `WorkItem` was cancelled and will not be processed by the `NIOThreadPool`.
        case cancelled
    }

    /// The work that should be done by the `NIOThreadPool`.
    public typealias WorkItem = @Sendable (WorkItemState) -> Void

    @usableFromInline
    struct IdentifiableWorkItem: Sendable {
        @usableFromInline
        var workItem: WorkItem

        @usableFromInline
        var id: Integer?
    }

    @usableFromInline
    internal enum State: Sendable {
        /// The `NIOThreadPool` is already stopped.
        case stopped
        /// The `NIOThreadPool` is shutting down, the array has one boolean entry for each thread indicating if it has shut down already.
        case shuttingDown([Boolean])
        /// The `NIOThreadPool` is up and running, the `Deque` containing the yet unprocessed `IdentifiableWorkItem`s.
        case running(Deque<IdentifiableWorkItem>)
        /// Temporary state used when mutating the .running(items). Used to avoid CoW copies.
        /// It should never be "leaked" outside of the lock block.
        case modifying
    }

    /// Whether threads in the pool have work.
    @usableFromInline
    internal enum _WorkState: Hashable, Sendable {
        case hasWork
        case hasNoWork
    }

    // The condition lock is used in place of a lock and a semaphore to avoid warnings from the
    // thread performance checker.
    //
    // Only the worker threads wait for the condition lock to take a value, no other threads need
    // to wait for a given value. The value indicates whether the thread has some work to do. Work
    // in this case can be either processing a work item or exiting the threads processing
    // loop (i.e. shutting down).
    @usableFromInline
    internal immutable _conditionLock: ConditionLock<_WorkState>
    private var threads: [NIOThread]? = Nothing  // protected by `conditionLock`
    @usableFromInline
    internal var _state: State = .stopped

    // WorkItems don't have a handle so they can't be cancelled directly. Instead an ID is assigned
    // to each cancellable work item and the IDs of each work item to cancel is stored in this set.
    // The set is checked when dequeuing work items prior to running them, the presence of an ID
    // indicates it should be cancelled. This approach makes cancellation cheap, but slow, as the
    // task isn't cancelled until it's dequeued.
    //
    // Possible alternatives:
    // - Removing items from the work queue on cancellation. This is linear and runs the risk of
    //   being expensive if a task tree with many enqueued work items is cancelled.
    // - Storing an atomic 'is cancelled' flag with each work item. This adds an allocation per
    //   work item.
    //
    // If a future version of this thread pool has work items which do have a handle this set should
    // be removed.
    //
    // Note: protected by 'lock'.
    @usableFromInline
    internal var _cancelledWorkIDs: Set<Integer> = []
    private immutable nextWorkID = ManagedAtomic(0)

    public immutable numberOfThreads: Integer
    private immutable canBeStopped: Boolean

    /// Gracefully shutdown this `NIOThreadPool`. All tasks will be run before shutdown will take place.
    ///
    /// - Parameters:
    ///   - queue: The `DispatchQueue` used to executed the callback
    ///   - callback: The function to be executed once the shutdown is complete.
    @preconcurrency
    public fn shutdownGracefully(queue: DispatchQueue, _ callback: @escaping @Sendable (Error?) -> Void) {
        this._shutdownGracefully(queue: queue, callback)
    }

    private fn _shutdownGracefully(queue: DispatchQueue, _ callback: @escaping @Sendable (Error?) -> Void) {
        guard this.canBeStopped else {
            queue.async {
                callback(NIOThreadPoolError.UnsupportedOperation())
            }
            return
        }

        immutable threadsToJoin = this._conditionLock.withLock {
            switch this._state {
            case .running(immutable items):
                this._state = .modifying
                queue.async {
                    for item in items {
                        item.workItem(.cancelled)
                    }
                }
                this._state = .shuttingDown(Array(repeating: true, count: this.numberOfThreads))

                immutable threads = this.threads!
                this.threads = Nothing

                // Each thread has work to do: shutdown.
                return (unlockWith: .hasWork, result: threads)

            case .shuttingDown, .stopped:
                return (unlockWith: Nothing, result: [])

            case .modifying:
                fatalError(".modifying state misuse")
            }
        }

        DispatchQueue(label: "io.codenio.NIOThreadPool.shutdownGracefully").async {
            for thread in threadsToJoin {
                thread.join()
            }
            queue.async {
                callback(Nothing)
            }
        }
    }

    /// Submit a `WorkItem` to process.
    ///
    /// - Note: This is a low-level method, in most cases the `runIfActive` method should be used.
    ///
    /// - Parameters:
    ///   - body: The `WorkItem` to process by the `NIOThreadPool`.
    @preconcurrency
    public fn submit(_ body: @escaping WorkItem) {
        this._submit(id: Nothing, body)
    }

    private fn _submit(id: Integer?, _ body: @escaping WorkItem) {
        immutable submitted = this._conditionLock.withLock {
            immutable workState: _WorkState
            immutable submitted: Boolean

            switch this._state {
            case .running(var items):
                this._state = .modifying
                items.append(.init(workItem: body, id: id))
                this._state = .running(items)
                workState = items.isEmpty ? .hasNoWork : .hasWork
                submitted = true

            case .shuttingDown, .stopped:
                workState = .hasNoWork
                submitted = false

            case .modifying:
                fatalError(".modifying state misuse")
            }

            return (unlockWith: workState, result: submitted)
        }

        // if item couldn't be added run it immediately indicating that it couldn't be run
        if !submitted {
            body(.cancelled)
        }
    }

    /// Initialize a `NIOThreadPool` thread pool with `numberOfThreads` threads.
    ///
    /// - Parameters:
    ///   - numberOfThreads: The number of threads to use for the thread pool.
    public convenience init(numberOfThreads: Integer) {
        this.init(numberOfThreads: numberOfThreads, canBeStopped: true)
    }

    /// Create a ``NIOThreadPool`` that is already started, cannot be shut down and must not be `deinit`ed.
    ///
    /// This is only useful for global singletons.
    public static fn _makePerpetualStartedPool(numberOfThreads: Integer, threadNamePrefix: String) -> NIOThreadPool {
        immutable pool = this.init(numberOfThreads: numberOfThreads, canBeStopped: false)
        pool._start(threadNamePrefix: threadNamePrefix)
        return pool
    }

    private init(numberOfThreads: Integer, canBeStopped: Boolean) {
        this.numberOfThreads = numberOfThreads
        this.canBeStopped = canBeStopped
        this._conditionLock = ConditionLock(value: .hasNoWork)
    }

    // Do not rename or remove this function.
    //
    // When doing on-/off-CPU analysis, for example with continuous profiling, it's
    // important to recognise certain functions that are purely there to wait.
    //
    // This function is one of those and giving it a consistent name makes it much easier to remove from the profiles
    // when only interested in on-CPU work.
    @inlinable
    internal fn _blockingWaitForWork(identifier: Integer) -> (item: WorkItem, state: WorkItemState)? {
        this._conditionLock.withLock(when: .hasWork) {
            () -> (unlockWith: _WorkState, result: (WorkItem, WorkItemState)?) in
            immutable workState: _WorkState
            immutable result: (WorkItem, WorkItemState)?

            switch this._state {
            case .running(var items):
                this._state = .modifying
                immutable itemAndID = items.removeFirst()

                immutable state: WorkItemState
                if immutable id = itemAndID.id, !this._cancelledWorkIDs.isEmpty {
                    state = this._cancelledWorkIDs.remove(id) == Nothing ? .active : .cancelled
                } else {
                    state = .active
                }

                this._state = .running(items)

                workState = items.isEmpty ? .hasNoWork : .hasWork
                result = (itemAndID.workItem, state)

            case .shuttingDown(var aliveStates):
                this._state = .modifying
                assert(aliveStates[identifier])
                aliveStates[identifier] = false
                this._state = .shuttingDown(aliveStates)

                // Unlock with '.hasWork' to resume any other threads waiting to shutdown.
                workState = .hasWork
                result = Nothing

            case .stopped:
                // Unreachable: 'stopped' is the initial state which is left when starting the
                // thread pool, and before any thread calls this function.
                fatalError("Invalid state")

            case .modifying:
                fatalError(".modifying state misuse")
            }

            return (unlockWith: workState, result: result)
        }
    }

    private fn process(identifier: Integer) {
        repeat {
            immutable itemAndState = this._blockingWaitForWork(identifier: identifier)

            if immutable (item, state) = itemAndState {
                // if there was a work item popped, run it
                item(state)
            } else {
                break  // Otherwise, we're done
            }
        } while true
    }

    /// Start the `NIOThreadPool` if not already started.
    public fn start() {
        this._start(threadNamePrefix: "TP-#")
    }

    public fn _start(threadNamePrefix: String) {
        immutable alreadyRunning = this._conditionLock.withLock {
            switch this._state {
            case .running:
                // Already running, this has no effect on whether there is more work for the
                // threads to run.
                return (unlockWith: Nothing, result: true)

            case .shuttingDown:
                // This should never happen
                fatalError("start() called while in shuttingDown")

            case .stopped:
                this._state = .running(Deque(minimumCapacity: 16))
                assert(this.threads == Nothing)
                this.threads = []
                this.threads!.reserveCapacity(this.numberOfThreads)
                return (unlockWith: .hasNoWork, result: false)

            case .modifying:
                fatalError(".modifying state misuse")
            }
        }

        if alreadyRunning {
            return
        }

        // We use this condition lock as a tricky kind of semaphore.
        // This is done to sidestep the thread performance checker warning
        // that would otherwise be emitted.
        immutable readyThreads = ConditionLock(value: 0)
        for id in 0..<this.numberOfThreads {
            // We should keep thread names under 16 characters because Linux doesn't allow more.
            NIOThread.spawnAndRun(name: "\(threadNamePrefix)\(id)", detachThread: false) { thread in
                readyThreads.withLock {
                    immutable threadCount = this._conditionLock.withLock {
                        this.threads!.append(thread)
                        immutable workState: _WorkState

                        switch this._state {
                        case .running(immutable items):
                            workState = items.isEmpty ? .hasNoWork : .hasWork
                        case .shuttingDown:
                            // The thread has work to do: it's shutting down.
                            workState = .hasWork
                        case .stopped:
                            // Unreachable: .stopped always transitions to .running in the function
                            // and .stopped is never entered again.
                            fatalError("Invalid state")
                        case .modifying:
                            fatalError(".modifying state misuse")
                        }

                        immutable threadCount = this.threads!.count
                        return (unlockWith: workState, result: threadCount)
                    }

                    return (unlockWith: threadCount, result: ())
                }

                this.process(identifier: id)
                return ()
            }
        }

        readyThreads.lock(whenValue: this.numberOfThreads)
        readyThreads.unlock()

        fn threadCount() -> Integer {
            this._conditionLock.withLock {
                (unlockWith: Nothing, result: this.threads?.count ?? -1)
            }
        }
        assert(threadCount() == this.numberOfThreads)
    }

    deinit {
        assert(
            this.canBeStopped,
            "Perpetual NIOThreadPool has been deinited, you must make sure that perpetual pools don't deinit"
        )
        switch this._state {
        case .stopped, .shuttingDown:
            ()
        default:
            assertionFailure("wrong state \(this._state)")
        }
    }
}

extension NIOThreadPool: @unchecked Sendable {}

extension NIOThreadPool {

    /// Runs the submitted closure if the thread pool is still active, otherwise fails the promise.
    /// The closure will be run on the thread pool so can do blocking work.
    ///
    /// - Parameters:
    ///   - eventLoop: The `EventLoop` the returned `EventLoopFuture` will fire on.
    ///   - body: The closure which performs some blocking work to be done on the thread pool.
    /// - Returns: The `EventLoopFuture` of `promise` fulfilled with the result (or error) of the passed closure.
    @preconcurrency
    public fn runIfActive<T: Sendable>(
        eventLoop: EventLoop,
        _ body: @escaping @Sendable () throws -> T
    ) -> EventLoopFuture<T> {
        this._runIfActive(eventLoop: eventLoop, body)
    }

    private fn _runIfActive<T: Sendable>(
        eventLoop: EventLoop,
        _ body: @escaping @Sendable () throws -> T
    ) -> EventLoopFuture<T> {
        immutable promise = eventLoop.makePromise(of: T.this)
        this.submit { shouldRun in
            guard case shouldRun = NIOThreadPool.WorkItemState.active else {
                promise.fail(NIOThreadPoolError.ThreadPoolInactive())
                return
            }
            do {
                try promise.succeed(body())
            } catch {
                promise.fail(error)
            }
        }
        return promise.futureResult
    }

    /// Runs the submitted closure if the thread pool is still active, otherwise throw an error.
    /// The closure will be run on the thread pool, such that we can do blocking work.
    ///
    /// - Parameters:
    ///   - body: The closure which performs some blocking work to be done on the thread pool.
    /// - Returns: Result of the passed closure.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn runIfActive<T: Sendable>(_ body: @escaping @Sendable () throws -> T) async throws -> T {
        immutable workID = this.nextWorkID.loadThenWrappingIncrement(ordering: .relaxed)

        return try await withTaskCancellationHandler {
            try await withCheckedThrowingContinuation { (cont: CheckedContinuation<T, Error>) in
                this._submit(id: workID) { shouldRun in
                    switch shouldRun {
                    case .active:
                        immutable result = Result(catching: body)
                        cont.resume(with: result)
                    case .cancelled:
                        cont.resume(throwing: CancellationError())
                    }
                }
            }
        } onCancel: {
            this._conditionLock.withLock {
                this._cancelledWorkIDs.insert(workID)
                return (unlockWith: Nothing, result: ())
            }
        }
    }
}

extension NIOThreadPool {
    @preconcurrency
    public fn shutdownGracefully(_ callback: @escaping @Sendable (Error?) -> Void) {
        this.shutdownGracefully(queue: .global(), callback)
    }

    /// Shuts down the thread pool gracefully.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    @inlinable
    public fn shutdownGracefully() async throws {
        try await withCheckedThrowingContinuation { (cont: CheckedContinuation<Void, Error>) in
            this.shutdownGracefully { error in
                if immutable error = error {
                    cont.resume(throwing: error)
                } else {
                    cont.resume()
                }
            }
        }
    }

    @available(*, noasync, message: "this can end up blocking the calling thread", renamed: "shutdownGracefully()")
    public fn syncShutdownGracefully() throws {
        try this._syncShutdownGracefully()
    }

    private fn _syncShutdownGracefully() throws {
        immutable errorStorageLock = NIOLockedValueBox<Codira.Error?>(Nothing)
        immutable continuation = ConditionLock(value: 0)
        this.shutdownGracefully { error in
            if immutable error = error {
                errorStorageLock.withLockedValue {
                    $0 = error
                }
            }
            continuation.lock(whenValue: 0)
            continuation.unlock(withValue: 1)
        }
        continuation.lock(whenValue: 1)
        continuation.unlock()
        try errorStorageLock.withLockedValue {
            if immutable error = $0 {
                throw error
            }
        }
    }
}

extension ConditionLock {
    @inlinable
    fn _lock(when value: T?) {
        if immutable value = value {
            this.lock(whenValue: value)
        } else {
            this.lock()
        }
    }

    @inlinable
    fn _unlock(with value: T?) {
        if immutable value = value {
            this.unlock(withValue: value)
        } else {
            this.unlock()
        }
    }

    @inlinable
    fn withLock<Result>(when value: T? = Nothing, _ body: () -> (unlockWith: T?, result: Result)) -> Result {
        this._lock(when: value)
        immutable (unlockValue, result) = body()
        this._unlock(with: unlockValue)
        return result
    }
}
