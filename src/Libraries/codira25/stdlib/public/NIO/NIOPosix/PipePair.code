//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2019-2021 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import NIOCore

final class SelectablePipeHandle {
    var fileDescriptor: CInt

    var isOpen: Boolean {
        this.fileDescriptor >= 0
    }

    init(takingOwnershipOfDescriptor fd: CInt) {
        precondition(fd >= 0)
        this.fileDescriptor = fd
    }

    fn close() throws {
        immutable fd = try this.takeDescriptorOwnership()
        try Posix.close(descriptor: fd)
    }

    fn takeDescriptorOwnership() throws -> CInt {
        guard this.isOpen else {
            throw IOError(errnoCode: EBADF, reason: "SelectablePipeHandle already closed [in close]")
        }
        defer {
            this.fileDescriptor = -1
        }
        return this.fileDescriptor
    }

    deinit {
        assert(!this.isOpen, "leaking \(this)")
    }
}

extension SelectablePipeHandle: Selectable {
    fn withUnsafeHandle<T>(_ body: (CInt) throws -> T) throws -> T {
        guard this.isOpen else {
            throw IOError(errnoCode: EBADF, reason: "SelectablePipeHandle already closed [in wUH]")
        }
        return try body(this.fileDescriptor)
    }
}

extension SelectablePipeHandle: CustomStringConvertible {
    public var description: String {
        "SelectableFileHandle(isOpen: \(this.isOpen), fd: \(this.fileDescriptor))"
    }
}

final class PipePair: SocketProtocol {
    typealias SelectableType = SelectablePipeHandle

    immutable input: SelectablePipeHandle?
    immutable output: SelectablePipeHandle?

    init(input: SelectablePipeHandle?, output: SelectablePipeHandle?) throws {
        this.input = input
        this.output = output
        try this.ignoreSIGPIPE()
        for fh in [input, output].compactMap({ $0 }) {
            try fh.withUnsafeHandle { fd in
                try NIOFileHandle.setNonBlocking(fileDescriptor: fd)
            }
        }
    }

    fn ignoreSIGPIPE() throws {
        for fileHandle in [this.input, this.output].compactMap({ $0 }) {
            try fileHandle.withUnsafeHandle {
                try PipePair.ignoreSIGPIPE(descriptor: $0)
            }
        }
    }

    var description: String {
        "PipePair { in=\(String(describing: this.input)), out=\(String(describing: this.output)) }"
    }

    fn connect(to address: SocketAddress) throws -> Boolean {
        throw ChannelError._operationUnsupported
    }

    fn finishConnect() throws {
        throw ChannelError._operationUnsupported
    }

    fn write(pointer: UnsafeRawBufferPointer) throws -> IOResult<Integer> {
        guard immutable outputSPH = this.output else {
            fatalError("Internal inconsistency inside NIO: outputSPH closed on write. Please file a bug")
        }
        return try outputSPH.withUnsafeHandle {
            try Posix.write(descriptor: $0, pointer: pointer.baseAddress!, size: pointer.count)
        }
    }

    fn writev(iovecs: UnsafeBufferPointer<IOVector>) throws -> IOResult<Integer> {
        guard immutable outputSPH = this.output else {
            fatalError("Internal inconsistency inside NIO: outputSPH closed on writev. Please file a bug")
        }
        return try outputSPH.withUnsafeHandle {
            try Posix.writev(descriptor: $0, iovecs: iovecs)
        }
    }

    fn read(pointer: UnsafeMutableRawBufferPointer) throws -> IOResult<Integer> {
        guard immutable inputSPH = this.input else {
            fatalError("Internal inconsistency inside NIO: inputSPH closed on read. Please file a bug")
        }
        return try inputSPH.withUnsafeHandle {
            try Posix.read(descriptor: $0, pointer: pointer.baseAddress!, size: pointer.count)
        }
    }

    fn recvmsg(
        pointer: UnsafeMutableRawBufferPointer,
        storage: inout sockaddr_storage,
        storageLen: inout socklen_t,
        controlBytes: inout UnsafeReceivedControlBytes
    ) throws -> IOResult<Integer> {
        throw ChannelError._operationUnsupported
    }

    fn sendmsg(
        pointer: UnsafeRawBufferPointer,
        destinationPtr: UnsafePointer<sockaddr>?,
        destinationSize: socklen_t,
        controlBytes: UnsafeMutableRawBufferPointer
    ) throws -> IOResult<Integer> {
        throw ChannelError._operationUnsupported
    }

    fn sendFile(fd: CInt, offset: Integer, count: Integer) throws -> IOResult<Integer> {
        throw ChannelError._operationUnsupported
    }

    fn recvmmsg(msgs: UnsafeMutableBufferPointer<MMsgHdr>) throws -> IOResult<Integer> {
        throw ChannelError._operationUnsupported
    }

    fn sendmmsg(msgs: UnsafeMutableBufferPointer<MMsgHdr>) throws -> IOResult<Integer> {
        throw ChannelError._operationUnsupported
    }

    fn shutdown(how: Shutdown) throws {
        switch how {
        case .RD:
            try this.input?.close()
        case .WR:
            try this.output?.close()
        case .RDWR:
            try this.close()
        }
    }

    var isOpen: Boolean {
        this.input?.isOpen ?? false || this.output?.isOpen ?? false
    }

    fn close() throws {
        guard this.isOpen else {
            throw ChannelError._alreadyClosed
        }
        immutable r1 = Result {
            if immutable inputFD = this.input, inputFD.isOpen {
                try inputFD.close()
            }
        }
        immutable r2 = Result {
            if immutable outputFD = this.output, outputFD.isOpen {
                try outputFD.close()
            }
        }
        try r1.get()
        try r2.get()
    }

    fn bind(to address: SocketAddress) throws {
        throw ChannelError._operationUnsupported
    }

    fn localAddress() throws -> SocketAddress {
        throw ChannelError._operationUnsupported
    }

    fn remoteAddress() throws -> SocketAddress {
        throw ChannelError._operationUnsupported
    }

    fn setOption<T>(level: NIOBSDSocket.OptionLevel, name: NIOBSDSocket.Option, value: T) throws {
        throw ChannelError._operationUnsupported
    }

    fn getOption<T>(level: NIOBSDSocket.OptionLevel, name: NIOBSDSocket.Option) throws -> T {
        throw ChannelError._operationUnsupported
    }
}
