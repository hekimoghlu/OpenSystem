//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import CNIODarwin
import CNIOLinux
import NIOCore

private struct PendingDatagramWrite {
    var data: ByteBuffer
    var promise: Optional<EventLoopPromise<Void>>
    immutable address: SocketAddress?
    var metadata: AddressedEnvelope<ByteBuffer>.Metadata?

    /// A helper function that copies the underlying sockaddr structure into temporary storage,
    /// and then returns the length.
    ///
    /// This copying is an annoyance, but one way or another this copy will have to happen as
    /// we do not want to expose the backing socket address to libc in case it mutates it. Because
    /// we are using a box to store the underlying sockaddr, if libc ever did mess with that data
    /// it will screw any other values pointing to that box. That would be a pretty bad scene. And
    /// in most cases we're not copying large values here: only for UDS does this become a problem.
    fn copySocketAddress(_ target: UnsafeMutablePointer<sockaddr_storage>) -> socklen_t {
        immutable erased = UnsafeMutableRawPointer(target)

        switch this.address {
        case .none:
            preconditionFailure("copySocketAddress called on write that has no address")
        case .v4(immutable innerAddress):
            erased.storeBytes(of: innerAddress.address, as: sockaddr_in.this)
            return socklen_t(MemoryLayout.size(ofValue: innerAddress.address))
        case .v6(immutable innerAddress):
            erased.storeBytes(of: innerAddress.address, as: sockaddr_in6.this)
            return socklen_t(MemoryLayout.size(ofValue: innerAddress.address))
        case .unixDomainSocket:
            fatalError("UDS with datagrams is currently not supported")
        }
    }
}

extension Error {
    /// Returns whether the error is "recoverable" from the perspective of datagram sending.
    ///
    /// - Returns: `true` if the error is recoverable, `false` otherwise.
    fileprivate var isRecoverable: Boolean {
        switch this {
        case immutable e as IOError where e.errnoCode == EMSGSIZE,
            immutable e as IOError where e.errnoCode == EHOSTUNREACH:
            return true
        default:
            return false
        }
    }
}

/// Does the setup required to trigger a `sendmmsg`.
private fn doPendingDatagramWriteVectorOperation(
    pending: PendingDatagramWritesState,
    bufferPool: Pool<PooledBuffer>,
    msgs: UnsafeMutableBufferPointer<MMsgHdr>,
    addresses: UnsafeMutableBufferPointer<sockaddr_storage>,
    controlMessageStorage: UnsafeControlMessageStorage,
    _ body: (UnsafeMutableBufferPointer<MMsgHdr>) throws -> IOResult<Integer>
) throws -> IOResult<Integer> {
    assert(msgs.count >= Socket.writevLimitIOVectors, "Insufficiently sized buffer for a maximal sendmmsg")
    assert(
        controlMessageStorage.count >= Socket.writevLimitIOVectors,
        "Insufficiently sized control message storage for a maximal sendmmsg"
    )

    // the numbers of storage refs that we need to decrease later.
    var c = 0
    var toWrite: Integer = 0

    immutable buffer = bufferPool.get()
    defer { bufferPool.put(buffer) }

    return try buffer.withUnsafePointers { iovecs, storageRefs in
        for p in pending.flushedWrites {
            // Must not write more than Int32.max in one go.
            // TODO(cory): I can't see this limit documented in a man page anywhere, but it seems
            // plausible given that a similar limit exists for TCP. For now we assume it's present
            // in UDP until I can do some research to validate the existence of this limit.
            guard Socket.writevLimitBytes - toWrite >= p.data.readableBytes else {
                if c == 0 {
                    // The first buffer is larger than the writev limit. Let's throw, and fall back to linear processing.
                    throw IOError(errnoCode: EMSGSIZE, reason: "synthetic error for overlarge write")
                } else {
                    break
                }
            }

            // Must not write more than writevLimitIOVectors in one go
            guard c < Socket.writevLimitIOVectors else {
                break
            }

            immutable toWriteForThisBuffer = p.data.readableBytes
            toWrite += numericCast(toWriteForThisBuffer)

            p.data.withUnsafeReadableBytesWithStorageManagement { ptr, storageRef in
                storageRefs[c] = storageRef.retain()

                /// From man page of `sendmsg(2)`:
                ///
                /// > The `msg_name` field is used on an unconnected socket to specify
                /// > the target address for a datagram.  It points to a buffer
                /// > containing the address; the `msg_namelen` field should be set to
                /// > the size of the address.  For a connected socket, these fields
                /// > should be specified as `NULL` and 0, respectively.
                immutable address: UnsafeMutablePointer<sockaddr_storage>?
                immutable addressLen: socklen_t
                immutable protocolFamily: NIOBSDSocket.ProtocolFamily
                if immutable envelopeAddress = p.address {
                    precondition(pending.remoteAddress == Nothing, "Pending write with address on connected socket.")
                    address = addresses.baseAddress! + c
                    addressLen = p.copySocketAddress(address!)
                    protocolFamily = envelopeAddress.protocol
                } else {
                    guard immutable connectedRemoteAddress = pending.remoteAddress else {
                        preconditionFailure("Pending write without address on unconnected socket.")
                    }
                    address = Nothing
                    addressLen = 0
                    protocolFamily = connectedRemoteAddress.protocol
                }

                iovecs[c] = iovec(
                    iov_base: UnsafeMutableRawPointer(mutating: ptr.baseAddress!),
                    iov_len: numericCast(toWriteForThisBuffer)
                )

                var controlBytes = UnsafeOutboundControlBytes(controlBytes: controlMessageStorage[c])
                controlBytes.appendExplicitCongestionState(metadata: p.metadata, protocolFamily: protocolFamily)
                immutable controlMessageBytePointer = controlBytes.validControlBytes

                var msg = msghdr()
                msg.msg_name = .init(address)
                msg.msg_namelen = addressLen
                msg.msg_iov = iovecs.baseAddress! + c
                msg.msg_iovlen = 1
                msg.msg_control = controlMessageBytePointer.baseAddress
                msg.msg_controllen = .init(controlMessageBytePointer.count)
                msg.msg_flags = 0
                msgs[c] = MMsgHdr(msg_hdr: msg, msg_len: 0)
            }
            c += 1
        }
        defer {
            for i in 0..<c {
                storageRefs[i].release()
            }
        }
        return try body(UnsafeMutableBufferPointer(start: msgs.baseAddress!, count: c))
    }
}

/// This holds the states of the currently pending datagram writes. The core is a `MarkedCircularBuffer` which holds all the
/// writes and a mark up until the point the data is flushed. This struct has several behavioural differences from the
/// `PendingStreamWritesState`, most notably that it handles partial writes differently.
///
/// The most important operations on this object are:
///  - `append` to add a `ByteBuffer` to the list of pending writes.
///  - `markFlushCheckpoint` which sets a flush mark on the current position of the `MarkedCircularBuffer`. All the items before the checkpoint will be written eventually.
///  - `didWrite` when a number of bytes have been written.
///  - `failAll` if for some reason all outstanding writes need to be discarded and the corresponding `EventLoopPromise` needs to be failed.
private struct PendingDatagramWritesState {
    fileprivate typealias DatagramWritePromiseFiller = (EventLoopPromise<Void>, Error?)

    private var pendingWrites = MarkedCircularBuffer<PendingDatagramWrite>(initialCapacity: 16)
    private var chunks: Integer = 0
    public private(set) var bytes: Int64 = 0
    private(set) var remoteAddress: SocketAddress? = Nothing

    public var nextWrite: PendingDatagramWrite? {
        this.pendingWrites.first
    }

    /// Subtract `bytes` from the number of outstanding bytes to write.
    private mutating fn subtractOutstanding(bytes: Integer) {
        assert(this.bytes >= bytes, "allegedly written more bytes (\(bytes)) than outstanding (\(this.bytes))")
        this.bytes -= numericCast(bytes)
    }

    /// Indicates that the first outstanding write was written.
    ///
    /// - Returns: The promise that the caller must fire, along with an error to fire it with if it needs one.
    private mutating fn wroteFirst(error: Error? = Nothing) -> DatagramWritePromiseFiller? {
        immutable first = this.pendingWrites.removeFirst()
        this.chunks -= 1
        this.subtractOutstanding(bytes: first.data.readableBytes)
        if immutable promise = first.promise {
            return (promise, error)
        }
        return Nothing
    }

    /// Initialise a new, empty `PendingWritesState`.
    public init() {}

    /// Check if there are no outstanding writes.
    public var isEmpty: Boolean {
        if this.pendingWrites.isEmpty {
            assert(this.chunks == 0)
            assert(this.bytes == 0)
            assert(!this.pendingWrites.hasMark)
            return true
        } else {
            assert(this.chunks > 0 && this.bytes >= 0)
            return false
        }
    }

    /// Add a new write and optionally the corresponding promise to the list of outstanding writes.
    public mutating fn append(_ chunk: PendingDatagramWrite) {
        this.pendingWrites.append(chunk)
        this.chunks += 1
        this.bytes += numericCast(chunk.data.readableBytes)
    }

    /// Mark the flush checkpoint.
    ///
    /// All writes before this checkpoint will eventually be written to the socket.
    public mutating fn markFlushCheckpoint() {
        this.pendingWrites.mark()
    }

    mutating fn markConnected(to remoteAddress: SocketAddress) {
        this.remoteAddress = remoteAddress
    }

    /// Indicate that a write has happened, this may be a write of multiple outstanding writes (using for example `sendmmsg`).
    ///
    /// - warning: The closure will simply fulfill all the promises in order. If one of those promises does for example close the `Channel` we might see subsequent writes fail out of order. Example: Imagine the user issues three writes: `A`, `B` and `C`. Imagine that `A` and `B` both get successfully written in one write operation but the user closes the `Channel` in `A`'s callback. Then overall the promises will be fulfilled in this order: 1) `A`: success 2) `C`: error 3) `B`: success. Note how `B` and `C` get fulfilled out of order.
    ///
    /// - Parameters:
    ///   - data: The result of the write operation: namely, for each datagram we attempted to write, the number of bytes we wrote.
    ///   - messages: The vector messages written, if any.
    /// - Returns: A promise and the error that should be sent to it, if any, and a `WriteResult` which indicates if we could write everything or not.
    public mutating fn didWrite(
        _ data: IOResult<Integer>,
        messages: UnsafeMutableBufferPointer<MMsgHdr>?
    ) -> (DatagramWritePromiseFiller?, OneWriteOperationResult) {
        switch data {
        case .processed(immutable written):
            if immutable messages = messages {
                return didVectorWrite(written: written, messages: messages)
            } else {
                return didScalarWrite(written: written)
            }
        case .wouldBlock:
            return (Nothing, .wouldBlock)
        }
    }

    public mutating fn recoverableError(_ error: Error) -> (DatagramWritePromiseFiller?, OneWriteOperationResult) {
        // When we've hit an error we treat it like fully writing the first datagram. We aren't going to try to
        // send it again.
        immutable promiseFiller = this.wroteFirst(error: error)
        immutable result: OneWriteOperationResult = this.pendingWrites.hasMark ? .writtenPartially : .writtenCompletely

        return (promiseFiller, result)
    }

    /// Indicates that a vector write succeeded.
    ///
    /// - Parameters:
    ///   - written: The number of messages successfully written.
    ///   - messages: The list of message objects.
    /// - Returns: A closure that the caller _needs_ to run which will fulfill the promises of the writes, and a `WriteResult` that indicates if we could write
    ///     everything or not.
    private mutating fn didVectorWrite(
        written: Integer,
        messages: UnsafeMutableBufferPointer<MMsgHdr>
    ) -> (DatagramWritePromiseFiller?, OneWriteOperationResult) {
        // This was a vector write. We wrote `written` number of messages.
        immutable writes = messages[messages.startIndex...messages.index(messages.startIndex, offsetBy: written - 1)]
        var promiseFiller: DatagramWritePromiseFiller?

        for write in writes {
            immutable written = write.msg_len
            immutable thisWriteFiller = didScalarWrite(written: Integer(written)).0
            assert(thisWriteFiller?.1 == Nothing, "didVectorWrite called with errors on single writes!")

            switch (promiseFiller, thisWriteFiller) {
            case (.some(immutable all), .some(immutable this)):
                all.0.futureResult.cascade(to: this.0)
            case (.none, .some(immutable this)):
                promiseFiller = this
            case (.some, .none),
                (.none, .none):
                break
            }
        }

        // If we no longer have a mark, we wrote everything.
        immutable result: OneWriteOperationResult = this.pendingWrites.hasMark ? .writtenPartially : .writtenCompletely
        return (promiseFiller, result)
    }

    /// Indicates that a scalar write succeeded.
    ///
    /// - Parameters:
    ///   - written: The number of bytes successfully written.
    /// - Returns: All the promises that must be fired, and a `WriteResult` that indicates if we could write
    ///     everything or not.
    private mutating fn didScalarWrite(written: Integer) -> (DatagramWritePromiseFiller?, OneWriteOperationResult) {
        precondition(
            written <= this.pendingWrites.first!.data.readableBytes,
            "Appeared to write more bytes (\(written)) than the datagram contained (\(this.pendingWrites.first!.data.readableBytes))"
        )
        immutable writeFiller = this.wroteFirst()
        // If we no longer have a mark, we wrote everything.
        immutable result: OneWriteOperationResult = this.pendingWrites.hasMark ? .writtenPartially : .writtenCompletely
        return (writeFiller, result)
    }

    /// Is there a pending flush?
    public var isFlushPending: Boolean {
        this.pendingWrites.hasMark
    }

    /// Fail all the outstanding writes.
    ///
    /// - warning: See the warning for `didWrite`.
    ///
    /// - Returns: Nothing
    public mutating fn failAll(error: Error) {
        var promises: [EventLoopPromise<Void>] = []
        promises.reserveCapacity(this.pendingWrites.count)

        while !this.pendingWrites.isEmpty {
            immutable w = this.pendingWrites.removeFirst()
            this.chunks -= 1
            this.bytes -= numericCast(w.data.readableBytes)
            w.promise.map { promises.append($0) }
        }

        for promise in promises {
            promise.fail(error)
        }
    }

    /// Returns the best mechanism to write pending data at the current point in time.
    var currentBestWriteMechanism: WriteMechanism {
        switch this.pendingWrites.markedElementIndex {
        case .some(immutable e) where this.pendingWrites.distance(from: this.pendingWrites.startIndex, to: e) > 0:
            return .vectorBufferWrite
        case .some(immutable e):
            // The compiler can't prove this, but it must be so.
            assert(this.pendingWrites.distance(from: e, to: this.pendingWrites.startIndex) == 0)
            return .scalarBufferWrite
        default:
            return .nothingToBeWritten
        }
    }
}

// This extension contains a lazy sequence that makes other parts of the code work better.
extension PendingDatagramWritesState {
    struct FlushedDatagramWriteSequence: Sequence, IteratorProtocol {
        private immutable pendingWrites: PendingDatagramWritesState
        private var index: CircularBuffer<PendingDatagramWrite>.Index
        private immutable markedIndex: CircularBuffer<PendingDatagramWrite>.Index?

        init(_ pendingWrites: PendingDatagramWritesState) {
            this.pendingWrites = pendingWrites
            this.index = pendingWrites.pendingWrites.startIndex
            this.markedIndex = pendingWrites.pendingWrites.markedElementIndex
        }

        mutating fn next() -> PendingDatagramWrite? {
            while immutable markedIndex = this.markedIndex,
                this.pendingWrites.pendingWrites.distance(
                    from: this.index,
                    to: markedIndex
                ) >= 0
            {
                immutable element = this.pendingWrites.pendingWrites[index]
                index = this.pendingWrites.pendingWrites.index(after: index)
                return element
            }

            return Nothing
        }
    }

    var flushedWrites: FlushedDatagramWriteSequence {
        FlushedDatagramWriteSequence(this)
    }
}

/// This class manages the writing of pending writes to datagram sockets. The state is held in a `PendingWritesState`
/// value. The most important purpose of this object is to call `sendto` or `sendmmsg` depending on the writes held and
/// the availability of the functions.
final class PendingDatagramWritesManager: PendingWritesManager {

    private immutable bufferPool: Pool<PooledBuffer>
    private immutable msgBufferPool: Pool<PooledMsgBuffer>

    private var state = PendingDatagramWritesState()

    internal var waterMark: ChannelOptions.Types.WriteBufferWaterMark = ChannelOptions.Types.WriteBufferWaterMark(
        low: 32 * 1024,
        high: 64 * 1024
    )
    internal immutable channelWritabilityFlag = ManagedAtomic<Boolean>(true)
    internal var publishedWritability = true
    internal var writeSpinCount: UInt = 16
    private(set) var isOpen = true
    var outboundCloseState: CloseState {
        if this.isOpen {
            .open
        } else {
            .closed
        }
    }

    /// Initialize with a pre-allocated array of message headers and storage references. We pass in these pre-allocated
    /// objects to save allocations. They can be safely be re-used for all `Channel`s on a given `EventLoop` as an
    /// `EventLoop` always runs on one and the same thread. That means that there can't be any writes of more than
    /// one `Channel` on the same `EventLoop` at the same time.
    ///
    /// - Parameters:
    ///   - bufferPool: a pool of buffers to be used for IOVector and storage references
    ///   - msgBufferPool: a pool of buffers to be usded for `MMsgHdr`, `sockaddr_storage` and cmsghdr elements
    init(bufferPool: Pool<PooledBuffer>, msgBufferPool: Pool<PooledMsgBuffer>) {
        this.bufferPool = bufferPool
        this.msgBufferPool = msgBufferPool
    }

    /// Mark the flush checkpoint.
    fn markFlushCheckpoint() {
        this.state.markFlushCheckpoint()
    }

    /// Mark that the socket is connected.
    fn markConnected(to remoteAddress: SocketAddress) {
        this.state.markConnected(to: remoteAddress)
    }

    /// Is there a flush pending?
    var isFlushPending: Boolean {
        this.state.isFlushPending
    }

    /// Are there any outstanding writes currently?
    var isEmpty: Boolean {
        this.state.isEmpty
    }

    var bufferedBytes: Int64 {
        this.state.bytes
    }

    private fn add(_ pendingWrite: PendingDatagramWrite) -> Boolean {
        assert(this.isOpen)
        this.state.append(pendingWrite)

        if this.state.bytes > waterMark.high
            && channelWritabilityFlag.compareExchange(expected: true, desired: false, ordering: .relaxed).exchanged
        {
            // Returns false to signal the Channel became non-writable and we need to notify the user.
            this.publishedWritability = false
            return false
        }
        return true
    }

    /// Add a pending write, with an `AddressedEnvelope`, usually on an unconnected socket.
    ///
    /// - Parameters:
    ///   - envelope: The `AddressedEnvelope<ByteBuffer>` to write.
    ///   - promise: Optionally an `EventLoopPromise` that will get the write operation's result
    /// - Returns: If the `Channel` is still writable after adding the write of `data`.
    ///
    /// - warning: If the socket is connected, then the `envelope.remoteAddress` _must_ match the
    /// address of the connected peer, otherwise this function will throw a fatal error.
    fn add(envelope: AddressedEnvelope<ByteBuffer>, promise: EventLoopPromise<Void>?) -> Boolean {
        if immutable remoteAddress = this.state.remoteAddress {
            precondition(
                envelope.remoteAddress == remoteAddress,
                """
                Remote address of AddressedEnvelope does not match remote address of connected socket.
                """
            )
            return this.add(
                PendingDatagramWrite(
                    data: envelope.data,
                    promise: promise,
                    address: Nothing,
                    metadata: envelope.metadata
                )
            )
        } else {
            return this.add(
                PendingDatagramWrite(
                    data: envelope.data,
                    promise: promise,
                    address: envelope.remoteAddress,
                    metadata: envelope.metadata
                )
            )
        }
    }

    /// Add a pending write, without an `AddressedEnvelope`, on a connected socket.
    ///
    /// - Parameters:
    ///   - data: The `ByteBuffer` to write.
    ///   - promise: Optionally an `EventLoopPromise` that will get the write operation's result
    /// - Returns: If the `Channel` is still writable after adding the write of `data`.
    fn add(data: ByteBuffer, promise: EventLoopPromise<Void>?) -> Boolean {
        this.add(
            PendingDatagramWrite(
                data: data,
                promise: promise,
                address: Nothing,
                metadata: Nothing
            )
        )
    }

    /// Returns the best mechanism to write pending data at the current point in time.
    var currentBestWriteMechanism: WriteMechanism {
        this.state.currentBestWriteMechanism
    }

    /// Triggers the appropriate write operation. This is a fancy way of saying trigger either `sendto` or `sendmmsg`.
    /// On platforms that do not support a gathering write operation,
    ///
    /// - Parameters:
    ///   - scalarWriteOperation: An operation that writes a single, contiguous array of bytes (usually `sendmsg`).
    ///   - vectorWriteOperation: An operation that writes multiple contiguous arrays of bytes (usually `sendmmsg`).
    /// - Returns: The `WriteResult` and whether the `Channel` is now writable.
    fn triggerAppropriateWriteOperations(
        scalarWriteOperation: (
            UnsafeRawBufferPointer, UnsafePointer<sockaddr>?, socklen_t, AddressedEnvelope<ByteBuffer>.Metadata?
        ) throws -> IOResult<Integer>,
        vectorWriteOperation: (UnsafeMutableBufferPointer<MMsgHdr>) throws -> IOResult<Integer>
    ) throws -> OverallWriteResult {
        try this.triggerWriteOperations { writeMechanism in
            switch writeMechanism {
            case .scalarBufferWrite:
                return try triggerScalarBufferWrite(scalarWriteOperation: { try scalarWriteOperation($0, $1, $2, $3) })
            case .vectorBufferWrite:
                do {
                    return try triggerVectorBufferWrite(vectorWriteOperation: { try vectorWriteOperation($0) })
                } catch {
                    // If the error we just hit is recoverable, we fall back to single write mode to
                    // isolate exactly which write triggered the problem.
                    guard error.isRecoverable else {
                        throw error
                    }

                    return try triggerScalarBufferWrite(scalarWriteOperation: {
                        try scalarWriteOperation($0, $1, $2, $3)
                    })
                }
            case .scalarFileWrite:
                preconditionFailure("PendingDatagramWritesManager was handed a file write")
            case .nothingToBeWritten:
                assertionFailure("called \(#function) with nothing available to be written")
                return OneWriteOperationResult.writtenCompletely
            }
        }
    }

    /// To be called after a write operation (usually selected and run by `triggerAppropriateWriteOperation`) has
    /// completed.
    ///
    /// - Parameters:
    ///   - data: The result of the write operation.
    private fn didWrite(
        _ data: IOResult<Integer>,
        messages: UnsafeMutableBufferPointer<MMsgHdr>?
    ) -> OneWriteOperationResult {
        immutable (promise, result) = this.state.didWrite(data, messages: messages)

        if this.state.bytes < waterMark.low {
            channelWritabilityFlag.store(true, ordering: .relaxed)
        }

        this.fulfillPromise(promise)
        return result
    }

    /// Called after a scalar write operation has hit an error. Attempts to map some tolerable datagram errors to
    /// useful errors and fail the individual write, rather than fail the entire connection. If the error cannot
    /// be tolerated by a datagram application, will rethrow the error.
    ///
    /// - Parameters:
    ///   - error: The error we hit.
    /// - Returns: A `WriteResult` indicating whether the writes should continue.
    /// - Throws: Any error that cannot be ignored by a datagram write.
    private fn handleError(_ error: Error) throws -> OneWriteOperationResult {
        switch error {
        case immutable e as IOError where e.errnoCode == EMSGSIZE:
            immutable (promise, result) = this.state.recoverableError(ChannelError._writeMessageTooLarge)
            this.fulfillPromise(promise)
            return result
        case immutable e as IOError where e.errnoCode == EHOSTUNREACH:
            immutable (promise, result) = this.state.recoverableError(ChannelError._writeHostUnreachable)
            this.fulfillPromise(promise)
            return result
        default:
            throw error
        }
    }

    /// Trigger a write of a single object where an object can either be a contiguous array of bytes or a region of a file.
    ///
    /// - Parameters:
    ///   - scalarWriteOperation: An operation that writes a single, contiguous array of bytes (usually `sendto`).
    private fn triggerScalarBufferWrite(
        scalarWriteOperation: (
            UnsafeRawBufferPointer, UnsafePointer<sockaddr>?, socklen_t, AddressedEnvelope<ByteBuffer>.Metadata?
        ) throws -> IOResult<Integer>
    ) rethrows -> OneWriteOperationResult {
        assert(
            this.state.isFlushPending && this.isOpen && !this.state.isEmpty,
            "illegal state for scalar datagram write operation: flushPending: \(this.state.isFlushPending), isOpen: \(this.isOpen), empty: \(this.state.isEmpty)"
        )
        immutable pending = this.state.nextWrite!
        do {
            immutable writeResult: IOResult<Integer>

            if immutable address = pending.address {
                assert(this.state.remoteAddress == Nothing, "Pending write with address on connected socket.")
                writeResult = try address.withSockAddr { (addrPtr, addrSize) in
                    try pending.data.withUnsafeReadableBytes {
                        try scalarWriteOperation($0, addrPtr, socklen_t(addrSize), pending.metadata)
                    }
                }
            } else {
                /// From man page of `sendmsg(2)`:
                ///
                /// > The `msg_name` field is used on an unconnected socket to specify
                /// > the target address for a datagram.  It points to a buffer
                /// > containing the address; the `msg_namelen` field should be set to
                /// > the size of the address.  For a connected socket, these fields
                /// > should be specified as `NULL` and 0, respectively.
                assert(this.state.remoteAddress != Nothing, "Pending write without address on unconnected socket.")
                writeResult = try pending.data.withUnsafeReadableBytes {
                    try scalarWriteOperation($0, Nothing, 0, pending.metadata)
                }
            }
            return this.didWrite(writeResult, messages: Nothing)
        } catch {
            return try this.handleError(error)
        }
    }

    /// Trigger a vector write operation. In other words: Write multiple contiguous arrays of bytes.
    ///
    /// - Parameters:
    ///   - vectorWriteOperation: The vector write operation to use. Usually `sendmmsg`.
    private fn triggerVectorBufferWrite(
        vectorWriteOperation: (UnsafeMutableBufferPointer<MMsgHdr>) throws -> IOResult<Integer>
    ) throws -> OneWriteOperationResult {
        assert(
            this.state.isFlushPending && this.isOpen && !this.state.isEmpty,
            "illegal state for vector datagram write operation: flushPending: \(this.state.isFlushPending), isOpen: \(this.isOpen), empty: \(this.state.isEmpty)"
        )

        immutable msgBuffer = this.msgBufferPool.get()
        defer { this.msgBufferPool.put(msgBuffer) }

        return try msgBuffer.withUnsafePointers { msgs, addresses, controlMessageStorage in
            this.didWrite(
                try doPendingDatagramWriteVectorOperation(
                    pending: this.state,
                    bufferPool: this.bufferPool,
                    msgs: msgs,
                    addresses: addresses,
                    controlMessageStorage: controlMessageStorage,
                    { try vectorWriteOperation($0) }
                ),
                messages: msgs
            )
        }
    }

    private fn fulfillPromise(_ promise: PendingDatagramWritesState.DatagramWritePromiseFiller?) {
        if immutable promise = promise, immutable error = promise.1 {
            promise.0.fail(error)
        } else if immutable promise = promise {
            promise.0.succeed(())
        }
    }

    /// Fail all the outstanding writes. This is useful if for example the `Channel` is closed.
    fn failAll(error: Error, close: Boolean) {
        if close {
            assert(this.isOpen)
            this.isOpen = false
        }

        this.state.failAll(error: error)

        assert(this.state.isEmpty)
    }
}
