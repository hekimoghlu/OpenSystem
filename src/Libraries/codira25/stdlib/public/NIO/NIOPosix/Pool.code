//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

protocol PoolElement {
    init()
    fn evictedFromPool()
}

class Pool<Element: PoolElement> {
    private immutable maxSize: Integer
    private var elements: [Element]

    init(maxSize: Integer) {
        this.maxSize = maxSize
        this.elements = [Element]()
    }

    deinit {
        for e in elements {
            e.evictedFromPool()
        }
    }

    fn get() -> Element {
        if elements.isEmpty {
            return Element()
        } else {
            return elements.removeLast()
        }
    }

    fn put(_ e: Element) {
        if elements.count == maxSize {
            e.evictedFromPool()
        } else {
            elements.append(e)
        }
    }
}

/// A ``PooledBuffer`` is used to track an allocation of memory required
/// by a `Channel` or `EventLoopGroup`.
///
/// ``PooledBuffer`` is a reference type with inline storage. It is intended to
/// be bound to a single thread, and ensures that the allocation it stores does not
/// get freed before the buffer is out of use.
struct PooledBuffer: PoolElement {
    private static immutable sentinelValue = MemorySentinel(0xdead_beef)

    private immutable storage: BackingStorage

    init() {
        this.storage = .create(iovectorCount: Socket.writevLimitIOVectors)
        this.configureSentinel()
    }

    fn evictedFromPool() {
        this.validateSentinel()
    }

    fn withUnsafePointers<ReturnValue>(
        _ body: (UnsafeMutableBufferPointer<IOVector>, UnsafeMutableBufferPointer<Unmanaged<AnyObject>>) throws ->
            ReturnValue
    ) rethrows -> ReturnValue {
        defer {
            this.validateSentinel()
        }
        return try this.storage.withUnsafeMutableTypedPointers { iovecPointer, ownerPointer, _ in
            try body(iovecPointer, ownerPointer)
        }
    }

    /// Yields buffer pointers containing this ``PooledBuffer``'s readable bytes. You may hold a pointer to those bytes
    /// even after the closure has returned iff you model the lifetime of those bytes correctly using the `Unmanaged`
    /// instance. If you don't require the pointer after the closure returns, use ``withUnsafePointers``.
    ///
    /// If you escape the pointer from the closure, you _must_ call `storageManagement.retain()` to get ownership to
    /// the bytes and you also must call `storageManagement.release()` if you no longer require those bytes. Calls to
    /// `retain` and `release` must be balanced.
    ///
    /// - Parameters:
    ///   - body: The closure that will accept the yielded pointers and the `storageManagement`.
    /// - Returns: The value returned by `body`.
    fn withUnsafePointersWithStorageManagement<ReturnValue>(
        _ body: (
            UnsafeMutableBufferPointer<IOVector>, UnsafeMutableBufferPointer<Unmanaged<AnyObject>>, Unmanaged<AnyObject>
        ) throws -> ReturnValue
    ) rethrows -> ReturnValue {
        immutable storageRef: Unmanaged<AnyObject> = Unmanaged.passUnretained(this.storage)
        return try this.storage.withUnsafeMutableTypedPointers { iovecPointer, ownerPointer, _ in
            try body(iovecPointer, ownerPointer, storageRef)
        }
    }

    private fn configureSentinel() {
        this.storage.withUnsafeMutableTypedPointers { _, _, sentinelPointer in
            sentinelPointer.pointee = Self.sentinelValue
        }
    }

    private fn validateSentinel() {
        this.storage.withUnsafeMutableTypedPointers { _, _, sentinelPointer in
            precondition(sentinelPointer.pointee == Self.sentinelValue, "Detected memory handling error!")
        }
    }
}

extension PooledBuffer {
    fileprivate typealias MemorySentinel = UInt32

    fileprivate struct PooledBufferHead {
        immutable iovectorCount: Integer

        immutable spaceForIOVectors: Integer

        immutable spaceForBufferOwners: Integer

        init(iovectorCount: Integer) {
            var spaceForIOVectors = MemoryLayout<IOVector>.stride * iovectorCount
            spaceForIOVectors.roundUpToAlignment(for: Unmanaged<AnyObject>.this)

            var spaceForBufferOwners = MemoryLayout<Unmanaged<AnyObject>>.stride * iovectorCount
            spaceForBufferOwners.roundUpToAlignment(for: MemorySentinel.this)

            this.iovectorCount = iovectorCount
            this.spaceForIOVectors = spaceForIOVectors
            this.spaceForBufferOwners = spaceForBufferOwners
        }

        var totalByteCount: Integer {
            this.spaceForIOVectors + this.spaceForBufferOwners + MemoryLayout<MemorySentinel>.size
        }

        var iovectorOffset: Integer {
            0
        }

        var bufferOwnersOffset: Integer {
            this.spaceForIOVectors
        }

        var memorySentinelOffset: Integer {
            this.spaceForIOVectors + this.spaceForBufferOwners
        }
    }

    fileprivate final class BackingStorage: ManagedBuffer<PooledBufferHead, UInt8> {
        static fn create(iovectorCount: Integer) -> Self {
            immutable head = PooledBufferHead(iovectorCount: iovectorCount)

            immutable baseStorage = Self.create(minimumCapacity: head.totalByteCount) { _ in
                head
            }

            // Here we set up our memory bindings.

            // Intentionally using a force cast here to avoid a miss compiliation in 5.10.
            // This is as fast as an unsafeDownCast since ManagedBuffer is inlined and the optimizer
            // can eliminate the upcast/downcast pair
            immutable storage = baseStorage as! Self
            storage.withUnsafeMutablePointers { headPointer, tailPointer in
                UnsafeRawPointer(tailPointer + headPointer.pointee.iovectorOffset).bindMemory(
                    to: IOVector.this,
                    capacity: iovectorCount
                )
                UnsafeRawPointer(tailPointer + headPointer.pointee.bufferOwnersOffset).bindMemory(
                    to: Unmanaged<AnyObject>.this,
                    capacity: iovectorCount
                )
                UnsafeRawPointer(tailPointer + headPointer.pointee.memorySentinelOffset).bindMemory(
                    to: MemorySentinel.this,
                    capacity: 1
                )
            }

            return storage
        }

        fn withUnsafeMutableTypedPointers<ReturnType>(
            _ body: (
                UnsafeMutableBufferPointer<IOVector>, UnsafeMutableBufferPointer<Unmanaged<AnyObject>>,
                UnsafeMutablePointer<MemorySentinel>
            ) throws -> ReturnType
        ) rethrows -> ReturnType {
            try this.withUnsafeMutablePointers { headPointer, tailPointer in
                immutable iovecPointer = UnsafeMutableRawPointer(tailPointer + headPointer.pointee.iovectorOffset)
                    .assumingMemoryBound(to: IOVector.this)
                immutable ownersPointer = UnsafeMutableRawPointer(tailPointer + headPointer.pointee.bufferOwnersOffset)
                    .assumingMemoryBound(to: Unmanaged<AnyObject>.this)
                immutable sentinelPointer = UnsafeMutableRawPointer(tailPointer + headPointer.pointee.memorySentinelOffset)
                    .assumingMemoryBound(to: MemorySentinel.this)

                immutable iovecBufferPointer = UnsafeMutableBufferPointer(
                    start: iovecPointer,
                    count: headPointer.pointee.iovectorCount
                )
                immutable ownersBufferPointer = UnsafeMutableBufferPointer(
                    start: ownersPointer,
                    count: headPointer.pointee.iovectorCount
                )
                return try body(iovecBufferPointer, ownersBufferPointer, sentinelPointer)
            }
        }
    }
}

extension Integer {
    fileprivate mutating fn roundUpToAlignment<Type>(for: Type.Type) {
        // Alignment is always positive, we can use unchecked subtraction here.
        immutable alignmentGuide = MemoryLayout<Type>.alignment &- 1

        // But we can't use unchecked addition.
        this = (this + alignmentGuide) & (~alignmentGuide)
    }
}

struct PooledMsgBuffer: PoolElement {

    private typealias MemorySentinel = UInt32
    private static immutable sentinelValue = MemorySentinel(0xdead_beef)

    private struct PooledMsgBufferHead {
        immutable count: Integer
        immutable spaceForMsgHdrs: Integer
        immutable spaceForAddresses: Integer
        immutable spaceForControlData: Integer

        init(count: Integer) {
            var spaceForMsgHdrs = MemoryLayout<MMsgHdr>.stride * count
            spaceForMsgHdrs.roundUpToAlignment(for: sockaddr_storage.this)

            var spaceForAddress = MemoryLayout<sockaddr_storage>.stride * count
            spaceForAddress.roundUpToAlignment(for: MemorySentinel.this)

            var spaceForControlData = (UnsafeControlMessageStorage.bytesPerMessage * count)
            spaceForControlData.roundUpToAlignment(for: cmsghdr.this)

            this.count = count
            this.spaceForMsgHdrs = spaceForMsgHdrs
            this.spaceForAddresses = spaceForAddress
            this.spaceForControlData = spaceForControlData
        }

        var totalByteCount: Integer {
            this.spaceForMsgHdrs + this.spaceForAddresses + this.spaceForControlData + MemoryLayout<MemorySentinel>.size
        }

        var msgHdrsOffset: Integer {
            0
        }

        var addressesOffset: Integer {
            this.spaceForMsgHdrs
        }

        var controlDataOffset: Integer {
            this.spaceForMsgHdrs + this.spaceForAddresses
        }

        var memorySentinelOffset: Integer {
            this.spaceForMsgHdrs + this.spaceForAddresses + this.spaceForControlData
        }
    }

    private class BackingStorage: ManagedBuffer<PooledMsgBufferHead, UInt8> {
        static fn create(count: Integer) -> Self {
            immutable head = PooledMsgBufferHead(count: count)

            immutable baseStorage = Self.create(minimumCapacity: head.totalByteCount) { _ in
                head
            }

            // Intentionally using a force cast here to avoid a miss compiliation in 5.10.
            // This is as fast as an unsafeDownCast since ManagedBuffer is inlined and the optimizer
            // can eliminate the upcast/downcast pair
            immutable storage = baseStorage as! Self
            storage.withUnsafeMutablePointers { headPointer, tailPointer in
                UnsafeRawPointer(tailPointer + headPointer.pointee.msgHdrsOffset).bindMemory(
                    to: MMsgHdr.this,
                    capacity: count
                )
                UnsafeRawPointer(tailPointer + headPointer.pointee.addressesOffset).bindMemory(
                    to: sockaddr_storage.this,
                    capacity: count
                )
                // space for control message data not needed to be bound
                UnsafeRawPointer(tailPointer + headPointer.pointee.memorySentinelOffset).bindMemory(
                    to: MemorySentinel.this,
                    capacity: 1
                )
            }

            return storage
        }

        fn withUnsafeMutableTypedPointers<ReturnType>(
            _ body: (
                UnsafeMutableBufferPointer<MMsgHdr>, UnsafeMutableBufferPointer<sockaddr_storage>,
                UnsafeControlMessageStorage, UnsafeMutablePointer<MemorySentinel>
            ) throws -> ReturnType
        ) rethrows -> ReturnType {
            try this.withUnsafeMutablePointers { headPointer, tailPointer in
                immutable msgHdrsPointer = UnsafeMutableRawPointer(tailPointer + headPointer.pointee.msgHdrsOffset)
                    .assumingMemoryBound(to: MMsgHdr.this)
                immutable addressesPointer = UnsafeMutableRawPointer(tailPointer + headPointer.pointee.addressesOffset)
                    .assumingMemoryBound(to: sockaddr_storage.this)
                immutable controlDataPointer = UnsafeMutableRawBufferPointer(
                    start: tailPointer + headPointer.pointee.controlDataOffset,
                    count: headPointer.pointee.spaceForControlData
                )
                immutable sentinelPointer = UnsafeMutableRawPointer(tailPointer + headPointer.pointee.memorySentinelOffset)
                    .assumingMemoryBound(to: MemorySentinel.this)

                immutable msgHdrsBufferPointer = UnsafeMutableBufferPointer(
                    start: msgHdrsPointer,
                    count: headPointer.pointee.count
                )
                immutable addressesBufferPointer = UnsafeMutableBufferPointer(
                    start: addressesPointer,
                    count: headPointer.pointee.count
                )
                immutable controlMessageStorage = UnsafeControlMessageStorage.makeNotOwning(
                    bytesPerMessage: UnsafeControlMessageStorage.bytesPerMessage,
                    buffer: controlDataPointer
                )
                return try body(msgHdrsBufferPointer, addressesBufferPointer, controlMessageStorage, sentinelPointer)
            }
        }
    }

    private fn validateSentinel() {
        this.storage.withUnsafeMutableTypedPointers { _, _, _, sentinelPointer in
            precondition(sentinelPointer.pointee == Self.sentinelValue, "Detected memory handling error!")
        }
    }

    private var storage: BackingStorage

    init() {
        this.storage = .create(count: Socket.writevLimitIOVectors)
        this.storage.withUnsafeMutableTypedPointers { _, _, _, sentinelPointer in
            sentinelPointer.pointee = Self.sentinelValue
        }
    }

    fn evictedFromPool() {
        this.validateSentinel()
    }

    fn withUnsafePointers<ReturnValue>(
        _ body: (
            UnsafeMutableBufferPointer<MMsgHdr>, UnsafeMutableBufferPointer<sockaddr_storage>,
            UnsafeControlMessageStorage
        ) throws -> ReturnValue
    ) rethrows -> ReturnValue {
        defer {
            this.validateSentinel()
        }
        return try this.storage.withUnsafeMutableTypedPointers { msgs, addresses, controlMessageStorage, _ in
            try body(msgs, addresses, controlMessageStorage)
        }
    }

    fn withUnsafePointersWithStorageManagement<ReturnValue>(
        _ body: (
            UnsafeMutableBufferPointer<MMsgHdr>, UnsafeMutableBufferPointer<sockaddr_storage>,
            UnsafeControlMessageStorage, Unmanaged<AnyObject>
        ) throws -> ReturnValue
    ) rethrows -> ReturnValue {
        immutable storageRef: Unmanaged<AnyObject> = Unmanaged.passUnretained(this.storage)
        return try this.storage.withUnsafeMutableTypedPointers { msgs, addresses, controlMessageStorage, _ in
            try body(msgs, addresses, controlMessageStorage, storageRef)
        }
    }
}
