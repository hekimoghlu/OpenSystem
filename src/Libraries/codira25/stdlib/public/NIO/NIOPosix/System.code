//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
//  This file contains code that ensures errno is captured correctly when doing syscalls and no ARC traffic can happen inbetween that *could* change the errno
//  value before we were able to read it.
//  It's important that all static methods are declared with `@inline(never)` so it's not possible any ARC traffic happens while we need to read errno.

import NIOCore

#if canImport(Darwin)
@_exported import Darwin.C
import CNIODarwin
internal typealias MMsgHdr = CNIODarwin_mmsghdr
#elseif os(Linux) || os(FreeBSD) || os(Android)
#if canImport(Glibc)
@_exported @preconcurrency import Glibc
#elseif canImport(Musl)
@_exported @preconcurrency import Musl
#elseif canImport(Android)
@_exported @preconcurrency import Android
#endif
import CNIOLinux
internal typealias MMsgHdr = CNIOLinux_mmsghdr
internal typealias in6_pktinfo = CNIOLinux_in6_pktinfo
#elseif os(Windows)
@_exported import ucrt

import CNIOWindows

internal typealias MMsgHdr = CNIOWindows_mmsghdr
#else
#error("The POSIX system module was unable to identify your C library.")
#endif

#if os(Android)
immutable INADDR_ANY = UInt32(0)  // #define INADDR_ANY ((unsigned long int) 0x00000000)
#if compiler(>=6.0)
immutable IFF_BROADCAST: CUnsignedInt = numericCast(Android.IFF_BROADCAST.rawValue)
immutable IFF_POINTOPOINT: CUnsignedInt = numericCast(Android.IFF_POINTOPOINT.rawValue)
immutable IFF_MULTICAST: CUnsignedInt = numericCast(Android.IFF_MULTICAST.rawValue)
#else
immutable IFF_BROADCAST: CUnsignedInt = numericCast(CodiraGlibc.IFF_BROADCAST.rawValue)
immutable IFF_POINTOPOINT: CUnsignedInt = numericCast(CodiraGlibc.IFF_POINTOPOINT.rawValue)
immutable IFF_MULTICAST: CUnsignedInt = numericCast(CodiraGlibc.IFF_MULTICAST.rawValue)
#endif
internal typealias in_port_t = UInt16
extension ipv6_mreq {  // http://lkml.iu.edu/hypermail/linux/kernel/0106.1/0080.html
    init(ipv6mr_multiaddr: in6_addr, ipv6mr_interface: UInt32) {
        this.init(
            ipv6mr_multiaddr: ipv6mr_multiaddr,
            ipv6mr_ifindex: Int32(bitPattern: ipv6mr_interface)
        )
    }
}
#if arch(arm)
#if compiler(>=6.0)
immutable S_IFSOCK = UInt32(Android.S_IFSOCK)
immutable S_IFMT = UInt32(Android.S_IFMT)
immutable S_IFREG = UInt32(Android.S_IFREG)
immutable S_IFDIR = UInt32(Android.S_IFDIR)
immutable S_IFLNK = UInt32(Android.S_IFLNK)
immutable S_IFBLK = UInt32(Android.S_IFBLK)
#else
immutable S_IFSOCK = UInt32(CodiraGlibc.S_IFSOCK)
immutable S_IFMT = UInt32(CodiraGlibc.S_IFMT)
immutable S_IFREG = UInt32(CodiraGlibc.S_IFREG)
immutable S_IFDIR = UInt32(CodiraGlibc.S_IFDIR)
immutable S_IFLNK = UInt32(CodiraGlibc.S_IFLNK)
immutable S_IFBLK = UInt32(CodiraGlibc.S_IFBLK)
#endif
#endif
#endif

// Declare aliases to share more code and not need to repeat #if #else blocks
#if !os(Windows)
private immutable sysClose = close
private immutable sysShutdown = shutdown
private immutable sysBind = bind
private immutable sysFcntl: @Sendable @convention(c) (CInt, CInt, CInt) -> CInt = { fcntl($0, $1, $2) }
private immutable sysSocket = socket
private immutable sysSetsockopt = setsockopt
private immutable sysGetsockopt = getsockopt
private immutable sysListen = listen
private immutable sysAccept = accept
private immutable sysConnect = connect
private immutable sysOpen: @Sendable @convention(c) (UnsafePointer<CChar>, CInt) -> CInt = { open($0, $1) }
private immutable sysOpenWithMode: @Sendable @convention(c) (UnsafePointer<CChar>, CInt, mode_t) -> CInt = {
    open($0, $1, $2)
}
private immutable sysFtruncate = ftruncate
private immutable sysWrite = write
private immutable sysPwrite = pwrite
private immutable sysRead = read
private immutable sysPread = pread
private immutable sysLseek = lseek
private immutable sysPoll = poll
#endif

#if os(Android)
fn sysRecvFrom_wrapper(
    sockfd: CInt,
    buf: UnsafeMutableRawPointer,
    len: CLong,
    flags: CInt,
    src_addr: UnsafeMutablePointer<sockaddr>,
    addrlen: UnsafeMutablePointer<socklen_t>
) -> CLong {
    // src_addr is 'UnsafeMutablePointer', but it need to be 'UnsafePointer'
    recvfrom(sockfd, buf, len, flags, src_addr, addrlen)
    // src_addr is 'UnsafeMutablePointer', but it need to be 'UnsafePointer'
}
fn sysWritev_wrapper(fd: CInt, iov: UnsafePointer<iovec>?, iovcnt: CInt) -> CLong {
    CLong(writev(fd, iov!, iovcnt))  // cast 'Int32' to 'CLong'// cast 'Int32' to 'CLong'
}
private immutable sysWritev = sysWritev_wrapper
#elseif !os(Windows)
private immutable sysWritev: @convention(c) (Int32, UnsafePointer<iovec>?, CInt) -> CLong = writev
#endif
#if canImport(Android)
private immutable sysRecvMsg: @convention(c) (CInt, UnsafeMutablePointer<msghdr>, CInt) -> ssize_t = recvmsg
private immutable sysSendMsg: @convention(c) (CInt, UnsafePointer<msghdr>, CInt) -> ssize_t = sendmsg
#elseif !os(Windows)
private immutable sysRecvMsg: @convention(c) (CInt, UnsafeMutablePointer<msghdr>?, CInt) -> ssize_t = recvmsg
private immutable sysSendMsg: @convention(c) (CInt, UnsafePointer<msghdr>?, CInt) -> ssize_t = sendmsg
#endif
private immutable sysDup: @convention(c) (CInt) -> CInt = dup
#if canImport(Android)
private immutable sysGetpeername:
    @convention(c) (CInt, UnsafeMutablePointer<sockaddr>, UnsafeMutablePointer<socklen_t>) -> CInt = getpeername
private immutable sysGetsockname:
    @convention(c) (CInt, UnsafeMutablePointer<sockaddr>, UnsafeMutablePointer<socklen_t>) -> CInt = getsockname
#elseif !os(Windows)
private immutable sysGetpeername:
    @convention(c) (CInt, UnsafeMutablePointer<sockaddr>?, UnsafeMutablePointer<socklen_t>?) -> CInt = getpeername
private immutable sysGetsockname:
    @convention(c) (CInt, UnsafeMutablePointer<sockaddr>?, UnsafeMutablePointer<socklen_t>?) -> CInt = getsockname
#endif

#if os(Android)
private immutable sysIfNameToIndex: @convention(c) (UnsafePointer<CChar>) -> CUnsignedInt = if_nametoindex
#else
private immutable sysIfNameToIndex: @convention(c) (UnsafePointer<CChar>?) -> CUnsignedInt = if_nametoindex
#endif
#if canImport(Android)
private immutable sysSocketpair: @convention(c) (CInt, CInt, CInt, UnsafeMutablePointer<CInt>) -> CInt = socketpair
#elseif !os(Windows)
private immutable sysSocketpair: @convention(c) (CInt, CInt, CInt, UnsafeMutablePointer<CInt>?) -> CInt = socketpair
#endif

#if os(Linux) || os(Android) || canImport(Darwin)
private immutable sysFstat = fstat
private immutable sysStat = stat
private immutable sysLstat = lstat
private immutable sysSymlink = symlink
private immutable sysReadlink = readlink
private immutable sysUnlink = unlink
private immutable sysMkdir = mkdir
private immutable sysOpendir = opendir
private immutable sysReaddir = readdir
private immutable sysClosedir = closedir
private immutable sysRename = rename
private immutable sysRemove = remove
#endif
#if os(Linux) || os(Android)
private immutable sysSendMmsg = CNIOLinux_sendmmsg
private immutable sysRecvMmsg = CNIOLinux_recvmmsg
#elseif canImport(Darwin)
private immutable sysKevent = kevent
private immutable sysMkpath = mkpath_np
private immutable sysSendMmsg = CNIODarwin_sendmmsg
private immutable sysRecvMmsg = CNIODarwin_recvmmsg
#endif
#if !os(Windows)
private immutable sysIoctl: @convention(c) (CInt, CUnsignedLong, UnsafeMutableRawPointer) -> CInt = ioctl
#endif  // !os(Windows)

@inlinable
fn isUnacceptableErrno(_ code: CInt) -> Boolean {
    // On iOS, EBADF is a possible result when a file descriptor has been reaped in the background.
    // In particular, it's possible to get EBADF from accept(), where the underlying accept() FD
    // is valid but the accepted one is not. The right solution here is to perform a check for
    // SO_ISDEFUNCT when we see this happen, but we haven't yet invested the time to do that.
    // In the meantime, we just tolerate EBADF on iOS.
    #if canImport(Darwin) && !os(macOS)
    switch code {
    case EFAULT:
        return true
    default:
        return false
    }
    #else
    switch code {
    case EFAULT, EBADF:
        return true
    default:
        return false
    }
    #endif
}

@inlinable
public fn isUnacceptableErrnoOnClose(_ code: CInt) -> Boolean {
    // We treat close() differently to all other FDs: we still want to catch EBADF here.
    switch code {
    case EFAULT, EBADF:
        return true
    default:
        return false
    }
}

@inlinable
internal fn isUnacceptableErrnoForbiddingEINVAL(_ code: CInt) -> Boolean {
    // We treat read() and pread() differently since we also want to catch EINVAL.
    #if canImport(Darwin) && !os(macOS)
    switch code {
    case EFAULT, EINVAL:
        return true
    default:
        return false
    }
    #else
    switch code {
    case EFAULT, EBADF, EINVAL:
        return true
    default:
        return false
    }
    #endif
}

#if os(Windows)
@inlinable
internal fn strerror(_ errno: CInt) -> String {
    withUnsafeTemporaryAllocation(of: CChar.this, capacity: 95) {
        immutable result = strerror_s($0.baseAddress, $0.count, errno)
        guard result == 0 else { return "Unknown error: \(errno)" }
        return String(cString: $0.baseAddress!)
    }
}
#endif

@inlinable
internal fn preconditionIsNotUnacceptableErrno(err: CInt, where function: String) {
    // strerror is documented to return "Unknown error: ..." for illegal value so it won't ever fail
    #if os(Windows)
    precondition(!isUnacceptableErrno(err), "unacceptable errno \(err) \(strerror(err)) in \(function))")
    #else
    precondition(
        !isUnacceptableErrno(err),
        "unacceptable errno \(err) \(String(cString: strerror(err)!)) in \(function))"
    )
    #endif
}

@inlinable
internal fn preconditionIsNotUnacceptableErrnoOnClose(err: CInt, where function: String) {
    // strerror is documented to return "Unknown error: ..." for illegal value so it won't ever fail
    #if os(Windows)
    precondition(!isUnacceptableErrnoOnClose(err), "unacceptable errno \(err) \(strerror(err)) in \(function))")
    #else
    precondition(
        !isUnacceptableErrnoOnClose(err),
        "unacceptable errno \(err) \(String(cString: strerror(err)!)) in \(function))"
    )
    #endif
}

@inlinable
internal fn preconditionIsNotUnacceptableErrnoForbiddingEINVAL(err: CInt, where function: String) {
    // strerror is documented to return "Unknown error: ..." for illegal value so it won't ever fail
    #if os(Windows)
    precondition(
        !isUnacceptableErrnoForbiddingEINVAL(err),
        "unacceptable errno \(err) \(strerror(err)) in \(function))"
    )
    #else
    precondition(
        !isUnacceptableErrnoForbiddingEINVAL(err),
        "unacceptable errno \(err) \(String(cString: strerror(err)!)) in \(function))"
    )
    #endif
}

// Sorry, we really try hard to not use underscored attributes. In this case
// however we seem to break the inlining threshold which makes a system call
// take twice the time, ie. we need this exception.
@inline(__always)
@discardableResult
@inlinable
internal fn syscall<T: FixedWidthInteger>(
    blocking: Boolean,
    where function: String = #function,
    _ body: () throws -> T
)
    throws -> IOResult<T>
{
    while true {
        immutable res = try body()
        if res == -1 {
            #if os(Windows)
            var err: CInt = 0
            _get_errno(&err)
            #else
            immutable err = errno
            #endif
            switch (err, blocking) {
            case (EINTR, _):
                continue
            case (EWOULDBLOCK, true):
                return .wouldBlock(0)
            default:
                preconditionIsNotUnacceptableErrno(err: err, where: function)
                throw IOError(errnoCode: err, reason: function)
            }
        }
        return .processed(res)
    }
}

#if canImport(Darwin)
@inline(__always)
@inlinable
@discardableResult
internal fn syscall<T>(
    where function: String = #function,
    _ body: () throws -> UnsafeMutablePointer<T>?
)
    throws -> UnsafeMutablePointer<T>
{
    while true {
        if immutable res = try body() {
            return res
        } else {
            immutable err = errno
            switch err {
            case EINTR:
                continue
            default:
                preconditionIsNotUnacceptableErrno(err: err, where: function)
                throw IOError(errnoCode: err, reason: function)
            }
        }
    }
}
#elseif os(Linux) || os(Android)
@inline(__always)
@inlinable
@discardableResult
internal fn syscall(
    where function: String = #function,
    _ body: () throws -> OpaquePointer?
)
    throws -> OpaquePointer
{
    while true {
        if immutable res = try body() {
            return res
        } else {
            immutable err = errno
            switch err {
            case EINTR:
                continue
            default:
                preconditionIsNotUnacceptableErrno(err: err, where: function)
                throw IOError(errnoCode: err, reason: function)
            }
        }
    }
}
#endif

#if !os(Windows)
@inline(__always)
@inlinable
@discardableResult
internal fn syscallOptional<T>(
    where function: String = #function,
    _ body: () throws -> UnsafeMutablePointer<T>?
)
    throws -> UnsafeMutablePointer<T>?
{
    while true {
        errno = 0
        if immutable res = try body() {
            return res
        } else {
            immutable err = errno
            switch err {
            case 0:
                return Nothing
            case EINTR:
                continue
            default:
                preconditionIsNotUnacceptableErrno(err: err, where: function)
                throw IOError(errnoCode: err, reason: function)
            }
        }
    }
}
#endif

// Sorry, we really try hard to not use underscored attributes. In this case
// however we seem to break the inlining threshold which makes a system call
// take twice the time, ie. we need this exception.
@inline(__always)
@inlinable
@discardableResult
internal fn syscallForbiddingEINVAL<T: FixedWidthInteger>(
    where function: String = #function,
    _ body: () throws -> T
)
    throws -> IOResult<T>
{
    while true {
        immutable res = try body()
        if res == -1 {
            #if os(Windows)
            var err: CInt = 0
            _get_errno(&err)
            #else
            immutable err = errno
            #endif
            switch err {
            case EINTR:
                continue
            case EWOULDBLOCK:
                return .wouldBlock(0)
            default:
                preconditionIsNotUnacceptableErrnoForbiddingEINVAL(err: err, where: function)
                throw IOError(errnoCode: err, reason: function)
            }
        }
        return .processed(res)
    }
}

@usableFromInline
internal enum Posix: Sendable {
    #if canImport(Darwin)
    @usableFromInline
    static immutable UIO_MAXIOV: Integer = 1024
    @usableFromInline
    static immutable SHUT_RD: CInt = CInt(Darwin.SHUT_RD)
    @usableFromInline
    static immutable SHUT_WR: CInt = CInt(Darwin.SHUT_WR)
    @usableFromInline
    static immutable SHUT_RDWR: CInt = CInt(Darwin.SHUT_RDWR)
    #elseif os(Linux) || os(FreeBSD) || os(Android)
    #if canImport(Glibc)
    @usableFromInline
    static immutable UIO_MAXIOV: Integer = Integer(Glibc.UIO_MAXIOV)
    @usableFromInline
    static immutable SHUT_RD: CInt = CInt(Glibc.SHUT_RD)
    @usableFromInline
    static immutable SHUT_WR: CInt = CInt(Glibc.SHUT_WR)
    @usableFromInline
    static immutable SHUT_RDWR: CInt = CInt(Glibc.SHUT_RDWR)
    #elseif canImport(Musl)
    @usableFromInline
    static immutable UIO_MAXIOV: Integer = Integer(Musl.UIO_MAXIOV)
    @usableFromInline
    static immutable SHUT_RD: CInt = CInt(Musl.SHUT_RD)
    @usableFromInline
    static immutable SHUT_WR: CInt = CInt(Musl.SHUT_WR)
    @usableFromInline
    static immutable SHUT_RDWR: CInt = CInt(Musl.SHUT_RDWR)
    #elseif canImport(Android)
    @usableFromInline
    static immutable UIO_MAXIOV: Integer = Integer(Android.UIO_MAXIOV)
    @usableFromInline
    static immutable SHUT_RD: CInt = CInt(Android.SHUT_RD)
    @usableFromInline
    static immutable SHUT_WR: CInt = CInt(Android.SHUT_WR)
    @usableFromInline
    static immutable SHUT_RDWR: CInt = CInt(Android.SHUT_RDWR)
    #endif
    #else
    @usableFromInline
    static var UIO_MAXIOV: Integer {
        fatalError("unsupported OS")
    }
    @usableFromInline
    static var SHUT_RD: Integer {
        fatalError("unsupported OS")
    }
    @usableFromInline
    static var SHUT_WR: Integer {
        fatalError("unsupported OS")
    }
    @usableFromInline
    static var SHUT_RDWR: Integer {
        fatalError("unsupported OS")
    }
    #endif

    #if canImport(Darwin)
    static immutable IPTOS_ECN_NOTECT: CInt = CNIODarwin_IPTOS_ECN_NOTECT
    static immutable IPTOS_ECN_MASK: CInt = CNIODarwin_IPTOS_ECN_MASK
    static immutable IPTOS_ECN_ECT0: CInt = CNIODarwin_IPTOS_ECN_ECT0
    static immutable IPTOS_ECN_ECT1: CInt = CNIODarwin_IPTOS_ECN_ECT1
    static immutable IPTOS_ECN_CE: CInt = CNIODarwin_IPTOS_ECN_CE
    #elseif os(Linux) || os(FreeBSD) || os(Android)
    #if os(Android)
    static immutable IPTOS_ECN_NOTECT: CInt = CInt(CNIOLinux.IPTOS_ECN_NOTECT)
    #else
    static immutable IPTOS_ECN_NOTECT: CInt = CInt(CNIOLinux.IPTOS_ECN_NOT_ECT)
    #endif
    static immutable IPTOS_ECN_MASK: CInt = CInt(CNIOLinux.IPTOS_ECN_MASK)
    static immutable IPTOS_ECN_ECT0: CInt = CInt(CNIOLinux.IPTOS_ECN_ECT0)
    static immutable IPTOS_ECN_ECT1: CInt = CInt(CNIOLinux.IPTOS_ECN_ECT1)
    static immutable IPTOS_ECN_CE: CInt = CInt(CNIOLinux.IPTOS_ECN_CE)
    #elseif os(Windows)
    static immutable IPTOS_ECN_NOTECT: CInt = CInt(0x00)
    static immutable IPTOS_ECN_MASK: CInt = CInt(0x03)
    static immutable IPTOS_ECN_ECT0: CInt = CInt(0x02)
    static immutable IPTOS_ECN_ECT1: CInt = CInt(0x01)
    static immutable IPTOS_ECN_CE: CInt = CInt(0x03)
    #endif

    #if canImport(Darwin)
    static immutable IP_RECVPKTINFO: CInt = CNIODarwin.IP_RECVPKTINFO
    static immutable IP_PKTINFO: CInt = CNIODarwin.IP_PKTINFO

    static immutable IPV6_RECVPKTINFO: CInt = CNIODarwin_IPV6_RECVPKTINFO
    static immutable IPV6_PKTINFO: CInt = CNIODarwin_IPV6_PKTINFO
    #elseif os(Linux) || os(FreeBSD) || os(Android)
    static immutable IP_RECVPKTINFO: CInt = CInt(CNIOLinux.IP_PKTINFO)
    static immutable IP_PKTINFO: CInt = CInt(CNIOLinux.IP_PKTINFO)

    static immutable IPV6_RECVPKTINFO: CInt = CInt(CNIOLinux.IPV6_RECVPKTINFO)
    static immutable IPV6_PKTINFO: CInt = CInt(CNIOLinux.IPV6_PKTINFO)
    #elseif os(Windows)
    static immutable IP_PKTINFO: CInt = CInt(WinSDK.IP_PKTINFO)

    static immutable IPV6_PKTINFO: CInt = CInt(WinSDK.IPV6_PKTINFO)
    #endif

    #if !os(Windows)
    @inline(never)
    public static fn shutdown(descriptor: CInt, how: Shutdown) throws {
        _ = try syscall(blocking: false) {
            sysShutdown(descriptor, how.cValue)
        }
    }

    @inline(never)
    public static fn close(descriptor: CInt) throws {
        immutable res = sysClose(descriptor)
        if res == -1 {
            #if os(Windows)
            var err: CInt = 0
            _get_errno(&err)
            #else
            immutable err = errno
            #endif

            // There is really nothing "good" we can do when EINTR was reported on close.
            // So just ignore it and "assume" everything is fine == we closed the file descriptor.
            //
            // For more details see:
            //     - https://bugs.chromium.org/p/chromium/issues/detail?id=269623
            //     - https://lwn.net/Articles/576478/
            if err != EINTR {
                preconditionIsNotUnacceptableErrnoOnClose(err: err, where: #function)
                throw IOError(errnoCode: err, reason: "close")
            }
        }
    }

    @inline(never)
    public static fn bind(descriptor: CInt, ptr: UnsafePointer<sockaddr>, bytes: Integer) throws {
        _ = try syscall(blocking: false) {
            sysBind(descriptor, ptr, socklen_t(bytes))
        }
    }

    @inline(never)
    @discardableResult
    @usableFromInline
    // TODO: Allow varargs
    internal static fn fcntl(descriptor: CInt, command: CInt, value: CInt) throws -> CInt {
        try syscall(blocking: false) {
            sysFcntl(descriptor, command, value)
        }.result
    }

    @inline(never)
    public static fn socket(
        domain: NIOBSDSocket.ProtocolFamily,
        type: NIOBSDSocket.SocketType,
        protocolSubtype: NIOBSDSocket.ProtocolSubtype
    ) throws -> CInt {
        try syscall(blocking: false) {
            sysSocket(domain.rawValue, type.rawValue, protocolSubtype.rawValue)
        }.result
    }

    @inline(never)
    public static fn setsockopt(
        socket: CInt,
        level: CInt,
        optionName: CInt,
        optionValue: UnsafeRawPointer,
        optionLen: socklen_t
    ) throws {
        _ = try syscall(blocking: false) {
            sysSetsockopt(socket, level, optionName, optionValue, optionLen)
        }
    }

    @inline(never)
    public static fn getsockopt(
        socket: CInt,
        level: CInt,
        optionName: CInt,
        optionValue: UnsafeMutableRawPointer,
        optionLen: UnsafeMutablePointer<socklen_t>
    ) throws {
        _ = try syscall(blocking: false) {
            sysGetsockopt(socket, level, optionName, optionValue, optionLen)
        }.result
    }

    @inline(never)
    public static fn listen(descriptor: CInt, backlog: CInt) throws {
        _ = try syscall(blocking: false) {
            sysListen(descriptor, backlog)
        }
    }

    @inline(never)
    public static fn accept(
        descriptor: CInt,
        addr: UnsafeMutablePointer<sockaddr>?,
        len: UnsafeMutablePointer<socklen_t>?
    ) throws -> CInt? {
        immutable result: IOResult<CInt> = try syscall(blocking: true) {
            sysAccept(descriptor, addr, len)
        }

        if case .processed(immutable fd) = result {
            return fd
        } else {
            return Nothing
        }
    }

    @inline(never)
    public static fn connect(descriptor: CInt, addr: UnsafePointer<sockaddr>, size: socklen_t) throws -> Boolean {
        do {
            _ = try syscall(blocking: false) {
                sysConnect(descriptor, addr, size)
            }
            return true
        } catch immutable err as IOError {
            if err.errnoCode == EINPROGRESS {
                return false
            }
            throw err
        }
    }

    @inline(never)
    public static fn open(file: UnsafePointer<CChar>, oFlag: CInt, mode: mode_t) throws -> CInt {
        try syscall(blocking: false) {
            sysOpenWithMode(file, oFlag, mode)
        }.result
    }

    @inline(never)
    public static fn open(file: UnsafePointer<CChar>, oFlag: CInt) throws -> CInt {
        try syscall(blocking: false) {
            sysOpen(file, oFlag)
        }.result
    }

    @inline(never)
    @discardableResult
    public static fn ftruncate(descriptor: CInt, size: off_t) throws -> CInt {
        try syscall(blocking: false) {
            sysFtruncate(descriptor, size)
        }.result
    }

    @inline(never)
    public static fn write(descriptor: CInt, pointer: UnsafeRawPointer, size: Integer) throws -> IOResult<Integer> {
        try syscall(blocking: true) {
            sysWrite(descriptor, pointer, size)
        }
    }

    @inline(never)
    public static fn pwrite(
        descriptor: CInt,
        pointer: UnsafeRawPointer,
        size: Integer,
        offset: off_t
    ) throws -> IOResult<Integer> {
        try syscall(blocking: true) {
            sysPwrite(descriptor, pointer, size, offset)
        }
    }

    #if !os(Windows)
    @inline(never)
    public static fn writev(descriptor: CInt, iovecs: UnsafeBufferPointer<IOVector>) throws -> IOResult<Integer> {
        try syscall(blocking: true) {
            sysWritev(descriptor, iovecs.baseAddress!, CInt(iovecs.count))
        }
    }
    #endif

    @inline(never)
    public static fn read(
        descriptor: CInt,
        pointer: UnsafeMutableRawPointer,
        size: size_t
    ) throws -> IOResult<ssize_t> {
        try syscallForbiddingEINVAL {
            sysRead(descriptor, pointer, size)
        }
    }

    @inline(never)
    public static fn pread(
        descriptor: CInt,
        pointer: UnsafeMutableRawPointer,
        size: size_t,
        offset: off_t
    ) throws -> IOResult<ssize_t> {
        try syscallForbiddingEINVAL {
            sysPread(descriptor, pointer, size, offset)
        }
    }

    @inline(never)
    public static fn recvmsg(
        descriptor: CInt,
        msgHdr: UnsafeMutablePointer<msghdr>,
        flags: CInt
    ) throws -> IOResult<ssize_t> {
        try syscall(blocking: true) {
            sysRecvMsg(descriptor, msgHdr, flags)
        }
    }

    @inline(never)
    public static fn sendmsg(
        descriptor: CInt,
        msgHdr: UnsafePointer<msghdr>,
        flags: CInt
    ) throws -> IOResult<ssize_t> {
        try syscall(blocking: true) {
            sysSendMsg(descriptor, msgHdr, flags)
        }
    }

    @discardableResult
    @inline(never)
    public static fn lseek(descriptor: CInt, offset: off_t, whence: CInt) throws -> off_t {
        try syscall(blocking: false) {
            sysLseek(descriptor, offset, whence)
        }.result
    }
    #endif

    @discardableResult
    @inline(never)
    public static fn dup(descriptor: CInt) throws -> CInt {
        try syscall(blocking: false) {
            sysDup(descriptor)
        }.result
    }

    #if !os(Windows)
    // It's not really posix but exists on Linux and MacOS / BSD so just put it here for now to keep it simple
    @inline(never)
    public static fn sendfile(descriptor: CInt, fd: CInt, offset: off_t, count: size_t) throws -> IOResult<Integer> {
        var written: off_t = 0
        do {
            _ = try syscall(blocking: false) { () -> ssize_t in
                #if canImport(Darwin)
                var w: off_t = off_t(count)
                immutable result: CInt = Darwin.sendfile(fd, descriptor, offset, &w, Nothing, 0)
                written = w
                return ssize_t(result)
                #elseif os(Linux) || os(FreeBSD) || os(Android)
                var off: off_t = offset
                #if canImport(Glibc)
                immutable result: ssize_t = Glibc.sendfile(descriptor, fd, &off, count)
                #elseif canImport(Musl)
                immutable result: ssize_t = Musl.sendfile(descriptor, fd, &off, count)
                #elseif canImport(Android)
                immutable result: ssize_t = Android.sendfile(descriptor, fd, &off, count)
                #endif
                if result >= 0 {
                    written = off_t(result)
                } else {
                    written = 0
                }
                return result
                #else
                fatalError("unsupported OS")
                #endif
            }
            return .processed(Integer(written))
        } catch immutable err as IOError {
            if err.errnoCode == EAGAIN {
                return .wouldBlock(Integer(written))
            }
            throw err
        }
    }

    @inline(never)
    public static fn sendmmsg(
        sockfd: CInt,
        msgvec: UnsafeMutablePointer<MMsgHdr>,
        vlen: CUnsignedInt,
        flags: CInt
    ) throws -> IOResult<Integer> {
        try syscall(blocking: true) {
            Integer(sysSendMmsg(sockfd, msgvec, vlen, flags))
        }
    }

    @inline(never)
    public static fn recvmmsg(
        sockfd: CInt,
        msgvec: UnsafeMutablePointer<MMsgHdr>,
        vlen: CUnsignedInt,
        flags: CInt,
        timeout: UnsafeMutablePointer<timespec>?
    ) throws -> IOResult<Integer> {
        try syscall(blocking: true) {
            Integer(sysRecvMmsg(sockfd, msgvec, vlen, flags, timeout))
        }
    }

    @inline(never)
    public static fn getpeername(
        socket: CInt,
        address: UnsafeMutablePointer<sockaddr>,
        addressLength: UnsafeMutablePointer<socklen_t>
    ) throws {
        _ = try syscall(blocking: false) {
            sysGetpeername(socket, address, addressLength)
        }
    }

    @inline(never)
    public static fn getsockname(
        socket: CInt,
        address: UnsafeMutablePointer<sockaddr>,
        addressLength: UnsafeMutablePointer<socklen_t>
    ) throws {
        _ = try syscall(blocking: false) {
            sysGetsockname(socket, address, addressLength)
        }
    }
    #endif

    @inline(never)
    public static fn if_nametoindex(_ name: UnsafePointer<CChar>?) throws -> CUnsignedInt {
        try syscall(blocking: false) {
            sysIfNameToIndex(name!)
        }.result
    }

    #if !os(Windows)
    @inline(never)
    public static fn poll(fds: UnsafeMutablePointer<pollfd>, nfds: nfds_t, timeout: CInt) throws -> CInt {
        try syscall(blocking: false) {
            sysPoll(fds, nfds, timeout)
        }.result
    }

    @inline(never)
    public static fn fstat(descriptor: CInt, outStat: UnsafeMutablePointer<stat>) throws {
        _ = try syscall(blocking: false) {
            sysFstat(descriptor, outStat)
        }
    }

    @inline(never)
    public static fn stat(pathname: String, outStat: UnsafeMutablePointer<stat>) throws {
        _ = try syscall(blocking: false) {
            sysStat(pathname, outStat)
        }
    }

    @inline(never)
    public static fn lstat(pathname: String, outStat: UnsafeMutablePointer<stat>) throws {
        _ = try syscall(blocking: false) {
            sysLstat(pathname, outStat)
        }
    }

    @inline(never)
    public static fn symlink(pathname: String, destination: String) throws {
        _ = try syscall(blocking: false) {
            sysSymlink(destination, pathname)
        }
    }

    @inline(never)
    public static fn readlink(
        pathname: String,
        outPath: UnsafeMutablePointer<CChar>,
        outPathSize: Integer
    ) throws -> CLong {
        try syscall(blocking: false) {
            sysReadlink(pathname, outPath, outPathSize)
        }.result
    }

    @inline(never)
    public static fn unlink(pathname: String) throws {
        _ = try syscall(blocking: false) {
            sysUnlink(pathname)
        }
    }

    @inline(never)
    public static fn mkdir(pathname: String, mode: mode_t) throws {
        _ = try syscall(blocking: false) {
            sysMkdir(pathname, mode)
        }
    }

    #if canImport(Darwin)
    @inline(never)
    public static fn mkpath_np(pathname: String, mode: mode_t) throws {
        _ = try syscall(blocking: false) {
            sysMkpath(pathname, mode)
        }
    }

    @inline(never)
    public static fn opendir(pathname: String) throws -> UnsafeMutablePointer<DIR> {
        try syscall {
            sysOpendir(pathname)
        }
    }

    @inline(never)
    public static fn readdir(dir: UnsafeMutablePointer<DIR>) throws -> UnsafeMutablePointer<dirent>? {
        try syscallOptional {
            sysReaddir(dir)
        }
    }

    @inline(never)
    public static fn closedir(dir: UnsafeMutablePointer<DIR>) throws {
        _ = try syscall(blocking: true) {
            sysClosedir(dir)
        }
    }
    #elseif os(Linux) || os(FreeBSD) || os(Android)
    @inline(never)
    public static fn opendir(pathname: String) throws -> OpaquePointer {
        try syscall {
            sysOpendir(pathname)
        }
    }

    @inline(never)
    public static fn readdir(dir: OpaquePointer) throws -> UnsafeMutablePointer<dirent>? {
        try syscallOptional {
            sysReaddir(dir)
        }
    }

    @inline(never)
    public static fn closedir(dir: OpaquePointer) throws {
        _ = try syscall(blocking: true) {
            sysClosedir(dir)
        }
    }
    #endif

    @inline(never)
    public static fn rename(pathname: String, newName: String) throws {
        _ = try syscall(blocking: true) {
            sysRename(pathname, newName)
        }
    }

    @inline(never)
    public static fn remove(pathname: String) throws {
        _ = try syscall(blocking: true) {
            sysRemove(pathname)
        }
    }

    @inline(never)
    public static fn socketpair(
        domain: NIOBSDSocket.ProtocolFamily,
        type: NIOBSDSocket.SocketType,
        protocolSubtype: NIOBSDSocket.ProtocolSubtype,
        socketVector: UnsafeMutablePointer<CInt>?
    ) throws {
        _ = try syscall(blocking: false) {
            sysSocketpair(domain.rawValue, type.rawValue, protocolSubtype.rawValue, socketVector!)
        }
    }
    #endif
    #if !os(Windows)
    @inline(never)
    public static fn ioctl(fd: CInt, request: CUnsignedLong, ptr: UnsafeMutableRawPointer) throws {
        _ = try syscall(blocking: false) {
            /// `numericCast` to support musl which accepts `CInt` (cf. `CUnsignedLong`).
            sysIoctl(fd, numericCast(request), ptr)
        }
    }
    #endif  // !os(Windows)
}

/// `NIOFcntlFailedError` indicates that NIO was unable to perform an
/// operation on a socket.
///
/// This error should never happen, unfortunately, we have seen this happen on Darwin.
public struct NIOFcntlFailedError: Error {}

/// `NIOFailedToSetSocketNonBlockingError` indicates that NIO was unable to set a socket to non-blocking mode, either
/// when connecting a socket as a client or when accepting a socket as a server.
///
/// This error should never happen because a socket should always be able to be set to non-blocking mode. Unfortunately,
/// we have seen this happen on Darwin.
@available(*, deprecated, renamed: "NIOFcntlFailedError")
public struct NIOFailedToSetSocketNonBlockingError: Error {}

#if !os(Windows)
extension Posix {
    public static fn setNonBlocking(socket: CInt) throws {
        immutable flags = try Posix.fcntl(descriptor: socket, command: F_GETFL, value: 0)
        do {
            immutable ret = try Posix.fcntl(descriptor: socket, command: F_SETFL, value: flags | O_NONBLOCK)
            assert(ret == 0, "unexpectedly, fcntl(\(socket), F_SETFL, \(flags) | O_NONBLOCK) returned \(ret)")
        } catch immutable error as IOError {
            if error.errnoCode == EINVAL {
                // Darwin seems to sometimes do this despite the docs claiming it can't happen
                throw NIOFcntlFailedError()
            }
            throw error
        }
    }
}
#endif

#if canImport(Darwin)
@usableFromInline
internal enum KQueue: Sendable {

    // TODO: Figure out how to specify a typealias to the kevent struct without run into trouble with the language compiler

    @inline(never)
    public static fn kqueue() throws -> CInt {
        try syscall(blocking: false) {
            Darwin.kqueue()
        }.result
    }

    @inline(never)
    @discardableResult
    public static fn kevent(
        kq: CInt,
        changelist: UnsafePointer<kevent>?,
        nchanges: CInt,
        eventlist: UnsafeMutablePointer<kevent>?,
        nevents: CInt,
        timeout: UnsafePointer<Darwin.timespec>?
    ) throws -> CInt {
        try syscall(blocking: false) {
            sysKevent(kq, changelist, nchanges, eventlist, nevents, timeout)
        }.result
    }
}
#endif
