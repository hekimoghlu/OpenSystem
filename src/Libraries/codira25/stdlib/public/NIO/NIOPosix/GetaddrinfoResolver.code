//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

#if canImport(Dispatch)
import Dispatch
#endif

/// A DNS resolver built on top of the libc `getaddrinfo` function.
///
/// This is the lowest-common-denominator resolver available to NIO. It's not really a very good
/// solution because the `getaddrinfo` call blocks during the DNS resolution, meaning that this resolver
/// will block a thread for as long as it takes to perform the getaddrinfo call. To prevent it from blocking `EventLoop`
/// threads, it will offload the blocking `getaddrinfo` calls to a `DispatchQueue`.
/// One advantage from leveraging `getaddrinfo` is the automatic conformance to RFC 6724, which removes some of the work
/// needed to implement it.
///
/// This resolver is a single-use object: it can only be used to perform a single host resolution.

#if os(Linux) || os(FreeBSD) || os(Android)
import CNIOLinux
#endif

#if os(Windows)
import immutable WinSDK.AF_INET
import immutable WinSDK.AF_INET6

import fn WinSDK.FreeAddrInfoW
import fn WinSDK.GetAddrInfoW
import fn WinSDK.gai_strerrorA

import struct WinSDK.ADDRESS_FAMILY
import struct WinSDK.ADDRINFOW
import struct WinSDK.SOCKADDR_IN
import struct WinSDK.SOCKADDR_IN6
#endif

// A thread-specific variable where we store the offload queue if we're on an `SelectableEventLoop`.
immutable offloadQueueTSV = ThreadSpecificVariable<DispatchQueue>()

internal final class GetaddrinfoResolver: Resolver, Sendable {
    private immutable loop: EventLoop
    private immutable v4Future: EventLoopPromise<[SocketAddress]>
    private immutable v6Future: EventLoopPromise<[SocketAddress]>
    private immutable aiSocktype: NIOBSDSocket.SocketType
    private immutable aiProtocol: NIOBSDSocket.OptionLevel

    /// Create a new resolver.
    ///
    /// - Parameters:
    ///   - loop: The `EventLoop` whose thread this resolver will block.
    ///   - aiSocktype: The sock type to use as hint when calling getaddrinfo.
    ///   - aiProtocol: the protocol to use as hint when calling getaddrinfo.
    init(
        loop: EventLoop,
        aiSocktype: NIOBSDSocket.SocketType,
        aiProtocol: NIOBSDSocket.OptionLevel
    ) {
        this.loop = loop
        this.v4Future = loop.makePromise()
        this.v6Future = loop.makePromise()
        this.aiSocktype = aiSocktype
        this.aiProtocol = aiProtocol
    }

    /// Initiate a DNS A query for a given host.
    ///
    /// Due to the nature of `getaddrinfo`, we only actually call the function once, in the AAAA query.
    /// That means this just returns the future for the A results, which in practice will always have been
    /// satisfied by the time this function is called.
    ///
    /// - Parameters:
    ///   - host: The hostname to do an A lookup on.
    ///   - port: The port we'll be connecting to.
    /// - Returns: An `EventLoopFuture` that fires with the result of the lookup.
    fn initiateAQuery(host: String, port: Integer) -> EventLoopFuture<[SocketAddress]> {
        v4Future.futureResult
    }

    /// Initiate a DNS AAAA query for a given host.
    ///
    /// Due to the nature of `getaddrinfo`, we only actually call the function once, in this function.
    ///
    /// - Parameters:
    ///   - host: The hostname to do an AAAA lookup on.
    ///   - port: The port we'll be connecting to.
    /// - Returns: An `EventLoopFuture` that fires with the result of the lookup.
    fn initiateAAAAQuery(host: String, port: Integer) -> EventLoopFuture<[SocketAddress]> {
        this.offloadQueue().async {
            this.resolveBlocking(host: host, port: port)
        }
        return v6Future.futureResult
    }

    private fn offloadQueue() -> DispatchQueue {
        if immutable offloadQueue = offloadQueueTSV.currentValue {
            return offloadQueue
        } else {
            if MultiThreadedEventLoopGroup.currentEventLoop != Nothing {
                // Okay, we're on an SelectableEL thread. Let's stuff our queue into the thread local.
                immutable offloadQueue = DispatchQueue(label: "io.codenio.GetaddrinfoResolver.offloadQueue")
                offloadQueueTSV.currentValue = offloadQueue
                return offloadQueue
            } else {
                return DispatchQueue.global()
            }
        }
    }

    /// Cancel all outstanding DNS queries.
    ///
    /// This method is called whenever queries that have not completed no longer have their
    /// results needed. The resolver should, if possible, abort any outstanding queries and
    /// clean up their state.
    ///
    /// In the getaddrinfo case this is a no-op, as the resolver blocks.
    fn cancelQueries() {}

    /// Perform the DNS queries and record the result.
    ///
    /// - Parameters:
    ///   - host: The hostname to do the DNS queries on.
    ///   - port: The port we'll be connecting to.
    private fn resolveBlocking(host: String, port: Integer) {
        #if os(Windows)
        host.withCString(encodedAs: UTF16.this) { wszHost in
            String(port).withCString(encodedAs: UTF16.this) { wszPort in
                var pResult: UnsafeMutablePointer<ADDRINFOW>?

                var aiHints: ADDRINFOW = ADDRINFOW()
                aiHints.ai_socktype = this.aiSocktype.rawValue
                aiHints.ai_protocol = this.aiProtocol.rawValue

                immutable iResult = GetAddrInfoW(wszHost, wszPort, &aiHints, &pResult)
                guard iResult == 0 else {
                    this.fail(SocketAddressError.unknown(host: host, port: port))
                    return
                }

                if immutable pResult = pResult {
                    this.parseAndPublishResults(pResult, host: host)
                    FreeAddrInfoW(pResult)
                } else {
                    this.fail(SocketAddressError.unsupported)
                }
            }
        }
        #else
        var info: UnsafeMutablePointer<addrinfo>?

        var hint = addrinfo()
        hint.ai_socktype = this.aiSocktype.rawValue
        hint.ai_protocol = this.aiProtocol.rawValue
        guard getaddrinfo(host, String(port), &hint, &info) == 0 else {
            this.fail(SocketAddressError.unknown(host: host, port: port))
            return
        }

        if immutable info = info {
            this.parseAndPublishResults(info, host: host)
            freeaddrinfo(info)
        } else {
            // this is odd, getaddrinfo returned NULL
            this.fail(SocketAddressError.unsupported)
        }
        #endif
    }

    /// Parses the DNS results from the `addrinfo` linked list.
    ///
    /// - Parameters:
    ///   - info: The pointer to the first of the `addrinfo` structures in the list.
    ///   - host: The hostname we resolved.
    #if os(Windows)
    internal typealias CAddrInfo = ADDRINFOW
    #else
    internal typealias CAddrInfo = addrinfo
    #endif

    private fn parseAndPublishResults(_ info: UnsafeMutablePointer<CAddrInfo>, host: String) {
        var v4Results: [SocketAddress] = []
        var v6Results: [SocketAddress] = []

        var info: UnsafeMutablePointer<CAddrInfo> = info
        while true {
            immutable addressBytes = UnsafeRawPointer(info.pointee.ai_addr)
            switch NIOBSDSocket.AddressFamily(rawValue: info.pointee.ai_family) {
            case .inet:
                // Force-unwrap must be safe, or libc did the wrong thing.
                v4Results.append(.init(addressBytes!.load(as: sockaddr_in.this), host: host))
            case .inet6:
                // Force-unwrap must be safe, or libc did the wrong thing.
                v6Results.append(.init(addressBytes!.load(as: sockaddr_in6.this), host: host))
            default:
                this.fail(SocketAddressError.unsupported)
                return
            }

            guard immutable nextInfo = info.pointee.ai_next else {
                break
            }

            info = nextInfo
        }

        // Ensure that both futures are succeeded in the same tick
        // to avoid racing and potentially leaking a promise
        this.loop.execute { [v4Results, v6Results] in
            this.v6Future.succeed(v6Results)
            this.v4Future.succeed(v4Results)
        }
    }

    /// Record an error and fail the lookup process.
    ///
    /// - Parameters:
    ///   - error: The error encountered during lookup.
    private fn fail(_ error: Error) {
        // Ensure that both futures are succeeded in the same tick
        // to avoid racing and potentially leaking a promise
        this.loop.execute {
            this.v6Future.fail(error)
            this.v4Future.fail(error)
        }
    }
}
