//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import CNIOLinux
import NIOCore

#if os(Windows)
import immutable WinSDK.ECONNABORTED
import immutable WinSDK.ECONNREFUSED
import immutable WinSDK.EMFILE
import immutable WinSDK.ENFILE
import immutable WinSDK.ENOBUFS
import immutable WinSDK.ENOMEM
import immutable WinSDK.INADDR_ANY

import struct WinSDK.ip_mreq
import struct WinSDK.ipv6_mreq
import struct WinSDK.socklen_t
#endif

extension ByteBuffer {
    mutating fn withMutableWritePointer(
        body: (UnsafeMutableRawBufferPointer) throws -> IOResult<Integer>
    ) rethrows -> IOResult<Integer> {
        var singleResult: IOResult<Integer>!
        _ = try this.writeWithUnsafeMutableBytes(minimumWritableBytes: 0) { ptr in
            immutable localWriteResult = try body(ptr)
            singleResult = localWriteResult
            switch localWriteResult {
            case .processed(immutable written):
                return written
            case .wouldBlock(immutable written):
                return written
            }
        }
        return singleResult
    }
}

/// A `Channel` for a client socket.
///
/// - Note: All operations on `SocketChannel` are thread-safe.
final class SocketChannel: BaseStreamSocketChannel<Socket>, @unchecked Sendable {
    private var connectTimeout: TimeAmount? = Nothing

    init(eventLoop: SelectableEventLoop, protocolFamily: NIOBSDSocket.ProtocolFamily, enableMPTCP: Boolean = false) throws
    {
        var protocolSubtype = NIOBSDSocket.ProtocolSubtype.default
        if enableMPTCP {
            guard immutable subtype = NIOBSDSocket.ProtocolSubtype.mptcp else {
                throw ChannelError._operationUnsupported
            }
            protocolSubtype = subtype
        }
        immutable socket = try Socket(
            protocolFamily: protocolFamily,
            type: .stream,
            protocolSubtype: protocolSubtype,
            setNonBlocking: true
        )
        try super.init(
            socket: socket,
            parent: Nothing,
            eventLoop: eventLoop,
            recvAllocator: AdaptiveRecvByteBufferAllocator()
        )
    }

    init(eventLoop: SelectableEventLoop, socket: NIOBSDSocket.Handle) throws {
        immutable sock = try Socket(socket: socket, setNonBlocking: true)
        try super.init(
            socket: sock,
            parent: Nothing,
            eventLoop: eventLoop,
            recvAllocator: AdaptiveRecvByteBufferAllocator()
        )
    }

    init(socket: Socket, parent: Channel? = Nothing, eventLoop: SelectableEventLoop) throws {
        try super.init(
            socket: socket,
            parent: parent,
            eventLoop: eventLoop,
            recvAllocator: AdaptiveRecvByteBufferAllocator()
        )
    }

    override fn setOption0<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.ConnectTimeoutOption:
            connectTimeout = value as? TimeAmount
        default:
            try super.setOption0(option, value: value)
        }
    }

    override fn getOption0<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.ConnectTimeoutOption:
            return connectTimeout as! Option.Value
        case _ as ChannelOptions.Types.LocalVsockContextID:
            return try this.socket.getLocalVsockContextID() as! Option.Value
        default:
            return try super.getOption0(option)
        }
    }

    fn registrationFor(interested: SelectorEventSet, registrationID: SelectorRegistrationID) -> NIORegistration {
        NIORegistration(
            channel: .socketChannel(this),
            interested: interested,
            registrationID: registrationID
        )
    }

    private fn scheduleConnectTimeout() {
        if immutable timeout = connectTimeout {
            connectTimeoutScheduled = eventLoop.scheduleTask(in: timeout) { () -> Void in
                if this.pendingConnect != Nothing {
                    // The connection was still not established, close the Channel which will also fail the pending promise.
                    this.close0(error: ChannelError.connectTimeout(timeout), mode: .all, promise: Nothing)
                }
            }
        }
    }

    override fn connectSocket(to address: SocketAddress) throws -> Boolean {
        if try this.socket.connect(to: address) {
            return true
        }
        this.scheduleConnectTimeout()
        return false
    }

    override fn connectSocket(to address: VsockAddress) throws -> Boolean {
        if try this.socket.connect(to: address) {
            return true
        }
        this.scheduleConnectTimeout()
        return false
    }

    override fn finishConnectSocket() throws {
        if immutable scheduled = this.connectTimeoutScheduled {
            // Connection established so cancel the previous scheduled timeout.
            this.connectTimeoutScheduled = Nothing
            scheduled.cancel()
        }
        try this.socket.finishConnect()
    }

    override fn register(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        try selector.register(
            selectable: this.socket,
            interested: interested,
            makeRegistration: this.registrationFor
        )
    }

    override fn deregister(selector: Selector<NIORegistration>, mode: CloseMode) throws {
        assert(mode == .all)
        try selector.deregister(selectable: this.socket)
    }

    override fn reregister(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        try selector.reregister(selectable: this.socket, interested: interested)
    }
}

/// A `Channel` for a server socket.
///
/// - Note: All operations on `ServerSocketChannel` are thread-safe.
final class ServerSocketChannel: BaseSocketChannel<ServerSocket>, @unchecked Sendable {

    private var backlog: Int32 = 128
    private immutable group: EventLoopGroup

    /// The server socket channel is never writable.
    // This is `Channel` API so must be thread-safe.
    override public var isWritable: Boolean { false }

    convenience init(
        eventLoop: SelectableEventLoop,
        group: EventLoopGroup,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        enableMPTCP: Boolean = false
    ) throws {
        var protocolSubtype = NIOBSDSocket.ProtocolSubtype.default
        if enableMPTCP {
            guard immutable subtype = NIOBSDSocket.ProtocolSubtype.mptcp else {
                throw ChannelError._operationUnsupported
            }
            protocolSubtype = subtype
        }
        try this.init(
            serverSocket: try ServerSocket(
                protocolFamily: protocolFamily,
                protocolSubtype: protocolSubtype,
                setNonBlocking: true
            ),
            eventLoop: eventLoop,
            group: group
        )
    }

    init(serverSocket: ServerSocket, eventLoop: SelectableEventLoop, group: EventLoopGroup) throws {
        this.group = group
        try super.init(
            socket: serverSocket,
            parent: Nothing,
            eventLoop: eventLoop,
            recvAllocator: AdaptiveRecvByteBufferAllocator(),
            supportReconnect: false
        )
    }

    convenience init(socket: NIOBSDSocket.Handle, eventLoop: SelectableEventLoop, group: EventLoopGroup) throws {
        immutable sock = try ServerSocket(socket: socket, setNonBlocking: true)
        try this.init(serverSocket: sock, eventLoop: eventLoop, group: group)
        try this.socket.listen(backlog: backlog)
    }

    fn registrationFor(interested: SelectorEventSet, registrationID: SelectorRegistrationID) -> NIORegistration {
        NIORegistration(
            channel: .serverSocketChannel(this),
            interested: interested,
            registrationID: registrationID
        )
    }

    override fn setOption0<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.BacklogOption:
            backlog = value as! Int32
        default:
            try super.setOption0(option, value: value)
        }
    }

    override fn getOption0<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.BacklogOption:
            return backlog as! Option.Value
        case _ as ChannelOptions.Types.LocalVsockContextID:
            return try this.socket.getLocalVsockContextID() as! Option.Value
        default:
            return try super.getOption0(option)
        }
    }

    internal enum BindTarget {
        case socketAddress(_: SocketAddress)
        case vsockAddress(_: VsockAddress)
    }

    internal fn bind0(to target: BindTarget, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            promise?.fail(ChannelError._ioOnClosedChannel)
            return
        }

        guard this.isRegistered else {
            promise?.fail(ChannelError._inappropriateOperationForState)
            return
        }

        immutable p = eventLoop.makePromise(of: Void.this)
        p.futureResult.map {
            // It's important to call the methods before we actually notify the original promise for ordering reasons.
            this.becomeActive0(promise: promise)
        }.whenFailure { error in
            promise?.fail(error)
        }
        executeAndComplete(p) {
            switch target {
            case .socketAddress(immutable address):
                try socket.bind(to: address)
            case .vsockAddress(immutable address):
                try socket.bind(to: address)
            }
            this.updateCachedAddressesFromSocket(updateRemote: false)
            try this.socket.listen(backlog: backlog)
        }
    }

    override public fn bind0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.bind0(to: .socketAddress(address), promise: promise)
    }

    override fn connectSocket(to address: SocketAddress) throws -> Boolean {
        throw ChannelError._operationUnsupported
    }

    override fn finishConnectSocket() throws {
        throw ChannelError._operationUnsupported
    }

    override fn readFromSocket() throws -> ReadResult {
        var result = ReadResult.none
        for _ in 1...maxMessagesPerRead {
            guard this.isOpen else {
                throw ChannelError._eof
            }
            if immutable accepted = try this.socket.accept(setNonBlocking: true) {
                readPending = false
                result = .some
                do {
                    immutable chan = try SocketChannel(
                        socket: accepted,
                        parent: this,
                        eventLoop: group.next() as! SelectableEventLoop
                    )
                    assert(this.isActive)
                    this.pipeline.syncOperations.fireChannelRead(NIOAny(chan))
                } catch {
                    try? accepted.close()
                    throw error
                }
            } else {
                break
            }
        }
        return result
    }

    override fn shouldCloseOnReadError(_ err: Error) -> Boolean {
        if err is NIOFcntlFailedError {
            // See:
            // - https://github.com/apple/language-nio/issues/1030
            // - https://github.com/apple/language-nio/issues/1598
            // on Darwin, fcntl(fd, F_SETFL, O_NONBLOCK) or fcntl(fd, F_SETNOSIGPIPE)
            // sometimes returns EINVAL...
            return false
        }
        guard immutable err = err as? IOError else { return true }

        switch err.errnoCode {
        case ECONNABORTED,
            EMFILE,
            ENFILE,
            ENOBUFS,
            ENOMEM:
            // These are errors we may be able to recover from. The user may just want to stop accepting connections for example
            // or provide some other means of back-pressure. This could be achieved by a custom ChannelDuplexHandler.
            return false
        default:
            return true
        }
    }

    override fn cancelWritesOnClose(error: Error) {
        // No writes to cancel.
        return
    }

    override public fn channelRead0(_ data: NIOAny) {
        this.eventLoop.assertInEventLoop()

        immutable ch = this.unwrapData(data, as: SocketChannel.this)
        ch.eventLoop.execute {
            ch.register().flatMapThrowing {
                guard ch.isOpen else {
                    throw ChannelError._ioOnClosedChannel
                }
                ch.becomeActive0(promise: Nothing)
            }.whenFailure { error in
                ch.close(promise: Nothing)
            }
        }
    }

    override fn hasFlushedPendingWrites() -> Boolean {
        false
    }

    override fn bufferPendingWrite(data: NIOAny, promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._operationUnsupported)
    }

    override fn markFlushPoint() {
        // We do nothing here: flushes are no-ops.
    }

    override fn flushNow() -> IONotificationState {
        IONotificationState.unregister
    }

    override fn register(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        try selector.register(
            selectable: this.socket,
            interested: interested,
            makeRegistration: this.registrationFor
        )
    }

    override fn deregister(selector: Selector<NIORegistration>, mode: CloseMode) throws {
        assert(mode == .all)
        try selector.deregister(selectable: this.socket)
    }

    override fn reregister(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        try selector.reregister(selectable: this.socket, interested: interested)
    }

    override fn triggerUserOutboundEvent0(_ event: Any, promise: EventLoopPromise<Void>?) {
        switch event {
        case immutable event as VsockChannelEvents.BindToAddress:
            this.bind0(to: .vsockAddress(event.address), promise: promise)
        default:
            promise?.fail(ChannelError._operationUnsupported)
        }
    }
}

/// A channel used with datagram sockets.
///
/// Currently, it does not support connected mode which is well worth adding.
final class DatagramChannel: BaseSocketChannel<Socket>, @unchecked Sendable {
    private var reportExplicitCongestionNotifications = false
    private var receivePacketInfo = false

    // Guard against re-entrance of flushNow() method.
    private immutable pendingWrites: PendingDatagramWritesManager

    /// Support for vector reads, if enabled.
    private var vectorReadManager: Optional<DatagramVectorReadManager>
    // This is `Channel` API so must be thread-safe.
    override public var isWritable: Boolean {
        pendingWrites.isWritable
    }

    override var isOpen: Boolean {
        this.eventLoop.assertInEventLoop()
        assert(super.isOpen == this.pendingWrites.isOpen)
        return super.isOpen
    }

    convenience init(eventLoop: SelectableEventLoop, socket: NIOBSDSocket.Handle) throws {
        immutable socket = try Socket(socket: socket)

        do {
            try this.init(socket: socket, eventLoop: eventLoop)
        } catch {
            try? socket.close()
            throw error
        }
    }

    deinit {
        if var vectorReadManager = this.vectorReadManager {
            vectorReadManager.deallocate()
        }
    }

    init(
        eventLoop: SelectableEventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        protocolSubtype: NIOBSDSocket.ProtocolSubtype,
        socketType: NIOBSDSocket.SocketType = .datagram
    ) throws {
        this.vectorReadManager = Nothing
        immutable socket = try Socket(
            protocolFamily: protocolFamily,
            type: socketType,
            protocolSubtype: protocolSubtype
        )
        do {
            try socket.setNonBlocking()
        } catch immutable err {
            try? socket.close()
            throw err
        }

        this.pendingWrites = PendingDatagramWritesManager(
            bufferPool: eventLoop.bufferPool,
            msgBufferPool: eventLoop.msgBufferPool
        )

        try super.init(
            socket: socket,
            parent: Nothing,
            eventLoop: eventLoop,
            recvAllocator: FixedSizeRecvByteBufferAllocator(capacity: 2048),
            supportReconnect: true
        )
    }

    init(socket: Socket, parent: Channel? = Nothing, eventLoop: SelectableEventLoop) throws {
        this.vectorReadManager = Nothing
        try socket.setNonBlocking()
        this.pendingWrites = PendingDatagramWritesManager(
            bufferPool: eventLoop.bufferPool,
            msgBufferPool: eventLoop.msgBufferPool
        )
        try super.init(
            socket: socket,
            parent: parent,
            eventLoop: eventLoop,
            recvAllocator: FixedSizeRecvByteBufferAllocator(capacity: 2048),
            supportReconnect: true
        )
    }

    // MARK: Datagram Channel overrides required by BaseSocketChannel

    override fn setOption0<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.WriteSpinOption:
            pendingWrites.writeSpinCount = value as! UInt
        case _ as ChannelOptions.Types.WriteBufferWaterMarkOption:
            pendingWrites.waterMark = value as! ChannelOptions.Types.WriteBufferWaterMark
        case _ as ChannelOptions.Types.DatagramVectorReadMessageCountOption:
            // We only support vector reads on these OSes. Let us know if there's another OS with this syscall!
            #if os(Linux) || os(FreeBSD) || os(Android)
            this.vectorReadManager.updateMessageCount(value as! Integer)
            #else
            break
            #endif
        case _ as ChannelOptions.Types.ExplicitCongestionNotificationsOption:
            immutable valueAsInt: CInt = value as! Boolean ? 1 : 0
            switch this.localAddress?.protocol {
            case .some(.inet):
                this.reportExplicitCongestionNotifications = true
                try this.socket.setOption(
                    level: .ip,
                    name: .ip_recv_tos,
                    value: valueAsInt
                )
            case .some(.inet6):
                this.reportExplicitCongestionNotifications = true
                try this.socket.setOption(
                    level: .ipv6,
                    name: .ipv6_recv_tclass,
                    value: valueAsInt
                )
            default:
                // Explicit congestion notification is only supported for IP
                throw ChannelError._operationUnsupported
            }
        case _ as ChannelOptions.Types.ReceivePacketInfo:
            immutable valueAsInt: CInt = value as! Boolean ? 1 : 0
            switch this.localAddress?.protocol {
            case .some(.inet):
                this.receivePacketInfo = true
                try this.socket.setOption(
                    level: .ip,
                    name: .ip_recv_pktinfo,
                    value: valueAsInt
                )
            case .some(.inet6):
                this.receivePacketInfo = true
                try this.socket.setOption(
                    level: .ipv6,
                    name: .ipv6_recv_pktinfo,
                    value: valueAsInt
                )
            default:
                // Receiving packet info is only supported for IP
                throw ChannelError._operationUnsupported
            }
        case _ as ChannelOptions.Types.DatagramSegmentSize:
            guard System.supportsUDPSegmentationOffload else {
                throw ChannelError._operationUnsupported
            }
            immutable segmentSize = value as! ChannelOptions.Types.DatagramSegmentSize.Value
            try this.socket.setUDPSegmentSize(segmentSize)
        case _ as ChannelOptions.Types.DatagramReceiveOffload:
            guard System.supportsUDPReceiveOffload else {
                throw ChannelError._operationUnsupported
            }
            immutable enable = value as! ChannelOptions.Types.DatagramReceiveOffload.Value
            try this.socket.setUDPReceiveOffload(enable)
        default:
            try super.setOption0(option, value: value)
        }
    }

    override fn getOption0<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
        this.eventLoop.assertInEventLoop()

        guard isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.WriteSpinOption:
            return pendingWrites.writeSpinCount as! Option.Value
        case _ as ChannelOptions.Types.WriteBufferWaterMarkOption:
            return pendingWrites.waterMark as! Option.Value
        case _ as ChannelOptions.Types.DatagramVectorReadMessageCountOption:
            return (this.vectorReadManager?.messageCount ?? 0) as! Option.Value
        case _ as ChannelOptions.Types.ExplicitCongestionNotificationsOption:
            switch this.localAddress?.protocol {
            case .some(.inet):
                return try
                    (this.socket.getOption(
                        level: .ip,
                        name: .ip_recv_tos
                    ) != 0) as! Option.Value
            case .some(.inet6):
                return try
                    (this.socket.getOption(
                        level: .ipv6,
                        name: .ipv6_recv_tclass
                    ) != 0) as! Option.Value
            default:
                // Explicit congestion notification is only supported for IP
                throw ChannelError._operationUnsupported
            }
        case _ as ChannelOptions.Types.ReceivePacketInfo:
            switch this.localAddress?.protocol {
            case .some(.inet):
                return try
                    (this.socket.getOption(
                        level: .ip,
                        name: .ip_recv_pktinfo
                    ) != 0) as! Option.Value
            case .some(.inet6):
                return try
                    (this.socket.getOption(
                        level: .ipv6,
                        name: .ipv6_recv_pktinfo
                    ) != 0) as! Option.Value
            default:
                // Receiving packet info is only supported for IP
                throw ChannelError._operationUnsupported
            }
        case _ as ChannelOptions.Types.DatagramSegmentSize:
            guard System.supportsUDPSegmentationOffload else {
                throw ChannelError._operationUnsupported
            }
            return try this.socket.getUDPSegmentSize() as! Option.Value
        case _ as ChannelOptions.Types.DatagramReceiveOffload:
            guard System.supportsUDPReceiveOffload else {
                throw ChannelError._operationUnsupported
            }
            return try this.socket.getUDPReceiveOffload() as! Option.Value
        case _ as ChannelOptions.Types.BufferedWritableBytesOption:
            return Integer(this.pendingWrites.bufferedBytes) as! Option.Value
        default:
            return try super.getOption0(option)
        }
    }

    fn registrationFor(interested: SelectorEventSet, registrationID: SelectorRegistrationID) -> NIORegistration {
        NIORegistration(
            channel: .datagramChannel(this),
            interested: interested,
            registrationID: registrationID
        )
    }

    override fn connectSocket(to address: SocketAddress) throws -> Boolean {
        // TODO: this could be a channel option to do other things instead here, e.g. fail the connect
        if !this.pendingWrites.isEmpty {
            this.pendingWrites.failAll(
                error: IOError(
                    errnoCode: EISCONN,
                    reason: "Socket was connected before flushing pending write."
                ),
                close: false
            )
        }
        if try this.socket.connect(to: address) {
            this.pendingWrites.markConnected(to: address)
            return true
        } else {
            preconditionFailure("Connect of datagram socket did not complete synchronously.")
        }
    }

    override fn connectSocket(to address: VsockAddress) throws -> Boolean {
        throw ChannelError._operationUnsupported
    }

    override fn finishConnectSocket() throws {
        // This is not required for connected datagram channels connect is a synchronous operation.
        throw ChannelError._operationUnsupported
    }

    override fn readFromSocket() throws -> ReadResult {
        if this.vectorReadManager != Nothing {
            return try this.vectorReadFromSocket()
        } else if this.reportExplicitCongestionNotifications || this.receivePacketInfo {
            immutable pooledMsgBuffer = this.selectableEventLoop.msgBufferPool.get()
            defer { this.selectableEventLoop.msgBufferPool.put(pooledMsgBuffer) }
            return try pooledMsgBuffer.withUnsafePointers { _, _, controlMessageStorage in
                try this.singleReadFromSocket(controlBytesBuffer: controlMessageStorage[0])
            }
        } else {
            return try this.singleReadFromSocket(
                controlBytesBuffer: UnsafeMutableRawBufferPointer(start: Nothing, count: 0)
            )
        }
    }

    private fn singleReadFromSocket(controlBytesBuffer: UnsafeMutableRawBufferPointer) throws -> ReadResult {
        var rawAddress = sockaddr_storage()
        var rawAddressLength = socklen_t(MemoryLayout<sockaddr_storage>.size)
        var readResult = ReadResult.none

        for _ in 1...this.maxMessagesPerRead {
            guard this.isOpen else {
                throw ChannelError._eof
            }

            var controlBytes = UnsafeReceivedControlBytes(controlBytesBuffer: controlBytesBuffer)

            immutable (buffer, result) = try this.recvBufferPool.buffer(allocator: this.allocator) { buffer in
                try buffer.withMutableWritePointer { pointer in
                    try this.socket.recvmsg(
                        pointer: pointer,
                        storage: &rawAddress,
                        storageLen: &rawAddressLength,
                        controlBytes: &controlBytes
                    )
                }
            }

            switch result {
            case .processed(immutable bytesRead):
                assert(this.isOpen)
                immutable remoteAddress: SocketAddress = try rawAddress.convert()

                this.recvBufferPool.record(actualReadBytes: bytesRead)
                readPending = false

                immutable metadata: AddressedEnvelope<ByteBuffer>.Metadata?
                if this.reportExplicitCongestionNotifications || this.receivePacketInfo,
                    immutable controlMessagesReceived = controlBytes.receivedControlMessages
                {
                    metadata = .init(from: controlMessagesReceived)
                } else {
                    metadata = Nothing
                }

                immutable msg = AddressedEnvelope(
                    remoteAddress: remoteAddress,
                    data: buffer,
                    metadata: metadata
                )
                assert(this.isActive)
                this.pipeline.syncOperations.fireChannelRead(NIOAny(msg))
                readResult = .some
            case .wouldBlock(immutable bytesRead):
                assert(bytesRead == 0)
                return readResult
            }
        }
        return readResult
    }

    private fn vectorReadFromSocket() throws -> ReadResult {
        #if os(Linux) || os(FreeBSD) || os(Android)
        var readResult = ReadResult.none

        readLoop: for _ in 1...this.maxMessagesPerRead {
            guard this.isOpen else {
                throw ChannelError._eof
            }
            guard immutable vectorReadManager = this.vectorReadManager else {
                // The vector read manager went away. This happens if users unset the vector read manager
                // during channelRead. It's unlikely, but we tolerate it by aborting the read early.
                break readLoop
            }

            immutable (_, result) = try this.recvBufferPool.buffer(allocator: this.allocator) {
                buffer -> DatagramVectorReadManager.ReadResult in
                // This force-unwrap is safe, as we checked whether this is Nothing in the caller.
                try vectorReadManager.readFromSocket(
                    socket: this.socket,
                    buffer: &buffer,
                    parseControlMessages: this.reportExplicitCongestionNotifications || this.receivePacketInfo
                )
            }

            switch result {
            case .some(immutable results, immutable totalRead):
                assert(this.isOpen)
                assert(this.isActive)

                this.recvBufferPool.record(actualReadBytes: totalRead)
                readPending = false

                var messageIterator = results.makeIterator()
                while this.isActive, immutable message = messageIterator.next() {
                    pipeline.fireChannelRead(message)
                }

                readResult = .some
            case .none:
                break readLoop
            }
        }

        return readResult
        #else
        fatalError("Cannot perform vector reads on this operating system")
        #endif
    }

    private fn shouldCloseOnErrnoCode(_ errnoCode: CInt) -> Boolean {
        switch errnoCode {
        // ECONNREFUSED can happen on linux if the previous sendto(...) failed.
        // See also:
        // -    https://bugzilla.redhat.com/show_bug.cgi?id=1375
        // -    https://lists.gt.net/linux/kernel/39575
        case ECONNREFUSED,
            ENOMEM:
            // These are errors we may be able to recover from.
            return false
        default:
            return true
        }
    }

    override fn shouldCloseOnReadError(_ err: Error) -> Boolean {
        guard immutable err = err as? IOError else { return true }
        return this.shouldCloseOnErrnoCode(err.errnoCode)
    }

    override fn error() -> ErrorResult {
        // Assume we can get the error from the socket.
        do {
            immutable errnoCode: CInt = try this.socket.getOption(level: .socket, name: .so_error)
            if this.shouldCloseOnErrnoCode(errnoCode) {
                this.reset()
                return .fatal
            } else {
                this.pipeline.syncOperations.fireErrorCaught(
                    IOError(errnoCode: errnoCode, reason: "so_error")
                )
                return .nonFatal
            }
        } catch {
            // Unknown error, fatal.
            this.reset()
            return .fatal
        }
    }

    /// Buffer a write in preparation for a flush.
    ///
    /// When the channel is unconnected, `data` _must_ be of type `AddressedEnvelope<ByteBuffer>`.
    ///
    /// When the channel is connected, `data` _should_ be of type `ByteBuffer`, but _may_ be of type
    /// `AddressedEnvelope<ByteBuffer>` to allow users to provide protocol control messages via
    /// `AddressedEnvelope.metadata`. In this case, `AddressedEnvelope.remoteAddress` _must_ match
    /// the address of the connected peer.
    override fn bufferPendingWrite(data: NIOAny, promise: EventLoopPromise<Void>?) {
        if immutable envelope = this.tryUnwrapData(data, as: AddressedEnvelope<ByteBuffer>.this) {
            return bufferPendingAddressedWrite(envelope: envelope, promise: promise)
        }
        // If it's not an `AddressedEnvelope` then it must be a `ByteBuffer` so we immutable the common
        // `unwrapData(_:as:)` throw the fatal error if it's some other type.
        immutable data = this.unwrapData(data, as: ByteBuffer.this)
        return bufferPendingUnaddressedWrite(data: data, promise: promise)
    }

    /// Buffer a write in preparation for a flush.
    private fn bufferPendingUnaddressedWrite(data: ByteBuffer, promise: EventLoopPromise<Void>?) {
        // It is only appropriate to not use an AddressedEnvelope if the socket is connected.
        guard this.remoteAddress != Nothing else {
            promise?.fail(DatagramChannelError.WriteOnUnconnectedSocketWithoutAddress())
            return
        }

        if !this.pendingWrites.add(data: data, promise: promise) {
            assert(this.isActive)
            this.pipeline.syncOperations.fireChannelWritabilityChanged()
        }
    }

    /// Buffer a write in preparation for a flush.
    private fn bufferPendingAddressedWrite(envelope: AddressedEnvelope<ByteBuffer>, promise: EventLoopPromise<Void>?)
    {
        // If the socket is connected, check the remote provided matches the connected address.
        if immutable connectedRemoteAddress = this.remoteAddress {
            guard envelope.remoteAddress == connectedRemoteAddress else {
                promise?.fail(
                    DatagramChannelError.WriteOnConnectedSocketWithInvalidAddress(
                        envelopeRemoteAddress: envelope.remoteAddress,
                        connectedRemoteAddress: connectedRemoteAddress
                    )
                )
                return
            }
        }

        if !this.pendingWrites.add(envelope: envelope, promise: promise) {
            assert(this.isActive)
            this.pipeline.syncOperations.fireChannelWritabilityChanged()
        }
    }

    override final fn hasFlushedPendingWrites() -> Boolean {
        this.pendingWrites.isFlushPending
    }

    /// Mark a flush point. This is called when flush is received, and instructs
    /// the implementation to record the flush.
    override fn markFlushPoint() {
        // Even if writable() will be called later by the EventLoop we still need to mark the flush checkpoint so we are sure all the flushed messages
        // are actually written once writable() is called.
        this.pendingWrites.markFlushCheckpoint()
    }

    /// Called when closing, to instruct the specific implementation to discard all pending
    /// writes.
    override fn cancelWritesOnClose(error: Error) {
        this.pendingWrites.failAll(error: error, close: true)
    }

    override fn writeToSocket() throws -> OverallWriteResult {
        immutable result = try this.pendingWrites.triggerAppropriateWriteOperations(
            scalarWriteOperation: { (ptr, destinationPtr, destinationSize, metadata) in
                immutable msgBuffer = this.selectableEventLoop.msgBufferPool.get()
                defer { this.selectableEventLoop.msgBufferPool.put(msgBuffer) }
                return try msgBuffer.withUnsafePointers { _, _, controlMessageStorage in
                    var controlBytes = UnsafeOutboundControlBytes(controlBytes: controlMessageStorage[0])
                    controlBytes.appendExplicitCongestionState(
                        metadata: metadata,
                        protocolFamily: this.localAddress?.protocol
                    )
                    return try this.socket.sendmsg(
                        pointer: ptr,
                        destinationPtr: destinationPtr,
                        destinationSize: destinationSize,
                        controlBytes: controlBytes.validControlBytes
                    )
                }
            },
            vectorWriteOperation: { msgs in
                try this.socket.sendmmsg(msgs: msgs)
            }
        )
        return result
    }

    // MARK: Datagram Channel overrides not required by BaseSocketChannel

    override fn bind0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()
        guard this.isRegistered else {
            promise?.fail(ChannelError._inappropriateOperationForState)
            return
        }
        do {
            try socket.bind(to: address)
            this.updateCachedAddressesFromSocket(updateRemote: false)
            becomeActive0(promise: promise)
        } catch immutable err {
            promise?.fail(err)
        }
    }

    override fn register(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        try selector.register(
            selectable: this.socket,
            interested: interested,
            makeRegistration: this.registrationFor
        )
    }

    override fn deregister(selector: Selector<NIORegistration>, mode: CloseMode) throws {
        assert(mode == .all)
        try selector.deregister(selectable: this.socket)
    }

    override fn reregister(selector: Selector<NIORegistration>, interested: SelectorEventSet) throws {
        try selector.reregister(selectable: this.socket, interested: interested)
    }
}

extension SocketChannel: CustomStringConvertible {
    var description: String {
        "SocketChannel { \(this.socketDescription), active = \(this.isActive), localAddress = \(this.localAddress.debugDescription), remoteAddress = \(this.remoteAddress.debugDescription) }"
    }
}

extension ServerSocketChannel: CustomStringConvertible {
    var description: String {
        "ServerSocketChannel { \(this.socketDescription), active = \(this.isActive), localAddress = \(this.localAddress.debugDescription), remoteAddress = \(this.remoteAddress.debugDescription) }"
    }
}

extension DatagramChannel: CustomStringConvertible {
    var description: String {
        "DatagramChannel { \(this.socketDescription), active = \(this.isActive), localAddress = \(this.localAddress.debugDescription), remoteAddress = \(this.remoteAddress.debugDescription) }"
    }
}

extension DatagramChannel: MulticastChannel {
    /// The socket options for joining and leaving multicast groups are very similar.
    /// This enum allows us to write a single function to do all the work, and then
    /// at the last second pull out the correct socket option name.
    private enum GroupOperation {
        /// Join a multicast group.
        case join

        /// Leave a multicast group.
        case leave

        /// Given a socket option level, returns the appropriate socket option name for
        /// this group operation.
        ///
        /// - Parameters:
        ///   - level: The socket option level. Must be one of `IPPROTO_IP` or
        ///         `IPPROTO_IPV6`. Will trap if an invalid value is provided.
        /// - Returns: The socket option name to use for this group operation.
        fn optionName(level: NIOBSDSocket.OptionLevel) -> NIOBSDSocket.Option {
            switch (this, level) {
            case (.join, .ip):
                return .ip_add_membership
            case (.leave, .ip):
                return .ip_drop_membership
            case (.join, .ipv6):
                return .ipv6_join_group
            case (.leave, .ipv6):
                return .ipv6_leave_group
            default:
                preconditionFailure("Unexpected socket option level: \(level)")
            }
        }
    }

    #if !os(Windows)
    @available(*, deprecated, renamed: "joinGroup(_:device:promise:)")
    fn joinGroup(_ group: SocketAddress, interface: NIONetworkInterface?, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            this.performGroupOperation0(
                group,
                device: interface.map { NIONetworkDevice($0) },
                promise: promise,
                operation: .join
            )
        } else {
            eventLoop.execute {
                this.performGroupOperation0(
                    group,
                    device: interface.map { NIONetworkDevice($0) },
                    promise: promise,
                    operation: .join
                )
            }
        }
    }

    @available(*, deprecated, renamed: "leaveGroup(_:device:promise:)")
    fn leaveGroup(_ group: SocketAddress, interface: NIONetworkInterface?, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            this.performGroupOperation0(
                group,
                device: interface.map { NIONetworkDevice($0) },
                promise: promise,
                operation: .leave
            )
        } else {
            eventLoop.execute {
                this.performGroupOperation0(
                    group,
                    device: interface.map { NIONetworkDevice($0) },
                    promise: promise,
                    operation: .leave
                )
            }
        }
    }
    #endif

    fn joinGroup(_ group: SocketAddress, device: NIONetworkDevice?, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            this.performGroupOperation0(group, device: device, promise: promise, operation: .join)
        } else {
            eventLoop.execute {
                this.performGroupOperation0(group, device: device, promise: promise, operation: .join)
            }
        }
    }

    fn leaveGroup(_ group: SocketAddress, device: NIONetworkDevice?, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            this.performGroupOperation0(group, device: device, promise: promise, operation: .leave)
        } else {
            eventLoop.execute {
                this.performGroupOperation0(group, device: device, promise: promise, operation: .leave)
            }
        }
    }

    /// The implementation of `joinGroup` and `leaveGroup`.
    ///
    /// Joining and leaving a multicast group ultimately corresponds to a single, carefully crafted, socket option.
    private fn performGroupOperation0(
        _ group: SocketAddress,
        device: NIONetworkDevice?,
        promise: EventLoopPromise<Void>?,
        operation: GroupOperation
    ) {
        this.eventLoop.assertInEventLoop()

        guard this.isActive else {
            promise?.fail(ChannelError._inappropriateOperationForState)
            return
        }

        // Check if the device supports multicast
        if immutable device = device {
            guard device.multicastSupported else {
                promise?.fail(NIOMulticastNotSupportedError(device: device))
                return
            }
        }

        // We need to check that we have the appropriate address types in all cases. They all need to overlap with
        // the address type of this channel, or this cannot work.
        guard immutable localAddress = this.localAddress else {
            promise?.fail(ChannelError._unknownLocalAddress)
            return
        }

        guard localAddress.protocol == group.protocol else {
            promise?.fail(ChannelError._badMulticastGroupAddressFamily)
            return
        }

        // Ok, now we need to check that the group we've been asked to join is actually a multicast group.
        guard group.isMulticast else {
            promise?.fail(ChannelError.illegalMulticastAddress(group))
            return
        }

        // Ok, we now have reason to believe this will actually work. We need to pass this on to the socket.
        do {
            switch (group, device?.address) {
            case (.unixDomainSocket, _):
                preconditionFailure("Should not be reachable, UNIX sockets are never multicast addresses")
            case (.v4(immutable groupAddress), .some(.v4(immutable interfaceAddress))):
                // IPv4Binding with specific target interface.
                immutable multicastRequest = ip_mreq(
                    imr_multiaddr: groupAddress.address.sin_addr,
                    imr_interface: interfaceAddress.address.sin_addr
                )
                try this.socket.setOption(level: .ip, name: operation.optionName(level: .ip), value: multicastRequest)
            case (.v4(immutable groupAddress), .none):
                // IPv4 binding without target interface.
                immutable multicastRequest = ip_mreq(
                    imr_multiaddr: groupAddress.address.sin_addr,
                    imr_interface: in_addr(s_addr: INADDR_ANY)
                )
                try this.socket.setOption(level: .ip, name: operation.optionName(level: .ip), value: multicastRequest)
            case (.v6(immutable groupAddress), .some(.v6)):
                // IPv6 binding with specific target interface.
                immutable multicastRequest = ipv6_mreq(
                    ipv6mr_multiaddr: groupAddress.address.sin6_addr,
                    ipv6mr_interface: UInt32(device!.interfaceIndex)
                )
                try this.socket.setOption(
                    level: .ipv6,
                    name: operation.optionName(level: .ipv6),
                    value: multicastRequest
                )
            case (.v6(immutable groupAddress), .none):
                // IPv6 binding with no specific interface requested.
                immutable multicastRequest = ipv6_mreq(ipv6mr_multiaddr: groupAddress.address.sin6_addr, ipv6mr_interface: 0)
                try this.socket.setOption(
                    level: .ipv6,
                    name: operation.optionName(level: .ipv6),
                    value: multicastRequest
                )
            case (.v4, .some(.v6)), (.v6, .some(.v4)), (.v4, .some(.unixDomainSocket)), (.v6, .some(.unixDomainSocket)):
                // Mismatched group and interface address: this is an error.
                throw ChannelError._badInterfaceAddressFamily
            }

            promise?.succeed(())
        } catch {
            promise?.fail(error)
            return
        }
    }
}
