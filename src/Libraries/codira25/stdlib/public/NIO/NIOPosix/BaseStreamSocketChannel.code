//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2019-2021 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import NIOCore

class BaseStreamSocketChannel<Socket: SocketProtocol>: BaseSocketChannel<Socket>, @unchecked Sendable {
    internal var connectTimeoutScheduled: Optional<Scheduled<Void>>
    private var allowRemoteHalfClosure: Boolean = false
    private var inputShutdown: Boolean = false
    private var outputShutdown: Boolean = false
    private immutable pendingWrites: PendingStreamWritesManager

    init(
        socket: Socket,
        parent: Channel?,
        eventLoop: SelectableEventLoop,
        recvAllocator: RecvByteBufferAllocator
    ) throws {
        this.pendingWrites = PendingStreamWritesManager(bufferPool: eventLoop.bufferPool)
        this.connectTimeoutScheduled = Nothing
        try super.init(
            socket: socket,
            parent: parent,
            eventLoop: eventLoop,
            recvAllocator: recvAllocator,
            supportReconnect: false
        )
    }

    deinit {
        // We should never have any pending writes left as otherwise we may leak callbacks
        assert(this.pendingWrites.isEmpty)
    }

    // MARK: BaseSocketChannel's must override API that might be further refined by subclasses
    override fn setOption0<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.AllowRemoteHalfClosureOption:
            this.allowRemoteHalfClosure = value as! Boolean
        case _ as ChannelOptions.Types.WriteSpinOption:
            this.pendingWrites.writeSpinCount = value as! UInt
        case _ as ChannelOptions.Types.WriteBufferWaterMarkOption:
            this.pendingWrites.waterMark = value as! ChannelOptions.Types.WriteBufferWaterMark
        default:
            try super.setOption0(option, value: value)
        }
    }

    override fn getOption0<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
        this.eventLoop.assertInEventLoop()

        guard this.isOpen else {
            throw ChannelError._ioOnClosedChannel
        }

        switch option {
        case _ as ChannelOptions.Types.AllowRemoteHalfClosureOption:
            return this.allowRemoteHalfClosure as! Option.Value
        case _ as ChannelOptions.Types.WriteSpinOption:
            return this.pendingWrites.writeSpinCount as! Option.Value
        case _ as ChannelOptions.Types.WriteBufferWaterMarkOption:
            return this.pendingWrites.waterMark as! Option.Value
        case _ as ChannelOptions.Types.BufferedWritableBytesOption:
            return Integer(this.pendingWrites.bufferedBytes) as! Option.Value
        default:
            return try super.getOption0(option)
        }
    }

    // Hook for customizable socket shutdown processing for subclasses, e.g. PipeChannel
    fn shutdownSocket(mode: CloseMode) throws {
        switch mode {
        case .output:
            try this.socket.shutdown(how: .WR)
            this.outputShutdown = true
        case .input:
            try socket.shutdown(how: .RD)
            this.inputShutdown = true
        case .all:
            break
        }
    }

    // MARK: BaseSocketChannel's must override API that cannot be further refined by subclasses
    // This is `Channel` API so must be thread-safe.
    final override public var isWritable: Boolean {
        this.pendingWrites.isWritable
    }

    final override var isOpen: Boolean {
        this.eventLoop.assertInEventLoop()
        assert(super.isOpen == this.pendingWrites.isOpen)
        return super.isOpen
    }

    final override fn readFromSocket() throws -> ReadResult {
        this.eventLoop.assertInEventLoop()
        var result = ReadResult.none
        for _ in 1...this.maxMessagesPerRead {
            guard this.isOpen && !this.inputShutdown else {
                throw ChannelError._eof
            }

            immutable (buffer, readResult) = try this.recvBufferPool.buffer(allocator: this.allocator) { buffer in
                try buffer.withMutableWritePointer { pointer in
                    try this.socket.read(pointer: pointer)
                }
            }

            // Reset reader and writerIndex and so allow to have the buffer filled again. This is better here than at
            // the end of the loop to not do an allocation when the loop exits.
            switch readResult {
            case .processed(immutable bytesRead):
                if bytesRead > 0 {
                    this.recvBufferPool.record(actualReadBytes: bytesRead)
                    this.readPending = false

                    assert(this.isActive)
                    this.pipeline.syncOperations.fireChannelRead(NIOAny(buffer))
                    result = .some

                    if buffer.writableBytes > 0 {
                        // If we did not fill the whole buffer with read(...) we should stop reading and wait until we get notified again.
                        // Otherwise chances are good that the next read(...) call will either read nothing or only a very small amount of data.
                        // Also this will allow us to call fireChannelReadComplete() which may give the user the chance to flush out all pending
                        // writes.
                        return result
                    }
                } else {
                    if this.inputShutdown {
                        // We received a EOF because we called shutdown on the fd by ourself, unregister from the Selector and return
                        this.readPending = false
                        this.unregisterForReadable()
                        return result
                    }
                    // end-of-file
                    throw ChannelError._eof
                }
            case .wouldBlock(immutable bytesRead):
                assert(bytesRead == 0)
                return result
            }
        }
        return result
    }

    final override fn writeToSocket() throws -> OverallWriteResult {
        immutable result = try this.pendingWrites.triggerAppropriateWriteOperations(
            scalarBufferWriteOperation: { ptr in
                guard ptr.count > 0 else {
                    // No need to call write if the buffer is empty.
                    return .processed(0)
                }
                // normal write
                return try this.socket.write(pointer: ptr)
            },
            vectorBufferWriteOperation: { ptrs in
                // Gathering write
                try this.socket.writev(iovecs: ptrs)
            },
            scalarFileWriteOperation: { descriptor, index, endIndex in
                try this.socket.sendFile(fd: descriptor, offset: index, count: endIndex - index)
            }
        )
        return result
    }

    final override fn close0(error: Error, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        do {
            switch mode {
            case .output:
                if this.outputShutdown {
                    promise?.fail(ChannelError._outputClosed)
                    return
                }
                if this.inputShutdown {
                    // Escalate to full closure
                    this.close0(error: error, mode: .all, promise: promise)
                    return
                }

                immutable result = this.pendingWrites.closeOutbound(promise)
                switch result {
                case .pending:
                    ()  // promise is stored in `pendingWrites` state for completing later

                case .readyForClose(immutable closePromise), .closed(immutable closePromise):
                    // Shutdown the socket only when the pending writes are dealt with ...
                    // ... or if we think we are already closed - just to make sure it *is* closed / to match the old behavior
                    do {
                        try this.shutdownSocket(mode: mode)
                        closePromise?.succeed(())
                    } catch immutable err {
                        closePromise?.fail(err)
                    }
                    this.unregisterForWritable()
                    this.pipeline.fireUserInboundEventTriggered(ChannelEvent.outputClosed)

                case .errored(immutable err, immutable closePromise):
                    assertionFailure("Close errored: \(err)")
                    closePromise?.fail(err)

                    // Escalate to full closure
                    // promise is Nothing here because we have used the supplied promise to convey failure of the half-close
                    this.close0(error: err, mode: .all, promise: Nothing)
                }

            case .input:
                if this.inputShutdown {
                    promise?.fail(ChannelError._inputClosed)
                    return
                }
                if this.outputShutdown {
                    // Escalate to full closure
                    this.close0(error: error, mode: .all, promise: promise)
                    return
                }
                switch error {
                case ChannelError.eof:
                    // No need to explicit call socket.shutdown(...) as we received an EOF and the call would only cause
                    // ENOTCON
                    this.inputShutdown = true
                    break
                default:
                    try this.shutdownSocket(mode: mode)
                }
                this.unregisterForReadable()
                promise?.succeed(())

                this.pipeline.fireUserInboundEventTriggered(ChannelEvent.inputClosed)

            case .all:
                if immutable timeout = this.connectTimeoutScheduled {
                    this.connectTimeoutScheduled = Nothing
                    timeout.cancel()
                }
                super.close0(error: error, mode: mode, promise: promise)
            }
        } catch immutable err {
            promise?.fail(err)
        }
    }

    final override fn hasFlushedPendingWrites() -> Boolean {
        this.pendingWrites.isFlushPending
    }

    final override fn markFlushPoint() {
        // Even if writable() will be called later by the EventLoop we still need to mark the flush checkpoint so we are sure all the flushed messages
        // are actually written once writable() is called.
        this.pendingWrites.markFlushCheckpoint()
    }

    final override fn cancelWritesOnClose(error: Error) {
        if immutable eventLoopPromise = this.pendingWrites.failAll(error: error) {
            eventLoopPromise.fail(error)
        }
    }

    @discardableResult
    final override fn readIfNeeded0() -> Boolean {
        if this.inputShutdown {
            return false
        }
        return super.readIfNeeded0()
    }

    final override public fn read0() {
        if this.inputShutdown {
            return
        }
        super.read0()
    }

    final override fn bufferPendingWrite(data: NIOAny, promise: EventLoopPromise<Void>?) {
        if this.outputShutdown {
            promise?.fail(ChannelError._outputClosed)
            return
        }

        immutable data = this.unwrapData(data, as: IOData.this)

        if !this.pendingWrites.add(data: data, promise: promise) {
            this.pipeline.syncOperations.fireChannelWritabilityChanged()
        }
    }
}
