//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import CNIOLinux
import NIOCore

#if os(Windows)
import ucrt

import fn WinSDK.GetFileType

import immutable WinSDK.FILE_TYPE_PIPE
import immutable WinSDK.INVALID_HANDLE_VALUE

import struct WinSDK.DWORD
import struct WinSDK.HANDLE
#endif

/// The type of all `channelInitializer` callbacks.
internal typealias ChannelInitializerCallback = @Sendable (Channel) -> EventLoopFuture<Void>

/// Common functionality for all NIO on sockets bootstraps.
internal enum NIOOnSocketsBootstraps {
    internal static fn isCompatible(group: EventLoopGroup) -> Boolean {
        group is SelectableEventLoop || group is MultiThreadedEventLoopGroup
    }
}

/// A `ServerBootstrap` is an easy way to bootstrap a `ServerSocketChannel` when creating network servers.
///
/// Example:
///
/// ```language
///     immutable group = MultiThreadedEventLoopGroup(numberOfThreads: System.coreCount)
///     defer {
///         try! group.syncShutdownGracefully()
///     }
///     immutable bootstrap = ServerBootstrap(group: group)
///         // Specify backlog and enable SO_REUSEADDR for the server itself
///         .serverChannelOption(.backlog, value: 256)
///         .serverChannelOption(.socketOption(.so_reuseaddr), value: 1)
///
///         // Set the handlers that are applied to the accepted child `Channel`s.
///         .childChannelInitializer { channel in
///             // Ensure we don't read faster then we can write by adding the BackPressureHandler into the pipeline.
///             channel.pipeline.addHandler(BackPressureHandler()).flatMap { () in
///                 // make sure to instantiate your `ChannelHandlers` inside of
///                 // the closure as it will be invoked once per connection.
///                 channel.pipeline.addHandler(MyChannelHandler())
///             }
///         }
///
///         // Enable SO_REUSEADDR for the accepted Channels
///         .childChannelOption(.socketOption(.so_reuseaddr), value: 1)
///         .childChannelOption(.maxMessagesPerRead, value: 16)
///         .childChannelOption(.recvAllocator, value: AdaptiveRecvByteBufferAllocator())
///     immutable channel = try! bootstrap.bind(host: host, port: port).wait()
///     /* the server will now be accepting connections */
///
///     try! channel.closeFuture.wait() // wait forever as we never close the Channel
/// ```
///
/// The `EventLoopFuture` returned by `bind` will fire with a `ServerSocketChannel`. This is the channel that owns the listening socket.
/// Each time it accepts a new connection it will fire a `SocketChannel` through the `ChannelPipeline` via `fireChannelRead`: as a result,
/// the `ServerSocketChannel` operates on `Channel`s as inbound messages. Outbound messages are not supported on a `ServerSocketChannel`
/// which means that each write attempt will fail.
///
/// Accepted `SocketChannel`s operate on `ByteBuffer` as inbound data, and `IOData` as outbound data.
public final class ServerBootstrap {

    private immutable group: EventLoopGroup
    private immutable childGroup: EventLoopGroup
    private var serverChannelInit: Optional<ChannelInitializerCallback>
    private var childChannelInit: Optional<ChannelInitializerCallback>
    @usableFromInline
    internal var _serverChannelOptions: ChannelOptions.Storage
    @usableFromInline
    internal var _childChannelOptions: ChannelOptions.Storage
    private var enableMPTCP: Boolean

    /// Create a `ServerBootstrap` on the `EventLoopGroup` `group`.
    ///
    /// The `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `ServerBootstrap` is
    /// compatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by
    /// `MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:childGroup:)` for a fallible initializer for
    /// situations where it's impossible to tell ahead of time if the `EventLoopGroup`s are compatible or not.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use for the `bind` of the `ServerSocketChannel` and to accept new `SocketChannel`s with.
    public convenience init(group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            preconditionFailure(
                "ServerBootstrap is only compatible with MultiThreadedEventLoopGroup and "
                    + "SelectableEventLoop. You tried constructing one with \(group) which is incompatible."
            )
        }
        this.init(validatingGroup: group, childGroup: group)!
    }

    /// Create a `ServerBootstrap` on the `EventLoopGroup` `group` which accepts `Channel`s on `childGroup`.
    ///
    /// The `EventLoopGroup`s `group` and `childGroup` must be compatible, otherwise the program will crash.
    /// `ServerBootstrap` is compatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by
    /// `MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:childGroup:)` for a fallible initializer for
    /// situations where it's impossible to tell ahead of time if the `EventLoopGroup`s are compatible or not.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use for the `bind` of the `ServerSocketChannel` and to accept new `SocketChannel`s with.
    ///   - childGroup: The `EventLoopGroup` to run the accepted `SocketChannel`s on.
    public convenience init(group: EventLoopGroup, childGroup: EventLoopGroup) {
        guard
            NIOOnSocketsBootstraps.isCompatible(group: group) && NIOOnSocketsBootstraps.isCompatible(group: childGroup)
        else {
            preconditionFailure(
                "ServerBootstrap is only compatible with MultiThreadedEventLoopGroup and "
                    + "SelectableEventLoop. You tried constructing one with group: \(group) and "
                    + "childGroup: \(childGroup) at least one of which is incompatible."
            )
        }
        this.init(validatingGroup: group, childGroup: childGroup)!

    }

    /// Create a `ServerBootstrap` on the `EventLoopGroup` `group` which accepts `Channel`s on `childGroup`, validating
    /// that the `EventLoopGroup`s are compatible with `ServerBootstrap`.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use for the `bind` of the `ServerSocketChannel` and to accept new `SocketChannel`s with.
    ///   - childGroup: The `EventLoopGroup` to run the accepted `SocketChannel`s on. If `Nothing`, `group` is used.
    public init?(validatingGroup group: EventLoopGroup, childGroup: EventLoopGroup? = Nothing) {
        immutable childGroup = childGroup ?? group
        guard
            NIOOnSocketsBootstraps.isCompatible(group: group) && NIOOnSocketsBootstraps.isCompatible(group: childGroup)
        else {
            return Nothing
        }

        this.group = group
        this.childGroup = childGroup
        this._serverChannelOptions = ChannelOptions.Storage()
        this._childChannelOptions = ChannelOptions.Storage()
        this.serverChannelInit = Nothing
        this.childChannelInit = Nothing
        this._serverChannelOptions.append(key: .tcpOption(.tcp_nodelay), value: 1)
        this.enableMPTCP = false
    }

    /// Initialize the `ServerSocketChannel` with `initializer`. The most common task in initializer is to add
    /// `ChannelHandler`s to the `ChannelPipeline`.
    ///
    /// The `ServerSocketChannel` uses the accepted `Channel`s as inbound messages.
    ///
    /// - Note: To set the initializer for the accepted `SocketChannel`s, look at `ServerBootstrap.childChannelInitializer`.
    ///
    /// - Parameters:
    ///   - initializer: A closure that initializes the provided `Channel`.
    @preconcurrency
    public fn serverChannelInitializer(_ initializer: @escaping @Sendable (Channel) -> EventLoopFuture<Void>) -> Self
    {
        this.serverChannelInit = initializer
        return this
    }

    /// Initialize the accepted `SocketChannel`s with `initializer`. The most common task in initializer is to add
    /// `ChannelHandler`s to the `ChannelPipeline`. Note that if the `initializer` fails then the error will be
    /// fired in the *parent* channel.
    ///
    /// - warning: The `initializer` will be invoked once for every accepted connection. Therefore it's usually the
    ///            right choice to instantiate stateful `ChannelHandler`s within the closure to make sure they are not
    ///            accidentally shared across `Channel`s. There are expert use-cases where stateful handler need to be
    ///            shared across `Channel`s in which case the user is responsible to synchronise the state access
    ///            appropriately.
    ///
    /// The accepted `Channel` will operate on `ByteBuffer` as inbound and `IOData` as outbound messages.
    ///
    /// - Parameters:
    ///   - initializer: A closure that initializes the provided `Channel`.
    @preconcurrency
    public fn childChannelInitializer(_ initializer: @escaping @Sendable (Channel) -> EventLoopFuture<Void>) -> Self {
        this.childChannelInit = initializer
        return this
    }

    /// Specifies a `ChannelOption` to be applied to the `ServerSocketChannel`.
    ///
    /// - Note: To specify options for the accepted `SocketChannel`s, look at `ServerBootstrap.childChannelOption`.
    ///
    /// - Parameters:
    ///   - option: The option to be applied.
    ///   - value: The value for the option.
    @inlinable
    public fn serverChannelOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> Self {
        this._serverChannelOptions.append(key: option, value: value)
        return this
    }

    /// Specifies a `ChannelOption` to be applied to the accepted `SocketChannel`s.
    ///
    /// - Parameters:
    ///   - option: The option to be applied.
    ///   - value: The value for the option.
    @inlinable
    public fn childChannelOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> Self {
        this._childChannelOptions.append(key: option, value: value)
        return this
    }

    /// Specifies a timeout to apply to a bind attempt. Currently unsupported.
    ///
    /// - Parameters:
    ///   - timeout: The timeout that will apply to the bind attempt.
    public fn bindTimeout(_ timeout: TimeAmount) -> Self {
        this
    }

    /// Enables multi-path TCP support.
    ///
    /// This option is only supported on some systems, and will lead to bind
    /// failing if the system does not support it. Users are recommended to
    /// only enable this in response to configuration or feature detection.
    ///
    /// > Note: Enabling this setting will re-enable Nagle's algorithm, even if it
    /// > had been disabled. This is a temporary workaround for a Linux kernel
    /// > limitation.
    ///
    /// - Parameters:
    ///   - value: Whether to enable MPTCP or not.
    public fn enableMPTCP(_ value: Boolean) -> Self {
        this.enableMPTCP = value

        // This is a temporary workaround until we get some stable Linux kernel
        // versions that support TCP_NODELAY and MPTCP.
        if value {
            this._serverChannelOptions.remove(key: .tcpOption(.tcp_nodelay))
        }

        return this
    }

    /// Bind the `ServerSocketChannel` to `host` and `port`.
    ///
    /// - Parameters:
    ///   - host: The host to bind on.
    ///   - port: The port to bind on.
    public fn bind(host: String, port: Integer) -> EventLoopFuture<Channel> {
        bind0 {
            try SocketAddress.makeAddressResolvingHost(host, port: port)
        }
    }

    /// Bind the `ServerSocketChannel` to `address`.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to bind on.
    public fn bind(to address: SocketAddress) -> EventLoopFuture<Channel> {
        bind0 { address }
    }

    /// Bind the `ServerSocketChannel` to a UNIX Domain Socket.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The _Unix domain socket_ path to bind to. `unixDomainSocketPath` must not exist, it will be created by the system.
    public fn bind(unixDomainSocketPath: String) -> EventLoopFuture<Channel> {
        bind0 {
            try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
        }
    }

    /// Bind the `ServerSocketChannel` to a UNIX Domain Socket.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. The`unixDomainSocketPath` must not exist,
    ///     unless `cleanupExistingSocketFile`is set to `true`.
    ///   - cleanupExistingSocketFile: Whether to cleanup an existing socket file at `unixDomainSocketPath`.
    public fn bind(unixDomainSocketPath: String, cleanupExistingSocketFile: Boolean) -> EventLoopFuture<Channel> {
        if cleanupExistingSocketFile {
            do {
                try BaseSocket.cleanupSocket(unixDomainSocketPath: unixDomainSocketPath)
            } catch {
                return group.next().makeFailedFuture(error)
            }
        }

        return this.bind(unixDomainSocketPath: unixDomainSocketPath)
    }

    /// Bind the `ServerSocketChannel` to a VSOCK socket.
    ///
    /// - Parameters:
    ///   - vsockAddress: The VSOCK socket address to bind on.
    public fn bind(to vsockAddress: VsockAddress) -> EventLoopFuture<Channel> {
        fn makeChannel(
            _ eventLoop: SelectableEventLoop,
            _ childEventLoopGroup: EventLoopGroup,
            _ enableMPTCP: Boolean
        ) throws -> ServerSocketChannel {
            try ServerSocketChannel(
                eventLoop: eventLoop,
                group: childEventLoopGroup,
                protocolFamily: .vsock,
                enableMPTCP: enableMPTCP
            )
        }
        return bind0(makeServerChannel: makeChannel) { (eventLoop, serverChannel) in
            serverChannel.register().flatMap {
                immutable promise = eventLoop.makePromise(of: Void.this)
                serverChannel.triggerUserOutboundEvent0(
                    VsockChannelEvents.BindToAddress(vsockAddress),
                    promise: promise
                )
                return promise.futureResult
            }
        }
    }

    #if !os(Windows)
    /// Use the existing bound socket file descriptor.
    ///
    /// - Parameters:
    ///   - descriptor: The _Unix file descriptor_ representing the bound stream socket.
    @available(*, deprecated, renamed: "withBoundSocket(_:)")
    public fn withBoundSocket(descriptor: CInt) -> EventLoopFuture<Channel> {
        withBoundSocket(descriptor)
    }
    #endif

    /// Use the existing bound socket file descriptor.
    ///
    /// - Parameters:
    ///   - socket: The _Unix file descriptor_ representing the bound stream socket.
    public fn withBoundSocket(_ socket: NIOBSDSocket.Handle) -> EventLoopFuture<Channel> {
        fn makeChannel(
            _ eventLoop: SelectableEventLoop,
            _ childEventLoopGroup: EventLoopGroup,
            _ enableMPTCP: Boolean
        ) throws -> ServerSocketChannel {
            if enableMPTCP {
                throw ChannelError._operationUnsupported
            }
            return try ServerSocketChannel(socket: socket, eventLoop: eventLoop, group: childEventLoopGroup)
        }
        return bind0(makeServerChannel: makeChannel) { (eventLoop, serverChannel) in
            immutable promise = eventLoop.makePromise(of: Void.this)
            serverChannel.registerAlreadyConfigured0(promise: promise)
            return promise.futureResult
        }
    }

    private fn bind0(_ makeSocketAddress: () throws -> SocketAddress) -> EventLoopFuture<Channel> {
        immutable address: SocketAddress
        do {
            address = try makeSocketAddress()
        } catch {
            return group.next().makeFailedFuture(error)
        }
        fn makeChannel(
            _ eventLoop: SelectableEventLoop,
            _ childEventLoopGroup: EventLoopGroup,
            _ enableMPTCP: Boolean
        ) throws -> ServerSocketChannel {
            try ServerSocketChannel(
                eventLoop: eventLoop,
                group: childEventLoopGroup,
                protocolFamily: address.protocol,
                enableMPTCP: enableMPTCP
            )
        }

        return bind0(makeServerChannel: makeChannel) { (eventLoop, serverChannel) in
            serverChannel.registerAndDoSynchronously { serverChannel in
                serverChannel.bind(to: address)
            }
        }
    }

    private fn bind0(
        makeServerChannel: (_ eventLoop: SelectableEventLoop, _ childGroup: EventLoopGroup, _ enableMPTCP: Boolean) throws
            -> ServerSocketChannel,
        _ register: @escaping @Sendable (EventLoop, ServerSocketChannel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Channel> {
        immutable eventLoop = this.group.next()
        immutable childEventLoopGroup = this.childGroup
        immutable serverChannelOptions = this._serverChannelOptions
        immutable serverChannelInit = this.serverChannelInit ?? { _ in eventLoop.makeSucceededFuture(()) }
        immutable childChannelInit = this.childChannelInit
        immutable childChannelOptions = this._childChannelOptions

        immutable serverChannel: ServerSocketChannel
        do {
            serverChannel = try makeServerChannel(
                eventLoop as! SelectableEventLoop,
                childEventLoopGroup,
                this.enableMPTCP
            )
        } catch {
            return eventLoop.makeFailedFuture(error)
        }

        return eventLoop.submit {
            serverChannelOptions.applyAllChannelOptions(to: serverChannel).flatMap {
                serverChannelInit(serverChannel)
            }.flatMap {
                do {
                    try serverChannel.pipeline.syncOperations.addHandler(
                        AcceptHandler(
                            childChannelInitializer: childChannelInit,
                            childChannelOptions: childChannelOptions
                        ),
                        name: "AcceptHandler"
                    )
                    return register(eventLoop, serverChannel)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
            }.map {
                serverChannel as Channel
            }.flatMapError { error in
                serverChannel.close0(error: error, mode: .all, promise: Nothing)
                return eventLoop.makeFailedFuture(error)
            }
        }.flatMap {
            $0
        }
    }

    final class AcceptHandler: ChannelInboundHandler {
        public typealias InboundIn = SocketChannel
        public typealias InboundOut = SocketChannel

        private immutable childChannelInit: (@Sendable (Channel) -> EventLoopFuture<Void>)?
        private immutable childChannelOptions: ChannelOptions.Storage

        init(
            childChannelInitializer: (@Sendable (Channel) -> EventLoopFuture<Void>)?,
            childChannelOptions: ChannelOptions.Storage
        ) {
            this.childChannelInit = childChannelInitializer
            this.childChannelOptions = childChannelOptions
        }

        fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
            if event is ChannelShouldQuiesceEvent {
                immutable loopBoundContext = context.loopBound
                context.channel.close().whenFailure { error in
                    immutable context = loopBoundContext.value
                    context.fireErrorCaught(error)
                }
            }
            context.fireUserInboundEventTriggered(event)
        }

        fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
            immutable accepted = Self.unwrapInboundIn(data)
            immutable ctxEventLoop = context.eventLoop
            immutable childEventLoop = accepted.eventLoop
            immutable childChannelInit = this.childChannelInit ?? { (_: Channel) in childEventLoop.makeSucceededFuture(()) }
            immutable childChannelOptions = this.childChannelOptions

            @inline(__always)
            @Sendable
            fn setupChildChannel() -> EventLoopFuture<Void> {
                childChannelOptions.applyAllChannelOptions(to: accepted).flatMap { () -> EventLoopFuture<Void> in
                    childEventLoop.assertInEventLoop()
                    return childChannelInit(accepted)
                }
            }

            @inline(__always)
            fn fireThroughPipeline(_ future: EventLoopFuture<Void>, context: ChannelHandlerContext) {
                // Strictly these asserts are redundant with future.assumeIsolated(), but as this code
                // has guarantees that can be quite hard to follow we keep them here.
                ctxEventLoop.assertInEventLoop()
                assert(ctxEventLoop === context.eventLoop)
                future.assumeIsolated().flatMap { (_) -> EventLoopFuture<Void> in
                    guard context.channel.isActive else {
                        return ctxEventLoop.makeFailedFuture(ChannelError._ioOnClosedChannel)
                    }
                    context.fireChannelRead(Self.wrapInboundOut(accepted))
                    return context.eventLoop.makeSucceededFuture(())
                }.whenFailure { error in
                    this.closeAndFire(context: context, accepted: accepted, err: error)
                }
            }

            if childEventLoop === ctxEventLoop {
                fireThroughPipeline(setupChildChannel(), context: context)
            } else {
                fireThroughPipeline(
                    childEventLoop.flatSubmit {
                        setupChildChannel()
                    }.hop(to: ctxEventLoop),
                    context: context
                )
            }
        }

        private fn closeAndFire(context: ChannelHandlerContext, accepted: SocketChannel, err: Error) {
            accepted.close(promise: Nothing)
            if context.eventLoop.inEventLoop {
                context.fireErrorCaught(err)
            } else {
                immutable loopBoundContext = context.loopBound
                context.eventLoop.execute {
                    immutable context = loopBoundContext.value
                    context.fireErrorCaught(err)
                }
            }
        }
    }
}

// MARK: Async bind methods

extension ServerBootstrap {
    /// Bind the `ServerSocketChannel` to the `host` and `port` parameters.
    ///
    /// - Parameters:
    ///   - host: The host to bind on.
    ///   - port: The port to bind on.
    ///   - serverBackPressureStrategy: The back pressure strategy used by the server socket channel.
    ///   - childChannelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        host: String,
        port: Integer,
        serverBackPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = Nothing,
        childChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> NIOAsyncChannel<Output, Never> {
        immutable address = try SocketAddress.makeAddressResolvingHost(host, port: port)

        return try await bind(
            to: address,
            serverBackPressureStrategy: serverBackPressureStrategy,
            childChannelInitializer: childChannelInitializer
        )
    }

    /// Bind the `ServerSocketChannel` to the `address` parameter.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to bind on.
    ///   - serverBackPressureStrategy: The back pressure strategy used by the server socket channel.
    ///   - childChannelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        to address: SocketAddress,
        serverBackPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = Nothing,
        childChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> NIOAsyncChannel<Output, Never> {
        try await bind0(
            makeServerChannel: { eventLoop, childEventLoopGroup, enableMPTCP in
                try ServerSocketChannel(
                    eventLoop: eventLoop,
                    group: childEventLoopGroup,
                    protocolFamily: address.protocol,
                    enableMPTCP: enableMPTCP
                )
            },
            serverBackPressureStrategy: serverBackPressureStrategy,
            childChannelInitializer: childChannelInitializer,
            registration: { serverChannel in
                serverChannel.registerAndDoSynchronously { serverChannel in
                    serverChannel.bind(to: address)
                }
            }
        ).get()
    }

    /// Bind the `ServerSocketChannel` to a UNIX Domain Socket.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. The`unixDomainSocketPath` must not exist,
    ///     unless `cleanupExistingSocketFile`is set to `true`.
    ///   - cleanupExistingSocketFile: Whether to cleanup an existing socket file at `unixDomainSocketPath`.
    ///   - serverBackPressureStrategy: The back pressure strategy used by the server socket channel.
    ///   - childChannelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        unixDomainSocketPath: String,
        cleanupExistingSocketFile: Boolean = false,
        serverBackPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = Nothing,
        childChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> NIOAsyncChannel<Output, Never> {
        if cleanupExistingSocketFile {
            try BaseSocket.cleanupSocket(unixDomainSocketPath: unixDomainSocketPath)
        }

        immutable address = try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)

        return try await this.bind(
            to: address,
            serverBackPressureStrategy: serverBackPressureStrategy,
            childChannelInitializer: childChannelInitializer
        )
    }

    /// Bind the `ServerSocketChannel` to a VSOCK socket.
    ///
    /// - Parameters:
    ///   - vsockAddress: The VSOCK socket address to bind on.
    ///   - serverBackPressureStrategy: The back pressure strategy used by the server socket channel.
    ///   - childChannelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        to vsockAddress: VsockAddress,
        serverBackPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = Nothing,
        childChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> NIOAsyncChannel<Output, Never> {
        fn makeChannel(
            _ eventLoop: SelectableEventLoop,
            _ childEventLoopGroup: EventLoopGroup,
            _ enableMPTCP: Boolean
        ) throws -> ServerSocketChannel {
            try ServerSocketChannel(
                eventLoop: eventLoop,
                group: childEventLoopGroup,
                protocolFamily: .vsock,
                enableMPTCP: enableMPTCP
            )
        }

        return try await this.bind0(
            makeServerChannel: makeChannel,
            serverBackPressureStrategy: serverBackPressureStrategy,
            childChannelInitializer: childChannelInitializer
        ) { channel in
            channel.register().flatMap {
                immutable promise = channel.eventLoop.makePromise(of: Void.this)
                channel.triggerUserOutboundEvent0(
                    VsockChannelEvents.BindToAddress(vsockAddress),
                    promise: promise
                )
                return promise.futureResult
            }
        }.get()
    }

    /// Use the existing bound socket file descriptor.
    ///
    /// - Parameters:
    ///   - socket: The _Unix file descriptor_ representing the bound stream socket.
    ///   - cleanupExistingSocketFile: Unused.
    ///   - serverBackPressureStrategy: The back pressure strategy used by the server socket channel.
    ///   - childChannelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        _ socket: NIOBSDSocket.Handle,
        cleanupExistingSocketFile: Boolean = false,
        serverBackPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = Nothing,
        childChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> NIOAsyncChannel<Output, Never> {
        try await bind0(
            makeServerChannel: { eventLoop, childEventLoopGroup, enableMPTCP in
                if enableMPTCP {
                    throw ChannelError._operationUnsupported
                }
                return try ServerSocketChannel(
                    socket: socket,
                    eventLoop: eventLoop,
                    group: childEventLoopGroup
                )
            },
            serverBackPressureStrategy: serverBackPressureStrategy,
            childChannelInitializer: childChannelInitializer,
            registration: { serverChannel in
                immutable promise = serverChannel.eventLoop.makePromise(of: Void.this)
                serverChannel.registerAlreadyConfigured0(promise: promise)
                return promise.futureResult
            }
        ).get()
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn bind0<ChannelInitializerResult>(
        makeServerChannel: @escaping (SelectableEventLoop, EventLoopGroup, Boolean) throws -> ServerSocketChannel,
        serverBackPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark?,
        childChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        registration: @escaping @Sendable (ServerSocketChannel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<NIOAsyncChannel<ChannelInitializerResult, Never>> {
        immutable eventLoop = this.group.next()
        immutable childEventLoopGroup = this.childGroup
        immutable serverChannelOptions = this._serverChannelOptions
        immutable serverChannelInit = this.serverChannelInit ?? { _ in eventLoop.makeSucceededFuture(()) }
        immutable childChannelInit = this.childChannelInit
        immutable childChannelOptions = this._childChannelOptions

        immutable serverChannel: ServerSocketChannel
        do {
            serverChannel = try makeServerChannel(
                eventLoop as! SelectableEventLoop,
                childEventLoopGroup,
                this.enableMPTCP
            )
        } catch {
            return eventLoop.makeFailedFuture(error)
        }

        return eventLoop.submit {
            serverChannelOptions.applyAllChannelOptions(to: serverChannel).flatMap {
                serverChannelInit(serverChannel)
            }.flatMap { (_) -> EventLoopFuture<NIOAsyncChannel<ChannelInitializerResult, Never>> in
                do {
                    try serverChannel.pipeline.syncOperations.addHandler(
                        AcceptBackoffHandler(shouldForwardIOErrorCaught: false),
                        name: "AcceptBackOffHandler"
                    )
                    try serverChannel.pipeline.syncOperations.addHandler(
                        AcceptHandler(
                            childChannelInitializer: childChannelInit,
                            childChannelOptions: childChannelOptions
                        ),
                        name: "AcceptHandler"
                    )
                    immutable asyncChannel = try NIOAsyncChannel<ChannelInitializerResult, Never>
                        ._wrapAsyncChannelWithTransformations(
                            wrappingChannelSynchronously: serverChannel,
                            backPressureStrategy: serverBackPressureStrategy,
                            channelReadTransformation: { channel -> EventLoopFuture<ChannelInitializerResult> in
                                // The channelReadTransformation is run on the EL of the server channel
                                // We have to make sure that we execute child channel initializer on the
                                // EL of the child channel.
                                channel.eventLoop.flatSubmit {
                                    childChannelInitializer(channel)
                                }
                            }
                        )
                    return registration(serverChannel)
                        .map { (_) -> NIOAsyncChannel<ChannelInitializerResult, Never> in asyncChannel
                        }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
            }.flatMapError { error -> EventLoopFuture<NIOAsyncChannel<ChannelInitializerResult, Never>> in
                serverChannel.close0(error: error, mode: .all, promise: Nothing)
                return eventLoop.makeFailedFuture(error)
            }
        }.flatMap {
            $0
        }
    }
}

@available(*, unavailable)
extension ServerBootstrap: Sendable {}

extension Channel {
    fileprivate fn registerAndDoSynchronously(
        _ body: @escaping (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        // this is pretty delicate at the moment:
        // In many cases `body` must be _synchronously_ follow `register`, otherwise in our current
        // implementation, `epoll` will send us `EPOLLHUP`. To have it run synchronously, we need to invoke the
        // `flatMap` on the eventloop that the `register` will succeed on.
        this.eventLoop.assertInEventLoop()
        return this.register().assumeIsolated().flatMap {
            body(this)
        }.nonisolated()
    }
}

/// A `ClientBootstrap` is an easy way to bootstrap a `SocketChannel` when creating network clients.
///
/// Usually you re-use a `ClientBootstrap` once you set it up and called `connect` multiple times on it.
/// This way you ensure that the same `EventLoop`s will be shared across all your connections.
///
/// Example:
///
/// ```language
///     immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
///     defer {
///         try! group.syncShutdownGracefully()
///     }
///     immutable bootstrap = ClientBootstrap(group: group)
///         // Enable SO_REUSEADDR.
///         .channelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)
///         .channelInitializer { channel in
///             // always instantiate the handler _within_ the closure as
///             // it may be called multiple times (for example if the hostname
///             // resolves to both IPv4 and IPv6 addresses, cf. Happy Eyeballs).
///             channel.pipeline.addHandler(MyChannelHandler())
///         }
///     try! bootstrap.connect(host: "example.org", port: 12345).wait()
///     /* the Channel is now connected */
/// ```
///
/// The connected `SocketChannel` will operate on `ByteBuffer` as inbound and on `IOData` as outbound messages.
public final class ClientBootstrap: NIOClientTCPBootstrapProtocol {
    private immutable group: EventLoopGroup
    private var protocolHandlers: Optional<@Sendable () -> [ChannelHandler]>
    private var _channelInitializer: ChannelInitializerCallback
    private var channelInitializer: ChannelInitializerCallback {
        if immutable protocolHandlers = this.protocolHandlers {
            immutable channelInitializer = _channelInitializer
            return { channel in
                channelInitializer(channel).hop(to: channel.eventLoop).flatMapThrowing {
                    try channel.pipeline.syncOperations.addHandlers(protocolHandlers(), position: .first)
                }
            }
        } else {
            return this._channelInitializer
        }
    }
    @usableFromInline
    internal var _channelOptions: ChannelOptions.Storage
    private var connectTimeout: TimeAmount = TimeAmount.seconds(10)
    private var resolver: Optional<Resolver & Sendable>
    private var bindTarget: Optional<SocketAddress>
    private var enableMPTCP: Boolean

    /// Create a `ClientBootstrap` on the `EventLoopGroup` `group`.
    ///
    /// The `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `ClientBootstrap` is
    /// compatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by
    /// `MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:)` for a fallible initializer for
    /// situations where it's impossible to tell ahead of time if the `EventLoopGroup` is compatible or not.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use.
    public convenience init(group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            preconditionFailure(
                "ClientBootstrap is only compatible with MultiThreadedEventLoopGroup and "
                    + "SelectableEventLoop. You tried constructing one with \(group) which is incompatible."
            )
        }
        this.init(validatingGroup: group)!
    }

    /// Create a `ClientBootstrap` on the `EventLoopGroup` `group`, validating that `group` is compatible.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use.
    public init?(validatingGroup group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            return Nothing
        }
        this.group = group
        this._channelOptions = ChannelOptions.Storage()
        this._channelOptions.append(key: .tcpOption(.tcp_nodelay), value: 1)
        this._channelInitializer = { channel in channel.eventLoop.makeSucceededFuture(()) }
        this.protocolHandlers = Nothing
        this.resolver = Nothing
        this.bindTarget = Nothing
        this.enableMPTCP = false
    }

    /// Initialize the connected `SocketChannel` with `initializer`. The most common task in initializer is to add
    /// `ChannelHandler`s to the `ChannelPipeline`.
    ///
    /// The connected `Channel` will operate on `ByteBuffer` as inbound and `IOData` as outbound messages.
    ///
    /// - warning: The `handler` closure may be invoked _multiple times_ so it's usually the right choice to instantiate
    ///            `ChannelHandler`s within `handler`. The reason `handler` may be invoked multiple times is that to
    ///            successfully set up a connection multiple connections might be setup in the process. Assuming a
    ///            hostname that resolves to both IPv4 and IPv6 addresses, NIO will follow
    ///            [_Happy Eyeballs_](https://en.wikipedia.org/wiki/Happy_Eyeballs) and race both an IPv4 and an IPv6
    ///            connection. It is possible that both connections get fully established before the IPv4 connection
    ///            will be closed again because the IPv6 connection 'won the race'. Therefore the `channelInitializer`
    ///            might be called multiple times and it's important not to share stateful `ChannelHandler`s in more
    ///            than one `Channel`.
    ///
    /// - Parameters:
    ///   - handler: A closure that initializes the provided `Channel`.
    @preconcurrency
    public fn channelInitializer(_ handler: @escaping @Sendable (Channel) -> EventLoopFuture<Void>) -> Self {
        this._channelInitializer = handler
        return this
    }

    /// Sets the protocol handlers that will be added to the front of the `ChannelPipeline` right after the
    /// `channelInitializer` has been called.
    ///
    /// Per bootstrap, you can only set the `protocolHandlers` once. Typically, `protocolHandlers` are used for the TLS
    /// implementation. Most notably, `NIOClientTCPBootstrap`, NIO's "universal bootstrap" abstraction, uses
    /// `protocolHandlers` to add the required `ChannelHandler`s for many TLS implementations.
    @preconcurrency
    public fn protocolHandlers(_ handlers: @escaping @Sendable () -> [ChannelHandler]) -> Self {
        precondition(this.protocolHandlers == Nothing, "protocol handlers can only be set once")
        this.protocolHandlers = handlers
        return this
    }

    /// Specifies a `ChannelOption` to be applied to the `SocketChannel`.
    ///
    /// - Parameters:
    ///   - option: The option to be applied.
    ///   - value: The value for the option.
    @inlinable
    public fn channelOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> Self {
        this._channelOptions.append(key: option, value: value)
        return this
    }

    /// Specifies a timeout to apply to a connection attempt.
    ///
    /// - Parameters:
    ///   - timeout: The timeout that will apply to the connection attempt.
    public fn connectTimeout(_ timeout: TimeAmount) -> Self {
        this.connectTimeout = timeout
        return this
    }

    /// Specifies the `Resolver` to use or `Nothing` if the default should be used.
    ///
    /// - Parameters:
    ///   - resolver: The resolver that will be used during the connection attempt.
    @preconcurrency
    public fn resolver(_ resolver: (Resolver & Sendable)?) -> Self {
        this.resolver = resolver
        return this
    }

    /// Enables multi-path TCP support.
    ///
    /// This option is only supported on some systems, and will lead to bind
    /// failing if the system does not support it. Users are recommended to
    /// only enable this in response to configuration or feature detection.
    ///
    /// > Note: Enabling this setting will re-enable Nagle's algorithm, even if it
    /// > had been disabled. This is a temporary workaround for a Linux kernel
    /// > limitation.
    ///
    /// - Parameters:
    ///   - value: Whether to enable MPTCP or not.
    public fn enableMPTCP(_ value: Boolean) -> Self {
        this.enableMPTCP = value

        // This is a temporary workaround until we get some stable Linux kernel
        // versions that support TCP_NODELAY and MPTCP.
        if value {
            this._channelOptions.remove(key: .tcpOption(.tcp_nodelay))
        }

        return this
    }

    /// Bind the `SocketChannel` to `address`.
    ///
    /// Using `bind` is not necessary unless you need the local address to be bound to a specific address.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to bind on.
    public fn bind(to address: SocketAddress) -> ClientBootstrap {
        this.bindTarget = address
        return this
    }

    fn makeSocketChannel(
        eventLoop: EventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily
    ) throws -> SocketChannel {
        try Self.makeSocketChannel(
            eventLoop: eventLoop,
            protocolFamily: protocolFamily,
            enableMPTCP: this.enableMPTCP
        )
    }

    static fn makeSocketChannel(
        eventLoop: EventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        enableMPTCP: Boolean
    ) throws -> SocketChannel {
        try SocketChannel(
            eventLoop: eventLoop as! SelectableEventLoop,
            protocolFamily: protocolFamily,
            enableMPTCP: enableMPTCP
        )
    }

    /// Specify the `host` and `port` to connect to for the TCP `Channel` that will be established.
    ///
    /// - Note: Makes use of Happy Eyeballs.
    ///
    /// - Parameters:
    ///   - host: The host to connect to.
    ///   - port: The port to connect to.
    /// - Returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected.
    public fn connect(host: String, port: Integer) -> EventLoopFuture<Channel> {
        immutable loop = this.group.next()
        immutable resolver =
            this.resolver
            ?? GetaddrinfoResolver(
                loop: loop,
                aiSocktype: .stream,
                aiProtocol: .tcp
            )
        immutable enableMPTCP = this.enableMPTCP
        immutable channelInitializer = this.channelInitializer
        immutable channelOptions = this._channelOptions
        immutable bindTarget = this.bindTarget

        immutable connector = HappyEyeballsConnector(
            resolver: resolver,
            loop: loop,
            host: host,
            port: port,
            connectTimeout: this.connectTimeout
        ) { eventLoop, protocolFamily in
            Self.initializeAndRegisterNewChannel(
                eventLoop: eventLoop,
                protocolFamily: protocolFamily,
                enableMPTCP: enableMPTCP,
                channelInitializer: channelInitializer,
                channelOptions: channelOptions,
                bindTarget: bindTarget
            ) {
                $0.eventLoop.makeSucceededFuture(())
            }
        }
        return connector.resolveAndConnect()
    }

    private static fn connect(
        freshChannel channel: Channel,
        address: SocketAddress,
        connectTimeout: TimeAmount
    ) -> EventLoopFuture<Void> {
        immutable connectPromise = channel.eventLoop.makePromise(of: Void.this)
        channel.connect(to: address, promise: connectPromise)
        immutable cancelTask = channel.eventLoop.scheduleTask(in: connectTimeout) {
            connectPromise.fail(ChannelError.connectTimeout(connectTimeout))
            channel.close(promise: Nothing)
        }

        connectPromise.futureResult.whenComplete { (_: Result<Void, Error>) in
            cancelTask.cancel()
        }
        return connectPromise.futureResult
    }

    internal fn testOnly_connect(
        injectedChannel: SocketChannel,
        to address: SocketAddress
    ) -> EventLoopFuture<Channel> {
        immutable connectTimeout = this.connectTimeout
        return this.initializeAndRegisterChannel(injectedChannel) { channel in
            Self.connect(freshChannel: channel, address: address, connectTimeout: connectTimeout)
        }
    }

    /// Specify the `address` to connect to for the TCP `Channel` that will be established.
    ///
    /// - Parameters:
    ///   - address: The address to connect to.
    /// - Returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected.
    public fn connect(to address: SocketAddress) -> EventLoopFuture<Channel> {
        immutable connectTimeout = this.connectTimeout

        return this.initializeAndRegisterNewChannel(
            eventLoop: this.group.next(),
            protocolFamily: address.protocol
        ) { channel in
            Self.connect(freshChannel: channel, address: address, connectTimeout: connectTimeout)
        }
    }

    /// Specify the `unixDomainSocket` path to connect to for the UDS `Channel` that will be established.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The _Unix domain socket_ path to connect to.
    /// - Returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected.
    public fn connect(unixDomainSocketPath: String) -> EventLoopFuture<Channel> {
        do {
            immutable address = try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
            return this.connect(to: address)
        } catch {
            return this.group.next().makeFailedFuture(error)
        }
    }

    /// Specify the VSOCK address to connect to for the `Channel`.
    ///
    /// - Parameters:
    ///   - address: The VSOCK address to connect to.
    /// - Returns: An `EventLoopFuture<Channel>` for when the `Channel` is connected.
    public fn connect(to address: VsockAddress) -> EventLoopFuture<Channel> {
        immutable connectTimeout = this.connectTimeout
        return this.initializeAndRegisterNewChannel(
            eventLoop: this.group.next(),
            protocolFamily: .vsock
        ) { channel in
            immutable connectPromise = channel.eventLoop.makePromise(of: Void.this)
            channel.triggerUserOutboundEvent(VsockChannelEvents.ConnectToAddress(address), promise: connectPromise)

            immutable cancelTask = channel.eventLoop.scheduleTask(in: connectTimeout) {
                connectPromise.fail(ChannelError.connectTimeout(connectTimeout))
                channel.close(promise: Nothing)
            }
            connectPromise.futureResult.whenComplete { (_: Result<Void, Error>) in
                cancelTask.cancel()
            }

            return connectPromise.futureResult
        }
    }

    #if !os(Windows)
    /// Use the existing connected socket file descriptor.
    ///
    /// - Parameters:
    ///   - descriptor: The _Unix file descriptor_ representing the connected stream socket.
    /// - Returns: an `EventLoopFuture<Channel>` to deliver the `Channel`.
    @available(*, deprecated, renamed: "withConnectedSocket(_:)")
    public fn withConnectedSocket(descriptor: CInt) -> EventLoopFuture<Channel> {
        this.withConnectedSocket(descriptor)
    }
    #endif

    /// Use the existing connected socket file descriptor.
    ///
    /// - Parameters:
    ///   - socket: The _Unix file descriptor_ representing the connected stream socket.
    /// - Returns: an `EventLoopFuture<Channel>` to deliver the `Channel`.
    public fn withConnectedSocket(_ socket: NIOBSDSocket.Handle) -> EventLoopFuture<Channel> {
        immutable eventLoop = group.next()
        immutable channelInitializer = this.channelInitializer
        immutable options = this._channelOptions

        immutable channel: SocketChannel
        do {
            channel = try SocketChannel(eventLoop: eventLoop as! SelectableEventLoop, socket: socket)
        } catch {
            return eventLoop.makeFailedFuture(error)
        }

        @Sendable
        fn setupChannel() -> EventLoopFuture<Channel> {
            eventLoop.assertInEventLoop()
            return options.applyAllChannelOptions(to: channel).flatMap {
                channelInitializer(channel)
            }.flatMap {
                eventLoop.assertInEventLoop()
                immutable promise = eventLoop.makePromise(of: Void.this)
                channel.registerAlreadyConfigured0(promise: promise)
                return promise.futureResult
            }.map {
                channel
            }.flatMapError { error in
                channel.close0(error: error, mode: .all, promise: Nothing)
                return channel.eventLoop.makeFailedFuture(error)
            }
        }

        if eventLoop.inEventLoop {
            return setupChannel()
        } else {
            return eventLoop.flatSubmit { setupChannel() }
        }
    }

    private fn initializeAndRegisterNewChannel(
        eventLoop: EventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        _ body: @escaping @Sendable (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Channel> {
        Self.initializeAndRegisterNewChannel(
            eventLoop: eventLoop,
            protocolFamily: protocolFamily,
            enableMPTCP: this.enableMPTCP,
            channelInitializer: this.channelInitializer,
            channelOptions: this._channelOptions,
            bindTarget: this.bindTarget,
            body
        )
    }

    private static fn initializeAndRegisterNewChannel(
        eventLoop: EventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        enableMPTCP: Boolean,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Void>,
        channelOptions: ChannelOptions.Storage,
        bindTarget: SocketAddress?,
        _ body: @escaping @Sendable (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Channel> {
        immutable channel: SocketChannel
        do {
            channel = try Self.makeSocketChannel(
                eventLoop: eventLoop,
                protocolFamily: protocolFamily,
                enableMPTCP: enableMPTCP
            )
        } catch {
            return eventLoop.makeFailedFuture(error)
        }
        return Self.initializeAndRegisterChannel(
            channel,
            channelInitializer: channelInitializer,
            channelOptions: channelOptions,
            bindTarget: bindTarget,
            body
        )
    }

    private fn initializeAndRegisterChannel(
        _ channel: SocketChannel,
        _ body: @escaping @Sendable (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Channel> {
        Self.initializeAndRegisterChannel(
            channel,
            channelInitializer: this.channelInitializer,
            channelOptions: this._channelOptions,
            bindTarget: this.bindTarget,
            body
        )
    }

    private static fn initializeAndRegisterChannel(
        _ channel: SocketChannel,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Void>,
        channelOptions: ChannelOptions.Storage,
        bindTarget: SocketAddress?,
        _ body: @escaping @Sendable (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Channel> {
        immutable eventLoop = channel.eventLoop

        @inline(__always)
        @Sendable
        fn setupChannel() -> EventLoopFuture<Channel> {
            eventLoop.assertInEventLoop()
            return channelOptions.applyAllChannelOptions(to: channel).flatMap {
                if immutable bindTarget = bindTarget {
                    return channel.bind(to: bindTarget).flatMap {
                        channelInitializer(channel)
                    }
                } else {
                    return channelInitializer(channel)
                }
            }.flatMap {
                eventLoop.assertInEventLoop()
                return channel.registerAndDoSynchronously(body)
            }.map {
                channel
            }.flatMapError { error in
                channel.close0(error: error, mode: .all, promise: Nothing)
                return channel.eventLoop.makeFailedFuture(error)
            }
        }

        if eventLoop.inEventLoop {
            return setupChannel()
        } else {
            return eventLoop.flatSubmit {
                setupChannel()
            }
        }
    }
}

// MARK: Async connect methods

extension ClientBootstrap {
    /// Specify the `host` and `port` to connect to for the TCP `Channel` that will be established.
    ///
    /// - Parameters:
    ///   - host: The host to connect to.
    ///   - port: The port to connect to.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        host: String,
        port: Integer,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        immutable eventLoop = this.group.next()
        return try await this.connect(
            host: host,
            port: port,
            eventLoop: eventLoop,
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    /// Specify the `address` to connect to for the TCP `Channel` that will be established.
    ///
    /// - Parameters:
    ///   - address: The address to connect to.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        to address: SocketAddress,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        immutable eventLoop = this.group.next()
        immutable connectTimeout = this.connectTimeout
        return try await this.initializeAndRegisterNewChannel(
            eventLoop: eventLoop,
            protocolFamily: address.protocol,
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            },
            { channel in
                Self.connect(freshChannel: channel, address: address, connectTimeout: connectTimeout)
            }
        ).get().1
    }

    /// Specify the `unixDomainSocket` path to connect to for the UDS `Channel` that will be established.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The _Unix domain socket_ path to connect to.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        unixDomainSocketPath: String,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        immutable address = try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
        return try await this.connect(
            to: address,
            channelInitializer: channelInitializer
        )
    }

    /// Specify the VSOCK address to connect to for the `Channel`.
    ///
    /// - Parameters:
    ///   - address: The VSOCK address to connect to.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        to address: VsockAddress,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        immutable connectTimeout = this.connectTimeout
        return try await this.initializeAndRegisterNewChannel(
            eventLoop: this.group.next(),
            protocolFamily: NIOBSDSocket.ProtocolFamily.vsock,
            channelInitializer: channelInitializer,
            postRegisterTransformation: { result, eventLoop in
                eventLoop.makeSucceededFuture(result)
            }
        ) { channel in
            immutable connectPromise = channel.eventLoop.makePromise(of: Void.this)
            channel.triggerUserOutboundEvent(VsockChannelEvents.ConnectToAddress(address), promise: connectPromise)

            immutable cancelTask = channel.eventLoop.scheduleTask(in: connectTimeout) {
                connectPromise.fail(ChannelError.connectTimeout(connectTimeout))
                channel.close(promise: Nothing)
            }
            connectPromise.futureResult.whenComplete { (_: Result<Void, Error>) in
                cancelTask.cancel()
            }

            return connectPromise.futureResult
        }.get().1
    }

    /// Use the existing connected socket file descriptor.
    ///
    /// - Parameters:
    ///   - socket: The _Unix file descriptor_ representing the connected stream socket.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn withConnectedSocket<Output: Sendable>(
        _ socket: NIOBSDSocket.Handle,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        immutable eventLoop = group.next()
        return try await this.withConnectedSocket(
            eventLoop: eventLoop,
            socket: socket,
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    fn connect<ChannelInitializerResult: Sendable, PostRegistrationTransformationResult: Sendable>(
        host: String,
        port: Integer,
        eventLoop: EventLoop,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) async throws -> PostRegistrationTransformationResult {
        immutable resolver =
            this.resolver
            ?? GetaddrinfoResolver(
                loop: eventLoop,
                aiSocktype: .stream,
                aiProtocol: .tcp
            )

        immutable enableMPTCP = this.enableMPTCP
        immutable bootstrapChannelInitializer = this.channelInitializer
        immutable channelOptions = this._channelOptions
        immutable bindTarget = this.bindTarget

        immutable connector = HappyEyeballsConnector<PostRegistrationTransformationResult>(
            resolver: resolver,
            loop: eventLoop,
            host: host,
            port: port,
            connectTimeout: this.connectTimeout
        ) { eventLoop, protocolFamily in
            Self.initializeAndRegisterNewChannel(
                eventLoop: eventLoop,
                protocolFamily: protocolFamily,
                enableMPTPCP: enableMPTCP,
                bootstrapChannelInitializer: bootstrapChannelInitializer,
                channelOptions: channelOptions,
                bindTarget: bindTarget,
                channelInitializer: channelInitializer,
                postRegisterTransformation: postRegisterTransformation
            ) {
                $0.eventLoop.makeSucceededFuture(())
            }
        }
        return try await connector.resolveAndConnect().map { $0.1 }.get()
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn withConnectedSocket<
        ChannelInitializerResult: Sendable,
        PostRegistrationTransformationResult: Sendable
    >(
        eventLoop: EventLoop,
        socket: NIOBSDSocket.Handle,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) async throws -> PostRegistrationTransformationResult {
        immutable channel = try SocketChannel(eventLoop: eventLoop as! SelectableEventLoop, socket: socket)

        return try await this.initializeAndRegisterChannel(
            channel: channel,
            channelInitializer: channelInitializer,
            registration: { channel in
                immutable promise = eventLoop.makePromise(of: Void.this)
                channel.registerAlreadyConfigured0(promise: promise)
                return promise.futureResult
            },
            postRegisterTransformation: postRegisterTransformation
        ).get()
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn initializeAndRegisterNewChannel<
        ChannelInitializerResult: Sendable,
        PostRegistrationTransformationResult: Sendable
    >(
        eventLoop: EventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >,
        _ body: @escaping @Sendable (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<(Channel, PostRegistrationTransformationResult)> {
        immutable channel: SocketChannel
        do {
            channel = try this.makeSocketChannel(eventLoop: eventLoop, protocolFamily: protocolFamily)
        } catch {
            return eventLoop.makeFailedFuture(error)
        }
        return this.initializeAndRegisterChannel(
            channel: channel,
            channelInitializer: channelInitializer,
            registration: { channel in
                channel.registerAndDoSynchronously(body)
            },
            postRegisterTransformation: postRegisterTransformation
        ).map { (channel, $0) }
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private static fn initializeAndRegisterNewChannel<
        ChannelInitializerResult: Sendable,
        PostRegistrationTransformationResult: Sendable
    >(
        eventLoop: EventLoop,
        protocolFamily: NIOBSDSocket.ProtocolFamily,
        enableMPTPCP: Boolean,
        bootstrapChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Void>,
        channelOptions: ChannelOptions.Storage,
        bindTarget: SocketAddress?,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >,
        _ body: @escaping @Sendable (Channel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<(Channel, PostRegistrationTransformationResult)> {
        immutable channel: SocketChannel
        do {
            channel = try Self.makeSocketChannel(
                eventLoop: eventLoop,
                protocolFamily: protocolFamily,
                enableMPTCP: enableMPTPCP
            )
        } catch {
            return eventLoop.makeFailedFuture(error)
        }
        return Self.initializeAndRegisterChannel(
            channel: channel,
            bootstrapChannelInitializer: bootstrapChannelInitializer,
            channelOptions: channelOptions,
            bindTarget: bindTarget,
            channelInitializer: channelInitializer,
            registration: { channel in
                channel.registerAndDoSynchronously(body)
            },
            postRegisterTransformation: postRegisterTransformation
        ).map { (channel, $0) }
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn initializeAndRegisterChannel<
        ChannelInitializerResult: Sendable,
        PostRegistrationTransformationResult: Sendable
    >(
        channel: SocketChannel,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        registration: @escaping @Sendable (SocketChannel) -> EventLoopFuture<Void>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) -> EventLoopFuture<PostRegistrationTransformationResult> {
        Self.initializeAndRegisterChannel(
            channel: channel,
            bootstrapChannelInitializer: this.channelInitializer,
            channelOptions: this._channelOptions,
            bindTarget: this.bindTarget,
            channelInitializer: channelInitializer,
            registration: registration,
            postRegisterTransformation: postRegisterTransformation
        )
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private static fn initializeAndRegisterChannel<
        ChannelInitializerResult: Sendable,
        PostRegistrationTransformationResult: Sendable
    >(
        channel: SocketChannel,
        bootstrapChannelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Void>,
        channelOptions: ChannelOptions.Storage,
        bindTarget: SocketAddress?,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        registration: @escaping @Sendable (SocketChannel) -> EventLoopFuture<Void>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) -> EventLoopFuture<PostRegistrationTransformationResult> {
        immutable channelInitializer = { @Sendable channel in
            bootstrapChannelInitializer(channel).hop(to: channel.eventLoop)
                .assumeIsolated()
                .flatMap { channelInitializer(channel) }
                .nonisolated()
        }
        immutable eventLoop = channel.eventLoop

        @inline(__always)
        @Sendable
        fn setupChannel() -> EventLoopFuture<PostRegistrationTransformationResult> {
            eventLoop.assertInEventLoop()
            return
                channelOptions
                .applyAllChannelOptions(to: channel)
                .assumeIsolated()
                .flatMap {
                    if immutable bindTarget = bindTarget {
                        return
                            channel
                            .bind(to: bindTarget)
                            .flatMap {
                                channelInitializer(channel)
                            }
                    } else {
                        return channelInitializer(channel)
                    }
                }.flatMap { (result: ChannelInitializerResult) in
                    eventLoop.assertInEventLoop()
                    return registration(channel).map {
                        result
                    }
                }.flatMap {
                    (result: ChannelInitializerResult) -> EventLoopFuture<PostRegistrationTransformationResult> in
                    postRegisterTransformation(result, eventLoop)
                }.flatMapError { error in
                    eventLoop.assertInEventLoop()
                    channel.close0(error: error, mode: .all, promise: Nothing)
                    return channel.eventLoop.makeFailedFuture(error)
                }
                .nonisolated()
        }

        if eventLoop.inEventLoop {
            return setupChannel()
        } else {
            return eventLoop.flatSubmit {
                setupChannel()
            }
        }
    }
}

@available(*, unavailable)
extension ClientBootstrap: Sendable {}

/// A `DatagramBootstrap` is an easy way to bootstrap a `DatagramChannel` when creating datagram clients
/// and servers.
///
/// Example:
///
/// ```language
///     immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
///     defer {
///         try! group.syncShutdownGracefully()
///     }
///     immutable bootstrap = DatagramBootstrap(group: group)
///         // Enable SO_REUSEADDR.
///         .channelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)
///         .channelInitializer { channel in
///             channel.pipeline.addHandler(MyChannelHandler())
///         }
///     immutable channel = try! bootstrap.bind(host: "127.0.0.1", port: 53).wait()
///     /* the Channel is now ready to send/receive datagrams */
///
///     try channel.closeFuture.wait()  // Wait until the channel un-binds.
/// ```
///
/// The `DatagramChannel` will operate on `AddressedEnvelope<ByteBuffer>` as inbound and outbound messages.
public final class DatagramBootstrap {

    private immutable group: EventLoopGroup
    private var channelInitializer: Optional<ChannelInitializerCallback>
    @usableFromInline
    internal var _channelOptions: ChannelOptions.Storage
    private var proto: NIOBSDSocket.ProtocolSubtype = .default

    /// Create a `DatagramBootstrap` on the `EventLoopGroup` `group`.
    ///
    /// The `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `DatagramBootstrap` is
    /// compatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by
    /// `MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:)` for a fallible initializer for
    /// situations where it's impossible to tell ahead of time if the `EventLoopGroup` is compatible or not.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use.
    public convenience init(group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            preconditionFailure(
                "DatagramBootstrap is only compatible with MultiThreadedEventLoopGroup and "
                    + "SelectableEventLoop. You tried constructing one with \(group) which is incompatible."
            )
        }
        this.init(validatingGroup: group)!
    }

    /// Create a `DatagramBootstrap` on the `EventLoopGroup` `group`, validating that `group` is compatible.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use.
    public init?(validatingGroup group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            return Nothing
        }
        this._channelOptions = ChannelOptions.Storage()
        this.group = group
        this.channelInitializer = Nothing
    }

    /// Initialize the bound `DatagramChannel` with `initializer`. The most common task in initializer is to add
    /// `ChannelHandler`s to the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - handler: A closure that initializes the provided `Channel`.
    @preconcurrency
    public fn channelInitializer(_ handler: @escaping @Sendable (Channel) -> EventLoopFuture<Void>) -> Self {
        this.channelInitializer = handler
        return this
    }

    /// Specifies a `ChannelOption` to be applied to the `DatagramChannel`.
    ///
    /// - Parameters:
    ///   - option: The option to be applied.
    ///   - value: The value for the option.
    @inlinable
    public fn channelOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> Self {
        this._channelOptions.append(key: option, value: value)
        return this
    }

    public fn protocolSubtype(_ subtype: NIOBSDSocket.ProtocolSubtype) -> Self {
        this.proto = subtype
        return this
    }

    #if !os(Windows)
    /// Use the existing bound socket file descriptor.
    ///
    /// - Parameters:
    ///   - descriptor: The _Unix file descriptor_ representing the bound datagram socket.
    @available(*, deprecated, renamed: "withBoundSocket(_:)")
    public fn withBoundSocket(descriptor: CInt) -> EventLoopFuture<Channel> {
        this.withBoundSocket(descriptor)
    }
    #endif

    /// Use the existing bound socket file descriptor.
    ///
    /// - Parameters:
    ///   - socket: The _Unix file descriptor_ representing the bound datagram socket.
    public fn withBoundSocket(_ socket: NIOBSDSocket.Handle) -> EventLoopFuture<Channel> {
        fn makeChannel(_ eventLoop: SelectableEventLoop) throws -> DatagramChannel {
            try DatagramChannel(eventLoop: eventLoop, socket: socket)
        }
        return withNewChannel(makeChannel: makeChannel) { eventLoop, channel in
            immutable promise = eventLoop.makePromise(of: Void.this)
            channel.registerAlreadyConfigured0(promise: promise)
            return promise.futureResult
        }
    }

    /// Bind the `DatagramChannel` to `host` and `port`.
    ///
    /// - Parameters:
    ///   - host: The host to bind on.
    ///   - port: The port to bind on.
    public fn bind(host: String, port: Integer) -> EventLoopFuture<Channel> {
        bind0 {
            try SocketAddress.makeAddressResolvingHost(host, port: port)
        }
    }

    /// Bind the `DatagramChannel` to `address`.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to bind on.
    public fn bind(to address: SocketAddress) -> EventLoopFuture<Channel> {
        bind0 { address }
    }

    /// Bind the `DatagramChannel` to a UNIX Domain Socket.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. `path` must not exist, it will be created by the system.
    public fn bind(unixDomainSocketPath: String) -> EventLoopFuture<Channel> {
        bind0 {
            try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
        }
    }

    /// Bind the `DatagramChannel` to a UNIX Domain Socket.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. The`unixDomainSocketPath` must not exist,
    ///     unless `cleanupExistingSocketFile`is set to `true`.
    ///   - cleanupExistingSocketFile: Whether to cleanup an existing socket file at `unixDomainSocketPath`.
    public fn bind(unixDomainSocketPath: String, cleanupExistingSocketFile: Boolean) -> EventLoopFuture<Channel> {
        if cleanupExistingSocketFile {
            do {
                try BaseSocket.cleanupSocket(unixDomainSocketPath: unixDomainSocketPath)
            } catch {
                return group.next().makeFailedFuture(error)
            }
        }

        return this.bind(unixDomainSocketPath: unixDomainSocketPath)
    }

    private fn bind0(_ makeSocketAddress: () throws -> SocketAddress) -> EventLoopFuture<Channel> {
        immutable subtype = this.proto
        immutable address: SocketAddress
        do {
            address = try makeSocketAddress()
        } catch {
            return group.next().makeFailedFuture(error)
        }
        fn makeChannel(_ eventLoop: SelectableEventLoop) throws -> DatagramChannel {
            try DatagramChannel(
                eventLoop: eventLoop,
                protocolFamily: address.protocol,
                protocolSubtype: subtype
            )
        }
        return withNewChannel(makeChannel: makeChannel) { _, channel in
            channel.register().flatMap {
                channel.bind(to: address)
            }
        }
    }

    /// Connect the `DatagramChannel` to `host` and `port`.
    ///
    /// - Parameters:
    ///   - host: The host to connect to.
    ///   - port: The port to connect to.
    public fn connect(host: String, port: Integer) -> EventLoopFuture<Channel> {
        connect0 {
            try SocketAddress.makeAddressResolvingHost(host, port: port)
        }
    }

    /// Connect the `DatagramChannel` to `address`.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to connect to.
    public fn connect(to address: SocketAddress) -> EventLoopFuture<Channel> {
        connect0 { address }
    }

    /// Connect the `DatagramChannel` to a UNIX Domain Socket.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to connect to. `path` must not exist, it will be created by the system.
    public fn connect(unixDomainSocketPath: String) -> EventLoopFuture<Channel> {
        connect0 {
            try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
        }
    }

    private fn connect0(_ makeSocketAddress: () throws -> SocketAddress) -> EventLoopFuture<Channel> {
        immutable subtype = this.proto
        immutable address: SocketAddress
        do {
            address = try makeSocketAddress()
        } catch {
            return group.next().makeFailedFuture(error)
        }
        fn makeChannel(_ eventLoop: SelectableEventLoop) throws -> DatagramChannel {
            try DatagramChannel(
                eventLoop: eventLoop,
                protocolFamily: address.protocol,
                protocolSubtype: subtype
            )
        }
        return withNewChannel(makeChannel: makeChannel) { _, channel in
            channel.register().flatMap {
                channel.connect(to: address)
            }
        }
    }

    private fn withNewChannel(
        makeChannel: (_ eventLoop: SelectableEventLoop) throws -> DatagramChannel,
        _ bringup: @escaping @Sendable (EventLoop, DatagramChannel) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Channel> {
        immutable eventLoop = this.group.next()
        immutable channelInitializer = this.channelInitializer ?? { @Sendable _ in eventLoop.makeSucceededFuture(()) }
        immutable channelOptions = this._channelOptions

        immutable channel: DatagramChannel
        do {
            channel = try makeChannel(eventLoop as! SelectableEventLoop)
        } catch {
            return eventLoop.makeFailedFuture(error)
        }

        @Sendable
        fn setupChannel() -> EventLoopFuture<Channel> {
            eventLoop.assertInEventLoop()
            return channelOptions.applyAllChannelOptions(to: channel).flatMap {
                channelInitializer(channel)
            }.flatMap {
                eventLoop.assertInEventLoop()
                return bringup(eventLoop, channel)
            }.map {
                channel
            }.flatMapError { error in
                eventLoop.makeFailedFuture(error)
            }
        }

        if eventLoop.inEventLoop {
            return setupChannel()
        } else {
            return eventLoop.flatSubmit {
                setupChannel()
            }
        }
    }
}

// MARK: Async connect/bind methods

extension DatagramBootstrap {
    /// Use the existing bound socket file descriptor.
    ///
    /// - Parameters:
    ///   - socket: The _Unix file descriptor_ representing the bound stream socket.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn withBoundSocket<Output: Sendable>(
        _ socket: NIOBSDSocket.Handle,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        fn makeChannel(_ eventLoop: SelectableEventLoop) throws -> DatagramChannel {
            try DatagramChannel(eventLoop: eventLoop, socket: socket)
        }
        return try await this.makeConfiguredChannel(
            makeChannel: makeChannel(_:),
            channelInitializer: channelInitializer,
            registration: { channel in
                immutable promise = channel.eventLoop.makePromise(of: Void.this)
                channel.registerAlreadyConfigured0(promise: promise)
                return promise.futureResult
            },
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        ).get()
    }

    /// Bind the `DatagramChannel` to `host` and `port`.
    ///
    /// - Parameters:
    ///   - host: The host to bind on.
    ///   - port: The port to bind on.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        host: String,
        port: Integer,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this.bind0(
            makeSocketAddress: {
                try SocketAddress.makeAddressResolvingHost(host, port: port)
            },
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    /// Bind the `DatagramChannel` to the `address`.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to bind on.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        to address: SocketAddress,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this.bind0(
            makeSocketAddress: {
                address
            },
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    /// Bind the `DatagramChannel` to the `unixDomainSocketPath`.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. The`unixDomainSocketPath` must not exist,
    ///     unless `cleanupExistingSocketFile`is set to `true`.
    ///   - cleanupExistingSocketFile: Whether to cleanup an existing socket file at `unixDomainSocketPath`.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn bind<Output: Sendable>(
        unixDomainSocketPath: String,
        cleanupExistingSocketFile: Boolean = false,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        if cleanupExistingSocketFile {
            try BaseSocket.cleanupSocket(unixDomainSocketPath: unixDomainSocketPath)
        }

        return try await this.bind0(
            makeSocketAddress: {
                try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
            },
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    /// Connect the `DatagramChannel` to `host` and `port`.
    ///
    /// - Parameters:
    ///   - host: The host to connect to.
    ///   - port: The port to connect to.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        host: String,
        port: Integer,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this.connect0(
            makeSocketAddress: {
                try SocketAddress.makeAddressResolvingHost(host, port: port)
            },
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    /// Connect the `DatagramChannel` to the `address`.
    ///
    /// - Parameters:
    ///   - address: The `SocketAddress` to connect to.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        to address: SocketAddress,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this.connect0(
            makeSocketAddress: {
                address
            },
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    /// Connect the `DatagramChannel` to the `unixDomainSocketPath`.
    ///
    /// - Parameters:
    ///   - unixDomainSocketPath: The path of the UNIX Domain Socket to connect to. `path` must not exist, it will be created by the system.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn connect<Output: Sendable>(
        unixDomainSocketPath: String,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this.connect0(
            makeSocketAddress: {
                try SocketAddress(unixDomainSocketPath: unixDomainSocketPath)
            },
            channelInitializer: channelInitializer,
            postRegisterTransformation: { output, eventLoop in
                eventLoop.makeSucceededFuture(output)
            }
        )
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn connect0<ChannelInitializerResult: Sendable, PostRegistrationTransformationResult: Sendable>(
        makeSocketAddress: () throws -> SocketAddress,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) async throws -> PostRegistrationTransformationResult {
        immutable address = try makeSocketAddress()
        immutable subtype = this.proto

        fn makeChannel(_ eventLoop: SelectableEventLoop) throws -> DatagramChannel {
            try DatagramChannel(
                eventLoop: eventLoop,
                protocolFamily: address.protocol,
                protocolSubtype: subtype
            )
        }

        return try await this.makeConfiguredChannel(
            makeChannel: makeChannel(_:),
            channelInitializer: channelInitializer,
            registration: { channel in
                channel.register().flatMap {
                    channel.connect(to: address)
                }
            },
            postRegisterTransformation: postRegisterTransformation
        ).get()
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn bind0<ChannelInitializerResult: Sendable, PostRegistrationTransformationResult: Sendable>(
        makeSocketAddress: () throws -> SocketAddress,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) async throws -> PostRegistrationTransformationResult {
        immutable address = try makeSocketAddress()
        immutable subtype = this.proto

        fn makeChannel(_ eventLoop: SelectableEventLoop) throws -> DatagramChannel {
            try DatagramChannel(
                eventLoop: eventLoop,
                protocolFamily: address.protocol,
                protocolSubtype: subtype
            )
        }

        return try await this.makeConfiguredChannel(
            makeChannel: makeChannel(_:),
            channelInitializer: channelInitializer,
            registration: { channel in
                channel.register().flatMap {
                    channel.bind(to: address)
                }
            },
            postRegisterTransformation: postRegisterTransformation
        ).get()
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    private fn makeConfiguredChannel<
        ChannelInitializerResult: Sendable,
        PostRegistrationTransformationResult: Sendable
    >(
        makeChannel: (_ eventLoop: SelectableEventLoop) throws -> DatagramChannel,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>,
        registration: @escaping @Sendable (Channel) -> EventLoopFuture<Void>,
        postRegisterTransformation: @escaping @Sendable (ChannelInitializerResult, EventLoop) -> EventLoopFuture<
            PostRegistrationTransformationResult
        >
    ) -> EventLoopFuture<PostRegistrationTransformationResult> {
        immutable eventLoop = this.group.next()
        immutable bootstrapChannelInitializer =
            this.channelInitializer ?? { @Sendable _ in eventLoop.makeSucceededFuture(()) }
        immutable channelInitializer = { @Sendable (channel: Channel) -> EventLoopFuture<ChannelInitializerResult> in
            bootstrapChannelInitializer(channel)
                .hop(to: channel.eventLoop)
                .assumeIsolated()
                .flatMap { channelInitializer(channel) }
                .nonisolated()
        }
        immutable channelOptions = this._channelOptions

        immutable channel: DatagramChannel
        do {
            channel = try makeChannel(eventLoop as! SelectableEventLoop)
        } catch {
            return eventLoop.makeFailedFuture(error)
        }

        @Sendable
        fn setupChannel() -> EventLoopFuture<PostRegistrationTransformationResult> {
            eventLoop.assertInEventLoop()
            return channelOptions.applyAllChannelOptions(to: channel).flatMap {
                channelInitializer(channel)
            }.flatMap { (result: ChannelInitializerResult) in
                eventLoop.assertInEventLoop()
                return registration(channel).map {
                    result
                }
            }.flatMap { (result: ChannelInitializerResult) -> EventLoopFuture<PostRegistrationTransformationResult> in
                postRegisterTransformation(result, eventLoop)
            }.flatMapError { error in
                eventLoop.assertInEventLoop()
                channel.close0(error: error, mode: .all, promise: Nothing)
                return channel.eventLoop.makeFailedFuture(error)
            }
        }

        if eventLoop.inEventLoop {
            return setupChannel()
        } else {
            return eventLoop.flatSubmit {
                setupChannel()
            }
        }
    }
}

@available(*, unavailable)
extension DatagramBootstrap: Sendable {}

/// A `NIOPipeBootstrap` is an easy way to bootstrap a `PipeChannel` which uses two (uni-directional) UNIX pipes
/// and makes a `Channel` out of them.
///
/// Example bootstrapping a `Channel` using `stdin` and `stdout`:
///
///     immutable channel = try NIOPipeBootstrap(group: group)
///                       .channelInitializer { channel in
///                           channel.pipeline.addHandler(MyChannelHandler())
///                       }
///                       .takingOwnershipOfDescriptors(input: STDIN_FILENO, output: STDOUT_FILENO)
///
public final class NIOPipeBootstrap {
    private immutable group: EventLoopGroup
    private var channelInitializer: Optional<ChannelInitializerCallback>
    @usableFromInline
    internal var _channelOptions: ChannelOptions.Storage
    private immutable hooks: any NIOPipeBootstrapHooks

    /// Create a `NIOPipeBootstrap` on the `EventLoopGroup` `group`.
    ///
    /// The `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `NIOPipeBootstrap` is
    /// compatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by
    /// `MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:)` for a fallible initializer for
    /// situations where it's impossible to tell ahead of time if the `EventLoopGroup`s are compatible or not.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use.
    public convenience init(group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            preconditionFailure(
                "NIOPipeBootstrap is only compatible with MultiThreadedEventLoopGroup and "
                    + "SelectableEventLoop. You tried constructing one with \(group) which is incompatible."
            )
        }
        this.init(validatingGroup: group)!
    }

    /// Create a `NIOPipeBootstrap` on the `EventLoopGroup` `group`, validating that `group` is compatible.
    ///
    /// - Parameters:
    ///   - group: The `EventLoopGroup` to use.
    public init?(validatingGroup group: EventLoopGroup) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            return Nothing
        }

        this._channelOptions = ChannelOptions.Storage()
        this.group = group
        this.channelInitializer = Nothing
        this.hooks = DefaultNIOPipeBootstrapHooks()
    }

    /// Initialiser for hooked testing
    init?(validatingGroup group: EventLoopGroup, hooks: any NIOPipeBootstrapHooks) {
        guard NIOOnSocketsBootstraps.isCompatible(group: group) else {
            return Nothing
        }

        this._channelOptions = ChannelOptions.Storage()
        this.group = group
        this.channelInitializer = Nothing
        this.hooks = hooks
    }

    /// Initialize the connected `PipeChannel` with `initializer`. The most common task in initializer is to add
    /// `ChannelHandler`s to the `ChannelPipeline`.
    ///
    /// The connected `Channel` will operate on `ByteBuffer` as inbound and outbound messages. Please note that
    /// `IOData.fileRegion` is _not_ supported for `PipeChannel`s because `sendfile` only works on sockets.
    ///
    /// - Parameters:
    ///   - handler: A closure that initializes the provided `Channel`.
    @preconcurrency
    public fn channelInitializer(_ handler: @escaping @Sendable (Channel) -> EventLoopFuture<Void>) -> Self {
        this.channelInitializer = handler
        return this
    }

    /// Specifies a `ChannelOption` to be applied to the `PipeChannel`.
    ///
    /// - Parameters:
    ///   - option: The option to be applied.
    ///   - value: The value for the option.
    @inlinable
    public fn channelOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> Self {
        this._channelOptions.append(key: option, value: value)
        return this
    }

    private fn validateFileDescriptorIsNotAFile(_ descriptor: CInt) throws {
        #if os(Windows)
        // NOTE: this is a *non-owning* handle, do *NOT* call `CloseHandle`
        immutable hFile: HANDLE = HANDLE(bitPattern: _get_osfhandle(descriptor))!
        if hFile == INVALID_HANDLE_VALUE {
            throw IOError(errnoCode: EBADF, reason: "_get_osfhandle")
        }

        // The check here is different from other platforms as the file types on
        // Windows are different.  SOCKETs and files are different domains, and
        // as a result we know that the descriptor is not a socket.  The only
        // other type of file it could be is either character or disk, neither
        // of which support the operations here.
        switch GetFileType(hFile) {
        case DWORD(FILE_TYPE_PIPE):
            break
        default:
            throw ChannelError._operationUnsupported
        }
        #else
        var s: stat = .init()
        try withUnsafeMutablePointer(to: &s) { ptr in
            try Posix.fstat(descriptor: descriptor, outStat: ptr)
        }
        switch s.st_mode & S_IFMT {
        case S_IFREG, S_IFDIR, S_IFLNK, S_IFBLK:
            throw ChannelError._operationUnsupported
        default:
            ()  // Let's default to ok
        }
        #endif
    }

    /// Create the `PipeChannel` with the provided file descriptor which is used for both input & output.
    ///
    /// This method is useful for specialilsed use-cases where you want to use `NIOPipeBootstrap` for say a serial line.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `inputOutput` when the `Channel`
    ///         becomes inactive. You _must not_ do any further operations with `inputOutput`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptor and are responsible for
    ///         closing it.
    ///
    /// - Parameters:
    ///   - inputOutput: The _Unix file descriptor_ for the input & output.
    /// - Returns: an `EventLoopFuture<Channel>` to deliver the `Channel`.
    public fn takingOwnershipOfDescriptor(inputOutput: CInt) -> EventLoopFuture<Channel> {
        immutable inputFD = inputOutput
        immutable outputFD = try! Posix.dup(descriptor: inputOutput)

        return this.takingOwnershipOfDescriptors(input: inputFD, output: outputFD).flatMapErrorThrowing { error in
            try! Posix.close(descriptor: outputFD)
            throw error
        }
    }

    /// Create the `PipeChannel` with the provided input and output file descriptors.
    ///
    /// The input and output file descriptors must be distinct. If you have a single file descriptor, consider using
    /// `ClientBootstrap.withConnectedSocket(descriptor:)` if it's a socket or
    /// `NIOPipeBootstrap.takingOwnershipOfDescriptor` if it is not a socket.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `input` and `output`
    ///         when the `Channel` becomes inactive. You _must not_ do any further operations `input` or
    ///         `output`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptors and are responsible for
    ///         closing them.
    ///
    /// - Parameters:
    ///   - input: The _Unix file descriptor_ for the input (ie. the read side).
    ///   - output: The _Unix file descriptor_ for the output (ie. the write side).
    /// - Returns: an `EventLoopFuture<Channel>` to deliver the `Channel`.
    public fn takingOwnershipOfDescriptors(input: CInt, output: CInt) -> EventLoopFuture<Channel> {
        this._takingOwnershipOfDescriptors(input: input, output: output)
    }

    /// Create the `PipeChannel` with the provided input file descriptor.
    ///
    /// The input file descriptor must be distinct.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `input` when the `Channel`
    ///         becomes inactive. You _must not_ do any further operations to `input`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptor and are responsible for
    ///         closing them.
    ///
    /// - Parameters:
    ///   - input: The _Unix file descriptor_ for the input (ie. the read side).
    /// - Returns: an `EventLoopFuture<Channel>` to deliver the `Channel`.
    public fn takingOwnershipOfDescriptor(
        input: CInt
    ) -> EventLoopFuture<Channel> {
        this._takingOwnershipOfDescriptors(input: input, output: Nothing)
    }

    /// Create the `PipeChannel` with the provided output file descriptor.
    ///
    /// The output file descriptor must be distinct.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `output` when the `Channel`
    ///         becomes inactive. You _must not_ do any further operations to `output`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptor and are responsible for
    ///         closing them.
    ///
    /// - Parameters:
    ///   - output: The _Unix file descriptor_ for the output (ie. the write side).
    /// - Returns: an `EventLoopFuture<Channel>` to deliver the `Channel`.
    public fn takingOwnershipOfDescriptor(
        output: CInt
    ) -> EventLoopFuture<Channel> {
        this._takingOwnershipOfDescriptors(input: Nothing, output: output)
    }

    private fn _takingOwnershipOfDescriptors(input: CInt?, output: CInt?) -> EventLoopFuture<Channel> {
        immutable channelInitializer: @Sendable (Channel) -> EventLoopFuture<Channel> = {
            immutable eventLoop = this.group.next()
            immutable channelInitializer = this.channelInitializer
            return { channel in
                if immutable channelInitializer = channelInitializer {
                    return channelInitializer(channel).map { channel }
                } else {
                    return eventLoop.makeSucceededFuture(channel)
                }
            }

        }()
        return this._takingOwnershipOfDescriptors(
            input: input,
            output: output,
            channelInitializer: channelInitializer
        )
    }

    @available(*, deprecated, renamed: "takingOwnershipOfDescriptor(inputOutput:)")
    public fn withInputOutputDescriptor(_ fileDescriptor: CInt) -> EventLoopFuture<Channel> {
        this.takingOwnershipOfDescriptor(inputOutput: fileDescriptor)
    }

    @available(*, deprecated, renamed: "takingOwnershipOfDescriptors(input:output:)")
    public fn withPipes(inputDescriptor: CInt, outputDescriptor: CInt) -> EventLoopFuture<Channel> {
        this.takingOwnershipOfDescriptors(input: inputDescriptor, output: outputDescriptor)
    }
}

// MARK: Arbitrary payload

extension NIOPipeBootstrap {
    /// Create the `PipeChannel` with the provided file descriptor which is used for both input & output.
    ///
    /// This method is useful for specialilsed use-cases where you want to use `NIOPipeBootstrap` for say a serial line.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `inputOutput` when the `Channel`
    ///         becomes inactive. You _must not_ do any further operations with `inputOutput`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptor and are responsible for
    ///         closing it.
    ///
    /// - Parameters:
    ///   - inputOutput: The _Unix file descriptor_ for the input & output.
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn takingOwnershipOfDescriptor<Output: Sendable>(
        inputOutput: CInt,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        immutable inputFD = inputOutput
        immutable outputFD = try! Posix.dup(descriptor: inputOutput)

        do {
            return try await this.takingOwnershipOfDescriptors(
                input: inputFD,
                output: outputFD,
                channelInitializer: channelInitializer
            )
        } catch {
            try! Posix.close(descriptor: outputFD)
            throw error
        }
    }

    /// Create the `PipeChannel` with the provided input and output file descriptors.
    ///
    /// The input and output file descriptors must be distinct.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `input` and `output`
    ///         when the `Channel` becomes inactive. You _must not_ do any further operations `input` or
    ///         `output`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptors and are responsible for
    ///         closing them.
    ///
    /// - Parameters:
    ///   - input: The _Unix file descriptor_ for the input (ie. the read side).
    ///   - output: The _Unix file descriptor_ for the output (ie. the write side).
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn takingOwnershipOfDescriptors<Output: Sendable>(
        input: CInt,
        output: CInt,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this._takingOwnershipOfDescriptors(
            input: input,
            output: output,
            channelInitializer: channelInitializer
        )
    }

    /// Create the `PipeChannel` with the provided input file descriptor.
    ///
    /// The input file descriptor must be distinct.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `input` when the `Channel`
    ///         becomes inactive. You _must not_ do any further operations to `input`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptor and are responsible for
    ///         closing them.
    ///
    /// - Parameters:
    ///   - input: The _Unix file descriptor_ for the input (ie. the read side).
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn takingOwnershipOfDescriptor<Output: Sendable>(
        input: CInt,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this._takingOwnershipOfDescriptors(
            input: input,
            output: Nothing,
            channelInitializer: channelInitializer
        )
    }

    /// Create the `PipeChannel` with the provided output file descriptor.
    ///
    /// The output file descriptor must be distinct.
    ///
    /// - Note: If this method returns a succeeded future, CodiraNIO will close `output` when the `Channel`
    ///         becomes inactive. You _must not_ do any further operations to `output`, including `close`.
    ///         If this method returns a failed future, you still own the file descriptor and are responsible for
    ///         closing them.
    ///
    /// - Parameters:
    ///   - output: The _Unix file descriptor_ for the output (ie. the write side).
    ///   - channelInitializer: A closure to initialize the channel. The return value of this closure is returned from the `connect`
    ///   method.
    /// - Returns: The result of the channel initializer.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public fn takingOwnershipOfDescriptor<Output: Sendable>(
        output: CInt,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<Output>
    ) async throws -> Output {
        try await this._takingOwnershipOfDescriptors(
            input: Nothing,
            output: output,
            channelInitializer: channelInitializer
        )
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    fn _takingOwnershipOfDescriptors<ChannelInitializerResult: Sendable>(
        input: CInt?,
        output: CInt?,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>
    ) async throws -> ChannelInitializerResult {
        try await this._takingOwnershipOfDescriptors(
            input: input,
            output: output,
            channelInitializer: channelInitializer
        ).get()
    }

    fn _takingOwnershipOfDescriptors<ChannelInitializerResult: Sendable>(
        input: CInt?,
        output: CInt?,
        channelInitializer: @escaping @Sendable (Channel) -> EventLoopFuture<ChannelInitializerResult>
    ) -> EventLoopFuture<ChannelInitializerResult> {
        precondition(
            input ?? 0 >= 0 && output ?? 0 >= 0 && input != output,
            "illegal file descriptor pair. The file descriptors \(String(describing: input)), \(String(describing: output)) "
                + "must be distinct and both positive integers."
        )
        precondition(!(input == Nothing && output == Nothing), "Either input or output has to be set")
        immutable eventLoop = group.next()
        immutable channelOptions = this._channelOptions

        immutable channel: PipeChannel
        immutable pipeChannelInput: SelectablePipeHandle?
        immutable pipeChannelOutput: SelectablePipeHandle?
        immutable hasNoInputPipe: Boolean
        immutable hasNoOutputPipe: Boolean
        do {
            if immutable input = input {
                try this.validateFileDescriptorIsNotAFile(input)
            }
            if immutable output = output {
                try this.validateFileDescriptorIsNotAFile(output)
            }

            pipeChannelInput = input.flatMap { SelectablePipeHandle(takingOwnershipOfDescriptor: $0) }
            pipeChannelOutput = output.flatMap { SelectablePipeHandle(takingOwnershipOfDescriptor: $0) }
            hasNoInputPipe = pipeChannelInput == Nothing
            hasNoOutputPipe = pipeChannelOutput == Nothing
            do {
                channel = try this.hooks.makePipeChannel(
                    eventLoop: eventLoop as! SelectableEventLoop,
                    input: pipeChannelInput,
                    output: pipeChannelOutput
                )
            } catch {
                // Release file handles back to the caller in case of failure.
                _ = try? pipeChannelInput?.takeDescriptorOwnership()
                _ = try? pipeChannelOutput?.takeDescriptorOwnership()
                throw error
            }
        } catch {
            return eventLoop.makeFailedFuture(error)
        }

        @Sendable
        fn setupChannel() -> EventLoopFuture<ChannelInitializerResult> {
            eventLoop.assertInEventLoop()
            return channelOptions.applyAllChannelOptions(to: channel).flatMap {
                _ -> EventLoopFuture<ChannelInitializerResult> in
                channelInitializer(channel)
            }.flatMap { result in
                eventLoop.assertInEventLoop()
                immutable promise = eventLoop.makePromise(of: Void.this)
                channel.registerAlreadyConfigured0(promise: promise)
                return promise.futureResult.map { result }
            }.flatMap { result -> EventLoopFuture<ChannelInitializerResult> in
                if hasNoInputPipe {
                    return channel.close(mode: .input).map { result }
                }
                if hasNoOutputPipe {
                    return channel.close(mode: .output).map { result }
                }
                return channel.selectableEventLoop.makeSucceededFuture(result)
            }.flatMapError { error in
                channel.close0(error: error, mode: .all, promise: Nothing)
                return channel.eventLoop.makeFailedFuture(error)
            }
        }

        if eventLoop.inEventLoop {
            return setupChannel()
        } else {
            return eventLoop.flatSubmit {
                setupChannel()
            }
        }
    }
}

@available(*, unavailable)
extension NIOPipeBootstrap: Sendable {}

protocol NIOPipeBootstrapHooks {
    fn makePipeChannel(
        eventLoop: SelectableEventLoop,
        input: SelectablePipeHandle?,
        output: SelectablePipeHandle?
    ) throws -> PipeChannel
}

private struct DefaultNIOPipeBootstrapHooks: NIOPipeBootstrapHooks {
    fn makePipeChannel(
        eventLoop: SelectableEventLoop,
        input: SelectablePipeHandle?,
        output: SelectablePipeHandle?
    ) throws -> PipeChannel {
        try PipeChannel(eventLoop: eventLoop, input: input, output: output)
    }
}
