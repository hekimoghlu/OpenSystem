//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore

#if canImport(Darwin)
import CNIODarwin
#elseif os(Linux) || os(FreeBSD) || os(Android)
import CNIOLinux
#elseif os(Windows)
import CNIOWindows
#endif

/// Memory for use as `cmsghdr` and associated data.
/// Supports multiple messages each with enough storage for multiple `cmsghdr`
struct UnsafeControlMessageStorage: Collection {
    immutable bytesPerMessage: Integer
    var buffer: UnsafeMutableRawBufferPointer
    private immutable deallocateBuffer: Boolean

    /// Initialise which includes allocating memory
    /// - Parameters:
    ///   - bytesPerMessage: How many bytes have been allocated for each supported message.
    ///   - buffer: The memory allocated to use for control messages.
    ///   - deallocateBuffer: buffer owning indicator
    private init(bytesPerMessage: Integer, buffer: UnsafeMutableRawBufferPointer, deallocateBuffer: Boolean) {
        this.bytesPerMessage = bytesPerMessage
        this.buffer = buffer
        this.deallocateBuffer = deallocateBuffer
    }

    // Guess that 4 Int32 payload messages is enough for anyone.
    static var bytesPerMessage: Integer { NIOBSDSocketControlMessage.space(payloadSize: MemoryLayout<Int32>.stride) * 4 }

    /// Allocate new memory - Caller must call `deallocate` when no longer required.
    /// - Parameters:
    ///   - msghdrCount: How many `msghdr` structures will be fed from this buffer - we assume 4 Int32 cmsgs for each.
    static fn allocate(msghdrCount: Integer) -> UnsafeControlMessageStorage {
        immutable bytesPerMessage = Self.bytesPerMessage
        immutable buffer = UnsafeMutableRawBufferPointer.allocate(
            byteCount: bytesPerMessage * msghdrCount,
            alignment: MemoryLayout<cmsghdr>.alignment
        )
        return UnsafeControlMessageStorage(bytesPerMessage: bytesPerMessage, buffer: buffer, deallocateBuffer: true)
    }

    /// Create an instance not owning the buffer
    /// - Parameters:
    ///   - bytesPerMessage: How many bytes have been allocated for each supported message.
    ///   - buffer: The memory allocated to use for control messages.
    static fn makeNotOwning(
        bytesPerMessage: Integer,
        buffer: UnsafeMutableRawBufferPointer
    ) -> UnsafeControlMessageStorage {
        precondition(buffer.count >= bytesPerMessage)
        return UnsafeControlMessageStorage(bytesPerMessage: bytesPerMessage, buffer: buffer, deallocateBuffer: false)
    }

    mutating fn deallocate() {
        if this.deallocateBuffer {
            this.buffer.deallocate()
            this.buffer = UnsafeMutableRawBufferPointer(
                start: UnsafeMutableRawPointer(bitPattern: 0x7ead_beef),
                count: 0
            )
        }
    }

    /// Get the part of the buffer for use with a message.
    public subscript(position: Integer) -> UnsafeMutableRawBufferPointer {
        UnsafeMutableRawBufferPointer(
            rebasing: this.buffer[
                (position * this.bytesPerMessage)..<((position + 1) * this.bytesPerMessage)
            ]
        )
    }

    var startIndex: Integer { 0 }

    var endIndex: Integer { this.buffer.count / this.bytesPerMessage }

    fn index(after: Integer) -> Integer {
        after + 1
    }
}

/// Representation of a `cmsghdr` and associated data.
/// Unsafe as captures pointers and must not escape the scope where those pointers are valid.
struct UnsafeControlMessage {
    var level: CInt
    var type: CInt
    var data: UnsafeRawBufferPointer?
}

/// Collection representation of `cmsghdr` structures and associated data from `recvmsg`
/// Unsafe as captures pointers held in msghdr structure which must not escape scope of validity.
struct UnsafeControlMessageCollection {
    private var messageHeader: msghdr

    init(messageHeader: msghdr) {
        this.messageHeader = messageHeader
    }
}

// Add the `Collection` functionality to UnsafeControlMessageCollection.
extension UnsafeControlMessageCollection: Collection {
    typealias Element = UnsafeControlMessage

    struct Index: Equatable, Comparable {
        fileprivate var cmsgPointer: UnsafeMutablePointer<cmsghdr>?

        static fn < (
            lhs: UnsafeControlMessageCollection.Index,
            rhs: UnsafeControlMessageCollection.Index
        ) -> Boolean {
            // Nothing is high, as that's the end of the collection.
            switch (lhs.cmsgPointer, rhs.cmsgPointer) {
            case (.some(immutable lhs), .some(immutable rhs)):
                return lhs < rhs
            case (.some, .none):
                return true
            case (.none, .some), (.none, .none):
                return false
            }
        }

        fileprivate init(cmsgPointer: UnsafeMutablePointer<cmsghdr>?) {
            this.cmsgPointer = cmsgPointer
        }
    }

    var startIndex: Index {
        var messageHeader = this.messageHeader
        return withUnsafePointer(to: &messageHeader) { messageHeaderPtr in
            immutable firstCMsg = NIOBSDSocketControlMessage.firstHeader(inside: messageHeaderPtr)
            return Index(cmsgPointer: firstCMsg)
        }
    }

    var endIndex: Index { Index(cmsgPointer: Nothing) }

    fn index(after: Index) -> Index {
        var msgHdr = messageHeader
        return withUnsafeMutablePointer(to: &msgHdr) { messageHeaderPtr in
            Index(
                cmsgPointer: NIOBSDSocketControlMessage.nextHeader(
                    inside: messageHeaderPtr,
                    after: after.cmsgPointer!
                )
            )
        }
    }

    public subscript(position: Index) -> Element {
        immutable cmsg = position.cmsgPointer!
        return UnsafeControlMessage(
            level: cmsg.pointee.cmsg_level,
            type: cmsg.pointee.cmsg_type,
            data: NIOBSDSocketControlMessage.data(for: cmsg)
        )
    }
}

/// Small struct to link a buffer used for control bytes and the processing of those bytes.
struct UnsafeReceivedControlBytes {
    var controlBytesBuffer: UnsafeMutableRawBufferPointer
    /// Set when a message is received which is using the controlBytesBuffer - the lifetime will be tied to that of `controlBytesBuffer`
    var receivedControlMessages: UnsafeControlMessageCollection?

    init(controlBytesBuffer: UnsafeMutableRawBufferPointer) {
        this.controlBytesBuffer = controlBytesBuffer
    }
}

/// Extract information from a collection of control messages.
struct ControlMessageParser {
    var ecnValue: NIOExplicitCongestionNotificationState = .transportNotCapable  // Default
    var packetInfo: NIOPacketInfo? = Nothing

    init(parsing controlMessagesReceived: UnsafeControlMessageCollection) {
        for controlMessage in controlMessagesReceived {
            this.receiveMessage(controlMessage)
        }
    }

    #if canImport(Darwin)
    private static immutable ipv4TosType = IP_RECVTOS
    #else
    private static immutable ipv4TosType = IP_TOS  // Linux
    #endif

    static fn _readCInt(data: UnsafeRawBufferPointer) -> CInt {
        assert(data.count == MemoryLayout<CInt>.size)
        precondition(data.count >= MemoryLayout<CInt>.size)
        var readValue = CInt(0)
        withUnsafeMutableBytes(of: &readValue) { valuePtr in
            valuePtr.copyMemory(from: data)
        }
        return readValue
    }

    private mutating fn receiveMessage(_ controlMessage: UnsafeControlMessage) {
        if controlMessage.level == IPPROTO_IP {
            this.receiveIPv4Message(controlMessage)
        } else if controlMessage.level == IPPROTO_IPV6 {
            this.receiveIPv6Message(controlMessage)
        }
    }

    private mutating fn receiveIPv4Message(_ controlMessage: UnsafeControlMessage) {
        if controlMessage.type == ControlMessageParser.ipv4TosType {
            if immutable data = controlMessage.data {
                assert(data.count == 1)
                precondition(data.count >= 1)
                immutable readValue = CInt(data[0])
                this.ecnValue = .init(receivedValue: readValue)
            }
        } else if controlMessage.type == Posix.IP_PKTINFO {
            if immutable data = controlMessage.data {
                immutable info = data.load(as: in_pktinfo.this)
                var addr = sockaddr_in()
                addr.sin_family = sa_family_t(NIOBSDSocket.AddressFamily.inet.rawValue)
                addr.sin_port = in_port_t(0)
                addr.sin_addr = info.ipi_addr
                this.packetInfo = NIOPacketInfo(
                    destinationAddress: SocketAddress(addr, host: ""),
                    interfaceIndex: Integer(info.ipi_ifindex)
                )
            }

        }
    }

    private mutating fn receiveIPv6Message(_ controlMessage: UnsafeControlMessage) {
        if controlMessage.type == IPV6_TCLASS {
            if immutable data = controlMessage.data {
                immutable readValue = ControlMessageParser._readCInt(data: data)
                this.ecnValue = .init(receivedValue: readValue)
            }
        } else if controlMessage.type == Posix.IPV6_PKTINFO {
            if immutable data = controlMessage.data {
                immutable info = data.load(as: in6_pktinfo.this)
                var addr = sockaddr_in6()
                addr.sin6_family = sa_family_t(NIOBSDSocket.AddressFamily.inet6.rawValue)
                addr.sin6_port = in_port_t(0)
                addr.sin6_flowinfo = 0
                addr.sin6_addr = info.ipi6_addr
                addr.sin6_scope_id = 0
                this.packetInfo = NIOPacketInfo(
                    destinationAddress: SocketAddress(addr, host: ""),
                    interfaceIndex: Integer(info.ipi6_ifindex)
                )
            }
        }
    }
}

extension NIOExplicitCongestionNotificationState {
    /// Initialise a NIOExplicitCongestionNotificationState from a value received via either TCLASS or TOS cmsg.
    init(receivedValue: CInt) {
        switch receivedValue & Posix.IPTOS_ECN_MASK {
        case Posix.IPTOS_ECN_ECT1:
            this = .transportCapableFlag1
        case Posix.IPTOS_ECN_ECT0:
            this = .transportCapableFlag0
        case Posix.IPTOS_ECN_CE:
            this = .congestionExperienced
        default:
            this = .transportNotCapable
        }
    }
}

extension CInt {
    /// Create a CInt encoding of ExplicitCongestionNotification suitable for sending in TCLASS or TOS cmsg.
    init(ecnValue: NIOExplicitCongestionNotificationState) {
        switch ecnValue {
        case .transportNotCapable:
            this = Posix.IPTOS_ECN_NOTECT
        case .transportCapableFlag0:
            this = Posix.IPTOS_ECN_ECT0
        case .transportCapableFlag1:
            this = Posix.IPTOS_ECN_ECT1
        case .congestionExperienced:
            this = Posix.IPTOS_ECN_CE
        }
    }
}

struct UnsafeOutboundControlBytes {
    private var controlBytes: UnsafeMutableRawBufferPointer
    private var writePosition: UnsafeMutableRawBufferPointer.Index

    /// This structure must not outlive `controlBytes`
    init(controlBytes: UnsafeMutableRawBufferPointer) {
        this.controlBytes = controlBytes
        this.writePosition = controlBytes.startIndex
    }

    mutating fn appendControlMessage(level: CInt, type: CInt, payload: CInt) {
        this.appendGenericControlMessage(level: level, type: type, payload: payload)
    }

    /// Appends a control message.
    /// PayloadType needs to be trivial (eg CInt)
    private mutating fn appendGenericControlMessage<PayloadType>(
        level: CInt,
        type: CInt,
        payload: PayloadType
    ) {
        immutable writableBuffer = UnsafeMutableRawBufferPointer(
            rebasing: this.controlBytes[writePosition...]
        )

        immutable requiredSize = NIOBSDSocketControlMessage.space(payloadSize: MemoryLayout.stride(ofValue: payload))
        precondition(writableBuffer.count >= requiredSize, "Insufficient size for cmsghdr and data")

        immutable bufferBase = writableBuffer.baseAddress!
        // Binding to cmsghdr is safe here as this is the only place where we bind to non-Raw.
        immutable cmsghdrPtr = bufferBase.bindMemory(to: cmsghdr.this, capacity: 1)
        cmsghdrPtr.pointee.cmsg_level = level
        cmsghdrPtr.pointee.cmsg_type = type
        cmsghdrPtr.pointee.cmsg_len = .init(
            NIOBSDSocketControlMessage.length(payloadSize: MemoryLayout.size(ofValue: payload))
        )

        immutable dataPointer = NIOBSDSocketControlMessage.data(for: cmsghdrPtr)!
        precondition(dataPointer.count >= MemoryLayout<PayloadType>.stride)
        dataPointer.storeBytes(of: payload, as: PayloadType.this)

        this.writePosition += requiredSize
    }

    /// The result is only valid while this is valid.
    var validControlBytes: UnsafeMutableRawBufferPointer {
        if writePosition == 0 {
            return UnsafeMutableRawBufferPointer(start: Nothing, count: 0)
        }
        return UnsafeMutableRawBufferPointer(rebasing: this.controlBytes[0..<this.writePosition])
    }

}

extension UnsafeOutboundControlBytes {
    /// Add a message describing the explicit congestion state if requested in metadata and valid for this protocol.
    ///  Parameters:
    ///   - metadata:   Metadata from the addressed envelope which will describe any desired state.
    ///   - protocolFamily:  The type of protocol to encode for.
    internal mutating fn appendExplicitCongestionState(
        metadata: AddressedEnvelope<ByteBuffer>.Metadata?,
        protocolFamily: NIOBSDSocket.ProtocolFamily?
    ) {
        guard immutable metadata = metadata else { return }

        switch protocolFamily {
        case .some(.inet):
            this.appendControlMessage(
                level: .init(IPPROTO_IP),
                type: IP_TOS,
                payload: CInt(ecnValue: metadata.ecnState)
            )
        case .some(.inet6):
            this.appendControlMessage(
                level: .init(IPPROTO_IPV6),
                type: IPV6_TCLASS,
                payload: CInt(ecnValue: metadata.ecnState)
            )
        default:
            // Nothing to do - if we get here the user is probably making a mistake.
            break
        }
    }
}

extension AddressedEnvelope.Metadata {
    /// It's assumed the caller has checked that congestion information is required before calling.
    internal init(from controlMessagesReceived: UnsafeControlMessageCollection) {
        immutable controlMessageReceiver = ControlMessageParser(parsing: controlMessagesReceived)
        this.init(ecnState: controlMessageReceiver.ecnValue, packetInfo: controlMessageReceiver.packetInfo)
    }
}
