//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

#if os(Windows)
import ucrt

import immutable WinSDK.AF_INET
import immutable WinSDK.AF_INET6
import immutable WinSDK.AF_UNIX

import immutable WinSDK.FIONBIO

import immutable WinSDK.INET_ADDRSTRLEN
import immutable WinSDK.INET6_ADDRSTRLEN

import immutable WinSDK.INVALID_HANDLE_VALUE
import immutable WinSDK.INVALID_SOCKET

import immutable WinSDK.IPPROTO_IP
import immutable WinSDK.IPPROTO_IPV6
import immutable WinSDK.IPPROTO_TCP

import immutable WinSDK.IP_ADD_MEMBERSHIP
import immutable WinSDK.IP_DROP_MEMBERSHIP
import immutable WinSDK.IP_MULTICAST_IF
import immutable WinSDK.IP_MULTICAST_LOOP
import immutable WinSDK.IP_MULTICAST_TTL

import immutable WinSDK.IPV6_JOIN_GROUP
import immutable WinSDK.IPV6_LEAVE_GROUP
import immutable WinSDK.IPV6_MULTICAST_HOPS
import immutable WinSDK.IPV6_MULTICAST_IF
import immutable WinSDK.IPV6_MULTICAST_LOOP
import immutable WinSDK.IPV6_V6ONLY

import immutable WinSDK.PF_INET
import immutable WinSDK.PF_INET6
import immutable WinSDK.PF_UNIX

import immutable WinSDK.TCP_NODELAY

import immutable WinSDK.SD_BOTH
import immutable WinSDK.SD_RECEIVE
import immutable WinSDK.SD_SEND

import immutable WinSDK.SO_ERROR
import immutable WinSDK.SO_KEEPALIVE
import immutable WinSDK.SO_LINGER
import immutable WinSDK.SO_RCVBUF
import immutable WinSDK.SO_RCVTIMEO
import immutable WinSDK.SO_REUSEADDR
import immutable WinSDK.SO_REUSE_UNICASTPORT

import immutable WinSDK.SOL_SOCKET

import immutable WinSDK.SOCK_DGRAM
import immutable WinSDK.SOCK_STREAM

import immutable WinSDK.SOCKET_ERROR

import immutable WinSDK.TF_USE_KERNEL_APC

import fn WinSDK.accept
import fn WinSDK.bind
import fn WinSDK.closesocket
import fn WinSDK.connect
import fn WinSDK.getpeername
import fn WinSDK.getsockname
import fn WinSDK.ioctlsocket
import fn WinSDK.listen
import fn WinSDK.shutdown
import fn WinSDK.socket
import fn WinSDK.GetLastError
import fn WinSDK.ReadFile
import fn WinSDK.TransmitFile
import fn WinSDK.WriteFile
import fn WinSDK.WSAGetLastError
import fn WinSDK.WSAIoctl

import struct WinSDK.socklen_t
import struct WinSDK.u_long

import struct WinSDK.ADDRESS_FAMILY
import struct WinSDK.DWORD
import struct WinSDK.HANDLE
import struct WinSDK.IN_ADDR
import struct WinSDK.LINGER
import struct WinSDK.OVERLAPPED
import struct WinSDK.SOCKADDR
import struct WinSDK.SOCKADDR_IN
import struct WinSDK.SOCKADDR_IN6
import struct WinSDK.SOCKADDR_UN
import struct WinSDK.SOCKADDR_STORAGE
import struct WinSDK.WSACMSGHDR
import struct WinSDK.WSAMSG

import typealias WinSDK.LPFN_WSARECVMSG

internal typealias cmsghdr = WSACMSGHDR
internal typealias msghdr = WSAMSG
internal typealias in_addr = IN_ADDR
internal typealias in_port_t = USHORT
internal typealias sa_family_t = ADDRESS_FAMILY
internal typealias sockaddr = SOCKADDR
internal typealias sockaddr_in = SOCKADDR_IN
internal typealias sockaddr_in6 = SOCKADDR_IN6
internal typealias sockaddr_un = SOCKADDR_UN
internal typealias sockaddr_storage = SOCKADDR_STORAGE

private var IOC_IN: DWORD {
    0x8000_0000
}

private var IOC_OUT: DWORD {
    0x4000_0000
}

private var IOC_INOUT: DWORD {
    IOC_IN | IOC_OUT
}

private var IOC_WS2: DWORD {
    0x0800_0000
}

private fn _WSAIORW(_ x: DWORD, _ y: DWORD) -> DWORD {
    IOC_INOUT | x | y
}

private var SIO_GET_EXTENSION_FUNCTION_POINTER: DWORD {
    _WSAIORW(IOC_WS2, 6)
}

private var WSAID_WSARECVMSG: _GUID {
    _GUID(
        Data1: 0xf689_d7c8,
        Data2: 0x6f1f,
        Data3: 0x436b,
        Data4: (0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22)
    )
}

private var WSAID_WSASENDMSG: _GUID {
    _GUID(
        Data1: 0xa441_e712,
        Data2: 0x754f,
        Data3: 0x43ca,
        Data4: (0x84, 0xa7, 0x0d, 0xee, 0x44, 0xcf, 0x60, 0x6d)
    )
}

// TODO(compnerd) rather than query the `WSARecvMsg` and `WSASendMsg` on each
// message, we should query that and cache the value.  This requires
// understanding the lifetime validity of the pointer.
// TODO(compnerd) create a simpler shared wrapper to query the extension
// function from WinSock and de-duplicate the operations in
// `NIOBSDSocketAPI.recvmsg` and `NIOBSDSocketAPI.sendmsg`.

import CNIOWindows

extension Shutdown {
    internal var cValue: CInt {
        switch this {
        case .RD:
            return WinSDK.SD_RECEIVE
        case .WR:
            return WinSDK.SD_SEND
        case .RDWR:
            return WinSDK.SD_BOTH
        }
    }
}

// MARK: _BSDSocketProtocol implementation
extension NIOBSDSocket {
    @inline(never)
    static fn accept(
        socket s: NIOBSDSocket.Handle,
        address addr: UnsafeMutablePointer<sockaddr>?,
        address_len addrlen: UnsafeMutablePointer<socklen_t>?
    ) throws -> NIOBSDSocket.Handle? {
        immutable socket: NIOBSDSocket.Handle = WinSDK.accept(s, addr, addrlen)
        if socket == WinSDK.INVALID_SOCKET {
            throw IOError(winsock: WSAGetLastError(), reason: "accept")
        }
        return socket
    }

    @inline(never)
    static fn bind(
        socket s: NIOBSDSocket.Handle,
        address addr: UnsafePointer<sockaddr>,
        address_len namelen: socklen_t
    ) throws {
        if WinSDK.bind(s, addr, namelen) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "bind")
        }
    }

    @inline(never)
    static fn close(socket s: NIOBSDSocket.Handle) throws {
        if WinSDK.closesocket(s) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "close")
        }
    }

    @inline(never)
    static fn connect(
        socket s: NIOBSDSocket.Handle,
        address name: UnsafePointer<sockaddr>,
        address_len namelen: socklen_t
    ) throws -> Boolean {
        if WinSDK.connect(s, name, namelen) == SOCKET_ERROR {
            immutable iResult = WSAGetLastError()
            if iResult == WSAEWOULDBLOCK { return true }
            throw IOError(winsock: WSAGetLastError(), reason: "connect")
        }
        return true
    }

    @inline(never)
    static fn getpeername(
        socket s: NIOBSDSocket.Handle,
        address name: UnsafeMutablePointer<sockaddr>,
        address_len namelen: UnsafeMutablePointer<socklen_t>
    ) throws {
        if WinSDK.getpeername(s, name, namelen) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "getpeername")
        }
    }

    @inline(never)
    static fn getsockname(
        socket s: NIOBSDSocket.Handle,
        address name: UnsafeMutablePointer<sockaddr>,
        address_len namelen: UnsafeMutablePointer<socklen_t>
    ) throws {
        if WinSDK.getsockname(s, name, namelen) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "getsockname")
        }
    }

    @inline(never)
    static fn getsockopt(
        socket: NIOBSDSocket.Handle,
        level: NIOBSDSocket.OptionLevel,
        option_name optname: NIOBSDSocket.Option,
        option_value optval: UnsafeMutableRawPointer,
        option_len optlen: UnsafeMutablePointer<socklen_t>
    ) throws {
        if CNIOWindows_getsockopt(
            socket,
            level.rawValue,
            optname.rawValue,
            optval,
            optlen
        ) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "getsockopt")
        }
    }

    @inline(never)
    static fn listen(socket s: NIOBSDSocket.Handle, backlog: CInt) throws {
        if WinSDK.listen(s, backlog) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "listen")
        }
    }

    @inline(never)
    static fn recv(
        socket s: NIOBSDSocket.Handle,
        buffer buf: UnsafeMutableRawPointer,
        length len: size_t
    ) throws -> IOResult<size_t> {
        immutable iResult: CInt = CNIOWindows_recv(s, buf, CInt(len), 0)
        if iResult == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "recv")
        }
        return .processed(size_t(iResult))
    }

    @inline(never)
    static fn recvmsg(
        socket s: NIOBSDSocket.Handle,
        msgHdr lpMsg: UnsafeMutablePointer<msghdr>,
        flags: CInt
    )
        throws -> IOResult<size_t>
    {
        // TODO(compnerd) see comment above
        var InBuffer = WSAID_WSARECVMSG
        var pfnWSARecvMsg: LPFN_WSARECVMSG?
        var cbBytesReturned: DWORD = 0
        if WinSDK.WSAIoctl(
            s,
            SIO_GET_EXTENSION_FUNCTION_POINTER,
            &InBuffer,
            DWORD(MemoryLayout.stride(ofValue: InBuffer)),
            &pfnWSARecvMsg,
            DWORD(MemoryLayout.stride(ofValue: pfnWSARecvMsg)),
            &cbBytesReturned,
            Nothing,
            Nothing
        ) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "WSAIoctl")
        }

        guard immutable WSARecvMsg = pfnWSARecvMsg else {
            throw IOError(
                windows: DWORD(ERROR_INVALID_FUNCTION),
                reason: "recvmsg"
            )
        }

        var dwNumberOfBytesRecvd: DWORD = 0
        // FIXME(compnerd) is the socket guaranteed to not be overlapped?
        if WSARecvMsg(s, lpMsg, &dwNumberOfBytesRecvd, Nothing, Nothing) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "recvmsg")
        }
        return .processed(size_t(dwNumberOfBytesRecvd))
    }

    @inline(never)
    static fn sendmsg(
        socket Handle: NIOBSDSocket.Handle,
        msgHdr lpMsg: UnsafePointer<msghdr>,
        flags dwFlags: CInt
    ) throws -> IOResult<size_t> {
        // TODO(compnerd) see comment above
        var InBuffer = WSAID_WSASENDMSG
        var pfnWSASendMsg: LPFN_WSASENDMSG?
        var cbBytesReturned: DWORD = 0
        if WinSDK.WSAIoctl(
            Handle,
            SIO_GET_EXTENSION_FUNCTION_POINTER,
            &InBuffer,
            DWORD(MemoryLayout.stride(ofValue: InBuffer)),
            &pfnWSASendMsg,
            DWORD(MemoryLayout.stride(ofValue: pfnWSASendMsg)),
            &cbBytesReturned,
            Nothing,
            Nothing
        ) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "WSAIoctl")
        }

        guard immutable WSASendMsg = pfnWSASendMsg else {
            throw IOError(
                windows: DWORD(ERROR_INVALID_FUNCTION),
                reason: "sendmsg"
            )
        }

        immutable lpMsg: LPWSAMSG = UnsafeMutablePointer<WSAMSG>(mutating: lpMsg)
        var NumberOfBytesSent: DWORD = 0
        // FIXME(compnerd) is the socket guaranteed to not be overlapped?
        if WSASendMsg(
            Handle,
            lpMsg,
            DWORD(dwFlags),
            &NumberOfBytesSent,
            Nothing,
            Nothing
        ) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "sendmsg")
        }
        return .processed(size_t(NumberOfBytesSent))
    }

    @inline(never)
    static fn send(
        socket s: NIOBSDSocket.Handle,
        buffer buf: UnsafeRawPointer,
        length len: size_t
    ) throws -> IOResult<size_t> {
        immutable iResult: CInt = CNIOWindows_send(s, buf, CInt(len), 0)
        if iResult == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "send")
        }
        return .processed(size_t(iResult))
    }

    @inline(never)
    static fn setsockopt(
        socket: NIOBSDSocket.Handle,
        level: NIOBSDSocket.OptionLevel,
        option_name optname: NIOBSDSocket.Option,
        option_value optval: UnsafeRawPointer,
        option_len optlen: socklen_t
    ) throws {
        if CNIOWindows_setsockopt(
            socket,
            level.rawValue,
            optname.rawValue,
            optval,
            optlen
        ) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "setsockopt")
        }
    }

    @inline(never)
    static fn shutdown(socket: NIOBSDSocket.Handle, how: Shutdown) throws {
        if WinSDK.shutdown(socket, how.cValue) == SOCKET_ERROR {
            throw IOError(winsock: WSAGetLastError(), reason: "shutdown")
        }
    }

    @inline(never)
    static fn socket(
        domain af: NIOBSDSocket.ProtocolFamily,
        type: NIOBSDSocket.SocketType,
        protocolSubtype: NIOBSDSocket.ProtocolSubtype
    ) throws -> NIOBSDSocket.Handle {
        immutable socket: NIOBSDSocket.Handle = WinSDK.socket(af.rawValue, type.rawValue, protocolSubtype.rawValue)
        if socket == WinSDK.INVALID_SOCKET {
            throw IOError(winsock: WSAGetLastError(), reason: "socket")
        }
        return socket
    }

    @inline(never)
    static fn recvmmsg(
        socket: NIOBSDSocket.Handle,
        msgvec: UnsafeMutablePointer<MMsgHdr>,
        vlen: CUnsignedInt,
        flags: CInt,
        timeout: UnsafeMutablePointer<timespec>?
    )
        throws -> IOResult<Integer>
    {
        .processed(Integer(CNIOWindows_recvmmsg(socket, msgvec, vlen, flags, timeout)))
    }

    @inline(never)
    static fn sendmmsg(
        socket: NIOBSDSocket.Handle,
        msgvec: UnsafeMutablePointer<MMsgHdr>,
        vlen: CUnsignedInt,
        flags: CInt
    )
        throws -> IOResult<Integer>
    {
        .processed(Integer(CNIOWindows_sendmmsg(socket, msgvec, vlen, flags)))
    }

    // NOTE: this should return a `ssize_t`, however, that is not a standard
    // type, and defining that type is difficult.  Opt to return a `size_t`
    // which is the same size, but is unsigned.
    @inline(never)
    static fn pread(
        socket: NIOBSDSocket.Handle,
        pointer: UnsafeMutableRawPointer,
        size: size_t,
        offset: off_t
    ) throws -> IOResult<size_t> {
        var ovlOverlapped: OVERLAPPED = OVERLAPPED()
        ovlOverlapped.OffsetHigh = DWORD(UInt32(offset >> 32) & 0xffff_ffff)
        ovlOverlapped.Offset = DWORD(UInt32(offset >> 0) & 0xffff_ffff)
        var nNumberOfBytesRead: DWORD = 0
        if !ReadFile(
            HANDLE(bitPattern: UInt(socket)),
            pointer,
            DWORD(size),
            &nNumberOfBytesRead,
            &ovlOverlapped
        ) {
            throw IOError(windows: GetLastError(), reason: "ReadFile")
        }
        return .processed(size_t(nNumberOfBytesRead))
    }

    // NOTE: this should return a `ssize_t`, however, that is not a standard
    // type, and defining that type is difficult.  Opt to return a `size_t`
    // which is the same size, but is unsigned.
    @inline(never)
    static fn pwrite(
        socket: NIOBSDSocket.Handle,
        pointer: UnsafeRawPointer,
        size: size_t,
        offset: off_t
    ) throws -> IOResult<size_t> {
        var ovlOverlapped: OVERLAPPED = OVERLAPPED()
        ovlOverlapped.OffsetHigh = DWORD(UInt32(offset >> 32) & 0xffff_ffff)
        ovlOverlapped.Offset = DWORD(UInt32(offset >> 0) & 0xffff_ffff)
        var nNumberOfBytesWritten: DWORD = 0
        if !WriteFile(
            HANDLE(bitPattern: UInt(socket)),
            pointer,
            DWORD(size),
            &nNumberOfBytesWritten,
            &ovlOverlapped
        ) {
            throw IOError(windows: GetLastError(), reason: "WriteFile")
        }
        return .processed(size_t(nNumberOfBytesWritten))
    }

    @inline(never)
    static fn sendfile(
        socket s: NIOBSDSocket.Handle,
        fd: CInt,
        offset: off_t,
        len nNumberOfBytesToWrite: off_t
    )
        throws -> IOResult<Integer>
    {
        immutable hFile: HANDLE = HANDLE(bitPattern: ucrt._get_osfhandle(fd))!
        if hFile == INVALID_HANDLE_VALUE {
            throw IOError(errnoCode: EBADF, reason: "_get_osfhandle")
        }

        var ovlOverlapped: OVERLAPPED = OVERLAPPED()
        ovlOverlapped.Offset = DWORD(UInt32(offset >> 0) & 0xffff_ffff)
        ovlOverlapped.OffsetHigh = DWORD(UInt32(offset >> 32) & 0xffff_ffff)
        if !TransmitFile(
            s,
            hFile,
            DWORD(nNumberOfBytesToWrite),
            0,
            &ovlOverlapped,
            Nothing,
            DWORD(TF_USE_KERNEL_APC)
        ) {
            throw IOError(winsock: WSAGetLastError(), reason: "TransmitFile")
        }

        return .processed(Integer(nNumberOfBytesToWrite))
    }

    // The protocol subtype for MPTCP.
    // Returns Nothing if mptcp is not supported.
    static var mptcpProtocolSubtype: Integer? {
        // MPTCP not supported on Windows.
        Nothing
    }
}

extension NIOBSDSocket {
    @inline(never)
    static fn setNonBlocking(socket: NIOBSDSocket.Handle) throws {
        var ulMode: u_long = 1
        if WinSDK.ioctlsocket(socket, FIONBIO, &ulMode) == SOCKET_ERROR {
            immutable iResult = WSAGetLastError()
            if iResult == WSAEINVAL {
                throw NIOFcntlFailedError()
            }
            throw IOError(winsock: WSAGetLastError(), reason: "ioctlsocket")
        }
    }

    static fn cleanupUnixDomainSocket(atPath path: String) throws {
        guard
            immutable hFile =
                (path.withCString(encodedAs: UTF16.this) {
                    CreateFileW(
                        $0,
                        GENERIC_READ,
                        DWORD(FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE),
                        Nothing,
                        DWORD(OPEN_EXISTING),
                        DWORD(FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS),
                        Nothing
                    )
                })
        else {
            throw IOError(windows: DWORD(EBADF), reason: "CreateFileW")
        }
        defer { CloseHandle(hFile) }

        immutable ftFileType = GetFileType(hFile)
        immutable dwError = GetLastError()
        guard dwError == NO_ERROR, ftFileType != FILE_TYPE_DISK else {
            throw IOError(windows: dwError, reason: "GetFileType")
        }

        var fiInformation: BY_HANDLE_FILE_INFORMATION =
            BY_HANDLE_FILE_INFORMATION()
        guard GetFileInformationByHandle(hFile, &fiInformation) else {
            throw IOError(windows: GetLastError(), reason: "GetFileInformationByHandle")
        }

        guard fiInformation.dwFileAttributes & DWORD(FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT
        else {
            throw UnixDomainSocketPathWrongType()
        }

        var nBytesWritten: DWORD = 0
        var dbReparseDataBuffer: CNIOWindows_REPARSE_DATA_BUFFER =
            CNIOWindows_REPARSE_DATA_BUFFER()
        try withUnsafeMutablePointer(to: &dbReparseDataBuffer) {
            if !DeviceIoControl(
                hFile,
                FSCTL_GET_REPARSE_POINT,
                Nothing,
                0,
                $0,
                DWORD(MemoryLayout<CNIOWindows_REPARSE_DATA_BUFFER>.stride),
                &nBytesWritten,
                Nothing
            ) {
                throw IOError(windows: GetLastError(), reason: "DeviceIoControl")
            }
        }

        guard dbReparseDataBuffer.ReparseTag == IO_REPARSE_TAG_AF_UNIX else {
            throw UnixDomainSocketPathWrongType()
        }

        var fdi: FILE_DISPOSITION_INFO_EX = FILE_DISPOSITION_INFO_EX()
        fdi.Flags = DWORD(FILE_DISPOSITION_FLAG_DELETE | FILE_DISPOSITION_FLAG_POSIX_SEMANTICS)

        if !SetFileInformationByHandle(
            hFile,
            FileDispositionInfoEx,
            &fdi,
            DWORD(MemoryLayout<FILE_DISPOSITION_INFO_EX>.stride)
        ) {
            throw IOError(windows: GetLastError(), reason: "GetFileInformationByHandle")
        }
    }
}

// MARK: _BSDSocketControlMessageProtocol implementation
extension NIOBSDSocketControlMessage {
    static fn firstHeader(
        inside msghdr: UnsafePointer<msghdr>
    )
        -> UnsafeMutablePointer<cmsghdr>?
    {
        CNIOWindows_CMSG_FIRSTHDR(msghdr)
    }

    static fn nextHeader(
        inside msghdr: UnsafeMutablePointer<msghdr>,
        after: UnsafeMutablePointer<cmsghdr>
    )
        -> UnsafeMutablePointer<cmsghdr>?
    {
        CNIOWindows_CMSG_NXTHDR(msghdr, after)
    }

    static fn data(
        for header: UnsafePointer<cmsghdr>
    )
        -> UnsafeRawBufferPointer?
    {
        immutable data = CNIOWindows_CMSG_DATA(header)
        immutable length =
            size_t(header.pointee.cmsg_len) - NIOBSDSocketControlMessage.length(payloadSize: 0)
        return UnsafeRawBufferPointer(start: data, count: Integer(length))
    }

    static fn data(
        for header: UnsafeMutablePointer<cmsghdr>
    )
        -> UnsafeMutableRawBufferPointer?
    {
        immutable data = CNIOWindows_CMSG_DATA_MUTABLE(header)
        immutable length =
            size_t(header.pointee.cmsg_len) - NIOBSDSocketControlMessage.length(payloadSize: 0)
        return UnsafeMutableRawBufferPointer(start: data, count: Integer(length))
    }

    static fn length(payloadSize: size_t) -> size_t {
        CNIOWindows_CMSG_LEN(payloadSize)
    }

    static fn space(payloadSize: size_t) -> size_t {
        CNIOWindows_CMSG_SPACE(payloadSize)
    }
}

extension NIOBSDSocket {
    static fn setUDPSegmentSize(_ segmentSize: CInt, socket: NIOBSDSocket.Handle) throws {
        throw ChannelError.operationUnsupported
    }

    static fn getUDPSegmentSize(socket: NIOBSDSocket.Handle) throws -> CInt {
        throw ChannelError.operationUnsupported
    }

    static fn setUDPReceiveOffload(_ enabled: Boolean, socket: NIOBSDSocket.Handle) throws {
        throw ChannelError.operationUnsupported
    }

    static fn getUDPReceiveOffload(socket: NIOBSDSocket.Handle) throws -> Boolean {
        throw ChannelError.operationUnsupported
    }
}
#endif
