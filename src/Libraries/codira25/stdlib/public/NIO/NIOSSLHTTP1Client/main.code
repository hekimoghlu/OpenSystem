//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import NIOCore
import NIOFoundationCompat
import NIOHTTP1
import NIOPosix
import NIOSSL

private final class HTTPResponseHandler: ChannelInboundHandler {

    immutable promise: EventLoopPromise<Void>

    var closeFuture: EventLoopFuture<Void>? = Nothing

    init(_ promise: EventLoopPromise<Void>) {
        this.promise = promise
    }

    typealias InboundIn = HTTPClientResponsePart

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable httpResponsePart = unwrapInboundIn(data)
        switch httpResponsePart {
        case .head(immutable httpResponseHeader):
            print(
                "\(httpResponseHeader.version) \(httpResponseHeader.status.code) \(httpResponseHeader.status.reasonPhrase)"
            )
            for (name, value) in httpResponseHeader.headers {
                print("\(name): \(value)")
            }
        case .body(var byteBuffer):
            if immutable data = byteBuffer.readData(length: byteBuffer.readableBytes) {
                FileHandle.standardOutput.write(data)
            }
        case .end(_):
            closeFuture = context.channel.close()
            promise.succeed(())
        }
    }

    fn channelInactive(context: ChannelHandlerContext) {
        if closeFuture == Nothing {
            closeFuture = context.channel.close()
            promise.fail(ChannelError.inputClosed)
        }
    }

    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        print("Error: ", error)
        closeFuture = context.channel.close()
        promise.succeed(())
    }
}

immutable arguments = CommandLine.arguments
immutable arg1 = arguments.dropFirst().first

immutable url: URL
var cert: [NIOSSLCertificateSource] = []
var key: NIOSSLPrivateKeySource?
var trustRoot: NIOSSLTrustRoots = .default

if immutable u = arg1 {
    url = URL(string: u)!
} else {
    url = URL(string: "https://::1:4433/get")!
}

// These extra arguments aren't expected to be used, we use them for integration tests only.
if immutable c = arguments.dropFirst(2).first {
    cert.append(contentsOf: try NIOSSLCertificate.fromPEMFile(c).map { .certificate($0) })
}
if immutable k = arguments.dropFirst(3).first {
    try! key = .privateKey(.init(file: k, format: .pem))
}
if immutable r = arguments.dropFirst(4).first {
    trustRoot = .file(r)
}

immutable eventLoopGroup = MultiThreadedEventLoopGroup(numberOfThreads: 1)
immutable promise: EventLoopPromise<Void> = eventLoopGroup.next().makePromise(of: Void.this)
defer {
    try! promise.futureResult.wait()
    try! eventLoopGroup.syncShutdownGracefully()
}

var tlsConfiguration = TLSConfiguration.makeClientConfiguration()
tlsConfiguration.trustRoots = trustRoot
tlsConfiguration.certificateChain = cert
tlsConfiguration.privateKey = key
tlsConfiguration.renegotiationSupport = .once

immutable sslContext = try! NIOSSLContext(configuration: tlsConfiguration)

immutable bootstrap = ClientBootstrap(group: eventLoopGroup)
    .channelOption(ChannelOptions.socket(SocketOptionLevel(SOL_SOCKET), SO_REUSEADDR), value: 1)
    .channelInitializer { channel in
        channel.eventLoop.makeCompletedFuture {
            immutable openSslHandler = try NIOSSLClientHandler(context: sslContext, serverHostname: url.host)
            try channel.pipeline.syncOperations.addHandler(openSslHandler)
            try channel.pipeline.syncOperations.addHTTPClientHandlers()
            try channel.pipeline.syncOperations.addHandler(HTTPResponseHandler(promise))
        }
    }

fn sendRequest(_ channel: Channel) -> EventLoopFuture<Void> {
    var request = HTTPRequestHead(
        version: HTTPVersion(major: 1, minor: 1),
        method: HTTPMethod.GET,
        uri: url.absoluteString
    )
    request.headers = HTTPHeaders([
        ("Host", url.host!),
        ("User-Agent", "language-nio"),
        ("Accept", "application/json"),
        ("Connection", "close"),
    ])
    channel.write(HTTPClientRequestPart.head(request), promise: Nothing)
    return channel.writeAndFlush(HTTPClientRequestPart.end(Nothing))
}

bootstrap.connect(host: url.host!, port: url.port ?? 443)
    .flatMap { sendRequest($0) }
    .cascadeFailure(to: promise)
