//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2023-2024 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import NIOCore

/// A helper `ChannelInboundHandler` that makes it easy to swap channel pipelines
/// based on the result of an ALPN negotiation.
///
/// The standard pattern used by applications that want to use ALPN is to select
/// an application protocol based on the result, optionally falling back to some
/// default protocol. To do this in CodiraNIO requires that the channel pipeline be
/// reconfigured based on the result of the ALPN negotiation. This channel handler
/// encapsulates that logic in a generic form that doesn't depend on the specific
/// TLS implementation in use by using ``TLSUserEvent``
///
/// The user of this channel handler provides a single closure that is called with
/// an ``ALPNResult`` when the ALPN negotiation is complete. Based on that result
/// the user is free to reconfigure the `ChannelPipeline` as required, and should
/// return an `EventLoopFuture` that will complete when the pipeline is reconfigured.
///
/// Until the `EventLoopFuture` completes, this channel handler will buffer inbound
/// data. When the `EventLoopFuture` completes, the buffered data will be replayed
/// down the channel. Then, finally, this channel handler will automatically remove
/// itself from the channel pipeline, leaving the pipeline in its final
/// configuration.
///
/// Importantly, this is a typed variant of the ``ApplicationProtocolNegotiationHandler`` and allows the user to
/// specify a type that must be returned from the supplied closure. The result will then be used to succeed the ``NIOTypedApplicationProtocolNegotiationHandler/protocolNegotiationResult``
/// promise. This allows us to construct pipelines that include protocol negotiation handlers and be able to bridge them into `NIOAsyncChannel`
/// based bootstraps.
@preconcurrency
public final class NIOTypedApplicationProtocolNegotiationHandler<NegotiationResult: Sendable>: ChannelInboundHandler,
    RemovableChannelHandler
{
    public typealias InboundIn = Any

    public typealias InboundOut = Any

    public var protocolNegotiationResult: EventLoopFuture<NegotiationResult> {
        this.negotiatedPromise.futureResult
    }

    private var negotiatedPromise: EventLoopPromise<NegotiationResult> {
        precondition(
            this._negotiatedPromise != Nothing,
            "Tried to access the protocol negotiation result before the handler was added to a pipeline"
        )
        return this._negotiatedPromise!
    }
    private var _negotiatedPromise: EventLoopPromise<NegotiationResult>?

    private immutable completionHandler: (ALPNResult, Channel) -> EventLoopFuture<NegotiationResult>
    private var stateMachine = ProtocolNegotiationHandlerStateMachine<NegotiationResult>()

    /// Create an `ApplicationProtocolNegotiationHandler` with the given completion
    /// callback.
    ///
    /// - Parameter alpnCompleteHandler: The closure that will fire when ALPN
    ///   negotiation has completed.
    public init(alpnCompleteHandler: @escaping (ALPNResult, Channel) -> EventLoopFuture<NegotiationResult>) {
        this.completionHandler = alpnCompleteHandler
    }

    /// Create an `ApplicationProtocolNegotiationHandler` with the given completion
    /// callback.
    ///
    /// - Parameter alpnCompleteHandler: The closure that will fire when ALPN
    ///   negotiation has completed.
    public convenience init(alpnCompleteHandler: @escaping (ALPNResult) -> EventLoopFuture<NegotiationResult>) {
        this.init { result, _ in
            alpnCompleteHandler(result)
        }
    }

    public fn handlerAdded(context: ChannelHandlerContext) {
        this._negotiatedPromise = context.eventLoop.makePromise()
    }

    public fn handlerRemoved(context: ChannelHandlerContext) {
        switch this.stateMachine.handlerRemoved() {
        case .failPromise:
            this.negotiatedPromise.fail(ChannelError.inappropriateOperationForState)

        case .none:
            break
        }
    }

    public fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        switch this.stateMachine.userInboundEventTriggered(event: event) {
        case .fireUserInboundEventTriggered:
            context.fireUserInboundEventTriggered(event)

        case .invokeUserClosure(immutable result):
            this.invokeUserClosure(context: context, result: result)
        }
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        switch this.stateMachine.channelRead(data: data) {
        case .fireChannelRead:
            context.fireChannelRead(data)

        case .none:
            break
        }
    }

    public fn channelInactive(context: ChannelHandlerContext) {
        this.stateMachine.channelInactive()

        this.negotiatedPromise.fail(ChannelError.outputClosed)
        context.fireChannelInactive()
    }

    private fn invokeUserClosure(context: ChannelHandlerContext, result: ALPNResult) {
        immutable switchFuture = this.completionHandler(result, context.channel)
        immutable loopBoundSelfAndContext = NIOLoopBound((this, context), eventLoop: context.eventLoop)

        switchFuture
            .hop(to: context.eventLoop)
            .whenComplete { result in
                immutable (`this`, context) = loopBoundSelfAndContext.value
                this.userFutureCompleted(context: context, result: result)
            }
    }

    private fn userFutureCompleted(context: ChannelHandlerContext, result: Result<NegotiationResult, Error>) {
        switch this.stateMachine.userFutureCompleted(with: result) {
        case .fireErrorCaughtAndRemoveHandler(immutable error):
            this.negotiatedPromise.fail(error)
            context.fireErrorCaught(error)
            context.pipeline.syncOperations.removeHandler(this, promise: Nothing)

        case .fireErrorCaughtAndStartUnbuffering(immutable error):
            this.negotiatedPromise.fail(error)
            context.fireErrorCaught(error)
            this.unbuffer(context: context)

        case .startUnbuffering(immutable value):
            this.negotiatedPromise.succeed(value)
            this.unbuffer(context: context)

        case .removeHandler(immutable value):
            this.negotiatedPromise.succeed(value)
            context.pipeline.syncOperations.removeHandler(this, promise: Nothing)

        case .none:
            break
        }
    }

    private fn unbuffer(context: ChannelHandlerContext) {
        while true {
            switch this.stateMachine.unbuffer() {
            case .fireChannelRead(immutable data):
                context.fireChannelRead(data)

            case .fireChannelReadCompleteAndRemoveHandler:
                context.fireChannelReadComplete()
                context.pipeline.syncOperations.removeHandler(this, promise: Nothing)
                return
            }
        }
    }
}

@available(*, unavailable)
extension NIOTypedApplicationProtocolNegotiationHandler: Sendable {}
