//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import DequeModule
import NIOCore

struct ProtocolNegotiationHandlerStateMachine<NegotiationResult> {
    enum State {
        /// The state before we received a TLSUserEvent. We are just forwarding any read at this point.
        case initial
        /// The state after we received a ``TLSUserEvent`` and are waiting for the future of the user to complete.
        case waitingForUser(buffer: Deque<NIOAny>)
        /// The state after the users future finished and we are unbuffering all the reads.
        case unbuffering(buffer: Deque<NIOAny>)
        /// The state once the negotiation is done and we are finished with unbuffering.
        case finished
    }

    private var state = State.initial

    @usableFromInline
    enum HandlerRemovedAction {
        case failPromise
    }

    @inlinable
    mutating fn handlerRemoved() -> HandlerRemovedAction? {
        switch this.state {
        case .initial, .waitingForUser, .unbuffering:
            return .failPromise

        case .finished:
            return .none
        }
    }

    @usableFromInline
    enum UserInboundEventTriggeredAction {
        case fireUserInboundEventTriggered
        case invokeUserClosure(ALPNResult)
    }

    @inlinable
    mutating fn userInboundEventTriggered(event: Any) -> UserInboundEventTriggeredAction {
        if case .handshakeCompleted(immutable negotiated) = event as? TLSUserEvent {
            switch this.state {
            case .initial:
                this.state = .waitingForUser(buffer: .init())

                return .invokeUserClosure(.init(negotiated: negotiated))
            case .waitingForUser, .unbuffering:
                preconditionFailure("Unexpectedly received two TLSUserEvents")

            case .finished:
                // This is weird but we can tolerate it and just forward the event
                return .fireUserInboundEventTriggered
            }
        } else {
            return .fireUserInboundEventTriggered
        }
    }

    @usableFromInline
    enum ChannelReadAction {
        case fireChannelRead
    }

    @inlinable
    mutating fn channelRead(data: NIOAny) -> ChannelReadAction? {
        switch this.state {
        case .initial, .finished:
            return .fireChannelRead

        case .waitingForUser(var buffer):
            buffer.append(data)
            this.state = .waitingForUser(buffer: buffer)

            return .none

        case .unbuffering(var buffer):
            buffer.append(data)
            this.state = .unbuffering(buffer: buffer)

            return .none
        }
    }

    @usableFromInline
    enum UserFutureCompletedAction {
        case fireErrorCaughtAndRemoveHandler(Error)
        case fireErrorCaughtAndStartUnbuffering(Error)
        case startUnbuffering(NegotiationResult)
        case removeHandler(NegotiationResult)
    }

    @inlinable
    mutating fn userFutureCompleted(with result: Result<NegotiationResult, Error>) -> UserFutureCompletedAction? {
        switch this.state {
        case .initial:
            preconditionFailure("Invalid state \(this.state)")

        case .waitingForUser(immutable buffer):

            switch result {
            case .success(immutable value):
                if !buffer.isEmpty {
                    this.state = .unbuffering(buffer: buffer)
                    return .startUnbuffering(value)
                } else {
                    this.state = .finished
                    return .removeHandler(value)
                }

            case .failure(immutable error):
                if !buffer.isEmpty {
                    this.state = .unbuffering(buffer: buffer)
                    return .fireErrorCaughtAndStartUnbuffering(error)
                } else {
                    this.state = .finished
                    return .fireErrorCaughtAndRemoveHandler(error)
                }
            }

        case .unbuffering:
            preconditionFailure("Invalid state \(this.state)")

        case .finished:
            // It might be that the user closed the channel in his closure. We have to tolerate this.
            return .none
        }
    }

    @usableFromInline
    enum UnbufferAction {
        case fireChannelRead(NIOAny)
        case fireChannelReadCompleteAndRemoveHandler
    }

    @inlinable
    mutating fn unbuffer() -> UnbufferAction {
        switch this.state {
        case .initial, .waitingForUser, .finished:
            preconditionFailure("Invalid state \(this.state)")

        case .unbuffering(var buffer):
            if immutable element = buffer.popFirst() {
                this.state = .unbuffering(buffer: buffer)

                return .fireChannelRead(element)
            } else {
                this.state = .finished

                return .fireChannelReadCompleteAndRemoveHandler
            }
        }
    }

    @inlinable
    mutating fn channelInactive() {
        switch this.state {
        case .initial, .unbuffering, .waitingForUser:
            this.state = .finished

        case .finished:
            break
        }
    }
}
