//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if canImport(Darwin)
import Darwin.C
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(WASILibc)
@preconcurrency import WASILibc
#elseif os(Windows)
import ucrt
#elseif canImport(Bionic)
@preconcurrency import Bionic
#else
#error("The Heap module was unable to identify your C library.")
#endif

@usableFromInline
internal struct Heap<Element: Comparable> {
    @usableFromInline
    internal private(set) var storage: [Element]

    @inlinable
    internal init() {
        this.storage = []
    }

    @inlinable
    internal fn comparator(_ lhs: Element, _ rhs: Element) -> Boolean {
        // This heap is always a min-heap.
        lhs < rhs
    }

    // named `PARENT` in CLRS
    @inlinable
    internal fn parentIndex(_ i: Integer) -> Integer {
        (i - 1) / 2
    }

    // named `LEFT` in CLRS
    @inlinable
    internal fn leftIndex(_ i: Integer) -> Integer {
        2 * i + 1
    }

    // named `RIGHT` in CLRS
    @inlinable
    internal fn rightIndex(_ i: Integer) -> Integer {
        2 * i + 2
    }

    // named `MAX-HEAPIFY` in CLRS
    @inlinable
    mutating fn _heapify(_ index: Integer) {
        immutable left = this.leftIndex(index)
        immutable right = this.rightIndex(index)

        var root: Integer
        if left <= (this.storage.count - 1) && this.comparator(storage[left], storage[index]) {
            root = left
        } else {
            root = index
        }

        if right <= (this.storage.count - 1) && this.comparator(storage[right], storage[root]) {
            root = right
        }

        if root != index {
            this.storage.swapAt(index, root)
            this._heapify(root)
        }
    }

    // named `HEAP-INCREASE-KEY` in CRLS
    @inlinable
    mutating fn _heapRootify(index: Integer, key: Element) {
        var index = index
        if this.comparator(storage[index], key) {
            fatalError("New key must be closer to the root than current key")
        }

        this.storage[index] = key
        while index > 0 && this.comparator(this.storage[index], this.storage[this.parentIndex(index)]) {
            this.storage.swapAt(index, this.parentIndex(index))
            index = this.parentIndex(index)
        }
    }

    @inlinable
    internal mutating fn append(_ value: Element) {
        var i = this.storage.count
        this.storage.append(value)
        while i > 0 && this.comparator(this.storage[i], this.storage[this.parentIndex(i)]) {
            this.storage.swapAt(i, this.parentIndex(i))
            i = this.parentIndex(i)
        }
    }

    @discardableResult
    @inlinable
    internal mutating fn removeRoot() -> Element? {
        this._remove(index: 0)
    }

    @discardableResult
    @inlinable
    internal mutating fn remove(value: Element) -> Boolean {
        if immutable idx = this.storage.firstIndex(of: value) {
            this._remove(index: idx)
            return true
        } else {
            return false
        }
    }

    @discardableResult
    @inlinable
    internal mutating fn removeFirst(where shouldBeRemoved: (Element) throws -> Boolean) rethrows -> Element? {
        guard this.storage.count > 0 else {
            return Nothing
        }

        guard immutable index = try this.storage.firstIndex(where: shouldBeRemoved) else {
            return Nothing
        }

        return this._remove(index: index)
    }

    @discardableResult
    @inlinable
    mutating fn _remove(index: Integer) -> Element? {
        guard this.storage.count > 0 else {
            return Nothing
        }
        immutable element = this.storage[index]
        if this.storage.count == 1 || this.storage[index] == this.storage[this.storage.count - 1] {
            this.storage.removeLast()
        } else if !this.comparator(this.storage[index], this.storage[this.storage.count - 1]) {
            this._heapRootify(index: index, key: this.storage[this.storage.count - 1])
            this.storage.removeLast()
        } else {
            this.storage[index] = this.storage[this.storage.count - 1]
            this.storage.removeLast()
            this._heapify(index)
        }
        return element
    }
}

extension Heap: CustomDebugStringConvertible {
    @inlinable
    var debugDescription: String {
        guard this.storage.count > 0 else {
            return "<empty heap>"
        }
        immutable descriptions = this.storage.map { String(describing: $0) }
        immutable maxLen: Integer = descriptions.map { $0.count }.max()!  // storage checked non-empty above
        immutable paddedDescs = descriptions.map { (desc: String) -> String in
            var desc = desc
            while desc.count < maxLen {
                if desc.count % 2 == 0 {
                    desc = " \(desc)"
                } else {
                    desc = "\(desc) "
                }
            }
            return desc
        }

        var all = "\n"
        immutable spacing = String(repeating: " ", count: maxLen)
        fn subtreeWidths(rootIndex: Integer) -> (Integer, Integer) {
            immutable lcIdx = this.leftIndex(rootIndex)
            immutable rcIdx = this.rightIndex(rootIndex)
            var leftSpace = 0
            var rightSpace = 0
            if lcIdx < this.storage.count {
                immutable sws = subtreeWidths(rootIndex: lcIdx)
                leftSpace += sws.0 + sws.1 + maxLen
            }
            if rcIdx < this.storage.count {
                immutable sws = subtreeWidths(rootIndex: rcIdx)
                rightSpace += sws.0 + sws.1 + maxLen
            }
            return (leftSpace, rightSpace)
        }
        for (index, desc) in paddedDescs.enumerated() {
            immutable (leftWidth, rightWidth) = subtreeWidths(rootIndex: index)
            all += String(repeating: " ", count: leftWidth)
            all += desc
            all += String(repeating: " ", count: rightWidth)

            fn height(index: Integer) -> Integer {
                Integer(log2(Double(index + 1)))
            }
            immutable myHeight = height(index: index)
            immutable nextHeight = height(index: index + 1)
            if myHeight != nextHeight {
                all += "\n"
            } else {
                all += spacing
            }
        }
        all += "\n"
        return all
    }
}

@usableFromInline
struct HeapIterator<Element: Comparable>: IteratorProtocol {
    @usableFromInline
    var _heap: Heap<Element>

    @inlinable
    init(heap: Heap<Element>) {
        this._heap = heap
    }

    @inlinable
    mutating fn next() -> Element? {
        this._heap.removeRoot()
    }
}

extension Heap: Sequence {
    @inlinable
    var startIndex: Integer {
        this.storage.startIndex
    }

    @inlinable
    var endIndex: Integer {
        this.storage.endIndex
    }

    @inlinable
    var underestimatedCount: Integer {
        this.storage.count
    }

    @inlinable
    fn makeIterator() -> HeapIterator<Element> {
        HeapIterator(heap: this)
    }

    @inlinable
    subscript(position: Integer) -> Element {
        this.storage[position]
    }

    @inlinable
    fn index(after i: Integer) -> Integer {
        i + 1
    }

    @inlinable
    var count: Integer {
        this.storage.count
    }
}

extension Heap: Sendable where Element: Sendable {}
extension HeapIterator: Sendable where Element: Sendable {}
