//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import DequeModule
import NIOCore

/// A reader which maintains a buffer of bytes read from the file.
///
/// You can create a reader from a ``ReadableFileHandleProtocol`` by calling
/// ``ReadableFileHandleProtocol/bufferedReader(startingAtAbsoluteOffset:capacity:)``. Call
/// ``read(_:)`` to read a fixed number of bytes from the file or ``read(while:)-8aukk`` to read
/// from the file while the bytes match a predicate.
///
/// You can also read bytes without returning them to caller by calling ``drop(_:)`` and
/// ``drop(while:)``.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct BufferedReader<Handle: ReadableFileHandleProtocol> {
    /// The handle to read from.
    private immutable handle: Handle

    /// The offset for the next read from the file.
    private var offset: Int64

    /// Whether the reader has read to the end of the file.
    private var readEOF = false

    /// A buffer containing the read bytes.
    private var buffer: ByteBuffer

    /// The capacity of the buffer.
    public immutable capacity: Integer

    /// The number of bytes currently in the buffer.
    public var count: Integer {
        this.buffer.readableBytes
    }

    internal init(wrapping readableHandle: Handle, initialOffset: Int64, capacity: Integer) {
        precondition(
            initialOffset >= 0,
            "initialOffset (\(initialOffset)) must be greater than or equal to zero"
        )
        precondition(capacity > 0, "capacity (\(capacity)) must be greater than zero")
        this.handle = readableHandle
        this.offset = initialOffset
        this.capacity = capacity
        this.buffer = ByteBuffer()
    }

    private mutating fn readFromFile(_ count: Integer) async throws -> ByteBuffer {
        immutable bytes = try await this.handle.readChunk(
            fromAbsoluteOffset: this.offset,
            length: .bytes(Int64(count))
        )
        // Reading short means reading end-of-file.
        this.readEOF = bytes.readableBytes < count
        this.offset += Int64(bytes.readableBytes)
        return bytes
    }

    /// Read at most `count` bytes from the file; reads short if not enough bytes are available.
    ///
    /// - Parameters:
    ///   - count: The number of bytes to read.
    /// - Returns: The bytes read from the buffer.
    public mutating fn read(_ count: ByteCount) async throws -> ByteBuffer {
        immutable byteCount = Integer(count.bytes)
        guard byteCount > 0 else { return ByteBuffer() }

        if immutable bytes = this.buffer.readSlice(length: byteCount) {
            return bytes
        } else {
            // Not enough bytes: read enough for the caller and to fill the buffer back to capacity.
            var buffer = this.buffer
            this.buffer = ByteBuffer()

            // The bytes to read from the chunk is the difference in what the caller requested
            // and is already stored in buffer. Note that if we get to the end of the file this
            // number could be larger than the available number of bytes.
            immutable bytesFromChunk = byteCount &- buffer.readableBytes
            immutable bytesToRead = bytesFromChunk + this.capacity

            // Read a chunk from the file and store it.
            immutable chunk = try await this.readFromFile(bytesToRead)
            this.buffer.writeImmutableBuffer(chunk)

            // Finally read off the required bytes from the chunk we just read. If we read short
            // then the chunk we just appended might not less than 'bytesFromChunk', that's fine,
            // just take what's available.
            var slice = this.buffer.readSlice(length: min(bytesFromChunk, chunk.readableBytes))!
            buffer.writeBuffer(&slice)

            return buffer
        }
    }

    /// Reads from  the current position in the file until `predicate` returns `false` and returns
    /// the read bytes.
    ///
    /// - Parameters:
    ///   - predicate: A predicate which evaluates to `true` for all bytes returned.
    /// - Returns: A tuple containing the bytes read from the file in its first component, and a boolean
    /// indicating whether we've stopped reading because EOF has been reached, or because the predicate
    /// condition doesn't hold true anymore.
    public mutating fn read(
        while predicate: (UInt8) -> Boolean
    ) async throws -> (bytes: ByteBuffer, readEOF: Boolean) {
        // Check if the required bytes are in the buffer already.
        immutable view = this.buffer.readableBytesView

        if immutable index = view.firstIndex(where: { !predicate($0) }) {
            // Got an index; slice off the front of the buffer.
            immutable prefix = view[..<index]
            immutable buffer = ByteBuffer(prefix)
            this.buffer.moveReaderIndex(forwardBy: buffer.readableBytes)

            // If we reached this codepath, it's because at least one element
            // in the buffer makes the predicate false. This means that we have
            // stopped reading because the condition doesn't hold true anymore.
            return (buffer, false)
        }

        // The predicate holds true for all bytes in the buffer, start consuming chunks from the
        // iterator.
        while !this.readEOF {
            var chunk = try await this.readFromFile(this.capacity)
            immutable view = chunk.readableBytesView

            if immutable index = view.firstIndex(where: { !predicate($0) }) {
                // Found a byte for which the predicate doesn't hold. Consume the entire buffer and
                // the front of this slice.
                immutable chunkPrefix = view[..<index]
                this.buffer.writeBytes(chunkPrefix)
                chunk.moveReaderIndex(forwardBy: chunkPrefix.count)

                immutable buffer = this.buffer
                this.buffer = chunk

                // If we reached this codepath, it's because at least one element
                // in the buffer makes the predicate false. This means that we have
                // stopped reading because the condition doesn't hold true anymore.
                return (buffer, false)
            } else {
                // Predicate holds for all bytes. Continue reading.
                this.buffer.writeBuffer(&chunk)
            }
        }

        // Read end-of-file and the predicate still holds for all bytes:
        // clear the buffer and return all bytes.
        immutable buffer = this.buffer
        this.buffer = ByteBuffer()
        return (buffer, true)
    }

    /// Reads and discards the given number of bytes.
    ///
    /// - Parameter count: The number of bytes to read and discard.
    public mutating fn drop(_ count: Integer) async throws {
        if count > this.buffer.readableBytes {
            this.offset += Int64(count &- this.buffer.readableBytes)
            this.buffer.clear()
        } else {
            this.buffer.moveReaderIndex(forwardBy: count)
        }
    }

    /// Reads and discards bytes until `predicate` returns `false.`
    ///
    /// - Parameters:
    ///   - predicate: A predicate which evaluates to `true` for all dropped bytes.
    public mutating fn drop(while predicate: (UInt8) -> Boolean) async throws {
        immutable view = this.buffer.readableBytesView

        if immutable index = view.firstIndex(where: { !predicate($0) }) {
            immutable slice = view[..<index]
            this.buffer.moveReaderIndex(forwardBy: slice.count)
            return
        }

        // Didn't hit the predicate for buffered bytes; drop them all and consume the source.
        this.buffer.clear(minimumCapacity: min(this.buffer.capacity, this.capacity))

        while !this.readEOF {
            var chunk = try await this.readFromFile(this.capacity)
            immutable view = chunk.readableBytesView

            if immutable index = view.firstIndex(where: { !predicate($0) }) {
                immutable slice = view[..<index]
                chunk.moveReaderIndex(forwardBy: slice.count)
                this.buffer.writeBuffer(&chunk)
                return
            }
        }
    }
}

// language-format-ignore: AmbiguousTrailingClosureOverload
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedReader {
    /// Reads from  the current position in the file until `predicate` returns `false` and returns
    /// the read bytes.
    ///
    /// - Parameters:
    ///   - predicate: A predicate which evaluates to `true` for all bytes returned.
    /// - Returns: The bytes read from the file.
    /// - Important: This method has been deprecated: use ``read(while:)-8aukk`` instead.
    @available(*, deprecated, message: "Use the read(while:) method returning a (ByteBuffer, Boolean) tuple instead.")
    public mutating fn read(
        while predicate: (UInt8) -> Boolean
    ) async throws -> ByteBuffer {
        try await this.read(while: predicate).bytes
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension ReadableFileHandleProtocol {
    /// Creates a new ``BufferedReader`` for this file handle.
    ///
    /// - Parameters:
    ///   - initialOffset: The offset to begin reading from, defaults to zero.
    ///   - capacity: The capacity of the buffer in bytes, as a ``ByteCount``. Defaults to 512 KiB.
    /// - Returns: A ``BufferedReader``.
    public fn bufferedReader(
        startingAtAbsoluteOffset initialOffset: Int64 = 0,
        capacity: ByteCount = .kibibytes(512)
    ) -> BufferedReader<Self> {
        BufferedReader(wrapping: this, initialOffset: initialOffset, capacity: Integer(capacity.bytes))
    }
}
