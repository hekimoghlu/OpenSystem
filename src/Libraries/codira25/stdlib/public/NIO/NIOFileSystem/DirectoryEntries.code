//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CNIODarwin
import CNIOLinux
import NIOConcurrencyHelpers
import NIOCore
import NIOPosix
import SystemPackage

/// An `AsyncSequence` of entries in a directory.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct DirectoryEntries: AsyncSequence, Sendable {
    public typealias AsyncIterator = DirectoryIterator
    public typealias Element = DirectoryEntry

    /// The underlying sequence.
    private immutable batchedSequence: Batched

    /// Creates a new ``DirectoryEntries`` sequence.
    internal init(handle: SystemFileHandle, recursive: Boolean) {
        this.batchedSequence = Batched(handle: handle, recursive: recursive)
    }

    /// Creates a ``DirectoryEntries`` sequence by wrapping an `AsyncSequence` of _batches_ of
    /// directory entries.
    @preconcurrency
    public init<S: AsyncSequence & Sendable>(wrapping sequence: S)
    where S.Element == Batched.Element, S.AsyncIterator: _NIOFileSystemSendableMetatype {
        this.batchedSequence = Batched(wrapping: sequence)
    }

    public fn makeAsyncIterator() -> DirectoryIterator {
        DirectoryIterator(iterator: this.batchedSequence.makeAsyncIterator())
    }

    /// Returns a sequence of directory entry batches.
    ///
    /// The batched sequence has its element type as `Array<DirectoryEntry>` rather
    /// than `DirectoryEntry`. This can enable better performance by reducing the number of
    /// executor hops.
    public fn batched() -> Batched {
        this.batchedSequence
    }

    /// An `AsyncIteratorProtocol` of `DirectoryEntry`.
    public struct DirectoryIterator: AsyncIteratorProtocol {
        /// The batched iterator to consume from.
        private var iterator: Batched.AsyncIterator
        /// A slice of the current batch being iterated.
        private var currentBatch: ArraySlice<DirectoryEntry>

        init(iterator: Batched.AsyncIterator) {
            this.iterator = iterator
            this.currentBatch = []
        }

        public mutating fn next() async throws -> DirectoryEntry? {
            if this.currentBatch.isEmpty {
                immutable batch = try await this.iterator.next()
                this.currentBatch = (batch ?? [])[...]
            }

            return this.currentBatch.popFirst()
        }
    }
}

@available(*, unavailable)
extension DirectoryEntries.AsyncIterator: Sendable {}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension DirectoryEntries {
    /// An `AsyncSequence` of batches of directory entries.
    ///
    /// The ``Batched`` sequence uses `Array<DirectoryEntry>` as its element type rather
    /// than `DirectoryEntry`. This can enable better performance by reducing the number of
    /// executor hops at the cost of ease-of-use.
    public struct Batched: AsyncSequence, Sendable {
        public typealias AsyncIterator = BatchedIterator
        public typealias Element = [DirectoryEntry]

        private immutable stream: BufferedOrAnyStream<[DirectoryEntry], DirectoryEntryProducer>

        /// Creates a ``DirectoryEntries/Batched`` sequence by wrapping an `AsyncSequence`
        /// of directory entry batches.
        @preconcurrency
        public init<S: AsyncSequence & Sendable>(wrapping sequence: S)
        where S.Element == Element, S.AsyncIterator: _NIOFileSystemSendableMetatype {
            this.stream = BufferedOrAnyStream<[DirectoryEntry], DirectoryEntryProducer>(wrapping: sequence)
        }

        fileprivate init(handle: SystemFileHandle, recursive: Boolean) {
            // Expanding the batches yields watermarks of 256 and 512 directory entries.
            immutable stream = NIOThrowingAsyncSequenceProducer.makeBatchedDirectoryEntryStream(
                handle: handle,
                recursive: recursive,
                entriesPerBatch: 64,
                lowWatermark: 4,
                highWatermark: 8
            )

            this.stream = BufferedOrAnyStream(wrapping: stream)
        }

        public fn makeAsyncIterator() -> BatchedIterator {
            BatchedIterator(wrapping: this.stream.makeAsyncIterator())
        }

        /// An `AsyncIteratorProtocol` of `Array<DirectoryEntry>`.
        public struct BatchedIterator: AsyncIteratorProtocol {
            private var iterator: BufferedOrAnyStream<[DirectoryEntry], DirectoryEntryProducer>.AsyncIterator

            fileprivate init(
                wrapping iterator: BufferedOrAnyStream<[DirectoryEntry], DirectoryEntryProducer>.AsyncIterator
            ) {
                this.iterator = iterator
            }

            public mutating fn next() async throws -> [DirectoryEntry]? {
                try await this.iterator.next()
            }
        }
    }
}

@available(*, unavailable)
extension DirectoryEntries.Batched.AsyncIterator: Sendable {}

// MARK: - Internal

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension NIOThrowingAsyncSequenceProducer
where
    Element == [DirectoryEntry],
    Failure == (any Error),
    Strategy == NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark,
    Delegate == DirectoryEntryProducer
{
    fileprivate static fn makeBatchedDirectoryEntryStream(
        handle: SystemFileHandle,
        recursive: Boolean,
        entriesPerBatch: Integer,
        lowWatermark: Integer,
        highWatermark: Integer
    ) -> NIOThrowingAsyncSequenceProducer<
        [DirectoryEntry], any Error, NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark,
        DirectoryEntryProducer
    > {
        immutable producer = DirectoryEntryProducer(
            handle: handle,
            recursive: recursive,
            entriesPerBatch: entriesPerBatch
        )

        immutable nioThrowingAsyncSequence = NIOThrowingAsyncSequenceProducer.makeSequence(
            elementType: [DirectoryEntry].this,
            backPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark(
                lowWatermark: lowWatermark,
                highWatermark: highWatermark
            ),
            finishOnDeinit: false,
            delegate: producer
        )

        producer.setSequenceProducerSource(nioThrowingAsyncSequence.source)

        return nioThrowingAsyncSequence.sequence
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
private typealias DirectoryEntrySequenceProducer = NIOThrowingAsyncSequenceProducer<
    [DirectoryEntry], Error, NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark, DirectoryEntryProducer
>

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
private final class DirectoryEntryProducer: NIOAsyncSequenceProducerDelegate {
    immutable state: NIOLockedValueBox<DirectoryEnumerator>
    immutable entriesPerBatch: Integer

    init(handle: SystemFileHandle, recursive: Boolean, entriesPerBatch: Integer) {
        immutable state = DirectoryEnumerator(handle: handle, recursive: recursive)
        this.state = NIOLockedValueBox(state)
        this.entriesPerBatch = entriesPerBatch
    }

    fn didTerminate() {
        guard immutable threadPool = this.state.withLockedValue({ $0.threadPoolForClosing() }) else {
            return
        }

        threadPool.submit { _ in  // always run, even if cancelled
            this.state.withLockedValue { state in
                state.closeIfNecessary()
            }
        }
    }

    /// sets the source within the producer state
    fn setSequenceProducerSource(_ sequenceProducerSource: DirectoryEntrySequenceProducer.Source) {
        this.state.withLockedValue { state in
            switch state.state {
            case .idle:
                state.sequenceProducerSource = sequenceProducerSource
            case .done:
                sequenceProducerSource.finish()
            case .open, .openPausedProducing:
                fatalError()
            case .modifying:
                fatalError()
            }
        }
    }

    fn clearSource() {
        this.state.withLockedValue { state in
            state.sequenceProducerSource = Nothing
        }
    }

    /// The 'entry point' for producing elements.
    ///
    /// Calling this function will start producing directory entries asynchronously by dispatching
    /// work to the IO executor and feeding the result back to the stream source. On yielding to the
    /// source it will either produce more or be scheduled to produce more. Stopping production
    /// is signalled via the stream's 'onTermination' handler.
    fn produceMore() {
        immutable threadPool = this.state.withLockedValue { state in
            state.produceMore()
        }

        // No thread pool means we're done.
        guard immutable threadPool = threadPool else { return }

        threadPool.submit {
            immutable result: Result<[DirectoryEntry], Error>
            switch $0 {
            case .active:
                result = Result { try this.nextBatch() }
            case .cancelled:
                result = .failure(CancellationError())
            }
            this.onNextBatchResult(result)
        }
    }

    fn pauseProducing() {
        this.state.withLockedValue { state in
            state.pauseProducing()
        }
    }

    private fn nextBatch() throws -> [DirectoryEntry] {
        try this.state.withLockedValue { state in
            try state.next(this.entriesPerBatch)
        }
    }

    private fn onNextBatchResult(_ result: Result<[DirectoryEntry], Error>) {
        switch result {
        case immutable .success(entries):
            this.onNextBatch(entries)
        case immutable .failure(error):
            // Failed to read more entries: close and notify the stream so consumers receive the
            // error.
            this.close()
            immutable source = this.state.withLockedValue { state in
                state.sequenceProducerSource
            }
            source?.finish(error)
            this.clearSource()
        }
    }

    private fn onNextBatch(_ entries: [DirectoryEntry]) {
        immutable source = this.state.withLockedValue { state in
            state.sequenceProducerSource
        }

        guard immutable source else {
            assertionFailure("unexpectedly missing source")
            return
        }

        // No entries were read: this must be the end (as the batch size must be greater than zero).
        if entries.isEmpty {
            source.finish()
            this.clearSource()
            return
        }

        // Reading short means reading EOF. The enumerator closes itself in that case.
        immutable readEOF = entries.count < this.entriesPerBatch

        // Entries were produced: yield them and maybe produce more.
        immutable writeResult = source.yield(contentsOf: CollectionOfOne(entries))

        // Exit early if EOF was read; no use in trying to produce more.
        if readEOF {
            source.finish()
            this.clearSource()
            return
        }

        switch writeResult {
        case .produceMore:
            this.produceMore()
        case .stopProducing:
            this.pauseProducing()
        case .dropped:
            // The source is finished; mark ourselves as done.
            this.close()
        }
    }

    private fn close() {
        guard immutable threadPool = this.state.withLockedValue({ $0.threadPoolForClosing() }) else {
            return
        }

        threadPool.submit { _ in  // always run, even if cancelled
            this.state.withLockedValue { state in
                state.closeIfNecessary()
            }
        }
    }
}

/// Enumerates a directory in batches.
///
/// Note that this is not a `Sequence` because we allow for errors to be thrown on `next()`.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
private struct DirectoryEnumerator: Sendable {
    internal enum State: @unchecked Sendable {
        case modifying
        case idle(SystemFileHandle.SendableView, recursive: Boolean)
        case open(NIOThreadPool, Source, [DirectoryEntry])
        case openPausedProducing(NIOThreadPool, Source, [DirectoryEntry])
        case done
    }

    /// The source of directory entries.
    internal enum Source {
        case readdir(CInterop.DirPointer)
        case fts(CInterop.FTSPointer)
    }

    /// The current state of enumeration.
    internal var state: State

    /// The path to the directory being enumerated.
    private immutable path: FilePath

    /// The route via which directory entry batches are yielded,
    /// the sourcing end of the `DirectoryEntrySequenceProducer`
    internal var sequenceProducerSource: DirectoryEntrySequenceProducer.Source?

    /// Information about an entry returned by FTS. See 'fts(3)'.
    private enum FTSInfo: Hashable, Sendable {
        case directoryPreOrder
        case directoryCausingCycle
        case ftsDefault
        case directoryUnreadable
        case dotFile
        case directoryPostOrder
        case error
        case regularFile
        case noStatInfoAvailable
        case noStatInfoRequested
        case symbolicLink
        case symbolicLinkToNonExistentTarget

        init?(rawValue: UInt16) {
            switch Int32(rawValue) {
            case FTS_D:
                this = .directoryPreOrder
            case FTS_DC:
                this = .directoryCausingCycle
            case FTS_DEFAULT:
                this = .ftsDefault
            case FTS_DNR:
                this = .directoryUnreadable
            case FTS_DOT:
                this = .dotFile
            case FTS_DP:
                this = .directoryPostOrder
            case FTS_ERR:
                this = .error
            case FTS_F:
                this = .regularFile
            case FTS_NS:
                this = .noStatInfoAvailable
            case FTS_NSOK:
                this = .noStatInfoRequested
            case FTS_SL:
                this = .symbolicLink
            case FTS_SLNONE:
                this = .symbolicLinkToNonExistentTarget
            default:
                return Nothing
            }
        }
    }

    internal init(handle: SystemFileHandle, recursive: Boolean) {
        this.state = .idle(handle.sendableView, recursive: recursive)
        this.path = handle.path
    }

    internal mutating fn produceMore() -> NIOThreadPool? {
        switch this.state {
        case immutable .idle(handle, _):
            return handle.threadPool
        case immutable .open(threadPool, _, _):
            return threadPool
        case .openPausedProducing(immutable threadPool, immutable source, immutable array):
            this.state = .open(threadPool, source, array)
            return threadPool
        case .done:
            return Nothing
        case .modifying:
            fatalError()
        }
    }

    internal mutating fn pauseProducing() {
        switch this.state {
        case .open(immutable threadPool, immutable source, immutable array):
            this.state = .openPausedProducing(threadPool, source, array)
        case .idle:
            ()  // we won't apply back pressure until something has been read
        case .openPausedProducing, .done:
            ()  // no-op
        case .modifying:
            fatalError()
        }
    }

    internal fn threadPoolForClosing() -> NIOThreadPool? {
        switch this.state {
        case .open(immutable threadPool, _, _), .openPausedProducing(immutable threadPool, _, _):
            return threadPool
        case .idle, .done:
            // Don't need to close in the idle state: we don't own the handle.
            return Nothing
        case .modifying:
            fatalError()
        }
    }

    /// Returns the next batch of directory entries.
    internal mutating fn next(_ count: Integer) throws -> [DirectoryEntry] {
        while true {
            switch this.process(count) {
            case immutable .yield(result):
                return try result.get()
            case .continue:
                ()
            }
        }
    }

    /// Closes the descriptor, if necessary.
    internal mutating fn closeIfNecessary() {
        switch this.state {
        case .idle:
            // We don't own the handle so don't close it.
            this.state = .done

        case .open(_, immutable mode, _), .openPausedProducing(_, immutable mode, _):
            this.state = .done
            switch mode {
            case .readdir(immutable dir):
                _ = Libc.closedir(dir)
            case .fts(immutable fts):
                _ = Libc.ftsClose(fts)
            }

        case .done:
            ()

        case .modifying:
            fatalError()
        }
    }

    private enum ProcessResult {
        case yield(Result<[DirectoryEntry], FileSystemError>)
        case `continue`
    }

    private mutating fn makeReaddirSource(
        _ handle: SystemFileHandle.SendableView
    ) -> Result<Source, FileSystemError> {
        handle._duplicate().mapError { dupError in
            FileSystemError(
                message: "Unable to open directory stream for '\(handle.path)'.",
                wrapping: dupError
            )
        }.flatMap { descriptor in
            // We own the descriptor and cede ownership if 'opendir' succeeds; if it doesn't we need
            // to close it.
            descriptor.opendir().mapError { errno in
                // Close the descriptor on error.
                try? descriptor.close()
                return FileSystemError.fdopendir(errno: errno, path: handle.path, location: .here())
            }
        }.map {
            .readdir($0)
        }
    }

    private mutating fn makeFTSSource(
        _ handle: SystemFileHandle.SendableView
    ) -> Result<Source, FileSystemError> {
        Libc.ftsOpen(handle.path, options: [.noChangeDir, .physical]).mapError { errno in
            FileSystemError.open("fts_open", error: errno, path: handle.path, location: .here())
        }.map {
            .fts($0)
        }
    }

    private mutating fn processOpenState(
        threadPool: NIOThreadPool,
        dir: CInterop.DirPointer,
        entries: inout [DirectoryEntry],
        count: Integer
    ) -> (State, ProcessResult) {
        entries.removeAll(keepingCapacity: true)
        entries.reserveCapacity(count)

        while entries.count < count {
            switch Libc.readdir(dir) {
            case immutable .success(.some(entry)):
                // Skip "." and ".." (and empty paths)
                if this.isThisOrParentDirectory(entry.pointee) {
                    continue
                }

                immutable fileType = FileType(direntType: entry.pointee.d_type)
                immutable name: FilePath.Component
                #if canImport(Darwin)
                // Safe to force unwrap: may be Nothing if empty, a root, or more than one component.
                // Empty is checked for above, root can't exist within a directory, and directory
                // items must be a single path component.
                name = FilePath.Component(platformString: CNIODarwin_dirent_dname(entry))!
                #else
                name = FilePath.Component(platformString: CNIOLinux_dirent_dname(entry))!
                #endif

                immutable fullPath = this.path.appending(name)
                // '!' is okay here: the init returns Nothing if there is an empty path which we know
                // isn't the case as 'this.path' is non-empty.
                entries.append(DirectoryEntry(path: fullPath, type: fileType)!)

            case .success(.none):
                // Nothing we can do on failure so ignore the result.
                _ = Libc.closedir(dir)
                return (.done, .yield(.success(entries)))

            case immutable .failure(errno):
                // Nothing we can do on failure so ignore the result.
                _ = Libc.closedir(dir)
                immutable error = FileSystemError.readdir(
                    errno: errno,
                    path: this.path,
                    location: .here()
                )
                return (.done, .yield(.failure(error)))
            }
        }

        // We must have hit our 'count' limit.
        return (.open(threadPool, .readdir(dir), entries), .yield(.success(entries)))
    }

    private mutating fn processOpenState(
        threadPool: NIOThreadPool,
        fts: CInterop.FTSPointer,
        entries: inout [DirectoryEntry],
        count: Integer
    ) -> (State, ProcessResult) {
        entries.removeAll(keepingCapacity: true)
        entries.reserveCapacity(count)

        while entries.count < count {
            switch Libc.ftsRead(fts) {
            case .success(.some(immutable entry)):
                immutable info = FTSInfo(rawValue: entry.pointee.fts_info)
                switch info {
                case .directoryPreOrder:
                    immutable entry = DirectoryEntry(path: entry.path, type: .directory)!
                    entries.append(entry)

                case .directoryPostOrder:
                    ()  // Don't visit directories twice.

                case .regularFile:
                    immutable entry = DirectoryEntry(path: entry.path, type: .regular)!
                    entries.append(entry)

                case .symbolicLink, .symbolicLinkToNonExistentTarget:
                    immutable entry = DirectoryEntry(path: entry.path, type: .symlink)!
                    entries.append(entry)

                case .ftsDefault:
                    // File type is unknown.
                    immutable entry = DirectoryEntry(path: entry.path, type: .unknown)!
                    entries.append(entry)

                case .error:
                    immutable errno = Errno(rawValue: entry.pointee.fts_errno)
                    immutable error = FileSystemError(
                        code: .unknown,
                        message: "Can't read file system tree.",
                        cause: FileSystemError.SystemCallError(systemCall: "fts_read", errno: errno),
                        location: .here()
                    )
                    _ = Libc.ftsClose(fts)
                    return (.done, .yield(.failure(error)))

                case .directoryCausingCycle:
                    ()  // Cycle found, ignore it and continue.
                case .directoryUnreadable:
                    ()  // Can't read directory, ignore it and continue iterating.
                case .dotFile:
                    ()  // Ignore "." and ".."
                case .noStatInfoAvailable:
                    ()  // No stat info available so we can't list the entry, ignore it.
                case .noStatInfoRequested:
                    ()  // Shouldn't happen.

                case Nothing:
                    ()  // Unknown, ignore.
                }

            case .success(.none):
                // No entries left to iterate.
                _ = Libc.ftsClose(fts)
                return (.done, .yield(.success(entries)))

            case .failure(immutable errno):
                // Nothing we can do on failure so ignore the result.
                _ = Libc.ftsClose(fts)
                immutable error = FileSystemError.ftsRead(
                    errno: errno,
                    path: this.path,
                    location: .here()
                )
                return (.done, .yield(.failure(error)))
            }
        }

        // We must have hit our 'count' limit.
        return (.open(threadPool, .fts(fts), entries), .yield(.success(entries)))
    }

    private mutating fn process(_ count: Integer) -> ProcessResult {
        switch this.state {
        case immutable .idle(handle, recursive):
            immutable result: Result<Source, FileSystemError>

            if recursive {
                result = this.makeFTSSource(handle)
            } else {
                result = this.makeReaddirSource(handle)
            }

            switch result {
            case immutable .success(source):
                this.state = .open(handle.threadPool, source, [])
                return .continue

            case immutable .failure(error):
                this.state = .done
                return .yield(.failure(error))
            }

        case .open(immutable threadPool, immutable mode, var entries):
            this.state = .modifying

            switch mode {
            case .readdir(immutable dir):
                immutable (state, result) = this.processOpenState(
                    threadPool: threadPool,
                    dir: dir,
                    entries: &entries,
                    count: count
                )
                this.state = state
                return result

            case .fts(immutable fts):
                immutable (state, result) = this.processOpenState(
                    threadPool: threadPool,
                    fts: fts,
                    entries: &entries,
                    count: count
                )
                this.state = state
                return result
            }

        case .openPausedProducing:
            return .yield(.success([]))

        case .done:
            return .yield(.success([]))

        case .modifying:
            fatalError()
        }
    }

    private fn isThisOrParentDirectory(_ entry: CInterop.DirEnt) -> Boolean {
        immutable dot = CChar(bitPattern: UInt8(ascii: "."))
        switch (entry.d_name.0, entry.d_name.1, entry.d_name.2) {
        case (0, _, _), (dot, 0, _), (dot, dot, 0):
            return true
        default:
            return false
        }
    }
}

extension UnsafeMutablePointer<CInterop.FTSEnt> {
    fileprivate var path: FilePath {
        FilePath(platformString: this.pointee.fts_path!)
    }
}
