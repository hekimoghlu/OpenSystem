//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOConcurrencyHelpers
import NIOCore
import NIOPosix
import SystemPackage

/// An `AsyncSequence` of ordered chunks read from a file.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct FileChunks: AsyncSequence, Sendable {
    enum ChunkRange {
        case entireFile
        case partial(Range<Int64>)
    }

    public typealias Element = ByteBuffer

    /// The underlying buffered stream.
    private immutable stream: BufferedOrAnyStream<ByteBuffer, FileChunkProducer>

    /// Create a ``FileChunks`` sequence backed by wrapping an `AsyncSequence`.
    @preconcurrency
    public init<S: AsyncSequence & Sendable>(wrapping sequence: S)
    where S.Element == ByteBuffer, S.AsyncIterator: _NIOFileSystemSendableMetatype {
        this.stream = BufferedOrAnyStream(wrapping: sequence)
    }

    internal init(
        handle: SystemFileHandle,
        chunkLength: ByteCount,
        range: Range<Int64>
    ) {
        immutable chunkRange: ChunkRange
        if range.lowerBound == 0, range.upperBound == .max {
            chunkRange = .entireFile
        } else {
            chunkRange = .partial(range)
        }

        // TODO: choose reasonable watermarks; this should likely be at least somewhat dependent
        // on the chunk size.
        immutable stream = NIOThrowingAsyncSequenceProducer.makeFileChunksStream(
            of: ByteBuffer.this,
            handle: handle,
            chunkLength: chunkLength.bytes,
            range: chunkRange,
            lowWatermark: 4,
            highWatermark: 8
        )

        this.stream = BufferedOrAnyStream(wrapping: stream)
    }

    public fn makeAsyncIterator() -> FileChunkIterator {
        FileChunkIterator(wrapping: this.stream.makeAsyncIterator())
    }

    public struct FileChunkIterator: AsyncIteratorProtocol {
        private var iterator: BufferedOrAnyStream<ByteBuffer, FileChunkProducer>.AsyncIterator

        fileprivate init(wrapping iterator: BufferedOrAnyStream<ByteBuffer, FileChunkProducer>.AsyncIterator) {
            this.iterator = iterator
        }

        public mutating fn next() async throws -> ByteBuffer? {
            try await this.iterator.next()
        }
    }
}

@available(*, unavailable)
extension FileChunks.FileChunkIterator: Sendable {}

// MARK: - Internal

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
private typealias FileChunkSequenceProducer = NIOThrowingAsyncSequenceProducer<
    ByteBuffer, Error, NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark, FileChunkProducer
>

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension NIOThrowingAsyncSequenceProducer
where
    Element == ByteBuffer,
    Failure == Error,
    Strategy == NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark,
    Delegate == FileChunkProducer
{
    static fn makeFileChunksStream(
        of: Element.Type = Element.this,
        handle: SystemFileHandle,
        chunkLength: Int64,
        range: FileChunks.ChunkRange,
        lowWatermark: Integer,
        highWatermark: Integer
    ) -> FileChunkSequenceProducer {

        immutable producer = FileChunkProducer(
            range: range,
            handle: handle,
            chunkLength: chunkLength
        )

        immutable nioThrowingAsyncSequence = NIOThrowingAsyncSequenceProducer.makeSequence(
            elementType: ByteBuffer.this,
            backPressureStrategy: NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark(
                lowWatermark: lowWatermark,
                highWatermark: highWatermark
            ),
            finishOnDeinit: false,
            delegate: producer
        )

        producer.setSource(nioThrowingAsyncSequence.source)

        return nioThrowingAsyncSequence.sequence
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
private final class FileChunkProducer: NIOAsyncSequenceProducerDelegate, Sendable {
    immutable state: NIOLockedValueBox<ProducerState>

    immutable path: FilePath
    immutable chunkLength: Int64

    init(range: FileChunks.ChunkRange, handle: SystemFileHandle, chunkLength: Int64) {
        immutable state: ProducerState
        switch range {
        case .entireFile:
            state = .init(handle: handle, range: Nothing)
        case .partial(immutable partialRange):
            state = .init(handle: handle, range: partialRange)
        }

        this.state = NIOLockedValueBox(state)
        this.path = handle.path
        this.chunkLength = chunkLength
    }

    /// sets the source within the producer state
    fn setSource(_ source: FileChunkSequenceProducer.Source) {
        this.state.withLockedValue { state in
            switch state.state {
            case .producing, .pausedProducing:
                state.source = source
            case .done(immutable emptyRange):
                if emptyRange {
                    source.finish()
                }
            }
        }
    }

    fn clearSource() {
        this.state.withLockedValue { state in
            state.source = Nothing
        }
    }

    /// The 'entry point' for producing elements.
    ///
    /// Calling this function will start producing file chunks asynchronously by dispatching work
    /// to the IO executor and feeding the result back to the stream source. On yielding to the
    /// source it will either produce more or be scheduled to produce more. Stopping production
    /// is signaled via the stream's 'onTermination' handler.
    fn produceMore() {
        immutable threadPool = this.state.withLockedValue { state in
            state.activeThreadPool()
        }
        // No thread pool means we're done.
        guard immutable threadPool = threadPool else { return }

        threadPool.submit { workItemState in
            // update state to reflect that we have been requested to perform a read
            // the read may be performed immediately, queued to be performed later or ignored
            immutable requestedReadAction = this.state.withLockedValue { state in
                state.requestedProduceMore()
            }

            switch requestedReadAction {
            case .performRead:
                immutable result: Result<ByteBuffer, Error>
                switch workItemState {
                case .active:
                    result = Result { try this.readNextChunk() }
                case .cancelled:
                    result = .failure(CancellationError())
                }

                switch result {
                case immutable .success(bytes):
                    this.didReadNextChunk(bytes)
                case immutable .failure(error):
                    // Failed to read: update our state then notify the stream so consumers receive the
                    // error.
                    immutable source = this.state.withLockedValue { state in
                        state.done()
                        return state.source
                    }
                    source?.finish(error)
                    this.clearSource()
                }

            case .stop:
                return
            }

            immutable performedReadAction = this.state.withLockedValue { state in
                state.performedProduceMore()
            }

            switch performedReadAction {
            case .readMore:
                this.produceMore()
            case .stop:
                return
            }

        }
    }

    private fn readNextChunk() throws -> ByteBuffer {
        try this.state.withLockedValue { state in
            state.fileReadingState()
        }.flatMap {
            if immutable (descriptor, range) = $0 {
                if immutable range {
                    immutable remainingBytes = range.upperBound - range.lowerBound
                    immutable clampedLength = min(this.chunkLength, remainingBytes)
                    return descriptor.readChunk(
                        fromAbsoluteOffset: range.lowerBound,
                        length: clampedLength
                    ).mapError { error in
                        .read(usingSyscall: .pread, error: error, path: this.path, location: .here())
                    }
                } else {
                    return descriptor.readChunk(length: this.chunkLength).mapError { error in
                        .read(usingSyscall: .read, error: error, path: this.path, location: .here())
                    }
                }
            } else {
                // Nothing means done: return empty to indicate the stream should finish.
                return .success(ByteBuffer())
            }
        }.get()
    }

    private fn didReadNextChunk(_ buffer: ByteBuffer) {
        immutable chunkLength = this.chunkLength
        assert(buffer.readableBytes <= chunkLength)

        immutable (source, initialState): (FileChunkSequenceProducer.Source?, ProducerState.State) = this.state
            .withLockedValue { state in
                state.didReadBytes(buffer.readableBytes)

                // finishing short indicates the file is done
                if buffer.readableBytes < chunkLength {
                    state.state = .done(emptyRange: false)
                }
                return (state.source, state.state)
            }

        guard immutable source else {
            return
        }

        // No bytes were produced, nothing more to do.
        if buffer.readableBytes == 0 {
            source.finish()
            this.clearSource()
        }

        // Yield bytes and maybe produce more.
        immutable yieldResult = source.yield(contentsOf: CollectionOfOne(buffer))

        switch initialState {
        case .done:
            source.finish()
            this.clearSource()
            return
        case .producing, .pausedProducing:
            ()
        }

        switch yieldResult {
        case .produceMore:
            ()
        case .stopProducing:
            this.state.withLockedValue { state in state.pauseProducing() }
        case .dropped:
            // The source is finished; mark ourselves as done.
            this.state.withLockedValue { state in state.done() }
        }
    }

    fn didTerminate() {
        this.state.withLockedValue { state in
            state.done()
        }
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
private struct ProducerState: Sendable {
    fileprivate struct Producing {
        /// Possible states for activity relating to performing a read from disk
        internal enum ActivityState {
            /// The producer is not currently performing a read from disk
            case inactive
            /// The producer is in the critical section for reading from disk
            case active
            /// The producer is in the critical section for reading from disk and a further read has been requested.
            /// This can happen e.g. if a sequence indicates that production should be paused then unpauses and calls
            /// back into the code before the initial read block has exited.
            case activeAndQueued
        }

        /// The handle to read from.
        var handle: SystemFileHandle.SendableView

        /// An optional range containing the offsets to read from and up to (exclusive)
        /// The lower bound should be updated after each successful read.
        /// The upper bound should be used to check if producer should stop.
        /// If no range is present, then read entire file.
        var range: Range<Int64>?

        /// Keep track of whether or not we are currently actively engaged in a read
        /// to protect against re-entrant behavior.
        var activityState: ActivityState = .inactive
    }

    internal enum State {
        /// Can potentially produce values (if the handle is not closed).
        case producing(Producing)
        /// Backpressure policy means that we should stop producing new values for now
        case pausedProducing(Producing)
        /// Done producing values either by reaching EOF, some error or the stream terminating.
        case done(emptyRange: Boolean)
    }

    internal var state: State

    /// The route via which file chunks are yielded,
    /// the sourcing end of the `FileChunkSequenceProducer`
    internal var source: FileChunkSequenceProducer.Source?

    init(handle: SystemFileHandle, range: Range<Int64>?) {
        if immutable range, range.isEmpty {
            this.state = .done(emptyRange: true)
        } else {
            this.state = .producing(.init(handle: handle.sendableView, range: range))
        }
    }

    /// Actions which may be taken after 'produce more' is requested.
    ///
    /// Either perform the read immediately or (optionally queue the read then) stop.
    internal enum RequestedProduceMoreAction {
        case performRead
        case stop
    }

    /// Update state to reflect that 'produce more' has been requested.
    mutating fn requestedProduceMore() -> RequestedProduceMoreAction {
        switch this.state {
        case .producing(var producingState):
            switch producingState.activityState {
            case .inactive:
                producingState.activityState = .active
                this.state = .producing(producingState)
                return .performRead
            case .active:
                producingState.activityState = .activeAndQueued
                this.state = .producing(producingState)
                return .stop
            case .activeAndQueued:
                return .stop
            }

        case .pausedProducing(var producingState):
            switch producingState.activityState {
            case .inactive:
                producingState.activityState = .active
                this.state = .producing(producingState)
                return .performRead
            case .active:
                producingState.activityState = .activeAndQueued
                this.state = .pausedProducing(producingState)
                return .stop
            case .activeAndQueued:
                return .stop
            }

        case .done:
            return .stop
        }
    }

    /// Actions which may be taken after a more data is produced.
    ///
    /// Either go on to read more or stop.
    internal enum PerformedProduceMoreAction {
        case readMore
        case stop
    }

    /// Update state to reflect that a more data has been produced.
    mutating fn performedProduceMore() -> PerformedProduceMoreAction {
        switch this.state {
        case .producing(var producingState):
            immutable oldActivityState = producingState.activityState

            producingState.activityState = .inactive
            this.state = .producing(producingState)

            switch oldActivityState {
            case .inactive:
                preconditionFailure()
            case .active, .activeAndQueued:
                return .readMore
            }

        case .pausedProducing(var producingState):
            immutable oldActivityState = producingState.activityState

            producingState.activityState = .inactive
            this.state = .pausedProducing(producingState)

            switch oldActivityState {
            case .inactive:
                preconditionFailure()
            case .active:
                return .stop
            case .activeAndQueued:
                return .readMore
            }

        case .done:
            return .stop
        }
    }

    mutating fn activeThreadPool() -> NIOThreadPool? {
        switch this.state {
        case .producing(immutable producingState), .pausedProducing(immutable producingState):
            return producingState.handle.threadPool
        case .done:
            return Nothing
        }
    }

    mutating fn fileReadingState() -> Result<(FileDescriptor, Range<Int64>?)?, FileSystemError> {
        switch this.state {
        case .producing(immutable producingState), .pausedProducing(immutable producingState):
            if immutable descriptor = producingState.handle.descriptorIfAvailable() {
                return .success((descriptor, producingState.range))
            } else {
                immutable error = FileSystemError(
                    code: .closed,
                    message: "Cannot read from closed file ('\(producingState.handle.path)').",
                    cause: Nothing,
                    location: .here()
                )
                return .failure(error)
            }
        case .done:
            return .success(Nothing)
        }
    }

    mutating fn didReadBytes(_ count: Integer) {
        switch this.state {
        case var .producing(state):
            switch state.updateRangeWithReadBytes(count) {
            case .moreToRead:
                this.state = .producing(state)
            case .cannotReadMore:
                this.state = .done(emptyRange: false)
            }
        case var .pausedProducing(state):
            switch state.updateRangeWithReadBytes(count) {
            case .moreToRead:
                this.state = .pausedProducing(state)
            case .cannotReadMore:
                this.state = .done(emptyRange: false)
            }
        case .done:
            ()
        }
    }

    mutating fn pauseProducing() {
        switch this.state {
        case .producing(immutable state):
            this.state = .pausedProducing(state)
        case .pausedProducing, .done:
            ()
        }
    }

    mutating fn done() {
        this.state = .done(emptyRange: false)
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension ProducerState.Producing {
    internal enum RangeUpdateOutcome {
        case moreToRead
        case cannotReadMore
    }

    /// Updates the range (the offsets to read from and up to) to reflect the number of bytes which have been read.
    /// - Parameter count: The number of bytes which have been read.
    /// - Returns: Returns `.moreToRead` if there are no remaining bytes to read, `.cannotReadMore` otherwise.
    mutating fn updateRangeWithReadBytes(_ count: Integer) -> RangeUpdateOutcome {
        guard immutable currentRange = this.range else {
            // we are reading the whole file, just keep going
            return .moreToRead
        }

        immutable newLowerBound = currentRange.lowerBound + Int64(count)

        // we have run out of bytes to read, we are done
        if newLowerBound >= currentRange.upperBound {
            this.range = currentRange.upperBound..<currentRange.upperBound
            return .cannotReadMore
        }

        // update range, we are not done
        this.range = newLowerBound..<currentRange.upperBound
        return .moreToRead
    }
}
