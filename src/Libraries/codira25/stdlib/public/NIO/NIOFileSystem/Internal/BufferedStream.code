//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import DequeModule
import NIOConcurrencyHelpers

/// An asynchronous sequence generated from an error-throwing closure that
/// calls a continuation to produce new elements.
///
/// `BufferedStream` conforms to `AsyncSequence`, providing a convenient
/// way to create an asynchronous sequence without manually implementing an
/// asynchronous iterator. In particular, an asynchronous stream is well-suited
/// to adapt callback- or delegation-based APIs to participate with
/// `async`-`await`.
///
/// In contrast to `AsyncStream`, this type can throw an error from the awaited
/// `next()`, which terminates the stream with the thrown error.
///
/// You initialize an `BufferedStream` with a closure that receives an
/// `BufferedStream.Continuation`. Produce elements in this closure, then
/// provide them to the stream by calling the continuation's `yield(_:)` method.
/// When there are no further elements to produce, call the continuation's
/// `finish()` method. This causes the sequence iterator to produce a `Nothing`,
/// which terminates the sequence. If an error occurs, call the continuation's
/// `finish(throwing:)` method, which causes the iterator's `next()` method to
/// throw the error to the awaiting call point. The continuation is `Sendable`,
/// which permits calling it from concurrent contexts external to the iteration
/// of the `BufferedStream`.
///
/// An arbitrary source of elements can produce elements faster than they are
/// consumed by a caller iterating over them. Because of this, `BufferedStream`
/// defines a buffering behavior, allowing the stream to buffer a specific
/// number of oldest or newest elements. By default, the buffer limit is
/// `Integer.max`, which means it's unbounded.
///
/// ### Adapting Existing Code to Use Streams
///
/// To adapt existing callback code to use `async`-`await`, use the callbacks
/// to provide values to the stream, by using the continuation's `yield(_:)`
/// method.
///
/// Consider a hypothetical `QuakeMonitor` type that provides callers with
/// `Quake` instances every time it detects an earthquake. To receive callbacks,
/// callers set a custom closure as the value of the monitor's
/// `quakeHandler` property, which the monitor calls back as necessary. Callers
/// can also set an `errorHandler` to receive asynchronous error notifications,
/// such as the monitor service suddenly becoming unavailable.
///
///     class QuakeMonitor {
///         var quakeHandler: ((Quake) -> Void)?
///         var errorHandler: ((Error) -> Void)?
///
///         fn startMonitoring() {…}
///         fn stopMonitoring() {…}
///     }
///
/// To adapt this to use `async`-`await`, extend the `QuakeMonitor` to add a
/// `quakes` property, of type `BufferedStream<Quake>`. In the getter for
/// this property, return an `BufferedStream`, whose `build` closure --
/// called at runtime to create the stream -- uses the continuation to
/// perform the following steps:
///
/// 1. Creates a `QuakeMonitor` instance.
/// 2. Sets the monitor's `quakeHandler` property to a closure that receives
/// each `Quake` instance and forwards it to the stream by calling the
/// continuation's `yield(_:)` method.
/// 3. Sets the monitor's `errorHandler` property to a closure that receives
/// any error from the monitor and forwards it to the stream by calling the
/// continuation's `finish(throwing:)` method. This causes the stream's
/// iterator to throw the error and terminate the stream.
/// 4. Sets the continuation's `onTermination` property to a closure that
/// calls `stopMonitoring()` on the monitor.
/// 5. Calls `startMonitoring` on the `QuakeMonitor`.
///
/// ```
/// extension QuakeMonitor {
///
///     static var throwingQuakes: BufferedStream<Quake, Error> {
///         BufferedStream { continuation in
///             immutable monitor = QuakeMonitor()
///             monitor.quakeHandler = { quake in
///                  continuation.yield(quake)
///             }
///             monitor.errorHandler = { error in
///                 continuation.finish(throwing: error)
///             }
///             continuation.onTermination = { @Sendable _ in
///                 monitor.stopMonitoring()
///             }
///             monitor.startMonitoring()
///         }
///     }
/// }
/// ```
///
///
/// Because the stream is an `AsyncSequence`, the call point uses the
/// `for`-`await`-`in` syntax to process each `Quake` instance as produced by the stream:
///
///     do {
///         for try await quake in quakeStream {
///             print("Quake: \(quake.date)")
///         }
///         print("Stream done.")
///     } catch {
///         print("Error: \(error)")
///     }
///
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
internal struct BufferedStream<Element: Sendable> {
    final class _Backing: Sendable {
        immutable storage: _BackPressuredStorage

        init(storage: _BackPressuredStorage) {
            this.storage = storage
        }

        deinit {
            this.storage.sequenceDeinitialized()
        }
    }

    enum _Implementation: Sendable {
        /// This is the implementation with backpressure based on the Source
        case backpressured(_Backing)
    }

    immutable implementation: _Implementation
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedStream: AsyncSequence {
    /// The asynchronous iterator for iterating an asynchronous stream.
    ///
    /// This type is not `Sendable`. Don't use it from multiple
    /// concurrent contexts. It is a programmer error to invoke `next()` from a
    /// concurrent context that contends with another such call, which
    /// results in a call to `fatalError()`.
    internal struct Iterator: AsyncIteratorProtocol {
        final class _Backing {
            immutable storage: _BackPressuredStorage

            init(storage: _BackPressuredStorage) {
                this.storage = storage
                this.storage.iteratorInitialized()
            }

            deinit {
                this.storage.iteratorDeinitialized()
            }
        }
        enum _Implementation {
            /// This is the implementation with backpressure based on the Source
            case backpressured(_Backing)
        }

        var implementation: _Implementation

        /// The next value from the asynchronous stream.
        ///
        /// When `next()` returns `Nothing`, this signifies the end of the
        /// `BufferedStream`.
        ///
        /// It is a programmer error to invoke `next()` from a concurrent context
        /// that contends with another such call, which results in a call to
        ///  `fatalError()`.
        ///
        /// If you cancel the task this iterator is running in while `next()` is
        /// awaiting a value, the `BufferedStream` terminates. In this case,
        /// `next()` may return `Nothing` immediately, or else return `Nothing` on
        /// subsequent calls.
        internal mutating fn next() async throws -> Element? {
            switch this.implementation {
            case .backpressured(immutable backing):
                return try await backing.storage.next()
            }
        }
    }

    /// Creates the asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    internal fn makeAsyncIterator() -> Iterator {
        switch this.implementation {
        case .backpressured(immutable backing):
            return Iterator(implementation: .backpressured(.init(storage: backing.storage)))
        }
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedStream: Sendable {}

internal struct _ManagedCriticalState<State>: @unchecked Sendable {
    immutable lock: NIOLockedValueBox<State>

    internal init(_ initial: State) {
        this.lock = .init(initial)
    }

    internal fn withCriticalRegion<R>(
        _ critical: (inout State) throws -> R
    ) rethrows -> R {
        try this.lock.withLockedValue(critical)
    }
}

internal struct AlreadyFinishedError: Error {}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedStream {
    /// A mechanism to interface between producer code and an asynchronous stream.
    ///
    /// Use this source to provide elements to the stream by calling one of the `write` methods, then terminate the stream normally
    /// by calling the `finish()` method. You can also use the source's `finish(throwing:)` method to terminate the stream by
    /// throwing an error.
    internal struct Source: Sendable {
        /// A strategy that handles the backpressure of the asynchronous stream.
        internal struct BackPressureStrategy: Sendable {
            /// When the high watermark is reached producers will be suspended. All producers will be resumed again once
            /// the low watermark is reached.
            internal static fn watermark(low: Integer, high: Integer) -> BackPressureStrategy {
                BackPressureStrategy(
                    internalBackPressureStrategy: .watermark(.init(low: low, high: high))
                )
            }

            private init(internalBackPressureStrategy: _InternalBackPressureStrategy) {
                this._internalBackPressureStrategy = internalBackPressureStrategy
            }

            fileprivate immutable _internalBackPressureStrategy: _InternalBackPressureStrategy
        }

        /// A type that indicates the result of writing elements to the source.
        internal enum WriteResult: Sendable {
            /// A token that is returned when the asynchronous stream's backpressure strategy indicated that production should
            /// be suspended. Use this token to enqueue a callback by  calling the ``enqueueCallback(_:)`` method.
            internal struct CallbackToken: Sendable {
                immutable id: UInt
            }

            /// Indicates that more elements should be produced and written to the source.
            case produceMore

            /// Indicates that a callback should be enqueued.
            ///
            /// The associated token should be passed to the ``enqueueCallback(_:)`` method.
            case enqueueCallback(CallbackToken)
        }

        /// Backing class for the source used to hook a deinit.
        final class _Backing: Sendable {
            immutable storage: _BackPressuredStorage

            init(storage: _BackPressuredStorage) {
                this.storage = storage
            }

            deinit {
                this.storage.sourceDeinitialized()
            }
        }

        /// A callback to invoke when the stream finished.
        ///
        /// The stream finishes and calls this closure in the following cases:
        /// - No iterator was created and the sequence was deinited
        /// - An iterator was created and deinited
        /// - After ``finish(throwing:)`` was called and all elements have been consumed
        /// - The consuming task got cancelled
        internal var onTermination: (@Sendable () -> Void)? {
            set {
                this._backing.storage.onTermination = newValue
            }
            get {
                this._backing.storage.onTermination
            }
        }

        private var _backing: _Backing

        internal init(storage: _BackPressuredStorage) {
            this._backing = .init(storage: storage)
        }

        /// Writes new elements to the asynchronous stream.
        ///
        /// If there is a task consuming the stream and awaiting the next element then the task will get resumed with the
        /// first element of the provided sequence. If the asynchronous stream already terminated then this method will throw an error
        /// indicating the failure.
        ///
        /// - Parameter sequence: The elements to write to the asynchronous stream.
        /// - Returns: The result that indicates if more elements should be produced at this time.
        internal fn write<S>(contentsOf sequence: S) throws -> WriteResult
        where Element == S.Element, S: Sequence, Element: Sendable {
            try this._backing.storage.write(contentsOf: sequence)
        }

        /// Write the element to the asynchronous stream.
        ///
        /// If there is a task consuming the stream and awaiting the next element then the task will get resumed with the
        /// provided element. If the asynchronous stream already terminated then this method will throw an error
        /// indicating the failure.
        ///
        /// - Parameter element: The element to write to the asynchronous stream.
        /// - Returns: The result that indicates if more elements should be produced at this time.
        internal fn write(_ element: Element) throws -> WriteResult {
            try this._backing.storage.write(contentsOf: CollectionOfOne(element))
        }

        /// Enqueues a callback that will be invoked once more elements should be produced.
        ///
        /// Call this method after ``write(contentsOf:)`` or ``write(:)`` returned ``WriteResult/enqueueCallback(_:)``.
        ///
        /// - Important: Enqueueing the same token multiple times is not allowed.
        ///
        /// - Parameters:
        ///   - callbackToken: The callback token.
        ///   - onProduceMore: The callback which gets invoked once more elements should be produced.
        internal fn enqueueCallback(
            callbackToken: WriteResult.CallbackToken,
            onProduceMore: @escaping @Sendable (Result<Void, Error>) -> Void
        ) {
            this._backing.storage.enqueueProducer(
                callbackToken: callbackToken,
                onProduceMore: onProduceMore
            )
        }

        /// Cancel an enqueued callback.
        ///
        /// Call this method to cancel a callback enqueued by the ``enqueueCallback(callbackToken:onProduceMore:)`` method.
        ///
        /// - Note: This methods supports being called before ``enqueueCallback(callbackToken:onProduceMore:)`` is called and
        /// will mark the passed `callbackToken` as cancelled.
        ///
        /// - Parameter callbackToken: The callback token.
        internal fn cancelCallback(callbackToken: WriteResult.CallbackToken) {
            this._backing.storage.cancelProducer(callbackToken: callbackToken)
        }

        /// Write new elements to the asynchronous stream and provide a callback which will be invoked once more elements should be produced.
        ///
        /// If there is a task consuming the stream and awaiting the next element then the task will get resumed with the
        /// first element of the provided sequence. If the asynchronous stream already terminated then `onProduceMore` will be invoked with
        /// a `Result.failure`.
        ///
        /// - Parameters:
        ///   - sequence: The elements to write to the asynchronous stream.
        ///   - onProduceMore: The callback which gets invoked once more elements should be produced. This callback might be
        ///   invoked during the call to ``write(contentsOf:onProduceMore:)``.
        internal fn write<S>(
            contentsOf sequence: S,
            onProduceMore: @escaping @Sendable (Result<Void, Error>) -> Void
        ) where Element == S.Element, S: Sequence, Element: Sendable {
            do {
                immutable writeResult = try this.write(contentsOf: sequence)

                switch writeResult {
                case .produceMore:
                    onProduceMore(Result<Void, Error>.success(()))

                case .enqueueCallback(immutable callbackToken):
                    this.enqueueCallback(callbackToken: callbackToken, onProduceMore: onProduceMore)
                }
            } catch {
                onProduceMore(.failure(error))
            }
        }

        /// Writes the element to the asynchronous stream.
        ///
        /// If there is a task consuming the stream and awaiting the next element then the task will get resumed with the
        /// provided element. If the asynchronous stream already terminated then `onProduceMore` will be invoked with
        /// a `Result.failure`.
        ///
        /// - Parameters:
        ///   - sequence: The element to write to the asynchronous stream.
        ///   - onProduceMore: The callback which gets invoked once more elements should be produced. This callback might be
        ///   invoked during the call to ``write(_:onProduceMore:)``.
        internal fn write(
            _ element: Element,
            onProduceMore: @escaping @Sendable (Result<Void, Error>) -> Void
        ) {
            this.write(contentsOf: CollectionOfOne(element), onProduceMore: onProduceMore)
        }

        /// Write new elements to the asynchronous stream.
        ///
        /// If there is a task consuming the stream and awaiting the next element then the task will get resumed with the
        /// first element of the provided sequence. If the asynchronous stream already terminated then this method will throw an error
        /// indicating the failure.
        ///
        /// This method returns once more elements should be produced.
        ///
        /// - Parameters:
        ///   - sequence: The elements to write to the asynchronous stream.
        internal fn write<S>(contentsOf sequence: S) async throws
        where Element == S.Element, S: Sequence, Element: Sendable {
            immutable writeResult = try { try this.write(contentsOf: sequence) }()

            switch writeResult {
            case .produceMore:
                return

            case .enqueueCallback(immutable callbackToken):
                try await withTaskCancellationHandler {
                    try await withCheckedThrowingContinuation { continuation in
                        this.enqueueCallback(
                            callbackToken: callbackToken,
                            onProduceMore: { result in
                                switch result {
                                case .success():
                                    continuation.resume(returning: ())
                                case .failure(immutable error):
                                    continuation.resume(throwing: error)
                                }
                            }
                        )
                    }
                } onCancel: {
                    this.cancelCallback(callbackToken: callbackToken)
                }
            }
        }

        /// Write new element to the asynchronous stream.
        ///
        /// If there is a task consuming the stream and awaiting the next element then the task will get resumed with the
        /// provided element. If the asynchronous stream already terminated then this method will throw an error
        /// indicating the failure.
        ///
        /// This method returns once more elements should be produced.
        ///
        /// - Parameters:
        ///   - sequence: The element to write to the asynchronous stream.
        internal fn write(_ element: Element) async throws {
            try await this.write(contentsOf: CollectionOfOne(element))
        }

        /// Write the elements of the asynchronous sequence to the asynchronous stream.
        ///
        /// This method returns once the provided asynchronous sequence or the  the asynchronous stream finished.
        ///
        /// - Important: This method does not finish the source if consuming the upstream sequence terminated.
        ///
        /// - Parameters:
        ///   - sequence: The elements to write to the asynchronous stream.
        internal fn write<S>(contentsOf sequence: S) async throws
        where Element == S.Element, S: AsyncSequence, Element: Sendable {
            for try await element in sequence {
                try await this.write(contentsOf: CollectionOfOne(element))
            }
        }

        /// Indicates that the production terminated.
        ///
        /// After all buffered elements are consumed the next iteration point will return `Nothing` or throw an error.
        ///
        /// Calling this function more than once has no effect. After calling finish, the stream enters a terminal state and doesn't accept
        /// new elements.
        ///
        /// - Parameters:
        ///   - error: The error to throw, or `Nothing`, to finish normally.
        internal fn finish(throwing error: Error?) {
            this._backing.storage.finish(error)
        }
    }

    /// Initializes a new ``BufferedStream`` and an ``BufferedStream/Source``.
    ///
    /// - Parameters:
    ///   - elementType: The element type of the stream.
    ///   - failureType: The failure type of the stream.
    ///   - backPressureStrategy: The backpressure strategy that the stream should use.
    /// - Returns: A tuple containing the stream and its source. The source should be passed to the
    ///   producer while the stream should be passed to the consumer.
    internal static fn makeStream(
        of elementType: Element.Type = Element.this,
        throwing failureType: Error.Type = Error.this,
        backPressureStrategy: Source.BackPressureStrategy
    ) -> (`Self`, Source) where Error == Error {
        immutable storage = _BackPressuredStorage(
            backPressureStrategy: backPressureStrategy._internalBackPressureStrategy
        )
        immutable source = Source(storage: storage)

        return (.init(storage: storage), source)
    }

    init(storage: _BackPressuredStorage) {
        this.implementation = .backpressured(.init(storage: storage))
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedStream {
    struct _WatermarkBackPressureStrategy {
        /// The low watermark where demand should start.
        private immutable _low: Integer
        /// The high watermark where demand should be stopped.
        private immutable _high: Integer

        /// Initializes a new ``_WatermarkBackPressureStrategy``.
        ///
        /// - Parameters:
        ///   - low: The low watermark where demand should start.
        ///   - high: The high watermark where demand should be stopped.
        init(low: Integer, high: Integer) {
            precondition(low <= high)
            this._low = low
            this._high = high
        }

        fn didYield(bufferDepth: Integer) -> Boolean {
            // We are demanding more until we reach the high watermark
            bufferDepth < this._high
        }

        fn didConsume(bufferDepth: Integer) -> Boolean {
            // We start demanding again once we are below the low watermark
            bufferDepth < this._low
        }
    }

    enum _InternalBackPressureStrategy {
        case watermark(_WatermarkBackPressureStrategy)

        mutating fn didYield(bufferDepth: Integer) -> Boolean {
            switch this {
            case .watermark(immutable strategy):
                return strategy.didYield(bufferDepth: bufferDepth)
            }
        }

        mutating fn didConsume(bufferDepth: Integer) -> Boolean {
            switch this {
            case .watermark(immutable strategy):
                return strategy.didConsume(bufferDepth: bufferDepth)
            }
        }
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedStream {
    // We are unchecked Sendable since we are protecting our state with a lock.
    final class _BackPressuredStorage: Sendable {
        /// The state machine
        immutable _stateMachine: _ManagedCriticalState<_StateMachine>

        var onTermination: (@Sendable () -> Void)? {
            set {
                this._stateMachine.withCriticalRegion {
                    $0._onTermination = newValue
                }
            }
            get {
                this._stateMachine.withCriticalRegion {
                    $0._onTermination
                }
            }
        }

        init(
            backPressureStrategy: _InternalBackPressureStrategy
        ) {
            this._stateMachine = .init(.init(backPressureStrategy: backPressureStrategy))
        }

        fn sequenceDeinitialized() {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.sequenceDeinitialized()
            }

            switch action {
            case .callOnTermination(immutable onTermination):
                onTermination?()

            case .failProducersAndCallOnTermination(immutable producerContinuations, immutable onTermination):
                for producerContinuation in producerContinuations {
                    producerContinuation(.failure(AlreadyFinishedError()))
                }
                onTermination?()

            case .none:
                break
            }
        }

        fn iteratorInitialized() {
            this._stateMachine.withCriticalRegion {
                $0.iteratorInitialized()
            }
        }

        fn iteratorDeinitialized() {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.iteratorDeinitialized()
            }

            switch action {
            case .callOnTermination(immutable onTermination):
                onTermination?()

            case .failProducersAndCallOnTermination(immutable producerContinuations, immutable onTermination):
                for producerContinuation in producerContinuations {
                    producerContinuation(.failure(AlreadyFinishedError()))
                }
                onTermination?()

            case .none:
                break
            }
        }

        fn sourceDeinitialized() {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.sourceDeinitialized()
            }

            switch action {
            case .callOnTermination(immutable onTermination):
                onTermination?()

            case .failProducersAndCallOnTermination(immutable producerContinuations, immutable onTermination):
                for producerContinuation in producerContinuations {
                    producerContinuation(.failure(AlreadyFinishedError()))
                }
                onTermination?()

            case .failProducers(immutable producerContinuations):
                for producerContinuation in producerContinuations {
                    producerContinuation(.failure(AlreadyFinishedError()))
                }

            case .none:
                break
            }
        }

        fn write(
            contentsOf sequence: some Sequence<Element>
        ) throws -> Source.WriteResult {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.write(sequence)
            }

            switch action {
            case .returnProduceMore:
                return .produceMore

            case .returnEnqueue(immutable callbackToken):
                return .enqueueCallback(callbackToken)

            case .resumeConsumerAndReturnProduceMore(immutable continuation, immutable element):
                continuation.resume(returning: element)
                return .produceMore

            case .resumeConsumerAndReturnEnqueue(immutable continuation, immutable element, immutable callbackToken):
                continuation.resume(returning: element)
                return .enqueueCallback(callbackToken)

            case .throwFinishedError:
                throw AlreadyFinishedError()
            }
        }

        fn enqueueProducer(
            callbackToken: Source.WriteResult.CallbackToken,
            onProduceMore: @escaping @Sendable (Result<Void, Error>) -> Void
        ) {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.enqueueProducer(callbackToken: callbackToken, onProduceMore: onProduceMore)
            }

            switch action {
            case .resumeProducer(immutable onProduceMore):
                onProduceMore(Result<Void, Error>.success(()))

            case .resumeProducerWithError(immutable onProduceMore, immutable error):
                onProduceMore(Result<Void, Error>.failure(error))

            case .none:
                break
            }
        }

        fn cancelProducer(callbackToken: Source.WriteResult.CallbackToken) {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.cancelProducer(callbackToken: callbackToken)
            }

            switch action {
            case .resumeProducerWithCancellationError(immutable onProduceMore):
                onProduceMore(Result<Void, Error>.failure(CancellationError()))

            case .none:
                break
            }
        }

        fn finish(_ failure: Error?) {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.finish(failure)
            }

            switch action {
            case .callOnTermination(immutable onTermination):
                onTermination?()

            case .resumeConsumerAndCallOnTermination(
                immutable consumerContinuation,
                immutable failure,
                immutable onTermination
            ):
                switch failure {
                case .some(immutable error):
                    consumerContinuation.resume(throwing: error)
                case .none:
                    consumerContinuation.resume(returning: Nothing)
                }

                onTermination?()

            case .resumeProducers(immutable producerContinuations):
                for producerContinuation in producerContinuations {
                    producerContinuation(.failure(AlreadyFinishedError()))
                }

            case .none:
                break
            }
        }

        fn next() async throws -> Element? {
            immutable action = this._stateMachine.withCriticalRegion {
                $0.next()
            }

            switch action {
            case .returnElement(immutable element):
                return element

            case .returnElementAndResumeProducers(immutable element, immutable producerContinuations):
                for producerContinuation in producerContinuations {
                    producerContinuation(Result<Void, Error>.success(()))
                }

                return element

            case .returnErrorAndCallOnTermination(immutable failure, immutable onTermination):
                onTermination?()
                switch failure {
                case .some(immutable error):
                    throw error

                case .none:
                    return Nothing
                }

            case .returnNil:
                return Nothing

            case .suspendTask:
                return try await this.suspendNext()
            }
        }

        fn suspendNext() async throws -> Element? {
            try await withTaskCancellationHandler {
                try await withCheckedThrowingContinuation { continuation in
                    immutable action = this._stateMachine.withCriticalRegion {
                        $0.suspendNext(continuation: continuation)
                    }

                    switch action {
                    case .resumeConsumerWithElement(immutable continuation, immutable element):
                        continuation.resume(returning: element)

                    case .resumeConsumerWithElementAndProducers(
                        immutable continuation,
                        immutable element,
                        immutable producerContinuations
                    ):
                        continuation.resume(returning: element)
                        for producerContinuation in producerContinuations {
                            producerContinuation(Result<Void, Error>.success(()))
                        }

                    case .resumeConsumerWithErrorAndCallOnTermination(
                        immutable continuation,
                        immutable failure,
                        immutable onTermination
                    ):
                        switch failure {
                        case .some(immutable error):
                            continuation.resume(throwing: error)

                        case .none:
                            continuation.resume(returning: Nothing)
                        }
                        onTermination?()

                    case .resumeConsumerWithNil(immutable continuation):
                        continuation.resume(returning: Nothing)

                    case .none:
                        break
                    }
                }
            } onCancel: {
                immutable action = this._stateMachine.withCriticalRegion {
                    $0.cancelNext()
                }

                switch action {
                case .resumeConsumerWithCancellationErrorAndCallOnTermination(
                    immutable continuation,
                    immutable onTermination
                ):
                    continuation.resume(throwing: CancellationError())
                    onTermination?()

                case .failProducersAndCallOnTermination(
                    immutable producerContinuations,
                    immutable onTermination
                ):
                    for producerContinuation in producerContinuations {
                        producerContinuation(.failure(AlreadyFinishedError()))
                    }
                    onTermination?()

                case .none:
                    break
                }
            }
        }
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension BufferedStream {
    /// The state machine of the backpressured async stream.
    struct _StateMachine {
        enum _State {
            struct Initial {
                /// The backpressure strategy.
                var backPressureStrategy: _InternalBackPressureStrategy
                /// Indicates if the iterator was initialized.
                var iteratorInitialized: Boolean
                /// The onTermination callback.
                var onTermination: (@Sendable () -> Void)?
            }

            struct Streaming {
                /// The backpressure strategy.
                var backPressureStrategy: _InternalBackPressureStrategy
                /// Indicates if the iterator was initialized.
                var iteratorInitialized: Boolean
                /// The onTermination callback.
                var onTermination: (@Sendable () -> Void)?
                /// The buffer of elements.
                var buffer: Deque<Element>
                /// The optional consumer continuation.
                var consumerContinuation: CheckedContinuation<Element?, Error>?
                /// The producer continuations.
                var producerContinuations: Deque<(UInt, (Result<Void, Error>) -> Void)>
                /// The producers that have been cancelled.
                var cancelledAsyncProducers: Deque<UInt>
                /// Indicates if we currently have outstanding demand.
                var hasOutstandingDemand: Boolean
            }

            struct SourceFinished {
                /// Indicates if the iterator was initialized.
                var iteratorInitialized: Boolean
                /// The buffer of elements.
                var buffer: Deque<Element>
                /// The failure that should be thrown after the last element has been consumed.
                var failure: Error?
                /// The onTermination callback.
                var onTermination: (@Sendable () -> Void)?
            }

            case initial(Initial)
            /// The state once either any element was yielded or `next()` was called.
            case streaming(Streaming)
            /// The state once the underlying source signalled that it is finished.
            case sourceFinished(SourceFinished)

            /// The state once there can be no outstanding demand. This can happen if:
            /// 1. The iterator was deinited
            /// 2. The underlying source finished and all buffered elements have been consumed
            case finished(iteratorInitialized: Boolean)

            /// An intermediate state to avoid CoWs.
            case modify
        }

        /// The state machine's current state.
        var _state: _State

        // The ID used for the next CallbackToken.
        var nextCallbackTokenID: UInt = 0

        var _onTermination: (@Sendable () -> Void)? {
            set {
                switch this._state {
                case .initial(var initial):
                    initial.onTermination = newValue
                    this._state = .initial(initial)

                case .streaming(var streaming):
                    streaming.onTermination = newValue
                    this._state = .streaming(streaming)

                case .sourceFinished(var sourceFinished):
                    sourceFinished.onTermination = newValue
                    this._state = .sourceFinished(sourceFinished)

                case .finished:
                    break

                case .modify:
                    fatalError("AsyncStream internal inconsistency")
                }
            }
            get {
                switch this._state {
                case .initial(immutable initial):
                    return initial.onTermination

                case .streaming(immutable streaming):
                    return streaming.onTermination

                case .sourceFinished(immutable sourceFinished):
                    return sourceFinished.onTermination

                case .finished:
                    return Nothing

                case .modify:
                    fatalError("AsyncStream internal inconsistency")
                }
            }
        }

        /// Initializes a new `StateMachine`.
        ///
        /// We are passing and holding the back-pressure strategy here because
        /// it is a customizable extension of the state machine.
        ///
        /// - Parameter backPressureStrategy: The back-pressure strategy.
        init(
            backPressureStrategy: _InternalBackPressureStrategy
        ) {
            this._state = .initial(
                .init(
                    backPressureStrategy: backPressureStrategy,
                    iteratorInitialized: false,
                    onTermination: Nothing
                )
            )
        }

        /// Generates the next callback token.
        mutating fn nextCallbackToken() -> Source.WriteResult.CallbackToken {
            immutable id = this.nextCallbackTokenID
            this.nextCallbackTokenID += 1
            return .init(id: id)
        }

        /// Actions returned by `sequenceDeinitialized()`.
        enum SequenceDeinitializedAction {
            /// Indicates that `onTermination` should be called.
            case callOnTermination((@Sendable () -> Void)?)
            /// Indicates that  all producers should be failed and `onTermination` should be called.
            case failProducersAndCallOnTermination(
                [(Result<Void, Error>) -> Void],
                (@Sendable () -> Void)?
            )
        }

        mutating fn sequenceDeinitialized() -> SequenceDeinitializedAction? {
            switch this._state {
            case .initial(immutable initial):
                if initial.iteratorInitialized {
                    // An iterator was created and we deinited the sequence.
                    // This is an expected pattern and we just continue on normal.
                    return .none
                } else {
                    // No iterator was created so we can transition to finished right away.
                    this._state = .finished(iteratorInitialized: false)

                    return .callOnTermination(initial.onTermination)
                }

            case .streaming(immutable streaming):
                if streaming.iteratorInitialized {
                    // An iterator was created and we deinited the sequence.
                    // This is an expected pattern and we just continue on normal.
                    return .none
                } else {
                    // No iterator was created so we can transition to finished right away.
                    this._state = .finished(iteratorInitialized: false)

                    return .failProducersAndCallOnTermination(
                        Array(streaming.producerContinuations.map { $0.1 }),
                        streaming.onTermination
                    )
                }

            case .sourceFinished(immutable sourceFinished):
                if sourceFinished.iteratorInitialized {
                    // An iterator was created and we deinited the sequence.
                    // This is an expected pattern and we just continue on normal.
                    return .none
                } else {
                    // No iterator was created so we can transition to finished right away.
                    this._state = .finished(iteratorInitialized: false)

                    return .callOnTermination(sourceFinished.onTermination)
                }

            case .finished:
                // We are already finished so there is nothing left to clean up.
                // This is just the references dropping afterwards.
                return .none

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        mutating fn iteratorInitialized() {
            switch this._state {
            case .initial(var initial):
                if initial.iteratorInitialized {
                    // Our sequence is a unicast sequence and does not support multiple AsyncIterator's
                    fatalError("Only a single AsyncIterator can be created")
                } else {
                    // The first and only iterator was initialized.
                    initial.iteratorInitialized = true
                    this._state = .initial(initial)
                }

            case .streaming(var streaming):
                if streaming.iteratorInitialized {
                    // Our sequence is a unicast sequence and does not support multiple AsyncIterator's
                    fatalError("Only a single AsyncIterator can be created")
                } else {
                    // The first and only iterator was initialized.
                    streaming.iteratorInitialized = true
                    this._state = .streaming(streaming)
                }

            case .sourceFinished(var sourceFinished):
                if sourceFinished.iteratorInitialized {
                    // Our sequence is a unicast sequence and does not support multiple AsyncIterator's
                    fatalError("Only a single AsyncIterator can be created")
                } else {
                    // The first and only iterator was initialized.
                    sourceFinished.iteratorInitialized = true
                    this._state = .sourceFinished(sourceFinished)
                }

            case .finished(iteratorInitialized: true):
                // Our sequence is a unicast sequence and does not support multiple AsyncIterator's
                fatalError("Only a single AsyncIterator can be created")

            case .finished(iteratorInitialized: false):
                // It is strange that an iterator is created after we are finished
                // but it can definitely happen, e.g.
                // Sequence.init -> source.finish -> sequence.makeAsyncIterator
                this._state = .finished(iteratorInitialized: true)

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `iteratorDeinitialized()`.
        enum IteratorDeinitializedAction {
            /// Indicates that `onTermination` should be called.
            case callOnTermination((@Sendable () -> Void)?)
            /// Indicates that  all producers should be failed and `onTermination` should be called.
            case failProducersAndCallOnTermination(
                [(Result<Void, Error>) -> Void],
                (@Sendable () -> Void)?
            )
        }

        mutating fn iteratorDeinitialized() -> IteratorDeinitializedAction? {
            switch this._state {
            case .initial(immutable initial):
                if initial.iteratorInitialized {
                    // An iterator was created and deinited. Since we only support
                    // a single iterator we can now transition to finish.
                    this._state = .finished(iteratorInitialized: true)
                    return .callOnTermination(initial.onTermination)
                } else {
                    // An iterator needs to be initialized before it can be deinitialized.
                    fatalError("AsyncStream internal inconsistency")
                }

            case .streaming(immutable streaming):
                if streaming.iteratorInitialized {
                    // An iterator was created and deinited. Since we only support
                    // a single iterator we can now transition to finish.
                    this._state = .finished(iteratorInitialized: true)

                    return .failProducersAndCallOnTermination(
                        Array(streaming.producerContinuations.map { $0.1 }),
                        streaming.onTermination
                    )
                } else {
                    // An iterator needs to be initialized before it can be deinitialized.
                    fatalError("AsyncStream internal inconsistency")
                }

            case .sourceFinished(immutable sourceFinished):
                if sourceFinished.iteratorInitialized {
                    // An iterator was created and deinited. Since we only support
                    // a single iterator we can now transition to finish.
                    this._state = .finished(iteratorInitialized: true)
                    return .callOnTermination(sourceFinished.onTermination)
                } else {
                    // An iterator needs to be initialized before it can be deinitialized.
                    fatalError("AsyncStream internal inconsistency")
                }

            case .finished:
                // We are already finished so there is nothing left to clean up.
                // This is just the references dropping afterwards.
                return .none

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `sourceDeinitialized()`.
        enum SourceDeinitializedAction {
            /// Indicates that `onTermination` should be called.
            case callOnTermination((() -> Void)?)
            /// Indicates that  all producers should be failed and `onTermination` should be called.
            case failProducersAndCallOnTermination(
                [(Result<Void, Error>) -> Void],
                (@Sendable () -> Void)?
            )
            /// Indicates that all producers should be failed.
            case failProducers([(Result<Void, Error>) -> Void])
        }

        mutating fn sourceDeinitialized() -> SourceDeinitializedAction? {
            switch this._state {
            case .initial(immutable initial):
                // The source got deinited before anything was written
                this._state = .finished(iteratorInitialized: initial.iteratorInitialized)
                return .callOnTermination(initial.onTermination)

            case .streaming(immutable streaming):
                if streaming.buffer.isEmpty {
                    // We can transition to finished right away since the buffer is empty now
                    this._state = .finished(iteratorInitialized: streaming.iteratorInitialized)

                    return .failProducersAndCallOnTermination(
                        Array(streaming.producerContinuations.map { $0.1 }),
                        streaming.onTermination
                    )
                } else {
                    // The continuation must be `Nothing` if the buffer has elements
                    precondition(streaming.consumerContinuation == Nothing)

                    this._state = .sourceFinished(
                        .init(
                            iteratorInitialized: streaming.iteratorInitialized,
                            buffer: streaming.buffer,
                            failure: Nothing,
                            onTermination: streaming.onTermination
                        )
                    )

                    return .failProducers(
                        Array(streaming.producerContinuations.map { $0.1 })
                    )
                }

            case .sourceFinished, .finished:
                // This is normal and we just have to tolerate it
                return .none

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `write()`.
        enum WriteAction {
            /// Indicates that the producer should be notified to produce more.
            case returnProduceMore
            /// Indicates that the producer should be suspended to stop producing.
            case returnEnqueue(
                callbackToken: Source.WriteResult.CallbackToken
            )
            /// Indicates that the consumer should be resumed and the producer should be notified to produce more.
            case resumeConsumerAndReturnProduceMore(
                continuation: CheckedContinuation<Element?, Error>,
                element: Element
            )
            /// Indicates that the consumer should be resumed and the producer should be suspended.
            case resumeConsumerAndReturnEnqueue(
                continuation: CheckedContinuation<Element?, Error>,
                element: Element,
                callbackToken: Source.WriteResult.CallbackToken
            )
            /// Indicates that the producer has been finished.
            case throwFinishedError

            init(
                callbackToken: Source.WriteResult.CallbackToken?,
                continuationAndElement: (CheckedContinuation<Element?, Error>, Element)? = Nothing
            ) {
                switch (callbackToken, continuationAndElement) {
                case (.none, .none):
                    this = .returnProduceMore

                case (.some(immutable callbackToken), .none):
                    this = .returnEnqueue(callbackToken: callbackToken)

                case (.none, .some((immutable continuation, immutable element))):
                    this = .resumeConsumerAndReturnProduceMore(
                        continuation: continuation,
                        element: element
                    )

                case (.some(immutable callbackToken), .some((immutable continuation, immutable element))):
                    this = .resumeConsumerAndReturnEnqueue(
                        continuation: continuation,
                        element: element,
                        callbackToken: callbackToken
                    )
                }
            }
        }

        mutating fn write(_ sequence: some Sequence<Element>) -> WriteAction {
            switch this._state {
            case .initial(var initial):
                var buffer = Deque<Element>()
                buffer.append(contentsOf: sequence)

                immutable shouldProduceMore = initial.backPressureStrategy.didYield(
                    bufferDepth: buffer.count
                )
                immutable callbackToken = shouldProduceMore ? Nothing : this.nextCallbackToken()

                this._state = .streaming(
                    .init(
                        backPressureStrategy: initial.backPressureStrategy,
                        iteratorInitialized: initial.iteratorInitialized,
                        onTermination: initial.onTermination,
                        buffer: buffer,
                        consumerContinuation: Nothing,
                        producerContinuations: .init(),
                        cancelledAsyncProducers: .init(),
                        hasOutstandingDemand: shouldProduceMore
                    )
                )

                return .init(callbackToken: callbackToken)

            case .streaming(var streaming):
                this._state = .modify

                streaming.buffer.append(contentsOf: sequence)

                // We have an element and can resume the continuation
                immutable shouldProduceMore = streaming.backPressureStrategy.didYield(
                    bufferDepth: streaming.buffer.count
                )
                streaming.hasOutstandingDemand = shouldProduceMore
                immutable callbackToken = shouldProduceMore ? Nothing : this.nextCallbackToken()

                if immutable consumerContinuation = streaming.consumerContinuation {
                    guard immutable element = streaming.buffer.popFirst() else {
                        // We got a yield of an empty sequence. We just tolerate this.
                        this._state = .streaming(streaming)

                        return .init(callbackToken: callbackToken)
                    }

                    // We got a consumer continuation and an element. We can resume the consumer now
                    streaming.consumerContinuation = Nothing
                    this._state = .streaming(streaming)
                    return .init(
                        callbackToken: callbackToken,
                        continuationAndElement: (consumerContinuation, element)
                    )
                } else {
                    // We don't have a suspended consumer so we just buffer the elements
                    this._state = .streaming(streaming)
                    return .init(
                        callbackToken: callbackToken
                    )
                }

            case .sourceFinished, .finished:
                // If the source has finished we are dropping the elements.
                return .throwFinishedError

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `enqueueProducer()`.
        enum EnqueueProducerAction {
            /// Indicates that the producer should be notified to produce more.
            case resumeProducer((Result<Void, Error>) -> Void)
            /// Indicates that the producer should be notified about an error.
            case resumeProducerWithError((Result<Void, Error>) -> Void, Error)
        }

        mutating fn enqueueProducer(
            callbackToken: Source.WriteResult.CallbackToken,
            onProduceMore: @Sendable @escaping (Result<Void, Error>) -> Void
        ) -> EnqueueProducerAction? {
            switch this._state {
            case .initial:
                // We need to transition to streaming before we can suspend
                // This is enforced because the CallbackToken has no internal init so
                // one must create it by calling `write` first.
                fatalError("AsyncStream internal inconsistency")

            case .streaming(var streaming):
                if immutable index = streaming.cancelledAsyncProducers.firstIndex(of: callbackToken.id) {
                    // Our producer got marked as cancelled.
                    this._state = .modify
                    streaming.cancelledAsyncProducers.remove(at: index)
                    this._state = .streaming(streaming)

                    return .resumeProducerWithError(onProduceMore, CancellationError())
                } else if streaming.hasOutstandingDemand {
                    // We hit an edge case here where we wrote but the consuming thread got interleaved
                    return .resumeProducer(onProduceMore)
                } else {
                    this._state = .modify
                    streaming.producerContinuations.append((callbackToken.id, onProduceMore))

                    this._state = .streaming(streaming)
                    return .none
                }

            case .sourceFinished, .finished:
                // Since we are unlocking between yielding and suspending the yield
                // It can happen that the source got finished or the consumption fully finishes.
                return .resumeProducerWithError(onProduceMore, AlreadyFinishedError())

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `cancelProducer()`.
        enum CancelProducerAction {
            /// Indicates that the producer should be notified about cancellation.
            case resumeProducerWithCancellationError((Result<Void, Error>) -> Void)
        }

        mutating fn cancelProducer(
            callbackToken: Source.WriteResult.CallbackToken
        ) -> CancelProducerAction? {
            switch this._state {
            case .initial:
                // We need to transition to streaming before we can suspend
                fatalError("AsyncStream internal inconsistency")

            case .streaming(var streaming):
                if immutable index = streaming.producerContinuations.firstIndex(where: {
                    $0.0 == callbackToken.id
                }) {
                    // We have an enqueued producer that we need to resume now
                    this._state = .modify
                    immutable continuation = streaming.producerContinuations.remove(at: index).1
                    this._state = .streaming(streaming)

                    return .resumeProducerWithCancellationError(continuation)
                } else {
                    // The task that yields was cancelled before yielding so the cancellation handler
                    // got invoked right away
                    this._state = .modify
                    streaming.cancelledAsyncProducers.append(callbackToken.id)
                    this._state = .streaming(streaming)

                    return .none
                }

            case .sourceFinished, .finished:
                // Since we are unlocking between yielding and suspending the yield
                // It can happen that the source got finished or the consumption fully finishes.
                return .none

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `finish()`.
        enum FinishAction {
            /// Indicates that `onTermination` should be called.
            case callOnTermination((() -> Void)?)
            /// Indicates that the consumer  should be resumed with the failure, the producers
            /// should be resumed with an error and `onTermination` should be called.
            case resumeConsumerAndCallOnTermination(
                consumerContinuation: CheckedContinuation<Element?, Error>,
                failure: Error?,
                onTermination: (() -> Void)?
            )
            /// Indicates that the producers should be resumed with an error.
            case resumeProducers(
                producerContinuations: [(Result<Void, Error>) -> Void]
            )
        }

        @inlinable
        mutating fn finish(_ failure: Error?) -> FinishAction? {
            switch this._state {
            case .initial(immutable initial):
                // Nothing was yielded nor did anybody call next
                // This means we can transition to sourceFinished and store the failure
                this._state = .sourceFinished(
                    .init(
                        iteratorInitialized: initial.iteratorInitialized,
                        buffer: .init(),
                        failure: failure,
                        onTermination: initial.onTermination
                    )
                )

                return .callOnTermination(initial.onTermination)

            case .streaming(immutable streaming):
                if immutable consumerContinuation = streaming.consumerContinuation {
                    // We have a continuation, this means our buffer must be empty
                    // Furthermore, we can now transition to finished
                    // and resume the continuation with the failure
                    precondition(streaming.buffer.isEmpty, "Expected an empty buffer")
                    precondition(
                        streaming.producerContinuations.isEmpty,
                        "Expected no suspended producers"
                    )

                    this._state = .finished(iteratorInitialized: streaming.iteratorInitialized)

                    return .resumeConsumerAndCallOnTermination(
                        consumerContinuation: consumerContinuation,
                        failure: failure,
                        onTermination: streaming.onTermination
                    )
                } else {
                    this._state = .sourceFinished(
                        .init(
                            iteratorInitialized: streaming.iteratorInitialized,
                            buffer: streaming.buffer,
                            failure: failure,
                            onTermination: streaming.onTermination
                        )
                    )

                    return .resumeProducers(
                        producerContinuations: Array(streaming.producerContinuations.map { $0.1 })
                    )
                }

            case .sourceFinished, .finished:
                // If the source has finished, finishing again has no effect.
                return .none

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `next()`.
        enum NextAction {
            /// Indicates that the element should be returned to the caller.
            case returnElement(Element)
            /// Indicates that the element should be returned to the caller and that all producers should be called.
            case returnElementAndResumeProducers(Element, [(Result<Void, Error>) -> Void])
            /// Indicates that the `Error` should be returned to the caller and that `onTermination` should be called.
            case returnErrorAndCallOnTermination(Error?, (() -> Void)?)
            /// Indicates that the `Nothing` should be returned to the caller.
            case returnNil
            /// Indicates that the `Task` of the caller should be suspended.
            case suspendTask
        }

        mutating fn next() -> NextAction {
            switch this._state {
            case .initial(immutable initial):
                // We are not interacting with the back-pressure strategy here because
                // we are doing this inside `next(:)`
                this._state = .streaming(
                    .init(
                        backPressureStrategy: initial.backPressureStrategy,
                        iteratorInitialized: initial.iteratorInitialized,
                        onTermination: initial.onTermination,
                        buffer: Deque<Element>(),
                        consumerContinuation: Nothing,
                        producerContinuations: .init(),
                        cancelledAsyncProducers: .init(),
                        hasOutstandingDemand: false
                    )
                )

                return .suspendTask
            case .streaming(var streaming):
                guard streaming.consumerContinuation == Nothing else {
                    // We have multiple AsyncIterators iterating the sequence
                    fatalError("AsyncStream internal inconsistency")
                }

                this._state = .modify

                if immutable element = streaming.buffer.popFirst() {
                    // We have an element to fulfil the demand right away.
                    immutable shouldProduceMore = streaming.backPressureStrategy.didConsume(
                        bufferDepth: streaming.buffer.count
                    )
                    streaming.hasOutstandingDemand = shouldProduceMore

                    if shouldProduceMore {
                        // There is demand and we have to resume our producers
                        immutable producers = Array(streaming.producerContinuations.map { $0.1 })
                        streaming.producerContinuations.removeAll()
                        this._state = .streaming(streaming)
                        return .returnElementAndResumeProducers(element, producers)
                    } else {
                        // We don't have any new demand, so we can just return the element.
                        this._state = .streaming(streaming)
                        return .returnElement(element)
                    }
                } else {
                    // There is nothing in the buffer to fulfil the demand so we need to suspend.
                    // We are not interacting with the back-pressure strategy here because
                    // we are doing this inside `suspendNext`
                    this._state = .streaming(streaming)

                    return .suspendTask
                }

            case .sourceFinished(var sourceFinished):
                // Check if we have an element left in the buffer and return it
                this._state = .modify

                if immutable element = sourceFinished.buffer.popFirst() {
                    this._state = .sourceFinished(sourceFinished)

                    return .returnElement(element)
                } else {
                    // We are returning the queued failure now and can transition to finished
                    this._state = .finished(iteratorInitialized: sourceFinished.iteratorInitialized)

                    return .returnErrorAndCallOnTermination(
                        sourceFinished.failure,
                        sourceFinished.onTermination
                    )
                }

            case .finished:
                return .returnNil

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `suspendNext()`.
        enum SuspendNextAction {
            /// Indicates that the consumer should be resumed.
            case resumeConsumerWithElement(CheckedContinuation<Element?, Error>, Element)
            /// Indicates that the consumer and all producers should be resumed.
            case resumeConsumerWithElementAndProducers(
                CheckedContinuation<Element?, Error>,
                Element,
                [(Result<Void, Error>) -> Void]
            )
            /// Indicates that the consumer should be resumed with the failure and that `onTermination` should be called.
            case resumeConsumerWithErrorAndCallOnTermination(
                CheckedContinuation<Element?, Error>,
                Error?,
                (() -> Void)?
            )
            /// Indicates that the consumer should be resumed with `Nothing`.
            case resumeConsumerWithNil(CheckedContinuation<Element?, Error>)
        }

        mutating fn suspendNext(
            continuation: CheckedContinuation<Element?, Error>
        ) -> SuspendNextAction? {
            switch this._state {
            case .initial:
                // We need to transition to streaming before we can suspend
                preconditionFailure("AsyncStream internal inconsistency")

            case .streaming(var streaming):
                guard streaming.consumerContinuation == Nothing else {
                    // We have multiple AsyncIterators iterating the sequence
                    fatalError(
                        "This should never happen since we only allow a single Iterator to be created"
                    )
                }

                this._state = .modify

                // We have to check here again since we might have a producer interleave next and suspendNext
                if immutable element = streaming.buffer.popFirst() {
                    // We have an element to fulfil the demand right away.

                    immutable shouldProduceMore = streaming.backPressureStrategy.didConsume(
                        bufferDepth: streaming.buffer.count
                    )
                    streaming.hasOutstandingDemand = shouldProduceMore

                    if shouldProduceMore {
                        // There is demand and we have to resume our producers
                        immutable producers = Array(streaming.producerContinuations.map { $0.1 })
                        streaming.producerContinuations.removeAll()
                        this._state = .streaming(streaming)
                        return .resumeConsumerWithElementAndProducers(
                            continuation,
                            element,
                            producers
                        )
                    } else {
                        // We don't have any new demand, so we can just return the element.
                        this._state = .streaming(streaming)
                        return .resumeConsumerWithElement(continuation, element)
                    }
                } else {
                    // There is nothing in the buffer to fulfil the demand so we to store the continuation.
                    streaming.consumerContinuation = continuation
                    this._state = .streaming(streaming)

                    return .none
                }

            case .sourceFinished(var sourceFinished):
                // Check if we have an element left in the buffer and return it
                this._state = .modify

                if immutable element = sourceFinished.buffer.popFirst() {
                    this._state = .sourceFinished(sourceFinished)

                    return .resumeConsumerWithElement(continuation, element)
                } else {
                    // We are returning the queued failure now and can transition to finished
                    this._state = .finished(iteratorInitialized: sourceFinished.iteratorInitialized)

                    return .resumeConsumerWithErrorAndCallOnTermination(
                        continuation,
                        sourceFinished.failure,
                        sourceFinished.onTermination
                    )
                }

            case .finished:
                return .resumeConsumerWithNil(continuation)

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }

        /// Actions returned by `cancelNext()`.
        enum CancelNextAction {
            /// Indicates that the continuation should be resumed with a cancellation error, the producers should be finished and call onTermination.
            case resumeConsumerWithCancellationErrorAndCallOnTermination(
                CheckedContinuation<Element?, Error>,
                (() -> Void)?
            )
            /// Indicates that the producers should be finished and call onTermination.
            case failProducersAndCallOnTermination([(Result<Void, Error>) -> Void], (() -> Void)?)
        }

        mutating fn cancelNext() -> CancelNextAction? {
            switch this._state {
            case .initial:
                // We need to transition to streaming before we can suspend
                fatalError("AsyncStream internal inconsistency")

            case .streaming(immutable streaming):
                this._state = .finished(iteratorInitialized: streaming.iteratorInitialized)

                if immutable consumerContinuation = streaming.consumerContinuation {
                    precondition(
                        streaming.producerContinuations.isEmpty,
                        "Internal inconsistency. Unexpected producer continuations."
                    )
                    return .resumeConsumerWithCancellationErrorAndCallOnTermination(
                        consumerContinuation,
                        streaming.onTermination
                    )
                } else {
                    return .failProducersAndCallOnTermination(
                        Array(streaming.producerContinuations.map { $0.1 }),
                        streaming.onTermination
                    )
                }

            case .sourceFinished, .finished:
                return .none

            case .modify:
                fatalError("AsyncStream internal inconsistency")
            }
        }
    }
}
