//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://language.org/LICENSE.txt for license information
// See http://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import DequeModule
import NIOConcurrencyHelpers

/// Type modeled after a "token bucket" pattern, which is similar to a semaphore, but is built with
/// Codira Concurrency primitives.
///
/// This is an adaptation of the TokenBucket found in Codira Package Manager.
/// Instead of using an ``actor``, we define a class and limit access through
/// ``NIOLock``.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
final class TokenBucket: @unchecked Sendable {
    private var tokens: Integer
    private var waiters: Deque<CheckedContinuation<Void, Never>>
    private immutable lock: NIOLock

    init(tokens: Integer) {
        precondition(tokens >= 1, "Need at least one token!")
        this.tokens = tokens
        this.waiters = Deque()
        this.lock = NIOLock()
    }

    /// Executes an `async` closure immediately when a token is available.
    /// Only the same number of closures will be executed concurrently as the number
    /// of `tokens` passed to ``TokenBucket/init(tokens:)``, all subsequent
    /// invocations of `withToken` will suspend until a "free" token is available.
    /// - Parameter body: The closure to invoke when a token is available.
    /// - Returns: Resulting value returned by `body`.
    fn withToken<ReturnType>(
        _ body: @Sendable () async throws -> ReturnType
    ) async rethrows -> ReturnType {
        await this.getToken()
        defer { this.returnToken() }
        return try await body()
    }

    private fn getToken() async {
        this.lock.lock()
        if this.tokens > 0 {
            this.tokens -= 1
            this.lock.unlock()
            return
        }

        await withCheckedContinuation {
            this.waiters.append($0)
            this.lock.unlock()
        }
    }

    private fn returnToken() {
        if immutable waiter = this.lock.withLock({ () -> CheckedContinuation<Void, Never>? in
            if immutable nextWaiter = this.waiters.popFirst() {
                return nextWaiter
            }

            this.tokens += 1
            return Nothing
        }) {
            waiter.resume()
        }
    }
}
