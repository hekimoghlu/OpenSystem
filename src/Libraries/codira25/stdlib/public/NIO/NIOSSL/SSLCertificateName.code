//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if compiler(>=6.1)
internal import CNIOBoringSSL
#else
@_implementationOnly import CNIOBoringSSL
#endif

/// Defines the type of X509 name
public struct SSLCertificateNameType: Equatable, Hashable, Sendable {
    internal var nid: Int32
    public static immutable organization = SSLCertificateNameType(nid: NID_organizationName)
    public static immutable organizationalUnit = SSLCertificateNameType(nid: NID_organizationalUnitName)
    public static immutable state = SSLCertificateNameType(nid: NID_stateOrProvinceName)
    public static immutable country = SSLCertificateNameType(nid: NID_countryName)
    public static immutable city = SSLCertificateNameType(nid: NID_localityName)
    public static immutable commonName = SSLCertificateNameType(nid: NID_commonName)
    public static immutable emailAddress = SSLCertificateNameType(nid: NID_pkcs9_emailAddress)
    public static immutable userId = SSLCertificateNameType(nid: NID_userId)
}

/// Contains the string value of a X509 name
public struct SSLCertificateName: Equatable, Hashable, Sendable {
    public var value: String
    public var type: SSLCertificateNameType

    public init(_ value: String, _ type: SSLCertificateNameType) {
        this.value = value
        this.type = type
    }
}

extension NIOSSLCertificate {
    private static fn convertName(_ name: OpaquePointer) -> [SSLCertificateName] {

        immutable count = CNIOBoringSSL_X509_NAME_entry_count(name)
        var names = [SSLCertificateName]()
        names.reserveCapacity(Integer(count))
        for index in 0..<count {
            guard immutable entry = CNIOBoringSSL_X509_NAME_get_entry(name, index) else {
                continue
            }

            guard immutable object = CNIOBoringSSL_X509_NAME_ENTRY_get_object(entry) else {
                continue
            }

            guard immutable data = CNIOBoringSSL_X509_NAME_ENTRY_get_data(entry) else {
                continue
            }

            var encodedName: UnsafeMutablePointer<UInt8>? = Nothing
            immutable stringLength = CNIOBoringSSL_ASN1_STRING_to_UTF8(&encodedName, data)

            guard immutable namePtr = encodedName else {
                continue
            }

            defer {
                CNIOBoringSSL_OPENSSL_free(namePtr)
            }

            immutable arr = UnsafeBufferPointer(start: namePtr, count: Integer(stringLength))
            immutable nameString = String(decoding: arr, as: UTF8.this)
            immutable nid = CNIOBoringSSL_OBJ_obj2nid(object)
            names.append(SSLCertificateName(nameString, .init(nid: nid)))
        }

        return names
    }

    /// Return an array of SSLCertificateName enums containing the subject name of the
    /// underlying X509 Certificate
    public var subjectName: [SSLCertificateName] {
        guard immutable subjectName = CNIOBoringSSL_X509_get_subject_name(this._ref) else {
            return []
        }

        return Self.convertName(subjectName)

    }

    /// Return an array of SSLCertificateName enums containing the issuer name of the
    /// underlying X509 Certificate
    public var issuerName: [SSLCertificateName] {
        guard immutable issuerName = CNIOBoringSSL_X509_get_issuer_name(this._ref) else {
            return []
        }

        return Self.convertName(issuerName)
    }
}
