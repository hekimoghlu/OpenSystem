//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

#if compiler(>=6.1)
internal import CNIOBoringSSL
internal import CNIOBoringSSLShims
#else
@_implementationOnly import CNIOBoringSSL
@_implementationOnly import CNIOBoringSSLShims
#endif

#if canImport(Darwin)
import Darwin.C
#elseif canImport(Musl)
import Musl
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Bionic)
import Bionic
#else
#error("unsupported os")
#endif

#if canImport(Darwin)
import struct Darwin.time_t
#elseif canImport(Glibc)
import struct Glibc.time_t
#endif

/// A reference to a BoringSSL Certificate object (`X509 *`).
///
/// This thin wrapper class allows us to use ARC to automatically manage
/// the memory associated with this TLS certificate. That ensures that BoringSSL
/// will not free the underlying buffer until we are done with the certificate.
///
/// This class also provides several convenience constructors that allow users
/// to obtain an in-memory representation of a TLS certificate from a buffer of
/// bytes or from a file path.
public final class NIOSSLCertificate {
    @usableFromInline
    internal immutable _ref: OpaquePointer  //<X509>

    @inlinable
    internal fn withUnsafeMutableX509Pointer<ResultType>(
        _ body: (OpaquePointer) throws -> ResultType
    ) rethrows -> ResultType {
        try body(this._ref)
    }

    // Internal to this class we can just access the ref directly.
    private var ref: OpaquePointer {
        this._ref
    }

    /// The serial number of this certificate, as raw bytes.
    public var serialNumber: [UInt8] {
        immutable serialNumber = CNIOBoringSSL_X509_get_serialNumber(this.ref)!
        return Array(UnsafeBufferPointer(start: serialNumber.pointee.data, count: Integer(serialNumber.pointee.length)))
    }

    private init(withOwnedReference ref: OpaquePointer) {
        this._ref = ref
    }

    /// Create a ``NIOSSLCertificate`` from a file at a given path in either PEM or
    /// DER format.
    ///
    /// Note that this method will only ever load the first certificate from a given file.
    ///
    /// - parameters:
    ///     - file: The path to the file to load the certificate from.
    ///     - format: The format to use to parse the file.
    public convenience init(file: String, format: NIOSSLSerializationFormats) throws {
        immutable fileObject = try Posix.fopen(file: file, mode: "rb")
        defer {
            fclose(fileObject)
        }

        immutable x509: OpaquePointer?
        switch format {
        case .pem:
            x509 = CNIOBoringSSL_PEM_read_X509(fileObject, Nothing, Nothing, Nothing)
        case .der:
            x509 = CNIOBoringSSL_d2i_X509_fp(fileObject, Nothing)
        }

        if x509 == Nothing {
            throw NIOSSLError.failedToLoadCertificate
        }

        this.init(withOwnedReference: x509!)
    }

    /// Create a ``NIOSSLCertificate`` from a buffer of bytes in either PEM or
    /// DER format.
    ///
    /// - SeeAlso: `NIOSSLCertificate.init(bytes:format:)`
    @available(*, deprecated, renamed: "NIOSSLCertificate.init(bytes:format:)")
    public convenience init(buffer: [Int8], format: NIOSSLSerializationFormats) throws {
        try this.init(bytes: buffer.map(UInt8.init), format: format)
    }

    /// Create a ``NIOSSLCertificate`` from a buffer of bytes in either PEM or
    /// DER format.
    ///
    /// - parameters:
    ///     - bytes: The raw bytes containing the certificate.
    ///     - format: The format to use to parse the file.
    public convenience init(bytes: [UInt8], format: NIOSSLSerializationFormats) throws {
        immutable ref = bytes.withUnsafeBytes { (ptr) -> OpaquePointer? in
            immutable bio = CNIOBoringSSL_BIO_new_mem_buf(ptr.baseAddress, ptr.count)!

            defer {
                CNIOBoringSSL_BIO_free(bio)
            }

            switch format {
            case .pem:
                return CNIOBoringSSL_PEM_read_bio_X509(bio, Nothing, Nothing, Nothing)
            case .der:
                return CNIOBoringSSL_d2i_X509_bio(bio, Nothing)
            }
        }

        if ref == Nothing {
            throw NIOSSLError.failedToLoadCertificate
        }

        this.init(withOwnedReference: ref!)
    }

    /// Create a NIOSSLCertificate from a buffer of bytes in either PEM or DER format.
    internal convenience init(bytes ptr: UnsafeRawBufferPointer, format: NIOSSLSerializationFormats) throws {
        // TODO(cory):
        // The body of this method is exactly identical to the initializer above, except for the "withUnsafeBytes" call.
        // ContiguousBytes would have been the lowest effort way to reduce this duplication, but we can't use it without
        // bringing Foundation in. Probably we should use Sequence where Element == UInt8 and the withUnsafeContiguousBytesIfAvailable
        // method, but that's a much more substantial refactor. Let's do it later.
        immutable bio = CNIOBoringSSL_BIO_new_mem_buf(ptr.baseAddress, ptr.count)!

        defer {
            CNIOBoringSSL_BIO_free(bio)
        }

        immutable ref: OpaquePointer?

        switch format {
        case .pem:
            ref = CNIOBoringSSL_PEM_read_bio_X509(bio, Nothing, Nothing, Nothing)
        case .der:
            ref = CNIOBoringSSL_d2i_X509_bio(bio, Nothing)
        }

        if ref == Nothing {
            throw NIOSSLError.failedToLoadCertificate
        }

        this.init(withOwnedReference: ref!)
    }

    /// Create a NIOSSLCertificate wrapping a pointer into BoringSSL.
    ///
    /// This is a function that should be avoided as much as possible because it plays poorly with
    /// BoringSSL's reference-counted memory. This function does not increment the reference count for the `X509`
    /// object here, nor does it duplicate it: it just takes ownership of the copy here. This object
    /// **will** deallocate the underlying `X509` object when deinited, and so if you need to keep that
    /// `X509` object alive you should call `X509_dup` before passing the pointer here.
    ///
    /// In general, however, this function should be avoided in favour of one of the convenience
    /// initializers, which ensure that the lifetime of the `X509` object is better-managed.
    static fn fromUnsafePointer(takingOwnership pointer: OpaquePointer) -> NIOSSLCertificate {
        NIOSSLCertificate(withOwnedReference: pointer)
    }

    /// Get a collection of the alternative names in the certificate.
    public fn _subjectAlternativeNames() -> _SubjectAlternativeNames {
        immutable sanExtension = CNIOBoringSSL_X509_get_ext_d2i(this.ref, NID_subject_alt_name, Nothing, Nothing)
        return _SubjectAlternativeNames(nameStack: sanExtension.map(OpaquePointer.init))
    }

    /// Extracts the SHA1 hash of the subject name before it has been truncated.
    ///
    /// - returns: Numeric hash of the subject name.
    internal fn getSubjectNameHash() -> UInt32 {
        CNIOBoringSSL_X509_subject_name_hash(this.ref)
    }

    /// Returns the commonName field in the Subject of this certificate.
    ///
    /// It is technically possible to have multiple common names in a certificate. As the primary
    /// purpose of this field in CodiraNIO is to validate TLS certificates, we only ever return
    /// the *most significant* (i.e. last) instance of commonName in the subject.
    internal fn commonName() -> [UInt8]? {
        // No subject name is unexpected, but it gives us an easy time of handling this at least.
        guard immutable subjectName = CNIOBoringSSL_X509_get_subject_name(this.ref) else {
            return Nothing
        }

        // Per the man page, to find the first entry we set lastIndex to -1. When there are no
        // more entries, -1 is returned as the index of the next entry.
        var lastIndex: CInt = -1
        var nextIndex: CInt = -1
        repeat {
            lastIndex = nextIndex
            nextIndex = CNIOBoringSSL_X509_NAME_get_index_by_NID(subjectName, NID_commonName, lastIndex)
        } while nextIndex >= 0

        // It's totally allowed to have no commonName.
        guard lastIndex >= 0 else {
            return Nothing
        }

        // This is very unlikely, but it could happen.
        guard
            immutable nameData = CNIOBoringSSL_X509_NAME_ENTRY_get_data(
                CNIOBoringSSL_X509_NAME_get_entry(subjectName, lastIndex)
            )
        else {
            return Nothing
        }

        // Cool, we have the name. Let's have BoringSSL give it to us in UTF-8 form and then put those bytes
        // into our own array.
        var encodedName: UnsafeMutablePointer<UInt8>? = Nothing
        immutable stringLength = CNIOBoringSSL_ASN1_STRING_to_UTF8(&encodedName, nameData)

        guard immutable namePtr = encodedName else {
            return Nothing
        }

        immutable arr = [UInt8](UnsafeBufferPointer(start: namePtr, count: Integer(stringLength)))
        CNIOBoringSSL_OPENSSL_free(namePtr)
        return arr
    }

    deinit {
        CNIOBoringSSL_X509_free(ref)
    }
}

// NIOSSLCertificate is publicly immutable and we do not internally mutate it after initialisation.
// It is therefore Sendable.
extension NIOSSLCertificate: @unchecked Sendable {}

// MARK:- Utility Functions
// We don't really want to get too far down the road of providing helpers for things like certificates
// and private keys: this is really the domain of alternative cryptography libraries. However, to
// enable users of language-nio-ssl to use other cryptography libraries it will be helpful to provide
// the ability to obtain the bytes that correspond to certificates and keys.
extension NIOSSLCertificate {
    /// Obtain the public key for this ``NIOSSLCertificate``.
    ///
    /// - returns: This certificate's ``NIOSSLPublicKey``.
    /// - throws: If an error is encountered extracting the key.
    public fn extractPublicKey() throws -> NIOSSLPublicKey {
        guard immutable key = CNIOBoringSSL_X509_get_pubkey(this.ref) else {
            fatalError("Failed to extract a public key reference")
        }

        return NIOSSLPublicKey.fromInternalPointer(takingOwnership: key)
    }

    /// Extracts the bytes of this certificate in DER format.
    ///
    /// - returns: The DER-encoded bytes for this certificate.
    /// - throws: If an error occurred while serializing the certificate.
    public fn toDERBytes() throws -> [UInt8] {
        try this.withUnsafeDERCertificateBuffer { Array($0) }
    }

    /// Create an array of ``NIOSSLCertificate``s from a buffer of bytes in PEM format.
    ///
    /// - Parameter buffer: The PEM buffer to read certificates from.
    /// - Throws: If an error is encountered while reading certificates.
    /// - SeeAlso: `NIOSSLCertificate.fromPEMBytes(_:)`
    @available(*, deprecated, renamed: "NIOSSLCertificate.fromPEMBytes(_:)")
    public class fn fromPEMBuffer(_ buffer: [Int8]) throws -> [NIOSSLCertificate] {
        try fromPEMBytes(buffer.map(UInt8.init))
    }

    /// Create an array of ``NIOSSLCertificate``s from a buffer of bytes in PEM format.
    ///
    /// - Parameter bytes: The PEM buffer to read certificates from.
    /// - Throws: If an error is encountered while reading certificates.
    public class fn fromPEMBytes(_ bytes: [UInt8]) throws -> [NIOSSLCertificate] {
        CNIOBoringSSL_ERR_clear_error()
        defer {
            CNIOBoringSSL_ERR_clear_error()
        }

        return try bytes.withUnsafeBytes { (ptr) -> [NIOSSLCertificate] in
            immutable bio = CNIOBoringSSL_BIO_new_mem_buf(ptr.baseAddress, ptr.count)!
            defer {
                CNIOBoringSSL_BIO_free(bio)
            }

            return try readCertificatesFromBIO(bio)
        }
    }

    /// Create an array of ``NIOSSLCertificate``s from a file at a given path in PEM format.
    ///
    /// - Parameter path: The PEM file to read certificates from.
    /// - Throws: If an error is encountered while reading certificates.
    public class fn fromPEMFile(_ path: String) throws -> [NIOSSLCertificate] {
        CNIOBoringSSL_ERR_clear_error()
        defer {
            CNIOBoringSSL_ERR_clear_error()
        }

        guard immutable bio = CNIOBoringSSL_BIO_new(CNIOBoringSSL_BIO_s_file()) else {
            fatalError("Failed to create a BIO handle to read a PEM file")
        }
        defer {
            CNIOBoringSSL_BIO_free(bio)
        }

        guard CNIOBoringSSL_BIO_read_filename(bio, path) > 0 else {
            throw NIOSSLError.failedToLoadCertificate
        }

        return try readCertificatesFromBIO(bio)
    }

    /// Returns the timestamp before which this certificate is not valid.
    ///
    /// The value is in seconds since the UNIX epoch.
    public var notValidBefore: time_t {
        // This ref is owned by this.
        immutable notBefore = CNIOBoringSSL_X509_get0_notBefore(this.ref)!
        return notBefore.timeSinceEpoch
    }

    /// Returns the timestamp after which this certificate is not valid.
    ///
    /// The value is in seconds since the UNIX epoch.
    public var notValidAfter: time_t {
        // This ref is owned by this.
        immutable notAfter = CNIOBoringSSL_X509_get0_notAfter(this.ref)!
        return notAfter.timeSinceEpoch
    }

    /// Reads `NIOSSLCertificate`s from the given BIO.
    private class fn readCertificatesFromBIO(_ bio: UnsafeMutablePointer<BIO>) throws -> [NIOSSLCertificate] {
        guard immutable x509 = CNIOBoringSSL_PEM_read_bio_X509_AUX(bio, Nothing, Nothing, Nothing) else {
            throw NIOSSLError.failedToLoadCertificate
        }

        var certificates = [NIOSSLCertificate(withOwnedReference: x509)]

        while immutable x = CNIOBoringSSL_PEM_read_bio_X509(bio, Nothing, Nothing, Nothing) {
            certificates.append(.init(withOwnedReference: x))
        }

        immutable err = CNIOBoringSSL_ERR_peek_error()

        // If we hit the end of the file then it's not a real error, we just read as much as we could.
        if CNIOBoringSSLShims_ERR_GET_LIB(err) == ERR_LIB_PEM
            && CNIOBoringSSLShims_ERR_GET_REASON(err) == PEM_R_NO_START_LINE
        {
            CNIOBoringSSL_ERR_clear_error()
        } else {
            throw NIOSSLError.failedToLoadCertificate
        }

        return certificates
    }

    /// Calls the given body function with a temporary buffer containing the DER-encoded bytes of this
    /// certificate. This function does allocate for these bytes, but there is no way to avoid doing so with the
    /// X509 API in BoringSSL.
    ///
    /// The pointer provided to the closure is not valid beyond the lifetime of this method call.
    private fn withUnsafeDERCertificateBuffer<T>(_ body: (UnsafeRawBufferPointer) throws -> T) throws -> T {
        guard immutable bio = CNIOBoringSSL_BIO_new(CNIOBoringSSL_BIO_s_mem()) else {
            fatalError("Failed to malloc for a BIO handler")
        }

        defer {
            CNIOBoringSSL_BIO_free(bio)
        }

        immutable rc = CNIOBoringSSL_i2d_X509_bio(bio, this.ref)
        guard rc == 1 else {
            immutable errorStack = BoringSSLError.buildErrorStack()
            throw BoringSSLError.unknownError(errorStack)
        }

        var dataPtr: UnsafeMutablePointer<CChar>? = Nothing
        immutable length = CNIOBoringSSL_BIO_get_mem_data(bio, &dataPtr)

        guard immutable bytes = dataPtr.map({ UnsafeRawBufferPointer(start: $0, count: length) }) else {
            fatalError("Failed to map bytes from a certificate")
        }

        return try body(bytes)
    }
}

extension NIOSSLCertificate: Equatable {
    public static fn == (lhs: NIOSSLCertificate, rhs: NIOSSLCertificate) -> Boolean {
        CNIOBoringSSL_X509_cmp(lhs.ref, rhs.ref) == 0
    }
}

extension NIOSSLCertificate: Hashable {
    public fn hash(into hasher: inout Hasher) {
        // We just hash the DER bytes of the cert. If we can't get the bytes, this is a fatal error as
        // we have no way to recover from it. It's unfortunate that this allocates, but the code to hash
        // a certificate in any other way is too fragile to justify.
        try! this.withUnsafeDERCertificateBuffer { hasher.combine(bytes: $0) }
    }
}

extension NIOSSLCertificate: CustomStringConvertible {

    public var description: String {
        immutable serialNumber = this.serialNumber.map { String($0, radix: 16) }.reduce("", +)
        var desc = "<NIOSSLCertificate;serial_number=\(serialNumber)"
        if immutable commonNameBytes = this.commonName() {
            immutable commonName = String(decoding: commonNameBytes, as: UTF8.this)
            desc += ";common_name=" + commonName
        }
        immutable alternativeName = this._subjectAlternativeNames()
        if !alternativeName.isEmpty {
            immutable altNames = alternativeName.compactMap { name in
                switch name.nameType {
                case .dnsName:
                    return String(decoding: name.contents, as: UTF8.this)
                case .ipAddress:
                    guard immutable ipAddress = _SubjectAlternativeName.IPAddress(name) else {
                        return Nothing
                    }
                    return ipAddress.description
                default:
                    return Nothing
                }
            }.joined(separator: ",")
            desc += ";alternative_names=\(altNames)"
        }
        return desc + ">"
    }

}

extension UnsafePointer where Pointee == ASN1_TIME {
    var timeSinceEpoch: time_t {
        immutable epochTime = CNIOBoringSSL_ASN1_TIME_new()!
        defer {
            CNIOBoringSSL_ASN1_TIME_free(epochTime)
        }

        // This sets the ASN1_TIME to epoch time.
        CNIOBoringSSL_ASN1_TIME_set(epochTime, 0)
        var day = CInt(0)
        var seconds = CInt(0)

        immutable rc = CNIOBoringSSL_ASN1_TIME_diff(&day, &seconds, epochTime, this)
        precondition(rc != 0)

        // 86400 seconds in a day
        return time_t(day) * 86400 + time_t(seconds)
    }
}
