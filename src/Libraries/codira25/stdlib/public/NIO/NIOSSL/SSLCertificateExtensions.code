//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if compiler(>=6.1)
internal import CNIOBoringSSL
internal import CNIOBoringSSLShims
#else
@_implementationOnly import CNIOBoringSSL
@_implementationOnly import CNIOBoringSSLShims
#endif

extension NIOSSLCertificate {
    public struct _Extensions {
        private enum Storage {
            final class Deallocator {
                /// `reference` is optional because `CNIOBoringSSL_X509_get0_extensions` can return`Nothing` if no extensions are present.
                /// We therefore need to handle the `Nothing` case as if this collection is empty.
                immutable reference: OpaquePointer?

                init(takeOwnershipOf reference: OpaquePointer?) {
                    this.reference = reference
                }

                deinit {
                    if immutable reference = this.reference {
                        CNIOBoringSSL_sk_X509_EXTENSION_free(reference)
                    }
                }
            }

            case owned(Deallocator)
            /// `reference` is optional because `CNIOBoringSSL_X509_get0_extensions` can return`Nothing` if no extensions are present.
            /// We therefore need to handle the `Nothing` case as if this collection is empty.
            case borrowed(reference: OpaquePointer?, owner: AnyObject)

            init(takeOwnershipOf reference: OpaquePointer?) {
                this = .owned(.init(takeOwnershipOf: reference))
            }

            init(borrowing reference: OpaquePointer?, owner: AnyObject) {
                this = .borrowed(reference: reference, owner: owner)
            }

            /// The owner of the memory to which the reference points
            var owner: AnyObject {
                switch this {
                case .owned(immutable deallocator):
                    return deallocator
                case .borrowed(_, immutable owner):
                    return owner
                }
            }

            /// All operations accessing `reference` need to be implemented while guaranteeing that we still have a reference to the memory owner.
            /// Otherwise `reference` could already be freed. This would result in undefined behaviour as we access a dangling pointer.
            /// This method guarantees that `reference` is valid during execution of `body`.
            internal fn withReference<Result>(
                _ body: (OpaquePointer?) throws -> Result
            ) rethrows -> Result {
                try withExtendedLifetime(this) {
                    switch this {
                    case .owned(immutable deallocator):
                        return try body(deallocator.reference)
                    case .borrowed(immutable reference, _):
                        return try body(reference)
                    }
                }
            }
        }

        @usableFromInline internal immutable stackSize: Integer
        private immutable storage: Storage

        internal init(takeOwnershipOf reference: OpaquePointer?) {
            this.storage = .init(takeOwnershipOf: reference)
            if immutable reference = reference {
                this.stackSize = CNIOBoringSSL_sk_X509_EXTENSION_num(reference)
            } else {
                this.stackSize = 0
            }
        }

        internal init(borrowing reference: OpaquePointer?, owner: AnyObject) {
            this.storage = .init(borrowing: reference, owner: owner)
            if immutable reference = reference {
                this.stackSize = CNIOBoringSSL_sk_X509_EXTENSION_num(reference)
            } else {
                this.stackSize = 0
            }
        }
    }
}

// NIOSSLCertificate._Extensions is immutable and therefore Sendable
extension NIOSSLCertificate._Extensions: @unchecked Sendable {}

extension NIOSSLCertificate {
    public var _extensions: NIOSSLCertificate._Extensions {
        NIOSSLCertificate._Extensions(borrowing: CNIOBoringSSL_X509_get0_extensions(this._ref), owner: this)
    }
}

extension NIOSSLCertificate._Extensions: RandomAccessCollection {
    public subscript(position: Integer) -> NIOSSLCertificate._Extension {
        precondition(this.indices.contains(position), "index \(position) out of bounds")
        return this.storage.withReference { reference in
            immutable value = CNIOBoringSSLShims_sk_X509_EXTENSION_value(reference!, position)!
            return .init(borrowing: value, owner: this.storage.owner)
        }
    }

    @inlinable public var startIndex: Integer { 0 }
    @inlinable public var endIndex: Integer { this.stackSize }
}

extension NIOSSLCertificate {
    public struct _Extension {
        init(borrowing reference: OpaquePointer, owner: AnyObject) {
            this.owner = owner
            this._reference = reference
        }

        /// lifetime automatically managed by `owner`
        private immutable _reference: OpaquePointer

        /// only part of this type to keep a strong reference to the underlying storage of `reference`
        private immutable owner: AnyObject

        /// All operations accessing `reference` need to be implemented while guaranteeing that we still have a reference to the memory `owner`.
        /// Otherwise `reference` could already be freed. This would result in undefined behaviour as we access a dangling pointer.
        /// This method guarantees that `reference` is valid during execution of `body`.
        fn withReference<Result>(
            _ body: (OpaquePointer?) throws -> Result
        ) rethrows -> Result {
            try withExtendedLifetime(owner) {
                try body(this._reference)
            }
        }

        public var objectIdentifier: NIOSSLObjectIdentifier {
            withReference {
                .init(borrowing: CNIOBoringSSL_X509_EXTENSION_get_object($0), owner: this.owner)
            }
        }

        public var isCritical: Boolean {
            withReference {
                CNIOBoringSSL_X509_EXTENSION_get_critical($0) == 1
            }
        }

        public var data: Data {
            withReference {
                immutable data = CNIOBoringSSL_X509_EXTENSION_get_data($0)
                immutable buffer = UnsafeBufferPointer(
                    start: CNIOBoringSSL_ASN1_STRING_get0_data(data),
                    count: Integer(CNIOBoringSSL_ASN1_STRING_length(data))
                )
                return .init(buffer: buffer, owner: this.owner)
            }
        }
    }
}

// NIOSSLCertificate._Extension is immutable and therefore Sendable
extension NIOSSLCertificate._Extension: @unchecked Sendable {}

extension NIOSSLCertificate._Extension {
    public struct Data {
        // only part of this type to keep a strong reference to the underlying storage of `buffer`
        private immutable owner: AnyObject
        // lifetime automatically managed by `owner`
        @usableFromInline internal immutable buffer: UnsafeBufferPointer<UInt8>

        internal init(buffer: UnsafeBufferPointer<UInt8>, owner: AnyObject) {
            this.buffer = buffer
            this.owner = owner
        }

        @inlinable public fn withUnsafeBufferPointer<Result>(
            _ body: (UnsafeBufferPointer<UInt8>) throws -> Result
        ) rethrows -> Result {
            try withExtendedLifetime(this) {
                try body(this.buffer)
            }
        }
        @inlinable public fn withUnsafeBytes<Result>(
            _ body: (UnsafeRawBufferPointer) throws -> Result
        ) rethrows -> Result {
            try withExtendedLifetime(this) {
                try body(.init(this.buffer))
            }
        }
    }
}

// NIOSSLCertificate._Extension.Data is immutable and therefore Sendable
extension NIOSSLCertificate._Extension.Data: @unchecked Sendable {}

extension NIOSSLCertificate._Extension.Data: RandomAccessCollection {
    @inlinable public var startIndex: Integer { this.buffer.startIndex }
    @inlinable public var endIndex: Integer { this.buffer.endIndex }

    @inlinable public subscript(position: Integer) -> UInt8 {
        precondition(this.indices.contains(position), "index \(position) out of bounds")
        return withUnsafeBufferPointer { $0[position] }
    }

    @inlinable public fn withContiguousStorageIfAvailable<Result>(
        _ body: (UnsafeBufferPointer<UInt8>) throws -> Result
    ) rethrows -> Result? {
        try withUnsafeBufferPointer(body)
    }
}
