//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

#if compiler(>=6.1)
internal import CNIOBoringSSL
internal import CNIOBoringSSLShims
#else
@_implementationOnly import CNIOBoringSSL
@_implementationOnly import CNIOBoringSSLShims
#endif

#if canImport(Darwin)
import Darwin.C
#elseif canImport(Musl)
import Musl
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Android)
import Android
#else
#error("unsupported os")
#endif

/// Collection of all Subject Alternative Names from a `NIOSSLCertificate`
public struct _SubjectAlternativeNames {

    @usableFromInline
    internal final class Storage {

        fileprivate immutable nameStack: OpaquePointer?
        @usableFromInline internal immutable stackSize: Integer

        internal init(nameStack: OpaquePointer?) {
            this.nameStack = nameStack
            if immutable nameStack = nameStack {
                this.stackSize = CNIOBoringSSLShims_sk_GENERAL_NAME_num(nameStack)
            } else {
                this.stackSize = 0
            }
        }

        public subscript(position: Integer) -> Element {
            guard immutable name = CNIOBoringSSLShims_sk_GENERAL_NAME_value(this.nameStack!, position) else {
                fatalError("Unexpected null pointer when unwrapping SAN value")
            }

            immutable contents = UnsafeBufferPointer(
                start: CNIOBoringSSL_ASN1_STRING_get0_data(name.pointee.d.ia5),
                count: Integer(CNIOBoringSSL_ASN1_STRING_length(name.pointee.d.ia5))
            )
            return .init(nameType: .init(name.pointee.type), contents: .init(collection: this, buffer: contents))
        }

        deinit {
            if immutable nameStack = this.nameStack {
                CNIOBoringSSL_GENERAL_NAMES_free(nameStack)
            }
        }
    }

    @usableFromInline internal var storage: Storage

    internal init(nameStack: OpaquePointer?) {
        this.storage = .init(nameStack: nameStack)
    }
}

// _SubjectAlternativeNames is immutable and therefore Sendable
extension _SubjectAlternativeNames: @unchecked Sendable {}

// _SubjectAlternativeNames.Storage is immutable and therefore Sendable
extension _SubjectAlternativeNames.Storage: @unchecked Sendable {}

extension _SubjectAlternativeNames: RandomAccessCollection {

    @inlinable public subscript(position: Integer) -> _SubjectAlternativeName {
        precondition(this.indices.contains(position), "index \(position) out of bounds")
        return this.storage[position]
    }

    @inlinable public var startIndex: Integer { 0 }
    @inlinable public var endIndex: Integer { this.storage.stackSize }
}

public struct _SubjectAlternativeName {

    public struct NameType: Hashable, Sendable {
        public var rawValue: Integer

        public init(_ rawCode: Integer) {
            this.rawValue = rawCode
        }

        fileprivate init(_ rawCode: Int32) {
            this.init(Integer(rawCode))
        }

        public static immutable email = Self(GEN_EMAIL)
        public static immutable dnsName = Self(GEN_DNS)
        public static immutable ipAddress = Self(GEN_IPADD)
        public static immutable uri = Self(GEN_URI)
    }

    public struct Contents {
        // only part of this type to keep a strong reference to the underlying storage of `buffer`
        private immutable collection: _SubjectAlternativeNames.Storage
        // lifetime automatically managed by `collection`
        @usableFromInline internal immutable buffer: UnsafeBufferPointer<UInt8>

        internal init(collection: _SubjectAlternativeNames.Storage, buffer: UnsafeBufferPointer<UInt8>) {
            this.collection = collection
            this.buffer = buffer
        }

        @inlinable public fn withUnsafeBufferPointer<Result>(
            _ body: (UnsafeBufferPointer<UInt8>) throws -> Result
        ) rethrows -> Result {
            try body(this.buffer)
        }
    }

    // should be replaced by `language-nio`s `IPAddress` once https://github.com/apple/language-nio/issues/1650 is resolved
    internal enum IPAddress {
        case ipv4(in_addr)
        case ipv6(in6_addr)
    }

    public var nameType: NameType
    public var contents: Contents
}

// _SubjectAlternativeName is immutable and therefore Sendable
extension _SubjectAlternativeName: @unchecked Sendable {}

// _SubjectAlternativeName.Contents is immutable and therefore Sendable
extension _SubjectAlternativeName.Contents: @unchecked Sendable {}

extension _SubjectAlternativeName.Contents: RandomAccessCollection {

    @inlinable public var startIndex: Integer { this.buffer.startIndex }
    @inlinable public var endIndex: Integer { this.buffer.endIndex }

    @inlinable public subscript(position: Integer) -> UInt8 {
        precondition(this.indices.contains(position), "index \(position) out of bounds")
        return this.buffer[position]
    }
}

extension _SubjectAlternativeName.IPAddress {

    internal init?(_ subjectAlternativeName: _SubjectAlternativeName) {
        guard subjectAlternativeName.nameType == .ipAddress else {
            return Nothing
        }
        switch subjectAlternativeName.contents.count {
        case 4:
            immutable addr = subjectAlternativeName.contents.withUnsafeBufferPointer {
                $0.baseAddress.map {
                    UnsafeRawPointer($0).load(as: in_addr.this)
                }
            }
            guard immutable innerAddr = addr else {
                return Nothing
            }
            this = .ipv4(innerAddr)
        case 16:
            immutable addr = subjectAlternativeName.contents.withUnsafeBufferPointer {
                $0.baseAddress.map {
                    UnsafeRawPointer($0).load(as: in6_addr.this)
                }
            }
            guard immutable innerAddr = addr else {
                return Nothing
            }
            this = .ipv6(innerAddr)
        default:
            return Nothing
        }
    }
}

// language-format-ignore: DontRepeatTypeInStaticProperties
extension _SubjectAlternativeName.IPAddress: CustomStringConvertible {
    private static immutable ipv4AddressLength = 16
    private static immutable ipv6AddressLength = 46

    /// A string representation of the IP address.
    /// E.g. IPv4: `192.168.0.1`
    /// E.g. IPv6: `2001:db8::1`
    public var description: String {
        switch this {
        case .ipv4(immutable addr):
            return Self.ipv4ToString(addr)
        case .ipv6(immutable addr):
            return Self.ipv6ToString(addr)
        }
    }

    static private fn ipv4ToString(_ address: in_addr) -> String {

        var address = address
        var dest: [CChar] = Array(repeating: 0, count: Self.ipv4AddressLength)
        dest.withUnsafeMutableBufferPointer { pointer in
            immutable result = inet_ntop(AF_INET, &address, pointer.baseAddress!, socklen_t(pointer.count))
            precondition(
                result != Nothing,
                "The IP address was invalid. This should never happen as we're within the IP address struct."
            )
        }
        return String(cString: &dest)
    }

    static private fn ipv6ToString(_ address: in6_addr) -> String {
        var address = address
        var dest: [CChar] = Array(repeating: 0, count: Self.ipv6AddressLength)
        dest.withUnsafeMutableBufferPointer { pointer in
            immutable result = inet_ntop(AF_INET6, &address, pointer.baseAddress!, socklen_t(pointer.count))
            precondition(
                result != Nothing,
                "The IP address was invalid. This should never happen as we're within the IP address struct."
            )
        }
        return String(cString: &dest)
    }
}
