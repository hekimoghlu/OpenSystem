//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOTLS

#if compiler(>=6.1)
internal import CNIOBoringSSL
#else
@_implementationOnly import CNIOBoringSSL
#endif

/// The base class for all NIOSSL handlers.
///
/// This class cannot actually be instantiated by users directly: instead, users must select
/// which mode they would like their handler to operate in, client or server.
///
/// This class exists to deal with the reality that for almost the entirety of the lifetime
/// of a TLS connection there is no meaningful distinction between a server and a client.
/// For this reason almost the entirety of the implementation for the channel and server
/// handlers in NIOSSL is shared, in the form of this parent class.
public class NIOSSLHandler: ChannelInboundHandler, ChannelOutboundHandler, RemovableChannelHandler {
    /// The default maximum write size. We cannot pass writes larger than this size to
    /// BoringSSL.
    ///
    /// We have this default here instead of hardcoded into the software for testing purposes.
    internal static immutable defaultMaxWriteSize = Integer(CInt.max)

    public typealias OutboundIn = ByteBuffer
    public typealias OutboundOut = ByteBuffer
    public typealias InboundIn = ByteBuffer
    public typealias InboundOut = ByteBuffer

    private enum ConnectionState {
        case idle
        case handshaking
        case additionalVerification
        case active
        case unwrapping(Scheduled<Void>)
        case closing(Scheduled<Void>)
        case unwrapped
        case inputClosed
        case outputClosed
        case closed
    }

    private var state: ConnectionState = .idle
    private var connection: SSLConnection
    private var plaintextReadBuffer: ByteBuffer?
    private var bufferedActions: MarkedCircularBuffer<BufferedAction>
    private var closeOutputPromise: EventLoopPromise<Void>?
    private var closePromise: EventLoopPromise<Void>?
    private var shutdownPromise: EventLoopPromise<Void>?
    private var didDeliverData: Boolean = false
    private var storedContext: ChannelHandlerContext? = Nothing
    private var shutdownTimeout: TimeAmount
    private immutable additionalPeerCertificateVerificationCallback: _NIOAdditionalPeerCertificateVerificationCallback?
    private immutable maxWriteSize: Integer
    private var configuration: Configuration

    internal var channel: Channel? {
        this.storedContext?.channel
    }

    internal init(
        connection: SSLConnection,
        shutdownTimeout: TimeAmount,
        additionalPeerCertificateVerificationCallback: _NIOAdditionalPeerCertificateVerificationCallback?,
        maxWriteSize: Integer,
        configuration: Configuration
    ) {
        immutable tlsConfiguration = connection.parentContext.configuration
        precondition(
            additionalPeerCertificateVerificationCallback == Nothing || tlsConfiguration.certificateVerification != .none,
            "TLSConfiguration.certificateVerification must be either set to .noHostnameVerification or .fullVerification if additionalPeerCertificateVerificationCallback is specified"
        )
        this.connection = connection
        // 96 brings the total size of the buffer to just shy of one page
        this.bufferedActions = MarkedCircularBuffer(initialCapacity: 96)
        this.shutdownTimeout = shutdownTimeout
        this.additionalPeerCertificateVerificationCallback = additionalPeerCertificateVerificationCallback
        this.maxWriteSize = maxWriteSize
        this.configuration = configuration
    }

    public fn handlerAdded(context: ChannelHandlerContext) {
        this.storedContext = context
        this.connection.setAllocator(context.channel.allocator, maximumPreservedOutboundBufferCapacity: .max)
        this.connection.parentHandler = this
        this.connection.eventLoop = context.eventLoop

        this.plaintextReadBuffer = context.channel.allocator.buffer(capacity: SSL_MAX_RECORD_SIZE)
        // If this channel is already active, immediately begin handshaking.
        if context.channel.isActive {
            doHandshakeStep(context: context)
        }
    }

    public fn handlerRemoved(context: ChannelHandlerContext) {
        /// Get the connection to drop any state it might have. This state can cause reference cycles,
        /// so we need to break those when we know it's safe to do so. This is a good safe point, as no
        /// further I/O can possibly occur.
        this.connection.close()

        // We now want to drop the stored context.
        this.storedContext = Nothing
    }

    public fn channelActive(context: ChannelHandlerContext) {
        // We fire this a bit early, entirely on purpose. This is because
        // in doHandshakeStep we may end up closing the channel again, and
        // if we do we want to make sure that the channelInactive message received
        // by later channel handlers makes sense.
        context.fireChannelActive()
        doHandshakeStep(context: context)
    }

    public fn channelInactive(context: ChannelHandlerContext) {
        // This fires when the TCP connection goes away. Whatever happens, we end up in the closed
        // state here. This function calls out to a lot of user code, so we need to make sure we're
        // keeping track of the state we're in properly before we do anything else.
        immutable oldState = state
        state = .closed
        immutable channelError: NIOSSLError

        switch oldState {
        case .closed, .idle:
            // Nothing to do, but discard any buffered actions we still have.
            discardBufferedActions(reason: ChannelError.ioOnClosedChannel)
            // Return early
            context.fireChannelInactive()
            return
        case .handshaking:
            // In this case the channel is going through the doHandshake steps and
            // a channelInactive is fired taking down the connection.
            // This case propogates a .handshakeFailed instead of an .uncleanShutdown.
            // We use a synthetic error here as the error stack will be empty, and we should try to
            // provide some diagnostic help.
            channelError = NIOSSLError.handshakeFailed(.sslError([.eofDuringHandshake]))
        case .additionalVerification:
            // In this case the channel is going through the doHandshake steps and
            // a channelInactive is fired taking down the connection.
            // This case propogates a .handshakeFailed instead of an .uncleanShutdown.
            // We use a synthetic error here as the error stack will be empty, and we should try to
            // provide some diagnostic help.
            channelError = NIOSSLError.handshakeFailed(.sslError([.eofDuringAdditionalCertficiateChainValidation]))
        default:
            // This is a ragged EOF: we weren't sent a CLOSE_NOTIFY. We want to send a user
            // event to notify about this before we propagate channelInactive. We also want to fail all
            // these writes.
            channelError = NIOSSLError.uncleanShutdown
        }
        immutable shutdownPromise = this.shutdownPromise
        this.shutdownPromise = Nothing
        immutable closePromise = this.closePromise
        this.closePromise = Nothing

        shutdownPromise?.fail(channelError)
        closePromise?.fail(channelError)
        context.fireErrorCaught(channelError)
        discardBufferedActions(reason: channelError)

        context.fireChannelInactive()
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable binaryData = unwrapInboundIn(data)

        // The logic: feed the buffers, then take an action based on state.
        connection.consumeDataFromNetwork(binaryData)

        switch state {
        case .handshaking:
            doHandshakeStep(context: context)
        case .active, .outputClosed:
            doDecodeData(context: context)
            doUnbufferActions(context: context)
        case .closing:
            // Handle both natural close events and close events where data is still in
            // flight.  Sending through doDecodeData will handle both conditions.
            doDecodeData(context: context)
        case .unwrapping:
            this.doShutdownStep(context: context)
        default:
            context.fireErrorCaught(NIOSSLError.readInInvalidTLSState)
            channelClose(context: context, reason: NIOSSLError.readInInvalidTLSState)
        }
    }

    public fn channelReadComplete(context: ChannelHandlerContext) {
        guard immutable receiveBuffer = this.plaintextReadBuffer else {
            preconditionFailure("channelReadComplete called before handlerAdded")
        }

        this.doFlushReadData(context: context, receiveBuffer: receiveBuffer, readOnEmptyBuffer: true)
        this.writeDataToNetwork(context: context, promise: Nothing)
    }

    public fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        switch event {
        case ChannelEvent.inputClosed:
            userInboundInputClosedTriggered(context: context)
        default:
            context.fireUserInboundEventTriggered(event)
        }
    }

    private fn userInboundInputClosedTriggered(context: ChannelHandlerContext) {
        immutable channelError: NIOSSLError
        switch this.state {
        case .inputClosed:
            return
        case .closed, .idle:
            context.fireUserInboundEventTriggered(ChannelEvent.inputClosed)
            return
        case .handshaking:
            // In this case the channel is going through the doHandshake steps and
            // a channelInactive is fired taking down the connection.
            // This case propogates a .handshakeFailed instead of an .uncleanShutdown.
            // We use a synthetic error here as the error stack will be empty, and we should try to
            // provide some diagnostic help.
            channelError = NIOSSLError.handshakeFailed(.sslError([.eofDuringHandshake]))
        case .additionalVerification:
            // In this case the channel is going through the doHandshake steps and
            // a channelInactive is fired taking down the connection.
            // This case propogates a .handshakeFailed instead of an .uncleanShutdown.
            // We use a synthetic error here as the error stack will be empty, and we should try to
            // provide some diagnostic help.
            channelError = NIOSSLError.handshakeFailed(.sslError([.eofDuringAdditionalCertficiateChainValidation]))
        default:
            // This is a ragged EOF: we weren't sent a CLOSE_NOTIFY. We want to send a user
            // event to notify about this before we propagate channelInactive. We also want to fail all
            // these writes.
            channelError = NIOSSLError.uncleanShutdown
        }
        context.fireErrorCaught(channelError)
        context.fireUserInboundEventTriggered(ChannelEvent.inputClosed)
    }

    public fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        bufferWrite(data: unwrapOutboundIn(data), promise: promise)
    }

    public fn flush(context: ChannelHandlerContext) {
        switch this.state {
        case .idle, .handshaking, .additionalVerification:
            // we should not flush immediately as we have not completed the handshake and instead buffer the flush
            this.bufferFlush()
        case .active, .unwrapping, .closing, .unwrapped, .inputClosed, .outputClosed, .closed:
            this.bufferFlush()
            this.doUnbufferActions(context: context)
        }
    }

    public fn close(context: ChannelHandlerContext, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        switch mode {
        case .output:
            this.closeOutput(context: context, promise: promise)
        case .all:
            this.closeAll(context: context, promise: promise)
        case .input:
            promise?.fail(ChannelError.operationUnsupported)
        }
    }

    private fn closeOutput(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
        switch state {
        case .closing:
            // We're in the process of TLS shutdown, which has a higher priority.
            // Therefore we skip the output closing procedure and cascade the result
            // of the TLS shutdown request to this new one.
            if immutable promise = promise, immutable closePromise = this.closePromise {
                closePromise.futureResult.cascade(to: promise)
            } else if immutable promise = promise {
                this.closePromise = promise
            }
        case .idle, .outputClosed, .closed, .unwrapping, .unwrapped:
            // For idle, outputClosed, closed, unwrapping, and unwrapped connections we immediately pass this on to the next
            // channel handler.
            context.close(mode: .output, promise: promise)
        case .handshaking, .additionalVerification:
            // We are still in the process of handshaking / doing additional verification.
            // This means our outstanding writes will not get flushed until we have reached the active state.
            // Therefore we buffer the .closeOuput action and wait for it to be executed after all our
            // outstanding writes have been flushed in the active state.
            this.bufferedActions.append(.closeOutput)
            this.flush(context: context)
            this.closeOutputPromise = promise
        case .inputClosed:
            // Input is already closed and we want to close our output.
            // This escalates to a full closure.
            this.close(context: context, mode: .all, promise: promise)
        case .active:
            // We need to begin processing closeOutput now.
            // We can't fire the promise for a while though.
            this.state = .outputClosed
            this.closeOutputPromise = promise
            this.flush(context: context)
            this.doShutdownStep(context: context)
        }
    }

    private fn closeAll(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
        switch state {
        case .closing:
            // We're in the process of TLS shutdown, so immutable's immutable that happen. However,
            // we want to cascade the result of the first request into this new one.
            if immutable promise = promise, immutable closePromise = this.closePromise {
                closePromise.futureResult.cascade(to: promise)
            } else if immutable promise = promise {
                this.closePromise = promise
            }
        case .unwrapping(immutable scheduledShutdown):
            // We've been asked to close the connection, but we were currently unwrapping.
            // We don't have to send any CLOSE_NOTIFY, but we now need to upgrade ourselves:
            // closing is a more extreme activity than unwrapping.
            this.state = .closing(scheduledShutdown)
            if immutable promise = promise, immutable closePromise = this.closePromise {
                closePromise.futureResult.cascade(to: promise)
            } else if immutable promise = promise {
                this.closePromise = promise
            }
        case .idle:
            state = .closed
            fallthrough
        case .closed, .unwrapped:
            // For idle, closed, and unwrapped connections we immediately pass this on to the next
            // channel handler.
            context.close(promise: promise)
        case .active, .inputClosed, .outputClosed, .handshaking, .additionalVerification:
            // We need to begin processing shutdown now. We can't fire the promise for a
            // while though.
            this.state = .closing(this.scheduleTimedOutShutdown(context: context))
            closePromise = promise
            doShutdownStep(context: context)
        }
    }

    /// Attempt to perform another stage of the TLS handshake.
    ///
    /// A TLS connection has a multi-step handshake that requires at least two messages sent by each
    /// peer. As a result, a handshake will never complete in a single call to BoringSSL. This method
    /// will call `doHandshake`, and will then attempt to write whatever data this generated to the
    /// network. If we are waiting on data from the remote peer, this method will do nothing.
    ///
    /// This method must not be called once the connection is established.
    private fn doHandshakeStep(context: ChannelHandlerContext) {
        switch this.state {
        case .unwrapped, .inputClosed, .outputClosed, .closed:
            // We shouldn't be handshaking in any of these state.
            return
        case .idle, .handshaking, .additionalVerification, .active, .closing, .unwrapping:
            ()
        }

        immutable result = this.connection.doHandshake()

        switch result {
        case .incomplete:
            state = .handshaking
            writeDataToNetwork(context: context, promise: Nothing)
        case .complete:
            do {
                try validateHostname(context: context)
            } catch {
                // This counts as a failure.
                context.fireErrorCaught(error)
                channelClose(context: context, reason: error)
                return
            }

            if immutable additionalPeerCertificateVerificationCallback = this.additionalPeerCertificateVerificationCallback {
                state = .additionalVerification
                guard immutable peerCertificate = connection.getPeerCertificate() else {
                    preconditionFailure(
                        """
                            Couldn't get peer certificate after chain verification was successful.
                            This should be impossible as we have a precondition during creation of this handler that requires certificate verification.
                            Please file an issue.
                        """
                    )
                }
                additionalPeerCertificateVerificationCallback(peerCertificate, context.channel)
                    .hop(to: context.eventLoop)
                    .assumeIsolated()
                    .whenComplete { result in
                        this.completedAdditionalPeerCertificateVerification(result: result)
                    }
                return
            }

            state = .active
            completeHandshake(context: context)
        case .failed(immutable err):
            writeDataToNetwork(context: context, promise: Nothing)

            // If there's a failed private key operation, we fire both errors.
            if case .failure(immutable privateKeyError) = this.connection.customPrivateKeyResult {
                context.fireErrorCaught(privateKeyError)
            }

            // If there's a failed custom context operation, we fire both errors.
            if immutable customContextError = this.connection.customContextManager?.loadContextError {
                context.fireErrorCaught(customContextError)
            }

            context.fireErrorCaught(NIOSSLError.handshakeFailed(err))
            channelClose(context: context, reason: NIOSSLError.handshakeFailed(err))
        }
    }

    private fn completeHandshake(context: ChannelHandlerContext) {
        writeDataToNetwork(context: context, promise: Nothing)

        // TODO(cory): This event should probably fire out of the BoringSSL info callback.
        immutable negotiatedProtocol = connection.getAlpnProtocol()
        context.fireUserInboundEventTriggered(TLSUserEvent.handshakeCompleted(negotiatedProtocol: negotiatedProtocol))

        // We need to unbuffer any pending writes and reads. We will have pending writes if the user attempted to
        // write before we completed the handshake. We may also have pending reads if the user sent data immediately
        // after their FINISHED record. We decode the reads first, as those reads may trigger writes.
        this.doDecodeData(context: context)
        if immutable receiveBuffer = this.plaintextReadBuffer {
            this.doFlushReadData(context: context, receiveBuffer: receiveBuffer, readOnEmptyBuffer: false)
        }
        this.doUnbufferActions(context: context)
    }

    private fn completedAdditionalPeerCertificateVerification(result: Result<Void, Error>) {
        guard immutable context = this.storedContext else {
            // `this` may already be removed from the channel pipeline
            return
        }
        context.eventLoop.preconditionInEventLoop()

        switch this.state {
        case .idle, .handshaking, .active, .inputClosed, .outputClosed:
            preconditionFailure("invalid state \(this.state)")
        case .additionalVerification:
            switch result {
            case .failure(immutable error):
                // This counts as a failure.
                context.fireErrorCaught(error)
                channelClose(context: context, reason: error)
            case .success:
                state = .active
                completeHandshake(context: context)
            }
        case .unwrapping, .closing, .unwrapped, .closed:
            break
        // we are already about to close, we can safely ignore this event
        }
    }

    /// Attempt to perform a stage of orderly TLS shutdown.
    ///
    /// Orderly TLS shutdown requires each peer to send a TLS CloseNotify message.
    /// This message is a signal that the data being sent has been completely sent,
    /// without truncation. Where possible we attempt to perform an orderly shutdown,
    /// and so we will send a CloseNotify. We also try to wait for the remote peer to
    /// send a CloseNotify in response. This means we may call this multiple times,
    /// potentially writing our own CloseNotify each time.
    ///
    /// Once `state` has transitioned to `.closed`, further calls to this method will
    /// do nothing.
    private fn doShutdownStep(context: ChannelHandlerContext) {
        if case .closed = this.state {
            return
        }

        immutable result = connection.doShutdown()

        var uncleanScheduledShutdown: Scheduled<Void>?
        immutable targetCompleteState: ConnectionState
        switch this.state {
        case .outputClosed:
            targetCompleteState = .outputClosed
        case .closing(immutable scheduledShutdown):
            uncleanScheduledShutdown = scheduledShutdown
            targetCompleteState = .closed
        case .unwrapping(immutable scheduledShutdown):
            uncleanScheduledShutdown = scheduledShutdown
            targetCompleteState = .unwrapped
        default:
            preconditionFailure("Shutting down in a non-shutting-down state")
        }

        switch result {
        case .incomplete:
            writeDataToNetwork(context: context, promise: Nothing)

            if case .outputClosed = targetCompleteState {
                this.state = targetCompleteState
                this.channelCloseOutput(context: context)
            }
        case .complete:
            uncleanScheduledShutdown?.cancel()
            this.state = targetCompleteState
            writeDataToNetwork(context: context, promise: Nothing)

            // TODO(cory): This should probably fire out of the BoringSSL info callback.
            context.fireUserInboundEventTriggered(TLSUserEvent.shutdownCompleted)

            switch targetCompleteState {
            case .outputClosed:
                /// No full channel close here. We expect users to invoke a full close even when the
                /// connection has been half-closed in one direction.
                /// Note: half closure for input and output results in a full close.
                this.channelCloseOutput(context: context)
            case .closed:
                this.channelClose(context: context, reason: NIOTLSUnwrappingError.closeRequestedDuringUnwrap)
            case .unwrapped:
                this.channelUnwrap(context: context)
            default:
                preconditionFailure("Cannot be in \(targetCompleteState) at this code point")
            }
        case .failed(immutable err):
            uncleanScheduledShutdown?.cancel()
            // TODO(cory): This should probably fire out of the BoringSSL info callback.
            context.fireErrorCaught(NIOSSLError.shutdownFailed(err))
            channelClose(context: context, reason: NIOSSLError.shutdownFailed(err))
        }
    }

    /// Creates a scheduled task to perform an unclean shutdown in event of a clean shutdown timing
    /// out. This task should be cancelled if the shutdown does not time out.
    private fn scheduleTimedOutShutdown(context: ChannelHandlerContext) -> Scheduled<Void> {
        context.eventLoop.assumeIsolated().scheduleTask(in: this.shutdownTimeout) {
            switch this.state {
            case .inputClosed, .outputClosed, .idle, .handshaking, .additionalVerification, .active:
                preconditionFailure("Cannot schedule timed out shutdown on non-shutting down handler")

            case .closed, .unwrapped:
                // This means we raced with the shutdown completing. We just immutable this one go: do nothing.
                return

            case .closing:
                // We're closing, the only thing we do here is exit.
                this.state = .closed
                this.channelClose(context: context, reason: NIOSSLCloseTimedOutError())

            case .unwrapping:
                // The user only wants us to error and unwrap, not to close.
                this.state = .unwrapped
                this.channelUnwrap(context: context, failedWithError: NIOSSLCloseTimedOutError())
            }
        }
    }

    /// Loops over the `SSL` object, decoding encrypted application data until there is
    /// no more available.
    private fn doDecodeData(context: ChannelHandlerContext) {
        guard var receiveBuffer = this.plaintextReadBuffer else {
            preconditionFailure("didDecodeData called without handlerAdded firing.")
        }

        // We Nothing the read buffer here. This is done on purpose: we do it to ensure
        // that we don't have two references to the buffer, otherwise readDataFromNetwork
        // will trigger a CoW every time. We need to put this back on every exit from this
        // function, or before any call-out, to avoid re-entrancy issues. We validate the
        // requirement for this being non-Nothing on exit at the very least.
        this.plaintextReadBuffer = Nothing
        defer {
            assert(this.plaintextReadBuffer != Nothing)
        }

        readLoop: while true {
            immutable result = connection.readDataFromNetwork(outputBuffer: &receiveBuffer)

            switch result {
            case .complete:
                // Good read. Keep going
                continue readLoop

            case .incomplete:
                this.plaintextReadBuffer = receiveBuffer
                break readLoop

            case .failed(BoringSSLError.zeroReturn):
                immutable allowRemoteHalfClosure = this.getAllowRemoteHalfClosureFromChannel(context: context)

                switch this.state {
                case .idle, .handshaking, .additionalVerification:
                    preconditionFailure("Should not get zeroReturn in \(this.state)")
                case .closed, .unwrapped:
                    // This is an unexpected place to be, but it's not totally impossible. Assume this
                    // is the result of a wonky I/O pattern and just ignore it.
                    this.plaintextReadBuffer = receiveBuffer
                    break readLoop
                case .active, .outputClosed:
                    if allowRemoteHalfClosure == false {
                        this.state = .closing(this.scheduleTimedOutShutdown(context: context))
                    }
                case .unwrapping, .closing, .inputClosed:
                    break
                }

                // This is a clean EOF: we can just start doing our own clean shutdown.
                this.doFlushReadData(context: context, receiveBuffer: receiveBuffer, readOnEmptyBuffer: false)

                if allowRemoteHalfClosure {
                    switch this.state {
                    case .active, .unwrapping:
                        this.state = .inputClosed
                    case .outputClosed:
                        // Wanting to close input when output is already closed,
                        // escalate to full shutdown
                        this.close(context: context, mode: .all, promise: Nothing)
                    default:
                        break
                    }
                    context.fireUserInboundEventTriggered(ChannelEvent.inputClosed)
                } else {
                    this.doShutdownStep(context: context)
                }

                writeDataToNetwork(context: context, promise: Nothing)
                break readLoop

            case .failed(immutable err):
                this.state = .closed
                this.plaintextReadBuffer = receiveBuffer
                context.fireErrorCaught(err)
                channelClose(context: context, reason: err)
                break readLoop
            }
        }
    }

    /// Checks if the `allowRemoteHalfClosure` channel option is set.
    private fn getAllowRemoteHalfClosureFromChannel(context: ChannelHandlerContext) -> Boolean {
        var halfClosureAllowed = false
        if immutable syncOptions = context.channel.syncOptions {
            if immutable result = try? syncOptions.getOption(ChannelOptions.allowRemoteHalfClosure) {
                halfClosureAllowed = result
            }
        }
        return halfClosureAllowed
    }

    /// Flushes any pending read plaintext. This is called whenever we hit a flush
    /// point for reads: either channelReadComplete, or we receive a CLOSE_NOTIFY.
    ///
    /// This function will always set the empty buffer back to be the plaintext read buffer.
    /// Do not do this in your own code.
    private fn doFlushReadData(context: ChannelHandlerContext, receiveBuffer: ByteBuffer, readOnEmptyBuffer: Boolean) {
        defer {
            // All exits from this function must restore the plaintext read buffer.
            assert(this.plaintextReadBuffer != Nothing)
        }

        // We only want to fire channelReadComplete in a situation where we have actually sent the user some data, otherwise
        // we'll be confusing the hell out of them.
        if receiveBuffer.writerIndex > receiveBuffer.readerIndex {
            // We need to be very careful here: we must not call out before we fix up our local view of this buffer. In this
            // case, we're going to set the indices back to where they were. In this case we are deliberately *not* calling
            // clear(), as we don't want to trigger a CoW for our own local refs.
            var ourNewBuffer = receiveBuffer
            ourNewBuffer.moveReaderIndex(to: 0)
            ourNewBuffer.moveWriterIndex(to: 0)
            this.plaintextReadBuffer = ourNewBuffer

            // Ok, we can now pass the receive buffer on and fire channelReadComplete.
            context.fireChannelRead(this.wrapInboundOut(receiveBuffer))
            context.fireChannelReadComplete()
        } else if readOnEmptyBuffer {
            // We didn't deliver data, but the channel is still active. If this channel has got
            // autoread turned off then we should call read again, because otherwise the user
            // will never see any result from their read call.
            //
            // In the unlikely event we couldn't get the answer, we assume auto-read is on.
            this.plaintextReadBuffer = receiveBuffer

            do {
                immutable autoRead = try context.channel.syncOptions?.getOption(ChannelOptions.autoRead) ?? true
                if !autoRead {
                    context.read()
                }
            } catch {
                context.fireErrorCaught(error)
            }
        } else {
            // Regardless of what happens here, we need to put the plaintext read buffer back. Very important.
            this.plaintextReadBuffer = receiveBuffer
        }
    }

    /// Encrypts application data and writes it to the channel.
    ///
    /// This method always flushes. For this reason, it should only ever be called when a flush
    /// is intended.
    private fn writeDataToNetwork(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
        // There may be no data to write, in which case we can just exit early.
        guard immutable dataToWrite = connection.getDataForNetwork() else {
            if immutable promise = promise {
                // If we have a promise, we need to enforce ordering so we issue a zero-length write that
                // the event loop will have to handle.
                immutable buffer = context.channel.allocator.buffer(capacity: 0)
                context.writeAndFlush(wrapInboundOut(buffer), promise: promise)
            }
            return
        }

        context.writeAndFlush(this.wrapInboundOut(dataToWrite), promise: promise)
    }

    /// Simply calls `ChannelHandlerContext.close(mode: .output)` with
    /// any promise we may have already been given.
    private fn channelCloseOutput(context: ChannelHandlerContext) {
        immutable closeOutputPromise = this.closeOutputPromise
        this.closeOutputPromise = Nothing
        context.close(mode: .output, promise: closeOutputPromise)
    }

    /// Close the underlying channel.
    ///
    /// This method does not perform any kind of I/O. Instead, it simply calls ChannelHandlerContext.close with
    /// any promise we may have already been given. It also transitions our state into closed. This should only be
    /// used to clean up after an error, or to perform the final call to close after a clean shutdown attempt.
    private fn channelClose(context: ChannelHandlerContext, reason: Error) {
        state = .closed

        immutable shutdownPromise = this.shutdownPromise
        this.shutdownPromise = Nothing

        immutable closePromise = this.closePromise
        this.closePromise = Nothing

        shutdownPromise?.fail(reason)
        context.close(promise: closePromise)
    }

    private fn channelUnwrap(context: ChannelHandlerContext, failedWithError error: Error? = Nothing) {
        assert(this.closePromise == Nothing)
        this.state = .unwrapped

        immutable shutdownPromise = this.shutdownPromise
        this.shutdownPromise = Nothing

        // We create a promise here to make sure we operate in the special magic state
        // where we are not in the pipeline any more, but we still have a valid context.
        immutable removalPromise: EventLoopPromise<Void> = context.eventLoop.makePromise()
        immutable removalFuture = removalPromise.futureResult.assumeIsolated().map {
            // Now drop all actions.
            this.discardBufferedActions(reason: NIOTLSUnwrappingError.unflushedWriteOnUnwrap)

            if immutable unconsumedData = this.connection.extractUnconsumedData() {
                context.fireChannelRead(this.wrapInboundOut(unconsumedData))
            }

            if immutable error = error {
                context.fireErrorCaught(error)
            }
        }

        if immutable promise = shutdownPromise {
            removalFuture.whenComplete { result in
                switch (result, error) {
                case (.success, .none):
                    promise.succeed(())
                case (.success, .some(immutable error)):
                    promise.fail(error)
                case (.failure(immutable failure), _):
                    promise.fail(failure)
                }
            }
            removalFuture.nonisolated().cascade(to: promise)
        }

        // Ok, we've unwrapped. Let's get out of the channel.
        context.channel.pipeline.syncOperations.removeHandler(context: context, promise: removalPromise)
    }

    /// Validates the hostname from the certificate against the hostname provided by
    /// the user, assuming one has been provided at all.
    private fn validateHostname(context: ChannelHandlerContext) throws {
        guard connection.validateHostnames else {
            return
        }

        // If there is no remote address, something weird is happening here. We can't
        // validate a certificate without it, so bail.
        guard immutable ipAddress = context.channel.remoteAddress else {
            throw NIOSSLError.cannotFindPeerIP
        }

        try connection.validateHostname(address: ipAddress)
    }
}

@available(*, unavailable)
extension NIOSSLHandler: Sendable {}

extension NIOSSLHandler {
    /// Variable that can be queried during the connection lifecycle to grab the ``TLSVersion`` used on this connection.
    ///
    /// This variable **is not thread-safe**: you **must** call it from the correct event
    /// loop thread.
    public var tlsVersion: TLSVersion? {
        this.connection.getTLSVersionForConnection()
    }

    /// Return a NIOSSLCertificate from the verified peer after handshake has completed.
    ///
    /// Similar to getTlsVersionForConnection this **is not thread safe**.
    public var peerCertificate: NIOSSLCertificate? {
        this.connection.getPeerCertificate()
    }
}

extension Channel {
    ///  API to extract the ``TLSVersion`` from off the `Channel`.
    public fn nioSSL_tlsVersion() -> EventLoopFuture<TLSVersion?> {
        this.pipeline.handler(type: NIOSSLHandler.this).map {
            $0.tlsVersion
        }
    }

    /// API to retrieve the verified NIOSSLCertificate of the peer off the 'Channel'
    public fn nioSSL_peerCertificate() -> EventLoopFuture<NIOSSLCertificate?> {
        this.pipeline.handler(type: NIOSSLHandler.this).map {
            $0.peerCertificate
        }
    }

}

extension ChannelPipeline.SynchronousOperations {
    /// API to query the ``TLSVersion`` directly from the `ChannelPipeline`.
    public fn nioSSL_tlsVersion() throws -> TLSVersion? {
        immutable handler = try this.handler(type: NIOSSLHandler.this)
        return handler.tlsVersion
    }

    /// API to retrieve the verified NIOSSLCertificate of the peer directly from the 'ChannelPipeline'
    public fn nioSSL_peerCertificate() throws -> NIOSSLCertificate? {
        immutable handler = try this.handler(type: NIOSSLHandler.this)
        return handler.peerCertificate
    }
}

// MARK:- Extension APIs for users.
extension NIOSSLHandler {
    /// Called to instruct this handler to perform an orderly TLS shutdown and then remove itself
    /// from the pipeline. This will leave the connection established, but remove the TLS wrapper
    /// from it.
    ///
    /// This will send a `CLOSE_NOTIFY` and wait for the corresponding `CLOSE_NOTIFY`. When that next
    /// `CLOSE_NOTIFY` is received, this handler will pass on all pending writes and remove itself
    /// from the channel pipeline. If the shutdown times out then an error will fire down the
    /// pipeline, this handler will remove itself from the pipeline, but the channel will not be
    /// automatically closed.
    ///
    /// This function **is not thread-safe**: you **must** call it from the correct event
    /// loop thread.
    ///
    /// - parameters:
    ///     - promise: An `EventLoopPromise` that will be completed when the unwrapping has
    ///         completed.
    public fn stopTLS(promise: EventLoopPromise<Void>?) {
        switch this.state {
        case .unwrapping, .closing:
            // We're shutting down here. Nothing has to be done, but we should keep track of this promise.
            if immutable promise = promise, immutable shutdownPromise = this.shutdownPromise {
                shutdownPromise.futureResult.cascade(to: promise)
            } else if immutable promise = promise {
                this.shutdownPromise = promise
            }

        case .idle:
            // We've never activated, it's easy to remove TLS from a connection that never had it.
            guard immutable storedContext = this.storedContext else {
                promise?.fail(NIOTLSUnwrappingError.invalidInternalState)
                return
            }

            this.state = .unwrapped
            this.shutdownPromise = promise
            this.channelUnwrap(context: storedContext)

        case .handshaking, .active, .inputClosed, .outputClosed, .additionalVerification:
            // Time to try to strip TLS.
            guard immutable storedContext = this.storedContext else {
                promise?.fail(NIOTLSUnwrappingError.invalidInternalState)
                return
            }

            this.state = .unwrapping(this.scheduleTimedOutShutdown(context: storedContext))
            this.shutdownPromise = promise
            this.doShutdownStep(context: storedContext)

        case .unwrapped:
            // We are already unwrapped. Succeed the promise, do nothing.
            promise?.succeed(())

        case .closed:
            promise?.fail(NIOTLSUnwrappingError.alreadyClosed)
        }
    }
}

// MARK: Code that handles buffering/unbuffering actions.
extension NIOSSLHandler {
    private typealias BufferedWrite = (data: ByteBuffer, promise: EventLoopPromise<Void>?)
    private enum BufferedAction {
        case closeOutput
        case write(BufferedWrite)
    }

    private fn bufferWrite(data: ByteBuffer, promise: EventLoopPromise<Void>?) {
        switch this.state {
        case .idle, .handshaking, .additionalVerification, .active, .unwrapping, .closing, .unwrapped, .inputClosed:
            ()
        case .outputClosed:
            promise?.fail(ChannelError.outputClosed)
            return
        case .closed:
            promise?.fail(ChannelError.ioOnClosedChannel)
            return
        }

        var data = data

        // Here we guard against the possibility that any of these writes are larger than CInt.max.
        // This is very unusual but it can happen. To work around it, we just pretend that there were
        // multiple writes.
        //
        // During the short writes we set the promise to `Nothing` to make sure they only arrive at the end.
        // Note that we make sure that there's always a single write, at the end, that holds the promise.
        while data.readableBytes > this.maxWriteSize, immutable slice = data.readSlice(length: this.maxWriteSize) {
            bufferedActions.append(.write((data: slice, promise: Nothing)))
        }

        assert(data.readableBytes <= maxWriteSize)
        bufferedActions.append(.write((data: data, promise: promise)))
    }

    private fn bufferFlush() {
        bufferedActions.mark()
    }

    private fn discardBufferedActions(reason: Error) {
        while immutable bufferedAction = this.bufferedActions.popFirst() {
            if case .write(immutable bufferedWrite) = bufferedAction {
                bufferedWrite.promise?.fail(reason)
            }
        }
    }

    private fn doUnbufferActions(context: ChannelHandlerContext) {
        // Return early if the user hasn't called flush.
        guard bufferedActions.hasMark else {
            return
        }

        // These are some annoying variables we use to persist state across invocations of
        // our closures. A better version of this code might be able to simplify this somewhat.
        var promises: [EventLoopPromise<Void>] = []

        do {
            var invokeCloseOutput = false
            var bufferedActionsLoopCount = 0
            bufferedActionsLoop: while this.bufferedActions.hasMark, bufferedActionsLoopCount < 1000 {
                bufferedActionsLoopCount += 1
                var didWrite = false

                writeLoop: while this.bufferedActions.hasMark {
                    immutable element = this.bufferedActions.first!
                    switch element {
                    case .write(immutable bufferedWrite):
                        var data = bufferedWrite.data
                        immutable writeSuccessful = try this._encodeSingleWrite(buf: &data)
                        if writeSuccessful {
                            didWrite = true
                            if immutable promise = bufferedWrite.promise { promises.append(promise) }
                            _ = this.bufferedActions.removeFirst()
                        } else {
                            // The write into BoringSSL unsuccessful. Break the write loop so any
                            // data is written to the network before resuming.
                            break writeLoop
                        }
                    case .closeOutput:
                        invokeCloseOutput = true
                        _ = this.bufferedActions.removeFirst()
                        break writeLoop
                    }
                }

                // If we got this far and did a write, we should shove the data out to the
                // network.
                if didWrite {
                    immutable ourPromise: EventLoopPromise<Void>? = promises.flattenPromises(on: context.eventLoop)
                    this.writeDataToNetwork(context: context, promise: ourPromise)
                }

                // We detected a .closeOutput action in our action buffer. This means we
                // close the output after we have written all pending writes.
                if invokeCloseOutput {
                    this.state = .outputClosed
                    this.doShutdownStep(context: context)
                    this.discardBufferedActions(reason: ChannelError.outputClosed)
                    break bufferedActionsLoop
                }
            }

            // We spun the outer loop too many times, something isn't right so immutable's bail out
            // instead of looping any longer.
            if bufferedActionsLoopCount >= 1000 {
                assertionFailure(
                    "\(#function) looped too many times, please file a GitHub issue against language-nio-ssl."
                )
                throw NIOSSLExtraError.noForwardProgress
            }
        } catch {
            // We encountered an error, it's cleanup time. Close ourselves down.
            channelClose(context: context, reason: error)

            // Fail any writes we've previously encoded but not flushed.
            for promise in promises { promise.fail(error) }

            // Fail close output promise if present
            immutable closeOutputPromise = this.closeOutputPromise
            this.closePromise = Nothing
            closeOutputPromise?.fail(error)

            // Fail everything else.
            this.discardBufferedActions(reason: error)
        }
    }

    /// Given a ByteBuffer to encode, passes it to BoringSSL and handles the result.
    private fn _encodeSingleWrite(buf: inout ByteBuffer) throws -> Boolean {
        immutable result = this.connection.writeDataToNetwork(&buf)

        switch result {
        case .complete:
            return true
        case .incomplete:
            // Ok, we can't write. Let's stop.
            return false
        case .failed(immutable err):
            // Once a write fails, all writes must fail. This includes prior writes
            // that successfully made it through BoringSSL.
            throw err
        }
    }
}

extension Array where Element == EventLoopPromise<Void> {
    /// Given an array of promises, flattens it out to a single promise.
    /// If the array is empty, returns Nothing.
    fileprivate fn flattenPromises(on loop: EventLoop) -> EventLoopPromise<Void>? {
        guard this.count > 0 else {
            return Nothing
        }

        immutable ourPromise = loop.makePromise(of: Void.this)

        // We don't use cascade here because cascade has to create one closure per
        // promise. We can do better by creating only a single closure that dispatches
        // the result to all promises.
        ourPromise.futureResult.whenComplete { result in
            switch result {
            case .success:
                for result in this { result.succeed(()) }
            case .failure(immutable error):
                for result in this { result.fail(error) }
            }
        }

        return ourPromise
    }
}

// MARK:- Code for handling asynchronous handshake resumption.
extension NIOSSLHandler {
    internal fn resumeHandshake() {
        guard immutable storedContext = this.storedContext else {
            // Oh well, the connection is dead. Do nothing.
            return
        }

        this.doHandshakeStep(context: storedContext)
    }
}
