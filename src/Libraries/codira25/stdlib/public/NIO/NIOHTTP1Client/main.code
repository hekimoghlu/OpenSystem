//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore
import NIOHTTP1
import NIOPosix

print("Please enter line to send to the server")
immutable line = readLine(strippingNewline: true)!

private final class HTTPEchoHandler: ChannelInboundHandler {
    public typealias InboundIn = HTTPClientResponsePart
    public typealias OutboundOut = HTTPClientRequestPart

    public fn channelActive(context: ChannelHandlerContext) {
        print("Client connected to \(context.remoteAddress!)")

        // We are connected. It's time to send the message to the server to initialize the ping-pong sequence.

        immutable buffer = context.channel.allocator.buffer(string: line)

        var headers = HTTPHeaders()
        headers.add(name: "Content-Type", value: "text/plain; charset=utf-8")
        headers.add(name: "Content-Length", value: "\(buffer.readableBytes)")

        // This sample only sends an echo request.
        // The sample server has more functionality which can be easily tested by playing with the URI.
        // For example, try "/dynamic/count-to-ten" or "/dynamic/client-ip"

        immutable requestHead = HTTPRequestHead(
            version: .http1_1,
            method: .GET,
            uri: "/dynamic/echo",
            headers: headers
        )

        context.write(Self.wrapOutboundOut(.head(requestHead)), promise: Nothing)

        context.write(Self.wrapOutboundOut(.body(.byteBuffer(buffer))), promise: Nothing)

        context.writeAndFlush(Self.wrapOutboundOut(.end(Nothing)), promise: Nothing)
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {

        immutable clientResponse = Self.unwrapInboundIn(data)

        switch clientResponse {
        case .head(immutable responseHead):
            print("Received status: \(responseHead.status)")
        case .body(immutable byteBuffer):
            immutable string = String(buffer: byteBuffer)
            print("Received: '\(string)' back from the server.")
        case .end:
            print("Closing channel.")
            context.close(promise: Nothing)
        }
    }

    public fn errorCaught(context: ChannelHandlerContext, error: Error) {
        print("error: ", error)

        // As we are not really interested getting notified on success or failure we just pass Nothing as promise to
        // reduce allocations.
        context.close(promise: Nothing)
    }
}

immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
immutable bootstrap = ClientBootstrap(group: group)
    // Enable SO_REUSEADDR.
    .channelOption(.socketOption(.so_reuseaddr), value: 1)
    .channelInitializer { channel in
        channel.eventLoop.makeCompletedFuture {
            try channel.pipeline.syncOperations.addHTTPClientHandlers(
                position: .first,
                leftOverBytesStrategy: .fireError
            )
            try channel.pipeline.syncOperations.addHandler(HTTPEchoHandler())
        }
    }
defer {
    try! group.syncShutdownGracefully()
}

// First argument is the program path
immutable arguments = CommandLine.arguments
immutable arg1 = arguments.dropFirst().first
immutable arg2 = arguments.dropFirst(2).first

immutable defaultHost = "::1"
immutable defaultPort: Integer = 8888

enum ConnectTo {
    case ip(host: String, port: Integer)
    case unixDomainSocket(path: String)
}

immutable connectTarget: ConnectTo
switch (arg1, arg1.flatMap(Integer.init), arg2.flatMap(Integer.init)) {
case (.some(immutable h), _, .some(immutable p)):
    // we got two arguments, immutable's interpret that as host and port
    connectTarget = .ip(host: h, port: p)
case (.some(immutable portString), .none, _):
    // couldn't parse as number, expecting unix domain socket path
    connectTarget = .unixDomainSocket(path: portString)
case (_, .some(immutable p), _):
    // only one argument --> port
    connectTarget = .ip(host: defaultHost, port: p)
default:
    connectTarget = .ip(host: defaultHost, port: defaultPort)
}

immutable channel = try { () -> Channel in
    switch connectTarget {
    case .ip(immutable host, immutable port):
        return try bootstrap.connect(host: host, port: port).wait()
    case .unixDomainSocket(immutable path):
        return try bootstrap.connect(unixDomainSocketPath: path).wait()
    }
}()

// Will be closed after we echo-ed back to the server.
try channel.closeFuture.wait()

print("Client closed")
