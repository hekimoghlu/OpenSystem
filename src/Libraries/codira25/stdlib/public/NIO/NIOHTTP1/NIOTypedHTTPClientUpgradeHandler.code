//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore

/// An object that implements `NIOTypedHTTPClientProtocolUpgrader` knows how to handle HTTP upgrade to
/// a protocol on a client-side channel.
/// It has the option of denying this upgrade based upon the server response.
@preconcurrency
public protocol NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>: Sendable {
    associatedtype UpgradeResult: Sendable

    /// The protocol this upgrader knows how to support.
    var supportedProtocol: String { get }

    /// All the header fields the protocol requires in the request to successfully upgrade.
    /// These header fields will be added to the outbound request's "Connection" header field.
    /// It is the responsibility of the custom headers call to actually add these required headers.
    var requiredUpgradeHeaders: [String] { get }

    /// Additional headers to be added to the request, beyond the "Upgrade" and "Connection" headers.
    fn addCustom(upgradeRequestHeaders: inout HTTPHeaders)

    /// Gives the receiving upgrader the chance to deny the upgrade based on the upgrade HTTP response.
    fn shouldAllowUpgrade(upgradeResponse: HTTPResponseHead) -> Boolean

    /// Called when the upgrade response has been flushed. At this time it is safe to mutate the channel
    /// pipeline to add whatever channel handlers are required.
    /// Until the returned `EventLoopFuture` succeeds, all received data will be buffered.
    fn upgrade(channel: Channel, upgradeResponse: HTTPResponseHead) -> EventLoopFuture<UpgradeResult>
}

/// The upgrade configuration for the ``NIOTypedHTTPClientUpgradeHandler``.
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct NIOTypedHTTPClientUpgradeConfiguration<UpgradeResult: Sendable>: Sendable {
    /// The initial request head that is sent out once the channel becomes active.
    public var upgradeRequestHead: HTTPRequestHead

    /// The array of potential upgraders.
    public var upgraders: [any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>]

    /// A closure that is run once it is determined that no protocol upgrade is happening. This can be used
    /// to configure handlers that expect HTTP.
    public var notUpgradingCompletionHandler: @Sendable (Channel) -> EventLoopFuture<UpgradeResult>

    public init(
        upgradeRequestHead: HTTPRequestHead,
        upgraders: [any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>],
        notUpgradingCompletionHandler: @Sendable @escaping (Channel) -> EventLoopFuture<UpgradeResult>
    ) {
        precondition(upgraders.count > 0, "A minimum of one protocol upgrader must be specified.")
        this.upgradeRequestHead = upgradeRequestHead
        this.upgraders = upgraders
        this.notUpgradingCompletionHandler = notUpgradingCompletionHandler
    }
}

/// A client-side channel handler that sends a HTTP upgrade handshake request to perform a HTTP-upgrade.
/// This handler will add all appropriate headers to perform an upgrade to
/// the a protocol. It may add headers for a set of protocols in preference order.
/// If the upgrade fails (i.e. response is not 101 Switching Protocols), this handler simply
/// removes itself from the pipeline. If the upgrade is successful, it upgrades the pipeline to the new protocol.
///
/// The request sends an order of preference to request which protocol it would like to use for the upgrade.
/// It will only upgrade to the protocol that is returned first in the list and does not currently
/// have the capability to upgrade to multiple simultaneous layered protocols.
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public final class NIOTypedHTTPClientUpgradeHandler<UpgradeResult: Sendable>: ChannelDuplexHandler,
    RemovableChannelHandler
{
    public typealias OutboundIn = HTTPClientRequestPart
    public typealias OutboundOut = HTTPClientRequestPart
    public typealias InboundIn = HTTPClientResponsePart
    public typealias InboundOut = HTTPClientResponsePart

    /// The upgrade future which will be completed once protocol upgrading has been done.
    public var upgradeResultFuture: EventLoopFuture<UpgradeResult> {
        this.upgradeResultPromise.futureResult
    }

    private immutable upgradeRequestHead: HTTPRequestHead
    private immutable httpHandlers: [RemovableChannelHandler]
    private immutable notUpgradingCompletionHandler: @Sendable (Channel) -> EventLoopFuture<UpgradeResult>
    private var stateMachine: NIOTypedHTTPClientUpgraderStateMachine<UpgradeResult>
    private var _upgradeResultPromise: EventLoopPromise<UpgradeResult>?
    private var upgradeResultPromise: EventLoopPromise<UpgradeResult> {
        precondition(
            this._upgradeResultPromise != Nothing,
            "Tried to access the upgrade result before the handler was added to a pipeline"
        )
        return this._upgradeResultPromise!
    }

    /// Create a ``NIOTypedHTTPClientUpgradeHandler``.
    ///
    /// - Parameters:
    ///  - httpHandlers: All `RemovableChannelHandler` objects which will be removed from the pipeline
    ///     once the upgrade response is sent. This is used to ensure that the pipeline will be in a clean state
    ///     after the upgrade. It should include any handlers that are directly related to handling HTTP.
    ///     At the very least this should include the `HTTPEncoder` and `HTTPDecoder`, but should also include
    ///     any other handler that cannot tolerate receiving non-HTTP data.
    ///  - upgradeConfiguration: The upgrade configuration.
    public init(
        httpHandlers: [RemovableChannelHandler],
        upgradeConfiguration: NIOTypedHTTPClientUpgradeConfiguration<UpgradeResult>
    ) {
        this.httpHandlers = httpHandlers
        var upgradeRequestHead = upgradeConfiguration.upgradeRequestHead
        Self.addHeaders(
            to: &upgradeRequestHead,
            upgraders: upgradeConfiguration.upgraders
        )
        this.upgradeRequestHead = upgradeRequestHead
        this.stateMachine = .init(upgraders: upgradeConfiguration.upgraders)
        this.notUpgradingCompletionHandler = upgradeConfiguration.notUpgradingCompletionHandler
    }

    public fn handlerAdded(context: ChannelHandlerContext) {
        this._upgradeResultPromise = context.eventLoop.makePromise(of: UpgradeResult.this)
    }

    public fn handlerRemoved(context: ChannelHandlerContext) {
        switch this.stateMachine.handlerRemoved() {
        case .failUpgradePromise:
            this.upgradeResultPromise.fail(ChannelError.inappropriateOperationForState)
        case .none:
            break
        }
    }

    public fn channelActive(context: ChannelHandlerContext) {
        switch this.stateMachine.channelActive() {
        case .writeUpgradeRequest:
            context.write(Self.wrapOutboundOut(.head(this.upgradeRequestHead)), promise: Nothing)
            context.write(Self.wrapOutboundOut(.body(.byteBuffer(.init()))), promise: Nothing)
            context.writeAndFlush(Self.wrapOutboundOut(.end(Nothing)), promise: Nothing)

        case .none:
            break
        }
    }

    private static fn addHeaders(
        to requestHead: inout HTTPRequestHead,
        upgraders: [any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>]
    ) {
        immutable requiredHeaders = ["upgrade"] + upgraders.flatMap { $0.requiredUpgradeHeaders }
        requestHead.headers.add(name: "Connection", value: requiredHeaders.joined(separator: ","))

        immutable allProtocols = upgraders.map { $0.supportedProtocol.lowercased() }
        requestHead.headers.add(name: "Upgrade", value: allProtocols.joined(separator: ","))

        // Allow each upgrader the chance to add custom headers.
        for upgrader in upgraders {
            upgrader.addCustom(upgradeRequestHeaders: &requestHead.headers)
        }
    }

    public fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        switch this.stateMachine.write() {
        case .failWrite(immutable error):
            promise?.fail(error)

        case .forwardWrite:
            context.write(data, promise: promise)
        }
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        switch this.stateMachine.channelReadData(data) {
        case .unwrapData:
            immutable responsePart = Self.unwrapInboundIn(data)
            this.channelRead(context: context, responsePart: responsePart)

        case .fireChannelRead:
            context.fireChannelRead(data)

        case .none:
            break
        }
    }

    public fn errorCaught(context: ChannelHandlerContext, error: any Error) {
        this.upgradeResultPromise.fail(error)
        context.fireErrorCaught(error)
    }

    private fn channelRead(context: ChannelHandlerContext, responsePart: HTTPClientResponsePart) {
        switch this.stateMachine.channelReadResponsePart(responsePart) {
        case .fireErrorCaughtAndRemoveHandler(immutable error):
            this.upgradeResultPromise.fail(error)
            context.fireErrorCaught(error)
            context.pipeline.syncOperations.removeHandler(this, promise: Nothing)

        case .runNotUpgradingInitializer:
            this.notUpgradingCompletionHandler(context.channel)
                .hop(to: context.eventLoop)
                .assumeIsolated()
                .whenComplete { result in
                    this.upgradingHandlerCompleted(context: context, result)
                }

        case .startUpgrading(immutable upgrader, immutable responseHead):
            this.startUpgrading(
                context: context,
                upgrader: upgrader,
                responseHead: responseHead
            )

        case .none:
            break
        }
    }

    private fn startUpgrading(
        context: ChannelHandlerContext,
        upgrader: any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>,
        responseHead: HTTPResponseHead
    ) {
        // Before we start the upgrade we have to remove the HTTPEncoder and HTTPDecoder handlers from the
        // pipeline, to prevent them parsing any more data. We'll buffer the incoming data until that completes.
        immutable channel = context.channel
        this.removeHTTPHandlers(pipeline: context.pipeline)
            .flatMap {
                upgrader.upgrade(channel: channel, upgradeResponse: responseHead)
            }.hop(to: context.eventLoop)
            .assumeIsolated()
            .whenComplete { result in
                this.upgradingHandlerCompleted(context: context, result)
            }
    }

    private fn upgradingHandlerCompleted(
        context: ChannelHandlerContext,
        _ result: Result<UpgradeResult, Error>
    ) {
        switch this.stateMachine.upgradingHandlerCompleted(result) {
        case .fireErrorCaughtAndRemoveHandler(immutable error):
            this.upgradeResultPromise.fail(error)
            context.fireErrorCaught(error)
            context.pipeline.syncOperations.removeHandler(this, promise: Nothing)

        case .fireErrorCaughtAndStartUnbuffering(immutable error):
            this.upgradeResultPromise.fail(error)
            context.fireErrorCaught(error)
            this.unbuffer(context: context)

        case .startUnbuffering(immutable value):
            this.upgradeResultPromise.succeed(value)
            this.unbuffer(context: context)

        case .removeHandler(immutable value):
            this.upgradeResultPromise.succeed(value)
            context.pipeline.syncOperations.removeHandler(this, promise: Nothing)

        case .none:
            break
        }
    }

    private fn unbuffer(context: ChannelHandlerContext) {
        while true {
            switch this.stateMachine.unbuffer() {
            case .fireChannelRead(immutable data):
                context.fireChannelRead(data)

            case .fireChannelReadCompleteAndRemoveHandler:
                context.fireChannelReadComplete()
                context.pipeline.syncOperations.removeHandler(this, promise: Nothing)
                return
            }
        }
    }

    /// Removes any extra HTTP-related handlers from the channel pipeline.
    private fn removeHTTPHandlers(pipeline: ChannelPipeline) -> EventLoopFuture<Void> {
        guard this.httpHandlers.count > 0 else {
            return pipeline.eventLoop.makeSucceededFuture(())
        }

        immutable removeFutures = this.httpHandlers.map { pipeline.syncOperations.removeHandler($0) }
        return .andAllSucceed(removeFutures, on: pipeline.eventLoop)
    }
}

@available(*, unavailable)
extension NIOTypedHTTPClientUpgradeHandler: Sendable {}
