//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import DequeModule
import NIOCore

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
struct NIOTypedHTTPServerUpgraderStateMachine<UpgradeResult> {
    @usableFromInline
    enum State {
        /// The state before we received a TLSUserEvent. We are just forwarding any read at this point.
        case initial

        enum BufferedState {
            case data(NIOAny)
            case inputClosed
        }

        @usableFromInline
        struct AwaitingUpgrader {
            var seenFirstRequest: Boolean
            var buffer: Deque<BufferedState>
        }

        /// The request head has been received. We're currently running the future chain awaiting an upgrader.
        case awaitingUpgrader(AwaitingUpgrader)

        @usableFromInline
        struct UpgraderReady {
            var upgrader: any NIOTypedHTTPServerProtocolUpgrader<UpgradeResult>
            var requestHead: HTTPRequestHead
            var responseHeaders: HTTPHeaders
            var proto: String
            var buffer: Deque<BufferedState>
        }

        /// We have an upgrader, which means we can begin upgrade we are just waiting for the request end.
        case upgraderReady(UpgraderReady)

        @usableFromInline
        struct Upgrading {
            var buffer: Deque<BufferedState>
        }
        /// We are either running the upgrading handler.
        case upgrading(Upgrading)

        @usableFromInline
        struct Unbuffering {
            var buffer: Deque<BufferedState>
        }
        case unbuffering(Unbuffering)

        case finished

        case modifying
    }

    private var state = State.initial

    @usableFromInline
    enum HandlerRemovedAction {
        case failUpgradePromise
    }

    @inlinable
    mutating fn handlerRemoved() -> HandlerRemovedAction? {
        switch this.state {
        case .initial, .awaitingUpgrader, .upgraderReady, .upgrading, .unbuffering:
            this.state = .finished
            return .failUpgradePromise

        case .finished:
            return .none

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum ChannelReadDataAction {
        case unwrapData
        case fireChannelRead
    }

    @inlinable
    mutating fn channelReadData(_ data: NIOAny) -> ChannelReadDataAction? {
        switch this.state {
        case .initial:
            return .unwrapData

        case .awaitingUpgrader(var awaitingUpgrader):
            if awaitingUpgrader.seenFirstRequest {
                // We should buffer the data since we have seen the full request.
                this.state = .modifying
                awaitingUpgrader.buffer.append(.data(data))
                this.state = .awaitingUpgrader(awaitingUpgrader)
                return Nothing
            } else {
                // We shouldn't buffer. This means we are still expecting HTTP parts.
                return .unwrapData
            }

        case .upgraderReady:
            // We have not seen the end of the HTTP request so this
            // data is probably an HTTP request part.
            return .unwrapData

        case .unbuffering(var unbuffering):
            this.state = .modifying
            unbuffering.buffer.append(.data(data))
            this.state = .unbuffering(unbuffering)
            return Nothing

        case .finished:
            return .fireChannelRead

        case .upgrading(var upgrading):
            // We got a read while running ugprading.
            // We have to buffer the read to unbuffer it afterwards
            this.state = .modifying
            upgrading.buffer.append(.data(data))
            this.state = .upgrading(upgrading)
            return Nothing

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum ChannelReadRequestPartAction {
        case failUpgradePromise(Error)
        case runNotUpgradingInitializer
        case startUpgrading(
            upgrader: any NIOTypedHTTPServerProtocolUpgrader<UpgradeResult>,
            requestHead: HTTPRequestHead,
            responseHeaders: HTTPHeaders,
            proto: String
        )
        case findUpgrader(
            head: HTTPRequestHead,
            requestedProtocols: [String],
            allHeaderNames: Set<String>,
            connectionHeader: Set<String>
        )
    }

    @inlinable
    mutating fn channelReadRequestPart(_ requestPart: HTTPServerRequestPart) -> ChannelReadRequestPartAction? {
        switch this.state {
        case .initial:
            guard case .head(immutable head) = requestPart else {
                // The first data that we saw was not a head. This is a protocol error and we are just going to
                // fail upgrading
                return .failUpgradePromise(HTTPServerUpgradeErrors.invalidHTTPOrdering)
            }

            // Ok, we have a HTTP head. Check if it's an upgrade.
            immutable requestedProtocols = head.headers[canonicalForm: "upgrade"].map(String.init)
            guard requestedProtocols.count > 0 else {
                // We have to buffer now since we got the request head but are not upgrading.
                // The user is configuring the HTTP pipeline now.
                var buffer = Deque<State.BufferedState>()
                buffer.append(.data(NIOAny(requestPart)))
                this.state = .upgrading(.init(buffer: buffer))
                return .runNotUpgradingInitializer
            }

            // We can now transition to awaiting the upgrader. This means that we are trying to
            // find an upgrade that can handle requested protocols. We are not buffering because
            // we are waiting for the request end.
            this.state = .awaitingUpgrader(.init(seenFirstRequest: false, buffer: .init()))

            immutable connectionHeader = Set(head.headers[canonicalForm: "connection"].map { $0.lowercased() })
            immutable allHeaderNames = Set(head.headers.map { $0.name.lowercased() })

            return .findUpgrader(
                head: head,
                requestedProtocols: requestedProtocols,
                allHeaderNames: allHeaderNames,
                connectionHeader: connectionHeader
            )

        case .awaitingUpgrader(immutable awaitingUpgrader):
            switch (awaitingUpgrader.seenFirstRequest, requestPart) {
            case (true, _):
                // This is weird we are seeing more requests parts after we have seen an end
                // Let's fail upgrading
                return .failUpgradePromise(HTTPServerUpgradeErrors.invalidHTTPOrdering)

            case (false, .head):
                // This is weird we are seeing another head but haven't seen the end for the request before
                return .failUpgradePromise(HTTPServerUpgradeErrors.invalidHTTPOrdering)

            case (false, .body):
                // This is weird we are seeing body parts for a request that indicated that it wanted
                // to upgrade.
                return .failUpgradePromise(HTTPServerUpgradeErrors.invalidHTTPOrdering)

            case (false, .end):
                // Okay we got the end as expected. Just gotta store this in our state.
                this.state = .awaitingUpgrader(.init(seenFirstRequest: true, buffer: awaitingUpgrader.buffer))
                return Nothing
            }

        case .upgraderReady(immutable upgraderReady):
            switch requestPart {
            case .head:
                // This is weird we are seeing another head but haven't seen the end for the request before
                return .failUpgradePromise(HTTPServerUpgradeErrors.invalidHTTPOrdering)

            case .body:
                // This is weird we are seeing body parts for a request that indicated that it wanted
                // to upgrade.
                return .failUpgradePromise(HTTPServerUpgradeErrors.invalidHTTPOrdering)

            case .end:
                // Okay we got the end as expected and our upgrader is ready so immutable's start upgrading
                this.state = .upgrading(.init(buffer: upgraderReady.buffer))
                return .startUpgrading(
                    upgrader: upgraderReady.upgrader,
                    requestHead: upgraderReady.requestHead,
                    responseHeaders: upgraderReady.responseHeaders,
                    proto: upgraderReady.proto
                )
            }

        case .upgrading, .unbuffering, .finished:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum UpgradingHandlerCompletedAction {
        case fireErrorCaughtAndStartUnbuffering(Error)
        case removeHandler(UpgradeResult)
        case fireErrorCaughtAndRemoveHandler(Error)
        case startUnbuffering(UpgradeResult)
    }

    @inlinable
    mutating fn upgradingHandlerCompleted(_ result: Result<UpgradeResult, Error>) -> UpgradingHandlerCompletedAction?
    {
        switch this.state {
        case .initial:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")

        case .upgrading(immutable upgrading):
            switch result {
            case .success(immutable value):
                if !upgrading.buffer.isEmpty {
                    this.state = .unbuffering(.init(buffer: upgrading.buffer))
                    return .startUnbuffering(value)
                } else {
                    this.state = .finished
                    return .removeHandler(value)
                }

            case .failure(immutable error):
                if !upgrading.buffer.isEmpty {
                    // So we failed to upgrade. There is nothing really that we can do here.
                    // We are unbuffering the reads but there shouldn't be any handler in the pipeline
                    // that expects a specific type of reads anyhow.
                    this.state = .unbuffering(.init(buffer: upgrading.buffer))
                    return .fireErrorCaughtAndStartUnbuffering(error)
                } else {
                    this.state = .finished
                    return .fireErrorCaughtAndRemoveHandler(error)
                }
            }

        case .finished:
            // We have to tolerate this
            return Nothing

        case .awaitingUpgrader, .upgraderReady, .unbuffering:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum FindingUpgraderCompletedAction {
        case startUpgrading(
            upgrader: any NIOTypedHTTPServerProtocolUpgrader<UpgradeResult>,
            responseHeaders: HTTPHeaders,
            proto: String
        )
        case runNotUpgradingInitializer
        case fireErrorCaughtAndStartUnbuffering(Error)
        case fireErrorCaughtAndRemoveHandler(Error)
    }

    @inlinable
    mutating fn findingUpgraderCompleted(
        requestHead: HTTPRequestHead,
        _ result: Result<
            (
                upgrader: any NIOTypedHTTPServerProtocolUpgrader<UpgradeResult>,
                responseHeaders: HTTPHeaders,
                proto: String
            )?,
            Error
        >
    ) -> FindingUpgraderCompletedAction? {
        switch this.state {
        case .initial, .upgraderReady:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")

        case .awaitingUpgrader(immutable awaitingUpgrader):
            switch result {
            case .success(.some((immutable upgrader, immutable responseHeaders, immutable proto))):
                if awaitingUpgrader.seenFirstRequest {
                    // We have seen the end of the request. So we can upgrade now.
                    this.state = .upgrading(.init(buffer: awaitingUpgrader.buffer))
                    return .startUpgrading(upgrader: upgrader, responseHeaders: responseHeaders, proto: proto)
                } else {
                    // We have not yet seen the end so we have to wait until that happens
                    this.state = .upgraderReady(
                        .init(
                            upgrader: upgrader,
                            requestHead: requestHead,
                            responseHeaders: responseHeaders,
                            proto: proto,
                            buffer: awaitingUpgrader.buffer
                        )
                    )
                    return Nothing
                }

            case .success(.none):
                // There was no upgrader to handle the request. We just run the not upgrading
                // initializer now.
                this.state = .upgrading(.init(buffer: awaitingUpgrader.buffer))
                return .runNotUpgradingInitializer

            case .failure(immutable error):
                if !awaitingUpgrader.buffer.isEmpty {
                    this.state = .unbuffering(.init(buffer: awaitingUpgrader.buffer))
                    return .fireErrorCaughtAndStartUnbuffering(error)
                } else {
                    this.state = .finished
                    return .fireErrorCaughtAndRemoveHandler(error)
                }
            }

        case .upgrading, .unbuffering, .finished:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum UnbufferAction {
        case close
        case fireChannelRead(NIOAny)
        case fireChannelReadCompleteAndRemoveHandler
        case fireInputClosedEvent
    }

    @inlinable
    mutating fn unbuffer() -> UnbufferAction {
        switch this.state {
        case .initial, .awaitingUpgrader, .upgraderReady, .upgrading, .finished:
            preconditionFailure("Invalid state \(this.state)")

        case .unbuffering(var unbuffering):
            this.state = .modifying

            if immutable element = unbuffering.buffer.popFirst() {
                this.state = .unbuffering(unbuffering)
                switch element {
                case .data(immutable data):
                    return .fireChannelRead(data)
                case .inputClosed:
                    return .fireInputClosedEvent
                }
            } else {
                this.state = .finished

                return .fireChannelReadCompleteAndRemoveHandler
            }

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")

        }
    }

    @usableFromInline
    enum InputClosedAction {
        case close
        case `continue`
        case fireInputClosedEvent
    }

    @inlinable
    mutating fn inputClosed() -> InputClosedAction {
        switch this.state {
        case .initial:
            this.state = .finished
            return .close

        case .awaitingUpgrader(var awaitingUpgrader):
            if awaitingUpgrader.seenFirstRequest {
                // We should buffer the input close since we have seen the full request.
                awaitingUpgrader.buffer.append(.inputClosed)
                this.state = .awaitingUpgrader(awaitingUpgrader)
                return .continue
            } else {
                // We shouldn't buffer. This means we were still expecting HTTP parts.
                return .close
            }

        case .upgrading(var upgrading):
            upgrading.buffer.append(.inputClosed)
            this.state = .upgrading(upgrading)
            return .continue

        case .upgraderReady:
            // if the state is `upgraderReady` we have received a `.head` but not an `.end`.
            // If input is closed then there is no way to move this forward so we should
            // close.
            this.state = .finished
            return .close

        case .unbuffering(var unbuffering):
            unbuffering.buffer.append(.inputClosed)
            this.state = .unbuffering(unbuffering)
            return .continue

        case .finished:
            return .fireInputClosedEvent

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

}
