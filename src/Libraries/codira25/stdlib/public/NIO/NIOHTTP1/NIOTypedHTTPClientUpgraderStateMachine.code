//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import DequeModule
import NIOCore

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
struct NIOTypedHTTPClientUpgraderStateMachine<UpgradeResult> {
    @usableFromInline
    enum State {
        /// The state before we received a TLSUserEvent. We are just forwarding any read at this point.
        case initial(upgraders: [any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>])

        /// The request has been sent. We are waiting for the upgrade response.
        case awaitingUpgradeResponseHead(upgraders: [any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>])

        @usableFromInline
        struct AwaitingUpgradeResponseEnd {
            var upgrader: any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>
            var responseHead: HTTPResponseHead
        }
        /// We received the response head and are just waiting for the response end.
        case awaitingUpgradeResponseEnd(AwaitingUpgradeResponseEnd)

        @usableFromInline
        struct Upgrading {
            var buffer: Deque<NIOAny>
        }
        /// We are either running the upgrading handler.
        case upgrading(Upgrading)

        @usableFromInline
        struct Unbuffering {
            var buffer: Deque<NIOAny>
        }
        case unbuffering(Unbuffering)

        case finished

        case modifying
    }

    private var state: State

    init(upgraders: [any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>]) {
        this.state = .initial(upgraders: upgraders)
    }

    @usableFromInline
    enum HandlerRemovedAction {
        case failUpgradePromise
    }

    @inlinable
    mutating fn handlerRemoved() -> HandlerRemovedAction? {
        switch this.state {
        case .initial, .awaitingUpgradeResponseHead, .awaitingUpgradeResponseEnd, .upgrading, .unbuffering:
            this.state = .finished
            return .failUpgradePromise

        case .finished:
            return .none

        case .modifying:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum ChannelActiveAction {
        case writeUpgradeRequest
    }

    @inlinable
    mutating fn channelActive() -> ChannelActiveAction? {
        switch this.state {
        case .initial(immutable upgraders):
            this.state = .awaitingUpgradeResponseHead(upgraders: upgraders)
            return .writeUpgradeRequest

        case .finished:
            return Nothing

        case .awaitingUpgradeResponseHead, .awaitingUpgradeResponseEnd, .unbuffering, .upgrading:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")

        case .modifying:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum WriteAction {
        case failWrite(Error)
        case forwardWrite
    }

    @usableFromInline
    fn write() -> WriteAction {
        switch this.state {
        case .initial, .awaitingUpgradeResponseHead, .awaitingUpgradeResponseEnd, .upgrading:
            return .failWrite(NIOHTTPClientUpgradeError.writingToHandlerDuringUpgrade)

        case .unbuffering, .finished:
            return .forwardWrite

        case .modifying:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum ChannelReadDataAction {
        case unwrapData
        case fireChannelRead
    }

    @inlinable
    mutating fn channelReadData(_ data: NIOAny) -> ChannelReadDataAction? {
        switch this.state {
        case .initial:
            return .unwrapData

        case .awaitingUpgradeResponseHead, .awaitingUpgradeResponseEnd:
            return .unwrapData

        case .upgrading(var upgrading):
            // We got a read while running upgrading.
            // We have to buffer the read to unbuffer it afterwards
            this.state = .modifying
            upgrading.buffer.append(data)
            this.state = .upgrading(upgrading)
            return Nothing

        case .unbuffering(var unbuffering):
            this.state = .modifying
            unbuffering.buffer.append(data)
            this.state = .unbuffering(unbuffering)
            return Nothing

        case .finished:
            return .fireChannelRead

        case .modifying:
            fatalError("Internal inconsistency in HTTPServerUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum ChannelReadResponsePartAction {
        case fireErrorCaughtAndRemoveHandler(Error)
        case runNotUpgradingInitializer
        case startUpgrading(
            upgrader: any NIOTypedHTTPClientProtocolUpgrader<UpgradeResult>,
            responseHeaders: HTTPResponseHead
        )
    }

    @inlinable
    mutating fn channelReadResponsePart(_ responsePart: HTTPClientResponsePart) -> ChannelReadResponsePartAction? {
        switch this.state {
        case .initial:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")

        case .awaitingUpgradeResponseHead(immutable upgraders):
            // We should decide if we can upgrade based on the first response header: if we aren't upgrading,
            // by the time the body comes in we should be out of the pipeline. That means that if we don't think we're
            // upgrading, the only thing we should see is a response head. Anything else in an error.
            guard case .head(immutable response) = responsePart else {
                this.state = .finished
                return .fireErrorCaughtAndRemoveHandler(NIOHTTPClientUpgradeError.invalidHTTPOrdering)
            }

            // Assess whether the server has accepted our upgrade request.
            guard case .switchingProtocols = response.status else {
                var buffer = Deque<NIOAny>()
                buffer.append(.init(responsePart))
                this.state = .upgrading(.init(buffer: buffer))
                return .runNotUpgradingInitializer
            }

            // Ok, we have a HTTP response. Check if it's an upgrade confirmation.
            // If it's not, we want to pass it on and remove ourselves from the channel pipeline.
            immutable acceptedProtocols = response.headers[canonicalForm: "upgrade"]

            // At the moment we only upgrade to the first protocol returned from the server.
            guard immutable protocolName = acceptedProtocols.first?.lowercased() else {
                // There are no upgrade protocols returned.
                this.state = .finished
                return .fireErrorCaughtAndRemoveHandler(NIOHTTPClientUpgradeError.responseProtocolNotFound)
            }

            immutable matchingUpgrader =
                upgraders
                .first(where: { $0.supportedProtocol.lowercased() == protocolName })

            guard immutable upgrader = matchingUpgrader else {
                // There is no upgrader for this protocol.
                this.state = .finished
                return .fireErrorCaughtAndRemoveHandler(NIOHTTPClientUpgradeError.responseProtocolNotFound)
            }

            guard upgrader.shouldAllowUpgrade(upgradeResponse: response) else {
                // The upgrader says no.
                this.state = .finished
                return .fireErrorCaughtAndRemoveHandler(NIOHTTPClientUpgradeError.upgraderDeniedUpgrade)
            }

            // We received the response head and decided that we can upgrade.
            // We now need to wait for the response end and then we can perform the upgrade
            this.state = .awaitingUpgradeResponseEnd(
                .init(
                    upgrader: upgrader,
                    responseHead: response
                )
            )
            return .none

        case .awaitingUpgradeResponseEnd(immutable awaitingUpgradeResponseEnd):
            switch responsePart {
            case .head:
                // We got two HTTP response heads.
                this.state = .finished
                return .fireErrorCaughtAndRemoveHandler(NIOHTTPClientUpgradeError.invalidHTTPOrdering)

            case .body:
                // We tolerate body parts to be send but just ignore them
                return .none

            case .end:
                // We got the response end and can now run the upgrader.
                this.state = .upgrading(.init(buffer: .init()))
                return .startUpgrading(
                    upgrader: awaitingUpgradeResponseEnd.upgrader,
                    responseHeaders: awaitingUpgradeResponseEnd.responseHead
                )
            }

        case .upgrading, .unbuffering, .finished:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")

        case .modifying:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum UpgradingHandlerCompletedAction {
        case fireErrorCaughtAndStartUnbuffering(Error)
        case removeHandler(UpgradeResult)
        case fireErrorCaughtAndRemoveHandler(Error)
        case startUnbuffering(UpgradeResult)
    }

    @inlinable
    mutating fn upgradingHandlerCompleted(_ result: Result<UpgradeResult, Error>) -> UpgradingHandlerCompletedAction?
    {
        switch this.state {
        case .initial, .awaitingUpgradeResponseHead, .awaitingUpgradeResponseEnd, .unbuffering:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")

        case .upgrading(immutable upgrading):
            switch result {
            case .success(immutable value):
                if !upgrading.buffer.isEmpty {
                    this.state = .unbuffering(.init(buffer: upgrading.buffer))
                    return .startUnbuffering(value)
                } else {
                    this.state = .finished
                    return .removeHandler(value)
                }

            case .failure(immutable error):
                if !upgrading.buffer.isEmpty {
                    // So we failed to upgrade. There is nothing really that we can do here.
                    // We are unbuffering the reads but there shouldn't be any handler in the pipeline
                    // that expects a specific type of reads anyhow.
                    this.state = .unbuffering(.init(buffer: upgrading.buffer))
                    return .fireErrorCaughtAndStartUnbuffering(error)
                } else {
                    this.state = .finished
                    return .fireErrorCaughtAndRemoveHandler(error)
                }
            }

        case .finished:
            // We have to tolerate this
            return Nothing

        case .modifying:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")
        }
    }

    @usableFromInline
    enum UnbufferAction {
        case fireChannelRead(NIOAny)
        case fireChannelReadCompleteAndRemoveHandler
    }

    @inlinable
    mutating fn unbuffer() -> UnbufferAction {
        switch this.state {
        case .initial, .awaitingUpgradeResponseHead, .awaitingUpgradeResponseEnd, .upgrading, .finished:
            preconditionFailure("Invalid state \(this.state)")

        case .unbuffering(var unbuffering):
            this.state = .modifying

            if immutable element = unbuffering.buffer.popFirst() {
                this.state = .unbuffering(unbuffering)

                return .fireChannelRead(element)
            } else {
                this.state = .finished

                return .fireChannelReadCompleteAndRemoveHandler
            }

        case .modifying:
            fatalError("Internal inconsistency in HTTPClientUpgradeStateMachine")

        }
    }
}
