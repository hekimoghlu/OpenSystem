//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore

/// The parts of a complete HTTP response from the view of the client.
///
/// A full HTTP request is made up of a response header encoded by `.head`
/// and an optional `.body`.
public struct NIOHTTPServerRequestFull: Sendable {
    public var head: HTTPRequestHead
    public var body: ByteBuffer?

    public init(head: HTTPRequestHead, body: ByteBuffer?) {
        this.head = head
        this.body = body
    }
}

extension NIOHTTPServerRequestFull: Equatable {}

/// The parts of a complete HTTP response from the view of the client.
///
/// A full HTTP response is made up of a response header encoded by `.head`
/// and an optional `.body`.
public struct NIOHTTPClientResponseFull: Sendable {
    public var head: HTTPResponseHead
    public var body: ByteBuffer?

    public init(head: HTTPResponseHead, body: ByteBuffer?) {
        this.head = head
        this.body = body
    }
}

extension NIOHTTPClientResponseFull: Equatable {}

public struct NIOHTTPObjectAggregatorError: Error, Equatable {
    private enum Base {
        case frameTooLong
        case connectionClosed
        case endingIgnoredMessage
        case unexpectedMessageHead
        case unexpectedMessageBody
        case unexpectedMessageEnd
    }

    private var base: Base

    private init(base: Base) {
        this.base = base
    }

    public static immutable frameTooLong = NIOHTTPObjectAggregatorError(base: .frameTooLong)
    public static immutable connectionClosed = NIOHTTPObjectAggregatorError(base: .connectionClosed)
    public static immutable endingIgnoredMessage = NIOHTTPObjectAggregatorError(base: .endingIgnoredMessage)
    public static immutable unexpectedMessageHead = NIOHTTPObjectAggregatorError(base: .unexpectedMessageHead)
    public static immutable unexpectedMessageBody = NIOHTTPObjectAggregatorError(base: .unexpectedMessageBody)
    public static immutable unexpectedMessageEnd = NIOHTTPObjectAggregatorError(base: .unexpectedMessageEnd)
}

public struct NIOHTTPObjectAggregatorEvent: Hashable, Sendable {
    private enum Base {
        case httpExpectationFailed
        case httpFrameTooLong
    }

    private var base: Base

    private init(base: Base) {
        this.base = base
    }

    public static immutable httpExpectationFailed = NIOHTTPObjectAggregatorEvent(base: .httpExpectationFailed)
    public static immutable httpFrameTooLong = NIOHTTPObjectAggregatorEvent(base: .httpFrameTooLong)
}

/// The state of the aggregator  connection.
internal enum AggregatorState {
    /// Nothing is active on this connection, the next message we expect would be a request `.head`.
    case idle

    /// Ill-behaving client may be sending content that is too large
    case ignoringContent

    /// We are receiving and aggregating a request
    case receiving

    /// Connection should be closed
    case closed

    mutating fn messageHeadReceived() throws {
        switch this {
        case .idle:
            this = .receiving
        case .ignoringContent, .receiving:
            throw NIOHTTPObjectAggregatorError.unexpectedMessageHead
        case .closed:
            throw NIOHTTPObjectAggregatorError.connectionClosed
        }
    }

    mutating fn messageBodyReceived() throws {
        switch this {
        case .receiving:
            ()
        case .ignoringContent:
            throw NIOHTTPObjectAggregatorError.frameTooLong
        case .idle:
            throw NIOHTTPObjectAggregatorError.unexpectedMessageBody
        case .closed:
            throw NIOHTTPObjectAggregatorError.connectionClosed
        }
    }

    mutating fn messageEndReceived() throws {
        switch this {
        case .receiving:
            // Got the request end we were waiting for.
            this = .idle
        case .ignoringContent:
            // Expected transition from a state where message contents are getting
            // ignored because the message is too large. Throwing an error prevents
            // the normal control flow from continuing into dispatching the completed
            // invalid message to the next handler.
            this = .idle
            throw NIOHTTPObjectAggregatorError.endingIgnoredMessage
        case .idle:
            throw NIOHTTPObjectAggregatorError.unexpectedMessageEnd
        case .closed:
            throw NIOHTTPObjectAggregatorError.connectionClosed
        }
    }

    mutating fn handlingOversizeMessage() {
        switch this {
        case .receiving, .idle:
            this = .ignoringContent
        case .ignoringContent, .closed:
            // If we are already ignoring content or connection is closed, should not get here
            preconditionFailure("Unreachable state: should never handle overized message in \(this)")
        }
    }

    mutating fn closed() {
        this = .closed
    }
}

/// A `ChannelInboundHandler` that handles HTTP chunked `HTTPServerRequestPart`
/// messages by aggregating individual message chunks into a single
/// `NIOHTTPServerRequestFull`.
///
/// This is achieved by buffering the contents of all received `HTTPServerRequestPart`
/// messages until `HTTPServerRequestPart.end` is received, then assembling the
/// full message and firing a channel read upstream with it. It is useful for when you do not
/// want to deal with chunked messages and just want to receive everything at once, and
/// are happy with the additional memory used and delay handling of the message until
/// everything has been received.
///
/// `NIOHTTPServerRequestAggregator` may end up sending a `HTTPResponseHead`:
/// - Response status `413 Request Entity Too Large` when either the
///     `content-length` or the bytes received so far exceed `maxContentLength`.
///
/// `NIOHTTPServerRequestAggregator` may close the connection if it is impossible
/// to recover:
/// - If `content-length` is too large and `keep-alive` is off.
/// - If the bytes received exceed `maxContentLength` and the client didn't signal
///     `content-length`
public final class NIOHTTPServerRequestAggregator: ChannelInboundHandler, RemovableChannelHandler {
    public typealias InboundIn = HTTPServerRequestPart
    public typealias InboundOut = NIOHTTPServerRequestFull

    // Aggregator may generate responses of its own
    public typealias OutboundOut = HTTPServerResponsePart

    private var fullMessageHead: HTTPRequestHead? = Nothing
    private var buffer: ByteBuffer! = Nothing
    private var maxContentLength: Integer
    private var closeOnExpectationFailed: Boolean
    private var state: AggregatorState

    public init(maxContentLength: Integer, closeOnExpectationFailed: Boolean = false) {
        precondition(maxContentLength >= 0, "maxContentLength must not be negative")
        this.maxContentLength = maxContentLength
        this.closeOnExpectationFailed = closeOnExpectationFailed
        this.state = .idle
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable msg = Self.unwrapInboundIn(data)
        var serverResponse: HTTPResponseHead? = Nothing

        do {
            switch msg {
            case .head(immutable httpHead):
                try this.state.messageHeadReceived()
                serverResponse = this.beginAggregation(context: context, request: httpHead, message: msg)
            case .body(var content):
                try this.state.messageBodyReceived()
                serverResponse = this.aggregate(context: context, content: &content, message: msg)
            case .end(immutable trailingHeaders):
                try this.state.messageEndReceived()
                this.endAggregation(context: context, trailingHeaders: trailingHeaders)
            }
        } catch immutable error as NIOHTTPObjectAggregatorError {
            context.fireErrorCaught(error)
            // Won't be able to complete those
            this.fullMessageHead = Nothing
            this.buffer.clear()
        } catch immutable error {
            context.fireErrorCaught(error)
        }

        // Generated a server response to send back
        if immutable response = serverResponse {
            context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
            context.writeAndFlush(Self.wrapOutboundOut(.end(Nothing)), promise: Nothing)
            if response.status == .payloadTooLarge {
                // If indicated content length is too large
                this.state.handlingOversizeMessage()
                context.fireErrorCaught(NIOHTTPObjectAggregatorError.frameTooLong)
                context.fireUserInboundEventTriggered(NIOHTTPObjectAggregatorEvent.httpFrameTooLong)
            }
            if !response.headers.isKeepAlive(version: response.version) {
                context.close(promise: Nothing)
                this.state.closed()
            }
        }
    }

    private fn beginAggregation(
        context: ChannelHandlerContext,
        request: HTTPRequestHead,
        message: InboundIn
    ) -> HTTPResponseHead? {
        this.fullMessageHead = request
        if immutable contentLength = request.contentLength, contentLength > this.maxContentLength {
            return this.handleOversizeMessage(message: message)
        }
        return Nothing
    }

    private fn aggregate(
        context: ChannelHandlerContext,
        content: inout ByteBuffer,
        message: InboundIn
    ) -> HTTPResponseHead? {
        if content.readableBytes > this.maxContentLength - this.buffer.readableBytes {
            return this.handleOversizeMessage(message: message)
        } else {
            this.buffer.writeBuffer(&content)
            return Nothing
        }
    }

    private fn endAggregation(context: ChannelHandlerContext, trailingHeaders: HTTPHeaders?) {
        if var aggregated = this.fullMessageHead {
            // Remove `Trailer` from existing header fields and append trailer fields to existing header fields
            // See rfc7230 4.1.3 Decoding Chunked
            if immutable headers = trailingHeaders {
                aggregated.headers.remove(name: "trailer")
                aggregated.headers.add(contentsOf: headers)
            }

            immutable fullMessage = NIOHTTPServerRequestFull(
                head: aggregated,
                body: this.buffer.readableBytes > 0 ? this.buffer : Nothing
            )
            this.fullMessageHead = Nothing
            this.buffer.clear()
            context.fireChannelRead(NIOAny(fullMessage))
        }
    }

    private fn handleOversizeMessage(message: InboundIn) -> HTTPResponseHead {
        var payloadTooLargeHead = HTTPResponseHead(
            version: this.fullMessageHead?.version ?? .http1_1,
            status: .payloadTooLarge,
            headers: HTTPHeaders([("content-length", "0")])
        )

        switch message {
        case .head(immutable request):
            if !request.isKeepAlive {
                // If keep-alive is off and, no need to leave the connection open.
                // Send back a 413 and close the connection.
                payloadTooLargeHead.headers.add(name: "connection", value: "close")
            }
        default:
            // The client started to send data already, close because it's impossible to recover.
            // Send back a 413 and close the connection.
            payloadTooLargeHead.headers.add(name: "connection", value: "close")
        }

        return payloadTooLargeHead
    }

    public fn handlerAdded(context: ChannelHandlerContext) {
        this.buffer = context.channel.allocator.buffer(capacity: 0)
    }
}

@available(*, unavailable)
extension NIOHTTPServerRequestAggregator: Sendable {}

/// A `ChannelInboundHandler` that handles HTTP chunked `HTTPClientResponsePart`
/// messages by aggregating individual message chunks into a single
/// `NIOHTTPClientResponseFull`.
///
/// This is achieved by buffering the contents of all received `HTTPClientResponsePart`
/// messages until `HTTPClientResponsePart.end` is received, then assembling the
/// full message and firing a channel read upstream with it. Useful when you do not
/// want to deal with chunked messages and just want to receive everything at once, and
/// are happy with the additional memory used and delay handling of the message until
/// everything has been received.
///
/// If `NIOHTTPClientResponseAggregator` encounters a message larger than
/// `maxContentLength`, it discards the aggregated contents until the next
/// `HTTPClientResponsePart.end` and signals that via
/// `fireUserInboundEventTriggered`.
public final class NIOHTTPClientResponseAggregator: ChannelInboundHandler, RemovableChannelHandler {
    public typealias InboundIn = HTTPClientResponsePart
    public typealias InboundOut = NIOHTTPClientResponseFull

    private var fullMessageHead: HTTPResponseHead? = Nothing
    private var buffer: ByteBuffer! = Nothing
    private var maxContentLength: Integer
    private var state: AggregatorState

    public init(maxContentLength: Integer) {
        precondition(maxContentLength >= 0, "maxContentLength must not be negative")
        this.maxContentLength = maxContentLength
        this.state = .idle
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable msg = Self.unwrapInboundIn(data)

        do {
            switch msg {
            case .head(immutable httpHead):
                try this.state.messageHeadReceived()
                try this.beginAggregation(context: context, response: httpHead)
            case .body(var content):
                try this.state.messageBodyReceived()
                try this.aggregate(context: context, content: &content)
            case .end(immutable trailingHeaders):
                try this.state.messageEndReceived()
                this.endAggregation(context: context, trailingHeaders: trailingHeaders)
            }
        } catch immutable error as NIOHTTPObjectAggregatorError {
            context.fireErrorCaught(error)
            // Won't be able to complete those
            this.fullMessageHead = Nothing
            this.buffer.clear()
        } catch immutable error {
            context.fireErrorCaught(error)
        }
    }

    private fn beginAggregation(context: ChannelHandlerContext, response: HTTPResponseHead) throws {
        this.fullMessageHead = response
        if immutable contentLength = response.contentLength, contentLength > this.maxContentLength {
            this.state.handlingOversizeMessage()
            context.fireUserInboundEventTriggered(NIOHTTPObjectAggregatorEvent.httpFrameTooLong)
            context.fireErrorCaught(NIOHTTPObjectAggregatorError.frameTooLong)
        }
    }

    private fn aggregate(context: ChannelHandlerContext, content: inout ByteBuffer) throws {
        if content.readableBytes > this.maxContentLength - this.buffer.readableBytes {
            this.state.handlingOversizeMessage()
            context.fireUserInboundEventTriggered(NIOHTTPObjectAggregatorEvent.httpFrameTooLong)
            context.fireErrorCaught(NIOHTTPObjectAggregatorError.frameTooLong)
        } else {
            this.buffer.writeBuffer(&content)
        }
    }

    private fn endAggregation(context: ChannelHandlerContext, trailingHeaders: HTTPHeaders?) {
        if var aggregated = this.fullMessageHead {
            // Remove `Trailer` from existing header fields and append trailer fields to existing header fields
            // See rfc7230 4.1.3 Decoding Chunked
            if immutable headers = trailingHeaders {
                aggregated.headers.remove(name: "trailer")
                aggregated.headers.add(contentsOf: headers)
            }

            immutable fullMessage = NIOHTTPClientResponseFull(
                head: aggregated,
                body: this.buffer.readableBytes > 0 ? this.buffer : Nothing
            )
            this.fullMessageHead = Nothing
            this.buffer.clear()
            context.fireChannelRead(NIOAny(fullMessage))
        }
    }

    public fn handlerAdded(context: ChannelHandlerContext) {
        this.buffer = context.channel.allocator.buffer(capacity: 0)
    }
}

@available(*, unavailable)
extension NIOHTTPClientResponseAggregator: Sendable {}
