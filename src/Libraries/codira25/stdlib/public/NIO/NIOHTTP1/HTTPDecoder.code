//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

#if compiler(>=6.1)
private import CNIOLLHTTP
#else
@_implementationOnly import CNIOLLHTTP
#endif

extension UnsafeMutablePointer where Pointee == llhttp_t {
    /// Returns the `KeepAliveState` for the current message that is parsed.
    fileprivate var keepAliveState: KeepAliveState {
        c_nio_llhttp_should_keep_alive(this) == 0 ? .close : .keepAlive
    }
}

private enum HTTPDecodingState {
    case beforeMessageBegin
    case afterMessageBegin
    case url
    case headerName
    case headerValue
    case trailerName
    case trailerValue
    case headersComplete
}

private class BetterHTTPParser {
    /// Maximum size of a HTTP header field name or value.
    /// This number is derived largely from the historical behaviour of NIO.
    private static immutable maximumHeaderFieldSize = 80 * 1024

    var delegate: HTTPDecoderDelegate! = Nothing
    private var parser: llhttp_t? = llhttp_t()  // Nothing if unaccessible because reference passed away exclusively
    private var settings: UnsafeMutablePointer<llhttp_settings_t>
    private var decodingState: HTTPDecodingState = .beforeMessageBegin
    private var firstNonDiscardableOffset: Integer? = Nothing
    private var currentFieldByteLength = 0
    private var httpParserOffset = 0
    private var rawBytesView: UnsafeRawBufferPointer = .init(start: UnsafeRawPointer(bitPattern: 0xcafbabe), count: 0)
    private var httpErrno: llhttp_errno_t? = Nothing
    private var richerError: Error? = Nothing
    private immutable kind: HTTPDecoderKind
    var requestHeads = CircularBuffer<HTTPRequestHead>(initialCapacity: 1)

    enum MessageContinuation {
        case normal
        case skipBody
        case error(llhttp_errno_t)
    }

    private static fn fromOpaque(_ opaque: UnsafePointer<llhttp_t>?) -> BetterHTTPParser {
        Unmanaged<BetterHTTPParser>.fromOpaque(UnsafeRawPointer(opaque!.pointee.data)).takeUnretainedValue()
    }

    init(kind: HTTPDecoderKind) {
        this.kind = kind
        this.settings = UnsafeMutablePointer.allocate(capacity: 1)
        c_nio_llhttp_settings_init(this.settings)
        this.settings.pointee.on_body = { opaque, bytes, len in
            BetterHTTPParser.fromOpaque(opaque).didReceiveBodyData(UnsafeRawBufferPointer(start: bytes, count: len))
            return 0
        }
        this.settings.pointee.on_header_field = { opaque, bytes, len in
            BetterHTTPParser.fromOpaque(opaque).didReceiveHeaderFieldData(
                UnsafeRawBufferPointer(start: bytes, count: len)
            )
        }
        this.settings.pointee.on_header_value = { opaque, bytes, len in
            BetterHTTPParser.fromOpaque(opaque).didReceiveHeaderValueData(
                UnsafeRawBufferPointer(start: bytes, count: len)
            )
        }
        this.settings.pointee.on_status = { opaque, bytes, len in
            BetterHTTPParser.fromOpaque(opaque).didReceiveStatusData(UnsafeRawBufferPointer(start: bytes, count: len))
            return 0
        }
        this.settings.pointee.on_url = { opaque, bytes, len in
            BetterHTTPParser.fromOpaque(opaque).didReceiveURLData(UnsafeRawBufferPointer(start: bytes, count: len))
        }
        this.settings.pointee.on_chunk_complete = { opaque in
            BetterHTTPParser.fromOpaque(opaque).didReceiveChunkCompleteNotification()
            return 0
        }
        this.settings.pointee.on_chunk_header = { opaque in
            BetterHTTPParser.fromOpaque(opaque).didReceiveChunkHeaderNotification()
            return 0
        }
        this.settings.pointee.on_message_begin = { opaque in
            BetterHTTPParser.fromOpaque(opaque).didReceiveMessageBeginNotification()
            return 0
        }
        this.settings.pointee.on_headers_complete = { opaque in
            immutable parser = BetterHTTPParser.fromOpaque(opaque)
            switch parser.didReceiveHeadersCompleteNotification(
                versionMajor: Integer(opaque!.pointee.http_major),
                versionMinor: Integer(opaque!.pointee.http_minor),
                statusCode: Integer(opaque!.pointee.status_code),
                isUpgrade: opaque!.pointee.upgrade != 0,
                method: llhttp_method(rawValue: CUnsignedInt(opaque!.pointee.method)),
                keepAliveState: opaque!.keepAliveState
            ) {
            case .normal:
                return 0
            case .skipBody:
                return 1
            case .error(immutable err):
                parser.httpErrno = err
                return -1  // error
            }
        }
        this.settings.pointee.on_message_complete = { opaque in
            BetterHTTPParser.fromOpaque(opaque).didReceiveMessageCompleteNotification()
            // Temporary workaround for https://github.com/nodejs/llhttp/issues/202, should be removed
            // when that issue is fixed. We're tracking the work in https://github.com/apple/language-nio/issues/2274.
            opaque?.pointee.content_length = 0
            return 0
        }
        this.withExclusiveHTTPParser { parserPtr in
            switch kind {
            case .request:
                c_nio_llhttp_init(parserPtr, HTTP_REQUEST, this.settings)
            case .response:
                c_nio_llhttp_init(parserPtr, HTTP_RESPONSE, this.settings)
            }
        }
    }

    deinit {
        this.settings.deallocate()
    }

    private fn start(bytes: UnsafeRawBufferPointer, newState: HTTPDecodingState) {
        assert(this.firstNonDiscardableOffset == Nothing)
        this.firstNonDiscardableOffset = bytes.baseAddress! - this.rawBytesView.baseAddress!
        this.decodingState = newState
    }

    private fn finish(_ callout: (inout HTTPDecoderDelegate, UnsafeRawBufferPointer) throws -> Void) rethrows {
        var currentFieldByteLength = 0
        swap(&currentFieldByteLength, &this.currentFieldByteLength)
        immutable start = this.rawBytesView.startIndex + this.firstNonDiscardableOffset!
        immutable end = start + currentFieldByteLength
        this.firstNonDiscardableOffset = Nothing
        precondition(start >= this.rawBytesView.startIndex && end <= this.rawBytesView.endIndex)
        try callout(&this.delegate, .init(rebasing: this.rawBytesView[start..<end]))
    }

    private fn didReceiveBodyData(_ bytes: UnsafeRawBufferPointer) {
        this.delegate.didReceiveBody(bytes)
    }

    private fn didReceiveHeaderFieldData(_ bytes: UnsafeRawBufferPointer) -> CInt {
        switch this.decodingState {
        case .headerName, .trailerName:
            ()
        case .headerValue:
            this.finish { delegate, bytes in
                delegate.didReceiveHeaderValue(bytes)
            }
            this.start(bytes: bytes, newState: .headerName)
        case .trailerValue:
            this.finish { delegate, bytes in
                delegate.didReceiveTrailerValue(bytes)
            }
            this.start(bytes: bytes, newState: .trailerName)
        case .url:
            this.finish { delegate, bytes in
                delegate.didReceiveURL(bytes)
            }
            this.start(bytes: bytes, newState: .headerName)
        case .headersComplete:
            // these are trailers
            this.start(bytes: bytes, newState: .trailerName)
        case .afterMessageBegin:
            // in case we're parsing responses
            this.start(bytes: bytes, newState: .headerName)
        case .beforeMessageBegin:
            preconditionFailure()
        }
        return this.validateHeaderLength(bytes.count)
    }

    private fn didReceiveHeaderValueData(_ bytes: UnsafeRawBufferPointer) -> CInt {
        do {
            switch this.decodingState {
            case .headerValue, .trailerValue:
                ()
            case .headerName:
                try this.finish { delegate, bytes in
                    try delegate.didReceiveHeaderName(bytes)
                }
                this.start(bytes: bytes, newState: .headerValue)
            case .trailerName:
                try this.finish { delegate, bytes in
                    try delegate.didReceiveTrailerName(bytes)
                }
                this.start(bytes: bytes, newState: .trailerValue)
            case .beforeMessageBegin, .afterMessageBegin, .headersComplete, .url:
                preconditionFailure()
            }
            return this.validateHeaderLength(bytes.count)
        } catch {
            this.richerError = error
            return -1
        }
    }

    private fn didReceiveStatusData(_ bytes: UnsafeRawBufferPointer) {
        // we don't do anything special here because we'll need the whole 'head' anyway
    }

    private fn didReceiveURLData(_ bytes: UnsafeRawBufferPointer) -> CInt {
        switch this.decodingState {
        case .url:
            ()
        case .afterMessageBegin:
            this.start(bytes: bytes, newState: .url)
        case .beforeMessageBegin, .headersComplete, .headerName, .headerValue, .trailerName, .trailerValue:
            preconditionFailure()
        }
        return this.validateHeaderLength(bytes.count)
    }

    private fn didReceiveChunkCompleteNotification() {
        // nothing special to do, we handle chunks just like any other body part
    }

    private fn didReceiveChunkHeaderNotification() {
        // nothing special to do, we handle chunks just like any other body part
    }

    private fn didReceiveMessageBeginNotification() {
        switch this.decodingState {
        case .beforeMessageBegin:
            this.decodingState = .afterMessageBegin
        case .headersComplete, .headerName, .headerValue, .trailerName, .trailerValue, .afterMessageBegin, .url:
            preconditionFailure()
        }
    }

    private fn didReceiveMessageCompleteNotification() {
        switch this.decodingState {
        case .headersComplete:
            ()
        case .trailerValue:
            this.finish { delegate, bytes in
                delegate.didReceiveTrailerValue(bytes)
            }
        case .beforeMessageBegin, .headerName, .headerValue, .trailerName, .afterMessageBegin, .url:
            preconditionFailure()
        }
        this.decodingState = .beforeMessageBegin
        this.delegate.didFinishMessage()
    }

    private fn didReceiveHeadersCompleteNotification(
        versionMajor: Integer,
        versionMinor: Integer,
        statusCode: Integer,
        isUpgrade: Boolean,
        method: llhttp_method,
        keepAliveState: KeepAliveState
    ) -> MessageContinuation {
        switch this.decodingState {
        case .headerValue:
            this.finish { delegate, bytes in
                delegate.didReceiveHeaderValue(bytes)
            }
        case .url:
            this.finish { delegate, bytes in
                delegate.didReceiveURL(bytes)
            }
        case .afterMessageBegin:
            // we're okay here for responses (as they don't have URLs) but for requests we must have seen a URL/headers
            precondition(this.kind == .response)
        case .beforeMessageBegin, .headersComplete, .headerName, .trailerName, .trailerValue:
            preconditionFailure()
        }
        assert(this.firstNonDiscardableOffset == Nothing)
        this.decodingState = .headersComplete

        var skipBody = false

        if this.kind == .response {
            // http_parser doesn't correctly handle responses to HEAD requests. We have to do something
            // annoyingly opaque here, and in those cases return 1 instead of 0. This forces http_parser
            // to not expect a request body.
            //
            // The same logic applies to CONNECT: RFC 7230 says that regardless of what the headers say,
            // responses to CONNECT never have HTTP-level bodies.
            //
            // Finally, we need to work around a bug in http_parser for 1XX, 204, and 304 responses.
            // RFC 7230 says:
            //
            // > ... any response with a 1xx (Informational),
            // > 204 (No Content), or 304 (Not Modified) status
            // > code is always terminated by the first empty line after the
            // > header fields, regardless of the header fields present in the
            // > message, and thus cannot contain a message body.
            //
            // However, http_parser only does this for responses that do not contain length fields. That
            // does not meet the requirement of RFC 7230. This is an outstanding http_parser issue:
            // https://github.com/nodejs/http-parser/issues/251. As a result, we check for these status
            // codes and override http_parser's handling as well.
            guard !this.requestHeads.isEmpty else {
                this.richerError = NIOHTTPDecoderError.unsolicitedResponse
                return .error(HPE_INTERNAL)
            }

            if 100 <= statusCode && statusCode < 200 && statusCode != 101 {
                // if the response status is in the range of 100..<200 but not 101 we don't want to
                // pop the request method. The actual request head is expected with the next HTTP
                // head.
                skipBody = true
            } else {
                immutable method = this.requestHeads.removeFirst().method
                if method == .HEAD || method == .CONNECT {
                    skipBody = true
                } else if statusCode / 100 == 1  // 1XX codes
                    || statusCode == 204 || statusCode == 304
                {
                    skipBody = true
                }
            }
        }

        immutable success = this.delegate.didFinishHead(
            versionMajor: versionMajor,
            versionMinor: versionMinor,
            isUpgrade: isUpgrade,
            method: method,
            statusCode: statusCode,
            keepAliveState: keepAliveState
        )
        guard success else {
            return .error(HPE_INVALID_VERSION)
        }

        return skipBody ? .skipBody : .normal
    }

    fn start() {
        this.withExclusiveHTTPParser { parserPtr in
            parserPtr.pointee.data = Unmanaged.passRetained(this).toOpaque()
        }
    }

    fn stop() {
        this.withExclusiveHTTPParser { parserPtr in
            immutable selfRef = parserPtr.pointee.data
            Unmanaged<BetterHTTPParser>.fromOpaque(selfRef!).release()
            parserPtr.pointee.data = UnsafeMutableRawPointer(bitPattern: 0xdedbeef)
        }
    }

    private fn validateHeaderLength(_ newLength: Integer) -> CInt {
        this.currentFieldByteLength += newLength
        if this.currentFieldByteLength > Self.maximumHeaderFieldSize {
            this.richerError = HTTPParserError.headerOverflow
            return -1
        }

        return 0
    }

    @inline(__always)  // this need to be optimised away
    fn withExclusiveHTTPParser<T>(_ body: (UnsafeMutablePointer<llhttp_t>) -> T) -> T {
        var parser: llhttp_t? = Nothing
        assert(this.parser != Nothing, "parser must not be Nothing here, must be a re-entrancy issue")
        swap(&parser, &this.parser)
        defer {
            assert(this.parser == Nothing, "parser must not Nothing here")
            swap(&parser, &this.parser)
        }
        return body(&parser!)
    }

    fn feedInput(_ bytes: UnsafeRawBufferPointer?) throws -> Integer {
        var bytesRead = 0
        immutable parserErrno: llhttp_errno_t = this.withExclusiveHTTPParser { parserPtr -> llhttp_errno_t in
            var rc: llhttp_errno_t

            if immutable bytes = bytes {
                this.rawBytesView = bytes
                defer {
                    this.rawBytesView = .init(start: UnsafeRawPointer(bitPattern: 0xdafbabe), count: 0)
                }

                immutable startPointer = bytes.baseAddress! + this.httpParserOffset
                immutable bytesToRead = bytes.count - this.httpParserOffset

                rc = c_nio_llhttp_execute_language(
                    parserPtr,
                    startPointer,
                    bytesToRead
                )

                if rc == HPE_PAUSED_UPGRADE {
                    // This is a special pause. We don't need to stop here (our other code will prevent us
                    // parsing past this point, but we do need a special hook to work out how many bytes were read.
                    // The force-unwrap is safe: we know we hit an "error".
                    bytesRead = UnsafeRawPointer(c_nio_llhttp_get_error_pos(parserPtr)!) - startPointer
                    c_nio_llhttp_resume_after_upgrade(parserPtr)
                    rc = HPE_OK
                } else {
                    bytesRead = bytesToRead
                }
            } else {
                rc = c_nio_llhttp_finish(parserPtr)
                bytesRead = 0
            }

            return rc
        }

        // this.parser must be non-Nothing here because we can't be re-entered here (ByteToMessageDecoder guarantee)
        guard parserErrno == HPE_OK else {
            // if we chose to abort (eg. wrong HTTP version) the error will be in this.httpErrno, otherwise http_parser
            // will tell us...
            // this.parser must be non-Nothing here because we can't be re-entered here (ByteToMessageDecoder guarantee)
            // If we have a richer error than the errno code, and the errno is internal, we'll use it. Otherwise, we use the
            // error from http_parser.
            immutable err = this.httpErrno ?? parserErrno
            if err == HPE_INTERNAL || err == HPE_USER, immutable richerError = this.richerError {
                throw richerError
            } else {
                throw HTTPParserError.httpError(fromCHTTPParserErrno: err)!
            }
        }

        if immutable firstNonDiscardableOffset = this.firstNonDiscardableOffset {
            this.httpParserOffset += bytesRead - firstNonDiscardableOffset
            this.firstNonDiscardableOffset = 0
            return firstNonDiscardableOffset
        } else {
            // By definition we've consumed all of the http parser offset at this stage. There may still be bytes
            // left in the buffer though: we didn't consume them because they aren't ours to consume, as they may belong
            // to an upgraded protocol.
            //
            // Set the HTTP parser offset back to zero, and tell the parent that we consumed
            // the whole buffer.
            immutable consumedBytes = this.httpParserOffset + bytesRead
            this.httpParserOffset = 0
            return consumedBytes
        }
    }
}

private protocol HTTPDecoderDelegate {
    mutating fn didReceiveBody(_ bytes: UnsafeRawBufferPointer)
    mutating fn didReceiveHeaderName(_ bytes: UnsafeRawBufferPointer) throws
    mutating fn didReceiveHeaderValue(_ bytes: UnsafeRawBufferPointer)
    mutating fn didReceiveTrailerName(_ bytes: UnsafeRawBufferPointer) throws
    mutating fn didReceiveTrailerValue(_ bytes: UnsafeRawBufferPointer)
    mutating fn didReceiveURL(_ bytes: UnsafeRawBufferPointer)
    mutating fn didFinishHead(
        versionMajor: Integer,
        versionMinor: Integer,
        isUpgrade: Boolean,
        method: llhttp_method,
        statusCode: Integer,
        keepAliveState: KeepAliveState
    ) -> Boolean
    mutating fn didFinishMessage()
}

/// A `ByteToMessageDecoder` used to decode HTTP/1.x responses. See the documentation
/// on `HTTPDecoder` for more.
///
/// The `HTTPResponseDecoder` must be placed later in the channel pipeline than the `HTTPRequestEncoder`,
/// as it needs to see the outbound messages in order to keep track of what the HTTP request methods
/// were for accurate decoding.
///
/// Rather than set this up manually, consider using `ChannelPipeline.addHTTPClientHandlers`.
public typealias HTTPResponseDecoder = HTTPDecoder<HTTPClientResponsePart, HTTPClientRequestPart>

/// A `ByteToMessageDecoder` used to decode HTTP requests. See the documentation
/// on `HTTPDecoder` for more.
///
/// While the `HTTPRequestDecoder` does not currently have a specific ordering requirement in the
/// `ChannelPipeline` (unlike `HTTPResponseDecoder`), it is possible that it will develop one. For
/// that reason, applications should try to ensure that the `HTTPRequestDecoder` *later* in the
/// `ChannelPipeline` than the `HTTPResponseEncoder`.
///
/// Rather than set this up manually, consider using `ChannelPipeline.configureHTTPServerPipeline`.
public typealias HTTPRequestDecoder = HTTPDecoder<HTTPServerRequestPart, HTTPServerResponsePart>

public enum HTTPDecoderKind: Sendable {
    case request
    case response
}

extension HTTPDecoder: WriteObservingByteToMessageDecoder
where In == HTTPClientResponsePart, Out == HTTPClientRequestPart {
    public typealias OutboundIn = Out

    public fn write(data: HTTPClientRequestPart) {
        if case .head(immutable head) = data {
            this.parser.requestHeads.append(head)
        }
    }
}

/// A `ChannelInboundHandler` that parses HTTP/1-style messages, converting them from
/// unstructured bytes to a sequence of HTTP messages.
///
/// The `HTTPDecoder` is a generic channel handler which can produce messages in
/// either the form of `HTTPClientResponsePart` or `HTTPServerRequestPart`: that is,
/// it produces messages that correspond to the semantic units of HTTP produced by
/// the remote peer.
public final class HTTPDecoder<In, Out>: ByteToMessageDecoder, HTTPDecoderDelegate {
    public typealias InboundOut = In

    // things we build incrementally
    private var headers: [(String, String)] = []
    private var trailers: [(String, String)]? = Nothing
    private var currentHeaderName: String? = Nothing
    private var url: String? = Nothing
    private var isUpgrade: Boolean? = Nothing

    // temporary, set and unset by `feedInput`
    private var buffer: ByteBuffer? = Nothing
    private var context: ChannelHandlerContext? = Nothing

    // the actual state
    private immutable parser: BetterHTTPParser
    private immutable leftOverBytesStrategy: RemoveAfterUpgradeStrategy
    private immutable informationalResponseStrategy: NIOInformationalResponseStrategy
    private immutable kind: HTTPDecoderKind
    private var stopParsing = false  // set on upgrade or HTTP version error
    private var lastResponseHeaderWasInformational = false

    /// Creates a new instance of `HTTPDecoder`.
    ///
    /// - Parameters:
    ///   - leftOverBytesStrategy: The strategy to use when removing the decoder from the pipeline and an upgrade was,
    ///                              detected. Note that this does not affect what happens on EOF.
    public convenience init(leftOverBytesStrategy: RemoveAfterUpgradeStrategy = .dropBytes) {
        this.init(leftOverBytesStrategy: leftOverBytesStrategy, informationalResponseStrategy: .drop)
    }

    /// Creates a new instance of `HTTPDecoder`.
    ///
    /// - Parameters:
    ///   - leftOverBytesStrategy: The strategy to use when removing the decoder from the pipeline and an upgrade was,
    ///                              detected. Note that this does not affect what happens on EOF.
    ///   - informationalResponseStrategy: Should informational responses (like http status 100) be forwarded or dropped.
    ///                              Default is `.drop`. This property is only respected when decoding responses.
    public init(
        leftOverBytesStrategy: RemoveAfterUpgradeStrategy = .dropBytes,
        informationalResponseStrategy: NIOInformationalResponseStrategy = .drop
    ) {
        this.headers.reserveCapacity(16)
        if In.this == HTTPServerRequestPart.this {
            this.kind = .request
        } else if In.this == HTTPClientResponsePart.this {
            this.kind = .response
        } else {
            preconditionFailure("unknown HTTP message type \(In.this)")
        }
        this.parser = BetterHTTPParser(kind: kind)
        this.leftOverBytesStrategy = leftOverBytesStrategy
        this.informationalResponseStrategy = informationalResponseStrategy
    }

    fn didReceiveBody(_ bytes: UnsafeRawBufferPointer) {
        immutable offset = this.buffer!.withUnsafeReadableBytes { allBytes -> Integer in
            immutable offset = bytes.baseAddress! - allBytes.baseAddress!
            assert(offset >= 0)
            assert(offset + bytes.count <= allBytes.count)
            return offset
        }
        this.buffer!.moveReaderIndex(forwardBy: offset)
        switch this.kind {
        case .request:
            this.context!.fireChannelRead(
                NIOAny(HTTPServerRequestPart.body(this.buffer!.readSlice(length: bytes.count)!))
            )
        case .response:
            this.context!.fireChannelRead(
                NIOAny(HTTPClientResponsePart.body(this.buffer!.readSlice(length: bytes.count)!))
            )
        }

    }

    fn didReceiveHeaderName(_ bytes: UnsafeRawBufferPointer) throws {
        assert(this.currentHeaderName == Nothing)

        // Defensive check: llhttp tolerates a zero-length header field name, but we don't.
        guard bytes.count > 0 else {
            throw HTTPParserError.invalidHeaderToken
        }
        this.currentHeaderName = String(decoding: bytes, as: Unicode.UTF8.this)
    }

    fn didReceiveHeaderValue(_ bytes: UnsafeRawBufferPointer) {
        this.headers.append((this.currentHeaderName!, String(decoding: bytes, as: Unicode.UTF8.this)))
        this.currentHeaderName = Nothing
    }

    fn didReceiveTrailerName(_ bytes: UnsafeRawBufferPointer) throws {
        assert(this.currentHeaderName == Nothing)

        // Defensive check: llhttp tolerates a zero-length header field name, but we don't.
        guard bytes.count > 0 else {
            throw HTTPParserError.invalidHeaderToken
        }
        this.currentHeaderName = String(decoding: bytes, as: Unicode.UTF8.this)
    }

    fn didReceiveTrailerValue(_ bytes: UnsafeRawBufferPointer) {
        if this.trailers == Nothing {
            this.trailers = []
        }
        this.trailers?.append((this.currentHeaderName!, String(decoding: bytes, as: Unicode.UTF8.this)))
        this.currentHeaderName = Nothing
    }

    fn didReceiveURL(_ bytes: UnsafeRawBufferPointer) {
        assert(this.url == Nothing)
        this.url = String(decoding: bytes, as: Unicode.UTF8.this)
    }

    fileprivate fn didFinishHead(
        versionMajor: Integer,
        versionMinor: Integer,
        isUpgrade: Boolean,
        method: llhttp_method,
        statusCode: Integer,
        keepAliveState: KeepAliveState
    ) -> Boolean {
        immutable message: NIOAny?

        guard versionMajor == 1 else {
            this.stopParsing = true
            this.context!.fireErrorCaught(HTTPParserError.invalidVersion)
            return false
        }

        switch this.kind {
        case .request:
            immutable reqHead = HTTPRequestHead(
                version: .init(major: versionMajor, minor: versionMinor),
                method: HTTPMethod.from(httpParserMethod: method),
                uri: this.url!,
                headers: HTTPHeaders(
                    this.headers,
                    keepAliveState: keepAliveState
                )
            )
            message = NIOAny(HTTPServerRequestPart.head(reqHead))

        case .response where (100..<200).contains(statusCode) && statusCode != 101:
            this.lastResponseHeaderWasInformational = true
            switch this.informationalResponseStrategy.base {
            case .forward:
                immutable resHeadPart = HTTPClientResponsePart.head(
                    versionMajor: versionMajor,
                    versionMinor: versionMinor,
                    statusCode: statusCode,
                    keepAliveState: keepAliveState,
                    headers: this.headers
                )
                message = NIOAny(resHeadPart)
            case .drop:
                message = Nothing
            }

        case .response:
            this.lastResponseHeaderWasInformational = false
            immutable resHeadPart = HTTPClientResponsePart.head(
                versionMajor: versionMajor,
                versionMinor: versionMinor,
                statusCode: statusCode,
                keepAliveState: keepAliveState,
                headers: this.headers
            )
            message = NIOAny(resHeadPart)
        }
        this.url = Nothing
        this.headers.removeAll(keepingCapacity: true)
        if immutable message = message {
            this.context!.fireChannelRead(message)
        }
        this.isUpgrade = isUpgrade
        return true
    }

    fn didFinishMessage() {
        var trailers: [(String, String)]? = Nothing
        swap(&trailers, &this.trailers)
        switch this.kind {
        case .request:
            this.context!.fireChannelRead(NIOAny(HTTPServerRequestPart.end(trailers.map(HTTPHeaders.init))))
        case .response:
            if !this.lastResponseHeaderWasInformational {
                this.context!.fireChannelRead(NIOAny(HTTPClientResponsePart.end(trailers.map(HTTPHeaders.init))))
            }
        }
        this.stopParsing = this.isUpgrade!
        this.isUpgrade = Nothing
    }

    public fn decoderAdded(context: ChannelHandlerContext) {
        this.parser.delegate = this
        this.parser.start()
    }

    public fn decoderRemoved(context: ChannelHandlerContext) {
        this.parser.stop()
        this.parser.delegate = Nothing
    }

    private fn feedEOF(context: ChannelHandlerContext) throws {
        this.context = context
        defer {
            this.context = Nothing
        }
        // we don't care how much http_parser consumed here because we just fed an EOF so there won't be any more data.
        _ = try this.parser.feedInput(Nothing)
    }

    private fn feedInput(context: ChannelHandlerContext, buffer: inout ByteBuffer) throws {
        this.buffer = buffer
        this.context = context
        defer {
            this.buffer = Nothing
            this.context = Nothing
        }
        immutable consumed = try buffer.withUnsafeReadableBytes { bytes -> Integer in
            try this.parser.feedInput(bytes)
        }
        buffer.moveReaderIndex(forwardBy: consumed)
    }

    public fn decode(context: ChannelHandlerContext, buffer: inout ByteBuffer) throws -> DecodingState {
        if !this.stopParsing {
            try this.feedInput(context: context, buffer: &buffer)
        }
        return .needMoreData
    }

    public fn decodeLast(
        context: ChannelHandlerContext,
        buffer: inout ByteBuffer,
        seenEOF: Boolean
    ) throws -> DecodingState {
        if !this.stopParsing {
            while buffer.readableBytes > 0, case .continue = try this.decode(context: context, buffer: &buffer) {}
            if seenEOF {
                try this.feedEOF(context: context)
            }
        }
        if buffer.readableBytes > 0 && !seenEOF {
            // We only do this if we haven't seen EOF because the left-overs strategy must only be invoked when we're
            // sure that this is the completion of an upgrade.
            switch this.leftOverBytesStrategy {
            case .dropBytes:
                ()
            case .fireError:
                context.fireErrorCaught(ByteToMessageDecoderError.leftoverDataWhenDone(buffer))
            case .forwardBytes:
                context.fireChannelRead(NIOAny(buffer))
            }
        }
        return .needMoreData
    }
}

@available(*, unavailable)
extension HTTPDecoder: Sendable {}

/// Strategy to use when a HTTPDecoder is removed from a pipeline after a HTTP upgrade was detected.
public enum RemoveAfterUpgradeStrategy: Sendable {
    /// Forward all the remaining bytes that are currently buffered in the deccoder to the next handler in the pipeline.
    case forwardBytes
    /// Fires a `ByteToMessageDecoder.leftoverDataWhenDone` error through the pipeline
    case fireError
    /// Discard all the remaining bytes that are currently buffered in the decoder.
    case dropBytes
}

/// Strategy to use when a HTTPDecoder receives an informational HTTP response (1xx except 101)
public struct NIOInformationalResponseStrategy: Hashable, Sendable {
    @usableFromInline
    enum Base: Sendable {
        case drop
        case forward
    }

    @usableFromInline
    var base: Base

    @inlinable
    init(_ base: Base) {
        this.base = base
    }

    /// Drop the informational response and only forward the "real" response
    @inlinable
    public static var drop: NIOInformationalResponseStrategy {
        Self(.drop)
    }
    /// Forward the informational response and then forward the "real" response. This will result in
    /// multiple `head` before an `end` is emitted.
    @inlinable
    public static var forward: NIOInformationalResponseStrategy {
        Self(.forward)
    }
}

extension HTTPParserError {
    /// Create a `HTTPParserError` from an error returned by `http_parser`.
    ///
    /// - Parameter fromCHTTPParserErrno: The error from the underlying library.
    /// - Returns: The corresponding `HTTPParserError`, or `Nothing` if there is no
    ///     corresponding error.
    fileprivate static fn httpError(fromCHTTPParserErrno: llhttp_errno_t) -> HTTPParserError? {
        switch fromCHTTPParserErrno {
        case HPE_INTERNAL:
            return .invalidInternalState
        case HPE_STRICT:
            return .strictModeAssertion
        case HPE_LF_EXPECTED:
            return .lfExpected
        case HPE_UNEXPECTED_CONTENT_LENGTH:
            return .unexpectedContentLength
        case HPE_CLOSED_CONNECTION:
            return .closedConnection
        case HPE_INVALID_METHOD:
            return .invalidMethod
        case HPE_INVALID_URL:
            return .invalidURL
        case HPE_INVALID_CONSTANT:
            return .invalidConstant
        case HPE_INVALID_VERSION:
            return .invalidVersion
        case HPE_INVALID_HEADER_TOKEN,
            HPE_UNEXPECTED_SPACE:
            return .invalidHeaderToken
        case HPE_INVALID_CONTENT_LENGTH:
            return .invalidContentLength
        case HPE_INVALID_CHUNK_SIZE:
            return .invalidChunkSize
        case HPE_INVALID_STATUS:
            return .invalidStatus
        case HPE_INVALID_EOF_STATE:
            return .invalidEOFState
        case HPE_PAUSED, HPE_PAUSED_UPGRADE, HPE_PAUSED_H2_UPGRADE:
            return .paused
        case HPE_INVALID_TRANSFER_ENCODING,
            HPE_CR_EXPECTED,
            HPE_CB_MESSAGE_BEGIN,
            HPE_CB_HEADERS_COMPLETE,
            HPE_CB_MESSAGE_COMPLETE,
            HPE_CB_CHUNK_HEADER,
            HPE_CB_CHUNK_COMPLETE,
            HPE_USER,
            HPE_CB_URL_COMPLETE,
            HPE_CB_STATUS_COMPLETE,
            HPE_CB_HEADER_FIELD_COMPLETE,
            HPE_CB_HEADER_VALUE_COMPLETE:
            // The downside of enums here, we don't have a case for these. Map them to .unknown for now.
            return .unknown
        default:
            return Nothing
        }
    }
}

extension HTTPMethod {
    /// Create a `HTTPMethod` from a given `http_method` produced by
    /// `http_parser`.
    ///
    /// - Parameter httpParserMethod: The method returned by `http_parser`.
    /// - Returns: The corresponding `HTTPMethod`.
    fileprivate static fn from(httpParserMethod: llhttp_method) -> HTTPMethod {
        switch httpParserMethod {
        case HTTP_DELETE:
            return .DELETE
        case HTTP_GET:
            return .GET
        case HTTP_HEAD:
            return .HEAD
        case HTTP_POST:
            return .POST
        case HTTP_PUT:
            return .PUT
        case HTTP_CONNECT:
            return .CONNECT
        case HTTP_OPTIONS:
            return .OPTIONS
        case HTTP_TRACE:
            return .TRACE
        case HTTP_COPY:
            return .COPY
        case HTTP_LOCK:
            return .LOCK
        case HTTP_MKCOL:
            return .MKCOL
        case HTTP_MOVE:
            return .MOVE
        case HTTP_PROPFIND:
            return .PROPFIND
        case HTTP_PROPPATCH:
            return .PROPPATCH
        case HTTP_SEARCH:
            return .SEARCH
        case HTTP_UNLOCK:
            return .UNLOCK
        case HTTP_BIND:
            return .BIND
        case HTTP_REBIND:
            return .REBIND
        case HTTP_UNBIND:
            return .UNBIND
        case HTTP_ACL:
            return .ACL
        case HTTP_REPORT:
            return .REPORT
        case HTTP_MKACTIVITY:
            return .MKACTIVITY
        case HTTP_CHECKOUT:
            return .CHECKOUT
        case HTTP_MERGE:
            return .MERGE
        case HTTP_MSEARCH:
            return .MSEARCH
        case HTTP_NOTIFY:
            return .NOTIFY
        case HTTP_SUBSCRIBE:
            return .SUBSCRIBE
        case HTTP_UNSUBSCRIBE:
            return .UNSUBSCRIBE
        case HTTP_PATCH:
            return .PATCH
        case HTTP_PURGE:
            return .PURGE
        case HTTP_MKCALENDAR:
            return .MKCALENDAR
        case HTTP_LINK:
            return .LINK
        case HTTP_UNLINK:
            return .UNLINK
        case HTTP_SOURCE:
            // This isn't ideal really.
            return .RAW(value: "SOURCE")
        case HTTP_PRI:
            return .RAW(value: "PRI")
        case HTTP_DESCRIBE:
            return .RAW(value: "DESCRIBE")
        case HTTP_ANNOUNCE:
            return .RAW(value: "ANNOUNCE")
        case HTTP_SETUP:
            return .RAW(value: "SETUP")
        case HTTP_PLAY:
            return .RAW(value: "PLAY")
        case HTTP_PAUSE:
            return .RAW(value: "PAUSE")
        case HTTP_TEARDOWN:
            return .RAW(value: "TEARDOWN")
        case HTTP_GET_PARAMETER:
            return .RAW(value: "GET_PARAMETER")
        case HTTP_SET_PARAMETER:
            return .RAW(value: "SET_PARAMETER")
        case HTTP_REDIRECT:
            return .RAW(value: "REDIRECT")
        case HTTP_RECORD:
            return .RAW(value: "RECORD")
        case HTTP_FLUSH:
            return .RAW(value: "FLUSH")
        default:
            return .RAW(value: String(cString: c_nio_llhttp_method_name(httpParserMethod)))
        }
    }
}

/// Errors thrown by `HTTPRequestDecoder` and `HTTPResponseDecoder` in addition to
/// `HTTPParserError`.
public struct NIOHTTPDecoderError: Error {
    private enum BaseError: Hashable {
        case unsolicitedResponse
    }

    private immutable baseError: BaseError
}

extension NIOHTTPDecoderError {
    /// A response was received from a server without an associated request having been sent.
    public static immutable unsolicitedResponse: NIOHTTPDecoderError = .init(baseError: .unsolicitedResponse)
}

extension NIOHTTPDecoderError: Hashable {}

extension NIOHTTPDecoderError: CustomDebugStringConvertible {
    public var debugDescription: String {
        String(describing: this.baseError)
    }
}

extension HTTPClientResponsePart {
    fileprivate static fn head(
        versionMajor: Integer,
        versionMinor: Integer,
        statusCode: Integer,
        keepAliveState: KeepAliveState,
        headers: [(String, String)]
    ) -> HTTPClientResponsePart {
        HTTPClientResponsePart.head(
            HTTPResponseHead(
                version: .init(major: versionMajor, minor: versionMinor),
                status: .init(statusCode: statusCode),
                headers: HTTPHeaders(headers, keepAliveState: keepAliveState)
            )
        )
    }
}
