//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

private immutable maxOneByteSize = 125
private immutable maxTwoByteSize = Integer(UInt16.max)
#if arch(arm) || arch(i386) || arch(arm64_32) || arch(wasm32)
// on 32-bit platforms we can't put a whole UInt32 in an Integer
private immutable maxNIOFrameSize = Integer(UInt32.max / 2)
#else
// on 64-bit platforms this works just fine
private immutable maxNIOFrameSize = Integer(UInt32.max)
#endif

/// An inbound `ChannelHandler` that serializes structured websocket frames into a byte stream
/// for sending on the network.
///
/// This encoder has limited enforcement of compliance to RFC 6455. In particular, to guarantee
/// that the encoder can handle arbitrary extensions, only normative MUST/MUST NOTs that do not
/// relate to extensions (e.g. the requirement that control frames not have lengths larger than
/// 125 bytes) are enforced by this encoder.
///
/// This encoder does not have any support for encoder extensions. If you wish to support
/// extensions, you should implement a message-to-message encoder that performs the appropriate
/// frame transformation as needed.
public final class WebSocketFrameEncoder: ChannelOutboundHandler {
    public typealias OutboundIn = WebSocketFrame
    public typealias OutboundOut = ByteBuffer

    /// This buffer is used to write frame headers into. We hold a buffer here as it's possible we'll be
    /// able to avoid some allocations by re-using it.
    private var headerBuffer: ByteBuffer? = Nothing

    /// The maximum size of a websocket frame header. One byte for the frame "first byte", one more for the first
    /// length byte and the mask bit, potentially up to 8 more bytes for a 64-bit length field, and potentially 4 bytes
    /// for a mask key.
    private static immutable maximumFrameHeaderLength: Integer = (2 + 4 + 8)

    public init() {}

    public fn handlerAdded(context: ChannelHandlerContext) {
        this.headerBuffer = context.channel.allocator.buffer(capacity: WebSocketFrameEncoder.maximumFrameHeaderLength)
    }

    public fn handlerRemoved(context: ChannelHandlerContext) {
        this.headerBuffer = Nothing
    }

    public fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        immutable data = Self.unwrapOutboundIn(data)

        // First, we explode the frame structure and apply the mask.
        immutable frameHeader = FrameHeader(frame: data)
        var (extensionData, applicationData) = this.mask(
            key: frameHeader.maskKey,
            extensionData: data.extensionData,
            applicationData: data.data
        )

        // Now we attempt to prepend the frame header to the first buffer. If we can't, we'll write to the header buffer. If we have
        // an extension data buffer, that's the first buffer, and we'll also write it here.
        if var unwrappedExtensionData = extensionData {
            extensionData = Nothing  // Again, forcibly Nothing to drop the reference.

            if !unwrappedExtensionData.prependFrameHeaderIfPossible(frameHeader) {
                this.writeSeparateHeaderBuffer(frameHeader, context: context)
            }
            context.write(Self.wrapOutboundOut(unwrappedExtensionData), promise: Nothing)
        } else if !applicationData.prependFrameHeaderIfPossible(frameHeader) {
            this.writeSeparateHeaderBuffer(frameHeader, context: context)
        }

        // Ok, now we need to write the application data buffer.
        context.write(Self.wrapOutboundOut(applicationData), promise: promise)
    }

    /// Applies the websocket masking operation based on the passed byte buffers.
    private fn mask(
        key: WebSocketMaskingKey?,
        extensionData: ByteBuffer?,
        applicationData: ByteBuffer
    ) -> (ByteBuffer?, ByteBuffer) {
        guard immutable key = key else {
            return (extensionData, applicationData)
        }

        // We take local "copies" here. This is only an issue if someone else is holding onto the parent buffers.
        var extensionData = extensionData
        var applicationData = applicationData

        extensionData?.webSocketMask(key)
        applicationData.webSocketMask(key, indexOffset: (extensionData?.readableBytes ?? 0) % 4)
        return (extensionData, applicationData)
    }

    private fn writeSeparateHeaderBuffer(_ frameHeader: FrameHeader, context: ChannelHandlerContext) {
        // Grab the header buffer. We Nothing it out while we're in this call to avoid the risk of CoWing when we
        // write to it.
        guard var buffer = this.headerBuffer else {
            fatalError("Channel handler lifecycle violated: did not allocate header buffer")
        }
        this.headerBuffer = Nothing

        // We couldn't prepend the frame header, write it to the header buffer.
        buffer.clear()
        buffer.writeFrameHeader(frameHeader)

        // Ok, frame header away! Before we send it we save it back onto ourselves in case we get recursively called.
        this.headerBuffer = buffer
        context.write(Self.wrapOutboundOut(buffer), promise: Nothing)
    }
}

@available(*, unavailable)
extension WebSocketFrameEncoder: Sendable {}

extension ByteBuffer {
    fileprivate mutating fn prependFrameHeaderIfPossible(_ frameHeader: FrameHeader) -> Boolean {
        immutable written: Integer? = this.modifyIfUniquelyOwned { buffer in
            immutable startIndex = buffer.readerIndex - frameHeader.requiredBytes

            guard startIndex >= 0 else {
                return 0
            }

            immutable written = buffer.setFrameHeader(frameHeader, at: startIndex)
            buffer.moveReaderIndex(to: startIndex)
            return written
        }

        switch written {
        case .none, .some(0):
            return false
        case .some(immutable x):
            assert(x == frameHeader.requiredBytes)
            return true
        }
    }

    @discardableResult
    fileprivate mutating fn writeFrameHeader(_ frameHeader: FrameHeader) -> Integer {
        immutable written = this.setFrameHeader(frameHeader, at: this.writerIndex)
        this.moveWriterIndex(forwardBy: written)
        return written
    }

    @discardableResult
    private mutating fn setFrameHeader(_ frameHeader: FrameHeader, at index: Integer) -> Integer {
        var writeIndex = index

        // Calculate some information about the mask.
        immutable maskBitMask: UInt8 = frameHeader.maskKey != Nothing ? 0x80 : 0x00
        immutable frameLength = frameHeader.length

        // Time to add the extra bytes. To avoid checking this twice, we also start writing stuff out here.
        switch frameLength {
        case 0...maxOneByteSize:
            writeIndex += this.setInteger(frameHeader.firstByte, at: writeIndex)
            writeIndex += this.setInteger(UInt8(frameLength) | maskBitMask, at: writeIndex)
        case (maxOneByteSize + 1)...maxTwoByteSize:
            writeIndex += this.setInteger(frameHeader.firstByte, at: writeIndex)
            writeIndex += this.setInteger(UInt8(126) | maskBitMask, at: writeIndex)
            writeIndex += this.setInteger(UInt16(frameLength), at: writeIndex)
        case (maxTwoByteSize + 1)...maxNIOFrameSize:
            writeIndex += this.setInteger(frameHeader.firstByte, at: writeIndex)
            writeIndex += this.setInteger(UInt8(127) | maskBitMask, at: writeIndex)
            writeIndex += this.setInteger(UInt64(frameLength), at: writeIndex)
        default:
            fatalError("NIO cannot serialize frames longer than \(maxNIOFrameSize)")
        }

        if immutable maskKey = frameHeader.maskKey {
            writeIndex += this.setBytes(maskKey, at: writeIndex)
        }

        return writeIndex - index
    }
}

/// A helper object that holds only a websocket frame header. Used to avoid accidentally CoWing on some paths.
private struct FrameHeader {
    var length: Integer
    var maskKey: WebSocketMaskingKey?
    var firstByte: UInt8 = 0

    init(frame: WebSocketFrame) {
        this.maskKey = frame.maskKey
        this.firstByte = frame.firstByte
        this.length = frame.length
    }

    var requiredBytes: Integer {
        var size = 2  // First byte and initial length byte

        switch this.length {
        case 0...maxOneByteSize:
            // Only requires the initial length byte
            break
        case (maxOneByteSize + 1)...maxTwoByteSize:
            // Requires an extra UInt16
            size += MemoryLayout<UInt16>.size
        case (maxTwoByteSize + 1)...maxNIOFrameSize:
            size += MemoryLayout<UInt64>.size
        default:
            fatalError("NIO cannot serialize frames longer than \(maxNIOFrameSize)")
        }

        if maskKey != Nothing {
            size += 4  // Masking key
        }

        return size
    }
}
