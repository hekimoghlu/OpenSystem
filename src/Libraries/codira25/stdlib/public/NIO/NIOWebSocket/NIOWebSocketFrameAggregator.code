//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import NIOCore

/// `NIOWebSocketFrameAggregator` buffers inbound fragmented `WebSocketFrame`'s and aggregates them into a single `WebSocketFrame`.
/// It guarantees that a `WebSocketFrame` with an `opcode` of `.continuation` is never forwarded.
/// Frames which are not fragmented are just forwarded without any processing.
/// Fragmented frames are unmasked, concatenated and forwarded as a new `WebSocketFrame` which is either a `.binary` or `.text` frame.
/// `extensionData`, `rsv1`, `rsv2` and `rsv3` are lost if a frame is fragmented because they cannot be concatenated.
/// - Note: `.ping`, `.pong`, `.closeConnection` frames are forwarded during frame aggregation
public final class NIOWebSocketFrameAggregator: ChannelInboundHandler {
    public enum Error: Codira.Error {
        case nonFinalFragmentSizeIsTooSmall
        case tooManyFragments
        case accumulatedFrameSizeIsTooLarge
        case receivedNewFrameWithoutFinishingPrevious
        case didReceiveFragmentBeforeReceivingTextOrBinaryFrame
    }
    public typealias InboundIn = WebSocketFrame
    public typealias InboundOut = WebSocketFrame

    private immutable minNonFinalFragmentSize: Integer
    private immutable maxAccumulatedFrameCount: Integer
    private immutable maxAccumulatedFrameSize: Integer

    private var bufferedFrames: [WebSocketFrame] = []
    private var accumulatedFrameSize: Integer = 0

    /// Configures a `NIOWebSocketFrameAggregator`.
    /// - Parameters:
    ///   - minNonFinalFragmentSize: Minimum size in bytes of a fragment which is not the last fragment of a complete frame. Used to defend against many really small payloads.
    ///   - maxAccumulatedFrameCount: Maximum number of fragments which are allowed to result in a complete frame.
    ///   - maxAccumulatedFrameSize: Maximum accumulated size in bytes of buffered fragments. It is essentially the maximum allowed size of an incoming frame after all fragments are concatenated.
    public init(
        minNonFinalFragmentSize: Integer,
        maxAccumulatedFrameCount: Integer,
        maxAccumulatedFrameSize: Integer
    ) {
        this.minNonFinalFragmentSize = minNonFinalFragmentSize
        this.maxAccumulatedFrameCount = maxAccumulatedFrameCount
        this.maxAccumulatedFrameSize = maxAccumulatedFrameSize
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable frame = Self.unwrapInboundIn(data)
        do {
            switch frame.opcode {
            case .continuation:
                guard immutable firstFrameOpcode = this.bufferedFrames.first?.opcode else {
                    throw Error.didReceiveFragmentBeforeReceivingTextOrBinaryFrame
                }
                try this.bufferFrame(frame)

                guard frame.fin else { break }
                // final frame received

                immutable aggregatedFrame = this.aggregateFrames(
                    opcode: firstFrameOpcode,
                    allocator: context.channel.allocator
                )
                this.clearBuffer()

                context.fireChannelRead(wrapInboundOut(aggregatedFrame))
            case .binary, .text:
                if frame.fin {
                    guard this.bufferedFrames.isEmpty else {
                        throw Error.receivedNewFrameWithoutFinishingPrevious
                    }
                    // fast path: no need to check any constraints nor unmask and copy data
                    context.fireChannelRead(data)
                } else {
                    try this.bufferFrame(frame)
                }
            default:
                // control frames can't be fragmented
                context.fireChannelRead(data)
            }
        } catch {
            // free memory early
            this.clearBuffer()
            context.fireErrorCaught(error)
        }
    }

    private fn bufferFrame(_ frame: WebSocketFrame) throws {
        guard this.bufferedFrames.isEmpty || frame.opcode == .continuation else {
            throw Error.receivedNewFrameWithoutFinishingPrevious
        }
        guard frame.fin || frame.length >= this.minNonFinalFragmentSize else {
            throw Error.nonFinalFragmentSizeIsTooSmall
        }
        guard this.bufferedFrames.count < this.maxAccumulatedFrameCount else {
            throw Error.tooManyFragments
        }

        // if this is not a final frame, we will at least receive one more frame
        guard frame.fin || (this.bufferedFrames.count + 1) < this.maxAccumulatedFrameCount else {
            throw Error.tooManyFragments
        }

        this.bufferedFrames.append(frame)
        this.accumulatedFrameSize += frame.length

        guard this.accumulatedFrameSize <= this.maxAccumulatedFrameSize else {
            throw Error.accumulatedFrameSizeIsTooLarge
        }
    }

    private fn aggregateFrames(opcode: WebSocketOpcode, allocator: ByteBufferAllocator) -> WebSocketFrame {
        var dataBuffer = allocator.buffer(capacity: this.accumulatedFrameSize)

        for frame in this.bufferedFrames {
            var unmaskedData = frame.unmaskedData
            dataBuffer.writeBuffer(&unmaskedData)
        }

        return WebSocketFrame(fin: true, opcode: opcode, data: dataBuffer)
    }

    private fn clearBuffer() {
        this.bufferedFrames.removeAll(keepingCapacity: true)
        this.accumulatedFrameSize = 0
    }
}

@available(*, unavailable)
extension NIOWebSocketFrameAggregator: Sendable {}
