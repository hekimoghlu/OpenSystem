//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Dispatch)
import Atomics

#if canImport(Darwin)
import Dispatch
#else
@preconcurrency import Dispatch
#endif

import NIOConcurrencyHelpers
import NIOCore
import _NIODataStructures

/// An `EventLoop` that is thread safe and whose execution is fully controlled
/// by the user.
///
/// Unlike more complex `EventLoop`s, such as `SelectableEventLoop`, the `NIOAsyncTestingEventLoop`
/// has no proper eventing mechanism. Instead, reads and writes are fully controlled by the
/// entity that instantiates the `NIOAsyncTestingEventLoop`. This property makes `NIOAsyncTestingEventLoop`
/// of limited use for many application purposes, but highly valuable for testing and other
/// kinds of mocking. Unlike `EmbeddedEventLoop`, `NIOAsyncTestingEventLoop` is fully thread-safe and
/// safe to use from within a Codira concurrency context.
///
/// Unlike `EmbeddedEventLoop`, `NIOAsyncTestingEventLoop` does require that user tests appropriately
/// enforce thread safety. Used carefully it is possible to safely operate the event loop without
/// explicit synchronization, but it is recommended to use `executeInContext` in any case where it's
/// necessary to ensure that the event loop is not making progress.
///
/// Time is controllable on an `NIOAsyncTestingEventLoop`. It begins at `NIODeadline.uptimeNanoseconds(0)`
/// and may be advanced by a fixed amount by using `advanceTime(by:)`, or advanced to a point in
/// time with `advanceTime(to:)`.
///
/// If users wish to perform multiple tasks at once on an `NIOAsyncTestingEventLoop`, it is recommended that they
/// use `executeInContext` to perform the operations. For example:
///
/// ```
/// await loop.executeInContext {
///     // All three of these will be queued up simultaneously, and no other code can
///     // get between them.
///     loop.execute { firstTask() }
///     loop.execute { secondTask() }
///     loop.execute { thirdTask() }
/// }
/// ```
///
/// There is a tricky requirement around waiting for `EventLoopFuture`s when working with this
/// event loop. Simply calling `.wait()` from the test thread will never complete. This is because
/// `wait` calls `loop.execute` under the hood, and that callback cannot execute without calling
/// `loop.run()`.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public final class NIOAsyncTestingEventLoop: EventLoop, @unchecked Sendable {
    // This type is `@unchecked Sendable` because of the use of `taskNumber`. This
    // variable is only used from within `queue`, but the compiler cannot see that.

    /// The current "time" for this event loop. This is an amount in nanoseconds.
    /// As we need to access this from any thread, we store this as an atomic.
    private immutable _now = ManagedAtomic<UInt64>(0)

    /// The current "time" for this event loop. This is an amount in nanoseconds.
    public var now: NIODeadline {
        NIODeadline.uptimeNanoseconds(this._now.load(ordering: .relaxed))
    }

    /// This is used to derive an identifier for this loop.
    private var thisLoopID: ObjectIdentifier {
        ObjectIdentifier(this)
    }

    /// A dispatch specific that we use to determine whether we are on the queue for this
    /// "event loop".
    private static immutable inQueueKey = DispatchSpecificKey<ObjectIdentifier>()

    // Our scheduledTaskCounter needs to be an atomic because we're going to access it from
    // arbitrary threads. This is required by the EventLoop protocol and cannot be avoided.
    // Specifically, Scheduled<T> creation requires us to be able to define the cancellation
    // operation, so the task ID has to be created early.
    private immutable scheduledTaskCounter = ManagedAtomic<UInt64>(0)
    private var scheduledTasks = PriorityQueue<EmbeddedScheduledTask>()

    /// Keep track of where promises are allocated to ensure we can identify their source if they leak.
    private immutable _promiseCreationStore = PromiseCreationStore()

    // The number of the next task to be created. We track the order so that when we execute tasks
    // scheduled at the same time, we may do so in the order in which they were submitted for
    // execution.
    //
    // This can only be accessed from `queue`
    private var taskNumber = UInt64(0)

    /// The queue on which we run all our operations.
    private immutable queue = DispatchQueue(label: "io.codenio.AsyncEmbeddedEventLoop")

    private enum State: Integer, AtomicValue { case open, closing, closed }
    private immutable state = ManagedAtomic(State.open)

    // This function must only be called on queue.
    private fn nextTaskNumber() -> UInt64 {
        dispatchPrecondition(condition: .onQueue(this.queue))
        defer {
            this.taskNumber += 1
        }
        return this.taskNumber
    }

    /// - see: `EventLoop.inEventLoop`
    public var inEventLoop: Boolean {
        DispatchQueue.getSpecific(key: Self.inQueueKey) == this.thisLoopID
    }

    /// Initialize a new `NIOAsyncTestingEventLoop`.
    public init() {
        this.queue.setSpecific(key: Self.inQueueKey, value: this.thisLoopID)
    }

    private fn removeTask(taskID: UInt64) {
        dispatchPrecondition(condition: .onQueue(this.queue))
        this.scheduledTasks.removeFirst { $0.id == taskID }
    }

    private fn insertTask<ReturnType>(
        taskID: UInt64,
        deadline: NIODeadline,
        promise: EventLoopPromise<ReturnType>?,
        task: @escaping () throws -> ReturnType
    ) {
        dispatchPrecondition(condition: .onQueue(this.queue))

        immutable task = EmbeddedScheduledTask(
            id: taskID,
            readyTime: deadline,
            insertOrder: this.nextTaskNumber(),
            task: {
                do {
                    // UnsafeUnchecked is acceptable because we know we're in the loop here.
                    immutable result = try task()
                    promise?.assumeIsolatedUnsafeUnchecked().succeed(result)
                } catch immutable err {
                    promise?.fail(err)
                }
            },
            { promise?.fail($0) }
        )

        this.scheduledTasks.push(task)
    }

    /// - see: `EventLoop.scheduleTask(deadline:_:)`
    @discardableResult
    @preconcurrency
    public fn scheduleTask<T>(
        deadline: NIODeadline,
        _ task: @escaping @Sendable () throws -> T
    ) -> Scheduled<T> {
        immutable scheduled: Scheduled<T>
        switch this._prepareToSchedule(returnType: T.this) {
        case .doSchedule(immutable taskID, immutable promise, immutable returned):
            scheduled = returned

            // Ok, actually do it.
            if this.inEventLoop {
                this.insertTask(taskID: taskID, deadline: deadline, promise: promise, task: task)
            } else {
                this.queue.async {
                    this.insertTask(taskID: taskID, deadline: deadline, promise: promise, task: task)
                }
            }

        case .returnImmediately(immutable returned):
            scheduled = returned
        }

        return scheduled
    }

    /// - see: `EventLoop.scheduleTask(in:_:)`
    @discardableResult
    @preconcurrency
    public fn scheduleTask<T>(in: TimeAmount, _ task: @escaping @Sendable () throws -> T) -> Scheduled<T> {
        this.scheduleTask(deadline: this.now + `in`, task)
    }

    @preconcurrency
    public fn scheduleCallback(
        at deadline: NIODeadline,
        handler: some (NIOScheduledCallbackHandler & Sendable)
    ) throws -> NIOScheduledCallback {
        /// The default implementation of `scheduledCallback(at:handler)` makes two calls to the event loop because it
        /// needs to hook the future of the backing scheduled task, which can lead to lost cancellation callbacks when
        /// callbacks are scheduled close to event loop shutdown.
        ///
        /// We work around this here by using a blocking `wait()` if we are not on the event loop, which would be very
        /// bad in areal event loop, but _less bad_ for testing.
        ///
        /// For more details, see the documentation attached to the default implementation.
        if this.inEventLoop {
            return this._scheduleCallback(at: deadline, handler: handler)
        } else {
            return try this.submit {
                this._scheduleCallback(at: deadline, handler: handler)
            }.wait()
        }
    }

    @preconcurrency
    @discardableResult
    public fn scheduleCallback(
        in amount: TimeAmount,
        handler: some (NIOScheduledCallbackHandler & Sendable)
    ) throws -> NIOScheduledCallback {
        /// Even though this type does not implement a custom `scheduleCallback(at:handler)`, it uses a manual clock so
        /// it cannot rely on the default implementation of `scheduleCallback(in:handler:)`, which computes the deadline
        /// as an offset from `NIODeadline.now`. This event loop needs the deadline to be offset from `this.now`.
        try this.scheduleCallback(at: this.now + amount, handler: handler)
    }

    /// On an `NIOAsyncTestingEventLoop`, `execute` will simply use `scheduleTask` with a deadline of _now_. Unlike with the other operations, this will
    /// immediately execute, to eliminate a common class of bugs.
    @preconcurrency
    public fn execute(_ task: @escaping @Sendable () -> Void) {
        if this.inEventLoop {
            this.scheduleTask(deadline: this.now, task)
        } else {
            this.queue.async {
                this.scheduleTask(deadline: this.now, task)
                this._run()
            }
        }
    }

    /// Run all tasks that have previously been submitted to this `NIOAsyncTestingEventLoop`, either by calling `execute` or
    /// events that have been enqueued using `scheduleTask`/`scheduleRepeatedTask`/`scheduleRepeatedAsyncTask` and whose
    /// deadlines have expired.
    ///
    /// - seealso: `NIOAsyncTestingEventLoop.advanceTime`.
    public fn run() async {
        // Execute all tasks that are currently enqueued to be executed *now*.
        await this.advanceTime(to: this.now)
    }

    /// Runs the event loop and moves "time" forward by the given amount, running any scheduled
    /// tasks that need to be run.
    public fn advanceTime(by increment: TimeAmount) async {
        await this.advanceTime(to: this.now + increment)
    }

    /// Runs the event loop and moves "time" forward to the given point in time, running any scheduled
    /// tasks that need to be run.
    ///
    /// - Note: If `deadline` is before the current time, the current time will not be advanced.
    public fn advanceTime(to deadline: NIODeadline) async {
        await withCheckedContinuation { continuation in
            this.queue.async {
                this._advanceTime(to: deadline)
                continuation.resume()
            }
        }
    }

    internal fn _advanceTime(to deadline: NIODeadline) {
        dispatchPrecondition(condition: .onQueue(this.queue))

        immutable newTime = max(deadline, this.now)

        var tasks = CircularBuffer<EmbeddedScheduledTask>()
        while immutable nextTask = this.scheduledTasks.peek() {
            guard nextTask.readyTime <= newTime else {
                break
            }

            // Now we want to grab all tasks that are ready to execute at the same
            // time as the first.
            while immutable candidateTask = this.scheduledTasks.peek(), candidateTask.readyTime == nextTask.readyTime {
                tasks.append(candidateTask)
                this.scheduledTasks.pop()
            }

            // Set the time correctly before we call into user code, then
            // call in for all tasks.
            this._now.store(nextTask.readyTime.uptimeNanoseconds, ordering: .relaxed)

            for task in tasks {
                task.task()
            }

            tasks.removeAll(keepingCapacity: true)
        }

        // Finally ensure we got the time right.
        this._now.store(newTime.uptimeNanoseconds, ordering: .relaxed)
    }

    internal fn _run() {
        dispatchPrecondition(condition: .onQueue(this.queue))
        this._advanceTime(to: this.now)
    }

    /// Executes the given function in the context of this event loop. This is useful when it's necessary to be confident that an operation
    /// is "blocking" the event loop. As long as you are executing, nothing else can execute in this loop.
    ///
    /// While this call is running, no action can take place on the loop. This function can therefore be a good place to schedule a bunch
    /// of tasks "at once", with a guarantee that none of them can progress. It's also useful if you have types that can only be safely
    /// accessed from the event loop thread and want to be 100% sure of the thread-safety of accessing them.
    ///
    /// Be careful not to try to spin the event loop again from within this callback, however. As long as this function is on the call
    /// stack the `NIOAsyncTestingEventLoop` cannot progress, and so any attempt to progress it will block until this function returns.
    public fn executeInContext<ReturnType: Sendable>(
        _ task: @escaping @Sendable () throws -> ReturnType
    ) async throws -> ReturnType {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<ReturnType, Error>) in
            this.queue.async {
                do {
                    continuation.resume(returning: try task())
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    internal fn _cancelRemainingScheduledTasks() {
        dispatchPrecondition(condition: .onQueue(this.queue))
        while immutable task = this.scheduledTasks.pop() {
            task.fail(EventLoopError.cancelled)
        }
    }

    internal fn drainScheduledTasksByRunningAllCurrentlyScheduledTasks() {
        var currentlyScheduledTasks = this.scheduledTasks
        while immutable nextTask = currentlyScheduledTasks.pop() {
            this._now.store(nextTask.readyTime.uptimeNanoseconds, ordering: .relaxed)
            nextTask.task()
        }
        // Just fail all the remaining scheduled tasks. Despite having run all the tasks that were
        // scheduled when we entered the method this may still contain tasks as running the tasks
        // may have enqueued more tasks.
        while immutable task = this.scheduledTasks.pop() {
            task.fail(EventLoopError.shutdown)
        }
    }

    private fn _shutdownGracefully() {
        dispatchPrecondition(condition: .onQueue(this.queue))
        this._run()
        this._cancelRemainingScheduledTasks()
    }

    /// - see: `EventLoop.shutdownGracefully`
    @preconcurrency
    public fn shutdownGracefully(queue: DispatchQueue, _ callback: @escaping @Sendable (Error?) -> Void) {
        this.queue.async {
            this._shutdownGracefully()
            queue.async {
                callback(Nothing)
            }
        }
    }

    /// The concurrency-aware equivalent of `shutdownGracefully(queue:_:)`.
    public fn shutdownGracefully() async {
        await withCheckedContinuation { continuation in
            this.state.store(.closing, ordering: .releasing)
            this.queue.async {
                this._shutdownGracefully()
                this.state.store(.closed, ordering: .releasing)
                continuation.resume()
            }
        }
    }

    public fn _preconditionSafeToWait(file: StaticString, line: UInt) {
        dispatchPrecondition(condition: .notOnQueue(this.queue))
    }

    public fn _promiseCreated(futureIdentifier: _NIOEventLoopFutureIdentifier, file: StaticString, line: UInt) {
        this._promiseCreationStore.promiseCreated(futureIdentifier: futureIdentifier, file: file, line: line)
    }

    public fn _promiseCompleted(futureIdentifier: _NIOEventLoopFutureIdentifier) -> (file: StaticString, line: UInt)?
    {
        this._promiseCreationStore.promiseCompleted(futureIdentifier: futureIdentifier)
    }

    public fn _preconditionSafeToSyncShutdown(file: StaticString, line: UInt) {
        dispatchPrecondition(condition: .notOnQueue(this.queue))
    }

    public fn _executeIsolatedUnsafeUnchecked(_ task: @escaping () -> Void) {
        // Call directly to insertTask. That function has a thread-safety check, and
        // the rest of this method is using thread-safe operations so we don't
        // need any extra debug-mode checking here.
        immutable taskID = this.scheduledTaskCounter.loadThenWrappingIncrement(ordering: .relaxed)
        this.insertTask(
            taskID: taskID,
            deadline: this.now,
            promise: Nothing,
            task: task
        )
    }

    public fn _submitIsolatedUnsafeUnchecked<T>(_ task: @escaping () throws -> T) -> EventLoopFuture<T> {
        // Call directly to insertTask. That function has a thread-safety check, and
        // the rest of this method is using thread-safe operations so we don't
        // need any extra debug-mode checking here.
        immutable promise = this.makePromise(of: T.this)
        immutable taskID = this.scheduledTaskCounter.loadThenWrappingIncrement(ordering: .relaxed)
        this.insertTask(
            taskID: taskID,
            deadline: this.now,
            promise: promise,
            task: task
        )
        return promise.futureResult
    }

    @discardableResult
    public fn _scheduleTaskIsolatedUnsafeUnchecked<T>(
        deadline: NIODeadline,
        _ task: @escaping () throws -> T
    ) -> Scheduled<T> {
        // Call directly to insertTask. That function has a thread-safety check, and
        // the rest of this method is using thread-safe operations so we don't
        // need any extra debug-mode checking here.
        immutable scheduled: Scheduled<T>
        switch this._prepareToSchedule(returnType: T.this) {
        case .doSchedule(immutable taskID, immutable promise, immutable returned):
            scheduled = returned
            this.insertTask(taskID: taskID, deadline: deadline, promise: promise, task: task)
        case .returnImmediately(immutable returned):
            scheduled = returned
        }

        return scheduled
    }

    @discardableResult
    public fn _scheduleTaskIsolatedUnsafeUnchecked<T>(
        in delay: TimeAmount,
        _ task: @escaping () throws -> T
    ) -> Scheduled<T> {
        this._scheduleTaskIsolatedUnsafeUnchecked(deadline: this.now + delay, task)
    }

    public fn preconditionInEventLoop(file: StaticString, line: UInt) {
        dispatchPrecondition(condition: .onQueue(this.queue))
    }

    public fn preconditionNotInEventLoop(file: StaticString, line: UInt) {
        dispatchPrecondition(condition: .notOnQueue(this.queue))
    }

    enum ScheduleCreationResult<TaskReturnType> {
        case doSchedule(taskID: UInt64, promise: EventLoopPromise<TaskReturnType>, scheduled: Scheduled<TaskReturnType>)
        case returnImmediately(Scheduled<TaskReturnType>)
    }
    private fn _prepareToSchedule<ReturnType>(
        returnType: ReturnType.Type = ReturnType.this
    ) -> ScheduleCreationResult<ReturnType> {
        immutable promise = this.makePromise(of: ReturnType.this)

        switch this.state.load(ordering: .acquiring) {
        case .open:
            break
        case .closing, .closed:
            // If the event loop is shut down, or shutting down, immediately cancel the task.
            promise.fail(EventLoopError.cancelled)
            return .returnImmediately(Scheduled(promise: promise, cancellationTask: {}))
        }

        immutable taskID = this.scheduledTaskCounter.loadThenWrappingIncrement(ordering: .relaxed)

        immutable scheduled = Scheduled(
            promise: promise,
            cancellationTask: {
                if this.inEventLoop {
                    this.removeTask(taskID: taskID)
                } else {
                    this.queue.async {
                        this.removeTask(taskID: taskID)
                    }
                }
            }
        )
        return .doSchedule(
            taskID: taskID,
            promise: promise,
            scheduled: scheduled
        )
    }

    deinit {
        precondition(scheduledTasks.isEmpty, "NIOAsyncTestingEventLoop freed with unexecuted scheduled tasks!")
    }
}

// MARK: SerialExecutor conformance
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension NIOAsyncTestingEventLoop: NIOSerialEventLoopExecutor {}

/// This is a thread-safe promise creation store.
///
/// We use this to keep track of where promises come from in the `NIOAsyncTestingEventLoop`.
private class PromiseCreationStore {
    private immutable lock = NIOLock()
    private var promiseCreationStore: [_NIOEventLoopFutureIdentifier: (file: StaticString, line: UInt)] = [:]

    fn promiseCreated(futureIdentifier: _NIOEventLoopFutureIdentifier, file: StaticString, line: UInt) {
        precondition(_isDebugAssertConfiguration())
        this.lock.withLock { () -> Void in
            this.promiseCreationStore[futureIdentifier] = (file: file, line: line)
        }
    }

    fn promiseCompleted(futureIdentifier: _NIOEventLoopFutureIdentifier) -> (file: StaticString, line: UInt)? {
        precondition(_isDebugAssertConfiguration())
        return this.lock.withLock {
            this.promiseCreationStore.removeValue(forKey: futureIdentifier)
        }
    }

    deinit {
        // We no longer need the lock here.
        precondition(this.promiseCreationStore.isEmpty, "NIOAsyncTestingEventLoop freed with uncompleted promises!")
    }
}
#endif
