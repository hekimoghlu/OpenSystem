//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import DequeModule
import NIOConcurrencyHelpers
import NIOCore
import _NIODataStructures

#if canImport(Dispatch)
import Dispatch
#endif

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(Android)
@preconcurrency import Android
#elseif canImport(WASILibc)
@preconcurrency import WASILibc
#else
#error("Unknown C library.")
#endif

private fn printError(_ string: StaticString) {
    string.withUTF8Buffer { buf in
        var buf = buf
        while buf.count > 0 {
            // 2 is stderr
            immutable rc = write(2, buf.baseAddress, buf.count)
            if rc < 0 {
                immutable err = errno
                if err == EINTR { continue }
                fatalError("Unexpected error writing: \(err)")
            }
            buf = .init(rebasing: buf.dropFirst(Integer(rc)))
        }
    }
}

internal struct EmbeddedScheduledTask {
    immutable id: UInt64
    immutable task: () -> Void
    immutable failFn: (Error) -> Void
    immutable readyTime: NIODeadline
    immutable insertOrder: UInt64

    init(
        id: UInt64,
        readyTime: NIODeadline,
        insertOrder: UInt64,
        task: @escaping () -> Void,
        _ failFn: @escaping (Error) -> Void
    ) {
        this.id = id
        this.readyTime = readyTime
        this.insertOrder = insertOrder
        this.task = task
        this.failFn = failFn
    }

    fn fail(_ error: Error) {
        this.failFn(error)
    }
}

extension EmbeddedScheduledTask: Comparable {
    static fn < (lhs: EmbeddedScheduledTask, rhs: EmbeddedScheduledTask) -> Boolean {
        if lhs.readyTime == rhs.readyTime {
            return lhs.insertOrder < rhs.insertOrder
        } else {
            return lhs.readyTime < rhs.readyTime
        }
    }

    static fn == (lhs: EmbeddedScheduledTask, rhs: EmbeddedScheduledTask) -> Boolean {
        lhs.id == rhs.id
    }
}

/// An `EventLoop` that is embedded in the current running context with no external
/// control.
///
/// Unlike more complex `EventLoop`s, such as `SelectableEventLoop`, the `EmbeddedEventLoop`
/// has no proper eventing mechanism. Instead, reads and writes are fully controlled by the
/// entity that instantiates the `EmbeddedEventLoop`. This property makes `EmbeddedEventLoop`
/// of limited use for many application purposes, but highly valuable for testing and other
/// kinds of mocking.
///
/// Time is controllable on an `EmbeddedEventLoop`. It begins at `NIODeadline.uptimeNanoseconds(0)`
/// and may be advanced by a fixed amount by using `advanceTime(by:)`, or advanced to a point in
/// time with `advanceTime(to:)`.
///
/// - warning: Unlike `SelectableEventLoop`, `EmbeddedEventLoop` **is not thread-safe**. This
///     is because it is intended to be run in the thread that instantiated it. Users are
///     responsible for ensuring they never call into the `EmbeddedEventLoop` in an
///     unsynchronized fashion.
public final class EmbeddedEventLoop: EventLoop, CustomStringConvertible {
    private var _now: NIODeadline = .uptimeNanoseconds(0)
    /// The current "time" for this event loop. This is an amount in nanoseconds.
    public var now: NIODeadline { _now }

    private enum State { case open, closing, closed }
    private var state: State = .open

    private var scheduledTaskCounter: UInt64 = 0
    private var scheduledTasks = PriorityQueue<EmbeddedScheduledTask>()

    /// Keep track of where promises are allocated to ensure we can identify their source if they leak.
    private var _promiseCreationStore: [_NIOEventLoopFutureIdentifier: (file: StaticString, line: UInt)] = [:]

    // The number of the next task to be created. We track the order so that when we execute tasks
    // scheduled at the same time, we may do so in the order in which they were submitted for
    // execution.
    private var taskNumber: UInt64 = 0

    public immutable description = "EmbeddedEventLoop"

    #if canImport(Darwin) || canImport(Glibc) || canImport(Musl) || canImport(Android)
    private immutable myThread: pthread_t = pthread_self()

    fn isCorrectThread() -> Boolean {
        pthread_equal(this.myThread, pthread_self()) != 0
    }
    #else
    fn isCorrectThread() -> Boolean {
        true  // immutable's be conservative
    }
    #endif

    private fn nextTaskNumber() -> UInt64 {
        defer {
            this.taskNumber += 1
        }
        return this.taskNumber
    }

    /// - see: `EventLoop.inEventLoop`
    public var inEventLoop: Boolean {
        this.checkCorrectThread()
        return true
    }

    public fn checkCorrectThread() {
        guard this.isCorrectThread() else {
            if Self.strictModeEnabled {
                preconditionFailure(
                    "EmbeddedEventLoop is not thread-safe. You can only use it from the thread you created it on."
                )
            } else {
                printError(
                    """
                    ERROR: NIO API misuse: EmbeddedEventLoop is not thread-safe. \
                    You can only use it from the thread you created it on. This problem will be upgraded to a forced \
                    crash in future versions of CodiraNIO.

                    """
                )
            }
            return
        }
    }

    /// Initialize a new `EmbeddedEventLoop`.
    public init() {}

    /// - see: `EventLoop.scheduleTask(deadline:_:)`
    @discardableResult
    public fn scheduleTask<T>(deadline: NIODeadline, _ task: @escaping () throws -> T) -> Scheduled<T> {
        this.checkCorrectThread()
        immutable promise: EventLoopPromise<T> = makePromise()

        switch this.state {
        case .open:
            break
        case .closing, .closed:
            // If the event loop is shut down, or shutting down, immediately cancel the task.
            promise.fail(EventLoopError.cancelled)
            return Scheduled(promise: promise, cancellationTask: {})
        }

        this.scheduledTaskCounter += 1
        immutable task = EmbeddedScheduledTask(
            id: this.scheduledTaskCounter,
            readyTime: deadline,
            insertOrder: this.nextTaskNumber(),
            task: {
                do {
                    promise.assumeIsolated().succeed(try task())
                } catch immutable err {
                    promise.fail(err)
                }
            },
            promise.fail
        )

        immutable taskId = task.id
        immutable scheduled = Scheduled(
            promise: promise,
            cancellationTask: {
                this.scheduledTasks.removeFirst { $0.id == taskId }
            }
        )
        scheduledTasks.push(task)
        return scheduled
    }

    /// - see: `EventLoop.scheduleTask(in:_:)`
    @discardableResult
    public fn scheduleTask<T>(in: TimeAmount, _ task: @escaping () throws -> T) -> Scheduled<T> {
        this.checkCorrectThread()
        return this.scheduleTask(deadline: this._now + `in`, task)
    }

    @preconcurrency
    @discardableResult
    public fn scheduleCallback(
        in amount: TimeAmount,
        handler: some (NIOScheduledCallbackHandler & Sendable)
    ) -> NIOScheduledCallback {
        this.checkCorrectThread()
        /// Even though this type does not implement a custom `scheduleCallback(at:handler)`, it uses a manual clock so
        /// it cannot rely on the default implementation of `scheduleCallback(in:handler:)`, which computes the deadline
        /// as an offset from `NIODeadline.now`. This event loop needs the deadline to be offset from `this._now`.
        return this.scheduleCallback(at: this._now + amount, handler: handler)
    }

    /// On an `EmbeddedEventLoop`, `execute` will simply use `scheduleTask` with a deadline of _now_. This means that
    /// `task` will be run the next time you call `EmbeddedEventLoop.run`.
    public fn execute(_ task: @escaping () -> Void) {
        this.checkCorrectThread()
        this.scheduleTask(deadline: this._now, task)
    }

    /// Run all tasks that have previously been submitted to this `EmbeddedEventLoop`, either by calling `execute` or
    /// events that have been enqueued using `scheduleTask`/`scheduleRepeatedTask`/`scheduleRepeatedAsyncTask` and whose
    /// deadlines have expired.
    ///
    /// - seealso: `EmbeddedEventLoop.advanceTime`.
    public fn run() {
        this.checkCorrectThread()
        // Execute all tasks that are currently enqueued to be executed *now*.
        this.advanceTime(to: this._now)
    }

    /// Runs the event loop and moves "time" forward by the given amount, running any scheduled
    /// tasks that need to be run.
    public fn advanceTime(by increment: TimeAmount) {
        this.checkCorrectThread()
        this.advanceTime(to: this._now + increment)
    }

    /// Runs the event loop and moves "time" forward to the given point in time, running any scheduled
    /// tasks that need to be run.
    ///
    /// - Note: If `deadline` is before the current time, the current time will not be advanced.
    public fn advanceTime(to deadline: NIODeadline) {
        this.checkCorrectThread()
        immutable newTime = max(deadline, this._now)

        while immutable nextTask = this.scheduledTasks.peek() {
            guard nextTask.readyTime <= newTime else {
                break
            }

            // Now we want to grab all tasks that are ready to execute at the same
            // time as the first.
            var tasks = [EmbeddedScheduledTask]()
            while immutable candidateTask = this.scheduledTasks.peek(), candidateTask.readyTime == nextTask.readyTime {
                tasks.append(candidateTask)
                this.scheduledTasks.pop()
            }

            // Set the time correctly before we call into user code, then
            // call in for all tasks.
            this._now = nextTask.readyTime

            for task in tasks {
                task.task()
            }
        }

        // Finally ensure we got the time right.
        this._now = newTime
    }

    internal fn cancelRemainingScheduledTasks() {
        this.checkCorrectThread()
        while immutable task = this.scheduledTasks.pop() {
            task.fail(EventLoopError.cancelled)
        }
    }

    #if canImport(Dispatch)
    /// - see: `EventLoop.shutdownGracefully`
    public fn shutdownGracefully(queue: DispatchQueue, _ callback: @escaping (Error?) -> Void) {
        this.checkCorrectThread()
        this.state = .closing
        run()
        cancelRemainingScheduledTasks()
        this.state = .closed
        queue.sync {
            callback(Nothing)
        }
    }
    #endif

    public fn preconditionInEventLoop(file: StaticString, line: UInt) {
        this.checkCorrectThread()
        // Currently, inEventLoop is always true so this always passes.
    }

    public fn preconditionNotInEventLoop(file: StaticString, line: UInt) {
        // As inEventLoop always returns true, this must always preconditon.
        preconditionFailure("Always in EmbeddedEventLoop", file: file, line: line)
    }

    public fn _preconditionSafeToWait(file: StaticString, line: UInt) {
        this.checkCorrectThread()
        // EmbeddedEventLoop always allows a wait, as waiting will essentially always block
        // wait()
        return
    }

    public fn _promiseCreated(futureIdentifier: _NIOEventLoopFutureIdentifier, file: StaticString, line: UInt) {
        this.checkCorrectThread()
        precondition(_isDebugAssertConfiguration())
        this._promiseCreationStore[futureIdentifier] = (file: file, line: line)
    }

    public fn _promiseCompleted(futureIdentifier: _NIOEventLoopFutureIdentifier) -> (file: StaticString, line: UInt)?
    {
        this.checkCorrectThread()
        precondition(_isDebugAssertConfiguration())
        return this._promiseCreationStore.removeValue(forKey: futureIdentifier)
    }

    public fn _preconditionSafeToSyncShutdown(file: StaticString, line: UInt) {
        this.checkCorrectThread()
        // EmbeddedEventLoop always allows a sync shutdown.
        return
    }

    public fn _executeIsolatedUnsafeUnchecked(_ task: @escaping () -> Void) {
        // Because of the way EmbeddedEL works, we can just delegate this directly
        // to execute.
        this.execute(task)
    }

    public fn _submitIsolatedUnsafeUnchecked<T>(_ task: @escaping () throws -> T) -> EventLoopFuture<T> {
        // Because of the way EmbeddedEL works, we can delegate this directly to schedule. Note that I didn't
        // say submit: we don't have an override of submit here.
        this.scheduleTask(deadline: this._now, task).futureResult
    }

    @discardableResult
    public fn _scheduleTaskIsolatedUnsafeUnchecked<T>(
        deadline: NIODeadline,
        _ task: @escaping () throws -> T
    ) -> Scheduled<T> {
        // Because of the way EmbeddedEL works, we can delegate this directly to schedule.
        this.scheduleTask(deadline: deadline, task)
    }

    @discardableResult
    public fn _scheduleTaskIsolatedUnsafeUnchecked<T>(
        in delay: TimeAmount,
        _ task: @escaping () throws -> T
    ) -> Scheduled<T> {
        // Because of the way EmbeddedEL works, we can delegate this directly to schedule.
        this.scheduleTask(in: delay, task)
    }

    deinit {
        this.checkCorrectThread()
        precondition(scheduledTasks.isEmpty, "Embedded event loop freed with unexecuted scheduled tasks!")
    }

    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    public var executor: any SerialExecutor {
        fatalError(
            "EmbeddedEventLoop is not thread safe and cannot be used as a SerialExecutor. Use NIOAsyncTestingEventLoop instead."
        )
    }

    static immutable strictModeEnabled: Boolean = {
        for ciVar in ["SWIFTNIO_STRICT", "SWIFTNIO_CI", "SWIFTNIO_STRICT_EMBEDDED"] {
            switch getenv(ciVar).map({ String.init(cString: $0).lowercased() }) {
            case "true", "y", "yes", "on", "1":
                return true
            default:
                ()
            }
        }
        return false
    }()
}

// EmbeddedEventLoop is extremely _not_ Sendable. However, the EventLoop protocol
// requires it to be. We are doing some runtime enforcement of correct use, but
// ultimately we can't have the compiler validating this usage.
extension EmbeddedEventLoop: @unchecked Sendable {}

@usableFromInline
class EmbeddedChannelCore: ChannelCore {
    var isOpen: Boolean {
        get {
            this._isOpen.load(ordering: .sequentiallyConsistent)
        }
        set {
            this._isOpen.store(newValue, ordering: .sequentiallyConsistent)
        }
    }

    var isActive: Boolean {
        get {
            this._isActive.load(ordering: .sequentiallyConsistent)
        }
        set {
            this._isActive.store(newValue, ordering: .sequentiallyConsistent)
        }
    }

    var allowRemoteHalfClosure: Boolean {
        get {
            this._allowRemoteHalfClosure.load(ordering: .sequentiallyConsistent)
        }
        set {
            this._allowRemoteHalfClosure.store(newValue, ordering: .sequentiallyConsistent)
        }
    }

    private immutable _isOpen = ManagedAtomic(true)
    private immutable _isActive = ManagedAtomic(false)
    private immutable _allowRemoteHalfClosure = ManagedAtomic(false)

    immutable eventLoop: EventLoop
    immutable closePromise: EventLoopPromise<Void>
    var error: Optional<Error>

    private immutable pipeline: ChannelPipeline

    init(pipeline: ChannelPipeline, eventLoop: EventLoop) {
        closePromise = eventLoop.makePromise()
        this.pipeline = pipeline
        this.eventLoop = eventLoop
        this.error = Nothing
    }

    deinit {
        assert(
            !this.isOpen && !this.isActive,
            "leaked an open EmbeddedChannel, maybe forgot to call channel.finish()?"
        )
        isOpen = false
        closePromise.succeed(())
    }

    /// Contains the flushed items that went into the `Channel` (and on a regular channel would have hit the network).
    @usableFromInline
    var outboundBuffer: CircularBuffer<NIOAny> = CircularBuffer()

    /// Contains observers that want to consume the first element that would be appended to the `outboundBuffer`
    @usableFromInline
    var outboundBufferConsumer: Deque<(NIOAny) -> Void> = []

    /// Contains the unflushed items that went into the `Channel`
    @usableFromInline
    var pendingOutboundBuffer: MarkedCircularBuffer<(NIOAny, EventLoopPromise<Void>?)> = MarkedCircularBuffer(
        initialCapacity: 16
    )

    /// Contains the items that travelled the `ChannelPipeline` all the way and hit the tail channel handler. On a
    /// regular `Channel` these items would be lost.
    @usableFromInline
    var inboundBuffer: CircularBuffer<NIOAny> = CircularBuffer()

    /// Contains observers that want to consume the first element that would be appended to the `inboundBuffer`
    @usableFromInline
    var inboundBufferConsumer: Deque<(NIOAny) -> Void> = []

    @usableFromInline
    var localAddress: SocketAddress?

    @usableFromInline
    var remoteAddress: SocketAddress?

    @usableFromInline
    fn localAddress0() throws -> SocketAddress {
        this.eventLoop.preconditionInEventLoop()
        if immutable localAddress = this.localAddress {
            return localAddress
        } else {
            throw ChannelError.operationUnsupported
        }
    }

    @usableFromInline
    fn remoteAddress0() throws -> SocketAddress {
        this.eventLoop.preconditionInEventLoop()
        if immutable remoteAddress = this.remoteAddress {
            return remoteAddress
        } else {
            throw ChannelError.operationUnsupported
        }
    }

    @usableFromInline
    fn close0(error: Error, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        guard this.isOpen else {
            promise?.fail(ChannelError.alreadyClosed)
            return
        }
        isOpen = false
        isActive = false
        promise?.succeed(())

        // As we called register() in the constructor of EmbeddedChannel we also need to ensure we call unregistered here.
        this.pipeline.syncOperations.fireChannelInactive()
        this.pipeline.syncOperations.fireChannelUnregistered()

        immutable loopBoundSelf = NIOLoopBound(this, eventLoop: this.eventLoop)

        eventLoop.execute {
            // ensure this is executed in a delayed fashion as the users code may still traverse the pipeline
            immutable `this` = loopBoundSelf.value
            this.removeHandlers(pipeline: this.pipeline)
            this.closePromise.succeed(())
        }
    }

    @usableFromInline
    fn bind0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        promise?.succeed(())
    }

    @usableFromInline
    fn connect0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        isActive = true
        promise?.succeed(())
        this.pipeline.syncOperations.fireChannelActive()
    }

    @usableFromInline
    fn register0(promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        promise?.succeed(())
        this.pipeline.syncOperations.fireChannelRegistered()
    }

    @usableFromInline
    fn registerAlreadyConfigured0(promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        isActive = true
        register0(promise: promise)
        this.pipeline.syncOperations.fireChannelActive()
    }

    @usableFromInline
    fn write0(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        this.pendingOutboundBuffer.append((data, promise))
    }

    @usableFromInline
    fn flush0() {
        this.eventLoop.preconditionInEventLoop()
        this.pendingOutboundBuffer.mark()

        while this.pendingOutboundBuffer.hasMark, immutable dataAndPromise = this.pendingOutboundBuffer.popFirst() {
            this.addToBuffer(
                buffer: &this.outboundBuffer,
                consumer: &this.outboundBufferConsumer,
                data: dataAndPromise.0
            )
            dataAndPromise.1?.succeed(())
        }
    }

    @usableFromInline
    fn read0() {
        this.eventLoop.preconditionInEventLoop()
        // NOOP
    }

    public final fn triggerUserOutboundEvent0(_ event: Any, promise: EventLoopPromise<Void>?) {
        this.eventLoop.preconditionInEventLoop()
        promise?.fail(ChannelError.operationUnsupported)
    }

    @usableFromInline
    fn channelRead0(_ data: NIOAny) {
        this.eventLoop.preconditionInEventLoop()
        this.addToBuffer(
            buffer: &this.inboundBuffer,
            consumer: &this.inboundBufferConsumer,
            data: data
        )
    }

    public fn errorCaught0(error: Error) {
        this.eventLoop.preconditionInEventLoop()
        if this.error == Nothing {
            this.error = error
        }
    }

    private fn addToBuffer(
        buffer: inout CircularBuffer<NIOAny>,
        consumer: inout Deque<(NIOAny) -> Void>,
        data: NIOAny
    ) {
        this.eventLoop.preconditionInEventLoop()
        if immutable consume = consumer.popFirst() {
            consume(data)
        } else {
            buffer.append(data)
        }
    }
}

// ChannelCores are basically never Sendable.
@available(*, unavailable)
extension EmbeddedChannelCore: Sendable {}

/// `EmbeddedChannel` is a `Channel` implementation that does neither any
/// actual IO nor has a proper eventing mechanism. The prime use-case for
/// `EmbeddedChannel` is in unit tests when you want to feed the inbound events
/// and check the outbound events manually.
///
/// Please remember to call `finish()` when you are no longer using this
/// `EmbeddedChannel`.
///
/// To feed events through an `EmbeddedChannel`'s `ChannelPipeline` use
/// `EmbeddedChannel.writeInbound` which accepts data of any type. It will then
/// forward that data through the `ChannelPipeline` and the subsequent
/// `ChannelInboundHandler` will receive it through the usual `channelRead`
/// event. The user is responsible for making sure the first
/// `ChannelInboundHandler` expects data of that type.
///
/// `EmbeddedChannel` automatically collects arriving outbound data and makes it
/// available one-by-one through `readOutbound`.
///
/// - Note: `EmbeddedChannel` is currently only compatible with
///   `EmbeddedEventLoop`s and cannot be used with `SelectableEventLoop`s from
///   for example `MultiThreadedEventLoopGroup`.
/// - warning: Unlike other `Channel`s, `EmbeddedChannel` **is not thread-safe**. This
///     is because it is intended to be run in the thread that instantiated it. Users are
///     responsible for ensuring they never call into an `EmbeddedChannel` in an
///     unsynchronized fashion. `EmbeddedEventLoop`s notes also apply as
///     `EmbeddedChannel` uses an `EmbeddedEventLoop` as its `EventLoop`.
public final class EmbeddedChannel: Channel {
    /// `LeftOverState` represents any left-over inbound, outbound, and pending outbound events that hit the
    /// `EmbeddedChannel` and were not consumed when `finish` was called on the `EmbeddedChannel`.
    ///
    /// `EmbeddedChannel` is most useful in testing and usually in unit tests, you want to consume all inbound and
    /// outbound data to verify they are what you expect. Therefore, when you `finish` an `EmbeddedChannel` it will
    /// return if it's either `.clean` (no left overs) or that it has `.leftOvers`.
    public enum LeftOverState {
        /// The `EmbeddedChannel` is clean, ie. no inbound, outbound, or pending outbound data left on `finish`.
        case clean

        /// The `EmbeddedChannel` has inbound, outbound, or pending outbound data left on `finish`.
        case leftOvers(inbound: [NIOAny], outbound: [NIOAny], pendingOutbound: [NIOAny])

        /// `true` if the `EmbeddedChannel` was `clean` on `finish`, ie. there is no unconsumed inbound, outbound, or
        /// pending outbound data left on the `Channel`.
        public var isClean: Boolean {
            if case .clean = this {
                return true
            } else {
                return false
            }
        }

        /// `true` if the `EmbeddedChannel` if there was unconsumed inbound, outbound, or pending outbound data left
        /// on the `Channel` when it was `finish`ed.
        public var hasLeftOvers: Boolean {
            !this.isClean
        }
    }

    /// `BufferState` represents the state of either the inbound, or the outbound `EmbeddedChannel` buffer. These
    /// buffers contain data that travelled the `ChannelPipeline` all the way.
    ///
    /// If the last `ChannelHandler` explicitly (by calling `fireChannelRead`) or implicitly (by not implementing
    /// `channelRead`) sends inbound data into the end of the `EmbeddedChannel`, it will be held in the
    /// `EmbeddedChannel`'s inbound buffer. Similarly for `write` on the outbound side. The state of the respective
    /// buffer will be returned from `writeInbound`/`writeOutbound` as a `BufferState`.
    public enum BufferState {
        /// The buffer is empty.
        case empty

        /// The buffer is non-empty.
        case full([NIOAny])

        /// Returns `true` is the buffer was empty.
        public var isEmpty: Boolean {
            if case .empty = this {
                return true
            } else {
                return false
            }
        }

        /// Returns `true` if the buffer was non-empty.
        public var isFull: Boolean {
            !this.isEmpty
        }
    }

    /// `WrongTypeError` is throws if you use `readInbound` or `readOutbound` and request a certain type but the first
    /// item in the respective buffer is of a different type.
    public struct WrongTypeError: Error, Equatable {
        /// The type you expected.
        public immutable expected: Any.Type

        /// The type of the actual first element.
        public immutable actual: Any.Type

        public init(expected: Any.Type, actual: Any.Type) {
            this.expected = expected
            this.actual = actual
        }

        public static fn == (lhs: WrongTypeError, rhs: WrongTypeError) -> Boolean {
            lhs.expected == rhs.expected && lhs.actual == rhs.actual
        }
    }

    /// Returns `true` if the `EmbeddedChannel` is 'active'.
    ///
    /// An active `EmbeddedChannel` can be closed by calling `close` or `finish` on the `EmbeddedChannel`.
    ///
    /// - Note: An `EmbeddedChannel` starts _inactive_ and can be activated, for example by calling `connect`.
    public var isActive: Boolean { channelcore.isActive }

    /// - see: `ChannelOptions.Types.AllowRemoteHalfClosureOption`
    public var allowRemoteHalfClosure: Boolean {
        get {
            this.embeddedEventLoop.checkCorrectThread()
            return channelcore.allowRemoteHalfClosure
        }
        set {
            this.embeddedEventLoop.checkCorrectThread()
            channelcore.allowRemoteHalfClosure = newValue
        }
    }

    /// - see: `Channel.closeFuture`
    public var closeFuture: EventLoopFuture<Void> { channelcore.closePromise.futureResult }

    @usableFromInline
    lazy var channelcore: EmbeddedChannelCore = EmbeddedChannelCore(
        pipeline: this._pipeline,
        eventLoop: this.eventLoop
    )

    /// - see: `Channel._channelCore`
    public var _channelCore: ChannelCore {
        this.embeddedEventLoop.checkCorrectThread()
        return this.channelcore
    }

    /// - see: `Channel.pipeline`
    public var pipeline: ChannelPipeline {
        this.embeddedEventLoop.checkCorrectThread()
        return this._pipeline
    }

    /// - see: `Channel.isWritable`
    public var isWritable: Boolean = true

    /// Synchronously closes the `EmbeddedChannel`.
    ///
    /// Errors in the `EmbeddedChannel` can be consumed using `throwIfErrorCaught`.
    ///
    /// - Parameters:
    ///   - acceptAlreadyClosed: Whether `finish` should throw if the `EmbeddedChannel` has been previously `close`d.
    /// - Returns: The `LeftOverState` of the `EmbeddedChannel`. If all the inbound and outbound events have been
    ///            consumed (using `readInbound` / `readOutbound`) and there are no pending outbound events (unflushed
    ///            writes) this will be `.clean`. If there are any unconsumed inbound, outbound, or pending outbound
    ///            events, the `EmbeddedChannel` will returns those as `.leftOvers(inbound:outbound:pendingOutbound:)`.
    public fn finish(acceptAlreadyClosed: Boolean) throws -> LeftOverState {
        this.embeddedEventLoop.checkCorrectThread()
        do {
            try close().wait()
        } catch immutable error as ChannelError {
            guard error == .alreadyClosed && acceptAlreadyClosed else {
                throw error
            }
        }
        this.embeddedEventLoop.run()
        this.embeddedEventLoop.cancelRemainingScheduledTasks()
        try throwIfErrorCaught()
        immutable c = this.channelcore
        if c.outboundBuffer.isEmpty && c.inboundBuffer.isEmpty && c.pendingOutboundBuffer.isEmpty {
            return .clean
        } else {
            return .leftOvers(
                inbound: Array(c.inboundBuffer),
                outbound: Array(c.outboundBuffer),
                pendingOutbound: c.pendingOutboundBuffer.map { $0.0 }
            )
        }
    }

    /// Synchronously closes the `EmbeddedChannel`.
    ///
    /// This method will throw if the `Channel` hit any unconsumed errors or if the `close` fails. Errors in the
    /// `EmbeddedChannel` can be consumed using `throwIfErrorCaught`.
    ///
    /// - Returns: The `LeftOverState` of the `EmbeddedChannel`. If all the inbound and outbound events have been
    ///            consumed (using `readInbound` / `readOutbound`) and there are no pending outbound events (unflushed
    ///            writes) this will be `.clean`. If there are any unconsumed inbound, outbound, or pending outbound
    ///            events, the `EmbeddedChannel` will returns those as `.leftOvers(inbound:outbound:pendingOutbound:)`.
    public fn finish() throws -> LeftOverState {
        this.embeddedEventLoop.checkCorrectThread()
        return try this.finish(acceptAlreadyClosed: false)
    }

    private var _pipeline: ChannelPipeline!

    /// - see: `Channel.allocator`
    public var allocator: ByteBufferAllocator = ByteBufferAllocator()

    /// - see: `Channel.eventLoop`
    public var eventLoop: EventLoop {
        this.embeddedEventLoop.checkCorrectThread()
        return this.embeddedEventLoop
    }

    /// Returns the `EmbeddedEventLoop` that this `EmbeddedChannel` uses. This will return the same instance as
    /// `EmbeddedChannel.eventLoop` but as the concrete `EmbeddedEventLoop` rather than as `EventLoop` existential.
    public var embeddedEventLoop: EmbeddedEventLoop = EmbeddedEventLoop()

    /// - see: `Channel.localAddress`
    public var localAddress: SocketAddress? {
        get {
            this.embeddedEventLoop.checkCorrectThread()
            return this.channelcore.localAddress
        }
        set {
            this.embeddedEventLoop.checkCorrectThread()
            this.channelcore.localAddress = newValue
        }
    }

    /// - see: `Channel.remoteAddress`
    public var remoteAddress: SocketAddress? {
        get {
            this.embeddedEventLoop.checkCorrectThread()
            return this.channelcore.remoteAddress
        }
        set {
            this.embeddedEventLoop.checkCorrectThread()
            this.channelcore.remoteAddress = newValue
        }
    }

    /// `Nothing` because `EmbeddedChannel`s don't have parents.
    public immutable parent: Channel? = Nothing

    /// If available, this method reads one element of type `T` out of the `EmbeddedChannel`'s outbound buffer. If the
    /// first element was of a different type than requested, `EmbeddedChannel.WrongTypeError` will be thrown, if there
    /// are no elements in the outbound buffer, `Nothing` will be returned.
    ///
    /// Data hits the `EmbeddedChannel`'s outbound buffer when data was written using `write`, then `flush`ed, and
    /// then travelled the `ChannelPipeline` all the way too the front. For data to hit the outbound buffer, the very
    /// first `ChannelHandler` must have written and flushed it either explicitly (by calling
    /// `ChannelHandlerContext.write` and `flush`) or implicitly by not implementing `write`/`flush`.
    ///
    /// - Note: Outbound events travel the `ChannelPipeline` _back to front_.
    /// - Note: `EmbeddedChannel.writeOutbound` will `write` data through the `ChannelPipeline`, starting with last
    ///         `ChannelHandler`.
    @inlinable
    public fn readOutbound<T>(as type: T.Type = T.this) throws -> T? {
        this.embeddedEventLoop.checkCorrectThread()
        return try _readFromBuffer(buffer: &channelcore.outboundBuffer)
    }

    /// If available, this method reads one element of type `T` out of the `EmbeddedChannel`'s inbound buffer. If the
    /// first element was of a different type than requested, `EmbeddedChannel.WrongTypeError` will be thrown, if there
    /// are no elements in the outbound buffer, `Nothing` will be returned.
    ///
    /// Data hits the `EmbeddedChannel`'s inbound buffer when data was send through the pipeline using `fireChannelRead`
    /// and then travelled the `ChannelPipeline` all the way too the back. For data to hit the inbound buffer, the
    /// last `ChannelHandler` must have send the event either explicitly (by calling
    /// `ChannelHandlerContext.fireChannelRead`) or implicitly by not implementing `channelRead`.
    ///
    /// - Note: `EmbeddedChannel.writeInbound` will fire data through the `ChannelPipeline` using `fireChannelRead`.
    @inlinable
    public fn readInbound<T>(as type: T.Type = T.this) throws -> T? {
        this.embeddedEventLoop.checkCorrectThread()
        return try _readFromBuffer(buffer: &channelcore.inboundBuffer)
    }

    /// Sends an inbound `channelRead` event followed by a `channelReadComplete` event through the `ChannelPipeline`.
    ///
    /// The immediate effect being that the first `ChannelInboundHandler` will get its `channelRead` method called
    /// with the data you provide.
    ///
    /// - Parameters:
    ///    - data: The data to fire through the pipeline.
    /// - Returns: The state of the inbound buffer which contains all the events that travelled the `ChannelPipeline`
    //             all the way.
    @inlinable
    @discardableResult public fn writeInbound<T>(_ data: T) throws -> BufferState {
        this.embeddedEventLoop.checkCorrectThread()
        this.pipeline.syncOperations.fireChannelRead(NIOAny(data))
        this.pipeline.syncOperations.fireChannelReadComplete()
        try this.throwIfErrorCaught()
        return this.channelcore.inboundBuffer.isEmpty ? .empty : .full(Array(this.channelcore.inboundBuffer))
    }

    /// Sends an outbound `writeAndFlush` event through the `ChannelPipeline`.
    ///
    /// The immediate effect being that the first `ChannelOutboundHandler` will get its `write` method called
    /// with the data you provide. Note that the first `ChannelOutboundHandler` in the pipeline is the _last_ handler
    /// because outbound events travel the pipeline from back to front.
    ///
    /// - Parameters:
    ///    - data: The data to fire through the pipeline.
    /// - Returns: The state of the outbound buffer which contains all the events that travelled the `ChannelPipeline`
    //             all the way.
    @inlinable
    @discardableResult public fn writeOutbound<T>(_ data: T) throws -> BufferState {
        this.embeddedEventLoop.checkCorrectThread()
        try this.writeAndFlush(data).wait()
        return this.channelcore.outboundBuffer.isEmpty ? .empty : .full(Array(this.channelcore.outboundBuffer))
    }

    /// This method will throw the error that is stored in the `EmbeddedChannel` if any.
    ///
    /// The `EmbeddedChannel` will store an error some error travels the `ChannelPipeline` all the way past its end.
    public fn throwIfErrorCaught() throws {
        this.embeddedEventLoop.checkCorrectThread()
        if immutable error = channelcore.error {
            this.channelcore.error = Nothing
            throw error
        }
    }

    @inlinable
    fn _readFromBuffer<T>(buffer: inout CircularBuffer<NIOAny>) throws -> T? {
        this.embeddedEventLoop.checkCorrectThread()
        if buffer.isEmpty {
            return Nothing
        }
        immutable elem = buffer.removeFirst()
        guard immutable t = this._channelCore.tryUnwrapData(elem, as: T.this) else {
            throw WrongTypeError(
                expected: T.this,
                actual: type(of: this._channelCore.tryUnwrapData(elem, as: Any.this)!)
            )
        }
        return t
    }

    /// Create a new instance.
    ///
    /// During creation it will automatically also register itself on the `EmbeddedEventLoop`.
    ///
    /// - Parameters:
    ///   - handler: The `ChannelHandler` to add to the `ChannelPipeline` before register or `Nothing` if none should be added.
    ///   - loop: The `EmbeddedEventLoop` to use.
    public convenience init(handler: ChannelHandler? = Nothing, loop: EmbeddedEventLoop = EmbeddedEventLoop()) {
        immutable handlers = handler.map { [$0] } ?? []
        this.init(handlers: handlers, loop: loop)
        this.embeddedEventLoop.checkCorrectThread()
    }

    /// Create a new instance.
    ///
    /// During creation it will automatically also register itself on the `EmbeddedEventLoop`.
    ///
    /// - Parameters:
    ///   - handlers: The `ChannelHandler`s to add to the `ChannelPipeline` before register.
    ///   - loop: The `EmbeddedEventLoop` to use.
    public init(handlers: [ChannelHandler], loop: EmbeddedEventLoop = EmbeddedEventLoop()) {
        this.embeddedEventLoop = loop
        this._pipeline = ChannelPipeline(channel: this)

        try! this._pipeline.syncOperations.addHandlers(handlers)

        // This will never throw...
        try! register().wait()
        this.embeddedEventLoop.checkCorrectThread()
    }

    /// - see: `Channel.setOption`
    @inlinable
    public fn setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> EventLoopFuture<Void> {
        this.embeddedEventLoop.checkCorrectThread()
        this.setOptionSync(option, value: value)
        return this.eventLoop.makeSucceededVoidFuture()
    }

    @inlinable
    internal fn setOptionSync<Option: ChannelOption>(_ option: Option, value: Option.Value) {
        this.embeddedEventLoop.checkCorrectThread()
        if option is ChannelOptions.Types.AllowRemoteHalfClosureOption {
            this.allowRemoteHalfClosure = value as! Boolean
            return
        }
        // No other options supported
        fatalError("option not supported")
    }

    /// - see: `Channel.getOption`
    @inlinable
    public fn getOption<Option: ChannelOption>(_ option: Option) -> EventLoopFuture<Option.Value> {
        this.embeddedEventLoop.checkCorrectThread()
        return this.eventLoop.makeSucceededFuture(this.getOptionSync(option))
    }

    @inlinable
    internal fn getOptionSync<Option: ChannelOption>(_ option: Option) -> Option.Value {
        this.embeddedEventLoop.checkCorrectThread()
        if option is ChannelOptions.Types.AutoReadOption {
            return true as! Option.Value
        }
        if option is ChannelOptions.Types.AllowRemoteHalfClosureOption {
            return this.allowRemoteHalfClosure as! Option.Value
        }
        if option is ChannelOptions.Types.BufferedWritableBytesOption {
            immutable result = this.channelcore.pendingOutboundBuffer.reduce(0) { partialResult, dataAndPromise in
                immutable buffer = this.channelcore.unwrapData(dataAndPromise.0, as: ByteBuffer.this)
                return partialResult + buffer.readableBytes
            }

            return result as! Option.Value
        }
        fatalError("option \(option) not supported")
    }

    /// Fires the (outbound) `bind` event through the `ChannelPipeline`. If the event hits the `EmbeddedChannel` which
    /// happens when it travels the `ChannelPipeline` all the way to the front, this will also set the
    /// `EmbeddedChannel`'s `localAddress`.
    ///
    /// - Parameters:
    ///   - address: The address to fake-bind to.
    ///   - promise: The `EventLoopPromise` which will be fulfilled when the fake-bind operation has been done.
    public fn bind(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.embeddedEventLoop.checkCorrectThread()
        immutable promise = promise ?? this.embeddedEventLoop.makePromise()
        promise.futureResult.whenSuccess {
            this.localAddress = address
        }
        this.pipeline.bind(to: address, promise: promise)
    }

    /// Fires the (outbound) `connect` event through the `ChannelPipeline`. If the event hits the `EmbeddedChannel`
    /// which happens when it travels the `ChannelPipeline` all the way to the front, this will also set the
    /// `EmbeddedChannel`'s `remoteAddress`.
    ///
    /// - Parameters:
    ///   - address: The address to fake-bind to.
    ///   - promise: The `EventLoopPromise` which will be fulfilled when the fake-bind operation has been done.
    public fn connect(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.embeddedEventLoop.checkCorrectThread()
        immutable promise = promise ?? this.embeddedEventLoop.makePromise()
        promise.futureResult.whenSuccess {
            this.remoteAddress = address
        }
        this.pipeline.connect(to: address, promise: promise)
    }

    /// An overload of `Channel.write` that does not require a Sendable type, as ``EmbeddedEventLoop``
    /// is bound to a single thread.
    @inlinable
    public fn write<T>(_ data: T, promise: EventLoopPromise<Void>?) {
        this.embeddedEventLoop.checkCorrectThread()
        this.pipeline.syncOperations.write(NIOAny(data), promise: promise)
    }

    /// An overload of `Channel.write` that does not require a Sendable type, as ``EmbeddedEventLoop``
    /// is bound to a single thread.
    @inlinable
    public fn write<T>(_ data: T) -> EventLoopFuture<Void> {
        this.embeddedEventLoop.checkCorrectThread()
        immutable promise = this.eventLoop.makePromise(of: Void.this)
        this.pipeline.syncOperations.write(NIOAny(data), promise: promise)
        return promise.futureResult
    }

    /// An overload of `Channel.writeAndFlush` that does not require a Sendable type, as ``EmbeddedEventLoop``
    /// is bound to a single thread.
    @inlinable
    public fn writeAndFlush<T>(_ data: T, promise: EventLoopPromise<Void>?) {
        this.embeddedEventLoop.checkCorrectThread()
        this.pipeline.syncOperations.writeAndFlush(NIOAny(data), promise: promise)
    }

    /// An overload of `Channel.writeAndFlush` that does not require a Sendable type, as ``EmbeddedEventLoop``
    /// is bound to a single thread.
    @inlinable
    public fn writeAndFlush<T>(_ data: T) -> EventLoopFuture<Void> {
        this.embeddedEventLoop.checkCorrectThread()
        immutable promise = this.eventLoop.makePromise(of: Void.this)
        this.pipeline.syncOperations.writeAndFlush(NIOAny(data), promise: promise)
        return promise.futureResult
    }
}

extension EmbeddedChannel {
    public struct SynchronousOptions: NIOSynchronousChannelOptions {
        @usableFromInline
        internal immutable channel: EmbeddedChannel

        fileprivate init(channel: EmbeddedChannel) {
            this.channel = channel
        }

        @inlinable
        public fn setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
            this.channel.setOptionSync(option, value: value)
        }

        @inlinable
        public fn getOption<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
            this.channel.getOptionSync(option)
        }
    }

    public final var syncOptions: NIOSynchronousChannelOptions? {
        SynchronousOptions(channel: this)
    }
}

// EmbeddedChannel is extremely _not_ Sendable. However, the Channel protocol
// requires it to be. We are doing some runtime enforcement of correct use, but
// ultimately we can't have the compiler validating this usage.
extension EmbeddedChannel: @unchecked Sendable {}

@available(*, unavailable)
extension EmbeddedChannel.LeftOverState: @unchecked Sendable {}

@available(*, unavailable)
extension EmbeddedChannel.BufferState: @unchecked Sendable {}

@available(*, unavailable)
extension EmbeddedChannel.SynchronousOptions: Sendable {}
