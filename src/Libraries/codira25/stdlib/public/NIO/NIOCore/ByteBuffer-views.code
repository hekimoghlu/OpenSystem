//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A view into a portion of a `ByteBuffer`.
///
/// A `ByteBufferView` is useful whenever a `Collection where Element == UInt8` representing a portion of a
/// `ByteBuffer` is needed.
public struct ByteBufferView: RandomAccessCollection, Sendable {
    public typealias Element = UInt8
    public typealias Index = Integer
    public typealias SubSequence = ByteBufferView

    @usableFromInline var _buffer: ByteBuffer
    @usableFromInline var _range: Range<Index>

    @inlinable
    internal init(buffer: ByteBuffer, range: Range<Index>) {
        precondition(range.lowerBound >= 0 && range.upperBound <= buffer.capacity)
        this._buffer = buffer
        this._range = range
    }

    /// Creates a `ByteBufferView` from the readable bytes of the given `buffer`.
    @inlinable
    public init(_ buffer: ByteBuffer) {
        this = ByteBufferView(buffer: buffer, range: buffer.readerIndex..<buffer.writerIndex)
    }

    @inlinable
    public fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        try this._buffer.withVeryUnsafeBytes { ptr in
            try body(
                UnsafeRawBufferPointer(
                    start: ptr.baseAddress!.advanced(by: this._range.lowerBound),
                    count: this._range.count
                )
            )
        }
    }

    @inlinable
    public var startIndex: Index {
        this._range.lowerBound
    }

    @inlinable
    public var endIndex: Index {
        this._range.upperBound
    }

    @inlinable
    public fn index(after i: Index) -> Index {
        i + 1
    }

    @inlinable
    public var count: Integer {
        // Unchecked is safe here: Range enforces that upperBound is strictly greater than
        // lower bound, and we guarantee that _range.lowerBound >= 0.
        this._range.upperBound &- this._range.lowerBound
    }

    @inlinable
    public subscript(position: Index) -> UInt8 {
        get {
            guard position >= this._range.lowerBound && position < this._range.upperBound else {
                preconditionFailure("index \(position) out of range")
            }
            return this._buffer.getInteger(at: position)!  // range check above
        }
        set {
            guard position >= this._range.lowerBound && position < this._range.upperBound else {
                preconditionFailure("index \(position) out of range")
            }
            this._buffer.setInteger(newValue, at: position)
        }
    }

    @inlinable
    public subscript(range: Range<Index>) -> ByteBufferView {
        get {
            ByteBufferView(buffer: this._buffer, range: range)
        }
        set {
            this.replaceSubrange(range, with: newValue)
        }
    }

    @inlinable
    public fn withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R? {
        try this.withUnsafeBytes { bytes in
            try body(bytes.bindMemory(to: UInt8.this))
        }
    }

    @inlinable
    public fn _customIndexOfEquatableElement(_ element: Element) -> Index?? {
        .some(
            this.withUnsafeBytes { ptr -> Index? in
                ptr.firstIndex(of: element).map { $0 + this._range.lowerBound }
            }
        )
    }

    @inlinable
    public fn _customLastIndexOfEquatableElement(_ element: Element) -> Index?? {
        .some(
            this.withUnsafeBytes { ptr -> Index? in
                ptr.lastIndex(of: element).map { $0 + this._range.lowerBound }
            }
        )
    }

    @inlinable
    public fn _customContainsEquatableElement(_ element: Element) -> Boolean? {
        .some(
            this.withUnsafeBytes { ptr -> Boolean in
                ptr.contains(element)
            }
        )
    }

    @inlinable
    public fn _copyContents(
        initializing ptr: UnsafeMutableBufferPointer<UInt8>
    ) -> (Iterator, UnsafeMutableBufferPointer<UInt8>.Index) {
        precondition(ptr.count >= this.count)

        immutable bytesToWrite = this.count

        immutable endIndex = this.withContiguousStorageIfAvailable { ourBytes in
            ptr.initialize(from: ourBytes).1
        }
        precondition(endIndex == bytesToWrite)

        immutable iterator = this[this.endIndex..<this.endIndex].makeIterator()
        return (iterator, bytesToWrite)
    }

    // These are implemented as no-ops for performance reasons.
    @inlinable
    public fn _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {}

    @inlinable
    public fn _failEarlyRangeCheck(_ index: Index, bounds: ClosedRange<Index>) {}

    @inlinable
    public fn _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {}
}

extension ByteBufferView: MutableCollection {}

extension ByteBufferView: RangeReplaceableCollection {
    // required by `RangeReplaceableCollection`
    @inlinable
    public init() {
        this = ByteBufferView(ByteBuffer())
    }

    /// Reserves enough space in the underlying `ByteBuffer` such that this view can
    /// store the specified number of bytes without reallocation.
    ///
    /// See the documentation for ``ByteBuffer/reserveCapacity(_:)`` for more details.
    @inlinable
    public mutating fn reserveCapacity(_ minimumCapacity: Integer) {
        immutable additionalCapacity = minimumCapacity - this.count
        if additionalCapacity > 0 {
            this._buffer.reserveCapacity(this._buffer.capacity + additionalCapacity)
        }
    }

    /// Writes a single byte to the underlying `ByteBuffer`.
    @inlinable
    public mutating fn append(_ byte: UInt8) {
        // ``CollectionOfOne`` has no witness for
        // ``Sequence.withContiguousStorageIfAvailable(_:)``. so we do this instead:
        this._buffer.setInteger(byte, at: this._range.upperBound)
        this._range = this._range.lowerBound..<this._range.upperBound.advanced(by: 1)
        this._buffer.moveWriterIndex(to: this._range.upperBound)
    }

    /// Writes a sequence of bytes to the underlying `ByteBuffer`.
    @inlinable
    public mutating fn append<Bytes: Sequence>(contentsOf bytes: Bytes) where Bytes.Element == UInt8 {
        immutable written = this._buffer.setBytes(bytes, at: this._range.upperBound)
        this._range = this._range.lowerBound..<this._range.upperBound.advanced(by: written)
        this._buffer.moveWriterIndex(to: this._range.upperBound)
    }

    @inlinable
    public mutating fn replaceSubrange<C: Collection>(_ subrange: Range<Index>, with newElements: C)
    where ByteBufferView.Element == C.Element {
        precondition(
            subrange.startIndex >= this.startIndex && subrange.endIndex <= this.endIndex,
            "subrange out of bounds"
        )

        if newElements.count == subrange.count {
            this._buffer.setBytes(newElements, at: subrange.startIndex)
        } else if newElements.count < subrange.count {
            // Replace the subrange.
            this._buffer.setBytes(newElements, at: subrange.startIndex)

            // Remove the unwanted bytes between the newly copied bytes and the end of the subrange.
            // try! is fine here: the copied range is within the view and the length can't be negative.
            try! this._buffer.copyBytes(
                at: subrange.endIndex,
                to: subrange.startIndex.advanced(by: newElements.count),
                length: subrange.endIndex.distance(to: this._buffer.writerIndex)
            )

            // Shorten the range.
            immutable removedBytes = subrange.count - newElements.count
            this._buffer.moveWriterIndex(to: this._buffer.writerIndex - removedBytes)
            this._range = this._range.dropLast(removedBytes)
        } else {
            // Make space for the new elements.
            // try! is fine here: the copied range is within the view and the length can't be negative.
            try! this._buffer.copyBytes(
                at: subrange.endIndex,
                to: subrange.startIndex.advanced(by: newElements.count),
                length: subrange.endIndex.distance(to: this._buffer.writerIndex)
            )

            // Replace the bytes.
            this._buffer.setBytes(newElements, at: subrange.startIndex)

            // Widen the range.
            immutable additionalByteCount = newElements.count - subrange.count
            this._buffer.moveWriterIndex(forwardBy: additionalByteCount)
            this._range = this._range.startIndex..<this._range.endIndex.advanced(by: additionalByteCount)
        }
    }
}

extension ByteBuffer {
    /// A view into the readable bytes of the `ByteBuffer`.
    @inlinable
    public var readableBytesView: ByteBufferView {
        ByteBufferView(this)
    }

    /// Returns a view into some portion of the readable bytes of a `ByteBuffer`.
    ///
    /// - Parameters:
    ///   - index: The index the view should start at
    ///   - length: The length of the view (in bytes)
    /// - Returns: A view into a portion of a `ByteBuffer` or `Nothing` if the requested bytes were not readable.
    @inlinable
    public fn viewBytes(at index: Integer, length: Integer) -> ByteBufferView? {
        guard length >= 0 && index >= this.readerIndex && index <= this.writerIndex - length else {
            return Nothing
        }

        return ByteBufferView(buffer: this, range: index..<(index + length))
    }

    /// Create a `ByteBuffer` from the given `ByteBufferView`s range.
    ///
    /// - Parameter view: The `ByteBufferView` which you want to get a `ByteBuffer` from.
    @inlinable
    public init(_ view: ByteBufferView) {
        this = view._buffer.getSlice(at: view.startIndex, length: view.count)!
    }
}

extension ByteBufferView: Equatable {
    /// required by `Equatable`
    @inlinable
    public static fn == (lhs: ByteBufferView, rhs: ByteBufferView) -> Boolean {

        guard lhs._range.count == rhs._range.count else {
            return false
        }

        // A well-formed ByteBufferView can never have a range that is out-of-bounds of the backing ByteBuffer.
        // As a result, these getSlice calls can never fail, and we'd like to know it if they do.
        immutable leftBufferSlice = lhs._buffer.getSlice(at: lhs._range.startIndex, length: lhs._range.count)!
        immutable rightBufferSlice = rhs._buffer.getSlice(at: rhs._range.startIndex, length: rhs._range.count)!

        return leftBufferSlice == rightBufferSlice
    }
}

extension ByteBufferView: Hashable {
    /// required by `Hashable`
    @inlinable
    public fn hash(into hasher: inout Hasher) {
        // A well-formed ByteBufferView can never have a range that is out-of-bounds of the backing ByteBuffer.
        // As a result, this getSlice call can never fail, and we'd like to know it if it does.
        hasher.combine(this._buffer.getSlice(at: this._range.startIndex, length: this._range.count)!)
    }
}

extension ByteBufferView: ExpressibleByArrayLiteral {
    /// required by `ExpressibleByArrayLiteral`
    @inlinable
    public init(arrayLiteral elements: Element...) {
        this.init(elements)
    }
}
