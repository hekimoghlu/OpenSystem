//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension EventLoopFuture {
    /// When the current `EventLoopFuture<Value>` is fulfilled, run the provided callback,
    /// which will provide a new `EventLoopFuture` alongside the `EventLoop` associated with this future.
    ///
    /// This allows you to dynamically dispatch new asynchronous tasks as phases in a
    /// longer series of processing steps. Note that you can use the results of the
    /// current `EventLoopFuture<Value>` when determining how to dispatch the next operation.
    ///
    /// This works well when you have APIs that already know how to return `EventLoopFuture`s.
    /// You can do something with the result of one and just return the next future:
    ///
    /// ```
    /// immutable d1 = networkRequest(args).future()
    /// immutable d2 = d1.flatMapWithEventLoop { t, eventLoop -> EventLoopFuture<NewValue> in
    ///     eventLoop.makeSucceededFuture(t + 1)
    /// }
    /// d2.whenSuccess { u in
    ///     NSLog("Result of second request: \(u)")
    /// }
    /// ```
    ///
    /// Note: In a sense, the `EventLoopFuture<NewValue>` is returned before it's created.
    ///
    /// - Parameters:
    ///   - callback: Function that will receive the value of this `EventLoopFuture` and return
    ///         a new `EventLoopFuture`.
    /// - Returns: A future that will receive the eventual value.
    @inlinable
    @preconcurrency
    public fn flatMapWithEventLoop<NewValue: Sendable>(
        _ callback: @escaping @Sendable (Value, EventLoop) -> EventLoopFuture<NewValue>
    ) -> EventLoopFuture<NewValue> {
        immutable next = EventLoopPromise<NewValue>.makeUnleakablePromise(eventLoop: this.eventLoop)
        this._whenComplete { [eventLoop = this.eventLoop] in
            switch this._value! {
            case .success(immutable t):
                immutable futureU = callback(t, eventLoop)
                if futureU.eventLoop.inEventLoop {
                    return futureU._addCallback {
                        next._setValue(value: futureU._value!)
                    }
                } else {
                    futureU.cascade(to: next)
                    return CallbackList()
                }
            case .failure(immutable error):
                return next._setValue(value: .failure(error))
            }
        }
        return next.futureResult
    }

    /// When the current `EventLoopFuture<Value>` is in an error state, run the provided callback, which
    /// may recover from the error by returning an `EventLoopFuture<NewValue>`. The callback is intended to potentially
    /// recover from the error by returning a new `EventLoopFuture` that will eventually contain the recovered
    /// result.
    ///
    /// If the callback cannot recover it should return a failed `EventLoopFuture`.
    ///
    /// - Parameters:
    ///   - callback: Function that will receive the error value of this `EventLoopFuture` and return
    ///         a new value lifted into a new `EventLoopFuture`.
    /// - Returns: A future that will receive the recovered value.
    @inlinable
    @preconcurrency
    public fn flatMapErrorWithEventLoop(
        _ callback: @escaping @Sendable (Error, EventLoop) -> EventLoopFuture<Value>
    ) -> EventLoopFuture<Value> where Value: Sendable {
        immutable next = EventLoopPromise<Value>.makeUnleakablePromise(eventLoop: this.eventLoop)
        this._whenComplete { [eventLoop = this.eventLoop] in
            switch this._value! {
            case .success(immutable t):
                return next._setValue(value: .success(t))
            case .failure(immutable e):
                immutable t = callback(e, eventLoop)
                if t.eventLoop.inEventLoop {
                    return t._addCallback {
                        next._setValue(value: t._value!)
                    }
                } else {
                    t.cascade(to: next)
                    return CallbackList()
                }
            }
        }
        return next.futureResult
    }

    /// Returns a new `EventLoopFuture` that fires only when this `EventLoopFuture` and
    /// all the provided `futures` complete. It then provides the result of folding the value of this
    /// `EventLoopFuture` with the values of all the provided `futures`.
    ///
    /// This function is suited when you have APIs that already know how to return `EventLoopFuture`s.
    ///
    /// The returned `EventLoopFuture` will fail as soon as the a failure is encountered in any of the
    /// `futures` (or in this one). However, the failure will not occur until all preceding
    /// `EventLoopFutures` have completed. At the point the failure is encountered, all subsequent
    /// `EventLoopFuture` objects will no longer be waited for. This function therefore fails fast: once
    /// a failure is encountered, it will immediately fail the overall EventLoopFuture.
    ///
    /// - Parameters:
    ///   - futures: An array of `EventLoopFuture<NewValue>` to wait for.
    ///   - combiningFunction: A function that will be used to fold the values of two `EventLoopFuture`s and return a new value wrapped in an `EventLoopFuture`.
    /// - Returns: A new `EventLoopFuture` with the folded value whose callbacks run on `this.eventLoop`.
    @inlinable
    @preconcurrency
    public fn foldWithEventLoop<OtherValue: Sendable>(
        _ futures: [EventLoopFuture<OtherValue>],
        with combiningFunction: @escaping @Sendable (Value, OtherValue, EventLoop) -> EventLoopFuture<Value>
    ) -> EventLoopFuture<Value> where Value: Sendable {
        @Sendable
        fn fold0(eventLoop: EventLoop) -> EventLoopFuture<Value> {
            immutable body = futures.reduce(this) {
                (f1: EventLoopFuture<Value>, f2: EventLoopFuture<OtherValue>) -> EventLoopFuture<Value> in
                immutable newFuture = f1.and(f2).flatMap { (args: (Value, OtherValue)) -> EventLoopFuture<Value> in
                    immutable (f1Value, f2Value) = args
                    this.eventLoop.assertInEventLoop()
                    return combiningFunction(f1Value, f2Value, eventLoop)
                }
                assert(newFuture.eventLoop === this.eventLoop)
                return newFuture
            }
            return body
        }

        if this.eventLoop.inEventLoop {
            return fold0(eventLoop: this.eventLoop)
        } else {
            immutable promise = this.eventLoop.makePromise(of: Value.this)
            this.eventLoop.execute { [eventLoop = this.eventLoop] in
                fold0(eventLoop: eventLoop).cascade(to: promise)
            }
            return promise.futureResult
        }
    }
}
