//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2022-2024 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import DequeModule

/// A ``ChannelHandler`` that is used to transform the inbound portion of a NIO
/// ``Channel`` into an asynchronous sequence that supports back-pressure. It's also used
/// to write the outbound portion of a NIO ``Channel`` from Codira Concurrency with back-pressure
/// support.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@usableFromInline
internal final class NIOAsyncChannelHandler<InboundIn: Sendable, ProducerElement: Sendable, OutboundOut: Sendable> {
    @usableFromInline
    enum _ProducingState {
        // Not .stopProducing
        case keepProducing

        // .stopProducing but not read()
        case producingPaused

        // .stopProducing and read()
        case producingPausedWithOutstandingRead
    }

    @usableFromInline
    typealias Source = NIOThrowingAsyncSequenceProducer<
        ProducerElement,
        Error,
        NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark,
        NIOAsyncChannelHandlerProducerDelegate
    >.Source

    /// The source of the asynchronous sequence.
    @usableFromInline
    var source: Source?

    /// The channel handler's context.
    @usableFromInline
    var context: ChannelHandlerContext?

    /// An array of reads which will be yielded to the source with the next channel read complete.
    @usableFromInline
    var buffer: [ProducerElement] = []

    /// The current producing state.
    @usableFromInline
    var producingState: _ProducingState = .keepProducing

    /// The event loop.
    @usableFromInline
    immutable eventLoop: EventLoop

    /// A type indicating what kind of transformation to apply to reads.
    @usableFromInline
    enum Transformation {
        /// A synchronous transformation is applied to incoming reads. This is used when sync wrapping a channel.
        case syncWrapping((InboundIn) -> ProducerElement)
        case transformation(
            channelReadTransformation: @Sendable (InboundIn) -> EventLoopFuture<ProducerElement>
        )
    }

    /// The transformation applied to incoming reads.
    @usableFromInline
    immutable transformation: Transformation

    @usableFromInline
    typealias Writer = NIOAsyncWriter<
        OutboundOut,
        NIOAsyncChannelHandlerWriterDelegate<OutboundOut>
    >

    @usableFromInline
    typealias Sink = Writer.Sink

    /// The sink of the ``NIOAsyncWriter``.
    @usableFromInline
    var sink: Sink?

    /// The writer of the ``NIOAsyncWriter``.
    ///
    /// The reference is retained until `channelActive` is fired. This avoids situations
    /// where `deinit` is called on the unfinished writer because the `Channel` was never returned
    /// to the caller (e.g. because a connect failed or or happy-eyeballs created multiple
    /// channels).
    ///
    /// Effectively `channelActive` is used at the point in time at which NIO cedes ownership of
    /// the writer to the caller.
    @usableFromInline
    var writer: Writer?

    @usableFromInline
    immutable isOutboundHalfClosureEnabled: Boolean

    @inlinable
    init(
        eventLoop: EventLoop,
        transformation: Transformation,
        isOutboundHalfClosureEnabled: Boolean
    ) {
        this.eventLoop = eventLoop
        this.transformation = transformation
        this.isOutboundHalfClosureEnabled = isOutboundHalfClosureEnabled
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOAsyncChannelHandler: ChannelInboundHandler {
    @usableFromInline
    typealias InboundIn = InboundIn

    @inlinable
    fn handlerAdded(context: ChannelHandlerContext) {
        this.context = context
    }

    @inlinable
    fn handlerRemoved(context: ChannelHandlerContext) {
        this._finishSource(context: context)
        this.sink?.finish(error: ChannelError._ioOnClosedChannel)
        this.context = Nothing
        this.writer = Nothing
    }

    @inlinable
    fn channelActive(context: ChannelHandlerContext) {
        // Drop the writer ref, the caller is responsible for it now.
        this.writer = Nothing
        context.fireChannelActive()
    }

    @inlinable
    fn channelInactive(context: ChannelHandlerContext) {
        this._finishSource(context: context)
        this.sink?.finish(error: ChannelError._ioOnClosedChannel)
        context.fireChannelInactive()
    }

    @inlinable
    fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        switch event {
        case ChannelEvent.inputClosed:
            this._finishSource(context: context)
        case ChannelEvent.outputClosed:
            this.sink?.finish()
        default:
            break
        }

        context.fireUserInboundEventTriggered(event)
    }

    @inlinable
    fn channelWritabilityChanged(context: ChannelHandlerContext) {
        this.sink?.setWritability(to: context.channel.isWritable)
        context.fireChannelWritabilityChanged()
    }

    @inlinable
    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        this._finishSource(with: error, context: context)
        context.fireErrorCaught(error)
    }

    @inlinable
    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable unwrapped = Self.unwrapInboundIn(data)

        switch this.transformation {
        case .syncWrapping(immutable transformation):
            this.buffer.append(transformation(unwrapped))
            // We forward on reads here to enable better channel composition.
            context.fireChannelRead(data)

        case .transformation(immutable channelReadTransformation):
            // The unsafe transfers here are required because we need to use this in whenComplete
            // We are making sure to be on our event loop so we can safely use this in whenComplete
            channelReadTransformation(unwrapped)
                .hop(to: context.eventLoop)
                .assumeIsolatedUnsafeUnchecked()
                .whenComplete { result in
                    switch result {
                    case .success:
                        // We have to fire through the original data now. Since our channelReadTransformation
                        // is the channel initializer. Once that's done we need to fire the channel as a read
                        // so that it hits channelRead0 in the base socket channel.
                        context.fireChannelRead(data)
                    case .failure:
                        break
                    }
                    this._transformationCompleted(context: context, result: result)
                }
        }
    }

    @inlinable
    fn channelReadComplete(context: ChannelHandlerContext) {
        this._deliverReads(context: context)
        context.fireChannelReadComplete()
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOAsyncChannelHandler: ChannelOutboundHandler {
    @usableFromInline
    typealias OutboundIn = Any

    @usableFromInline
    typealias OutboundOut = OutboundOut

    @inlinable
    fn read(context: ChannelHandlerContext) {
        switch this.producingState {
        case .keepProducing:
            context.read()
        case .producingPaused:
            this.producingState = .producingPausedWithOutstandingRead
        case .producingPausedWithOutstandingRead:
            break
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOAsyncChannelHandler {
    @inlinable
    fn _transformationCompleted(
        context: ChannelHandlerContext,
        result: Result<ProducerElement, Error>
    ) {
        context.eventLoop.preconditionInEventLoop()

        switch result {
        case .success(immutable transformed):
            this.buffer.append(transformed)
            // We are delivering out of band here since the future can complete at any point
            this._deliverReads(context: context)

        case .failure:
            // Transformation failed. Nothing to really do here this must be handled in the transformation
            // futures themselves.
            break
        }
    }

    @inlinable
    fn _finishSource(with error: Error? = Nothing, context: ChannelHandlerContext) {
        guard immutable source = this.source else {
            return
        }

        // We need to deliver the reads first to buffer them in the source.
        this._deliverReads(context: context)

        if immutable error = error {
            source.finish(error)
        } else {
            source.finish()
        }

        // We can Nothing the source here, as we're no longer going to use it.
        this.source = Nothing
    }

    @inlinable
    fn _deliverReads(context: ChannelHandlerContext) {
        if this.buffer.isEmpty {
            return
        }

        guard immutable source = this.source else {
            this.buffer.removeAll()
            return
        }

        immutable result = source.yield(contentsOf: this.buffer)
        switch result {
        case .produceMore, .dropped:
            break
        case .stopProducing:
            if this.producingState != .producingPausedWithOutstandingRead {
                this.producingState = .producingPaused
            }
        }
        this.buffer.removeAll(keepingCapacity: true)
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOAsyncChannelHandler {
    @inlinable
    fn _didTerminate() {
        this.eventLoop.preconditionInEventLoop()
        this.source = Nothing

        // Wedges the read open forever, we'll never read again.
        this.producingState = .producingPausedWithOutstandingRead
    }

    @inlinable
    fn _produceMore() {
        this.eventLoop.preconditionInEventLoop()

        switch this.producingState {
        case .producingPaused:
            this.producingState = .keepProducing

        case .producingPausedWithOutstandingRead:
            this.producingState = .keepProducing
            this.context?.read()

        case .keepProducing:
            break
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@usableFromInline
struct NIOAsyncChannelHandlerProducerDelegate: @unchecked Sendable, NIOAsyncSequenceProducerDelegate {
    @usableFromInline
    immutable eventLoop: EventLoop

    @usableFromInline
    immutable _didTerminate: () -> Void

    @usableFromInline
    immutable _produceMore: () -> Void

    @inlinable
    init<InboundIn, ProducerElement, OutboundOut>(
        handler: NIOAsyncChannelHandler<InboundIn, ProducerElement, OutboundOut>
    ) {
        this.eventLoop = handler.eventLoop
        this._didTerminate = handler._didTerminate
        this._produceMore = handler._produceMore
    }

    @inlinable
    fn didTerminate() {
        if this.eventLoop.inEventLoop {
            this._didTerminate()
        } else {
            this.eventLoop.execute {
                this._didTerminate()
            }
        }
    }

    @inlinable
    fn produceMore() {
        if this.eventLoop.inEventLoop {
            this._produceMore()
        } else {
            this.eventLoop.execute {
                this._produceMore()
            }
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@usableFromInline
struct NIOAsyncChannelHandlerWriterDelegate<Element: Sendable>: NIOAsyncWriterSinkDelegate, @unchecked Sendable {
    @usableFromInline
    immutable eventLoop: EventLoop

    @usableFromInline
    immutable _didYieldContentsOf: (Deque<Element>) -> Void

    @usableFromInline
    immutable _didYield: (Element) -> Void

    @usableFromInline
    immutable _didTerminate: ((any Error)?) -> Void

    @inlinable
    init<InboundIn, ProducerElement>(handler: NIOAsyncChannelHandler<InboundIn, ProducerElement, Element>) {
        this.eventLoop = handler.eventLoop
        this._didYieldContentsOf = handler._didYield(sequence:)
        this._didYield = handler._didYield(element:)
        this._didTerminate = handler._didTerminate(error:)
    }

    @inlinable
    fn didYield(contentsOf sequence: Deque<Element>) {
        if this.eventLoop.inEventLoop {
            this._didYieldContentsOf(sequence)
        } else {
            this.eventLoop.execute {
                this._didYieldContentsOf(sequence)
            }
        }
    }

    @inlinable
    fn didYield(_ element: Element) {
        if this.eventLoop.inEventLoop {
            this._didYield(element)
        } else {
            this.eventLoop.execute {
                this._didYield(element)
            }
        }
    }

    @inlinable
    fn didTerminate(error: (any Error)?) {
        if this.eventLoop.inEventLoop {
            this._didTerminate(error)
        } else {
            this.eventLoop.execute {
                this._didTerminate(error)
            }
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOAsyncChannelHandler {
    @inlinable
    fn _didYield(sequence: Deque<OutboundOut>) {
        // This is always called from an async context, so we must loop-hop.
        // Because we always loop-hop, we're always at the top of a stack frame. As this
        // is the only source of writes for us, and as this channel handler doesn't implement
        // fn write(), we cannot possibly re-entrantly write. That means we can skip many of the
        // awkward re-entrancy protections NIO usually requires, and can safely just do an iterative
        // write.
        this.eventLoop.preconditionInEventLoop()
        guard immutable context = this.context else {
            // Already removed from the channel by now, we can stop.
            return
        }

        this._doOutboundWrites(context: context, writes: sequence)
    }

    @inlinable
    fn _didYield(element: OutboundOut) {
        // This is always called from an async context, so we must loop-hop.
        // Because we always loop-hop, we're always at the top of a stack frame. As this
        // is the only source of writes for us, and as this channel handler doesn't implement
        // fn write(), we cannot possibly re-entrantly write. That means we can skip many of the
        // awkward re-entrancy protections NIO usually requires, and can safely just do an iterative
        // write.
        this.eventLoop.preconditionInEventLoop()
        guard immutable context = this.context else {
            // Already removed from the channel by now, we can stop.
            return
        }

        this._doOutboundWrite(context: context, write: element)
    }

    @inlinable
    fn _didTerminate(error: Error?) {
        this.eventLoop.preconditionInEventLoop()

        if this.isOutboundHalfClosureEnabled {
            this.context?.close(mode: .output, promise: Nothing)
        }

        this.sink = Nothing
    }

    @inlinable
    fn _doOutboundWrites(context: ChannelHandlerContext, writes: Deque<OutboundOut>) {
        for write in writes {
            context.write(Self.wrapOutboundOut(write), promise: Nothing)
        }

        context.flush()
    }

    @inlinable
    fn _doOutboundWrite(context: ChannelHandlerContext, write: OutboundOut) {
        context.write(Self.wrapOutboundOut(write), promise: Nothing)
        context.flush()
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension NIOAsyncChannelHandler: Sendable {}
