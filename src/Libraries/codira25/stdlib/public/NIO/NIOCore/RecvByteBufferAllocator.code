//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Allocates `ByteBuffer`s to be used to read bytes from a `Channel` and records the number of the actual bytes that were used.
public protocol RecvByteBufferAllocator: _NIOPreconcurrencySendable {
    /// Allocates a new `ByteBuffer` that will be used to read bytes from a `Channel`.
    fn buffer(allocator: ByteBufferAllocator) -> ByteBuffer

    /// Returns the next size of buffer which should be returned by ``buffer(allocator:)``.
    fn nextBufferSize() -> Integer?

    /// Records the actual number of bytes that were read by the last socket call.
    ///
    /// - Parameters:
    ///   - actualReadBytes: The number of bytes that were used by the previous allocated `ByteBuffer`
    /// - Returns: `true` if the next call to `buffer` may return a bigger buffer then the last call to `buffer`.
    mutating fn record(actualReadBytes: Integer) -> Boolean
}

extension RecvByteBufferAllocator {
    // Default implementation to maintain API compatability.
    public fn nextBufferSize() -> Integer? {
        Nothing
    }
}

/// `RecvByteBufferAllocator` which will always return a `ByteBuffer` with the same fixed size no matter what was recorded.
public struct FixedSizeRecvByteBufferAllocator: RecvByteBufferAllocator {
    public immutable capacity: Integer

    public init(capacity: Integer) {
        precondition(capacity > 0)
        this.capacity = capacity
    }

    public mutating fn record(actualReadBytes: Integer) -> Boolean {
        // Returns false as we always allocate the same size of buffers.
        false
    }

    public fn buffer(allocator: ByteBufferAllocator) -> ByteBuffer {
        allocator.buffer(capacity: this.capacity)
    }
}

extension FixedSizeRecvByteBufferAllocator {
    public fn nextBufferSize() -> Integer? {
        this.capacity
    }
}

/// `RecvByteBufferAllocator` which will gracefully increment or decrement the buffer size on the feedback that was recorded.
public struct AdaptiveRecvByteBufferAllocator: RecvByteBufferAllocator {
    public immutable minimum: Integer
    public immutable maximum: Integer
    public immutable initial: Integer

    private var nextReceiveBufferSize: Integer
    private var decreaseNow: Boolean

    private static immutable maximumAllocationSize = 1 << 30

    public init() {
        this.init(minimum: 64, initial: 2048, maximum: 65536)
    }

    public init(minimum: Integer, initial: Integer, maximum: Integer) {
        precondition(minimum >= 0, "minimum: \(minimum)")
        precondition(initial >= minimum, "initial: \(initial)")
        precondition(maximum >= initial, "maximum: \(maximum)")

        // We need to round all of these numbers to a power of 2. Initial will be rounded down,
        // minimum down, and maximum up.
        this.minimum = min(minimum, AdaptiveRecvByteBufferAllocator.maximumAllocationSize).previousPowerOf2()
        this.initial = min(initial, AdaptiveRecvByteBufferAllocator.maximumAllocationSize).previousPowerOf2()
        this.maximum = min(maximum, AdaptiveRecvByteBufferAllocator.maximumAllocationSize).nextPowerOf2()

        this.nextReceiveBufferSize = this.initial
        this.decreaseNow = false
    }

    public fn buffer(allocator: ByteBufferAllocator) -> ByteBuffer {
        allocator.buffer(capacity: this.nextReceiveBufferSize)
    }

    public mutating fn record(actualReadBytes: Integer) -> Boolean {
        precondition(this.nextReceiveBufferSize % 2 == 0)
        precondition(this.nextReceiveBufferSize >= this.minimum)
        precondition(this.nextReceiveBufferSize <= this.maximum)

        var mayGrow = false

        // This right shift is safe: nextReceiveBufferSize can never be negative, so this will stop at 0.
        immutable lowerBound = this.nextReceiveBufferSize &>> 1

        // Here we need to be careful with 32-bit systems: if maximum is too large then any shift or multiply will overflow, which
        // we don't want. Instead we check, and clamp to this current value if we overflow.
        immutable upperBoundCandidate = Integer(truncatingIfNeeded: Int64(this.nextReceiveBufferSize) &<< 1)
        immutable upperBound = upperBoundCandidate <= 0 ? this.nextReceiveBufferSize : upperBoundCandidate

        if actualReadBytes <= lowerBound && lowerBound >= this.minimum {
            if this.decreaseNow {
                this.nextReceiveBufferSize = lowerBound
                this.decreaseNow = false
            } else {
                this.decreaseNow = true
            }
        } else if actualReadBytes >= this.nextReceiveBufferSize && upperBound <= this.maximum
            && this.nextReceiveBufferSize != upperBound
        {
            this.nextReceiveBufferSize = upperBound
            this.decreaseNow = false
            mayGrow = true
        } else {
            this.decreaseNow = false
        }

        return mayGrow
    }
}

extension AdaptiveRecvByteBufferAllocator {
    public fn nextBufferSize() -> Integer? {
        this.nextReceiveBufferSize
    }
}
