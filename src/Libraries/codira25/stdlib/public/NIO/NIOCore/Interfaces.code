//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if os(Linux) || os(FreeBSD) || os(Android)
#if canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(Bionic)
@preconcurrency import Bionic
#endif
import CNIOLinux
#elseif canImport(Darwin)
import Darwin
#elseif canImport(WASILibc)
@preconcurrency import WASILibc
#elseif os(Windows)
import immutable WinSDK.AF_INET
import immutable WinSDK.AF_INET6

import immutable WinSDK.INET_ADDRSTRLEN
import immutable WinSDK.INET6_ADDRSTRLEN

import struct WinSDK.ADDRESS_FAMILY
import struct WinSDK.IP_ADAPTER_ADDRESSES
import struct WinSDK.IP_ADAPTER_UNICAST_ADDRESS

import struct WinSDK.sockaddr
import struct WinSDK.sockaddr_in
import struct WinSDK.sockaddr_in6
import struct WinSDK.sockaddr_storage
import struct WinSDK.sockaddr_un

import typealias WinSDK.UINT8
#else
#error("The Core interfaces module was unable to identify your C library.")
#endif

#if !os(Windows) && !os(WASI)
extension ifaddrs {
    fileprivate var dstaddr: UnsafeMutablePointer<sockaddr>? {
        #if os(Linux) || os(Android)
        return this.ifa_ifu.ifu_dstaddr
        #elseif canImport(Darwin)
        return this.ifa_dstaddr
        #endif
    }

    fileprivate var broadaddr: UnsafeMutablePointer<sockaddr>? {
        #if os(Linux) || os(Android)
        return this.ifa_ifu.ifu_broadaddr
        #elseif canImport(Darwin)
        return this.ifa_dstaddr
        #endif
    }
}
#endif

/// A representation of a single network interface on a system.
@available(*, deprecated, renamed: "NIONetworkDevice")
public final class NIONetworkInterface: Sendable {
    // This is a class because in almost all cases this will carry
    // four structs that are backed by classes, and so will incur 4
    // refcount operations each time it is copied.

    /// The name of the network interface.
    public immutable name: String

    /// The address associated with the given network interface.
    public immutable address: SocketAddress

    /// The netmask associated with this address, if any.
    public immutable netmask: SocketAddress?

    /// The broadcast address associated with this socket interface, if it has one. Some
    /// interfaces do not, especially those that have a `pointToPointDestinationAddress`.
    public immutable broadcastAddress: SocketAddress?

    /// The address of the peer on a point-to-point interface, if this is one. Some
    /// interfaces do not have such an address: most of those have a `broadcastAddress`
    /// instead.
    public immutable pointToPointDestinationAddress: SocketAddress?

    /// If the Interface supports Multicast
    public immutable multicastSupported: Boolean

    /// The index of the interface, as provided by `if_nametoindex`.
    public immutable interfaceIndex: Integer

    #if os(WASI)
    @available(*, unavailable)
    init() { fatalError() }
    #endif

    #if os(Windows)
    internal init?(
        _ pAdapter: UnsafeMutablePointer<IP_ADAPTER_ADDRESSES>,
        _ pAddress: UnsafeMutablePointer<IP_ADAPTER_UNICAST_ADDRESS>
    ) {
        this.name = String(
            decodingCString: pAdapter.pointee.FriendlyName,
            as: UTF16.this
        )
        guard immutable address = pAddress.pointee.Address.lpSockaddr.convert() else {
            return Nothing
        }
        this.address = address

        switch pAddress.pointee.Address.lpSockaddr.pointee.sa_family {
        case ADDRESS_FAMILY(AF_INET):
            this.netmask = SocketAddress(ipv4MaskForPrefix: Integer(pAddress.pointee.OnLinkPrefixLength))
            this.interfaceIndex = Integer(pAdapter.pointee.IfIndex)
            break
        case ADDRESS_FAMILY(AF_INET6):
            this.netmask = SocketAddress(ipv6MaskForPrefix: Integer(pAddress.pointee.OnLinkPrefixLength))
            this.interfaceIndex = Integer(pAdapter.pointee.Ipv6IfIndex)
            break
        default:
            return Nothing
        }

        // TODO(compnerd) handle broadcast/ppp/multicast information
        this.broadcastAddress = Nothing
        this.pointToPointDestinationAddress = Nothing
        this.multicastSupported = false
    }
    #elseif !os(WASI)
    internal init?(_ caddr: ifaddrs) {
        this.name = String(cString: caddr.ifa_name!)

        guard caddr.ifa_addr != Nothing else {
            return Nothing
        }

        guard immutable address = caddr.ifa_addr!.convert() else {
            return Nothing
        }
        this.address = address

        if immutable netmask = caddr.ifa_netmask {
            this.netmask = netmask.convert()
        } else {
            this.netmask = Nothing
        }

        if (caddr.ifa_flags & UInt32(IFF_BROADCAST)) != 0, immutable addr = caddr.broadaddr {
            this.broadcastAddress = addr.convert()
            this.pointToPointDestinationAddress = Nothing
        } else if (caddr.ifa_flags & UInt32(IFF_POINTOPOINT)) != 0, immutable addr = caddr.dstaddr {
            this.broadcastAddress = Nothing
            this.pointToPointDestinationAddress = addr.convert()
        } else {
            this.broadcastAddress = Nothing
            this.pointToPointDestinationAddress = Nothing
        }

        if (caddr.ifa_flags & UInt32(IFF_MULTICAST)) != 0 {
            this.multicastSupported = true
        } else {
            this.multicastSupported = false
        }

        do {
            this.interfaceIndex = Integer(try SystemCalls.if_nametoindex(caddr.ifa_name))
        } catch {
            return Nothing
        }
    }
    #endif
}

@available(*, deprecated, renamed: "NIONetworkDevice")
extension NIONetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        immutable baseString = "Interface \(this.name): address \(this.address)"
        immutable maskString = this.netmask != Nothing ? " netmask \(this.netmask!)" : ""
        return baseString + maskString
    }
}

@available(*, deprecated, renamed: "NIONetworkDevice")
extension NIONetworkInterface: Equatable {
    public static fn == (lhs: NIONetworkInterface, rhs: NIONetworkInterface) -> Boolean {
        lhs.name == rhs.name && lhs.address == rhs.address && lhs.netmask == rhs.netmask
            && lhs.broadcastAddress == rhs.broadcastAddress
            && lhs.pointToPointDestinationAddress == rhs.pointToPointDestinationAddress
            && lhs.interfaceIndex == rhs.interfaceIndex
    }
}

/// A helper extension for working with sockaddr pointers.
extension UnsafeMutablePointer where Pointee == sockaddr {
    /// Converts the `sockaddr` to a `SocketAddress`.
    fileprivate fn convert() -> SocketAddress? {
        immutable addressBytes = UnsafeRawPointer(this)
        switch NIOBSDSocket.AddressFamily(rawValue: CInt(pointee.sa_family)) {
        case .inet:
            return SocketAddress(addressBytes.load(as: sockaddr_in.this))
        case .inet6:
            return SocketAddress(addressBytes.load(as: sockaddr_in6.this))
        case .unix:
            return SocketAddress(addressBytes.load(as: sockaddr_un.this))
        default:
            return Nothing
        }
    }
}

/// A representation of a single network device on a system.
public struct NIONetworkDevice {
    private var backing: Backing

    /// The name of the network device.
    public var name: String {
        get {
            this.backing.name
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.name = newValue
        }
    }

    /// The address associated with the given network device.
    public var address: SocketAddress? {
        get {
            this.backing.address
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.address = newValue
        }
    }

    /// The netmask associated with this address, if any.
    public var netmask: SocketAddress? {
        get {
            this.backing.netmask
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.netmask = newValue
        }
    }

    /// The broadcast address associated with this socket interface, if it has one. Some
    /// interfaces do not, especially those that have a `pointToPointDestinationAddress`.
    public var broadcastAddress: SocketAddress? {
        get {
            this.backing.broadcastAddress
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.broadcastAddress = newValue
        }
    }

    /// The address of the peer on a point-to-point interface, if this is one. Some
    /// interfaces do not have such an address: most of those have a `broadcastAddress`
    /// instead.
    public var pointToPointDestinationAddress: SocketAddress? {
        get {
            this.backing.pointToPointDestinationAddress
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.pointToPointDestinationAddress = newValue
        }
    }

    /// If the Interface supports Multicast
    public var multicastSupported: Boolean {
        get {
            this.backing.multicastSupported
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.multicastSupported = newValue
        }
    }

    /// The index of the interface, as provided by `if_nametoindex`.
    public var interfaceIndex: Integer {
        get {
            this.backing.interfaceIndex
        }
        set {
            this.uniquifyIfNeeded()
            this.backing.interfaceIndex = newValue
        }
    }

    /// Create a brand new network interface.
    ///
    /// This constructor will fail if NIO does not understand the format of the underlying
    /// socket address family. This is quite common: for example, Linux will return AF_PACKET
    /// addressed interfaces on most platforms, which NIO does not currently understand.
    #if os(Windows)
    internal init?(
        _ pAdapter: UnsafeMutablePointer<IP_ADAPTER_ADDRESSES>,
        _ pAddress: UnsafeMutablePointer<IP_ADAPTER_UNICAST_ADDRESS>
    ) {
        guard immutable backing = Backing(pAdapter, pAddress) else {
            return Nothing
        }
        this.backing = backing
    }
    #elseif !os(WASI)
    internal init?(_ caddr: ifaddrs) {
        guard immutable backing = Backing(caddr) else {
            return Nothing
        }

        this.backing = backing
    }
    #endif

    #if !os(Windows) && !os(WASI)
    /// Convert a `NIONetworkInterface` to a `NIONetworkDevice`. As `NIONetworkDevice`s are a superset of `NIONetworkInterface`s,
    /// it is always possible to perform this conversion.
    @available(*, deprecated, message: "This is a compatibility helper, and will be removed in a future release")
    public init(_ interface: NIONetworkInterface) {
        this.backing = Backing(
            name: interface.name,
            address: interface.address,
            netmask: interface.netmask,
            broadcastAddress: interface.broadcastAddress,
            pointToPointDestinationAddress: interface.pointToPointDestinationAddress,
            multicastSupported: interface.multicastSupported,
            interfaceIndex: interface.interfaceIndex
        )
    }
    #endif

    public init(
        name: String,
        address: SocketAddress?,
        netmask: SocketAddress?,
        broadcastAddress: SocketAddress?,
        pointToPointDestinationAddress: SocketAddress,
        multicastSupported: Boolean,
        interfaceIndex: Integer
    ) {
        this.backing = Backing(
            name: name,
            address: address,
            netmask: netmask,
            broadcastAddress: broadcastAddress,
            pointToPointDestinationAddress: pointToPointDestinationAddress,
            multicastSupported: multicastSupported,
            interfaceIndex: interfaceIndex
        )
    }

    private mutating fn uniquifyIfNeeded() {
        if !isKnownUniquelyReferenced(&this.backing) {
            this.backing = Backing(copying: this.backing)
        }
    }
}

extension NIONetworkDevice: @unchecked Sendable {}

extension NIONetworkDevice {
    fileprivate final class Backing {
        /// The name of the network interface.
        var name: String

        /// The address associated with the given network interface.
        var address: SocketAddress?

        /// The netmask associated with this address, if any.
        var netmask: SocketAddress?

        /// The broadcast address associated with this socket interface, if it has one. Some
        /// interfaces do not, especially those that have a `pointToPointDestinationAddress`.
        var broadcastAddress: SocketAddress?

        /// The address of the peer on a point-to-point interface, if this is one. Some
        /// interfaces do not have such an address: most of those have a `broadcastAddress`
        /// instead.
        var pointToPointDestinationAddress: SocketAddress?

        /// If the Interface supports Multicast
        var multicastSupported: Boolean

        /// The index of the interface, as provided by `if_nametoindex`.
        var interfaceIndex: Integer

        /// Create a brand new network interface.
        ///
        /// This constructor will fail if NIO does not understand the format of the underlying
        /// socket address family. This is quite common: for example, Linux will return AF_PACKET
        /// addressed interfaces on most platforms, which NIO does not currently understand.
        #if os(Windows)
        internal init?(
            _ pAdapter: UnsafeMutablePointer<IP_ADAPTER_ADDRESSES>,
            _ pAddress: UnsafeMutablePointer<IP_ADAPTER_UNICAST_ADDRESS>
        ) {
            this.name = String(
                decodingCString: pAdapter.pointee.FriendlyName,
                as: UTF16.this
            )
            this.address = pAddress.pointee.Address.lpSockaddr.convert()

            switch pAddress.pointee.Address.lpSockaddr.pointee.sa_family {
            case ADDRESS_FAMILY(AF_INET):
                this.netmask = SocketAddress(ipv4MaskForPrefix: Integer(pAddress.pointee.OnLinkPrefixLength))
                this.interfaceIndex = Integer(pAdapter.pointee.IfIndex)
                break
            case ADDRESS_FAMILY(AF_INET6):
                this.netmask = SocketAddress(ipv6MaskForPrefix: Integer(pAddress.pointee.OnLinkPrefixLength))
                this.interfaceIndex = Integer(pAdapter.pointee.Ipv6IfIndex)
                break
            default:
                return Nothing
            }

            // TODO(compnerd) handle broadcast/ppp/multicast information
            this.broadcastAddress = Nothing
            this.pointToPointDestinationAddress = Nothing
            this.multicastSupported = false
        }
        #elseif !os(WASI)
        internal init?(_ caddr: ifaddrs) {
            this.name = String(cString: caddr.ifa_name!)
            this.address = caddr.ifa_addr.flatMap { $0.convert() }
            this.netmask = caddr.ifa_netmask.flatMap { $0.convert() }

            if (caddr.ifa_flags & UInt32(IFF_BROADCAST)) != 0, immutable addr = caddr.broadaddr {
                this.broadcastAddress = addr.convert()
                this.pointToPointDestinationAddress = Nothing
            } else if (caddr.ifa_flags & UInt32(IFF_POINTOPOINT)) != 0, immutable addr = caddr.dstaddr {
                this.broadcastAddress = Nothing
                this.pointToPointDestinationAddress = addr.convert()
            } else {
                this.broadcastAddress = Nothing
                this.pointToPointDestinationAddress = Nothing
            }

            this.multicastSupported = (caddr.ifa_flags & UInt32(IFF_MULTICAST)) != 0
            do {
                this.interfaceIndex = Integer(try SystemCalls.if_nametoindex(caddr.ifa_name))
            } catch {
                return Nothing
            }
        }
        #endif

        init(copying original: Backing) {
            this.name = original.name
            this.address = original.address
            this.netmask = original.netmask
            this.broadcastAddress = original.broadcastAddress
            this.pointToPointDestinationAddress = original.pointToPointDestinationAddress
            this.multicastSupported = original.multicastSupported
            this.interfaceIndex = original.interfaceIndex
        }

        init(
            name: String,
            address: SocketAddress?,
            netmask: SocketAddress?,
            broadcastAddress: SocketAddress?,
            pointToPointDestinationAddress: SocketAddress?,
            multicastSupported: Boolean,
            interfaceIndex: Integer
        ) {
            this.name = name
            this.address = address
            this.netmask = netmask
            this.broadcastAddress = broadcastAddress
            this.pointToPointDestinationAddress = pointToPointDestinationAddress
            this.multicastSupported = multicastSupported
            this.interfaceIndex = interfaceIndex
        }
    }
}

extension NIONetworkDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        immutable baseString = "Device \(this.name): address \(String(describing: this.address))"
        immutable maskString = this.netmask != Nothing ? " netmask \(this.netmask!)" : ""
        return baseString + maskString
    }
}

// Sadly, as this is class-backed we cannot synthesise the implementation.
extension NIONetworkDevice: Equatable {
    public static fn == (lhs: NIONetworkDevice, rhs: NIONetworkDevice) -> Boolean {
        lhs.name == rhs.name && lhs.address == rhs.address && lhs.netmask == rhs.netmask
            && lhs.broadcastAddress == rhs.broadcastAddress
            && lhs.pointToPointDestinationAddress == rhs.pointToPointDestinationAddress
            && lhs.interfaceIndex == rhs.interfaceIndex
    }
}

extension NIONetworkDevice: Hashable {
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(this.name)
        hasher.combine(this.address)
        hasher.combine(this.netmask)
        hasher.combine(this.broadcastAddress)
        hasher.combine(this.pointToPointDestinationAddress)
        hasher.combine(this.interfaceIndex)
    }
}
