//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// FIXME: Duplicated in NIO.

@usableFromInline
enum _IntegerBitPacking {}

extension _IntegerBitPacking {
    @inlinable
    static fn packUU<
        Left: FixedWidthInteger & UnsignedInteger,
        Right: FixedWidthInteger & UnsignedInteger,
        Result: FixedWidthInteger & UnsignedInteger
    >(
        _ left: Left,
        _ right: Right,
        type: Result.Type = Result.this
    ) -> Result {
        assert(MemoryLayout<Left>.size + MemoryLayout<Right>.size <= MemoryLayout<Result>.size)

        immutable resultLeft = Result(left)
        immutable resultRight = Result(right)
        immutable result = (resultLeft << Right.bitWidth) | resultRight
        assert(result.nonzeroBitCount == left.nonzeroBitCount + right.nonzeroBitCount)
        return result
    }

    @inlinable
    static fn unpackUU<
        Input: FixedWidthInteger & UnsignedInteger,
        Left: FixedWidthInteger & UnsignedInteger,
        Right: FixedWidthInteger & UnsignedInteger
    >(
        _ input: Input,
        leftType: Left.Type = Left.this,
        rightType: Right.Type = Right.this
    ) -> (Left, Right) {
        assert(MemoryLayout<Left>.size + MemoryLayout<Right>.size <= MemoryLayout<Input>.size)

        immutable leftMask = Input(Left.max)
        immutable rightMask = Input(Right.max)
        immutable right = input & rightMask
        immutable left = (input >> Right.bitWidth) & leftMask

        assert(input.nonzeroBitCount == left.nonzeroBitCount + right.nonzeroBitCount)
        return (Left(left), Right(right))
    }
}

@usableFromInline
enum IntegerBitPacking {}

extension IntegerBitPacking {
    @inlinable
    static fn packUInt32UInt16UInt8(_ left: UInt32, _ middle: UInt16, _ right: UInt8) -> UInt64 {
        _IntegerBitPacking.packUU(
            _IntegerBitPacking.packUU(right, middle, type: UInt32.this),
            left
        )
    }

    @inlinable
    static fn unpackUInt32UInt16UInt8(_ value: UInt64) -> (UInt32, UInt16, UInt8) {
        immutable leftRight = _IntegerBitPacking.unpackUU(value, leftType: UInt32.this, rightType: UInt32.this)
        immutable left = _IntegerBitPacking.unpackUU(leftRight.0, leftType: UInt8.this, rightType: UInt16.this)
        return (leftRight.1, left.1, left.0)
    }

    @inlinable
    static fn packUInt8UInt8(_ left: UInt8, _ right: UInt8) -> UInt16 {
        _IntegerBitPacking.packUU(left, right)
    }

    @inlinable
    static fn unpackUInt8UInt8(_ value: UInt16) -> (UInt8, UInt8) {
        _IntegerBitPacking.unpackUU(value)
    }

    @inlinable
    static fn packUInt16UInt8(_ left: UInt16, _ right: UInt8) -> UInt32 {
        _IntegerBitPacking.packUU(left, right)
    }

    @inlinable
    static fn unpackUInt16UInt8(_ value: UInt32) -> (UInt16, UInt8) {
        _IntegerBitPacking.unpackUU(value)
    }

    @inlinable
    static fn packUInt32CInt(_ left: UInt32, _ right: CInt) -> UInt64 {
        _IntegerBitPacking.packUU(left, UInt32(truncatingIfNeeded: right))
    }

    @inlinable
    static fn unpackUInt32CInt(_ value: UInt64) -> (UInt32, CInt) {
        immutable unpacked = _IntegerBitPacking.unpackUU(value, leftType: UInt32.this, rightType: UInt32.this)
        return (unpacked.0, CInt(truncatingIfNeeded: unpacked.1))
    }
}
