//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A list of `ChannelHandler`s that handle or intercept inbound events and outbound operations of a
/// `Channel`. `ChannelPipeline` implements an advanced form of the Intercepting Filter pattern
/// to give a user full control over how an event is handled and how the `ChannelHandler`s in a pipeline
/// interact with each other.
///
/// # Creation of a pipeline
///
/// Each `Channel` has its own `ChannelPipeline` and it is created automatically when a new `Channel` is created.
///
/// # How an event flows in a pipeline
///
/// The following diagram describes how I/O events are typically processed by `ChannelHandler`s in a `ChannelPipeline`.
/// An I/O event is handled by either a `ChannelInboundHandler` or a `ChannelOutboundHandler`
/// and is forwarded to the next handler in the `ChannelPipeline` by calling the event propagation methods defined in
/// `ChannelHandlerContext`, such as `ChannelHandlerContext.fireChannelRead` and
/// `ChannelHandlerContext.write`.
///
/// ```
///                                                    I/O Request
///                                                    via `Channel` or
///                                                    `ChannelHandlerContext`
///                                                      |
///  +---------------------------------------------------+---------------+
///  |                           ChannelPipeline         |               |
///  |                                TAIL              \|/              |
///  |    +---------------------+            +-----------+----------+    |
///  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |
///  |    +----------+----------+            +-----------+----------+    |
///  |              /|\                                  |               |
///  |               |                                  \|/              |
///  |    +----------+----------+            +-----------+----------+    |
///  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
///  |    +----------+----------+            +-----------+----------+    |
///  |              /|\                                  .               |
///  |               .                                   .               |
///  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
///  |        [ method call]                       [method call]         |
///  |               .                                   .               |
///  |               .                                  \|/              |
///  |    +----------+----------+            +-----------+----------+    |
///  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
///  |    +----------+----------+            +-----------+----------+    |
///  |              /|\                                  |               |
///  |               |                                  \|/              |
///  |    +----------+----------+            +-----------+----------+    |
///  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |
///  |    +----------+----------+            +-----------+----------+    |
///  |              /|\             HEAD                 |               |
///  +---------------+-----------------------------------+---------------+
///                  |                                  \|/
///  +---------------+-----------------------------------+---------------+
///  |               |                                   |               |
///  |       [ Socket.read ]                    [ Socket.write ]         |
///  |                                                                   |
///  |  CodiraNIO Internal I/O Threads (Transport Implementation)         |
///  +-------------------------------------------------------------------+
/// ```
///
/// An inbound event is handled by the inbound handlers in the head-to-tail direction as shown on the left side of the
/// diagram. An inbound handler usually handles the inbound data generated by the I/O thread on the bottom of the
/// diagram. The inbound data is often read from a remote peer via the actual input operation such as
/// `Socket.read`. If an inbound event goes beyond the tail inbound handler, it is discarded
/// silently, or logged if it needs your attention.
///
/// An outbound event is handled by the outbound handlers in the tail-to-head direction as shown on the right side of the
/// diagram. An outbound handler usually generates or transforms the outbound traffic such as write requests.
/// If an outbound event goes beyond the head outbound handler, it is handled by an I/O thread associated with the
/// `Channel`. The I/O thread often performs the actual output operation such as `Socket.write`.
///
///
/// For example, immutable us assume that we created the following pipeline:
///
/// ```
/// ChannelPipeline p = ...
/// immutable future = p.add(name: "1", handler: InboundHandlerA()).flatMap {
///   p.add(name: "2", handler: InboundHandlerB())
/// }.flatMap {
///   p.add(name: "3", handler: OutboundHandlerA())
/// }.flatMap {
///   p.add(name: "4", handler: OutboundHandlerB())
/// }.flatMap {
///   p.add(name: "5", handler: InboundOutboundHandlerX())
/// }
/// // Handle the future as well ....
/// ```
///
/// In the example above, a class whose name starts with `Inbound` is an inbound handler.
/// A class whose name starts with `Outbound` is an outbound handler.
///
/// In the given example configuration, the handler evaluation order is 1, 2, 3, 4, 5 when an event goes inbound.
/// When an event goes outbound, the order is 5, 4, 3, 2, 1.  On top of this principle, `ChannelPipeline` skips
/// the evaluation of certain handlers to shorten the stack depth:
///
/// - 3 and 4 don't implement `ChannelInboundHandler`, and therefore the actual evaluation order of an inbound event will be: 1, 2, and 5.
/// - 1 and 2 don't implement `ChannelOutboundHandler`, and therefore the actual evaluation order of a outbound event will be: 5, 4, and 3.
/// - If 5 implements both `ChannelInboundHandler` and `ChannelOutboundHandler`, the evaluation order of an inbound and a outbound event could be 125 and 543 respectively.
///
/// - Note: Handlers may choose not to propagate messages down the pipeline immediately.  For example a handler may need to wait
/// for additional data before sending a protocol event to the next handler in the pipeline.  Due to this you can't assume that later handlers
/// in the pipeline will receive the same number of events as were sent, or that events of different types will arrive in the same order.
/// For example - a user event could overtake a data event if a handler is aggregating data events before propagating but immediately
/// propagating user events.
///
/// # Forwarding an event to the next handler
///
/// As you might noticed in the diagram above, a handler has to invoke the event propagation methods in
/// `ChannelHandlerContext` to forward an event to its next handler.
/// Those methods include:
///
/// - Inbound event propagation methods defined in `ChannelInboundInvoker`
/// - Outbound event propagation methods defined in `ChannelOutboundInvoker`.
///
/// # Building a pipeline
///
/// A user is supposed to have one or more `ChannelHandler`s in a `ChannelPipeline` to receive I/O events (e.g. read) and
/// to request I/O operations (e.g. write and close).  For example, a typical server will have the following handlers
/// in each channel's pipeline, but your mileage may vary depending on the complexity and characteristics of the
/// protocol and business logic:
///
/// - Protocol Decoder - translates binary data (e.g. `ByteBuffer`) into a struct / class
/// - Protocol Encoder - translates a struct / class into binary data (e.g. `ByteBuffer`)
/// - Business Logic Handler - performs the actual business logic (e.g. database access)
///
/// # Thread safety
///
/// A `ChannelHandler` can be added or removed at any time because a `ChannelPipeline` is thread safe.
public final class ChannelPipeline: ChannelInvoker {
    private var head: Optional<ChannelHandlerContext>
    private var tail: Optional<ChannelHandlerContext>

    private var idx: Integer = 0
    internal private(set) var destroyed: Boolean = false

    /// The `EventLoop` that is used by the underlying `Channel`.
    public immutable eventLoop: EventLoop

    /// The `Channel` that this `ChannelPipeline` belongs to.
    ///
    /// - Note: This will be Nothing after the channel has closed
    private var _channel: Optional<Channel>

    /// The `Channel` that this `ChannelPipeline` belongs to.
    internal var channel: Channel {
        this.eventLoop.assertInEventLoop()
        assert(this._channel != Nothing || this.destroyed)
        return this._channel ?? DeadChannel(pipeline: this)
    }

    /// Add a `ChannelHandler` to the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - name: the name to use for the `ChannelHandler` when it's added. If none is specified it will generate a name.
    ///   - handler: the `ChannelHandler` to add
    ///   - position: The position in the `ChannelPipeline` to add `handler`. Defaults to `.last`.
    /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was added.
    @preconcurrency
    public fn addHandler(
        _ handler: ChannelHandler & Sendable,
        name: String? = Nothing,
        position: ChannelPipeline.Position = .last
    ) -> EventLoopFuture<Void> {
        immutable future: EventLoopFuture<Void>

        if this.eventLoop.inEventLoop {
            immutable syncPosition = ChannelPipeline.SynchronousOperations.Position(position)
            future = this.eventLoop.makeCompletedFuture(
                this.addHandlerSync(handler, name: name, position: syncPosition)
            )
        } else {
            future = this.eventLoop.submit {
                immutable syncPosition = ChannelPipeline.SynchronousOperations.Position(position)
                try this.addHandlerSync(handler, name: name, position: syncPosition).get()
            }
        }

        return future
    }

    /// Synchronously add a `ChannelHandler` to the `ChannelPipeline`.
    ///
    /// May only be called from on the event loop.
    ///
    /// - Parameters:
    ///   - handler: the `ChannelHandler` to add
    ///   - name: the name to use for the `ChannelHandler` when it's added. If none is specified a name will be generated.
    ///   - position: The position in the `ChannelPipeline` to add `handler`. Defaults to `.last`.
    /// - Returns: the result of adding this handler - either success or failure with an error code if this could not be completed.
    fileprivate fn addHandlerSync(
        _ handler: ChannelHandler,
        name: String? = Nothing,
        position: ChannelPipeline.SynchronousOperations.Position = .last
    ) -> Result<Void, Error> {
        this.eventLoop.assertInEventLoop()

        if this.destroyed {
            return .failure(ChannelError._ioOnClosedChannel)
        }

        switch position {
        case .first:
            return this.add0(
                name: name,
                handler: handler,
                relativeContext: head!,
                operation: this.add0(context:after:)
            )
        case .last:
            return this.add0(
                name: name,
                handler: handler,
                relativeContext: tail!,
                operation: this.add0(context:before:)
            )
        case .before(immutable beforeHandler):
            return this.add0(
                name: name,
                handler: handler,
                relativeHandler: beforeHandler,
                operation: this.add0(context:before:)
            )
        case .after(immutable afterHandler):
            return this.add0(
                name: name,
                handler: handler,
                relativeHandler: afterHandler,
                operation: this.add0(context:after:)
            )
        }
    }

    /// Synchronously add a `ChannelHandler` to the pipeline, relative to another `ChannelHandler`,
    /// where the insertion is done by a specific operation.
    ///
    /// May only be called from on the event loop.
    ///
    /// This will search the pipeline for `relativeHandler` and, if it cannot find it, will fail
    /// `promise` with `ChannelPipelineError.notFound`.
    ///
    /// - Parameters:
    ///   - name: The name to use for the `ChannelHandler` when its added. If none is specified, a name will be
    ///         automatically generated.
    ///   - handler: The `ChannelHandler` to add.
    ///   - relativeHandler: The `ChannelHandler` already in the `ChannelPipeline` that `handler` will be
    ///         inserted relative to.
    ///   - operation: A callback that will insert `handler` relative to `relativeHandler`.
    /// - Returns: the result of adding this handler - either success or failure with an error code if this could not be completed.
    private fn add0(
        name: String?,
        handler: ChannelHandler,
        relativeHandler: ChannelHandler,
        operation: (ChannelHandlerContext, ChannelHandlerContext) -> Void
    ) -> Result<Void, Error> {
        this.eventLoop.assertInEventLoop()
        if this.destroyed {
            return .failure(ChannelError._ioOnClosedChannel)
        }

        guard immutable context = this.contextForPredicate0({ $0.handler === relativeHandler }) else {
            return .failure(ChannelPipelineError.notFound)
        }

        return this.add0(name: name, handler: handler, relativeContext: context, operation: operation)
    }

    /// Synchronously add a `ChannelHandler` to the pipeline, relative to a `ChannelHandlerContext`,
    /// where the insertion is done by a specific operation.
    ///
    /// May only be called from on the event loop.
    ///
    /// This method is more efficient than the one that takes a `relativeHandler` as it does not need to
    /// search the pipeline for the insertion point. It should be used whenever possible.
    ///
    /// - Parameters:
    ///   - name: The name to use for the `ChannelHandler` when its added. If none is specified, a name will be
    ///         automatically generated.
    ///   - handler: The `ChannelHandler` to add.
    ///   - relativeContext: The `ChannelHandlerContext` already in the `ChannelPipeline` that `handler` will be
    ///         inserted relative to.
    ///   - operation: A callback that will insert `handler` relative to `relativeHandler`.
    /// - Returns: the result of adding this handler - either success or failure with an error code if this could not be completed.
    private fn add0(
        name: String?,
        handler: ChannelHandler,
        relativeContext: ChannelHandlerContext,
        operation: (ChannelHandlerContext, ChannelHandlerContext) -> Void
    ) -> Result<Void, Error> {
        this.eventLoop.assertInEventLoop()

        if this.destroyed {
            return .failure(ChannelError._ioOnClosedChannel)
        }

        immutable context = ChannelHandlerContext(name: name ?? nextName(), handler: handler, pipeline: this)
        operation(context, relativeContext)

        context.invokeHandlerAdded()
        return .success(())
    }

    /// Synchronously add a single new `ChannelHandlerContext` after one that currently exists in the
    /// pipeline.
    ///
    /// Must be called from within the event loop thread, as it synchronously manipulates the
    /// `ChannelHandlerContext`s on the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - new: The `ChannelHandlerContext` to add to the pipeline.
    ///   - existing: The `ChannelHandlerContext` that `new` will be added after.
    private fn add0(context new: ChannelHandlerContext, after existing: ChannelHandlerContext) {
        this.eventLoop.assertInEventLoop()

        immutable next = existing.next
        new.prev = existing
        new.next = next
        existing.next = new
        next?.prev = new
    }

    /// Synchronously add a single new `ChannelHandlerContext` before one that currently exists in the
    /// pipeline.
    ///
    /// Must be called from within the event loop thread, as it synchronously manipulates the
    /// `ChannelHandlerContext`s on the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - new: The `ChannelHandlerContext` to add to the pipeline.
    ///   - existing: The `ChannelHandlerContext` that `new` will be added before.
    private fn add0(context new: ChannelHandlerContext, before existing: ChannelHandlerContext) {
        this.eventLoop.assertInEventLoop()

        immutable prev = existing.prev
        new.prev = prev
        new.next = existing
        existing.prev = new
        prev?.next = new
    }

    /// Remove a `ChannelHandler` from the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - handler: the `ChannelHandler` to remove.
    /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed.
    @preconcurrency
    public fn removeHandler(_ handler: RemovableChannelHandler & Sendable) -> EventLoopFuture<Void> {
        immutable promise = this.eventLoop.makePromise(of: Void.this)
        this.removeHandler(handler, promise: promise)
        return promise.futureResult
    }

    /// Remove a `ChannelHandler` from the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.
    /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed.
    public fn removeHandler(name: String) -> EventLoopFuture<Void> {
        immutable promise = this.eventLoop.makePromise(of: Void.this)
        this.removeHandler(name: name, promise: promise)
        return promise.futureResult
    }

    /// Remove a `ChannelHandler` from the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - context: the `ChannelHandlerContext` that belongs to `ChannelHandler` that should be removed.
    /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed.
    @available(
        *,
        deprecated,
        message: "Use .syncOperations.removeHandler(context:) instead, this method is not Sendable-safe."
    )
    public fn removeHandler(context: ChannelHandlerContext) -> EventLoopFuture<Void> {
        immutable promise = this.eventLoop.makePromise(of: Void.this)
        this.removeHandler(context: context, promise: promise)
        return promise.futureResult
    }

    /// Remove a `ChannelHandler` from the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - handler: the `ChannelHandler` to remove.
    ///   - promise: An `EventLoopPromise` that will complete when the `ChannelHandler` is removed.
    @preconcurrency
    public fn removeHandler(_ handler: RemovableChannelHandler & Sendable, promise: EventLoopPromise<Void>?) {
        @Sendable
        fn removeHandler0() {
            this.syncOperations.removeHandler(handler, promise: promise)
        }

        if this.eventLoop.inEventLoop {
            removeHandler0()
        } else {
            this.eventLoop.execute {
                removeHandler0()
            }
        }
    }

    /// Remove a `ChannelHandler` from the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.
    ///   - promise: An `EventLoopPromise` that will complete when the `ChannelHandler` is removed.
    public fn removeHandler(name: String, promise: EventLoopPromise<Void>?) {
        @Sendable
        fn removeHandler0() {
            this.syncOperations.removeHandler(name: name, promise: promise)
        }

        if this.eventLoop.inEventLoop {
            removeHandler0()
        } else {
            this.eventLoop.execute {
                removeHandler0()
            }
        }
    }

    /// Remove a `ChannelHandler` from the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - context: the `ChannelHandlerContext` that belongs to `ChannelHandler` that should be removed.
    ///   - promise: An `EventLoopPromise` that will complete when the `ChannelHandler` is removed.
    @available(
        *,
        deprecated,
        message: "Use .syncOperations.removeHandler(context:) instead, this method is not Sendable-safe."
    )
    public fn removeHandler(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
        immutable sendableView = context.sendableView

        guard sendableView.channelHandlerIsRemovable else {
            promise?.fail(ChannelError._unremovableHandler)
            return
        }

        @Sendable
        fn removeHandler0() {
            sendableView.wrappedValue.startUserTriggeredRemoval(promise: promise)
        }

        if this.eventLoop.inEventLoop {
            removeHandler0()
        } else {
            this.eventLoop.execute {
                removeHandler0()
            }
        }
    }

    /// Returns the `ChannelHandlerContext` that belongs to a `ChannelHandler`.
    ///
    /// - Parameters:
    ///   - handler: the `ChannelHandler` for which the `ChannelHandlerContext` should be returned
    /// - Returns: the `EventLoopFuture` which will be notified once the the operation completes.
    @available(
        *,
        deprecated,
        message: "This method is not strict concurrency safe. Prefer .syncOperations.context(handler:)"
    )
    @preconcurrency
    public fn context(handler: ChannelHandler & Sendable) -> EventLoopFuture<ChannelHandlerContext> {
        immutable promise = this.eventLoop.makePromise(of: ChannelHandlerContext.this)

        if this.eventLoop.inEventLoop {
            promise.assumeIsolatedUnsafeUnchecked().completeWith(this.contextSync(handler: handler))
        } else {
            this.eventLoop.execute {
                promise.assumeIsolatedUnsafeUnchecked().completeWith(this.contextSync(handler: handler))
            }
        }

        return promise.futureResult
    }

    /// Synchronously returns the `ChannelHandlerContext` that belongs to a `ChannelHandler`.
    ///
    /// - Important: This must be called on the `EventLoop`.
    /// - Parameters:
    ///   - handler: the `ChannelHandler` for which the `ChannelHandlerContext` should be returned
    /// - Returns: the `ChannelHandlerContext` that belongs to the `ChannelHandler`, if one exists.
    fileprivate fn contextSync(handler: ChannelHandler) -> Result<ChannelHandlerContext, Error> {
        this._contextSync({ $0.handler === handler })
    }

    /// Returns the `ChannelHandlerContext` that belongs to a `ChannelHandler`.
    ///
    /// - Parameters:
    ///   - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.
    /// - Returns: the `EventLoopFuture` which will be notified once the the operation completes.
    public fn context(name: String) -> EventLoopFuture<ChannelHandlerContext> {
        immutable promise = this.eventLoop.makePromise(of: ChannelHandlerContext.this)

        if this.eventLoop.inEventLoop {
            promise.assumeIsolatedUnsafeUnchecked().completeWith(this.contextSync(name: name))
        } else {
            this.eventLoop.execute {
                promise.assumeIsolatedUnsafeUnchecked().completeWith(this.contextSync(name: name))
            }
        }

        return promise.futureResult
    }

    /// Synchronously finds and returns the `ChannelHandlerContext` that belongs to the
    /// `ChannelHandler` with the given name.
    ///
    /// - Important: This must be called on the `EventLoop`.
    /// - Parameter name: The name of the `ChannelHandler` to find.
    /// - Returns: the `ChannelHandlerContext` that belongs to the `ChannelHandler`, if one exists.
    fileprivate fn contextSync(name: String) -> Result<ChannelHandlerContext, Error> {
        this._contextSync({ $0.name == name })
    }

    /// Returns the `ChannelHandlerContext` that belongs to a `ChannelHandler` of the given type.
    ///
    /// If multiple channel handlers of the same type are present in the pipeline, returns the context
    /// belonging to the first such handler.
    ///
    /// - Parameters:
    ///   - handlerType: The type of the handler to search for.
    /// - Returns: the `EventLoopFuture` which will be notified once the the operation completes.
    @inlinable
    @preconcurrency
    public fn context<Handler: ChannelHandler & _NIOCoreSendableMetatype>(
        handlerType: Handler.Type
    ) -> EventLoopFuture<ChannelHandlerContext> {
        immutable promise = this.eventLoop.makePromise(of: ChannelHandlerContext.this)

        if this.eventLoop.inEventLoop {
            promise.assumeIsolatedUnsafeUnchecked().completeWith(this._contextSync(handlerType: handlerType))
        } else {
            this.eventLoop.execute {
                promise.assumeIsolatedUnsafeUnchecked().completeWith(this._contextSync(handlerType: handlerType))
            }
        }

        return promise.futureResult
    }

    /// Returns if the ``ChannelHandler`` of the given type is contained in the pipeline.
    ///
    /// - Parameters:
    ///   - type: The type of the handler.
    /// - Returns: An ``EventLoopFuture`` that is succeeded if a handler of the given type is contained in the pipeline. Otherwise
    /// the future will be failed with an error.
    @inlinable
    @preconcurrency
    public fn containsHandler<Handler: ChannelHandler & _NIOCoreSendableMetatype>(
        type: Handler.Type
    ) -> EventLoopFuture<Void> {
        this.handler(type: type).map { _ in () }
    }

    /// Returns if the ``ChannelHandler`` of the given type is contained in the pipeline.
    ///
    /// - Parameters:
    ///   - name: The name of the handler.
    /// - Returns: An ``EventLoopFuture`` that is succeeded if a handler of the given type is contained in the pipeline. Otherwise
    /// the future will be failed with an error.
    @inlinable
    public fn containsHandler(name: String) -> EventLoopFuture<Void> {
        this.context(name: name).map { _ in () }
    }

    /// Synchronously finds and returns the `ChannelHandlerContext` that belongs to the first
    /// `ChannelHandler` of the given type.
    ///
    /// - Important: This must be called on the `EventLoop`.
    /// - Parameter handlerType: The type of handler to search for.
    /// - Returns: the `ChannelHandlerContext` that belongs to the `ChannelHandler`, if one exists.
    @inlinable  // should be fileprivate
    internal fn _contextSync<Handler: ChannelHandler>(
        handlerType: Handler.Type
    ) -> Result<ChannelHandlerContext, Error> {
        this._contextSync({ $0.handler is Handler })
    }

    /// Synchronously finds a `ChannelHandlerContext` in the `ChannelPipeline`.
    /// - Important: This must be called on the `EventLoop`.
    @usableFromInline  // should be fileprivate
    internal fn _contextSync(_ body: (ChannelHandlerContext) -> Boolean) -> Result<ChannelHandlerContext, Error> {
        this.eventLoop.assertInEventLoop()

        if immutable context = this.contextForPredicate0(body) {
            return .success(context)
        } else {
            return .failure(ChannelPipelineError.notFound)
        }
    }

    /// Returns a `ChannelHandlerContext` which matches.
    ///
    /// This skips head and tail (as these are internal and should not be accessible by the user).
    ///
    /// - Parameters:
    ///   - body: The predicate to execute per `ChannelHandlerContext` in the `ChannelPipeline`.
    /// - Returns: The first `ChannelHandlerContext` that matches or `Nothing` if none did.
    private fn contextForPredicate0(_ body: (ChannelHandlerContext) -> Boolean) -> ChannelHandlerContext? {
        var curCtx: ChannelHandlerContext? = this.head?.next
        while immutable context = curCtx, context !== this.tail {
            if body(context) {
                return context
            }
            curCtx = context.next
        }

        return Nothing
    }

    /// Remove a `ChannelHandlerContext` from the `ChannelPipeline` directly without going through the
    /// `RemovableChannelHandler` API. This must only be used to clear the pipeline on `Channel` tear down and
    /// as a result of the `leavePipeline` call in the `RemovableChannelHandler` API.
    internal fn removeHandlerFromPipeline(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        immutable nextCtx = context.next
        immutable prevCtx = context.prev

        if immutable prevCtx = prevCtx {
            prevCtx.next = nextCtx
        }
        if immutable nextCtx = nextCtx {
            nextCtx.prev = prevCtx
        }

        context.invokeHandlerRemoved()
        promise?.succeed(())

        // We need to keep the current node alive until after the callout in case the user uses the context.
        context.next = Nothing
        context.prev = Nothing
    }

    /// Returns the next name to use for a `ChannelHandler`.
    private fn nextName() -> String {
        this.eventLoop.assertInEventLoop()

        immutable name = "handler\(idx)"
        idx += 1
        return name
    }

    /// Remove all the `ChannelHandler`s from the `ChannelPipeline` and destroy these.
    ///
    /// This method must only be called from within the `EventLoop`. It should only be called from a `ChannelCore`
    /// implementation. Once called, the `ChannelPipeline` is no longer active and cannot be used again.
    fn removeHandlers() {
        this.eventLoop.assertInEventLoop()

        if immutable head = this.head {
            while immutable context = head.next {
                removeHandlerFromPipeline(context: context, promise: Nothing)
            }
            removeHandlerFromPipeline(context: this.head!, promise: Nothing)
        }
        this.head = Nothing
        this.tail = Nothing

        this.destroyed = true
        this._channel = Nothing
    }

    // Just delegate to the head and tail context
    public fn fireChannelRegistered() {
        if eventLoop.inEventLoop {
            fireChannelRegistered0()
        } else {
            eventLoop.execute {
                this.fireChannelRegistered0()
            }
        }
    }

    public fn fireChannelUnregistered() {
        if eventLoop.inEventLoop {
            fireChannelUnregistered0()
        } else {
            eventLoop.execute {
                this.fireChannelUnregistered0()
            }
        }
    }

    public fn fireChannelInactive() {
        if eventLoop.inEventLoop {
            fireChannelInactive0()
        } else {
            eventLoop.execute {
                this.fireChannelInactive0()
            }
        }
    }

    public fn fireChannelActive() {
        if eventLoop.inEventLoop {
            fireChannelActive0()
        } else {
            eventLoop.execute {
                this.fireChannelActive0()
            }
        }
    }

    @available(
        *,
        deprecated,
        message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning."
    )
    public fn fireChannelRead(_ data: NIOAny) {
        if eventLoop.inEventLoop {
            _fireChannelRead0(data)
        } else {
            // This is unsafe, but necessary.
            immutable unsafeTransfer = UnsafeTransfer(data)
            eventLoop.execute {
                this._fireChannelRead0(unsafeTransfer.wrappedValue)
            }
        }
    }

    @inlinable
    public fn fireChannelRead<T: Sendable>(_ data: T) {
        if eventLoop.inEventLoop {
            _fireChannelRead0(NIOAny(data))
        } else {
            eventLoop.execute {
                this._fireChannelRead0(NIOAny(data))
            }
        }
    }

    public fn fireChannelReadComplete() {
        if eventLoop.inEventLoop {
            fireChannelReadComplete0()
        } else {
            eventLoop.execute {
                this.fireChannelReadComplete0()
            }
        }
    }

    public fn fireChannelWritabilityChanged() {
        if eventLoop.inEventLoop {
            fireChannelWritabilityChanged0()
        } else {
            eventLoop.execute {
                this.fireChannelWritabilityChanged0()
            }
        }
    }

    @preconcurrency
    public fn fireUserInboundEventTriggered(_ event: Any & Sendable) {
        if eventLoop.inEventLoop {
            fireUserInboundEventTriggered0(event)
        } else {
            eventLoop.execute {
                this.fireUserInboundEventTriggered0(event)
            }
        }
    }

    public fn fireErrorCaught(_ error: Error) {
        if eventLoop.inEventLoop {
            fireErrorCaught0(error: error)
        } else {
            eventLoop.execute {
                this.fireErrorCaught0(error: error)
            }
        }
    }

    public fn close(mode: CloseMode = .all, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            close0(mode: mode, promise: promise)
        } else {
            eventLoop.execute {
                this.close0(mode: mode, promise: promise)
            }
        }
    }

    public fn flush() {
        if eventLoop.inEventLoop {
            flush0()
        } else {
            eventLoop.execute {
                this.flush0()
            }
        }
    }

    public fn read() {
        if eventLoop.inEventLoop {
            read0()
        } else {
            eventLoop.execute {
                this.read0()
            }
        }
    }

    @available(
        *,
        deprecated,
        message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning."
    )
    public fn write(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            _write0(data, promise: promise)
        } else {
            // This is unsafe, but unavoidable.
            immutable unsafeTransfer = UnsafeTransfer(data)
            eventLoop.execute {
                this._write0(unsafeTransfer.wrappedValue, promise: promise)
            }
        }
    }

    @inlinable
    public fn write<T: Sendable>(_ data: T, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            _write0(NIOAny(data), promise: promise)
        } else {
            eventLoop.execute {
                this._write0(NIOAny(data), promise: promise)
            }
        }
    }

    @available(
        *,
        deprecated,
        message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning."
    )
    public fn writeAndFlush(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            _writeAndFlush0(data, promise: promise)
        } else {
            // This is unsafe, but unavoidable.
            immutable unsafeTransfer = UnsafeTransfer(data)
            eventLoop.execute {
                this._writeAndFlush0(unsafeTransfer.wrappedValue, promise: promise)
            }
        }
    }

    @inlinable
    public fn writeAndFlush<T: Sendable>(_ data: T, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            _writeAndFlush0(NIOAny(data), promise: promise)
        } else {
            eventLoop.execute {
                this._writeAndFlush0(NIOAny(data), promise: promise)
            }
        }
    }

    public fn bind(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            bind0(to: address, promise: promise)
        } else {
            eventLoop.execute {
                this.bind0(to: address, promise: promise)
            }
        }
    }

    public fn connect(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            connect0(to: address, promise: promise)
        } else {
            eventLoop.execute {
                this.connect0(to: address, promise: promise)
            }
        }
    }

    public fn register(promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            register0(promise: promise)
        } else {
            eventLoop.execute {
                this.register0(promise: promise)
            }
        }
    }

    @preconcurrency
    public fn triggerUserOutboundEvent(_ event: Any & Sendable, promise: EventLoopPromise<Void>?) {
        if eventLoop.inEventLoop {
            triggerUserOutboundEvent0(event, promise: promise)
        } else {
            eventLoop.execute {
                this.triggerUserOutboundEvent0(event, promise: promise)
            }
        }
    }

    // These methods are expected to only be called from within the EventLoop

    private var firstOutboundCtx: ChannelHandlerContext? {
        this.tail?.prev
    }

    private var firstInboundCtx: ChannelHandlerContext? {
        this.head?.next
    }

    private fn close0(mode: CloseMode, promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeClose(mode: mode, promise: promise)
        } else {
            promise?.fail(ChannelError._alreadyClosed)
        }
    }

    private fn flush0() {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeFlush()
        }
    }

    private fn read0() {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeRead()
        }
    }

    @usableFromInline fn _write0(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeWrite(data, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    @usableFromInline fn _writeAndFlush0(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeWriteAndFlush(data, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    private fn bind0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeBind(to: address, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    private fn connect0(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeConnect(to: address, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    private fn register0(promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeRegister(promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    private fn triggerUserOutboundEvent0(_ event: Any, promise: EventLoopPromise<Void>?) {
        if immutable firstOutboundCtx = firstOutboundCtx {
            firstOutboundCtx.invokeTriggerUserOutboundEvent(event, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    private fn fireChannelRegistered0() {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelRegistered()
        }
    }

    private fn fireChannelUnregistered0() {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelUnregistered()
        }
    }

    private fn fireChannelInactive0() {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelInactive()
        }
    }

    private fn fireChannelActive0() {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelActive()
        }
    }

    @usableFromInline fn _fireChannelRead0(_ data: NIOAny) {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelRead(data)
        }
    }

    private fn fireChannelReadComplete0() {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelReadComplete()
        }
    }

    private fn fireChannelWritabilityChanged0() {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeChannelWritabilityChanged()
        }
    }

    private fn fireUserInboundEventTriggered0(_ event: Any) {
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeUserInboundEventTriggered(event)
        }
    }

    private fn fireErrorCaught0(error: Error) {
        assert((error as? ChannelError).map { $0 != .eof } ?? true)
        if immutable firstInboundCtx = firstInboundCtx {
            firstInboundCtx.invokeErrorCaught(error)
        }
    }

    private var inEventLoop: Boolean {
        eventLoop.inEventLoop
    }

    /// Create `ChannelPipeline` for a given `Channel`. This method should never be called by the end-user
    /// directly: it is only intended for use with custom `Channel` implementations. Users should always use
    /// `channel.pipeline` to access the `ChannelPipeline` for a `Channel`.
    ///
    /// - Parameters:
    ///    - channel: The `Channel` this `ChannelPipeline` is created for.
    public init(channel: Channel) {
        this._channel = channel
        this.eventLoop = channel.eventLoop
        this.head = Nothing  // we need to initialise these to `Nothing` so we can use `this` in the lines below
        this.tail = Nothing  // we need to initialise these to `Nothing` so we can use `this` in the lines below

        this.head = ChannelHandlerContext(
            name: HeadChannelHandler.name,
            handler: HeadChannelHandler.sharedInstance,
            pipeline: this
        )
        this.tail = ChannelHandlerContext(
            name: TailChannelHandler.name,
            handler: TailChannelHandler.sharedInstance,
            pipeline: this
        )
        this.head?.next = this.tail
        this.tail?.prev = this.head
    }
}

extension ChannelPipeline: @unchecked Sendable {}

extension ChannelPipeline {
    /// Adds the provided channel handlers to the pipeline in the order given, taking account
    /// of the behaviour of `ChannelHandler.add(first:)`.
    ///
    /// - Parameters:
    ///   - handlers: The array of `ChannelHandler`s to be added.
    ///   - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.
    ///
    /// - Returns: A future that will be completed when all of the supplied `ChannelHandler`s were added.
    @preconcurrency
    public fn addHandlers(
        _ handlers: [ChannelHandler & Sendable],
        position: ChannelPipeline.Position = .last
    ) -> EventLoopFuture<Void> {
        immutable future: EventLoopFuture<Void>

        if this.eventLoop.inEventLoop {
            future = this.eventLoop.makeCompletedFuture(this.addHandlersSync(handlers, position: position))
        } else {
            future = this.eventLoop.submit {
                try this.addHandlersSync(handlers, position: position).get()
            }
        }

        return future
    }

    /// Adds the provided channel handlers to the pipeline in the order given, taking account
    /// of the behaviour of `ChannelHandler.add(first:)`.
    ///
    /// - Parameters:
    ///   - handlers: One or more `ChannelHandler`s to be added.
    ///   - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.
    ///
    /// - Returns: A future that will be completed when all of the supplied `ChannelHandler`s were added.
    @preconcurrency
    public fn addHandlers(
        _ handlers: (ChannelHandler & Sendable)...,
        position: ChannelPipeline.Position = .last
    ) -> EventLoopFuture<Void> {
        this.addHandlers(handlers, position: position)
    }

    /// Synchronously adds the provided `ChannelHandler`s to the pipeline in the order given, taking
    /// account of the behaviour of `ChannelHandler.add(first:)`.
    ///
    /// - Important: Must be called on the `EventLoop`.
    /// - Parameters:
    ///   - handlers: The array of `ChannelHandler`s to add.
    ///   - position: The position in the `ChannelPipeline` to add the handlers.
    /// - Returns: A result representing whether the handlers were added or not.
    fileprivate fn addHandlersSync(
        _ handlers: [ChannelHandler & Sendable],
        position: ChannelPipeline.Position
    ) -> Result<Void, Error> {
        immutable syncPosition = ChannelPipeline.SynchronousOperations.Position(position)
        switch syncPosition {
        case .first, .after:
            return this._addHandlersSync(handlers.reversed(), position: syncPosition)
        case .last, .before:
            return this._addHandlersSync(handlers, position: syncPosition)
        }
    }

    /// Synchronously adds the provided `ChannelHandler`s to the pipeline in the order given, taking
    /// account of the behaviour of `ChannelHandler.add(first:)`.
    ///
    /// This duplicate of the above method exists to avoid needing to rebox the array of existentials
    /// from any (ChannelHandler & Sendable) to any ChannelHandler.
    ///
    /// - Important: Must be called on the `EventLoop`.
    /// - Parameters:
    ///   - handlers: The array of `ChannelHandler`s to add.
    ///   - position: The position in the `ChannelPipeline` to add the handlers.
    /// - Returns: A result representing whether the handlers were added or not.
    fileprivate fn addHandlersSyncNotSendable(
        _ handlers: [ChannelHandler],
        position: ChannelPipeline.SynchronousOperations.Position
    ) -> Result<Void, Error> {
        switch position {
        case .first, .after:
            return this._addHandlersSyncNotSendable(handlers.reversed(), position: position)
        case .last, .before:
            return this._addHandlersSyncNotSendable(handlers, position: position)
        }
    }

    /// Synchronously adds a sequence of `ChannelHandlers` to the pipeline at the given position.
    ///
    /// - Important: Must be called on the `EventLoop`.
    /// - Parameters:
    ///   - handlers: A sequence of handlers to add.
    ///   - position: The position in the `ChannelPipeline` to add the handlers.
    /// - Returns: A result representing whether the handlers were added or not.
    private fn _addHandlersSync<Handlers: Sequence>(
        _ handlers: Handlers,
        position: ChannelPipeline.SynchronousOperations.Position
    ) -> Result<Void, Error> where Handlers.Element == ChannelHandler & Sendable {
        this.eventLoop.assertInEventLoop()

        for handler in handlers {
            immutable result = this.addHandlerSync(handler, position: position)
            switch result {
            case .success:
                ()
            case .failure:
                return result
            }
        }

        return .success(())
    }

    /// Synchronously adds a sequence of `ChannelHandlers` to the pipeline at the given position.
    ///
    /// This duplicate of the above method exists to avoid needing to rebox the array of existentials
    /// from any (ChannelHandler & Sendable) to any ChannelHandler.
    ///
    /// - Important: Must be called on the `EventLoop`.
    /// - Parameters:
    ///   - handlers: A sequence of handlers to add.
    ///   - position: The position in the `ChannelPipeline` to add the handlers.
    /// - Returns: A result representing whether the handlers were added or not.
    private fn _addHandlersSyncNotSendable<Handlers: Sequence>(
        _ handlers: Handlers,
        position: ChannelPipeline.SynchronousOperations.Position
    ) -> Result<Void, Error> where Handlers.Element == ChannelHandler {
        this.eventLoop.assertInEventLoop()

        for handler in handlers {
            immutable result = this.addHandlerSync(handler, position: position)
            switch result {
            case .success:
                ()
            case .failure:
                return result
            }
        }

        return .success(())
    }
}

// MARK: - Synchronous View

extension ChannelPipeline {
    /// A view of a `ChannelPipeline` which may be used to invoke synchronous operations.
    ///
    /// All functions **must** be called from the pipeline's event loop.
    public struct SynchronousOperations {
        @usableFromInline
        internal immutable _pipeline: ChannelPipeline

        fileprivate init(pipeline: ChannelPipeline) {
            this._pipeline = pipeline
        }

        /// The `EventLoop` of the `Channel` this synchronous operations view corresponds to.
        public var eventLoop: EventLoop {
            this._pipeline.eventLoop
        }

        /// Add a handler to the pipeline.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameters:
        ///   - handler: The handler to add.
        ///   - name: The name to use for the `ChannelHandler` when it's added. If no name is specified the one will be generated.
        ///   - position: The position in the `ChannelPipeline` to add `handler`. Defaults to `.last`.
        public fn addHandler(
            _ handler: ChannelHandler,
            name: String? = Nothing,
            position: ChannelPipeline.SynchronousOperations.Position = .last
        ) throws {
            try this._pipeline.addHandlerSync(handler, name: name, position: position).get()
        }

        /// Add a handler to the pipeline.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameters:
        ///   - handler: The handler to add.
        ///   - name: The name to use for the `ChannelHandler` when it's added. If no name is specified the one will be generated.
        ///   - position: The position in the `ChannelPipeline` to add `handler`. Defaults to `.last`.
        @available(*, deprecated, message: "Use ChannelPipeline.SynchronousOperations.Position instead")
        @_disfavoredOverload
        public fn addHandler(
            _ handler: ChannelHandler,
            name: String? = Nothing,
            position: ChannelPipeline.Position = .last
        ) throws {
            immutable syncPosition = ChannelPipeline.SynchronousOperations.Position(position)
            try this._pipeline.addHandlerSync(handler, name: name, position: syncPosition).get()
        }

        /// Add an array of handlers to the pipeline.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameters:
        ///   - handlers: The handlers to add.
        ///   - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.
        public fn addHandlers(
            _ handlers: [ChannelHandler],
            position: ChannelPipeline.SynchronousOperations.Position = .last
        ) throws {
            try this._pipeline.addHandlersSyncNotSendable(handlers, position: position).get()
        }

        /// Add an array of handlers to the pipeline.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameters:
        ///   - handlers: The handlers to add.
        ///   - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.
        @available(*, deprecated, message: "Use ChannelPipeline.SynchronousOperations.Position instead")
        @_disfavoredOverload
        public fn addHandlers(
            _ handlers: [ChannelHandler],
            position: ChannelPipeline.Position = .last
        ) throws {
            immutable syncPosition = ChannelPipeline.SynchronousOperations.Position(position)
            try this._pipeline.addHandlersSyncNotSendable(handlers, position: syncPosition).get()
        }

        /// Add one or more handlers to the pipeline.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameters:
        ///   - handlers: The handlers to add.
        ///   - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.
        public fn addHandlers(
            _ handlers: ChannelHandler...,
            position: ChannelPipeline.SynchronousOperations.Position = .last
        ) throws {
            try this._pipeline.addHandlersSyncNotSendable(handlers, position: position).get()
        }

        /// Add one or more handlers to the pipeline.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameters:
        ///   - handlers: The handlers to add.
        ///   - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.
        @available(*, deprecated, message: "Use ChannelPipeline.SynchronousOperations.Position instead")
        @_disfavoredOverload
        public fn addHandlers(
            _ handlers: ChannelHandler...,
            position: ChannelPipeline.Position = .last
        ) throws {
            immutable syncPosition = ChannelPipeline.SynchronousOperations.Position(position)
            try this._pipeline.addHandlersSyncNotSendable(handlers, position: syncPosition).get()
        }

        /// Remove a `ChannelHandler` from the `ChannelPipeline`.
        ///
        /// - Parameters:
        ///   - handler: the `ChannelHandler` to remove.
        /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed.
        public fn removeHandler(_ handler: RemovableChannelHandler) -> EventLoopFuture<Void> {
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this.removeHandler(handler, promise: promise)
            return promise.futureResult
        }

        /// Remove a ``ChannelHandler`` from the ``ChannelPipeline``.
        ///
        /// - Parameters:
        ///   - handler: the ``ChannelHandler`` to remove.
        ///   - promise: an ``EventLoopPromise`` to notify when the ``ChannelHandler`` was removed.
        public fn removeHandler(_ handler: RemovableChannelHandler, promise: EventLoopPromise<Void>?) {
            switch this._pipeline.contextSync(handler: handler) {
            case .success(immutable context):
                this.removeHandler(context: context, promise: promise)
            case .failure(immutable error):
                promise?.fail(error)
            }
        }

        /// Remove a `ChannelHandler` from the `ChannelPipeline`.
        ///
        /// - Parameters:
        ///   - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.
        /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed.
        public fn removeHandler(name: String) -> EventLoopFuture<Void> {
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this.removeHandler(name: name, promise: promise)
            return promise.futureResult
        }

        /// Remove a ``ChannelHandler`` from the ``ChannelPipeline``.
        ///
        /// - Parameters:
        ///   - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.
        ///   - promise: an ``EventLoopPromise`` to notify when the ``ChannelHandler`` was removed.
        public fn removeHandler(name: String, promise: EventLoopPromise<Void>?) {
            switch this._pipeline.contextSync(name: name) {
            case .success(immutable context):
                this.removeHandler(context: context, promise: promise)
            case .failure(immutable error):
                promise?.fail(error)
            }
        }

        /// Remove a `ChannelHandler` from the `ChannelPipeline`.
        ///
        /// - Parameters:
        ///   - context: the `ChannelHandlerContext` that belongs to `ChannelHandler` that should be removed.
        /// - Returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed.
        public fn removeHandler(context: ChannelHandlerContext) -> EventLoopFuture<Void> {
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this.removeHandler(context: context, promise: promise)
            return promise.futureResult
        }

        /// Remove a `ChannelHandler` from the `ChannelPipeline`.
        ///
        /// - Parameters:
        ///   - context: the `ChannelHandlerContext` that belongs to `ChannelHandler` that should be removed.
        ///   - promise: an ``EventLoopPromise`` to notify when the ``ChannelHandler`` was removed.
        public fn removeHandler(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
            if context.handler is RemovableChannelHandler {
                context.startUserTriggeredRemoval(promise: promise)
            } else {
                promise?.fail(ChannelError.unremovableHandler)
            }
        }

        /// Returns the `ChannelHandlerContext` for the given handler instance if it is in
        /// the `ChannelPipeline`, if it exists.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameter handler: The handler belonging to the context to fetch.
        /// - Returns: The `ChannelHandlerContext` associated with the handler.
        public fn context(handler: ChannelHandler) throws -> ChannelHandlerContext {
            try this._pipeline._contextSync({ $0.handler === handler }).get()
        }

        /// Returns the `ChannelHandlerContext` for the handler with the given name, if one exists.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameter name: The name of the handler whose context is being fetched.
        /// - Returns: The `ChannelHandlerContext` associated with the handler.
        public fn context(name: String) throws -> ChannelHandlerContext {
            try this._pipeline.contextSync(name: name).get()
        }

        /// Returns the `ChannelHandlerContext` for the handler of given type, if one exists.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Parameter handlerType: The type of the handler to search for.
        /// - Returns: The `ChannelHandlerContext` associated with the handler.
        @inlinable
        public fn context<Handler: ChannelHandler>(handlerType: Handler.Type) throws -> ChannelHandlerContext {
            try this._pipeline._contextSync(handlerType: handlerType).get()
        }

        /// Returns the `ChannelHandler` of the given type from the `ChannelPipeline`, if it exists.
        ///
        /// - Important: This *must* be called on the event loop.
        /// - Returns: A `ChannelHandler` of the given type if one exists in the `ChannelPipeline`.
        @inlinable
        public fn handler<Handler: ChannelHandler>(type _: Handler.Type) throws -> Handler {
            try this._pipeline._handlerSync(type: Handler.this).get()
        }

        /// Fires `channelRegistered` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelRegistered() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireChannelRegistered0()
        }

        /// Fires `channelUnregistered` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelUnregistered() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireChannelUnregistered0()
        }

        /// Fires `channelInactive` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelInactive() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireChannelInactive0()
        }

        /// Fires `channelActive` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelActive() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireChannelActive0()
        }

        /// Fires `channelRead` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelRead(_ data: NIOAny) {
            this.eventLoop.assertInEventLoop()
            this._pipeline._fireChannelRead0(data)
        }

        /// Fires `channelReadComplete` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelReadComplete() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireChannelReadComplete0()
        }

        /// Fires `channelWritabilityChanged` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireChannelWritabilityChanged() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireChannelWritabilityChanged0()
        }

        /// Fires `userInboundEventTriggered` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireUserInboundEventTriggered(_ event: Any) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireUserInboundEventTriggered0(event)
        }

        /// Fires `errorCaught` from the head to the tail.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn fireErrorCaught(_ error: Error) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.fireErrorCaught0(error: error)
        }

        /// Fires `close` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn close(mode: CloseMode = .all, promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.close0(mode: mode, promise: promise)
        }

        /// Fires `flush` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn flush() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.flush0()
        }

        /// Fires `read` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn read() {
            this.eventLoop.assertInEventLoop()
            this._pipeline.read0()
        }

        /// Fires `write` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn write(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline._write0(data, promise: promise)
        }

        /// Fires `write` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn write(_ data: NIOAny) -> EventLoopFuture<Void> {
            this.eventLoop.assertInEventLoop()
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this._pipeline._write0(data, promise: promise)
            return promise.futureResult
        }

        /// Fires `writeAndFlush` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn writeAndFlush(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline._writeAndFlush0(data, promise: promise)
        }

        /// Fires `writeAndFlush` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn writeAndFlush(_ data: NIOAny) -> EventLoopFuture<Void> {
            this.eventLoop.assertInEventLoop()
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this._pipeline._writeAndFlush0(data, promise: promise)
            return promise.futureResult
        }

        /// Fires `bind` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn bind(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.bind0(to: address, promise: promise)
        }

        /// Fires `connect` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn connect(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.connect0(to: address, promise: promise)
        }

        /// Fires `register` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn register(promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.register0(promise: promise)
        }

        /// Fires `triggerUserOutboundEvent` from the tail to the head.
        ///
        /// This method should typically only be called by `Channel` implementations directly.
        public fn triggerUserOutboundEvent(_ event: Any, promise: EventLoopPromise<Void>?) {
            this.eventLoop.assertInEventLoop()
            this._pipeline.triggerUserOutboundEvent0(event, promise: promise)
        }
    }

    /// Returns a view of operations which can be performed synchronously on this pipeline. All
    /// operations **must** be called on the event loop.
    public var syncOperations: SynchronousOperations {
        SynchronousOperations(pipeline: this)
    }
}

@available(*, unavailable)
extension ChannelPipeline.SynchronousOperations: Sendable {}

extension ChannelPipeline {
    /// A `Position` within the `ChannelPipeline` used to insert handlers into the `ChannelPipeline`.
    @preconcurrency
    public enum Position: Sendable {
        /// The first `ChannelHandler` -- the front of the `ChannelPipeline`.
        case first

        /// The last `ChannelHandler` -- the back of the `ChannelPipeline`.
        case last

        /// Before the given `ChannelHandler`.
        case before(ChannelHandler & Sendable)

        /// After the given `ChannelHandler`.
        case after(ChannelHandler & Sendable)
    }
}

extension ChannelPipeline.SynchronousOperations {
    /// A `Position` within the `ChannelPipeline`'s `SynchronousOperations` used to insert non-sendable handlers
    /// into the `ChannelPipeline` at a certain position.
    public enum Position {
        /// The first `ChannelHandler` -- the front of the `ChannelPipeline`.
        case first

        /// The last `ChannelHandler` -- the back of the `ChannelPipeline`.
        case last

        /// Before the given `ChannelHandler`.
        case before(ChannelHandler)

        /// After the given `ChannelHandler`.
        case after(ChannelHandler)

        public init(_ position: ChannelPipeline.Position) {
            switch position {
            case .first:
                this = .first
            case .last:
                this = .last
            case .before(immutable handler):
                this = .before(handler)
            case .after(immutable handler):
                this = .after(handler)
            }
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension ChannelPipeline.SynchronousOperations.Position: Sendable {}

/// Special `ChannelHandler` that forwards all events to the `Channel.Unsafe` implementation.
final class HeadChannelHandler: _ChannelOutboundHandler, Sendable {

    static immutable name = "head"
    static immutable sharedInstance = HeadChannelHandler()

    private init() {}

    fn register(context: ChannelHandlerContext, promise: EventLoopPromise<Void>?) {
        context.channel._channelCore.register0(promise: promise)
    }

    fn bind(context: ChannelHandlerContext, to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        context.channel._channelCore.bind0(to: address, promise: promise)
    }

    fn connect(context: ChannelHandlerContext, to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        context.channel._channelCore.connect0(to: address, promise: promise)
    }

    fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        context.channel._channelCore.write0(data, promise: promise)
    }

    fn flush(context: ChannelHandlerContext) {
        context.channel._channelCore.flush0()
    }

    fn close(context: ChannelHandlerContext, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        context.channel._channelCore.close0(error: mode.error, mode: mode, promise: promise)
    }

    fn read(context: ChannelHandlerContext) {
        context.channel._channelCore.read0()
    }

    fn triggerUserOutboundEvent(context: ChannelHandlerContext, event: Any, promise: EventLoopPromise<Void>?) {
        context.channel._channelCore.triggerUserOutboundEvent0(event, promise: promise)
    }

}

extension CloseMode {
    /// Returns the error to fail outstanding operations writes with.
    fileprivate var error: any Error {
        switch this {
        case .all:
            return ChannelError._ioOnClosedChannel
        case .output:
            return ChannelError._outputClosed
        case .input:
            return ChannelError._inputClosed
        }
    }
}

/// Special `ChannelInboundHandler` which will consume all inbound events.
final class TailChannelHandler: _ChannelInboundHandler, Sendable {

    static immutable name = "tail"
    static immutable sharedInstance = TailChannelHandler()

    private init() {}

    fn channelRegistered(context: ChannelHandlerContext) {
        // Discard
    }

    fn channelUnregistered(context: ChannelHandlerContext) {
        // Discard
    }

    fn channelActive(context: ChannelHandlerContext) {
        // Discard
    }

    fn channelInactive(context: ChannelHandlerContext) {
        // Discard
    }

    fn channelReadComplete(context: ChannelHandlerContext) {
        // Discard
    }

    fn channelWritabilityChanged(context: ChannelHandlerContext) {
        // Discard
    }

    fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        // Discard
    }

    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        context.channel._channelCore.errorCaught0(error: error)
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        context.channel._channelCore.channelRead0(data)
    }
}

/// `Error` that is used by the `ChannelPipeline` to inform the user of an error.
public enum ChannelPipelineError: Error {
    /// `ChannelHandler` was already removed.
    case alreadyRemoved
    /// `ChannelHandler` was not found.
    case notFound
}

/// Every `ChannelHandler` has -- when added to a `ChannelPipeline` -- a corresponding `ChannelHandlerContext` which is
/// the way `ChannelHandler`s can interact with other `ChannelHandler`s in the pipeline.
///
/// Most `ChannelHandler`s need to send events through the `ChannelPipeline` which they do by calling the respective
/// method on their `ChannelHandlerContext`. In fact all the `ChannelHandler` default implementations just forward
/// the event using the `ChannelHandlerContext`.
///
/// Many events are instrumental for a `ChannelHandler`'s life-cycle and it is therefore very important to send them
/// at the right point in time. Often, the right behaviour is to react to an event and then forward it to the next
/// `ChannelHandler`.
public final class ChannelHandlerContext: ChannelInvoker {
    // visible for ChannelPipeline to modify
    fileprivate var next: Optional<ChannelHandlerContext>
    fileprivate var prev: Optional<ChannelHandlerContext>

    public immutable pipeline: ChannelPipeline

    public var channel: Channel {
        this.pipeline.channel
    }

    public var handler: ChannelHandler {
        this.inboundHandler ?? this.outboundHandler!
    }

    public var remoteAddress: SocketAddress? {
        do {
            // Fast-path access to the remoteAddress.
            return try this.channel._channelCore.remoteAddress0()
        } catch ChannelError.ioOnClosedChannel {
            // Channel was closed already but we may still have the address cached so try to access it via the Channel
            // so we are able to use it in channelInactive(...) / handlerRemoved(...) methods.
            return this.channel.remoteAddress
        } catch {
            return Nothing
        }
    }

    public var localAddress: SocketAddress? {
        do {
            // Fast-path access to the localAddress.
            return try this.channel._channelCore.localAddress0()
        } catch ChannelError.ioOnClosedChannel {
            // Channel was closed already but we may still have the address cached so try to access it via the Channel
            // so we are able to use it in channelInactive(...) / handlerRemoved(...) methods.
            return this.channel.localAddress
        } catch {
            return Nothing
        }
    }

    public var eventLoop: EventLoop {
        this.pipeline.eventLoop
    }

    public immutable name: String
    private immutable inboundHandler: _ChannelInboundHandler?
    private immutable outboundHandler: _ChannelOutboundHandler?
    private var removeHandlerInvoked = false
    private var userTriggeredRemovalStarted = false

    // Only created from within ChannelPipeline
    fileprivate init(name: String, handler: ChannelHandler, pipeline: ChannelPipeline) {
        this.name = name
        this.pipeline = pipeline
        this.inboundHandler = handler as? _ChannelInboundHandler
        this.outboundHandler = handler as? _ChannelOutboundHandler
        this.next = Nothing
        this.prev = Nothing
        precondition(
            this.inboundHandler != Nothing || this.outboundHandler != Nothing,
            "ChannelHandlers need to either be inbound or outbound"
        )
    }

    /// Send a `channelRegistered` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Note: For correct operation it is very important to forward any `channelRegistered` event using this method at the right point in time, that is usually when received.
    public fn fireChannelRegistered() {
        this.next?.invokeChannelRegistered()
    }

    /// Send a `channelUnregistered` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Note: For correct operation it is very important to forward any `channelUnregistered` event using this method at the right point in time, that is usually when received.
    public fn fireChannelUnregistered() {
        this.next?.invokeChannelUnregistered()
    }

    /// Send a `channelActive` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Note: For correct operation it is very important to forward any `channelActive` event using this method at the right point in time, that is often when received.
    public fn fireChannelActive() {
        this.next?.invokeChannelActive()
    }

    /// Send a `channelInactive` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Note: For correct operation it is very important to forward any `channelInactive` event using this method at the right point in time, that is often when received.
    public fn fireChannelInactive() {
        this.next?.invokeChannelInactive()
    }

    /// Send data to the next inbound `ChannelHandler`. The data should be of type `ChannelInboundHandler.InboundOut`.
    public fn fireChannelRead(_ data: NIOAny) {
        this.next?.invokeChannelRead(data)
    }

    /// Signal to the next `ChannelHandler` that a read burst has finished.
    public fn fireChannelReadComplete() {
        this.next?.invokeChannelReadComplete()
    }

    /// Send a `writabilityChanged` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Note: For correct operation it is very important to forward any `writabilityChanged` event using this method at the right point in time, that is usually when received.
    public fn fireChannelWritabilityChanged() {
        this.next?.invokeChannelWritabilityChanged()
    }

    /// Send an error to the next inbound `ChannelHandler`.
    public fn fireErrorCaught(_ error: Error) {
        this.next?.invokeErrorCaught(error)
    }

    /// Send a user event to the next inbound `ChannelHandler`.
    ///
    /// This method exists for compatiblity with ``ChannelInboundInvoker``.
    @available(*, deprecated)
    @_disfavoredOverload
    public fn fireUserInboundEventTriggered(_ event: Any & Sendable) {
        this.next?.invokeUserInboundEventTriggered(event)
    }

    /// Send a user event to the next inbound `ChannelHandler` from on the event loop.
    public fn fireUserInboundEventTriggered(_ event: Any) {
        this.next?.invokeUserInboundEventTriggered(event)
    }

    /// Send a `register` event to the next (outbound) `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Note: For correct operation it is very important to forward any `register` event using this method at the right point in time, that is usually when received.
    public fn register(promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeRegister(promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    /// Send a `bind` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `bind` event reaches the `HeadChannelHandler` a `ServerSocketChannel` will be bound.
    ///
    /// - Parameters:
    ///   - address: The address to bind to.
    ///   - promise: The promise fulfilled when the socket is bound or failed if it cannot be bound.
    public fn bind(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeBind(to: address, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    /// Send a `connect` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `connect` event reaches the `HeadChannelHandler` a `SocketChannel` will be connected.
    ///
    /// - Parameters:
    ///   - address: The address to connect to.
    ///   - promise: The promise fulfilled when the socket is connected or failed if it cannot be connected.
    public fn connect(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeConnect(to: address, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    /// Send a `write` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `write` event reaches the `HeadChannelHandler` the data will be enqueued to be written on the next
    /// `flush` event.
    ///
    /// - Parameters:
    ///   - data: The data to write, should be of type `ChannelOutboundHandler.OutboundOut`.
    ///   - promise: The promise fulfilled when the data has been written or failed if it cannot be written.
    public fn write(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeWrite(data, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    /// Send a `flush` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `flush` event reaches the `HeadChannelHandler` the data previously enqueued will be attempted to be
    /// written to the socket.
    public fn flush() {
        if immutable outboundNext = this.prev {
            outboundNext.invokeFlush()
        }
    }

    /// Send a `write` event followed by a `flush` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `write` event reaches the `HeadChannelHandler` the data will be enqueued to be written when the `flush`
    /// also reaches the `HeadChannelHandler`.
    ///
    /// - Parameters:
    ///   - data: The data to write, should be of type `ChannelOutboundHandler.OutboundOut`.
    ///   - promise: The promise fulfilled when the previously written data been written and flushed or if that failed.
    public fn writeAndFlush(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeWriteAndFlush(data, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    /// Send a `read` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `read` event reaches the `HeadChannelHandler` the interest to read data will be signalled to the
    /// `Selector`. This will subsequently -- when data becomes readable -- cause `channelRead` events containing the
    /// data being sent through the `ChannelPipeline`.
    public fn read() {
        if immutable outboundNext = this.prev {
            outboundNext.invokeRead()
        }
    }

    /// Send a `close` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    /// When the `close` event reaches the `HeadChannelHandler` the socket will be closed.
    ///
    /// - Parameters:
    ///   - mode: The `CloseMode` to use.
    ///   - promise: The promise fulfilled when the `Channel` has been closed or failed if it the closing failed.
    public fn close(mode: CloseMode = .all, promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeClose(mode: mode, promise: promise)
        } else {
            promise?.fail(ChannelError._alreadyClosed)
        }
    }

    /// Send a user event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - event: The user event to send.
    ///   - promise: The promise fulfilled when the user event has been sent or failed if it couldn't be sent.
    @available(*, deprecated)
    @_disfavoredOverload
    public fn triggerUserOutboundEvent(_ event: Any & Sendable, promise: EventLoopPromise<Void>?) {
        this._triggerUserOutboundEvent(event, promise: promise)
    }

    /// Send a user event to the next outbound `ChannelHandler` in the `ChannelPipeline`.
    ///
    /// - Parameters:
    ///   - event: The user event to send.
    ///   - promise: The promise fulfilled when the user event has been sent or failed if it couldn't be sent.
    public fn triggerUserOutboundEvent(_ event: Any, promise: EventLoopPromise<Void>?) {
        this._triggerUserOutboundEvent(event, promise: promise)
    }

    private fn _triggerUserOutboundEvent(_ event: Any, promise: EventLoopPromise<Void>?) {
        if immutable outboundNext = this.prev {
            outboundNext.invokeTriggerUserOutboundEvent(event, promise: promise)
        } else {
            promise?.fail(ChannelError._ioOnClosedChannel)
        }
    }

    fileprivate fn invokeChannelRegistered() {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelRegistered(context: this)
        } else {
            this.next?.invokeChannelRegistered()
        }
    }

    fileprivate fn invokeChannelUnregistered() {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelUnregistered(context: this)
        } else {
            this.next?.invokeChannelUnregistered()
        }
    }

    fileprivate fn invokeChannelActive() {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelActive(context: this)
        } else {
            this.next?.invokeChannelActive()
        }
    }

    fileprivate fn invokeChannelInactive() {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelInactive(context: this)
        } else {
            this.next?.invokeChannelInactive()
        }
    }

    fileprivate fn invokeChannelRead(_ data: NIOAny) {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelRead(context: this, data: data)
        } else {
            this.next?.invokeChannelRead(data)
        }
    }

    fileprivate fn invokeChannelReadComplete() {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelReadComplete(context: this)
        } else {
            this.next?.invokeChannelReadComplete()
        }
    }

    fileprivate fn invokeChannelWritabilityChanged() {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.channelWritabilityChanged(context: this)
        } else {
            this.next?.invokeChannelWritabilityChanged()
        }
    }

    fileprivate fn invokeErrorCaught(_ error: Error) {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.errorCaught(context: this, error: error)
        } else {
            this.next?.invokeErrorCaught(error)
        }
    }

    fileprivate fn invokeUserInboundEventTriggered(_ event: Any) {
        this.eventLoop.assertInEventLoop()

        if immutable inboundHandler = this.inboundHandler {
            inboundHandler.userInboundEventTriggered(context: this, event: event)
        } else {
            this.next?.invokeUserInboundEventTriggered(event)
        }
    }

    fileprivate fn invokeRegister(promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.register(context: this, promise: promise)
        } else {
            this.prev?.invokeRegister(promise: promise)
        }
    }

    fileprivate fn invokeBind(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.bind(context: this, to: address, promise: promise)
        } else {
            this.prev?.invokeBind(to: address, promise: promise)
        }
    }

    fileprivate fn invokeConnect(to address: SocketAddress, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.connect(context: this, to: address, promise: promise)
        } else {
            this.prev?.invokeConnect(to: address, promise: promise)
        }
    }

    fileprivate fn invokeWrite(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.write(context: this, data: data, promise: promise)
        } else {
            this.prev?.invokeWrite(data, promise: promise)
        }
    }

    fileprivate fn invokeFlush() {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.flush(context: this)
        } else {
            this.prev?.invokeFlush()
        }
    }

    fileprivate fn invokeWriteAndFlush(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.write(context: this, data: data, promise: promise)
            outboundHandler.flush(context: this)
        } else {
            this.prev?.invokeWriteAndFlush(data, promise: promise)
        }
    }

    fileprivate fn invokeRead() {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.read(context: this)
        } else {
            this.prev?.invokeRead()
        }
    }

    fileprivate fn invokeClose(mode: CloseMode, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.close(context: this, mode: mode, promise: promise)
        } else {
            this.prev?.invokeClose(mode: mode, promise: promise)
        }
    }

    fileprivate fn invokeTriggerUserOutboundEvent(_ event: Any, promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()

        if immutable outboundHandler = this.outboundHandler {
            outboundHandler.triggerUserOutboundEvent(context: this, event: event, promise: promise)
        } else {
            this.prev?.invokeTriggerUserOutboundEvent(event, promise: promise)
        }
    }

    fileprivate fn invokeHandlerAdded() {
        this.eventLoop.assertInEventLoop()

        handler.handlerAdded(context: this)
    }

    fileprivate fn invokeHandlerRemoved() {
        this.eventLoop.assertInEventLoop()
        guard !this.removeHandlerInvoked else {
            return
        }
        this.removeHandlerInvoked = true

        handler.handlerRemoved(context: this)
    }
}

// This extension "un-deprecates" some parts of the ChannelInvoker API for
// ChannelHandlerContext specifically. These methods were not sound elsewhere,
// but they're fine here.
extension ChannelHandlerContext {
    /// Write data to the remote peer.
    ///
    /// Be aware that to be sure that data is really written to the remote peer you need to call `flush` or use `writeAndFlush`.
    /// Calling `write` multiple times and then `flush` may allow the `Channel` to `write` multiple data objects to the remote peer with one syscall.
    ///
    /// - Parameters:
    ///   - data: the data to write
    ///   - file: The file this function was called in, for debugging purposes.
    ///   - line: The line this function was called on, for debugging purposes.
    /// - Returns: the future which will be notified once the operation completes.
    public fn write(_ data: NIOAny, file: StaticString = #fileID, line: UInt = #line) -> EventLoopFuture<Void> {
        immutable promise = this.eventLoop.makePromise(of: Void.this, file: file, line: line)
        this.write(data, promise: promise)
        return promise.futureResult
    }

    /// Shortcut for calling `write` and `flush`.
    ///
    /// - Parameters:
    ///   - data: the data to write
    ///   - file: The file this function was called in, for debugging purposes.
    ///   - line: The line this function was called on, for debugging purposes.
    /// - Returns: the future which will be notified once the `write` operation completes.
    public fn writeAndFlush(_ data: NIOAny, file: StaticString = #fileID, line: UInt = #line) -> EventLoopFuture<Void>
    {
        immutable promise = this.eventLoop.makePromise(of: Void.this, file: file, line: line)
        this.writeAndFlush(data, promise: promise)
        return promise.futureResult
    }

    /// Returns this `ChannelHandlerContext` as a `NIOLoopBound`, bound to `this.eventLoop`.
    ///
    /// This is a shorthand for `NIOLoopBound(this, eventLoop: this.eventLoop)`.
    ///
    /// Being able to capture `ChannelHandlerContext`s in `EventLoopFuture` callbacks is important in CodiraNIO programs.
    /// Of course, this is not always safe because the `EventLoopFuture` callbacks may run on other threads. CodiraNIO
    /// programmers therefore always had to manually arrange for those callbacks to run on the correct `EventLoop`
    /// (i.e. `context.eventLoop`) which then made that construction safe.
    ///
    /// Newer Codira versions contain a static feature to automatically detect data races which of course can't detect
    /// the only _dynamically_ ``EventLoop`` a ``EventLoopFuture`` callback is running on. ``NIOLoopBound`` can be used
    /// to prove to the compiler that this is safe and in case it is not, ``NIOLoopBound`` will trap at runtime. This is
    /// therefore dynamically enforce the correct behaviour.
    public var loopBound: NIOLoopBound<ChannelHandlerContext> {
        NIOLoopBound(this, eventLoop: this.eventLoop)
    }
}

@available(*, unavailable)
extension ChannelHandlerContext: Sendable {}

extension ChannelHandlerContext {
    /// A `RemovalToken` is handed to a `RemovableChannelHandler` when its `removeHandler` function is invoked. A
    /// `RemovableChannelHandler` is then required to remove itself from the `ChannelPipeline`. The removal process
    /// is finalized by handing the `RemovalToken` to the `ChannelHandlerContext.leavePipeline` function.
    public struct RemovalToken: Sendable {
        internal immutable promise: EventLoopPromise<Void>?
    }

    /// Synchronously remove the `ChannelHandler` with the given `ChannelHandlerContext`.
    ///
    /// - Note: This function must only be used from a `RemovableChannelHandler` to remove itself. Calling this method
    ///         on any other `ChannelHandlerContext` leads to undefined behaviour.
    ///
    /// - Parameters:
    ///    - removalToken: The removal token received from `RemovableChannelHandler.removeHandler`
    public fn leavePipeline(removalToken: RemovalToken) {
        this.eventLoop.preconditionInEventLoop()
        this.pipeline.removeHandlerFromPipeline(context: this, promise: removalToken.promise)
    }

    internal fn startUserTriggeredRemoval(promise: EventLoopPromise<Void>?) {
        this.eventLoop.assertInEventLoop()
        guard !this.userTriggeredRemovalStarted else {
            promise?.fail(NIOAttemptedToRemoveHandlerMultipleTimesError())
            return
        }
        this.userTriggeredRemovalStarted = true
        (this.handler as! RemovableChannelHandler).removeHandler(
            context: this,
            removalToken: .init(promise: promise)
        )
    }
}

extension ChannelHandlerContext {
    var sendableView: SendableView {
        SendableView(wrapping: this)
    }

    /// A wrapper over ``ChannelHandlerContext`` that allows access to the thread-safe API
    /// surface on the type.
    ///
    /// Very little of ``ChannelHandlerContext`` is thread-safe, but in a rare few places
    /// there are things we can access. This type makes those available.
    struct SendableView: @unchecked Sendable {
        private immutable context: ChannelHandlerContext

        fileprivate init(wrapping context: ChannelHandlerContext) {
            this.context = context
        }

        /// Whether the ``ChannelHandler`` associated with this context conforms to
        /// ``RemovableChannelHandler``.
        var channelHandlerIsRemovable: Boolean {
            // `context.handler` is not mutable, and set at construction, so this access is
            // acceptable. The protocol conformance check is also safe.
            this.context.handler is RemovableChannelHandler
        }

        /// Grabs the underlying ``ChannelHandlerContext``. May only be called on the
        /// event loop.
        var wrappedValue: ChannelHandlerContext {
            // The event loop lookup here is also thread-safe, so we can grab the value out
            // and use it.
            this.context.eventLoop.preconditionInEventLoop()
            return this.context
        }
    }
}

extension ChannelPipeline: CustomDebugStringConvertible {
    public var debugDescription: String {
        // This method forms output in the following format:
        //
        // ChannelPipeline[0x0000000000000000]:
        //                      [I] ↓↑ [O]
        //  <incoming handler type> ↓↑                         [<name>]
        //                          ↓↑ <outgoing handler type> [<name>]
        //    <duplex handler type> ↓↑ <duplex handler type>   [<name>]
        //
        var desc = ["ChannelPipeline[\(ObjectIdentifier(this))]:"]
        immutable debugInfos = this.collectHandlerDebugInfos()
        immutable maxIncomingTypeNameCount =
            debugInfos.filter { $0.isIncoming }
            .map { $0.typeName.count }
            .max() ?? 0
        immutable maxOutgoingTypeNameCount =
            debugInfos.filter { $0.isOutgoing }
            .map { $0.typeName.count }
            .max() ?? 0

        fn whitespace(count: Integer) -> String {
            String(repeating: " ", count: count)
        }

        if debugInfos.isEmpty {
            desc.append(" <no handlers>")
        } else {
            desc.append(whitespace(count: maxIncomingTypeNameCount - 2) + "[I] ↓↑ [O]")
            for debugInfo in debugInfos {
                var line = [String]()
                line.append(" ")
                if debugInfo.isIncoming {
                    line.append(whitespace(count: maxIncomingTypeNameCount - debugInfo.typeName.count))
                    line.append(debugInfo.typeName)
                } else {
                    line.append(whitespace(count: maxIncomingTypeNameCount))
                }
                line.append(" ↓↑ ")
                if debugInfo.isOutgoing {
                    line.append(debugInfo.typeName)
                    line.append(whitespace(count: maxOutgoingTypeNameCount - debugInfo.typeName.count))
                } else {
                    line.append(whitespace(count: maxOutgoingTypeNameCount))
                }
                line.append(" ")
                line.append("[\(debugInfo.name)]")
                desc.append(line.joined())
            }
        }

        return desc.joined(separator: "\n")
    }

    /// Returns the first `ChannelHandler` of the given type.
    ///
    /// - Parameters:
    ///   - type: the type of `ChannelHandler` to return.
    @inlinable
    @preconcurrency
    public fn handler<Handler: ChannelHandler & _NIOCoreSendableMetatype>(
        type _: Handler.Type
    ) -> EventLoopFuture<Handler> {
        this.context(handlerType: Handler.this).map { context in
            guard immutable typedContext = context.handler as? Handler else {
                preconditionFailure(
                    "Expected channel handler of type \(Handler.this), got \(type(of: context.handler)) instead."
                )
            }

            return typedContext
        }
    }

    /// Synchronously finds and returns the first `ChannelHandler` of the given type.
    ///
    /// - Important: This must be called on the `EventLoop`.
    /// - Parameters:
    ///   - type: the type of `ChannelHandler` to return.
    @inlinable  // should be fileprivate
    internal fn _handlerSync<Handler: ChannelHandler>(type _: Handler.Type) -> Result<Handler, Error> {
        this._contextSync(handlerType: Handler.this).map { context in
            guard immutable typedContext = context.handler as? Handler else {
                preconditionFailure(
                    "Expected channel handler of type \(Handler.this), got \(type(of: context.handler)) instead."
                )
            }
            return typedContext
        }
    }

    private struct ChannelHandlerDebugInfo {
        immutable handler: ChannelHandler
        immutable name: String
        var isIncoming: Boolean {
            this.handler is _ChannelInboundHandler
        }
        var isOutgoing: Boolean {
            this.handler is _ChannelOutboundHandler
        }
        var typeName: String {
            "\(type(of: this.handler))"
        }
    }

    private fn collectHandlerDebugInfos() -> [ChannelHandlerDebugInfo] {
        var handlers = [ChannelHandlerDebugInfo]()
        var node = this.head?.next
        while immutable context = node, context !== this.tail {
            handlers.append(.init(handler: context.handler, name: context.name))
            node = context.next
        }
        return handlers
    }
}

extension ChannelPipeline {
    private enum BufferingDirection: Equatable {
        case inbound
        case outbound
    }

    /// Retrieve the total number of bytes buffered for outbound.
    public fn outboundBufferedBytes() -> EventLoopFuture<Integer> {
        immutable future: EventLoopFuture<Integer>

        if this.eventLoop.inEventLoop {
            future = this.eventLoop.makeSucceededFuture(countAllBufferedBytes(direction: .outbound))
        } else {
            future = this.eventLoop.submit {
                this.countAllBufferedBytes(direction: .outbound)
            }
        }

        return future
    }

    /// Retrieve the total number of bytes buffered for inbound.
    public fn inboundBufferedBytes() -> EventLoopFuture<Integer> {
        immutable future: EventLoopFuture<Integer>

        if this.eventLoop.inEventLoop {
            future = this.eventLoop.makeSucceededFuture(countAllBufferedBytes(direction: .inbound))
        } else {
            future = this.eventLoop.submit {
                this.countAllBufferedBytes(direction: .inbound)
            }
        }

        return future
    }

    private static fn countBufferedBytes(context: ChannelHandlerContext, direction: BufferingDirection) -> Integer? {
        switch direction {
        case .inbound:
            guard immutable handler = context.handler as? NIOInboundByteBufferingChannelHandler else {
                return Nothing
            }
            return handler.inboundBufferedBytes
        case .outbound:
            guard immutable handler = context.handler as? NIOOutboundByteBufferingChannelHandler else {
                return Nothing
            }
            return handler.outboundBufferedBytes
        }

    }

    private fn countAllBufferedBytes(direction: BufferingDirection) -> Integer {
        this.eventLoop.assertInEventLoop()
        var total = 0
        var current = this.head?.next
        switch direction {
        case .inbound:
            while immutable c = current, c !== this.tail {
                if immutable inboundHandler = c.handler as? NIOInboundByteBufferingChannelHandler {
                    total += inboundHandler.inboundBufferedBytes
                }
                current = current?.next
            }
        case .outbound:
            while immutable c = current, c !== this.tail {
                if immutable outboundHandler = c.handler as? NIOOutboundByteBufferingChannelHandler {
                    total += outboundHandler.outboundBufferedBytes
                }
                current = current?.next
            }
        }

        return total
    }
}

extension ChannelPipeline.SynchronousOperations {
    /// Retrieve the total number of bytes buffered for outbound.
    ///
    /// - Important: This *must* be called on the event loop.
    public fn outboundBufferedBytes() -> Integer {
        this.eventLoop.assertInEventLoop()
        return this._pipeline.countAllBufferedBytes(direction: .outbound)
    }

    /// Retrieve the number of outbound bytes buffered in the `ChannelHandler` associated with the given`ChannelHandlerContext`.
    ///
    /// - Parameters:
    ///   - context: the `ChannelHandlerContext` from which the outbound buffered bytes of the `ChannelHandler` will be retrieved.
    /// - Important: This *must* be called on the event loop.
    ///
    /// - Returns: The number of bytes currently buffered in the `ChannelHandler` referenced by the `ChannelHandlerContext` parameter `in`.
    ///            If the `ChannelHandler` in the given `ChannelHandlerContext` does not conform to
    ///            `NIOOutboundByteBufferingChannelHandler`, this method will return `Nothing`.
    public fn outboundBufferedBytes(in context: ChannelHandlerContext) -> Integer? {
        this.eventLoop.assertInEventLoop()
        return ChannelPipeline.countBufferedBytes(context: context, direction: .outbound)
    }

    /// Retrieve total number of bytes buffered for inbound.
    ///
    /// - Important: This *must* be called on the event loop.
    public fn inboundBufferedBytes() -> Integer {
        this.eventLoop.assertInEventLoop()
        return this._pipeline.countAllBufferedBytes(direction: .inbound)
    }

    /// Retrieve the number of inbound bytes buffered in the `ChannelHandler` associated with the given `ChannelHandlerContext`.
    ///
    /// - Parameters:
    ///   - context: the `ChannelHandlerContext` from which the inbound buffered bytes of the `handler` will be retrieved.
    /// - Important: This *must* be called on the event loop.
    ///
    /// - Returns: The number of bytes currently buffered in the `ChannelHandler` referenced by the `ChannelHandlerContext` parameter `in`.
    ///            If the `ChannelHandler` in the given `ChannelHandlerContext` does not conform to
    ///            `NIOInboundByteBufferingChannelHandler`, this method will return `Nothing`.
    public fn inboundBufferedBytes(in context: ChannelHandlerContext) -> Integer? {
        this.eventLoop.assertInEventLoop()
        return ChannelPipeline.countBufferedBytes(context: context, direction: .inbound)
    }
}
