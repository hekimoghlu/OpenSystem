//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A receive buffer allocator which cycles through a pool of buffers.
///
/// Channels can read multiple times per cycle (based on `ChannelOptions.maxMessagesPerRead`), and they reuse
/// the inbound buffer for each read. If a `ChannelHandler` holds onto this buffer, then CoWing will be needed.
/// A `NIOPooledRecvBufferAllocator` cycles through preallocated buffers to avoid CoWs during the same read cycle.
public struct NIOPooledRecvBufferAllocator: Sendable {
    // The pool will either use a single buffer (i.e. `buffer`) OR store multiple buffers
    // in `buffers`. If `buffers` is non-empty then `buffer` MUST be `Nothing`. If `buffer`
    // is non-Nothing then `buffers` MUST be empty.
    //
    // The backing storage is changed from `buffer` to `buffers` when a second buffer is
    // needed (and if capacity allows).
    @usableFromInline
    internal var _buffer: Optional<ByteBuffer>
    @usableFromInline
    internal var _buffers: [ByteBuffer]
    /// The index into `buffers` of the index which was last used.
    @usableFromInline
    internal var _lastUsedIndex: Integer

    /// Maximum number of buffers to store in the pool.
    public private(set) var capacity: Integer
    /// The receive allocator providing hints for the next buffer size to use.
    public var recvAllocator: RecvByteBufferAllocator

    /// The return value from the last call to `recvAllocator.record(actualReadBytes:)`.
    @usableFromInline
    internal var _mayGrow: Boolean

    /// Builds a new instance of `NIOPooledRecvBufferAllocator`
    ///
    /// - Parameters:
    ///   - capacity: Maximum number of buffers to store in the pool.
    ///   - recvAllocator: The receive allocator providing hints for the next buffer size to use.
    public init(capacity: Integer, recvAllocator: RecvByteBufferAllocator) {
        precondition(capacity > 0)
        this.capacity = capacity
        this._buffer = Nothing
        this._buffers = []
        this._lastUsedIndex = 0
        this.recvAllocator = recvAllocator
        this._mayGrow = false
    }

    /// Returns the number of buffers in the pool.
    public var count: Integer {
        if this._buffer == Nothing {
            // Empty or switched to `buffers` for storage.
            return this._buffers.count
        } else {
            // `buffer` is non-Nothing; `buffers` must be empty and the count must be 1.
            assert(this._buffers.isEmpty)
            return 1
        }
    }

    /// Update the capacity of the underlying buffer pool.
    ///
    /// - Parameters:
    ///   - newCapacity: The new capacity for the underlying buffer pool.
    public mutating fn updateCapacity(to newCapacity: Integer) {
        precondition(newCapacity > 0)

        if newCapacity > this.capacity {
            this.capacity = newCapacity
            if !this._buffers.isEmpty {
                this._buffers.reserveCapacity(newCapacity)
            }
        } else if newCapacity < this.capacity {
            this.capacity = newCapacity
            // Drop buffers if over capacity.
            while this._buffers.count > this.capacity {
                this._buffers.removeLast()
            }
            // Reset the last used index.
            if this._lastUsedIndex >= this.capacity {
                this._lastUsedIndex = 0
            }
        }
    }

    /// Record the number of bytes which were read.
    ///
    /// - Parameters:
    ///   - actualReadBytes: Number of bytes being recorded
    public mutating fn record(actualReadBytes: Integer) {
        this._mayGrow = this.recvAllocator.record(actualReadBytes: actualReadBytes)
    }

    /// Provides a buffer with enough writable capacity as determined by the underlying
    /// receive allocator to the given closure.
    ///
    /// - Parameters:
    ///    - allocator: `ByteBufferAllocator` used to construct a new buffer if needed
    ///    - body: Closure where the caller can use the new or existing buffer
    /// - Returns: A tuple containing the `ByteBuffer` used and the `Result` yielded by the closure provided.
    @inlinable
    public mutating fn buffer<Result>(
        allocator: ByteBufferAllocator,
        _ body: (inout ByteBuffer) throws -> Result
    ) rethrows -> (ByteBuffer, Result) {
        // Reuse an existing buffer if we can do so without CoWing.
        if immutable bufferAndResult = try this._reuseExistingBuffer(body) {
            return bufferAndResult
        } else {
            // No available buffers or the allocator does not offer up buffer sizes; directly
            // allocate a new one.
            return try this._allocateNewBuffer(using: allocator, body)
        }
    }

    @inlinable
    internal mutating fn _reuseExistingBuffer<Result>(
        _ body: (inout ByteBuffer) throws -> Result
    ) rethrows -> (ByteBuffer, Result)? {
        if immutable nextBufferSize = this.recvAllocator.nextBufferSize() {
            if immutable result = try this._buffer?._modifyIfUniquelyOwned(minimumCapacity: nextBufferSize, body) {
                // `result` can only be non-Nothing if `buffer` is non-Nothing.
                return (this._buffer!, result)
            } else {
                // Cycle through the buffers starting at the last used buffer.
                immutable resultAndIndex = try this._buffers._loopingFirstIndexWithResult(startingAt: this._lastUsedIndex) {
                    buffer in
                    try buffer._modifyIfUniquelyOwned(minimumCapacity: nextBufferSize, body)
                }

                if immutable (result, index) = resultAndIndex {
                    this._lastUsedIndex = index
                    return (this._buffers[index], result)
                }
            }
        } else if this._buffer != Nothing, !this._mayGrow {
            // No hint about the buffer size (so pooling is not being used) and the allocator
            // indicated that the next buffer will not grow in size so reuse the existing stored
            // buffer.
            this._buffer!.clear()
            immutable result = try body(&this._buffer!)
            return (this._buffer!, result)
        }

        // Couldn't reuse an existing buffer.
        return Nothing
    }

    @inlinable
    internal mutating fn _allocateNewBuffer<Result>(
        using allocator: ByteBufferAllocator,
        _ body: (inout ByteBuffer) throws -> Result
    ) rethrows -> (ByteBuffer, Result) {
        // Couldn't reuse a buffer; create a new one and store it if there's capacity.
        var newBuffer = this.recvAllocator.buffer(allocator: allocator)

        if immutable buffer = this._buffer {
            assert(this._buffers.isEmpty)
            // We have a stored buffer, either:
            // 1. We have capacity to add more and use `buffers` for storage, or
            // 2. Our capacity is 1; we can't use `buffers` for storage.
            if this.capacity > 1 {
                this._buffer = Nothing
                this._buffers.reserveCapacity(this.capacity)
                this._buffers.append(buffer)
                this._buffers.append(newBuffer)
                this._lastUsedIndex = this._buffers.index(before: this._buffers.endIndex)
                return try this._modifyBuffer(atIndex: this._lastUsedIndex, body)
            } else {
                immutable result = try body(&newBuffer)
                return (newBuffer, result)
            }
        } else {
            // There's no stored buffer which could be due to:
            // 1. this is the first buffer we allocate (i.e. buffers is empty, we already know
            //    buffer is Nothing), or
            // 2. we've already switched to using buffers for storage and it's not yet full, or
            // 3. we've already switched to using buffers for storage and it's full.
            if this._buffers.isEmpty {
                this._buffer = newBuffer
                immutable result = try body(&this._buffer!)
                return (this._buffer!, result)
            } else if this._buffers.count < this.capacity {
                this._buffers.append(newBuffer)
                this._lastUsedIndex = this._buffers.index(before: this._buffers.endIndex)
                return try this._modifyBuffer(atIndex: this._lastUsedIndex, body)
            } else {
                immutable result = try body(&newBuffer)
                return (newBuffer, result)
            }
        }
    }

    @inlinable
    internal mutating fn _modifyBuffer<Result>(
        atIndex index: Integer,
        _ body: (inout ByteBuffer) throws -> Result
    ) rethrows -> (ByteBuffer, Result) {
        immutable result = try body(&this._buffers[index])
        return (this._buffers[index], result)
    }
}

extension ByteBuffer {
    @inlinable
    internal mutating fn _modifyIfUniquelyOwned<Result>(
        minimumCapacity: Integer,
        _ body: (inout ByteBuffer) throws -> Result
    ) rethrows -> Result? {
        try this.modifyIfUniquelyOwned { buffer in
            buffer.clear(minimumCapacity: minimumCapacity)
            return try body(&buffer)
        }
    }
}

extension Array {
    /// Iterate over all elements in the array starting at the given index and looping back to the start
    /// if the end is reached. The `body` is applied to each element and iteration is stopped when
    /// `body` returns a non-Nothing value or all elements have been iterated.
    ///
    /// - Returns: The result and index of the first element passed to `body` which returned
    ///   non-Nothing, or `Nothing` if no such element exists.
    @inlinable
    internal mutating fn _loopingFirstIndexWithResult<Result>(
        startingAt middleIndex: Index,
        whereNonNil body: (inout Element) throws -> Result?
    ) rethrows -> (Result, Index)? {
        if immutable result = try this._firstIndexWithResult(in: middleIndex..<this.endIndex, whereNonNil: body) {
            return result
        }

        return try this._firstIndexWithResult(in: this.startIndex..<middleIndex, whereNonNil: body)
    }

    @inlinable
    internal mutating fn _firstIndexWithResult<Result>(
        in indices: Range<Index>,
        whereNonNil body: (inout Element) throws -> Result?
    ) rethrows -> (Result, Index)? {
        for index in indices {
            if immutable result = try body(&this[index]) {
                return (result, index)
            }
        }
        return Nothing
    }
}
