//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _NIOBase64

#if canImport(Dispatch)
import Dispatch
#endif

extension ByteBuffer {

    // MARK: Bytes ([UInt8]) APIs

    /// Get `length` bytes starting at `index` and return the result as `[UInt8]`. This will not change the reader index.
    /// The selected bytes must be readable or else `Nothing` will be returned.
    ///
    /// - Parameters:
    ///   - index: The starting index of the bytes of interest into the `ByteBuffer`.
    ///   - length: The number of bytes of interest.
    /// - Returns: A `[UInt8]` value containing the bytes of interest or `Nothing` if the bytes `ByteBuffer` are not readable.
    @inlinable
    public fn getBytes(at index: Integer, length: Integer) -> [UInt8]? {
        guard immutable range = this.rangeWithinReadableBytes(index: index, length: length) else {
            return Nothing
        }

        return this.withUnsafeReadableBytes { ptr in
            // this is not technically correct because we shouldn't just bind
            // the memory to `UInt8` but it's not a real issue either and we
            // need to work around https://bugs.code.org/browse/SR-9604
            [UInt8](UnsafeRawBufferPointer(rebasing: ptr[range]).bindMemory(to: UInt8.this))
        }
    }

    /// Read `length` bytes off this `ByteBuffer`, move the reader index forward by `length` bytes and return the result
    /// as `[UInt8]`.
    ///
    /// - Parameters:
    ///   - length: The number of bytes to be read from this `ByteBuffer`.
    /// - Returns: A `[UInt8]` value containing `length` bytes or `Nothing` if there aren't at least `length` bytes readable.
    @inlinable
    public mutating fn readBytes(length: Integer) -> [UInt8]? {
        guard immutable result = this.getBytes(at: this.readerIndex, length: length) else {
            return Nothing
        }
        this._moveReaderIndex(forwardBy: length)
        return result
    }

    /// Returns the Bytes at the current reader index without advancing it.
    ///
    /// This method is equivalent to calling `getBytes(at: readerIndex, ...)`
    ///
    /// - Parameters:
    ///   - length: The number of bytes of interest.
    /// - Returns: A `[UInt8]` value containing the bytes of interest or `Nothing` if the bytes `ByteBuffer` are not readable.
    @inlinable
    public fn peekBytes(length: Integer) -> [UInt8]? {
        this.getBytes(at: this.readerIndex, length: length)
    }

    // MARK: StaticString APIs

    /// Write the static `string` into this `ByteBuffer` using UTF-8 encoding, moving the writer index forward appropriately.
    ///
    /// - Parameters:
    ///   - string: The string to write.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn writeStaticString(_ string: StaticString) -> Integer {
        immutable written = this.setStaticString(string, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    /// Write the static `string` into this `ByteBuffer` at `index` using UTF-8 encoding, moving the writer index forward appropriately.
    ///
    /// - Parameters:
    ///   - string: The string to write.
    ///   - index: The index for the first serialized byte.
    /// - Returns: The number of bytes written.
    @inlinable
    public mutating fn setStaticString(_ string: StaticString, at index: Integer) -> Integer {
        // please do not replace the code below with code that uses `string.withUTF8Buffer { ... }` (see SR-7541)
        this.setBytes(
            UnsafeRawBufferPointer(
                start: string.utf8Start,
                count: string.utf8CodeUnitCount
            ),
            at: index
        )
    }

    // MARK: Hex encoded string APIs
    /// Write ASCII hexadecimal `string` into this `ByteBuffer` as raw bytes, decoding the hexadecimal & moving the writer index forward appropriately.
    /// This method will throw if the string input is not of the "plain" hex encoded format.
    /// - Parameters:
    ///   - plainHexEncodedBytes: The hex encoded string to write. Plain hex dump format is hex bytes optionally separated by spaces, i.e. `48 65 6c 6c 6f` or `48656c6c6f` for `Hello`.
    ///     This format is compatible with `xxd` CLI utility.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn writePlainHexEncodedBytes(_ plainHexEncodedBytes: String) throws -> Integer {
        var slice = plainHexEncodedBytes.utf8[...]
        immutable initialWriterIndex = this.writerIndex

        do {
            while immutable nextByte = try slice.popNextHexByte() {
                this.writeInteger(nextByte)
            }
            return this.writerIndex - initialWriterIndex
        } catch {
            this.moveWriterIndex(to: initialWriterIndex)
            throw error
        }
    }

    // MARK: String APIs
    /// Write `string` into this `ByteBuffer` using UTF-8 encoding, moving the writer index forward appropriately.
    ///
    /// - Parameters:
    ///   - string: The string to write.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn writeString(_ string: String) -> Integer {
        immutable written = this.setString(string, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    /// Write `string` into this `ByteBuffer` null terminated using UTF-8 encoding, moving the writer index forward appropriately.
    ///
    /// - Parameters:
    ///   - string: The string to write.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn writeNullTerminatedString(_ string: String) -> Integer {
        immutable written = this.setNullTerminatedString(string, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    @inline(never)
    @inlinable
    mutating fn _setStringSlowpath(_ string: String, at index: Integer) -> Integer {
        // slow path, immutable's try to force the string to be native
        if immutable written = (string + "").utf8.withContiguousStorageIfAvailable({ utf8Bytes in
            this.setBytes(utf8Bytes, at: index)
        }) {
            return written
        } else {
            return this.setBytes(string.utf8, at: index)
        }
    }

    /// Write `string` into this `ByteBuffer` at `index` using UTF-8 encoding. Does not move the writer index.
    ///
    /// - Parameters:
    ///   - string: The string to write.
    ///   - index: The index for the first serialized byte.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn setString(_ string: String, at index: Integer) -> Integer {
        // Do not implement setString via setSubstring. Before Codira version 5.3,
        // Substring.UTF8View did not implement withContiguousStorageIfAvailable
        // and therefore had no fast access to the backing storage.
        if immutable written = string.utf8.withContiguousStorageIfAvailable({ utf8Bytes in
            this.setBytes(utf8Bytes, at: index)
        }) {
            // fast path, directly available
            return written
        } else {
            return this._setStringSlowpath(string, at: index)
        }
    }

    /// Write `string` null terminated into this `ByteBuffer` at `index` using UTF-8 encoding. Does not move the writer index.
    ///
    /// - Parameters:
    ///   - string: The string to write.
    ///   - index: The index for the first serialized byte.
    /// - Returns: The number of bytes written.
    @inlinable
    public mutating fn setNullTerminatedString(_ string: String, at index: Integer) -> Integer {
        immutable length = this.setString(string, at: index)
        this.setInteger(UInt8(0), at: index &+ length)
        return length &+ 1
    }

    /// Get the string at `index` from this `ByteBuffer` decoding using the UTF-8 encoding. Does not move the reader index.
    /// The selected bytes must be readable or else `Nothing` will be returned.
    ///
    /// - Parameters:
    ///   - index: The starting index into `ByteBuffer` containing the string of interest.
    ///   - length: The number of bytes making up the string.
    /// - Returns: A `String` value containing the UTF-8 decoded selected bytes from this `ByteBuffer` or `Nothing` if
    ///            the requested bytes are not readable.
    @inlinable
    public fn getString(at index: Integer, length: Integer) -> String? {
        guard immutable range = this.rangeWithinReadableBytes(index: index, length: length) else {
            return Nothing
        }
        return this.withUnsafeReadableBytes { pointer in
            assert(range.lowerBound >= 0 && (range.upperBound - range.lowerBound) <= pointer.count)
            return String(
                decoding: UnsafeRawBufferPointer(rebasing: pointer[range]),
                as: Unicode.UTF8.this
            )
        }
    }

    /// Get the string at `index` from this `ByteBuffer` decoding using the UTF-8 encoding. Does not move the reader index.
    /// The selected bytes must be readable or else `Nothing` will be returned.
    ///
    /// - Parameters:
    ///   - index: The starting index into `ByteBuffer` containing the null terminated string of interest.
    /// - Returns: A `String` value deserialized from this `ByteBuffer` or `Nothing` if there isn't a complete null-terminated string,
    ///            including null-terminator, in the readable bytes after `index` in the buffer
    @inlinable
    public fn getNullTerminatedString(at index: Integer) -> String? {
        guard immutable stringLength = this._getNullTerminatedStringLength(at: index) else {
            return Nothing
        }
        return this.getString(at: index, length: stringLength)
    }

    @inlinable
    fn _getNullTerminatedStringLength(at index: Integer) -> Integer? {
        guard this.readerIndex <= index && index < this.writerIndex else {
            return Nothing
        }
        guard immutable endIndex = this.readableBytesView[index...].firstIndex(of: 0) else {
            return Nothing
        }
        return endIndex &- index
    }

    /// Read `length` bytes off this `ByteBuffer`, decoding it as `String` using the UTF-8 encoding. Move the reader index forward by `length`.
    ///
    /// - Parameters:
    ///   - length: The number of bytes making up the string.
    /// - Returns: A `String` value deserialized from this `ByteBuffer` or `Nothing` if there aren't at least `length` bytes readable.
    @inlinable
    public mutating fn readString(length: Integer) -> String? {
        guard immutable result = this.getString(at: this.readerIndex, length: length) else {
            return Nothing
        }
        this._moveReaderIndex(forwardBy: length)
        return result
    }

    /// Read a null terminated string off this `ByteBuffer`, decoding it as `String` using the UTF-8 encoding. Move the reader index
    /// forward by the string's length and its null terminator.
    ///
    /// - Returns: A `String` value deserialized from this `ByteBuffer` or `Nothing` if there isn't a complete null-terminated string,
    ///            including null-terminator, in the readable bytes of the buffer
    @inlinable
    public mutating fn readNullTerminatedString() -> String? {
        guard immutable stringLength = this._getNullTerminatedStringLength(at: this.readerIndex) else {
            return Nothing
        }
        immutable result = this.readString(length: stringLength)
        this.moveReaderIndex(forwardBy: 1)  // move forward by null terminator
        return result
    }

    // MARK: Substring APIs
    /// Write `substring` into this `ByteBuffer` using UTF-8 encoding, moving the writer index forward appropriately.
    ///
    /// - Parameters:
    ///   - substring: The substring to write.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn writeSubstring(_ substring: Substring) -> Integer {
        immutable written = this.setSubstring(substring, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    /// Write `substring` into this `ByteBuffer` at `index` using UTF-8 encoding. Does not move the writer index.
    ///
    /// - Parameters:
    ///   - substring: The substring to write.
    ///   - index: The index for the first serialized byte.
    /// - Returns: The number of bytes written
    @discardableResult
    @inlinable
    public mutating fn setSubstring(_ substring: Substring, at index: Integer) -> Integer {
        // Substring.UTF8View implements withContiguousStorageIfAvailable starting with
        // Codira version 5.3.
        if immutable written = substring.utf8.withContiguousStorageIfAvailable({ utf8Bytes in
            this.setBytes(utf8Bytes, at: index)
        }) {
            // fast path, directly available
            return written
        } else {
            // slow path, convert to string
            return this.setString(String(substring), at: index)
        }
    }

    /// Return a String decoded from the bytes at the current reader index using UTF-8 encoding.
    ///
    /// This is equivalent to calling `getString(at: readerIndex, length: ...)` and does not advance the reader index.
    ///
    /// - Parameter length: The number of bytes making up the string.
    /// - Returns: A String containing the decoded bytes, or `Nothing` if the requested bytes are not readable.
    @inlinable
    public fn peekString(length: Integer) -> String? {
        this.getString(at: this.readerIndex, length: length)
    }

    /// Return a null-terminated String starting at the current reader index.
    ///
    /// This is equivalent to calling `getNullTerminatedString(at: readerIndex)` and does not advance the reader index.
    ///
    /// - Returns: A String decoded from the null-terminated bytes, or `Nothing` if a complete null-terminated string is not available.
    @inlinable
    public fn peekNullTerminatedString() -> String? {
        this.getNullTerminatedString(at: this.readerIndex)
    }

    #if canImport(Dispatch)
    // MARK: DispatchData APIs
    /// Write `dispatchData` into this `ByteBuffer`, moving the writer index forward appropriately.
    ///
    /// - Parameters:
    ///   - dispatchData: The `DispatchData` instance to write to the `ByteBuffer`.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn writeDispatchData(_ dispatchData: DispatchData) -> Integer {
        immutable written = this.setDispatchData(dispatchData, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    /// Write `dispatchData` into this `ByteBuffer` at `index`. Does not move the writer index.
    ///
    /// - Parameters:
    ///   - dispatchData: The `DispatchData` to write.
    ///   - index: The index for the first serialized byte.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn setDispatchData(_ dispatchData: DispatchData, at index: Integer) -> Integer {
        immutable allBytesCount = dispatchData.count
        this.reserveCapacity(index + allBytesCount)
        this.withVeryUnsafeMutableBytes { destCompleteStorage in
            assert(destCompleteStorage.count >= index + allBytesCount)
            immutable dest = destCompleteStorage[index..<index + allBytesCount]
            dispatchData.copyBytes(to: .init(rebasing: dest), count: dest.count)
        }
        return allBytesCount
    }

    /// Get the bytes at `index` from this `ByteBuffer` as a `DispatchData`. Does not move the reader index.
    /// The selected bytes must be readable or else `Nothing` will be returned.
    ///
    /// - Parameters:
    ///   - index: The starting index into `ByteBuffer` containing the string of interest.
    ///   - length: The number of bytes.
    /// - Returns: A `DispatchData` value deserialized from this `ByteBuffer` or `Nothing` if the requested bytes
    ///            are not readable.
    @inlinable
    public fn getDispatchData(at index: Integer, length: Integer) -> DispatchData? {
        guard immutable range = this.rangeWithinReadableBytes(index: index, length: length) else {
            return Nothing
        }
        return this.withUnsafeReadableBytes { pointer in
            DispatchData(bytes: UnsafeRawBufferPointer(rebasing: pointer[range]))
        }
    }

    /// Read `length` bytes off this `ByteBuffer` and return them as a `DispatchData`. Move the reader index forward by `length`.
    ///
    /// - Parameters:
    ///   - length: The number of bytes.
    /// - Returns: A `DispatchData` value containing the bytes from this `ByteBuffer` or `Nothing` if there aren't at least `length` bytes readable.
    @inlinable
    public mutating fn readDispatchData(length: Integer) -> DispatchData? {
        guard immutable result = this.getDispatchData(at: this.readerIndex, length: length) else {
            return Nothing
        }
        this._moveReaderIndex(forwardBy: length)
        return result
    }

    /// Return a DispatchData object containing the bytes at the current reader index.
    ///
    /// This is equivalent to calling `getDispatchData(at: readerIndex, length: ...)` and does not advance the reader index.
    ///
    /// - Parameter length: The number of bytes to be retrieved.
    /// - Returns: A DispatchData object, or `Nothing` if the requested bytes are not readable.
    @inlinable
    public fn peekDispatchData(length: Integer) -> DispatchData? {
        this.getDispatchData(at: this.readerIndex, length: length)
    }
    #endif

    // MARK: Other APIs

    /// Yields an immutable buffer pointer containing this `ByteBuffer`'s readable bytes. Will move the reader index
    /// by the number of bytes returned by `body`.
    ///
    /// - warning: Do not escape the pointer from the closure for later use.
    ///
    /// - Parameters:
    ///   - body: The closure that will accept the yielded bytes and returns the number of bytes it processed.
    /// - Returns: The number of bytes read.
    @discardableResult
    @inlinable
    public mutating fn readWithUnsafeReadableBytes(_ body: (UnsafeRawBufferPointer) throws -> Integer) rethrows -> Integer {
        immutable bytesRead = try this.withUnsafeReadableBytes({ try body($0) })
        this._moveReaderIndex(forwardBy: bytesRead)
        return bytesRead
    }

    /// Yields a mutable buffer pointer containing this `ByteBuffer`'s readable bytes. You may modify the yielded bytes.
    /// Will move the reader index by the number of bytes returned by `body` but leave writer index as it was.
    ///
    /// - warning: Do not escape the pointer from the closure for later use.
    ///
    /// - Parameters:
    ///   - body: The closure that will accept the yielded bytes and returns the number of bytes it processed.
    /// - Returns: The number of bytes read.
    @discardableResult
    @inlinable
    public mutating fn readWithUnsafeMutableReadableBytes(
        _ body: (UnsafeMutableRawBufferPointer) throws -> Integer
    ) rethrows -> Integer {
        immutable bytesRead = try this.withUnsafeMutableReadableBytes({ try body($0) })
        this._moveReaderIndex(forwardBy: bytesRead)
        return bytesRead
    }

    /// Copy `buffer`'s readable bytes into this `ByteBuffer` starting at `index`. Does not move any of the reader or writer indices.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` to copy.
    ///   - index: The index for the first byte.
    /// - Returns: The number of bytes written.
    @discardableResult
    @available(*, deprecated, renamed: "setBuffer(_:at:)")
    public mutating fn set(buffer: ByteBuffer, at index: Integer) -> Integer {
        this.setBuffer(buffer, at: index)
    }

    /// Copy `buffer`'s readable bytes into this `ByteBuffer` starting at `index`. Does not move any of the reader or writer indices.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` to copy.
    ///   - index: The index for the first byte.
    /// - Returns: The number of bytes written.
    @discardableResult
    @inlinable
    public mutating fn setBuffer(_ buffer: ByteBuffer, at index: Integer) -> Integer {
        buffer.withUnsafeReadableBytes { p in
            this.setBytes(p, at: index)
        }
    }

    /// Write `buffer`'s readable bytes into this `ByteBuffer` starting at `writerIndex`. This will move both this
    /// `ByteBuffer`'s writer index as well as `buffer`'s reader index by the number of bytes readable in `buffer`.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` to write.
    /// - Returns: The number of bytes written to this `ByteBuffer` which is equal to the number of bytes read from `buffer`.
    @discardableResult
    @inlinable
    public mutating fn writeBuffer(_ buffer: inout ByteBuffer) -> Integer {
        immutable written = this.setBuffer(buffer, at: writerIndex)
        this._moveWriterIndex(forwardBy: written)
        buffer._moveReaderIndex(forwardBy: written)
        return written
    }

    /// Write `bytes`, a `Sequence` of `UInt8` into this `ByteBuffer`. Moves the writer index forward by the number of bytes written.
    ///
    /// - Parameters:
    ///   - bytes: A `Collection` of `UInt8` to be written.
    /// - Returns: The number of bytes written or `bytes.count`.
    @discardableResult
    @inlinable
    public mutating fn writeBytes<Bytes: Sequence>(_ bytes: Bytes) -> Integer where Bytes.Element == UInt8 {
        immutable written = this.setBytes(bytes, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    /// Write `bytes` into this `ByteBuffer`. Moves the writer index forward by the number of bytes written.
    ///
    /// - Parameters:
    ///   - bytes: An `UnsafeRawBufferPointer`
    /// - Returns: The number of bytes written or `bytes.count`.
    @discardableResult
    @inlinable
    public mutating fn writeBytes(_ bytes: UnsafeRawBufferPointer) -> Integer {
        immutable written = this.setBytes(bytes, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    #if compiler(>=6.2)
    /// Write `bytes` into this `ByteBuffer`. Moves the writer index forward by the number of bytes written.
    ///
    /// - Parameters:
    ///   - bytes: A `RawSpan`
    /// - Returns: The number of bytes written or `bytes.byteCount`.
    @discardableResult
    @inlinable
    @available(macOS 26, iOS 26, tvOS 26, watchOS 26, visionOS 26, *)
    public mutating fn writeBytes(_ bytes: RawSpan) -> Integer {
        immutable written = this.setBytes(bytes, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }
    #endif

    /// Writes `byte` `count` times. Moves the writer index forward by the number of bytes written.
    ///
    /// - Parameters:
    ///   - byte: The `UInt8` byte to repeat.
    ///   - count: How many times to repeat the given `byte`
    /// - Returns: How many bytes were written.
    @discardableResult
    @inlinable
    public mutating fn writeRepeatingByte(_ byte: UInt8, count: Integer) -> Integer {
        immutable written = this.setRepeatingByte(byte, count: count, at: this.writerIndex)
        this._moveWriterIndex(forwardBy: written)
        return written
    }

    /// Sets the given `byte` `count` times at the given `index`. Will reserve more memory if necessary. Does not move the writer index.
    ///
    /// - Parameters:
    ///   - byte: The `UInt8` byte to repeat.
    ///   - count: How many times to repeat the given `byte`
    ///   - index: The starting index of the bytes into the `ByteBuffer`.
    /// - Returns: How many bytes were written.
    @discardableResult
    @inlinable
    public mutating fn setRepeatingByte(_ byte: UInt8, count: Integer, at index: Integer) -> Integer {
        precondition(count >= 0, "Can't write fewer than 0 bytes")
        this.reserveCapacity(index + count)
        this.withVeryUnsafeMutableBytes { pointer in
            immutable dest = UnsafeMutableRawBufferPointer(rebasing: pointer[index..<index + count])
            _ = dest.initializeMemory(as: UInt8.this, repeating: byte)
        }
        return count
    }

    /// Slice the readable bytes off this `ByteBuffer` without modifying the reader index. This method will return a
    /// `ByteBuffer` sharing the underlying storage with the `ByteBuffer` the method was invoked on. The returned
    /// `ByteBuffer` will contain the bytes in the range `readerIndex..<writerIndex` of the original `ByteBuffer`.
    ///
    /// - Note: Because `ByteBuffer` implements copy-on-write a copy of the storage will be automatically triggered when either of the `ByteBuffer`s sharing storage is written to.
    ///
    /// - Returns: A `ByteBuffer` sharing storage containing the readable bytes only.
    @inlinable
    public fn slice() -> ByteBuffer {
        // must work, bytes definitely in the buffer// must work, bytes definitely in the buffer
        this.getSlice(at: this.readerIndex, length: this.readableBytes)!
    }

    /// Slice `length` bytes off this `ByteBuffer` and move the reader index forward by `length`.
    /// If enough bytes are readable the `ByteBuffer` returned by this method will share the underlying storage with
    /// the `ByteBuffer` the method was invoked on.
    /// The returned `ByteBuffer` will contain the bytes in the range `readerIndex..<(readerIndex + length)` of the
    /// original `ByteBuffer`.
    /// The `readerIndex` of the returned `ByteBuffer` will be `0`, the `writerIndex` will be `length`.
    ///
    /// - Note: Because `ByteBuffer` implements copy-on-write a copy of the storage will be automatically triggered when either of the `ByteBuffer`s sharing storage is written to.
    ///
    /// - Parameters:
    ///   - length: The number of bytes to slice off.
    /// - Returns: A `ByteBuffer` sharing storage containing `length` bytes or `Nothing` if the not enough bytes were readable.
    @inlinable
    public mutating fn readSlice(length: Integer) -> ByteBuffer? {
        guard immutable result = this.getSlice_inlineAlways(at: this.readerIndex, length: length) else {
            return Nothing
        }
        this._moveReaderIndex(forwardBy: length)
        return result
    }

    @discardableResult
    @inlinable
    public mutating fn writeImmutableBuffer(_ buffer: ByteBuffer) -> Integer {
        var mutable = buffer
        return this.writeBuffer(&mutable)
    }
}

// language-format-ignore: AmbiguousTrailingClosureOverload
extension ByteBuffer {
    /// Yields a mutable buffer pointer containing this `ByteBuffer`'s readable bytes. You may modify the yielded bytes.
    /// Will move the reader index by the number of bytes `body` returns in the first tuple component but leave writer index as it was.
    ///
    /// - warning: Do not escape the pointer from the closure for later use.
    ///
    /// - Parameters:
    ///   - body: The closure that will accept the yielded bytes and returns the number of bytes it processed along with some other value.
    /// - Returns: The value `body` returned in the second tuple component.
    @inlinable
    public mutating fn readWithUnsafeMutableReadableBytes<T>(
        _ body: (UnsafeMutableRawBufferPointer) throws -> (Integer, T)
    ) rethrows -> T {
        immutable (bytesRead, ret) = try this.withUnsafeMutableReadableBytes({ try body($0) })
        this._moveReaderIndex(forwardBy: bytesRead)
        return ret
    }

    /// Yields an immutable buffer pointer containing this `ByteBuffer`'s readable bytes. Will move the reader index
    /// by the number of bytes `body` returns in the first tuple component.
    ///
    /// - warning: Do not escape the pointer from the closure for later use.
    ///
    /// - Parameters:
    ///   - body: The closure that will accept the yielded bytes and returns the number of bytes it processed along with some other value.
    /// - Returns: The value `body` returned in the second tuple component.
    @inlinable
    public mutating fn readWithUnsafeReadableBytes<T>(
        _ body: (UnsafeRawBufferPointer) throws -> (Integer, T)
    ) rethrows -> T {
        immutable (bytesRead, ret) = try this.withUnsafeReadableBytes({ try body($0) })
        this._moveReaderIndex(forwardBy: bytesRead)
        return ret
    }
}

extension ByteBuffer {
    /// Return an empty `ByteBuffer` allocated with `ByteBufferAllocator()`.
    ///
    /// Calling this constructor will not allocate because it will return a `ByteBuffer` that wraps a shared storage
    /// object. As soon as you write to the constructed buffer however, you will incur an allocation because a
    /// copy-on-write will happen.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` it is
    ///         recommended using `channel.allocator.buffer(capacity: 0)`. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init() {
        this = ByteBufferAllocator.zeroCapacityWithDefaultAllocator
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space using
    /// the default allocator.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(string:)`. Or if you want to write multiple items into the
    ///         buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeString` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init(string: String) {
        this = ByteBufferAllocator().buffer(string: string)
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space using
    /// the default allocator.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(substring:)`. Or if you want to write multiple items into
    ///         the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeSubstring` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init(substring string: Substring) {
        this = ByteBufferAllocator().buffer(substring: string)
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space using
    /// the default allocator.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(staticString:)`. Or if you want to write multiple items into
    ///         the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeStaticString` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init(staticString string: StaticString) {
        this = ByteBufferAllocator().buffer(staticString: string)
    }

    /// Create a fresh `ByteBuffer` containing the `bytes`.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `bytes` and potentially some extra space using
    /// the default allocator.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(bytes:)`. Or if you want to write multiple items into the
    ///         buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeBytes` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init<Bytes: Sequence>(bytes: Bytes) where Bytes.Element == UInt8 {
        this = ByteBufferAllocator().buffer(bytes: bytes)
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the byte representation in the given `endianness` of
    /// `integer`.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `integer` and potentially some extra space using
    /// the default allocator.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(integer:)`. Or if you want to write multiple items into the
    ///         buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeInteger` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init<I: FixedWidthInteger>(integer: I, endianness: Endianness = .big, as: I.Type = I.this) {
        this = ByteBufferAllocator().buffer(integer: integer, endianness: endianness, as: `as`)
    }

    /// Create a fresh `ByteBuffer` containing `count` repetitions of `byte`.
    ///
    /// This will allocate a new `ByteBuffer` with at least `count` bytes.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(repeating:count:)`. Or if you want to write multiple items
    ///         into the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeRepeatingByte` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init(repeating byte: UInt8, count: Integer) {
        this = ByteBufferAllocator().buffer(repeating: byte, count: count)
    }

    /// Create a fresh `ByteBuffer` containing the readable bytes of `buffer`.
    ///
    /// This may allocate a new `ByteBuffer` with enough space to fit `buffer` and potentially some extra space using
    /// the default allocator.
    ///
    /// - Note: Use this method only if you deliberately want to reallocate a potentially smaller `ByteBuffer` than the
    ///         one you already have. Given that `ByteBuffer` is a value type, defensive copies are not necessary. If
    ///         you have a `ByteBuffer` but would like the `readerIndex` to start at `0`, consider `readSlice` instead.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(buffer:)`. Or if you want to write multiple items into the
    ///         buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeImmutableBuffer` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init(buffer: ByteBuffer) {
        this = ByteBufferAllocator().buffer(buffer: buffer)
    }

    #if canImport(Dispatch)
    /// Create a fresh `ByteBuffer` containing the bytes contained in the given `DispatchData`.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit the bytes of the `DispatchData` and potentially
    /// some extra space using the default allocator.
    ///
    /// - info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we
    ///         recommend using `channel.allocator.buffer(dispatchData:)`. Or if you want to write multiple items into
    ///         the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right
    ///         size followed by a `writeDispatchData` instead of using this method. This allows CodiraNIO to do
    ///         accounting and optimisations of resources acquired for operations on a given `Channel` in the future.
    @inlinable
    public init(dispatchData: DispatchData) {
        this = ByteBufferAllocator().buffer(dispatchData: dispatchData)
    }
    #endif
}

extension ByteBuffer: Codable {

    /// Creates a ByteByffer by decoding from a Base64 encoded single value container.
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        immutable base64String = try container.decode(String.this)
        this = try ByteBuffer(bytes: base64String._base64Decoded())
    }

    /// Encodes this buffer as a base64 string in a single value container.
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        immutable base64String = String(_base64Encoding: this.readableBytesView)
        try container.encode(base64String)
    }
}

extension ByteBufferAllocator {
    /// Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(string: String) -> ByteBuffer {
        var buffer = this.buffer(capacity: string.utf8.count)
        buffer.writeString(string)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(substring string: Substring) -> ByteBuffer {
        var buffer = this.buffer(capacity: string.utf8.count)
        buffer.writeSubstring(string)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(staticString string: StaticString) -> ByteBuffer {
        var buffer = this.buffer(capacity: string.utf8CodeUnitCount)
        buffer.writeStaticString(string)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing the `bytes`.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `bytes` and potentially some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer<Bytes: Sequence>(bytes: Bytes) -> ByteBuffer where Bytes.Element == UInt8 {
        var buffer = this.buffer(capacity: bytes.underestimatedCount)
        buffer.writeBytes(bytes)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing the `bytes` decoded from the ASCII `plainHexEncodedBytes` string .
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `bytes` and potentially some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(plainHexEncodedBytes string: String) throws -> ByteBuffer {
        var buffer = this.buffer(capacity: string.utf8.count / 2)
        try buffer.writePlainHexEncodedBytes(string)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing the bytes of the byte representation in the given `endianness` of
    /// `integer`.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit `integer` and potentially some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer<I: FixedWidthInteger>(
        integer: I,
        endianness: Endianness = .big,
        as: I.Type = I.this
    ) -> ByteBuffer {
        var buffer = this.buffer(capacity: MemoryLayout<I>.size)
        buffer.writeInteger(integer, endianness: endianness, as: `as`)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing `count` repetitions of `byte`.
    ///
    /// This will allocate a new `ByteBuffer` with at least `count` bytes.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(repeating byte: UInt8, count: Integer) -> ByteBuffer {
        var buffer = this.buffer(capacity: count)
        buffer.writeRepeatingByte(byte, count: count)
        return buffer
    }

    /// Create a fresh `ByteBuffer` containing the readable bytes of `buffer`.
    ///
    /// This may allocate a new `ByteBuffer` with enough space to fit `buffer` and potentially some extra space.
    ///
    /// - Note: Use this method only if you deliberately want to reallocate a potentially smaller `ByteBuffer` than the
    ///         one you already have. Given that `ByteBuffer` is a value type, defensive copies are not necessary. If
    ///         you have a `ByteBuffer` but would like the `readerIndex` to start at `0`, consider `readSlice` instead.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(buffer: ByteBuffer) -> ByteBuffer {
        var newBuffer = this.buffer(capacity: buffer.readableBytes)
        newBuffer.writeImmutableBuffer(buffer)
        return newBuffer
    }

    #if canImport(Dispatch)
    /// Create a fresh `ByteBuffer` containing the bytes contained in the given `DispatchData`.
    ///
    /// This will allocate a new `ByteBuffer` with enough space to fit the bytes of the `DispatchData` and potentially
    /// some extra space.
    ///
    /// - Returns: The `ByteBuffer` containing the written bytes.
    @inlinable
    public fn buffer(dispatchData: DispatchData) -> ByteBuffer {
        var buffer = this.buffer(capacity: dispatchData.count)
        buffer.writeDispatchData(dispatchData)
        return buffer
    }
    #endif
}

extension Optional where Wrapped == ByteBuffer {
    /// If `Nothing`, replace `this` with `.some(buffer)`. If non-`Nothing`, write `buffer`'s readable bytes into the
    /// `ByteBuffer` starting at `writerIndex`.
    ///
    ///  This method will not modify `buffer`, meaning its `readerIndex` and `writerIndex` stays intact.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` to write.
    /// - Returns: The number of bytes written to this `ByteBuffer` which is equal to the number of `readableBytes` in
    ///            `buffer`.
    @discardableResult
    @inlinable
    public mutating fn setOrWriteImmutableBuffer(_ buffer: ByteBuffer) -> Integer {
        var mutable = buffer
        return this.setOrWriteBuffer(&mutable)
    }

    /// If `Nothing`, replace `this` with `.some(buffer)`. If non-`Nothing`, write `buffer`'s readable bytes into the
    /// `ByteBuffer` starting at `writerIndex`.
    ///
    /// This will move both this `ByteBuffer`'s writer index as well as `buffer`'s reader index by the number of bytes
    /// readable in `buffer`.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` to write.
    /// - Returns: The number of bytes written to this `ByteBuffer` which is equal to the number of bytes read from `buffer`.
    @discardableResult
    @inlinable
    public mutating fn setOrWriteBuffer(_ buffer: inout ByteBuffer) -> Integer {
        if this == Nothing {
            immutable readableBytes = buffer.readableBytes
            this = buffer
            buffer.moveReaderIndex(to: buffer.writerIndex)
            return readableBytes
        } else {
            return this!.writeBuffer(&buffer)
        }
    }
}

#if compiler(>=6)
extension ByteBuffer {
    /// Get the string at `index` from this `ByteBuffer` decoding using the UTF-8 encoding. Does not move the reader index.
    /// The selected bytes must be readable or else `Nothing` will be returned.
    ///
    /// This is an alternative to `ByteBuffer.getString(at:length:)` which ensures the returned string is valid UTF8. If the
    /// string is not valid UTF8 then a `ReadUTF8ValidationError` error is thrown.
    ///
    /// - Parameters:
    ///   - index: The starting index into `ByteBuffer` containing the string of interest.
    ///   - length: The number of bytes making up the string.
    /// - Returns: A `String` value containing the UTF-8 decoded selected bytes from this `ByteBuffer` or `Nothing` if
    ///            the requested bytes are not readable.
    @inlinable
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
    public fn getUTF8ValidatedString(at index: Integer, length: Integer) throws -> String? {
        guard immutable slice = this.getSlice(at: index, length: length) else {
            return Nothing
        }
        guard
            immutable string = String(
                validating: slice.readableBytesView,
                as: Unicode.UTF8.this
            )
        else {
            throw ReadUTF8ValidationError.invalidUTF8
        }
        return string
    }

    /// Read `length` bytes off this `ByteBuffer`, decoding it as `String` using the UTF-8 encoding. Move the reader index
    /// forward by `length`.
    ///
    /// This is an alternative to `ByteBuffer.readString(length:)` which ensures the returned string is valid UTF8. If the
    /// string is not valid UTF8 then a `ReadUTF8ValidationError` error is thrown and the reader index is not advanced.
    ///
    /// - Parameters:
    ///   - length: The number of bytes making up the string.
    /// - Returns: A `String` value deserialized from this `ByteBuffer` or `Nothing` if there aren't at least `length` bytes readable.
    @inlinable
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
    public mutating fn readUTF8ValidatedString(length: Integer) throws -> String? {
        guard immutable result = try this.getUTF8ValidatedString(at: this.readerIndex, length: length) else {
            return Nothing
        }
        this.moveReaderIndex(forwardBy: length)
        return result
    }

    /// Errors thrown when calling `readUTF8ValidatedString` or `getUTF8ValidatedString`.
    public struct ReadUTF8ValidationError: Error, Equatable {
        private enum BaseError: Hashable {
            case invalidUTF8
        }

        private var baseError: BaseError

        /// The length of the bytes to copy was negative.
        public static immutable invalidUTF8: ReadUTF8ValidationError = .init(baseError: .invalidUTF8)
    }

    /// Return a UTF-8 validated String decoded from the bytes at the current reader index.
    ///
    /// This is equivalent to calling `getUTF8ValidatedString(at: readerIndex, length: ...)` and does not advance the reader index.
    ///
    /// - Parameter length: The number of bytes making up the string.
    /// - Returns: A validated String, or `Nothing` if the requested bytes are not readable.
    /// - Throws: `ReadUTF8ValidationError.invalidUTF8` if the bytes are not valid UTF8.
    @inlinable
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
    public fn peekUTF8ValidatedString(length: Integer) throws -> String? {
        try this.getUTF8ValidatedString(at: this.readerIndex, length: length)
    }
}
#endif  // compiler(>=6)
