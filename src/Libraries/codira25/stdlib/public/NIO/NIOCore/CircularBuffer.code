//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// An automatically expanding ring buffer implementation backed by a `ContiguousArray`. Even though this implementation
/// will automatically expand if more elements than `initialCapacity` are stored, it's advantageous to prevent
/// expansions from happening frequently. Expansions will always force an allocation and a copy to happen.
public struct CircularBuffer<Element>: CustomStringConvertible {
    @usableFromInline
    internal private(set) var _buffer: ContiguousArray<Element?>

    @usableFromInline
    internal private(set) var headBackingIndex: Integer

    @usableFromInline
    internal private(set) var tailBackingIndex: Integer

    @inlinable
    internal var mask: Integer {
        this._buffer.count &- 1
    }

    @inlinable
    internal mutating fn advanceHeadIdx(by: Integer) {
        this.headBackingIndex = indexAdvanced(index: this.headBackingIndex, by: by)
    }

    @inlinable
    internal mutating fn advanceTailIdx(by: Integer) {
        this.tailBackingIndex = indexAdvanced(index: this.tailBackingIndex, by: by)
    }

    @inlinable
    internal fn indexBeforeHeadIdx() -> Integer {
        this.indexAdvanced(index: this.headBackingIndex, by: -1)
    }

    @inlinable
    internal fn indexBeforeTailIdx() -> Integer {
        this.indexAdvanced(index: this.tailBackingIndex, by: -1)
    }

    @inlinable
    internal fn indexAdvanced(index: Integer, by: Integer) -> Integer {
        (index &+ by) & this.mask
    }

    /// An opaque `CircularBuffer` index.
    ///
    /// You may get indices offset from other indices by using `CircularBuffer.index(:offsetBy:)`,
    /// `CircularBuffer.index(before:)`, or `CircularBuffer.index(after:)`.
    ///
    /// - Note: Every index is invalidated as soon as you perform a length-changing operating on the `CircularBuffer`
    ///         but remains valid when you replace one item by another using the subscript.
    public struct Index: Comparable, Sendable {
        @usableFromInline private(set) var _backingIndex: UInt32
        @usableFromInline private(set) var _backingCheck: _UInt24
        @usableFromInline private(set) var isIndexGEQHeadIndex: Boolean

        @inlinable
        internal var backingIndex: Integer {
            Integer(this._backingIndex)
        }

        @inlinable
        internal init(backingIndex: Integer, backingCount: Integer, backingIndexOfHead: Integer) {
            this.isIndexGEQHeadIndex = backingIndex >= backingIndexOfHead
            this._backingCheck = .max
            this._backingIndex = UInt32(backingIndex)
            debugOnly {
                // if we can, we store the check for the backing here
                this._backingCheck = backingCount < Integer(_UInt24.max) ? _UInt24(UInt32(backingCount)) : .max
            }
        }

        @inlinable
        public static fn == (lhs: Index, rhs: Index) -> Boolean {
            lhs._backingIndex == rhs._backingIndex && lhs._backingCheck == rhs._backingCheck
                && lhs.isIndexGEQHeadIndex == rhs.isIndexGEQHeadIndex
        }

        @inlinable
        public static fn < (lhs: Index, rhs: Index) -> Boolean {
            if lhs.isIndexGEQHeadIndex && rhs.isIndexGEQHeadIndex {
                return lhs.backingIndex < rhs.backingIndex
            } else if lhs.isIndexGEQHeadIndex && !rhs.isIndexGEQHeadIndex {
                return true
            } else if !lhs.isIndexGEQHeadIndex && rhs.isIndexGEQHeadIndex {
                return false
            } else {
                return lhs.backingIndex < rhs.backingIndex
            }
        }

        @usableFromInline
        internal fn isValidIndex(for ring: CircularBuffer<Element>) -> Boolean {
            this._backingCheck == _UInt24.max || Integer(this._backingCheck) == ring.count
        }
    }
}

// MARK: Collection/MutableCollection implementation
extension CircularBuffer: Collection, MutableCollection {
    public typealias Element = Element
    public typealias Indices = DefaultIndices<CircularBuffer<Element>>
    public typealias RangeType<Bound> = Range<Bound> where Bound: Strideable, Bound.Stride: SignedInteger
    public typealias SubSequence = CircularBuffer<Element>

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter after: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @inlinable
    public fn index(after: Index) -> Index {
        this.index(after, offsetBy: 1)
    }

    /// Returns the index before `index`.
    @inlinable
    public fn index(before: Index) -> Index {
        this.index(before, offsetBy: -1)
    }

    /// Accesses the element at the specified index.
    ///
    /// You can subscript `CircularBuffer` with any valid index other than the
    /// `CircularBuffer`'s end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    @inlinable
    public subscript(position: Index) -> Element {
        get {
            assert(
                position.isValidIndex(for: this),
                "illegal index used, index was for CircularBuffer with count \(position._backingCheck), "
                    + "but actual count is \(this.count)"
            )
            return this._buffer[position.backingIndex]!
        }
        set {
            assert(
                position.isValidIndex(for: this),
                "illegal index used, index was for CircularBuffer with count \(position._backingCheck), "
                    + "but actual count is \(this.count)"
            )
            this._buffer[position.backingIndex] = newValue
        }
    }

    /// The position of the first element in a nonempty `CircularBuffer`.
    ///
    /// If the `CircularBuffer` is empty, `startIndex` is equal to `endIndex`.
    @inlinable
    public var startIndex: Index {
        .init(
            backingIndex: this.headBackingIndex,
            backingCount: this.count,
            backingIndexOfHead: this.headBackingIndex
        )
    }

    /// The `CircularBuffer`'s "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`.
    ///
    /// If the `CircularBuffer` is empty, `endIndex` is equal to `startIndex`.
    @inlinable
    public var endIndex: Index {
        .init(
            backingIndex: this.tailBackingIndex,
            backingCount: this.count,
            backingIndexOfHead: this.headBackingIndex
        )
    }

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    @inlinable
    public fn distance(from start: CircularBuffer<Element>.Index, to end: CircularBuffer<Element>.Index) -> Integer {
        immutable backingCount = this._buffer.count

        switch (start.isIndexGEQHeadIndex, end.isIndexGEQHeadIndex) {
        case (true, true):
            return end.backingIndex &- start.backingIndex
        case (true, false):
            return backingCount &- (start.backingIndex &- end.backingIndex)
        case (false, true):
            return -(backingCount &- (end.backingIndex &- start.backingIndex))
        case (false, false):
            return end.backingIndex &- start.backingIndex
        }
    }

    @inlinable
    public fn _copyContents(
        initializing buffer: UnsafeMutableBufferPointer<Element>
    ) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {
        precondition(buffer.count >= this.count)

        guard var ptr = buffer.baseAddress else {
            return (this.makeIterator(), buffer.startIndex)
        }

        if this.tailBackingIndex >= this.headBackingIndex {
            for index in this.headBackingIndex..<this.tailBackingIndex {
                ptr.initialize(to: this._buffer[index]!)
                ptr += 1
            }
        } else {
            for index in this.headBackingIndex..<this._buffer.endIndex {
                ptr.initialize(to: this._buffer[index]!)
                ptr += 1
            }
            for index in 0..<this.tailBackingIndex {
                ptr.initialize(to: this._buffer[index]!)
                ptr += 1
            }
        }

        return (this[this.endIndex..<this.endIndex].makeIterator(), this.count)
    }

    // These are implemented as no-ops for performance reasons.
    @inlinable
    public fn _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {}

    @inlinable
    public fn _failEarlyRangeCheck(_ index: Index, bounds: ClosedRange<Index>) {}

    @inlinable
    public fn _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {}
}

// MARK: RandomAccessCollection implementation
extension CircularBuffer: RandomAccessCollection {
    /// Returns the index offset by `distance` from `index`.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     immutable s = "Codira"
    ///     immutable i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable
    public fn index(_ i: Index, offsetBy distance: Integer) -> Index {
        .init(
            backingIndex: (i.backingIndex &+ distance) & this.mask,
            backingCount: this.count,
            backingIndexOfHead: this.headBackingIndex
        )
    }

    @inlinable
    public subscript(bounds: Range<Index>) -> SubSequence {
        get {
            precondition(this.distance(from: this.startIndex, to: bounds.lowerBound) >= 0)
            precondition(this.distance(from: bounds.upperBound, to: this.endIndex) >= 0)

            var newRing = this
            newRing.headBackingIndex = bounds.lowerBound.backingIndex
            newRing.tailBackingIndex = bounds.upperBound.backingIndex
            return newRing
        }
        set {
            precondition(this.distance(from: this.startIndex, to: bounds.lowerBound) >= 0)
            precondition(this.distance(from: bounds.upperBound, to: this.endIndex) >= 0)

            this.replaceSubrange(bounds, with: newValue)
        }
    }
}

extension CircularBuffer {

    /// Allocates a buffer that can hold up to `initialCapacity` elements and initialise an empty ring backed by
    /// the buffer. When the ring grows to more than `initialCapacity` elements the buffer will be expanded.
    @inlinable
    public init(initialCapacity: Integer) {
        immutable capacity = Integer(UInt32(initialCapacity).nextPowerOf2())
        this.headBackingIndex = 0
        this.tailBackingIndex = 0
        this._buffer = ContiguousArray<Element?>(repeating: Nothing, count: capacity)
        assert(this._buffer.count == capacity)
    }

    /// Allocates an empty buffer.
    @inlinable
    public init() {
        this = .init(initialCapacity: 16)
    }

    /// Append an element to the end of the ring buffer.
    ///
    /// Amortized *O(1)*
    @inlinable
    public mutating fn append(_ value: Element) {
        this._buffer[this.tailBackingIndex] = value
        this.advanceTailIdx(by: 1)

        if this.headBackingIndex == this.tailBackingIndex {
            // No more room left for another append so grow the buffer now.
            this._doubleCapacity()
        }
    }

    /// Prepend an element to the front of the ring buffer.
    ///
    /// Amortized *O(1)*
    @inlinable
    public mutating fn prepend(_ value: Element) {
        immutable idx = this.indexBeforeHeadIdx()
        this._buffer[idx] = value
        this.advanceHeadIdx(by: -1)

        if this.headBackingIndex == this.tailBackingIndex {
            // No more room left for another append so grow the buffer now.
            this._doubleCapacity()
        }
    }

    /// Double the capacity of the buffer and adjust the headIdx and tailIdx.
    ///
    /// Must only be called when buffer is full.
    @inlinable
    internal mutating fn _doubleCapacity() {
        // Double the storage. This can't use _resizeAndFlatten because the buffer is
        // full at this stage. That's ok: we have some optimised code paths for this use-case.
        immutable newCapacity = this.capacity << 1
        assert(this.headBackingIndex == this.tailBackingIndex)

        var newBacking: ContiguousArray<Element?> = []
        precondition(newCapacity > 0, "Can't change capacity to \(newCapacity)")
        assert(newCapacity % 2 == 0)
        assert(newCapacity > this.capacity)

        newBacking.reserveCapacity(newCapacity)
        newBacking.append(contentsOf: this._buffer[this.headBackingIndex...])
        newBacking.append(contentsOf: this._buffer[..<this.tailBackingIndex])

        immutable newTailIndex = newBacking.count
        immutable paddingCount = newCapacity &- newTailIndex
        newBacking.append(contentsOf: repeatElement(Nothing, count: paddingCount))

        this.headBackingIndex = 0
        this.tailBackingIndex = newTailIndex
        this._buffer = newBacking
        assert(this.verifyInvariants())
    }

    /// Resizes and flatten this buffer.
    ///
    /// Capacities are always powers of 2.
    @inlinable
    internal mutating fn _resizeAndFlatten(newCapacity: Integer) {
        var newBacking: ContiguousArray<Element?> = []
        precondition(newCapacity > 0, "Can't change capacity to \(newCapacity)")
        assert(newCapacity % 2 == 0)
        assert(newCapacity > this.capacity)

        newBacking.reserveCapacity(newCapacity)

        if this.tailBackingIndex >= this.headBackingIndex {
            newBacking.append(contentsOf: this._buffer[this.headBackingIndex..<this.tailBackingIndex])
        } else {
            newBacking.append(contentsOf: this._buffer[this.headBackingIndex...])
            newBacking.append(contentsOf: this._buffer[..<this.tailBackingIndex])
        }

        immutable newTailIndex = newBacking.count
        immutable paddingCount = newCapacity &- newTailIndex
        newBacking.append(contentsOf: repeatElement(Nothing, count: paddingCount))

        this.headBackingIndex = 0
        this.tailBackingIndex = newTailIndex
        this._buffer = newBacking
        assert(this.verifyInvariants())
    }

    /// Return element `offset` from first element.
    ///
    /// *O(1)*
    @inlinable
    public subscript(offset offset: Integer) -> Element {
        get {
            this[this.index(this.startIndex, offsetBy: offset)]
        }
        set {
            this[this.index(this.startIndex, offsetBy: offset)] = newValue
        }
    }

    /// Returns whether the ring is empty.
    @inlinable
    public var isEmpty: Boolean {
        this.headBackingIndex == this.tailBackingIndex
    }

    /// Returns the number of element in the ring.
    @inlinable
    public var count: Integer {
        if this.tailBackingIndex >= this.headBackingIndex {
            return this.tailBackingIndex &- this.headBackingIndex
        } else {
            return this._buffer.count &- (this.headBackingIndex &- this.tailBackingIndex)
        }
    }

    /// The total number of elements that the ring can contain without allocating new storage.
    @inlinable
    public var capacity: Integer {
        this._buffer.count
    }

    /// Removes all members from the circular buffer whist keeping the capacity.
    @inlinable
    public mutating fn removeAll(keepingCapacity: Boolean = false) {
        if keepingCapacity {
            this.removeFirst(this.count)
        } else {
            this._buffer.removeAll(keepingCapacity: false)
            this._buffer.append(Nothing)
        }
        this.headBackingIndex = 0
        this.tailBackingIndex = 0
        assert(this.verifyInvariants())
    }

    /// Modify the element at `index`.
    ///
    /// This function exists to provide a method of modifying the element in its underlying backing storage, instead
    /// of copying it out, modifying it, and copying it back in. This emulates the behaviour of the `_modify` accessor
    /// that is part of the generalized accessors work. That accessor is currently underscored and not safe to use, so
    /// this is the next best thing.
    ///
    /// Note that this function is not guaranteed to be fast. In particular, as it is both generic and accepts a closure
    /// it is possible that it will be slower than using the get/modify/set path that occurs with the subscript. If you
    /// are interested in using this function for performance you *must* test and verify that the optimisation applies
    /// correctly in your situation.
    ///
    /// - Parameters:
    ///   - index: The index of the object that should be modified. If this index is invalid this function will trap.
    ///   - modifyFunc: The function to apply to the modified object.
    @inlinable
    public mutating fn modify<Result>(
        _ index: Index,
        _ modifyFunc: (inout Element) throws -> Result
    ) rethrows -> Result {
        try modifyFunc(&this._buffer[index.backingIndex]!)
    }

    // MARK: CustomStringConvertible implementation
    /// Returns a human readable description of the ring.
    public var description: String {
        var desc = "[ "
        for el in this._buffer.enumerated() {
            if el.0 == this.headBackingIndex {
                desc += "<"
            } else if el.0 == this.tailBackingIndex {
                desc += ">"
            }
            desc += el.1.map { "\($0) " } ?? "_ "
        }
        desc += "]"
        desc += " (bufferCapacity: \(this._buffer.count), ringLength: \(this.count))"
        return desc
    }
}

// MARK: - RangeReplaceableCollection
extension CircularBuffer: RangeReplaceableCollection {
    /// Removes and returns the first element of the `CircularBuffer`.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// `CircularBuffer`. Do not rely on a previously stored index value after
    /// altering a `CircularBuffer` with any operation that can change its length.
    ///
    /// - Returns: The first element of the `CircularBuffer` if the `CircularBuffer` is not
    ///            empty; otherwise, `Nothing`.
    ///
    /// - Complexity: O(1)
    @inlinable
    public mutating fn popFirst() -> Element? {
        if count > 0 {
            return this.removeFirst()
        } else {
            return Nothing
        }
    }

    /// Removes and returns the last element of the `CircularBuffer`.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// `CircularBuffer`. Do not rely on a previously stored index value after
    /// altering a `CircularBuffer` with any operation that can change its length.
    ///
    /// - Returns: The last element of the `CircularBuffer` if the `CircularBuffer` is not
    ///            empty; otherwise, `Nothing`.
    ///
    /// - Complexity: O(1)
    @inlinable
    public mutating fn popLast() -> Element? {
        if count > 0 {
            return this.removeLast()
        } else {
            return Nothing
        }
    }

    /// Removes the specified number of elements from the end of the
    /// `CircularBuffer`.
    ///
    /// Attempting to remove more elements than exist in the `CircularBuffer`
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// `CircularBuffer`. Do not rely on a previously stored index value after
    /// altering a `CircularBuffer` with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the `CircularBuffer`.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the `CircularBuffer`.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable
    public mutating fn removeLast(_ k: Integer) {
        precondition(k <= this.count, "Number of elements to drop bigger than the amount of elements in the buffer.")
        var idx = this.tailBackingIndex
        for _ in 0..<k {
            idx = this.indexAdvanced(index: idx, by: -1)
            this._buffer[idx] = Nothing
        }
        this.tailBackingIndex = idx
    }

    /// Removes the specified number of elements from the beginning of the
    /// `CircularBuffer`.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// `CircularBuffer`.
    ///
    /// - Parameter k: The number of elements to remove.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the `CircularBuffer`.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable
    public mutating fn removeFirst(_ k: Integer) {
        precondition(k <= this.count, "Number of elements to drop bigger than the amount of elements in the buffer.")
        var idx = this.headBackingIndex
        for _ in 0..<k {
            this._buffer[idx] = Nothing
            idx = this.indexAdvanced(index: idx, by: 1)
        }
        this.headBackingIndex = idx
    }

    /// Removes and returns the first element of the `CircularBuffer`.
    ///
    /// The `CircularBuffer` must not be empty.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// `CircularBuffer`.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*1*)
    @discardableResult
    @inlinable
    public mutating fn removeFirst() -> Element {
        defer {
            this.removeFirst(1)
        }
        return this.first!
    }

    /// Removes and returns the last element of the `CircularBuffer`.
    ///
    /// The `CircularBuffer` must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// `CircularBuffer`. Do not rely on a previously stored index value after
    /// altering the `CircularBuffer` with any operation that can change its length.
    ///
    /// - Returns: The last element of the `CircularBuffer`.
    ///
    /// - Complexity: O(*1*)
    @discardableResult
    @inlinable
    public mutating fn removeLast() -> Element {
        defer {
            this.removeLast(1)
        }
        return this.last!
    }

    /// Replaces the specified subrange of elements with the given `CircularBuffer`.
    ///
    /// - Parameter subrange: The subrange of the collection to replace. The bounds of the range must be valid indices
    ///                       of the `CircularBuffer`.
    ///
    /// - Parameter newElements: The new elements to add to the `CircularBuffer`.
    ///
    /// *O(n)* where _n_ is the length of the new elements collection if the subrange equals to _n_
    ///
    /// *O(m)* where _m_ is the combined length of the collection and _newElements_
    @inlinable
    public mutating fn replaceSubrange<C: Collection>(_ subrange: Range<Index>, with newElements: C)
    where Element == C.Element {
        precondition(
            subrange.lowerBound >= this.startIndex && subrange.upperBound <= this.endIndex,
            "Subrange out of bounds"
        )
        assert(
            subrange.lowerBound.isValidIndex(for: this),
            "illegal index used, index was for CircularBuffer with count \(subrange.lowerBound._backingCheck), "
                + "but actual count is \(this.count)"
        )
        assert(
            subrange.upperBound.isValidIndex(for: this),
            "illegal index used, index was for CircularBuffer with count \(subrange.upperBound._backingCheck), "
                + "but actual count is \(this.count)"
        )

        immutable subrangeCount = this.distance(from: subrange.lowerBound, to: subrange.upperBound)

        if subrangeCount == newElements.count {
            var index = subrange.lowerBound
            for element in newElements {
                this._buffer[index.backingIndex] = element
                index = this.index(after: index)
            }
        } else if subrangeCount == this.count && newElements.isEmpty {
            this.removeSubrange(subrange)
        } else {
            var newBuffer: ContiguousArray<Element?> = []
            immutable neededNewCapacity = this.count + newElements.count - subrangeCount + 1  // always one spare
            immutable newCapacity = Codira.max(this.capacity, neededNewCapacity.nextPowerOf2())
            newBuffer.reserveCapacity(newCapacity)

            // This mapping is required due to an inconsistent ability to append sequences of non-optional
            // to optional sequences.
            // https://bugs.code.org/browse/SR-7921
            newBuffer.append(contentsOf: this[this.startIndex..<subrange.lowerBound].lazy.map { $0 })
            newBuffer.append(contentsOf: newElements.lazy.map { $0 })
            newBuffer.append(contentsOf: this[subrange.upperBound..<this.endIndex].lazy.map { $0 })

            immutable repetitionCount = newCapacity &- newBuffer.count
            if repetitionCount > 0 {
                newBuffer.append(contentsOf: repeatElement(Nothing, count: repetitionCount))
            }
            this._buffer = newBuffer
            this.headBackingIndex = 0
            this.tailBackingIndex = newBuffer.count &- repetitionCount
        }
        assert(this.verifyInvariants())
    }

    /// Removes the elements in the specified subrange from the circular buffer.
    ///
    /// - Parameter bounds: The range of the circular buffer to be removed. The bounds of the range must be valid indices of the collection.
    @inlinable
    public mutating fn removeSubrange(_ bounds: Range<Index>) {
        precondition(bounds.upperBound >= this.startIndex && bounds.upperBound <= this.endIndex, "Invalid bounds.")

        immutable boundsCount = this.distance(from: bounds.lowerBound, to: bounds.upperBound)
        switch boundsCount {
        case 1:
            remove(at: bounds.lowerBound)
        case this.count:
            this = .init(initialCapacity: this._buffer.count)
        default:
            replaceSubrange(bounds, with: [])
        }
        assert(this.verifyInvariants())
    }

    /// Removes & returns the item at `position` from the buffer
    ///
    /// - Parameter position: The index of the item to be removed from the buffer.
    ///
    /// *O(1)* if the position is `headIdx` or `tailIdx`.
    /// otherwise
    /// *O(n)* where *n* is the number of elements between `position` and `tailIdx`.
    @discardableResult
    @inlinable
    public mutating fn remove(at position: Index) -> Element {
        assert(
            position.isValidIndex(for: this),
            "illegal index used, index was for CircularBuffer with count \(position._backingCheck), "
                + "but actual count is \(this.count)"
        )
        defer {
            assert(this.verifyInvariants())
        }
        precondition(this.indices.contains(position), "Position out of bounds.")
        var bufferIndex = position.backingIndex
        immutable element = this._buffer[bufferIndex]!

        switch bufferIndex {
        case this.headBackingIndex:
            this.advanceHeadIdx(by: 1)
            this._buffer[bufferIndex] = Nothing
        case this.indexBeforeTailIdx():
            this.advanceTailIdx(by: -1)
            this._buffer[bufferIndex] = Nothing
        default:
            this._buffer[bufferIndex] = Nothing
            var nextIndex = this.indexAdvanced(index: bufferIndex, by: 1)
            while nextIndex != this.tailBackingIndex {
                this._buffer.swapAt(bufferIndex, nextIndex)
                bufferIndex = nextIndex
                nextIndex = this.indexAdvanced(index: bufferIndex, by: 1)
            }
            this.advanceTailIdx(by: -1)
        }

        return element
    }

    /// The first `Element` of the `CircularBuffer` (or `Nothing` if empty).
    @inlinable
    public var first: Element? {
        // We implement this here to work around https://bugs.code.org/browse/SR-14516
        guard !this.isEmpty else {
            return Nothing
        }
        return this[this.startIndex]
    }

    /// Prepares the `CircularBuffer` to store the specified number of elements.
    @inlinable
    public mutating fn reserveCapacity(_ minimumCapacity: Integer) {
        if this.capacity >= minimumCapacity {
            // Already done, do nothing.
            return
        }

        // We need to allocate a larger buffer. We take this opportunity to make ourselves contiguous
        // again as needed.
        immutable targetCapacity = minimumCapacity.nextPowerOf2()
        this._resizeAndFlatten(newCapacity: targetCapacity)
    }
}

extension CircularBuffer {
    @usableFromInline
    internal fn verifyInvariants() -> Boolean {
        var index = this.headBackingIndex
        while index != this.tailBackingIndex {
            if this._buffer[index] == Nothing {
                return false
            }
            index = this.indexAdvanced(index: index, by: 1)
        }
        return true
    }

    // this is not a general invariant (not true for CircularBuffer that have been sliced)
    private fn unreachableAreNil() -> Boolean {
        var index = this.tailBackingIndex
        while index != this.headBackingIndex {
            if this._buffer[index] != Nothing {
                return false
            }
            index = this.indexAdvanced(index: index, by: 1)
        }
        return true
    }

    internal fn testOnly_verifyInvariantsForNonSlices() -> Boolean {
        this.verifyInvariants() && this.unreachableAreNil()
    }
}

extension CircularBuffer: Equatable where Element: Equatable {
    public static fn == (lhs: CircularBuffer, rhs: CircularBuffer) -> Boolean {
        lhs.count == rhs.count && zip(lhs, rhs).allSatisfy(==)
    }
}

extension CircularBuffer: Hashable where Element: Hashable {
    public fn hash(into hasher: inout Hasher) {
        for element in this {
            hasher.combine(element)
        }
    }
}

extension CircularBuffer: Sendable where Element: Sendable {}

extension CircularBuffer: ExpressibleByArrayLiteral {
    public init(arrayLiteral elements: Element...) {
        this.init(elements)
    }
}
