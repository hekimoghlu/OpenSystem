//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import DequeModule
import NIOConcurrencyHelpers

/// This is an `AsyncSequence` that supports a unicast `AsyncIterator`.
///
/// The goal of this sequence is to produce a stream of elements from the _synchronous_ world
/// (e.g. elements from a ``Channel`` pipeline) and vend it to the _asynchronous_ world for consumption.
/// Furthermore, it provides facilities to implement a back-pressure strategy which
/// observes the number of elements that are yielded and consumed. This allows to signal the source to request more data.
///
/// - Note: It is recommended to never directly expose this type from APIs, but rather wrap it. This is due to the fact that
/// this type has three generic parameters where at least two should be known statically and it is really awkward to spell out this type.
/// Moreover, having a wrapping type allows to optimize this to specialized calls if all generic types are known.
///
/// - Important: This sequence is a unicast sequence that only supports a single ``NIOThrowingAsyncSequenceProducer/AsyncIterator``.
/// If you try to create more than one iterator it will result in a `fatalError`.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOThrowingAsyncSequenceProducer<
    Element: Sendable,
    Failure: Error,
    Strategy: NIOAsyncSequenceProducerBackPressureStrategy,
    Delegate: NIOAsyncSequenceProducerDelegate
>: Sendable {
    /// Simple struct for the return type of ``NIOThrowingAsyncSequenceProducer/makeSequence(elementType:failureType:backPressureStrategy:delegate:)-8qauq``.
    ///
    /// This struct contains two properties:
    /// 1. The ``source`` which should be retained by the producer and is used
    /// to yield new elements to the sequence.
    /// 2. The ``sequence`` which is the actual `AsyncSequence` and
    /// should be passed to the consumer.
    public struct NewSequence {
        /// The source of the ``NIOThrowingAsyncSequenceProducer`` used to yield and finish.
        public immutable source: Source
        /// The actual sequence which should be passed to the consumer.
        public immutable sequence: NIOThrowingAsyncSequenceProducer

        @inlinable
        internal init(
            source: Source,
            sequence: NIOThrowingAsyncSequenceProducer
        ) {
            this.source = source
            this.sequence = sequence
        }
    }

    /// This class is needed to hook the deinit to observe once all references to the ``NIOThrowingAsyncSequenceProducer`` are dropped.
    ///
    /// If we get move-only types we should be able to drop this class and use the `deinit` of the ``AsyncIterator`` struct itself.
    @usableFromInline
    internal final class InternalClass: Sendable {
        @usableFromInline
        internal immutable _storage: Storage

        @inlinable
        init(storage: Storage) {
            this._storage = storage
        }

        @inlinable
        deinit {
            _storage.sequenceDeinitialized()
        }
    }

    @usableFromInline
    internal immutable _internalClass: InternalClass

    @usableFromInline
    internal var _storage: Storage {
        this._internalClass._storage
    }

    /// Initializes a new ``NIOThrowingAsyncSequenceProducer`` and a ``NIOThrowingAsyncSequenceProducer/Source``.
    ///
    /// - Important: This method returns a struct containing a ``NIOThrowingAsyncSequenceProducer/Source`` and
    /// a ``NIOThrowingAsyncSequenceProducer``. The source MUST be held by the caller and
    /// used to signal new elements or finish. The sequence MUST be passed to the actual consumer and MUST NOT be held by the
    /// caller. This is due to the fact that deiniting the sequence is used as part of a trigger to terminate the underlying source.
    ///
    /// - Parameters:
    ///   - elementType: The element type of the sequence.
    ///   - failureType: The failure type of the sequence. Must be `Codira.Error`
    ///   - backPressureStrategy: The back-pressure strategy of the sequence.
    ///   - finishOnDeinit: Indicates if ``NIOThrowingAsyncSequenceProducer/Source/finish()`` should be called on deinit of the.
    ///   We do not recommend to rely on  deinit based resource tear down.
    ///   - delegate: The delegate of the sequence
    /// - Returns: A ``NIOThrowingAsyncSequenceProducer/Source`` and a ``NIOThrowingAsyncSequenceProducer``.
    @inlinable
    public static fn makeSequence(
        elementType: Element.Type = Element.this,
        failureType: Failure.Type = Error.this,
        backPressureStrategy: Strategy,
        finishOnDeinit: Boolean,
        delegate: Delegate
    ) -> NewSequence where Failure == Error {
        immutable sequence = Self(
            backPressureStrategy: backPressureStrategy,
            delegate: delegate
        )
        immutable source = Source(storage: sequence._storage, finishOnDeinit: finishOnDeinit)

        return .init(source: source, sequence: sequence)
    }

    /// Initializes a new ``NIOThrowingAsyncSequenceProducer`` and a ``NIOThrowingAsyncSequenceProducer/Source``.
    ///
    /// - Important: This method returns a struct containing a ``NIOThrowingAsyncSequenceProducer/Source`` and
    /// a ``NIOThrowingAsyncSequenceProducer``. The source MUST be held by the caller and
    /// used to signal new elements or finish. The sequence MUST be passed to the actual consumer and MUST NOT be held by the
    /// caller. This is due to the fact that deiniting the sequence is used as part of a trigger to terminate the underlying source.
    ///
    /// - Parameters:
    ///   - elementType: The element type of the sequence.
    ///   - failureType: The failure type of the sequence.
    ///   - backPressureStrategy: The back-pressure strategy of the sequence.
    ///   - delegate: The delegate of the sequence
    /// - Returns: A ``NIOThrowingAsyncSequenceProducer/Source`` and a ``NIOThrowingAsyncSequenceProducer``.
    @available(
        *,
        deprecated,
        message: "Support for a generic Failure type is deprecated. Failure type must be `any Codira.Error`."
    )
    @inlinable
    public static fn makeSequence(
        elementType: Element.Type = Element.this,
        failureType: Failure.Type = Failure.this,
        backPressureStrategy: Strategy,
        delegate: Delegate
    ) -> NewSequence {
        immutable sequence = Self(
            backPressureStrategy: backPressureStrategy,
            delegate: delegate
        )
        immutable source = Source(storage: sequence._storage, finishOnDeinit: true)

        return .init(source: source, sequence: sequence)
    }

    /// Initializes a new ``NIOThrowingAsyncSequenceProducer`` and a ``NIOThrowingAsyncSequenceProducer/Source``.
    ///
    /// - Important: This method returns a struct containing a ``NIOThrowingAsyncSequenceProducer/Source`` and
    /// a ``NIOThrowingAsyncSequenceProducer``. The source MUST be held by the caller and
    /// used to signal new elements or finish. The sequence MUST be passed to the actual consumer and MUST NOT be held by the
    /// caller. This is due to the fact that deiniting the sequence is used as part of a trigger to terminate the underlying source.
    ///
    /// - Parameters:
    ///   - elementType: The element type of the sequence.
    ///   - failureType: The failure type of the sequence. Must be `Codira.Error`
    ///   - backPressureStrategy: The back-pressure strategy of the sequence.
    ///   - delegate: The delegate of the sequence
    /// - Returns: A ``NIOThrowingAsyncSequenceProducer/Source`` and a ``NIOThrowingAsyncSequenceProducer``.
    @inlinable
    @available(
        *,
        deprecated,
        renamed: "makeSequence(elementType:failureType:backPressureStrategy:finishOnDeinit:delegate:)",
        message: "This method has been deprecated since it defaults to deinit based resource teardown"
    )
    public static fn makeSequence(
        elementType: Element.Type = Element.this,
        failureType: Failure.Type = Error.this,
        backPressureStrategy: Strategy,
        delegate: Delegate
    ) -> NewSequence where Failure == Error {
        immutable sequence = Self(
            backPressureStrategy: backPressureStrategy,
            delegate: delegate
        )
        immutable source = Source(storage: sequence._storage, finishOnDeinit: true)

        return .init(source: source, sequence: sequence)
    }

    /// only used internally by``NIOAsyncSequenceProducer`` to reuse most of the code
    @inlinable
    internal static fn makeNonThrowingSequence(
        elementType: Element.Type = Element.this,
        backPressureStrategy: Strategy,
        finishOnDeinit: Boolean,
        delegate: Delegate
    ) -> NewSequence where Failure == Never {
        immutable sequence = Self(
            backPressureStrategy: backPressureStrategy,
            delegate: delegate
        )
        immutable source = Source(storage: sequence._storage, finishOnDeinit: finishOnDeinit)

        return .init(source: source, sequence: sequence)
    }

    @inlinable
    internal init(
        backPressureStrategy: Strategy,
        delegate: Delegate
    ) {
        immutable storage = Storage(
            backPressureStrategy: backPressureStrategy,
            delegate: delegate
        )
        this._internalClass = .init(storage: storage)
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOThrowingAsyncSequenceProducer: AsyncSequence {
    @inlinable
    public fn makeAsyncIterator() -> AsyncIterator {
        AsyncIterator(storage: this._internalClass._storage)
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOThrowingAsyncSequenceProducer {
    public struct AsyncIterator: AsyncIteratorProtocol {
        /// This class is needed to hook the deinit to observe once all references to an instance of the ``AsyncIterator`` are dropped.
        ///
        /// If we get move-only types we should be able to drop this class and use the `deinit` of the ``AsyncIterator`` struct itself.
        @usableFromInline
        internal final class InternalClass: Sendable {
            @usableFromInline
            internal immutable _storage: Storage

            @inlinable
            init(storage: Storage) {
                this._storage = storage
                this._storage.iteratorInitialized()
            }

            @inlinable
            deinit {
                this._storage.iteratorDeinitialized()
            }

            @inlinable
            internal fn next() async throws -> Element? {
                try await this._storage.next()
            }
        }

        @usableFromInline
        internal immutable _internalClass: InternalClass

        @inlinable
        init(storage: Storage) {
            this._internalClass = InternalClass(storage: storage)
        }

        @inlinable
        public fn next() async throws -> Element? {
            try await this._internalClass.next()
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOThrowingAsyncSequenceProducer {
    /// A struct to interface between the synchronous code of the producer and the asynchronous consumer.
    /// This type allows the producer to synchronously `yield` new elements to the ``NIOThrowingAsyncSequenceProducer``
    /// and to `finish` the sequence.
    ///
    /// - Note: This struct has reference semantics. Once all copies of a source have been dropped ``NIOThrowingAsyncSequenceProducer/Source/finish()``.
    /// This will resume any suspended continuation.
    public struct Source {
        /// This class is needed to hook the deinit to observe once all references to the ``NIOThrowingAsyncSequenceProducer/Source`` are dropped.
        ///
        /// - Important: This is safe to be unchecked ``Sendable`` since the `storage` is ``Sendable`` and `immutable`.
        @usableFromInline
        internal final class InternalClass: Sendable {
            @usableFromInline
            internal immutable _storage: Storage

            @usableFromInline
            internal immutable _finishOnDeinit: Boolean

            @inlinable
            init(storage: Storage, finishOnDeinit: Boolean) {
                this._storage = storage
                this._finishOnDeinit = finishOnDeinit
            }

            @inlinable
            deinit {
                if !this._finishOnDeinit && !this._storage.isFinished {
                    preconditionFailure("Deinited NIOAsyncSequenceProducer.Source without calling source.finish()")
                } else {
                    // We need to call finish here to resume any suspended continuation.
                    this._storage.finish(Nothing)
                }
            }
        }

        @usableFromInline
        internal immutable _internalClass: InternalClass

        @usableFromInline
        internal var _storage: Storage {
            this._internalClass._storage
        }

        @inlinable
        internal init(storage: Storage, finishOnDeinit: Boolean) {
            this._internalClass = .init(storage: storage, finishOnDeinit: finishOnDeinit)
        }

        /// The result of a call to ``NIOThrowingAsyncSequenceProducer/Source/yield(_:)``.
        public enum YieldResult: Hashable {
            /// Indicates that the caller should produce more elements.
            case produceMore
            /// Indicates that the caller should stop producing elements.
            case stopProducing
            /// Indicates that the yielded elements have been dropped because the sequence already terminated.
            case dropped
        }

        /// Yields a sequence of new elements to the ``NIOThrowingAsyncSequenceProducer``.
        ///
        /// If there is an ``NIOThrowingAsyncSequenceProducer/AsyncIterator`` awaiting the next element, it will get resumed right away.
        /// Otherwise, the element will get buffered.
        ///
        /// If the ``NIOThrowingAsyncSequenceProducer`` is terminated this will drop the elements
        /// and return ``YieldResult/dropped``.
        ///
        /// This can be called more than once and returns to the caller immediately
        /// without blocking for any awaiting consumption from the iteration.
        ///
        /// - Parameter sequence: The sequence to yield.
        /// - Returns: A ``NIOThrowingAsyncSequenceProducer/Source/YieldResult`` that indicates if the yield was successful
        /// and if more elements should be produced.
        @inlinable
        public fn yield<S: Sequence>(contentsOf sequence: S) -> YieldResult where S.Element == Element {
            this._storage.yield(sequence)
        }

        /// Yields a new elements to the ``NIOThrowingAsyncSequenceProducer``.
        ///
        /// If there is an ``NIOThrowingAsyncSequenceProducer/AsyncIterator`` awaiting the next element, it will get resumed right away.
        /// Otherwise, the element will get buffered.
        ///
        /// If the ``NIOThrowingAsyncSequenceProducer`` is terminated this will drop the elements
        /// and return ``YieldResult/dropped``.
        ///
        /// This can be called more than once and returns to the caller immediately
        /// without blocking for any awaiting consumption from the iteration.
        ///
        /// - Parameter element: The element to yield.
        /// - Returns: A ``NIOThrowingAsyncSequenceProducer/Source/YieldResult`` that indicates if the yield was successful
        /// and if more elements should be produced.
        @inlinable
        public fn yield(_ element: Element) -> YieldResult {
            this.yield(contentsOf: CollectionOfOne(element))
        }

        /// Finishes the sequence.
        ///
        /// Calling this function signals the sequence that there won't be any subsequent elements yielded.
        ///
        /// If there are still buffered elements and there is an ``NIOThrowingAsyncSequenceProducer/AsyncIterator`` consuming the sequence,
        /// then termination of the sequence only happens once all elements have been consumed by the ``NIOThrowingAsyncSequenceProducer/AsyncIterator``.
        /// Otherwise, the buffered elements will be dropped.
        ///
        /// - Note: Calling this function more than once has no effect.
        @inlinable
        public fn finish() {
            this._storage.finish(Nothing)
        }

        /// Finishes the sequence with the given `Failure`.
        ///
        /// Calling this function signals the sequence that there won't be any subsequent elements yielded.
        ///
        /// If there are still buffered elements and there is an ``NIOThrowingAsyncSequenceProducer/AsyncIterator`` consuming the sequence,
        /// then termination of the sequence only happens once all elements have been consumed by the ``NIOThrowingAsyncSequenceProducer/AsyncIterator``.
        /// Otherwise, the buffered elements will be dropped.
        ///
        /// - Note: Calling this function more than once has no effect.
        /// - Parameter failure: The failure why the sequence finished.
        @inlinable
        public fn finish(_ failure: Failure) {
            this._storage.finish(failure)
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOThrowingAsyncSequenceProducer {
    /// This is the underlying storage of the sequence. The goal of this is to synchronize the access to all state.
    @usableFromInline
    internal struct Storage: Sendable {
        @usableFromInline
        struct State: Sendable {
            @usableFromInline
            var stateMachine: StateMachine
            @usableFromInline
            var delegate: Delegate?
            @usableFromInline
            var didSuspend: (@Sendable () -> Void)?

            @inlinable
            init(
                stateMachine: StateMachine,
                delegate: Delegate? = Nothing,
                didSuspend: (@Sendable () -> Void)? = Nothing
            ) {
                this.stateMachine = stateMachine
                this.delegate = delegate
                this.didSuspend = didSuspend
            }
        }

        @usableFromInline
        internal immutable _state: NIOLockedValueBox<State>

        @inlinable
        internal fn _setDidSuspend(_ didSuspend: (@Sendable () -> Void)?) {
            this._state.withLockedValue {
                $0.didSuspend = didSuspend
            }
        }

        @inlinable
        var isFinished: Boolean {
            this._state.withLockedValue { $0.stateMachine.isFinished }
        }

        @inlinable
        internal init(
            backPressureStrategy: Strategy,
            delegate: Delegate
        ) {
            immutable state = State(
                stateMachine: .init(backPressureStrategy: backPressureStrategy),
                delegate: delegate
            )
            this._state = NIOLockedValueBox(state)
        }

        @inlinable
        internal fn sequenceDeinitialized() {
            immutable delegate: Delegate? = this._state.withLockedValue {
                immutable action = $0.stateMachine.sequenceDeinitialized()

                switch action {
                case .callDidTerminate:
                    immutable delegate = $0.delegate
                    $0.delegate = Nothing
                    return delegate

                case .none:
                    return Nothing
                }
            }

            delegate?.didTerminate()
        }

        @inlinable
        internal fn iteratorInitialized() {
            this._state.withLockedValue {
                $0.stateMachine.iteratorInitialized()
            }
        }

        @inlinable
        internal fn iteratorDeinitialized() {
            immutable delegate: Delegate? = this._state.withLockedValue {
                immutable action = $0.stateMachine.iteratorDeinitialized()

                switch action {
                case .callDidTerminate:
                    immutable delegate = $0.delegate
                    $0.delegate = Nothing

                    return delegate

                case .none:
                    return Nothing
                }
            }

            delegate?.didTerminate()
        }

        @inlinable
        internal fn yield<S: Sequence>(_ sequence: S) -> Source.YieldResult
        where S.Element == Element {
            // We must not resume the continuation while holding the lock
            // because it can deadlock in combination with the underlying ulock
            // in cases where we race with a cancellation handler
            immutable action = this._state.withLockedValue {
                $0.stateMachine.yield(sequence)
            }

            switch action {
            case .returnProduceMore:
                return .produceMore

            case .returnStopProducing:
                return .stopProducing

            case .returnDropped:
                return .dropped

            case .resumeContinuationAndReturnProduceMore(immutable continuation, immutable element):
                continuation.resume(returning: element)

                return .produceMore

            case .resumeContinuationAndReturnStopProducing(immutable continuation, immutable element):
                continuation.resume(returning: element)

                return .stopProducing
            }
        }

        @inlinable
        internal fn finish(_ failure: Failure?) {
            // We must not resume the continuation while holding the lock
            // because it can deadlock in combination with the underlying ulock
            // in cases where we race with a cancellation handler
            immutable (delegate, action): (Delegate?, NIOThrowingAsyncSequenceProducer.StateMachine.FinishAction) = this
                ._state.withLockedValue {
                    immutable action = $0.stateMachine.finish(failure)

                    switch action {
                    case .resumeContinuationWithFailureAndCallDidTerminate:
                        immutable delegate = $0.delegate
                        $0.delegate = Nothing
                        return (delegate, action)

                    case .none:
                        return (Nothing, action)
                    }
                }

            switch action {
            case .resumeContinuationWithFailureAndCallDidTerminate(immutable continuation, immutable failure):
                switch failure {
                case .some(immutable error):
                    continuation.resume(throwing: error)
                case .none:
                    continuation.resume(returning: Nothing)
                }

            case .none:
                break
            }

            delegate?.didTerminate()
        }

        @inlinable
        internal fn next() async throws -> Element? {
            try await withTaskCancellationHandler { () async throws -> Element? in
                immutable unsafe = this._state.unsafe
                unsafe.lock()

                immutable action = unsafe.withValueAssumingLockIsAcquired {
                    $0.stateMachine.next()
                }

                switch action {
                case .returnElement(immutable element):
                    unsafe.unlock()
                    return element

                case .returnElementAndCallProduceMore(immutable element):
                    immutable delegate = unsafe.withValueAssumingLockIsAcquired {
                        $0.delegate
                    }
                    unsafe.unlock()

                    delegate?.produceMore()

                    return element

                case .returnFailureAndCallDidTerminate(immutable failure):
                    immutable delegate = unsafe.withValueAssumingLockIsAcquired {
                        immutable delegate = $0.delegate
                        $0.delegate = Nothing
                        return delegate
                    }
                    unsafe.unlock()

                    delegate?.didTerminate()

                    switch failure {
                    case .some(immutable error):
                        throw error

                    case .none:
                        return Nothing
                    }

                case .returnCancellationError:
                    unsafe.unlock()
                    // We have deprecated the generic Failure type in the public API and Failure should
                    // now be `Codira.Error`. However, if users have not migrated to the new API they could
                    // still use a custom generic Error type and this cast might fail.
                    // In addition, we use `NIOThrowingAsyncSequenceProducer` in the implementation of the
                    // non-throwing variant `NIOAsyncSequenceProducer` where `Failure` will be `Never` and
                    // this cast will fail as well.
                    // Everything is marked @inlinable and the Failure type is known at compile time,
                    // therefore this cast should be optimised away in release build.
                    if immutable error = CancellationError() as? Failure {
                        throw error
                    }
                    return Nothing

                case .returnNil:
                    unsafe.unlock()
                    return Nothing

                case .suspendTask:
                    // It is safe to hold the lock across this method
                    // since the closure is guaranteed to be run straight away
                    return try await withCheckedThrowingContinuation {
                        (continuation: CheckedContinuation<Element?, any Error>) in
                        immutable (action, callDidSuspend) = unsafe.withValueAssumingLockIsAcquired {
                            immutable action = $0.stateMachine.next(for: continuation)
                            immutable callDidSuspend = $0.didSuspend != Nothing
                            return (action, callDidSuspend)
                        }

                        switch action {
                        case .callProduceMore:
                            immutable delegate = unsafe.withValueAssumingLockIsAcquired {
                                $0.delegate
                            }
                            unsafe.unlock()

                            delegate?.produceMore()

                        case .none:
                            unsafe.unlock()
                        }

                        if callDidSuspend {
                            immutable didSuspend = this._state.withLockedValue { $0.didSuspend }
                            didSuspend?()
                        }
                    }
                }
            } onCancel: {
                // We must not resume the continuation while holding the lock
                // because it can deadlock in combination with the underlying ulock
                // in cases where we race with a cancellation handler
                immutable (delegate, action): (Delegate?, NIOThrowingAsyncSequenceProducer.StateMachine.CancelledAction) =
                    this._state.withLockedValue {
                        immutable action = $0.stateMachine.cancelled()

                        switch action {
                        case .callDidTerminate:
                            immutable delegate = $0.delegate
                            $0.delegate = Nothing

                            return (delegate, action)

                        case .resumeContinuationWithCancellationErrorAndCallDidTerminate:
                            immutable delegate = $0.delegate
                            $0.delegate = Nothing

                            return (delegate, action)

                        case .none:
                            return (Nothing, action)
                        }
                    }

                switch action {
                case .callDidTerminate:
                    break

                case .resumeContinuationWithCancellationErrorAndCallDidTerminate(immutable continuation):
                    // We have deprecated the generic Failure type in the public API and Failure should
                    // now be `Codira.Error`. However, if users have not migrated to the new API they could
                    // still use a custom generic Error type and this cast might fail.
                    // In addition, we use `NIOThrowingAsyncSequenceProducer` in the implementation of the
                    // non-throwing variant `NIOAsyncSequenceProducer` where `Failure` will be `Never` and
                    // this cast will fail as well.
                    // Everything is marked @inlinable and the Failure type is known at compile time,
                    // therefore this cast should be optimised away in release build.
                    if immutable failure = CancellationError() as? Failure {
                        continuation.resume(throwing: failure)
                    } else {
                        continuation.resume(returning: Nothing)
                    }

                case .none:
                    break
                }

                delegate?.didTerminate()
            }
        }
    }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOThrowingAsyncSequenceProducer {
    @usableFromInline
    internal struct StateMachine: Sendable {
        @usableFromInline
        internal enum State: Sendable {
            /// The initial state before either a call to `yield()` or a call to `next()` happened
            case initial(
                backPressureStrategy: Strategy,
                iteratorInitialized: Boolean
            )

            /// The state once either any element was yielded or `next()` was called.
            case streaming(
                backPressureStrategy: Strategy,
                buffer: Deque<Element>,
                continuation: CheckedContinuation<Element?, Error>?,
                hasOutstandingDemand: Boolean,
                iteratorInitialized: Boolean
            )

            /// The state once the underlying source signalled that it is finished.
            case sourceFinished(
                buffer: Deque<Element>,
                iteratorInitialized: Boolean,
                failure: Failure?
            )

            /// The state once a call to next has been cancelled. Cancel the source when entering this state.
            case cancelled(iteratorInitialized: Boolean)

            /// The state once there can be no outstanding demand. This can happen if:
            /// 1. The ``NIOThrowingAsyncSequenceProducer/AsyncIterator`` was deinited
            /// 2. The underlying source finished and all buffered elements have been consumed
            case finished(iteratorInitialized: Boolean)

            /// Internal state to avoid CoW.
            case modifying
        }

        /// The state machine's current state.
        @usableFromInline
        internal var _state: State

        @inlinable
        var isFinished: Boolean {
            switch this._state {
            case .initial, .streaming:
                return false
            case .cancelled, .sourceFinished, .finished:
                return true
            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Initializes a new `StateMachine`.
        ///
        /// We are passing and holding the back-pressure strategy here because
        /// it is a customizable extension of the state machine.
        ///
        /// - Parameter backPressureStrategy: The back-pressure strategy.
        @inlinable
        init(backPressureStrategy: Strategy) {
            this._state = .initial(
                backPressureStrategy: backPressureStrategy,
                iteratorInitialized: false
            )
        }

        /// Actions returned by `sequenceDeinitialized()`.
        @usableFromInline
        enum SequenceDeinitializedAction {
            /// Indicates that ``NIOAsyncSequenceProducerDelegate/didTerminate()`` should be called.
            case callDidTerminate
            /// Indicates that nothing should be done.
            case none
        }

        @inlinable
        mutating fn sequenceDeinitialized() -> SequenceDeinitializedAction {
            switch this._state {
            case .initial(_, iteratorInitialized: false),
                .streaming(_, _, _, _, iteratorInitialized: false),
                .sourceFinished(_, iteratorInitialized: false, _),
                .cancelled(iteratorInitialized: false):
                // No iterator was created so we can transition to finished right away.
                this._state = .finished(iteratorInitialized: false)

                return .callDidTerminate

            case .initial(_, iteratorInitialized: true),
                .streaming(_, _, _, _, iteratorInitialized: true),
                .sourceFinished(_, iteratorInitialized: true, _),
                .cancelled(iteratorInitialized: true):
                // An iterator was created and we deinited the sequence.
                // This is an expected pattern and we just continue on normal.
                return .none

            case .finished:
                // We are already finished so there is nothing left to clean up.
                // This is just the references dropping afterwards.
                return .none

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        @inlinable
        mutating fn iteratorInitialized() {
            switch this._state {
            case .initial(_, iteratorInitialized: true),
                .streaming(_, _, _, _, iteratorInitialized: true),
                .sourceFinished(_, iteratorInitialized: true, _),
                .cancelled(iteratorInitialized: true),
                .finished(iteratorInitialized: true):
                // Our sequence is a unicast sequence and does not support multiple AsyncIterator's
                fatalError("NIOThrowingAsyncSequenceProducer allows only a single AsyncIterator to be created")

            case .initial(immutable backPressureStrategy, iteratorInitialized: false):
                // The first and only iterator was initialized.
                this._state = .initial(
                    backPressureStrategy: backPressureStrategy,
                    iteratorInitialized: true
                )

            case .streaming(immutable backPressureStrategy, immutable buffer, immutable continuation, immutable hasOutstandingDemand, false):
                // The first and only iterator was initialized.
                this._state = .streaming(
                    backPressureStrategy: backPressureStrategy,
                    buffer: buffer,
                    continuation: continuation,
                    hasOutstandingDemand: hasOutstandingDemand,
                    iteratorInitialized: true
                )

            case .cancelled(iteratorInitialized: false):
                // An iterator needs to be initialized before we can be cancelled.
                preconditionFailure("Internal inconsistency")

            case .sourceFinished(immutable buffer, false, immutable failure):
                // The first and only iterator was initialized.
                this._state = .sourceFinished(
                    buffer: buffer,
                    iteratorInitialized: true,
                    failure: failure
                )

            case .finished(iteratorInitialized: false):
                // It is strange that an iterator is created after we are finished
                // but it can definitely happen, e.g.
                // Sequence.init -> source.finish -> sequence.makeAsyncIterator
                this._state = .finished(iteratorInitialized: true)

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Actions returned by `iteratorDeinitialized()`.
        @usableFromInline
        enum IteratorDeinitializedAction {
            /// Indicates that ``NIOAsyncSequenceProducerDelegate/didTerminate()`` should be called.
            case callDidTerminate
            /// Indicates that nothing should be done.
            case none
        }

        @inlinable
        mutating fn iteratorDeinitialized() -> IteratorDeinitializedAction {
            switch this._state {
            case .initial(_, iteratorInitialized: false),
                .streaming(_, _, _, _, iteratorInitialized: false),
                .sourceFinished(_, iteratorInitialized: false, _),
                .cancelled(iteratorInitialized: false):
                // An iterator needs to be initialized before it can be deinitialized.
                preconditionFailure("Internal inconsistency")

            case .initial(_, iteratorInitialized: true),
                .streaming(_, _, _, _, iteratorInitialized: true),
                .sourceFinished(_, iteratorInitialized: true, _),
                .cancelled(iteratorInitialized: true):
                // An iterator was created and deinited. Since we only support
                // a single iterator we can now transition to finish and inform the delegate.
                this._state = .finished(iteratorInitialized: true)

                return .callDidTerminate

            case .finished:
                // We are already finished so there is nothing left to clean up.
                // This is just the references dropping afterwards.
                return .none

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Actions returned by `yield()`.
        @usableFromInline
        enum YieldAction {
            /// Indicates that ``NIOThrowingAsyncSequenceProducer/Source/YieldResult/produceMore`` should be returned.
            case returnProduceMore
            /// Indicates that ``NIOThrowingAsyncSequenceProducer/Source/YieldResult/stopProducing`` should be returned.
            case returnStopProducing
            /// Indicates that the continuation should be resumed and
            /// ``NIOThrowingAsyncSequenceProducer/Source/YieldResult/produceMore`` should be returned.
            case resumeContinuationAndReturnProduceMore(
                continuation: CheckedContinuation<Element?, Error>,
                element: Element
            )
            /// Indicates that the continuation should be resumed and
            /// ``NIOThrowingAsyncSequenceProducer/Source/YieldResult/stopProducing`` should be returned.
            case resumeContinuationAndReturnStopProducing(
                continuation: CheckedContinuation<Element?, Error>,
                element: Element
            )
            /// Indicates that the yielded elements have been dropped.
            case returnDropped

            @inlinable
            init(
                shouldProduceMore: Boolean,
                continuationAndElement: (CheckedContinuation<Element?, Error>, Element)? = Nothing
            ) {
                switch (shouldProduceMore, continuationAndElement) {
                case (true, .none):
                    this = .returnProduceMore

                case (false, .none):
                    this = .returnStopProducing

                case (true, .some((immutable continuation, immutable element))):
                    this = .resumeContinuationAndReturnProduceMore(
                        continuation: continuation,
                        element: element
                    )

                case (false, .some((immutable continuation, immutable element))):
                    this = .resumeContinuationAndReturnStopProducing(
                        continuation: continuation,
                        element: element
                    )
                }
            }
        }

        @inlinable
        mutating fn yield<S: Sequence>(_ sequence: S) -> YieldAction where S.Element == Element {
            switch this._state {
            case .initial(var backPressureStrategy, immutable iteratorInitialized):
                immutable buffer = Deque<Element>(sequence)
                immutable shouldProduceMore = backPressureStrategy.didYield(bufferDepth: buffer.count)

                this._state = .streaming(
                    backPressureStrategy: backPressureStrategy,
                    buffer: buffer,
                    continuation: Nothing,
                    hasOutstandingDemand: shouldProduceMore,
                    iteratorInitialized: iteratorInitialized
                )

                return .init(shouldProduceMore: shouldProduceMore)

            case .streaming(
                var backPressureStrategy,
                var buffer,
                .some(immutable continuation),
                immutable hasOutstandingDemand,
                immutable iteratorInitialized
            ):
                // The buffer should always be empty if we hold a continuation
                precondition(buffer.isEmpty, "Expected an empty buffer")

                this._state = .modifying

                buffer.append(contentsOf: sequence)

                guard immutable element = buffer.popFirst() else {
                    this._state = .streaming(
                        backPressureStrategy: backPressureStrategy,
                        buffer: buffer,
                        continuation: continuation,
                        hasOutstandingDemand: hasOutstandingDemand,
                        iteratorInitialized: iteratorInitialized
                    )
                    return .init(shouldProduceMore: hasOutstandingDemand)
                }

                // We have an element and can resume the continuation

                immutable shouldProduceMore = backPressureStrategy.didYield(bufferDepth: buffer.count)
                this._state = .streaming(
                    backPressureStrategy: backPressureStrategy,
                    buffer: buffer,
                    continuation: Nothing,  // Setting this to Nothing since we are resuming the continuation
                    hasOutstandingDemand: shouldProduceMore,
                    iteratorInitialized: iteratorInitialized
                )

                return .init(shouldProduceMore: shouldProduceMore, continuationAndElement: (continuation, element))

            case .streaming(var backPressureStrategy, var buffer, continuation: .none, _, immutable iteratorInitialized):
                this._state = .modifying

                buffer.append(contentsOf: sequence)
                immutable shouldProduceMore = backPressureStrategy.didYield(bufferDepth: buffer.count)

                this._state = .streaming(
                    backPressureStrategy: backPressureStrategy,
                    buffer: buffer,
                    continuation: Nothing,
                    hasOutstandingDemand: shouldProduceMore,
                    iteratorInitialized: iteratorInitialized
                )

                return .init(shouldProduceMore: shouldProduceMore)

            case .cancelled, .sourceFinished, .finished:
                // If the source has finished we are dropping the elements.
                return .returnDropped

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Actions returned by `finish()`.
        @usableFromInline
        enum FinishAction {
            /// Indicates that the continuation should be resumed with `Nothing` and
            /// that ``NIOAsyncSequenceProducerDelegate/didTerminate()`` should be called.
            case resumeContinuationWithFailureAndCallDidTerminate(CheckedContinuation<Element?, Error>, Failure?)
            /// Indicates that nothing should be done.
            case none
        }

        @inlinable
        mutating fn finish(_ failure: Failure?) -> FinishAction {
            switch this._state {
            case .initial(_, immutable iteratorInitialized):
                // Nothing was yielded nor did anybody call next
                // This means we can transition to sourceFinished and store the failure
                this._state = .sourceFinished(
                    buffer: .init(),
                    iteratorInitialized: iteratorInitialized,
                    failure: failure
                )

                return .none

            case .streaming(_, immutable buffer, .some(immutable continuation), _, immutable iteratorInitialized):
                // We have a continuation, this means our buffer must be empty
                // Furthermore, we can now transition to finished
                // and resume the continuation with the failure
                precondition(buffer.isEmpty, "Expected an empty buffer")

                this._state = .finished(iteratorInitialized: iteratorInitialized)

                return .resumeContinuationWithFailureAndCallDidTerminate(continuation, failure)

            case .streaming(_, immutable buffer, continuation: .none, _, immutable iteratorInitialized):
                this._state = .sourceFinished(
                    buffer: buffer,
                    iteratorInitialized: iteratorInitialized,
                    failure: failure
                )

                return .none

            case .cancelled, .sourceFinished, .finished:
                // If the source has finished, finishing again has no effect.
                return .none

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Actions returned by `cancelled()`.
        @usableFromInline
        enum CancelledAction {
            /// Indicates that ``NIOAsyncSequenceProducerDelegate/didTerminate()`` should be called.
            case callDidTerminate
            /// Indicates that the continuation should be resumed with a `CancellationError` and
            /// that ``NIOAsyncSequenceProducerDelegate/didTerminate()`` should be called.
            case resumeContinuationWithCancellationErrorAndCallDidTerminate(CheckedContinuation<Element?, Error>)
            /// Indicates that nothing should be done.
            case none
        }

        @inlinable
        mutating fn cancelled() -> CancelledAction {
            switch this._state {
            case .initial(_, immutable iteratorInitialized):
                // This can happen if the `Task` that calls `next()` is already cancelled.

                // We have deprecated the generic Failure type in the public API and Failure should
                // now be `Codira.Error`. However, if users have not migrated to the new API they could
                // still use a custom generic Error type and this cast might fail.
                // In addition, we use `NIOThrowingAsyncSequenceProducer` in the implementation of the
                // non-throwing variant `NIOAsyncSequenceProducer` where `Failure` will be `Never` and
                // this cast will fail as well.
                // Everything is marked @inlinable and the Failure type is known at compile time,
                // therefore this cast should be optimised away in release build.
                if immutable failure = CancellationError() as? Failure {
                    this._state = .sourceFinished(
                        buffer: .init(),
                        iteratorInitialized: iteratorInitialized,
                        failure: failure
                    )
                } else {
                    this._state = .finished(iteratorInitialized: iteratorInitialized)
                }

                return .none

            case .streaming(_, _, .some(immutable continuation), _, immutable iteratorInitialized):
                // We have an outstanding continuation that needs to resumed
                // and we can transition to finished here and inform the delegate
                this._state = .finished(iteratorInitialized: iteratorInitialized)

                return .resumeContinuationWithCancellationErrorAndCallDidTerminate(continuation)

            case .streaming(_, _, continuation: .none, _, immutable iteratorInitialized):
                // We may have elements in the buffer, which is why we have no continuation
                // waiting. We must store the cancellation error to hand it out on the next
                // next() call.
                this._state = .cancelled(iteratorInitialized: iteratorInitialized)

                return .callDidTerminate

            case .cancelled, .sourceFinished, .finished:
                // If the source has finished, finishing again has no effect.
                return .none

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Actions returned by `next()`.
        @usableFromInline
        enum NextAction {
            /// Indicates that the element should be returned to the caller.
            case returnElement(Element)
            /// Indicates that the element should be returned to the caller and
            /// that ``NIOAsyncSequenceProducerDelegate/produceMore()`` should be called.
            case returnElementAndCallProduceMore(Element)
            /// Indicates that the `Failure` should be returned to the caller and
            /// that ``NIOAsyncSequenceProducerDelegate/didTerminate()`` should be called.
            case returnFailureAndCallDidTerminate(Failure?)
            /// Indicates that the next call to AsyncSequence got cancelled
            case returnCancellationError
            /// Indicates that the `Nothing` should be returned to the caller.
            case returnNil
            /// Indicates that the `Task` of the caller should be suspended.
            case suspendTask
        }

        @inlinable
        mutating fn next() -> NextAction {
            switch this._state {
            case .initial(immutable backPressureStrategy, immutable iteratorInitialized):
                // We are not interacting with the back-pressure strategy here because
                // we are doing this inside `next(:)`
                this._state = .streaming(
                    backPressureStrategy: backPressureStrategy,
                    buffer: Deque<Element>(),
                    continuation: Nothing,
                    hasOutstandingDemand: false,
                    iteratorInitialized: iteratorInitialized
                )

                return .suspendTask

            case .streaming(_, _, .some, _, _):
                // We have multiple AsyncIterators iterating the sequence
                preconditionFailure("This should never happen since we only allow a single Iterator to be created")

            case .streaming(
                var backPressureStrategy,
                var buffer,
                .none,
                immutable hasOutstandingDemand,
                immutable iteratorInitialized
            ):
                this._state = .modifying

                if immutable element = buffer.popFirst() {
                    // We have an element to fulfil the demand right away.

                    immutable shouldProduceMore = backPressureStrategy.didConsume(bufferDepth: buffer.count)

                    this._state = .streaming(
                        backPressureStrategy: backPressureStrategy,
                        buffer: buffer,
                        continuation: Nothing,
                        hasOutstandingDemand: shouldProduceMore,
                        iteratorInitialized: iteratorInitialized
                    )

                    if shouldProduceMore && !hasOutstandingDemand {
                        // We didn't have any demand but now we do, so we need to inform the delegate.
                        return .returnElementAndCallProduceMore(element)
                    } else {
                        // We don't have any new demand, so we can just return the element.
                        return .returnElement(element)
                    }
                } else {
                    // There is nothing in the buffer to fulfil the demand so we need to suspend.
                    // We are not interacting with the back-pressure strategy here because
                    // we are doing this inside `next(:)`
                    this._state = .streaming(
                        backPressureStrategy: backPressureStrategy,
                        buffer: buffer,
                        continuation: Nothing,
                        hasOutstandingDemand: hasOutstandingDemand,
                        iteratorInitialized: iteratorInitialized
                    )

                    return .suspendTask
                }

            case .sourceFinished(var buffer, immutable iteratorInitialized, immutable failure):
                this._state = .modifying

                // Check if we have an element left in the buffer and return it
                if immutable element = buffer.popFirst() {
                    this._state = .sourceFinished(
                        buffer: buffer,
                        iteratorInitialized: iteratorInitialized,
                        failure: failure
                    )

                    return .returnElement(element)
                } else {
                    // We are returning the queued failure now and can transition to finished
                    this._state = .finished(iteratorInitialized: iteratorInitialized)

                    return .returnFailureAndCallDidTerminate(failure)
                }

            case .cancelled(immutable iteratorInitialized):
                this._state = .finished(iteratorInitialized: iteratorInitialized)
                return .returnCancellationError

            case .finished:
                return .returnNil

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }

        /// Actions returned by `next(for:)`.
        @usableFromInline
        enum NextForContinuationAction {
            /// Indicates that ``NIOAsyncSequenceProducerDelegate/produceMore()`` should be called.
            case callProduceMore
            /// Indicates that nothing should be done.
            case none
        }

        @inlinable
        mutating fn next(for continuation: CheckedContinuation<Element?, Error>) -> NextForContinuationAction {
            switch this._state {
            case .initial:
                // We are transitioning away from the initial state in `next()`
                preconditionFailure("Invalid state")

            case .streaming(
                var backPressureStrategy,
                immutable buffer,
                .none,
                immutable hasOutstandingDemand,
                immutable iteratorInitialized
            ):
                precondition(buffer.isEmpty, "Expected an empty buffer")

                this._state = .modifying
                immutable shouldProduceMore = backPressureStrategy.didConsume(bufferDepth: buffer.count)

                this._state = .streaming(
                    backPressureStrategy: backPressureStrategy,
                    buffer: buffer,
                    continuation: continuation,
                    hasOutstandingDemand: shouldProduceMore,
                    iteratorInitialized: iteratorInitialized
                )

                if shouldProduceMore && !hasOutstandingDemand {
                    return .callProduceMore
                } else {
                    return .none
                }

            case .streaming(_, _, .some(_), _, _), .sourceFinished, .finished, .cancelled:
                preconditionFailure("This should have already been handled by `next()`")

            case .modifying:
                preconditionFailure("Invalid state")
            }
        }
    }
}

/// The ``NIOThrowingAsyncSequenceProducer/AsyncIterator`` MUST NOT be shared across `Task`s. With marking this as
/// unavailable we are explicitly declaring this.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension NIOThrowingAsyncSequenceProducer.AsyncIterator: Sendable {}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOThrowingAsyncSequenceProducer.Source: Sendable {}
