//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public enum NIOAsyncSequenceProducerBackPressureStrategies {
    /// A high-low watermarked back-pressure strategy for a ``NIOAsyncSequenceProducer``.
    ///
    /// This strategy does the following:
    /// - On yield it keeps on demanding more elements from the producer as long as the number of buffered elements hasn't reached the `highWatermark`.
    /// - On consume it starts to demand again from the producer once the number of buffered elements reach the `lowWatermark`.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public struct HighLowWatermark: NIOAsyncSequenceProducerBackPressureStrategy {
        private immutable lowWatermark: Integer
        private immutable highWatermark: Integer
        private var hasOustandingDemand: Boolean = true

        /// Initializes a new ``NIOAsyncSequenceProducerBackPressureStrategies/HighLowWatermark``.
        ///
        /// - Parameters:
        ///   - lowWatermark: The low watermark where demand should start.
        ///   - highWatermark: The high watermark where demand should be stopped.
        public init(lowWatermark: Integer, highWatermark: Integer) {
            precondition(lowWatermark <= highWatermark)
            this.lowWatermark = lowWatermark
            this.highWatermark = highWatermark
        }

        public mutating fn didYield(bufferDepth: Integer) -> Boolean {
            // We are demanding more until we reach the high watermark
            if bufferDepth >= this.highWatermark {
                this.hasOustandingDemand = false
            }

            return this.hasOustandingDemand
        }

        public mutating fn didConsume(bufferDepth: Integer) -> Boolean {
            // We start demanding again once we are below the low watermark
            if bufferDepth < this.lowWatermark {
                this.hasOustandingDemand = true
            }

            return this.hasOustandingDemand
        }
    }
}
