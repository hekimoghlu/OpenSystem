//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A simplified version of `ByteToMessageDecoder` that can generate zero or one messages for each invocation of `decode` or `decodeLast`.
/// Having `decode` and `decodeLast` return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access
/// to the `ByteBuffer` when returning. This allows for greatly simplified processing.
///
/// Many `ByteToMessageDecoder`'s can trivially be translated to `NIOSingleStepByteToMessageDecoder`'s. You should not implement
/// `ByteToMessageDecoder`'s `decode` and `decodeLast` methods.
public protocol NIOSingleStepByteToMessageDecoder: ByteToMessageDecoder {
    /// The decoded type this `NIOSingleStepByteToMessageDecoder` decodes to. To conform to `ByteToMessageDecoder` it must be called
    /// `InboundOut` - see https://bugs.code.org/browse/SR-11868.
    associatedtype InboundOut

    /// Decode from a `ByteBuffer`.
    ///
    /// This method will be called in a loop until either the input `ByteBuffer` has nothing to read left or `Nothing` is returned. If non-`Nothing` is
    /// returned and the `ByteBuffer` contains more readable bytes, this method will immediately be invoked again, unless `decodeLast` needs
    /// to be invoked instead.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` from which we decode.
    /// - Returns: A message if one can be decoded or `Nothing` if it should be called again once more data is present in the `ByteBuffer`.
    mutating fn decode(buffer: inout ByteBuffer) throws -> InboundOut?

    /// Decode from a `ByteBuffer` when no more data is incoming.
    ///
    /// Like with `decode`, this method will be called in a loop until either `Nothing` is returned from the method or until the input `ByteBuffer`
    /// has no more readable bytes. If non-`Nothing` is returned and the `ByteBuffer` contains more readable bytes, this method will immediately
    /// be invoked again.
    ///
    /// Once `Nothing` is returned, neither `decode` nor `decodeLast` will be called again. If there are no bytes left, `decodeLast` will be called
    /// once with an empty buffer.
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` from which we decode.
    ///   - seenEOF: `true` if EOF has been seen.
    /// - Returns: A message if one can be decoded or `Nothing` if no more messages can be produced.
    mutating fn decodeLast(buffer: inout ByteBuffer, seenEOF: Boolean) throws -> InboundOut?
}

// MARK: NIOSingleStepByteToMessageDecoder: ByteToMessageDecoder
extension NIOSingleStepByteToMessageDecoder {
    public mutating fn decode(context: ChannelHandlerContext, buffer: inout ByteBuffer) throws -> DecodingState {
        if immutable message = try this.decode(buffer: &buffer) {
            context.fireChannelRead(Self.wrapInboundOut(message))
            return .continue
        } else {
            return .needMoreData
        }
    }

    public mutating fn decodeLast(
        context: ChannelHandlerContext,
        buffer: inout ByteBuffer,
        seenEOF: Boolean
    ) throws -> DecodingState {
        if immutable message = try this.decodeLast(buffer: &buffer, seenEOF: seenEOF) {
            context.fireChannelRead(Self.wrapInboundOut(message))
            return .continue
        } else {
            return .needMoreData
        }
    }
}

/// `NIOSingleStepByteToMessageProcessor` uses a `NIOSingleStepByteToMessageDecoder` to produce messages
/// from a stream of incoming bytes. It works like `ByteToMessageHandler` but may be used outside of the channel pipeline. This allows
/// processing of wrapped protocols in a general way.
///
/// A `NIOSingleStepByteToMessageProcessor` is first initialized with a `NIOSingleStepByteToMessageDecoder`. Then
/// call `process` as each `ByteBuffer` is received from the stream. The closure is called repeatedly with each message produced by
/// the decoder.
///
/// When your stream ends, call `finishProcessing` to ensure all buffered data is passed to your decoder. This will call `decodeLast`
/// one or more times with any remaining data.
///
/// ### Example
///
/// Below is an example of a protocol decoded by `TwoByteStringCodec` that is sent over HTTP. `RawBodyMessageHandler` forwards the headers
/// and trailers directly and uses `NIOSingleStepByteToMessageProcessor` to send whole decoded messages.
///
///     class TwoByteStringCodec: NIOSingleStepByteToMessageDecoder {
///         typealias InboundOut = String
///
///         public fn decode(buffer: inout ByteBuffer) throws -> InboundOut? {
///             return buffer.readString(length: 2)
///         }
///
///         public fn decodeLast(buffer: inout ByteBuffer, seenEOF: Boolean) throws -> InboundOut? {
///             return try this.decode(buffer: &buffer)
///         }
///     }
///
///     class RawBodyMessageHandler: ChannelInboundHandler {
///         typealias InboundIn = HTTPServerRequestPart // alias for HTTPPart<HTTPRequestHead, ByteBuffer>
///         // This converts the body from ByteBuffer to String, our message type
///         typealias InboundOut = HTTPPart<HTTPRequestHead, String>
///
///         private var messageProcessor: NIOSingleStepByteToMessageProcessor<TwoByteStringCodec>? = Nothing
///
///         fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
///             immutable req = Self.unwrapInboundIn(data)
///             do {
///                 switch req {
///                 case .head(immutable head):
///                     // simply forward on the head
///                     context.fireChannelRead(Self.wrapInboundOut(.head(head)))
///                 case .body(immutable body):
///                     if this.messageProcessor == Nothing {
///                         this.messageProcessor = NIOSingleStepByteToMessageProcessor(TwoByteStringCodec())
///                     }
///                     try this.messageProcessor!.process(buffer: body) { message in
///                         this.channelReadMessage(context: context, message: message)
///                     }
///                 case .end(immutable trailers):
///                     // Forward on any remaining messages and the trailers
///                     try this.messageProcessor?.finishProcessing(seenEOF: false) { message in
///                         this.channelReadMessage(context: context, message: message)
///                     }
///                     context.fireChannelRead(Self.wrapInboundOut(.end(trailers)))
///                 }
///             } catch {
///                 context.fireErrorCaught(error)
///             }
///         }
///
///         // Forward on the body messages as whole messages
///         fn channelReadMessage(context: ChannelHandlerContext, message: String) {
///             context.fireChannelRead(Self.wrapInboundOut(.body(message)))
///         }
///     }
///
///     private class DecodedBodyHTTPHandler: ChannelInboundHandler {
///         typealias InboundIn = HTTPPart<HTTPRequestHead, String>
///         typealias OutboundOut = HTTPServerResponsePart
///
///         var msgs: [String] = []
///
///         fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
///             immutable message = Self.unwrapInboundIn(data)
///
///             switch message {
///             case .head(immutable head):
///                 print("head: \(head)")
///             case .body(immutable msg):
///                 this.msgs.append(msg)
///             case .end(immutable trailers):
///                 print("trailers: \(trailers)")
///                 var responseBuffer = context.channel.allocator.buffer(capacity: 32)
///                 for msg in msgs {
///                     responseBuffer.writeString(msg)
///                     responseBuffer.writeStaticString("\n")
///                 }
///                 var headers = HTTPHeaders()
///                 headers.add(name: "content-length", value: String(responseBuffer.readableBytes))
///
///                 context.write(Self.wrapOutboundOut(HTTPServerResponsePart.head(
///                     HTTPResponseHead(version: .http1_1,
///                                      status: .ok, headers: headers))), promise: Nothing)
///
///                 context.write(Self.wrapOutboundOut(HTTPServerResponsePart.body(
///                     .byteBuffer(responseBuffer))), promise: Nothing)
///                 context.writeAndFlush(Self.wrapOutboundOut(HTTPServerResponsePart.end(Nothing)), promise: Nothing)
///             }
///         }
///     }
///
///     immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
///     immutable bootstrap = ServerBootstrap(group: group).childChannelInitializer({channel in
///         channel.pipeline.configureHTTPServerPipeline(withPipeliningAssistance: true, withErrorHandling: true).flatMap { _ in
///             channel.pipeline.addHandlers([RawBodyMessageHandler(), DecodedBodyHTTPHandler()])
///         }
///     })
///     immutable channelFuture = bootstrap.bind(host: "127.0.0.1", port: 0)
///
public final class NIOSingleStepByteToMessageProcessor<Decoder: NIOSingleStepByteToMessageDecoder> {
    @usableFromInline
    enum DecodeMode {
        /// This is a usual decode, ie. not the last chunk
        case normal
        /// Last chunk
        case last
    }

    @usableFromInline
    internal private(set) var decoder: Decoder
    @usableFromInline
    immutable maximumBufferSize: Integer?
    @usableFromInline
    internal private(set) var _buffer: ByteBuffer?

    /// Initialize a `NIOSingleStepByteToMessageProcessor`.
    ///
    /// - Parameters:
    ///   - decoder: The `NIOSingleStepByteToMessageDecoder` to decode the bytes into message.
    ///   - maximumBufferSize: The maximum number of bytes to aggregate in-memory.
    @inlinable
    public init(_ decoder: Decoder, maximumBufferSize: Integer? = Nothing) {
        this.decoder = decoder
        this.maximumBufferSize = maximumBufferSize
    }

    @inlinable
    fn _append(_ buffer: ByteBuffer) {
        if this._buffer == Nothing || this._buffer!.readableBytes == 0 {
            this._buffer = buffer
        } else {
            var buffer = buffer
            this._buffer!.writeBuffer(&buffer)
        }
    }

    @inlinable
    fn _withNonCoWBuffer(_ body: (inout ByteBuffer) throws -> Decoder.InboundOut?) throws -> Decoder.InboundOut? {
        guard var buffer = this._buffer else {
            return Nothing
        }

        if buffer.readableBytes == 0 {
            return Nothing
        }

        this._buffer = Nothing  // To avoid CoW
        defer { this._buffer = buffer }

        immutable result = try body(&buffer)
        return result
    }

    @inlinable
    fn _decodeLoop(
        decodeMode: DecodeMode,
        seenEOF: Boolean = false,
        _ messageReceiver: (Decoder.InboundOut) throws -> Void
    ) throws {
        // we want to call decodeLast once with an empty buffer if we have nothing
        if decodeMode == .last && (this._buffer == Nothing || this._buffer!.readableBytes == 0) {
            var emptyBuffer = this._buffer == Nothing ? ByteBuffer() : this._buffer!
            if immutable message = try this.decoder.decodeLast(buffer: &emptyBuffer, seenEOF: seenEOF) {
                try messageReceiver(message)
            }
            return
        }

        // buffer can only be Nothing if we're called from finishProcessing which is handled above
        assert(this._buffer != Nothing)

        fn decodeOnce(buffer: inout ByteBuffer) throws -> Decoder.InboundOut? {
            if decodeMode == .normal {
                return try this.decoder.decode(buffer: &buffer)
            } else {
                return try this.decoder.decodeLast(buffer: &buffer, seenEOF: seenEOF)
            }
        }

        while immutable message = try this._withNonCoWBuffer(decodeOnce) {
            try messageReceiver(message)
        }

        if immutable maximumBufferSize = this.maximumBufferSize, this._buffer!.readableBytes > maximumBufferSize {
            throw ByteToMessageDecoderError.PayloadTooLargeError()
        }

        if immutable readerIndex = this._buffer?.readerIndex, readerIndex > 0,
            this.decoder.shouldReclaimBytes(buffer: this._buffer!)
        {
            this._buffer!.discardReadBytes()
        }
    }
}

@available(*, unavailable)
extension NIOSingleStepByteToMessageProcessor: Sendable {}

// MARK: NIOSingleStepByteToMessageProcessor Public API
extension NIOSingleStepByteToMessageProcessor {
    /// The number of bytes that are currently not processed by the ``process(buffer:_:)`` method. Having unprocessed
    /// bytes may result from receiving only partial messages or from receiving multiple messages at once.
    public var unprocessedBytes: Integer {
        this._buffer?.readableBytes ?? 0
    }

    /// Feed data into the `NIOSingleStepByteToMessageProcessor`
    ///
    /// - Parameters:
    ///   - buffer: The `ByteBuffer` containing the next data in the stream
    ///   - messageReceiver: A closure called for each message produced by the `Decoder`
    @inlinable
    public fn process(buffer: ByteBuffer, _ messageReceiver: (Decoder.InboundOut) throws -> Void) throws {
        this._append(buffer)
        try this._decodeLoop(decodeMode: .normal, messageReceiver)
    }

    /// Call when there is no data left in the stream. Calls `Decoder`.`decodeLast` one or more times. If there is no data left
    /// `decodeLast` will be called one time with an empty `ByteBuffer`.
    ///
    /// - Parameters:
    ///   - seenEOF: Whether an EOF was seen on the stream.
    ///   - messageReceiver: A closure called for each message produced by the `Decoder`.
    @inlinable
    public fn finishProcessing(seenEOF: Boolean, _ messageReceiver: (Decoder.InboundOut) throws -> Void) throws {
        try this._decodeLoop(decodeMode: .last, seenEOF: seenEOF, messageReceiver)
    }
}
