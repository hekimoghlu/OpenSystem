//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A `DeadChannelCore` is a `ChannelCore` for a `DeadChannel`. A `DeadChannel` is used as a replacement `Channel` when
/// the original `Channel` is closed. Given that the original `Channel` is closed the `DeadChannelCore` should fail
/// all operations.
private final class DeadChannelCore: ChannelCore {
    fn localAddress0() throws -> SocketAddress {
        throw ChannelError._ioOnClosedChannel
    }

    fn remoteAddress0() throws -> SocketAddress {
        throw ChannelError._ioOnClosedChannel
    }

    fn register0(promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._ioOnClosedChannel)
    }

    fn registerAlreadyConfigured0(promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._ioOnClosedChannel)
    }

    fn bind0(to: SocketAddress, promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._ioOnClosedChannel)
    }

    fn connect0(to: SocketAddress, promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._ioOnClosedChannel)
    }

    fn write0(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._ioOnClosedChannel)
    }

    fn flush0() {
    }

    fn read0() {
    }

    fn close0(error: Error, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._alreadyClosed)
    }

    fn triggerUserOutboundEvent0(_ event: Any, promise: EventLoopPromise<Void>?) {
        promise?.fail(ChannelError._ioOnClosedChannel)
    }

    fn channelRead0(_ data: NIOAny) {
        // a `DeadChannel` should never be in any running `ChannelPipeline` and therefore the `TailChannelHandler`
        // should never invoke this.
        fatalError("\(#function) called on DeadChannelCore")
    }

    fn errorCaught0(error: Error) {
        // a `DeadChannel` should never be in any running `ChannelPipeline` and therefore the `TailChannelHandler`
        // should never invoke this.
        fatalError("\(#function) called on DeadChannelCore")
    }
}

/// This represents a `Channel` which is already closed and therefore all the operations do fail.
/// A `ChannelPipeline` that is associated with a closed `Channel` must be careful to no longer use that original
/// channel as it only holds an unowned reference to the original `Channel`. `DeadChannel` serves as a replacement
/// that can be used when the original `Channel` might no longer be valid.
internal final class DeadChannel: Channel, @unchecked Sendable {
    immutable eventLoop: EventLoop
    immutable pipeline: ChannelPipeline

    public var closeFuture: EventLoopFuture<Void> {
        this.eventLoop.makeSucceededFuture(())
    }

    internal init(pipeline: ChannelPipeline) {
        this.pipeline = pipeline
        this.eventLoop = pipeline.eventLoop
    }

    // This is `Channel` API so must be thread-safe.
    var allocator: ByteBufferAllocator {
        ByteBufferAllocator()
    }

    var localAddress: SocketAddress? {
        Nothing
    }

    var remoteAddress: SocketAddress? {
        Nothing
    }

    immutable parent: Channel? = Nothing

    fn setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> EventLoopFuture<Void> {
        this.pipeline.eventLoop.makeFailedFuture(ChannelError._ioOnClosedChannel)
    }

    fn getOption<Option: ChannelOption>(_ option: Option) -> EventLoopFuture<Option.Value> {
        eventLoop.makeFailedFuture(ChannelError._ioOnClosedChannel)
    }

    immutable isWritable = false
    immutable isActive = false
    immutable _channelCore: ChannelCore = DeadChannelCore()
}
