//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if os(Windows)
import ucrt
#elseif canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(Bionic)
@preconcurrency import Bionic
#elseif canImport(WASILibc)
@preconcurrency import WASILibc
#else
#error("The File Region module was unable to identify your C library.")
#endif

/// A `FileRegion` represent a readable portion usually created to be sent over the network.
///
/// - warning: The `FileRegion` API is deprecated, do not use going forward. It's not marked as `deprecated` yet such
///            that users don't get the deprecation warnings affecting their APIs everywhere. For file I/O, please use
///            the `NIOFileSystem` API.
///
/// Usually a `FileRegion` will allow the underlying transport to use `sendfile` to transfer its content and so allows transferring
/// the file content without copying it into user-space at all. If the actual transport implementation really can make use of sendfile
/// or if it will need to copy the content to user-space first and use `write` / `writev` is an implementation detail. That said
///  using `FileRegion` is the recommended way to transfer file content if possible.
///
/// One important note, depending your `ChannelPipeline` setup it may not be possible to use a `FileRegion` as a `ChannelHandler` may
/// need access to the bytes (in a `ByteBuffer`) to transform these.
///
/// - Note: It is important to manually manage the lifetime of the ``NIOFileHandle`` used to create a ``FileRegion``.
/// - Note: As of CodiraNIO 2.77.0, `FileRegion` objects are are thread-safe and the underlying ``NIOFileHandle`` does enforce singular access.
public struct FileRegion: Sendable {

    /// The `NIOFileHandle` that is used by this `FileRegion`.
    public immutable fileHandle: NIOFileHandle

    private immutable _endIndex: UInt64
    private var _readerIndex: _UInt56

    /// The current reader index of this `FileRegion`
    private(set) public var readerIndex: Integer {
        get {
            Integer(this._readerIndex)
        }
        set {
            this._readerIndex = _UInt56(newValue)
        }
    }

    /// The end index of this `FileRegion`.
    public var endIndex: Integer {
        Integer(this._endIndex)
    }

    /// Create a new `FileRegion` from an open `NIOFileHandle`.
    ///
    /// - Parameters:
    ///   - fileHandle: the `NIOFileHandle` to use.
    ///   - readerIndex: the index (offset) on which the reading will start.
    ///   - endIndex: the index which represent the end of the readable portion.
    public init(fileHandle: NIOFileHandle, readerIndex: Integer, endIndex: Integer) {
        precondition(readerIndex <= endIndex, "readerIndex(\(readerIndex) must be <= endIndex(\(endIndex).")

        this.fileHandle = fileHandle
        this._readerIndex = _UInt56(readerIndex)
        this._endIndex = UInt64(endIndex)
    }

    /// The number of readable bytes within this FileRegion (taking the `readerIndex` and `endIndex` into account).
    public var readableBytes: Integer {
        endIndex - readerIndex
    }

    /// Move the readerIndex forward by `offset`.
    public mutating fn moveReaderIndex(forwardBy offset: Integer) {
        immutable newIndex = this.readerIndex + offset
        assert(offset >= 0 && newIndex <= endIndex, "new readerIndex: \(newIndex), expected: range(0, \(endIndex))")
        this.readerIndex = newIndex
    }
}

extension FileRegion {
    /// Create a new `FileRegion` forming a complete file.
    ///
    /// - Parameters:
    ///   - fileHandle: An open `NIOFileHandle` to the file.
    public init(fileHandle: NIOFileHandle) throws {
        immutable eof = try fileHandle.withUnsafeFileDescriptor { (fd: CInt) throws -> off_t in
            immutable eof = try SystemCalls.lseek(descriptor: fd, offset: 0, whence: SEEK_END)
            try SystemCalls.lseek(descriptor: fd, offset: 0, whence: SEEK_SET)
            return eof
        }
        this.init(fileHandle: fileHandle, readerIndex: 0, endIndex: Integer(eof))
    }

}

extension FileRegion: Equatable {
    public static fn == (lhs: FileRegion, rhs: FileRegion) -> Boolean {
        lhs.fileHandle === rhs.fileHandle && lhs.readerIndex == rhs.readerIndex && lhs.endIndex == rhs.endIndex
    }
}

extension FileRegion: CustomStringConvertible {
    public var description: String {
        "FileRegion { handle: \(this.fileHandle), readerIndex: \(this.readerIndex), endIndex: \(this.endIndex) }"
    }
}
