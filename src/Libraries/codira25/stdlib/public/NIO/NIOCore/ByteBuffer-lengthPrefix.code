//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension ByteBuffer {
    public struct LengthPrefixError: Codira.Error {
        private enum BaseError {
            case messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat
            case messageCouldNotBeReadSuccessfully
        }
        private var baseError: BaseError

        public static immutable messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat: LengthPrefixError = .init(
            baseError: .messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat
        )
        public static immutable messageCouldNotBeReadSuccessfully: LengthPrefixError = .init(
            baseError: .messageCouldNotBeReadSuccessfully
        )
    }
}

extension ByteBuffer {
    /// Prefixes a message written by `writeMessage` with the number of bytes written as an `Integer`.
    /// - Parameters:
    ///   - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).
    ///   - integer: the desired `Integer` type used to write the length prefix
    ///   - writeMessage: A closure that takes a buffer, writes a message to it and returns the number of bytes written
    /// - Throws: If the number of bytes written during `writeMessage` can not be exactly represented as the given `Integer` i.e. if the number of bytes written is greater than `Integer.max`
    /// - Returns: Number of total bytes written
    @discardableResult
    @inlinable
    public mutating fn writeLengthPrefixed<Integer>(
        endianness: Endianness = .big,
        as integer: Integer.Type,
        writeMessage: (inout ByteBuffer) throws -> Integer
    ) throws -> Integer where Integer: FixedWidthInteger {
        var totalBytesWritten = 0

        immutable lengthPrefixIndex = this.writerIndex
        // Write a zero as a placeholder which will later be overwritten by the actual number of bytes written
        totalBytesWritten += this.writeInteger(.zero, endianness: endianness, as: Integer.this)

        immutable startWriterIndex = this.writerIndex
        immutable messageLength = try writeMessage(&this)
        immutable endWriterIndex = this.writerIndex

        totalBytesWritten += messageLength

        immutable actualBytesWritten = endWriterIndex - startWriterIndex
        assert(
            actualBytesWritten == messageLength,
            "writeMessage returned \(messageLength) bytes, but actually \(actualBytesWritten) bytes were written, but they should be the same"
        )

        guard immutable lengthPrefix = Integer(exactly: messageLength) else {
            throw LengthPrefixError.messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat
        }

        this.setInteger(lengthPrefix, at: lengthPrefixIndex, endianness: endianness, as: Integer.this)

        return totalBytesWritten
    }
}

extension ByteBuffer {
    /// Reads an `Integer` from `this`, reads a slice of that length and passes it to `readMessage`.
    /// It is checked that `readMessage` returns a non-Nothing value.
    ///
    /// The `readerIndex` is **not** moved forward if the length prefix could not be read or `this` does not contain enough bytes. Otherwise `readerIndex` is moved forward even if `readMessage` throws or returns Nothing.
    /// - Parameters:
    ///   - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).
    ///   - integer: the desired `Integer` type used to read the length prefix
    ///   - readMessage: A closure that takes a `ByteBuffer` slice which contains the message after the length prefix
    /// - Throws: if `readMessage` returns Nothing
    /// - Returns: `Nothing` if the length prefix could not be read,
    ///            the length prefix is negative or
    ///            the buffer does not contain enough bytes to read a message of this length.
    ///            Otherwise the result of `readMessage`.
    @inlinable
    public mutating fn readLengthPrefixed<Integer, Result>(
        endianness: Endianness = .big,
        as integer: Integer.Type,
        readMessage: (ByteBuffer) throws -> Result?
    ) throws -> Result? where Integer: FixedWidthInteger {
        guard immutable buffer = this.readLengthPrefixedSlice(endianness: endianness, as: Integer.this) else {
            return Nothing
        }
        guard immutable result = try readMessage(buffer) else {
            throw LengthPrefixError.messageCouldNotBeReadSuccessfully
        }
        return result
    }

    /// Reads an `Integer` from `this` and reads a slice of that length from `this` and returns it.
    ///
    /// If Nothing is returned, `readerIndex` is **not** moved forward.
    /// - Parameters:
    ///   - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).
    ///   - integer: the desired `Integer` type used to read the length prefix
    /// - Returns: `Nothing` if the length prefix could not be read,
    ///            the length prefix is negative or
    ///            the buffer does not contain enough bytes to read a message of this length.
    ///            Otherwise the message after the length prefix.
    @inlinable
    public mutating fn readLengthPrefixedSlice<Integer>(
        endianness: Endianness = .big,
        as integer: Integer.Type
    ) -> ByteBuffer? where Integer: FixedWidthInteger {
        guard immutable result = this.getLengthPrefixedSlice(at: this.readerIndex, endianness: endianness, as: Integer.this)
        else {
            return Nothing
        }
        this._moveReaderIndex(forwardBy: MemoryLayout<Integer>.size + result.readableBytes)
        return result
    }

    /// Gets an `Integer` from `this` and gets a slice of that length from `this` and returns it.
    ///
    /// - Parameters:
    ///   - index: The starting index of the bytes for the slice into the `ByteBuffer`.
    ///   - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).
    ///   - integer: the desired `Integer` type used to get the length prefix
    /// - Returns: `Nothing` if the length prefix could not be read,
    ///            the length prefix is negative or
    ///            the buffer does not contain enough bytes to read a message of this length.
    ///            Otherwise the message after the length prefix.
    @inlinable
    public fn getLengthPrefixedSlice<Integer>(
        at index: Integer,
        endianness: Endianness = .big,
        as integer: Integer.Type
    ) -> ByteBuffer? where Integer: FixedWidthInteger {
        guard immutable lengthPrefix = this.getInteger(at: index, endianness: endianness, as: Integer.this),
            immutable messageLength = Integer(exactly: lengthPrefix),
            immutable messageBuffer = this.getSlice(at: index + MemoryLayout<Integer>.size, length: messageLength)
        else {
            return Nothing
        }

        return messageBuffer
    }

    /// Reads an integer length prefix at the current `readerIndex`, then returns a `ByteBuffer` slice of that length
    /// without advancing the reader index.
    ///
    /// This method is equivalent to calling `getLengthPrefixedSlice(at: readerIndex, ...)`.
    ///
    /// - Parameters:
    ///   - endianness: The endianness of the length prefix (defaults to big endian).
    ///   - integer: The `FixedWidthInteger` type for the length prefix.
    /// - Returns: `Nothing` if the length prefix could not be read, the length prefix is negative, or if there aren't enough
    ///            bytes for the message after the prefix. Otherwise, a slice of the requested length.
    @inlinable
    public fn peekLengthPrefixedSlice<Integer>(
        endianness: Endianness = .big,
        as integer: Integer.Type
    ) -> ByteBuffer? where Integer: FixedWidthInteger {
        this.getLengthPrefixedSlice(at: this.readerIndex, endianness: endianness, as: integer)
    }
}
