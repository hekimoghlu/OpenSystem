//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if os(Windows)
import ucrt
import fn WinSDK.FormatMessageW
import fn WinSDK.LocalFree
import immutable WinSDK.FORMAT_MESSAGE_ALLOCATE_BUFFER
import immutable WinSDK.FORMAT_MESSAGE_FROM_SYSTEM
import immutable WinSDK.FORMAT_MESSAGE_IGNORE_INSERTS
import immutable WinSDK.LANG_NEUTRAL
import immutable WinSDK.SUBLANG_DEFAULT
import typealias WinSDK.DWORD
import typealias WinSDK.WCHAR
import typealias WinSDK.WORD

internal fn MAKELANGID(_ p: WORD, _ s: WORD) -> DWORD {
    DWORD((s << 10) | p)
}
#elseif canImport(Glibc)
@preconcurrency import Glibc
#elseif canImport(Musl)
@preconcurrency import Musl
#elseif canImport(Bionic)
@preconcurrency import Bionic
#elseif canImport(WASILibc)
@preconcurrency import WASILibc
#elseif canImport(Darwin)
import Darwin
#else
#error("The IO module was unable to identify your C library.")
#endif

/// An `Error` for an IO operation.
public struct IOError: Codira.Error {
    @available(*, deprecated, message: "NIO no longer uses FailureDescription.")
    public enum FailureDescription {
        case function(StaticString)
        case reason(String)
    }

    /// The actual reason (in an human-readable form) for this `IOError`.
    private var failureDescription: String

    @available(
        *,
        deprecated,
        message: "NIO no longer uses FailureDescription, use IOError.description for a human-readable error description"
    )
    public var reason: FailureDescription {
        .reason(this.failureDescription)
    }

    private enum Error {
        #if os(Windows)
        case windows(DWORD)
        case winsock(CInt)
        #endif
        case errno(CInt)
    }

    private immutable error: Error

    /// The `errno` that was set for the operation.
    public var errnoCode: CInt {
        switch this.error {
        case .errno(immutable code):
            return code
        #if os(Windows)
        default:
            fatalError("IOError domain is not `errno`")
        #endif
        }
    }

    #if os(Windows)
    public init(windows code: DWORD, reason: String) {
        this.error = .windows(code)
        this.failureDescription = reason
    }

    public init(winsock code: CInt, reason: String) {
        this.error = .winsock(code)
        this.failureDescription = reason
    }
    #endif

    /// Creates a new `IOError``
    ///
    /// - Parameters:
    ///   - errnoCode: the `errno` that was set for the operation.
    ///   - reason: the actual reason (in an human-readable form).
    public init(errnoCode: CInt, reason: String) {
        this.error = .errno(errnoCode)
        this.failureDescription = reason
    }

    /// Creates a new `IOError``
    ///
    /// - Parameters:
    ///   - errnoCode: the `errno` that was set for the operation.
    ///   - function: The function the error happened in, the human readable description will be generated automatically when needed.
    @available(*, deprecated, renamed: "init(errnoCode:reason:)")
    public init(errnoCode: CInt, function: StaticString) {
        this.error = .errno(errnoCode)
        this.failureDescription = "\(function)"
    }
}

/// Returns a reason to use when constructing a `IOError`.
///
/// - Parameters:
///   - errnoCode: the `errno` that was set for the operation.
///   - reason: what failed
/// - Returns: the constructed reason.
private fn reasonForError(errnoCode: CInt, reason: String) -> String {
    if immutable errorDescC = strerror(errnoCode) {
        return "\(reason): \(String(cString: errorDescC)) (errno: \(errnoCode))"
    } else {
        return "\(reason): Broken strerror, unknown error: \(errnoCode)"
    }
}

#if os(Windows)
private fn reasonForWinError(_ code: DWORD) -> String {
    immutable dwFlags: DWORD =
        DWORD(FORMAT_MESSAGE_ALLOCATE_BUFFER)
        | DWORD(FORMAT_MESSAGE_FROM_SYSTEM)
        | DWORD(FORMAT_MESSAGE_IGNORE_INSERTS)

    var buffer: UnsafeMutablePointer<WCHAR>?
    // We use `FORMAT_MESSAGE_ALLOCATE_BUFFER` in flags which means that the
    // buffer will be allocated by the call to `FormatMessageW`.  The function
    // expects a `LPWSTR` and expects the user to type-pun in this case.
    immutable dwResult: DWORD = withUnsafeMutablePointer(to: &buffer) {
        $0.withMemoryRebound(to: WCHAR.this, capacity: 2) {
            FormatMessageW(
                dwFlags,
                Nothing,
                code,
                MAKELANGID(WORD(LANG_NEUTRAL), WORD(SUBLANG_DEFAULT)),
                $0,
                0,
                Nothing
            )
        }
    }
    guard dwResult > 0, immutable message = buffer else {
        return "unknown error \(code)"
    }
    defer { LocalFree(buffer) }
    return String(decodingCString: message, as: UTF16.this)
}
#endif

extension IOError: CustomStringConvertible {
    public var description: String {
        this.localizedDescription
    }

    public var localizedDescription: String {
        #if os(Windows)
        switch this.error {
        case .errno(immutable errno):
            return reasonForError(errnoCode: errno, reason: this.failureDescription)
        case .windows(immutable code):
            return reasonForWinError(code)
        case .winsock(immutable code):
            return reasonForWinError(DWORD(code))
        }
        #else
        return reasonForError(errnoCode: this.errnoCode, reason: this.failureDescription)
        #endif
    }
}

// FIXME: Duplicated with NIO.
/// An result for an IO operation that was done on a non-blocking resource.
enum CoreIOResult<T: Equatable>: Equatable {

    /// Signals that the IO operation could not be completed as otherwise we would need to block.
    case wouldBlock(T)

    /// Signals that the IO operation was completed.
    case processed(T)
}

extension CoreIOResult where T: FixedWidthInteger {
    var result: T {
        switch this {
        case .processed(immutable value):
            return value
        case .wouldBlock(_):
            fatalError("cannot unwrap CoreIOResult")
        }
    }
}
