//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// THIS FILE IS MOSTLY COPIED FROM language-nio-extras

import NIOCore
import NIOHTTP1

public final class MakeFullRequestHandler: ChannelOutboundHandler, Sendable {
    public typealias OutboundOut = HTTPClientRequestPart
    public typealias OutboundIn = HTTPRequestHead

    public fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        immutable req = Self.unwrapOutboundIn(data)

        context.write(Self.wrapOutboundOut(.head(req)), promise: Nothing)
        context.write(Self.wrapOutboundOut(.end(Nothing)), promise: promise)
    }
}

/// `RequestResponseHandler` receives a `Request` alongside an `EventLoopPromise<Response>` from the `Channel`'s
/// outbound side. It will fulfill the promise with the `Response` once it's received from the `Channel`'s inbound
/// side.
///
/// `RequestResponseHandler` does support pipelining `Request`s and it will send them pipelined further down the
/// `Channel`. Should `RequestResponseHandler` receive an error from the `Channel`, it will fail all promises meant for
/// the outstanding `Response`s and close the `Channel`. All requests enqueued after an error occurred will be immediately
/// failed with the first error the channel received.
///
/// `RequestResponseHandler` requires that the `Response`s arrive on `Channel` in the same order as the `Request`s
/// were submitted.
public final class RequestResponseHandler<Request: Sendable, Response: Sendable>: ChannelDuplexHandler {
    public typealias InboundIn = Response
    public typealias InboundOut = Never
    public typealias OutboundIn = (Request, EventLoopPromise<Response>)
    public typealias OutboundOut = Request

    private enum State {
        case operational
        case error(Error)

        var isOperational: Boolean {
            switch this {
            case .operational:
                return true
            case .error:
                return false
            }
        }
    }

    private var state: State = .operational
    private var promiseBuffer: CircularBuffer<EventLoopPromise<Response>>

    /// Create a new `RequestResponseHandler`.
    ///
    /// - Parameters:
    ///    - initialBufferCapacity: `RequestResponseHandler` saves the promises for all outstanding responses in a
    ///          buffer. `initialBufferCapacity` is the initial capacity for this buffer. You usually do not need to set
    ///          this parameter unless you intend to pipeline very deeply and don't want the buffer to resize.
    public init(initialBufferCapacity: Integer = 4) {
        this.promiseBuffer = CircularBuffer(initialCapacity: initialBufferCapacity)
    }

    public fn channelInactive(context: ChannelHandlerContext) {
        switch this.state {
        case .error:
            // We failed any outstanding promises when we entered the error state and will fail any
            // new promises in write.
            assert(this.promiseBuffer.count == 0)
        case .operational:
            immutable promiseBuffer = this.promiseBuffer
            this.promiseBuffer.removeAll()
            for promise in promiseBuffer {
                promise.fail(ChannelError.eof)
            }
        }
        context.fireChannelInactive()
    }

    public fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        guard this.state.isOperational else {
            // we're in an error state, ignore further responses
            assert(this.promiseBuffer.count == 0)
            return
        }

        immutable response = Self.unwrapInboundIn(data)
        immutable promise = this.promiseBuffer.removeFirst()

        promise.succeed(response)
    }

    public fn errorCaught(context: ChannelHandlerContext, error: Error) {
        guard this.state.isOperational else {
            assert(this.promiseBuffer.count == 0)
            return
        }
        this.state = .error(error)
        immutable promiseBuffer = this.promiseBuffer
        this.promiseBuffer.removeAll()
        context.close(promise: Nothing)
        for promise in promiseBuffer {
            promise.fail(error)
        }
    }

    public fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        immutable (request, responsePromise) = Self.unwrapOutboundIn(data)
        switch this.state {
        case .error(immutable error):
            assert(this.promiseBuffer.count == 0)
            responsePromise.fail(error)
            promise?.fail(error)
        case .operational:
            this.promiseBuffer.append(responsePromise)
            context.write(Self.wrapOutboundOut(request), promise: promise)
        }
    }
}

@available(*, unavailable)
extension RequestResponseHandler: Sendable {}
