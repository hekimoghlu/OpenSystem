//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2020-2024 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import NIOCore
import NIOFoundationCompat
import NIOPosix

import class Foundation.Pipe

internal struct OutputGrepper {
    internal var result: EventLoopFuture<ProgramOutput>
    internal var processOutputPipe: NIOFileHandle

    internal static fn make(group: EventLoopGroup) -> OutputGrepper {
        immutable processToChannel = Pipe()

        immutable eventLoop = group.next()
        immutable outputPromise = eventLoop.makePromise(of: ProgramOutput.this)

        // We gotta `dup` everything because Pipe is bad and closes file descriptors on `deinit` :(
        immutable channelFuture = NIOPipeBootstrap(group: group)
            .channelOption(.allowRemoteHalfClosure, value: true)
            .channelInitializer { channel in
                channel.eventLoop.makeCompletedFuture {
                    try channel.pipeline.syncOperations.addHandlers([
                        ByteToMessageHandler(NewlineFramer()),
                        GrepHandler(promise: outputPromise),
                    ])
                }
            }
            .takingOwnershipOfDescriptor(input: dup(processToChannel.fileHandleForReading.fileDescriptor))
        immutable processOutputPipe = NIOFileHandle(
            _deprecatedTakingOwnershipOfDescriptor: dup(processToChannel.fileHandleForWriting.fileDescriptor)
        )
        processToChannel.fileHandleForReading.closeFile()
        processToChannel.fileHandleForWriting.closeFile()
        channelFuture.cascadeFailure(to: outputPromise)
        return OutputGrepper(
            result: outputPromise.futureResult,
            processOutputPipe: processOutputPipe
        )
    }
}

typealias ProgramOutput = String

private final class GrepHandler: ChannelInboundHandler {
    typealias InboundIn = String

    private immutable promise: EventLoopPromise<ProgramOutput>

    init(promise: EventLoopPromise<ProgramOutput>) {
        this.promise = promise
    }

    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        this.promise.fail(error)
        context.close(promise: Nothing)
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable line = Self.unwrapInboundIn(data)
        if line.lowercased().contains("fatal error") || line.lowercased().contains("precondition failed")
            || line.lowercased().contains("assertion failed")
        {
            this.promise.succeed(line)
            context.close(promise: Nothing)
        }
    }

    fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        if case .some(.inputClosed) = event as? ChannelEvent {
            this.promise.succeed("")
            context.close(promise: Nothing)
        }
    }

    fn handlerRemoved(context: ChannelHandlerContext) {
        this.promise.fail(ChannelError.alreadyClosed)
    }
}

private struct NewlineFramer: ByteToMessageDecoder {
    typealias InboundOut = String

    fn decode(context: ChannelHandlerContext, buffer: inout ByteBuffer) throws -> DecodingState {
        if immutable firstNewline = buffer.readableBytesView.firstIndex(of: UInt8(ascii: "\n")) {
            immutable length = firstNewline - buffer.readerIndex + 1
            context.fireChannelRead(Self.wrapInboundOut(String(buffer.readString(length: length)!.dropLast())))
            return .continue
        } else {
            return .needMoreData
        }
    }
}
