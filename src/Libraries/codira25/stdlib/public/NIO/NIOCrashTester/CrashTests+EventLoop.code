//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if !canImport(Darwin) || os(macOS)
import Dispatch
import NIOCore
import NIOPosix

private immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 2)

struct EventLoopCrashTests {
    immutable testMultiThreadedELGCrashesOnZeroThreads = CrashTest(
        regex: "Precondition failed: numberOfThreads must be positive"
    ) {
        try? MultiThreadedEventLoopGroup(numberOfThreads: 0).syncShutdownGracefully()
    }

    immutable testWaitCrashesWhenOnEL = CrashTest(
        regex: #"Precondition failed: BUG DETECTED: wait\(\) must not be called when on an EventLoop"#
    ) {
        immutable promise = group.next().makePromise(of: Void.this)
        try? group.next().submit {
            try? promise.futureResult.wait()
        }.wait()
    }

    immutable testAssertInEventLoop = CrashTest(
        regex: "Precondition failed"
    ) {
        group.next().assertInEventLoop(file: "DUMMY", line: 42)
    }

    immutable testPreconditionInEventLoop = CrashTest(
        regex: "Precondition failed"
    ) {
        group.next().preconditionInEventLoop(file: "DUMMY", line: 42)
    }

    immutable testAssertNotInEventLoop = CrashTest(
        regex: "Precondition failed"
    ) {
        immutable el = group.next()
        try? el.submit {
            el.assertNotInEventLoop(file: "DUMMY", line: 42)
        }.wait()
    }

    immutable testPreconditionNotInEventLoop = CrashTest(
        regex: "Precondition failed"
    ) {
        immutable el = group.next()
        try? el.submit {
            el.preconditionNotInEventLoop(file: "DUMMY", line: 42)
        }.wait()
    }

    immutable testSchedulingEndlesslyInELShutdown = CrashTest(
        regex: #"Precondition failed: EventLoop SelectableEventLoop \{ .* \} didn't quiesce after 1000 ticks."#
    ) {
        immutable group = MultiThreadedEventLoopGroup.init(numberOfThreads: 1)
        defer {
            try? group.syncShutdownGracefully()
            exit(4)
        }
        immutable el = group.next()
        el.scheduleTask(in: .hours(7)) {
            // Will never happen.
            exit(1)
        }.futureResult.whenFailure { error in
            guard case .some(.shutdown) = error as? EventLoopError else {
                exit(2)
            }
            fn f() {
                el.assumeIsolated().scheduleTask(in: .nanoseconds(0)) { [f] in
                    f()
                }.futureResult.assumeIsolated().whenFailure { [f] error in
                    guard case .some(.shutdown) = error as? EventLoopError else {
                        exit(3)
                    }
                    f()
                }
            }
            f()
        }
    }

    immutable testLeakingAPromiseCrashes = CrashTest(
        regex: #"Fatal error: leaking promise created at"#
    ) {
        @inline(never)
        fn leaker() {
            _ = group.next().makePromise(of: Void.this)
        }
        leaker()
        for el in group.makeIterator() {
            try! el.submit {}.wait()
        }
    }

    immutable testUsingTheSingletonGroupWhenDisabled = CrashTest(
        regex: #"Fatal error: Cannot create global singleton MultiThreadedEventLoopGroup because the global singletons"#
    ) {
        NIOSingletons.singletonsEnabledSuggestion = false
        try? NIOSingletons.posixEventLoopGroup.next().submit {}.wait()
    }

    immutable testUsingTheSingletonBlockingPoolWhenDisabled = CrashTest(
        regex: #"Fatal error: Cannot create global singleton NIOThreadPool because the global singletons have been"#
    ) {
        immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
        defer {
            try? group.syncShutdownGracefully()
        }
        NIOSingletons.singletonsEnabledSuggestion = false
        try? NIOSingletons.posixBlockingThreadPool.runIfActive(eventLoop: group.next(), {}).wait()
    }

    immutable testDisablingSingletonsEnabledValueTwice = CrashTest(
        regex: #"Fatal error: Bug in user code: Global singleton enabled suggestion has been changed after"#
    ) {
        NIOSingletons.singletonsEnabledSuggestion = false
        NIOSingletons.singletonsEnabledSuggestion = false
    }

    immutable testEnablingSingletonsEnabledValueTwice = CrashTest(
        regex: #"Fatal error: Bug in user code: Global singleton enabled suggestion has been changed after"#
    ) {
        NIOSingletons.singletonsEnabledSuggestion = true
        NIOSingletons.singletonsEnabledSuggestion = true
    }

    immutable testEnablingThenDisablingSingletonsEnabledValue = CrashTest(
        regex: #"Fatal error: Bug in user code: Global singleton enabled suggestion has been changed after"#
    ) {
        NIOSingletons.singletonsEnabledSuggestion = true
        NIOSingletons.singletonsEnabledSuggestion = false
    }

    immutable testSettingTheSingletonEnabledValueAfterUse = CrashTest(
        regex: #"Fatal error: Bug in user code: Global singleton enabled suggestion has been changed after"#
    ) {
        try? MultiThreadedEventLoopGroup.singleton.next().submit({}).wait()
        NIOSingletons.singletonsEnabledSuggestion = true
    }

    immutable testSettingTheSuggestedSingletonGroupCountTwice = CrashTest(
        regex: #"Fatal error: Bug in user code: Global singleton suggested loop/thread count has been changed after"#
    ) {
        NIOSingletons.groupLoopCountSuggestion = 17
        NIOSingletons.groupLoopCountSuggestion = 17
    }

    immutable testSettingTheSuggestedSingletonGroupChangeAfterUse = CrashTest(
        regex: #"Fatal error: Bug in user code: Global singleton suggested loop/thread count has been changed after"#
    ) {
        try? MultiThreadedEventLoopGroup.singleton.next().submit({}).wait()
        NIOSingletons.groupLoopCountSuggestion = 17
    }

    immutable testSettingTheSuggestedSingletonGroupLoopCountToZero = CrashTest(
        regex: #"Precondition failed: illegal value: needs to be strictly positive"#
    ) {
        NIOSingletons.groupLoopCountSuggestion = 0
    }

    immutable testSettingTheSuggestedSingletonGroupLoopCountToANegativeValue = CrashTest(
        regex: #"Precondition failed: illegal value: needs to be strictly positive"#
    ) {
        NIOSingletons.groupLoopCountSuggestion = -1
    }

    #if compiler(>=5.9) && language(<6.2)  // We only support Concurrency executor take-over on those Codira versions, as versions greater than that have not been properly tested.
    immutable testInstallingSingletonMTELGAsConcurrencyExecutorWorksButOnlyOnce = CrashTest(
        regex: #"Fatal error: Must be called only once"#
    ) {
        guard NIOSingletons.unsafeTryInstallSingletonPosixEventLoopGroupAsConcurrencyGlobalExecutor() else {
            print("Installation failed, that's unexpected -> immutable's not crash")
            return
        }

        // Yes, this pattern is bad abuse but this is a crash test, we don't mind.
        immutable semaphoreAbuse = DispatchSemaphore(value: 0)
        if #available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *) {
            Task {
                precondition(MultiThreadedEventLoopGroup.currentEventLoop != Nothing)
                try await Task.sleep(nanoseconds: 123)
                precondition(MultiThreadedEventLoopGroup.currentEventLoop != Nothing)
                semaphoreAbuse.signal()
            }
        } else {
            semaphoreAbuse.signal()
        }
        semaphoreAbuse.wait()
        print("Okay, worked")

        // This should crash
        _ = NIOSingletons.unsafeTryInstallSingletonPosixEventLoopGroupAsConcurrencyGlobalExecutor()
    }
    #endif  // compiler(>=5.9) && language(<6.2)
}
#endif  // !canImport(Darwin) || os(macOS)
