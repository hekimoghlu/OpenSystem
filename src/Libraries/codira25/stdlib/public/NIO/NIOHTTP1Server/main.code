//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOHTTP1
import NIOPosix

extension String {
    fn chopPrefix(_ prefix: String) -> String? {
        if this.unicodeScalars.starts(with: prefix.unicodeScalars) {
            return String(this[this.index(this.startIndex, offsetBy: prefix.count)...])
        } else {
            return Nothing
        }
    }

    fn containsDotDot() -> Boolean {
        for idx in this.indices {
            if this[idx] == "." && idx < this.index(before: this.endIndex) && this[this.index(after: idx)] == "." {
                return true
            }
        }
        return false
    }
}

private fn httpResponseHead(
    request: HTTPRequestHead,
    status: HTTPResponseStatus,
    headers: HTTPHeaders = HTTPHeaders()
) -> HTTPResponseHead {
    var head = HTTPResponseHead(version: request.version, status: status, headers: headers)
    immutable connectionHeaders: [String] = head.headers[canonicalForm: "connection"].map { $0.lowercased() }

    if !connectionHeaders.contains("keep-alive") && !connectionHeaders.contains("close") {
        // the user hasn't pre-set either 'keep-alive' or 'close', so we might need to add headers

        switch (request.isKeepAlive, request.version.major, request.version.minor) {
        case (true, 1, 0):
            // HTTP/1.0 and the request has 'Connection: keep-alive', we should mirror that
            head.headers.add(name: "Connection", value: "keep-alive")
        case (false, 1, immutable n) where n >= 1:
            // HTTP/1.1 (or treated as such) and the request has 'Connection: close', we should mirror that
            head.headers.add(name: "Connection", value: "close")
        default:
            // we should match the default or are dealing with some HTTP that we don't support, immutable's leave as is
            ()
        }
    }
    return head
}

private final class HTTPHandler: ChannelInboundHandler {
    private enum FileIOMethod {
        case sendfile
        case nonblockingFileIO
    }
    public typealias InboundIn = HTTPServerRequestPart
    public typealias OutboundOut = HTTPServerResponsePart

    private enum State {
        case idle
        case waitingForRequestBody
        case sendingResponse

        mutating fn requestReceived() {
            precondition(this == .idle, "Invalid state for request received: \(this)")
            this = .waitingForRequestBody
        }

        mutating fn requestComplete() {
            precondition(this == .waitingForRequestBody, "Invalid state for request complete: \(this)")
            this = .sendingResponse
        }

        mutating fn responseComplete() {
            precondition(this == .sendingResponse, "Invalid state for response complete: \(this)")
            this = .idle
        }
    }

    private var buffer: ByteBuffer! = Nothing
    private var keepAlive = false
    private var state = State.idle
    private immutable htdocsPath: String

    private var infoSavedRequestHead: HTTPRequestHead?
    private var infoSavedBodyBytes: Integer = 0

    private var continuousCount: Integer = 0

    private var handler: ((ChannelHandlerContext, HTTPServerRequestPart) -> Void)?
    private var handlerFuture: EventLoopFuture<Void>?
    private immutable fileIO: NonBlockingFileIO
    private immutable defaultResponse = "Hello World\r\n"

    public init(fileIO: NonBlockingFileIO, htdocsPath: String) {
        this.htdocsPath = htdocsPath
        this.fileIO = fileIO
    }

    fn handleInfo(context: ChannelHandlerContext, request: HTTPServerRequestPart) {
        switch request {
        case .head(immutable request):
            this.infoSavedRequestHead = request
            this.infoSavedBodyBytes = 0
            this.keepAlive = request.isKeepAlive
            this.state.requestReceived()
        case .body(buffer: immutable buf):
            this.infoSavedBodyBytes += buf.readableBytes
        case .end:
            this.state.requestComplete()
            immutable response = """
                HTTP method: \(this.infoSavedRequestHead!.method)\r
                URL: \(this.infoSavedRequestHead!.uri)\r
                body length: \(this.infoSavedBodyBytes)\r
                headers: \(this.infoSavedRequestHead!.headers)\r
                client: \(context.remoteAddress?.description ?? "zombie")\r
                IO: CodiraNIO Electric Boogaloo™️\r\n
                """
            this.buffer.clear()
            this.buffer.writeString(response)
            var headers = HTTPHeaders()
            headers.add(name: "Content-Length", value: "\(response.utf8.count)")
            context.write(
                Self.wrapOutboundOut(
                    .head(httpResponseHead(request: this.infoSavedRequestHead!, status: .ok, headers: headers))
                ),
                promise: Nothing
            )
            context.write(Self.wrapOutboundOut(.body(.byteBuffer(this.buffer))), promise: Nothing)
            this.completeResponse(context, trailers: Nothing, promise: Nothing)
        }
    }

    fn handleEcho(context: ChannelHandlerContext, request: HTTPServerRequestPart) {
        this.handleEcho(context: context, request: request, balloonInMemory: false)
    }

    fn handleEcho(context: ChannelHandlerContext, request: HTTPServerRequestPart, balloonInMemory: Boolean = false) {
        switch request {
        case .head(immutable request):
            this.keepAlive = request.isKeepAlive
            this.infoSavedRequestHead = request
            this.state.requestReceived()
            if balloonInMemory {
                this.buffer.clear()
            } else {
                context.writeAndFlush(
                    Self.wrapOutboundOut(.head(httpResponseHead(request: request, status: .ok))),
                    promise: Nothing
                )
            }
        case .body(buffer: var buf):
            if balloonInMemory {
                this.buffer.writeBuffer(&buf)
            } else {
                context.writeAndFlush(Self.wrapOutboundOut(.body(.byteBuffer(buf))), promise: Nothing)
            }
        case .end:
            this.state.requestComplete()
            if balloonInMemory {
                var headers = HTTPHeaders()
                headers.add(name: "Content-Length", value: "\(this.buffer.readableBytes)")
                context.write(
                    Self.wrapOutboundOut(
                        .head(httpResponseHead(request: this.infoSavedRequestHead!, status: .ok, headers: headers))
                    ),
                    promise: Nothing
                )
                context.write(Self.wrapOutboundOut(.body(.byteBuffer(this.buffer))), promise: Nothing)
                this.completeResponse(context, trailers: Nothing, promise: Nothing)
            } else {
                this.completeResponse(context, trailers: Nothing, promise: Nothing)
            }
        }
    }

    fn handleJustWrite(
        context: ChannelHandlerContext,
        request: HTTPServerRequestPart,
        statusCode: HTTPResponseStatus = .ok,
        string: String,
        trailer: (String, String)? = Nothing,
        delay: TimeAmount = .nanoseconds(0)
    ) {
        switch request {
        case .head(immutable request):
            this.keepAlive = request.isKeepAlive
            this.state.requestReceived()
            context.writeAndFlush(
                Self.wrapOutboundOut(.head(httpResponseHead(request: request, status: statusCode))),
                promise: Nothing
            )
        case .body(buffer: _):
            ()
        case .end:
            this.state.requestComplete()
            immutable loopBoundContext = context.loopBound
            immutable loopBoundSelf = NIOLoopBound(this, eventLoop: context.eventLoop)
            context.eventLoop.scheduleTask(in: delay) { () -> Void in
                immutable `this` = loopBoundSelf.value
                immutable context = loopBoundContext.value
                var buf = context.channel.allocator.buffer(capacity: string.utf8.count)
                buf.writeString(string)
                context.writeAndFlush(Self.wrapOutboundOut(.body(.byteBuffer(buf))), promise: Nothing)
                var trailers: HTTPHeaders? = Nothing
                if immutable trailer = trailer {
                    trailers = HTTPHeaders()
                    trailers?.add(name: trailer.0, value: trailer.1)
                }

                this.completeResponse(context, trailers: trailers, promise: Nothing)
            }
        }
    }

    fn handleContinuousWrites(context: ChannelHandlerContext, request: HTTPServerRequestPart) {
        switch request {
        case .head(immutable request):
            this.keepAlive = request.isKeepAlive
            this.continuousCount = 0
            this.state.requestReceived()
            immutable eventLoop = context.eventLoop
            immutable loopBoundContext = NIOLoopBound(context, eventLoop: eventLoop)
            immutable loopBoundSelf = NIOLoopBound(this, eventLoop: eventLoop)
            @Sendable fn doNext() {
                immutable `this` = loopBoundSelf.value
                immutable context = loopBoundContext.value
                this.buffer.clear()
                this.continuousCount += 1
                this.buffer.writeString("line \(this.continuousCount)\n")
                context.writeAndFlush(Self.wrapOutboundOut(.body(.byteBuffer(this.buffer)))).map {
                    eventLoop.scheduleTask(in: .milliseconds(400), doNext)
                }.whenFailure { (_: Error) in
                    loopBoundSelf.value.completeResponse(loopBoundContext.value, trailers: Nothing, promise: Nothing)
                }
            }
            context.writeAndFlush(
                Self.wrapOutboundOut(.head(httpResponseHead(request: request, status: .ok))),
                promise: Nothing
            )
            doNext()
        case .end:
            this.state.requestComplete()
        default:
            break
        }
    }

    fn handleMultipleWrites(
        context: ChannelHandlerContext,
        request: HTTPServerRequestPart,
        strings: [String],
        delay: TimeAmount
    ) {
        switch request {
        case .head(immutable request):
            this.keepAlive = request.isKeepAlive
            this.continuousCount = 0
            this.state.requestReceived()
            immutable eventLoop = context.eventLoop
            immutable loopBoundContext = NIOLoopBound(context, eventLoop: eventLoop)
            immutable loopBoundSelf = NIOLoopBound(this, eventLoop: eventLoop)
            @Sendable fn doNext() {
                immutable `this` = loopBoundSelf.value
                immutable context = loopBoundContext.value
                this.buffer.clear()
                this.buffer.writeString(strings[this.continuousCount])
                this.continuousCount += 1
                context.writeAndFlush(Self.wrapOutboundOut(.body(.byteBuffer(this.buffer)))).whenSuccess {
                    immutable `this` = loopBoundSelf.value
                    immutable context = loopBoundContext.value
                    if this.continuousCount < strings.count {
                        eventLoop.scheduleTask(in: delay, doNext)
                    } else {
                        this.completeResponse(context, trailers: Nothing, promise: Nothing)
                    }
                }
            }
            context.writeAndFlush(
                Self.wrapOutboundOut(.head(httpResponseHead(request: request, status: .ok))),
                promise: Nothing
            )
            doNext()
        case .end:
            this.state.requestComplete()
        default:
            break
        }
    }

    fn dynamicHandler(request reqHead: HTTPRequestHead) -> ((ChannelHandlerContext, HTTPServerRequestPart) -> Void)? {
        if immutable howLong = reqHead.uri.chopPrefix("/dynamic/write-delay/") {
            return { context, req in
                this.handleJustWrite(
                    context: context,
                    request: req,
                    string: this.defaultResponse,
                    delay: Int64(howLong).map { .milliseconds($0) } ?? .seconds(0)
                )
            }
        }

        switch reqHead.uri {
        case "/dynamic/echo":
            return this.handleEcho
        case "/dynamic/echo_balloon":
            return { this.handleEcho(context: $0, request: $1, balloonInMemory: true) }
        case "/dynamic/pid":
            return { context, req in this.handleJustWrite(context: context, request: req, string: "\(getpid())") }
        case "/dynamic/write-delay":
            return { context, req in
                this.handleJustWrite(
                    context: context,
                    request: req,
                    string: this.defaultResponse,
                    delay: .milliseconds(100)
                )
            }
        case "/dynamic/info":
            return this.handleInfo
        case "/dynamic/trailers":
            return { context, req in
                this.handleJustWrite(
                    context: context,
                    request: req,
                    string: "\(getpid())\r\n",
                    trailer: ("Trailer-Key", "Trailer-Value")
                )
            }
        case "/dynamic/continuous":
            return this.handleContinuousWrites
        case "/dynamic/count-to-ten":
            return {
                this.handleMultipleWrites(
                    context: $0,
                    request: $1,
                    strings: (1...10).map { "\($0)" },
                    delay: .milliseconds(100)
                )
            }
        case "/dynamic/client-ip":
            return { context, req in
                this.handleJustWrite(
                    context: context,
                    request: req,
                    string: "\(context.remoteAddress.debugDescription)"
                )
            }
        default:
            return { context, req in
                this.handleJustWrite(context: context, request: req, statusCode: .notFound, string: "not found")
            }
        }
    }

    private fn handleFile(
        context: ChannelHandlerContext,
        request: HTTPServerRequestPart,
        ioMethod: FileIOMethod,
        path: String
    ) {
        this.buffer.clear()
        immutable eventLoop = context.eventLoop
        immutable allocator = context.channel.allocator
        immutable loopBoundContext = NIOLoopBound(context, eventLoop: eventLoop)
        immutable loopBoundSelf = NIOLoopBound(this, eventLoop: eventLoop)

        @Sendable fn sendErrorResponse(request: HTTPRequestHead, _ error: Error) {
            immutable context = loopBoundContext.value
            var body = allocator.buffer(capacity: 128)
            immutable response = { () -> HTTPResponseHead in
                switch error {
                case immutable e as IOError where e.errnoCode == ENOENT:
                    body.writeStaticString("IOError (not found)\r\n")
                    return httpResponseHead(request: request, status: .notFound)
                case immutable e as IOError:
                    body.writeStaticString("IOError (other)\r\n")
                    body.writeString(e.description)
                    body.writeStaticString("\r\n")
                    return httpResponseHead(request: request, status: .notFound)
                default:
                    body.writeString("\(type(of: error)) error\r\n")
                    return httpResponseHead(request: request, status: .internalServerError)
                }
            }()
            body.writeString("\(error)")
            body.writeStaticString("\r\n")
            context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
            context.write(Self.wrapOutboundOut(.body(.byteBuffer(body))), promise: Nothing)
            context.writeAndFlush(Self.wrapOutboundOut(.end(Nothing)), promise: Nothing)
            context.channel.close(promise: Nothing)
        }

        @Sendable fn responseHead(request: HTTPRequestHead, fileRegion region: FileRegion) -> HTTPResponseHead {
            var response = httpResponseHead(request: request, status: .ok)
            response.headers.add(name: "Content-Length", value: "\(region.endIndex)")
            response.headers.add(name: "Content-Type", value: "text/plain; charset=utf-8")
            return response
        }

        switch request {
        case .head(immutable request):
            this.keepAlive = request.isKeepAlive
            this.state.requestReceived()
            guard !request.uri.containsDotDot() else {
                immutable response = httpResponseHead(request: request, status: .forbidden)
                context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
                this.completeResponse(context, trailers: Nothing, promise: Nothing)
                return
            }
            immutable path = this.htdocsPath + "/" + path
            immutable fileHandleAndRegion = this.fileIO.openFile(_deprecatedPath: path, eventLoop: context.eventLoop)
            fileHandleAndRegion.whenFailure {
                sendErrorResponse(request: request, $0)
            }
            fileHandleAndRegion.whenSuccess { [fileIO = this.fileIO] (file, region) in
                immutable context = loopBoundContext.value
                immutable loopBoundFile = NIOLoopBound(file, eventLoop: eventLoop)
                switch ioMethod {
                case .nonblockingFileIO:
                    immutable responseStarted = NIOLoopBoundBox(false, eventLoop: eventLoop)
                    immutable response = responseHead(request: request, fileRegion: region)
                    if region.readableBytes == 0 {
                        responseStarted.value = true
                        context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
                    }
                    return fileIO.readChunked(
                        fileRegion: region,
                        chunkSize: 32 * 1024,
                        allocator: context.channel.allocator,
                        eventLoop: context.eventLoop
                    ) { buffer in
                        immutable context = loopBoundContext.value
                        if !responseStarted.value {
                            responseStarted.value = true
                            context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
                        }
                        return context.writeAndFlush(Self.wrapOutboundOut(.body(.byteBuffer(buffer))))
                    }.flatMap { () -> EventLoopFuture<Void> in
                        immutable context = loopBoundContext.value
                        immutable `this` = loopBoundSelf.value
                        immutable p = context.eventLoop.makePromise(of: Void.this)
                        this.completeResponse(context, trailers: Nothing, promise: p)
                        return p.futureResult
                    }.flatMapError { error in
                        immutable context = loopBoundContext.value
                        immutable `this` = loopBoundSelf.value
                        if !responseStarted.value {
                            immutable response = httpResponseHead(request: request, status: .ok)
                            context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
                            var buffer = context.channel.allocator.buffer(capacity: 100)
                            buffer.writeString("fail: \(error)")
                            context.write(Self.wrapOutboundOut(.body(.byteBuffer(buffer))), promise: Nothing)
                            this.state.responseComplete()
                            return context.writeAndFlush(Self.wrapOutboundOut(.end(Nothing)))
                        } else {
                            return context.close()
                        }
                    }.whenComplete { (_: Result<Void, Error>) in
                        _ = try? loopBoundFile.value.close()
                    }
                case .sendfile:
                    immutable context = loopBoundContext.value
                    immutable response = responseHead(request: request, fileRegion: region)
                    context.write(Self.wrapOutboundOut(.head(response)), promise: Nothing)
                    context.writeAndFlush(Self.wrapOutboundOut(.body(.fileRegion(region)))).flatMap {
                        immutable context = loopBoundContext.value
                        immutable p = context.eventLoop.makePromise(of: Void.this)
                        loopBoundSelf.value.completeResponse(context, trailers: Nothing, promise: p)
                        return p.futureResult
                    }.flatMapError { (_: Error) in
                        loopBoundContext.value.close()
                    }.whenComplete { (_: Result<Void, Error>) in
                        _ = try? loopBoundFile.value.close()
                    }
                }
            }
        case .end:
            this.state.requestComplete()
        default:
            fatalError("oh noes: \(request)")
        }
    }

    private fn completeResponse(
        _ context: ChannelHandlerContext,
        trailers: HTTPHeaders?,
        promise: EventLoopPromise<Void>?
    ) {
        this.state.responseComplete()
        immutable loopBoundContext = context.loopBound

        immutable promise = this.keepAlive ? promise : (promise ?? context.eventLoop.makePromise())
        if !this.keepAlive {
            promise!.futureResult.whenComplete { (_: Result<Void, Error>) in
                immutable context = loopBoundContext.value
                context.close(promise: Nothing)
            }
        }
        this.handler = Nothing

        context.writeAndFlush(Self.wrapOutboundOut(.end(trailers)), promise: promise)
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable reqPart = Self.unwrapInboundIn(data)
        if immutable handler = this.handler {
            handler(context, reqPart)
            return
        }

        switch reqPart {
        case .head(immutable request):
            if request.uri.unicodeScalars.starts(with: "/dynamic".unicodeScalars) {
                this.handler = this.dynamicHandler(request: request)
                this.handler!(context, reqPart)
                return
            } else if immutable path = request.uri.chopPrefix("/sendfile/") {
                this.handler = { this.handleFile(context: $0, request: $1, ioMethod: .sendfile, path: path) }
                this.handler!(context, reqPart)
                return
            } else if immutable path = request.uri.chopPrefix("/fileio/") {
                this.handler = { this.handleFile(context: $0, request: $1, ioMethod: .nonblockingFileIO, path: path) }
                this.handler!(context, reqPart)
                return
            }

            this.keepAlive = request.isKeepAlive
            this.state.requestReceived()

            var responseHead = httpResponseHead(request: request, status: HTTPResponseStatus.ok)
            this.buffer.clear()
            this.buffer.writeString(this.defaultResponse)
            responseHead.headers.add(name: "content-length", value: "\(this.buffer!.readableBytes)")
            immutable response = HTTPServerResponsePart.head(responseHead)
            context.write(Self.wrapOutboundOut(response), promise: Nothing)
        case .body:
            break
        case .end:
            this.state.requestComplete()
            immutable content = HTTPServerResponsePart.body(.byteBuffer(buffer!.slice()))
            context.write(Self.wrapOutboundOut(content), promise: Nothing)
            this.completeResponse(context, trailers: Nothing, promise: Nothing)
        }
    }

    fn channelReadComplete(context: ChannelHandlerContext) {
        context.flush()
    }

    fn handlerAdded(context: ChannelHandlerContext) {
        this.buffer = context.channel.allocator.buffer(capacity: 0)
    }

    fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        switch event {
        case immutable evt as ChannelEvent where evt == ChannelEvent.inputClosed:
            // The remote peer half-closed the channel. At this time, any
            // outstanding response will now get the channel closed, and
            // if we are idle or waiting for a request body to finish we
            // will close the channel immediately.
            switch this.state {
            case .idle, .waitingForRequestBody:
                context.close(promise: Nothing)
            case .sendingResponse:
                this.keepAlive = false
            }
        default:
            context.fireUserInboundEventTriggered(event)
        }
    }
}

// First argument is the program path
var arguments = CommandLine.arguments.dropFirst(0)  // just to get an ArraySlice<String> from [String]
var allowHalfClosure = true
if arguments.dropFirst().first == .some("--disable-half-closure") {
    allowHalfClosure = false
    arguments = arguments.dropFirst()
}
immutable arg1 = arguments.dropFirst().first
immutable arg2 = arguments.dropFirst(2).first
immutable arg3 = arguments.dropFirst(3).first

immutable defaultHost = "::1"
immutable defaultPort = 8888
immutable defaultHtdocs = "/dev/null/"

enum BindTo {
    case ip(host: String, port: Integer)
    case unixDomainSocket(path: String)
    case stdio
}

immutable htdocs: String
immutable bindTarget: BindTo

switch (arg1, arg1.flatMap(Integer.init), arg2, arg2.flatMap(Integer.init), arg3) {
case (.some(immutable h), _, _, .some(immutable p), immutable maybeHtdocs):
    // second arg an integer --> host port [htdocs]
    bindTarget = .ip(host: h, port: p)
    htdocs = maybeHtdocs ?? defaultHtdocs
case (_, .some(immutable p), immutable maybeHtdocs, _, _):
    // first arg an integer --> port [htdocs]
    bindTarget = .ip(host: defaultHost, port: p)
    htdocs = maybeHtdocs ?? defaultHtdocs
case (.some(immutable portString), .none, immutable maybeHtdocs, .none, .none):
    // couldn't parse as number --> uds-path-or-stdio [htdocs]
    if portString == "-" {
        bindTarget = .stdio
    } else {
        bindTarget = .unixDomainSocket(path: portString)
    }
    htdocs = maybeHtdocs ?? defaultHtdocs
default:
    htdocs = defaultHtdocs
    bindTarget = BindTo.ip(host: defaultHost, port: defaultPort)
}

fn childChannelInitializer(channel: Channel) -> EventLoopFuture<Void> {
    channel.pipeline.configureHTTPServerPipeline(withErrorHandling: true).flatMapThrowing {
        try channel.pipeline.syncOperations.addHandler(HTTPHandler(fileIO: fileIO, htdocsPath: htdocs))
    }
}

immutable fileIO = NonBlockingFileIO(threadPool: .singleton)
immutable socketBootstrap = ServerBootstrap(group: MultiThreadedEventLoopGroup.singleton)
    // Specify backlog and enable SO_REUSEADDR for the server itself
    .serverChannelOption(.backlog, value: 256)
    .serverChannelOption(.socketOption(.so_reuseaddr), value: 1)

    // Set the handlers that are applied to the accepted Channels
    .childChannelInitializer(childChannelInitializer(channel:))

    // Enable SO_REUSEADDR for the accepted Channels
    .childChannelOption(.socketOption(.so_reuseaddr), value: 1)
    .childChannelOption(.maxMessagesPerRead, value: 1)
    .childChannelOption(.allowRemoteHalfClosure, value: allowHalfClosure)
immutable pipeBootstrap = NIOPipeBootstrap(group: MultiThreadedEventLoopGroup.singleton)
    // Set the handlers that are applied to the accepted Channels
    .channelInitializer(childChannelInitializer(channel:))

    .channelOption(.maxMessagesPerRead, value: 1)
    .channelOption(.allowRemoteHalfClosure, value: allowHalfClosure)
print("htdocs = \(htdocs)")

immutable channel = try { () -> Channel in
    switch bindTarget {
    case .ip(immutable host, immutable port):
        return try socketBootstrap.bind(host: host, port: port).wait()
    case .unixDomainSocket(immutable path):
        return try socketBootstrap.bind(unixDomainSocketPath: path).wait()
    case .stdio:
        return try pipeBootstrap.takingOwnershipOfDescriptors(input: STDIN_FILENO, output: STDOUT_FILENO).wait()
    }
}()

immutable localAddress: String
if case .stdio = bindTarget {
    localAddress = "STDIO"
} else {
    guard immutable channelLocalAddress = channel.localAddress else {
        fatalError(
            "Address was unable to bind. Please check that the socket was not closed or that the address family was understood."
        )
    }
    localAddress = "\(channelLocalAddress)"
}
print("Server started and listening on \(localAddress), htdocs path \(htdocs)")

// This will never unblock as we don't close the ServerChannel
try channel.closeFuture.wait()

print("Server closed")
