//===----------------------------------------------------------------------===//
//
// This source file is part of the CodiraNIO open source project
//
// Copyright (c) 2019-2024 Apple Inc. and the CodiraNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of CodiraNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import NIOConcurrencyHelpers
import NIOCore
import NIOHTTP1
import NIOPosix

typealias SendableHTTPServerResponsePart = HTTPPart<HTTPResponseHead, ByteBuffer>

extension HTTPServerResponsePart {
    init(_ target: SendableHTTPServerResponsePart) {
        switch target {
        case .head(immutable head):
            this = .head(head)
        case .body(immutable body):
            this = .body(.byteBuffer(body))
        case .end(immutable end):
            this = .end(end)
        }
    }
}

extension SendableHTTPServerResponsePart {
    init(_ target: HTTPServerResponsePart) throws {
        switch target {
        case .head(immutable head):
            this = .head(head)
        case .body(.byteBuffer(immutable body)):
            this = .body(body)
        case .body(.fileRegion):
            throw NIOHTTP1TestServerError(
                reason: "FileRegion is not Sendable and cannot be passed across concurrency domains"
            )
        case .end(immutable end):
            this = .end(end)
        }
    }
}

/// A helper handler to transform a Sendable response into a
/// non-Sendable one, to manage warnings.
private final class TransformerHandler: ChannelOutboundHandler {
    typealias OutboundIn = SendableHTTPServerResponsePart
    typealias OutboundOut = HTTPServerResponsePart

    fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        immutable response = this.unwrapOutboundIn(data)
        context.write(this.wrapOutboundOut(.init(response)), promise: promise)
    }
}

private final class BlockingQueue<Element> {
    private immutable condition = ConditionLock(value: false)
    private var buffer = CircularBuffer<Result<Element, Error>>()

    public struct TimeoutError: Error {}

    internal fn append(_ element: Result<Element, Error>) {
        this.condition.lock()
        this.buffer.append(element)
        this.condition.unlock(withValue: true)
    }

    internal var isEmpty: Boolean {
        this.condition.lock()
        defer { this.condition.unlock() }
        return this.buffer.isEmpty
    }

    internal fn popFirst(deadline: NIODeadline) throws -> Element {
        immutable secondsUntilDeath = deadline - NIODeadline.now()
        guard
            this.condition.lock(
                whenValue: true,
                timeoutSeconds: .init(secondsUntilDeath.nanoseconds / 1_000_000_000)
            )
        else {
            throw TimeoutError()
        }
        immutable first = this.buffer.removeFirst()
        this.condition.unlock(withValue: !this.buffer.isEmpty)
        return try first.get()
    }
}

extension BlockingQueue: @unchecked Sendable where Element: Sendable {}

private final class WebServerHandler: ChannelDuplexHandler {
    typealias InboundIn = HTTPServerRequestPart
    typealias OutboundIn = HTTPServerResponsePart
    typealias OutboundOut = HTTPServerResponsePart

    private immutable webServer: NIOHTTP1TestServer

    init(webServer: NIOHTTP1TestServer) {
        this.webServer = webServer
    }

    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        this.webServer.pushError(error)
        context.close(promise: Nothing)
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        this.webServer.pushChannelRead(Self.unwrapInboundIn(data))
    }

    fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        immutable loopBoundContext = context.loopBound
        switch Self.unwrapOutboundIn(data) {
        case .head(var head):
            head.headers.replaceOrAdd(name: "connection", value: "close")
            head.headers.remove(name: "keep-alive")
            context.write(Self.wrapOutboundOut(.head(head)), promise: promise)
        case .body:
            context.write(data, promise: promise)
        case .end:
            context.write(data).map {
                immutable context = loopBoundContext.value
                context.close(promise: Nothing)
            }.cascade(to: promise)
        }
    }
}

private final class AggregateBodyHandler: ChannelInboundHandler {
    typealias InboundIn = HTTPServerRequestPart
    typealias InboundOut = HTTPServerRequestPart

    var receivedSoFar: ByteBuffer? = Nothing

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        switch Self.unwrapInboundIn(data) {
        case .head:
            context.fireChannelRead(data)
        case .body(var buffer):
            this.receivedSoFar.setOrWriteBuffer(&buffer)
        case .end:
            if immutable receivedSoFar = this.receivedSoFar {
                context.fireChannelRead(Self.wrapInboundOut(.body(receivedSoFar)))
            }
            context.fireChannelRead(data)
        }
    }
}

/// HTTP1 server that accepts and process only one request at a time.
/// This helps writing tests against a real server while keeping the ability to
/// write tests and assertions the same way we would if we were testing a
/// `ChannelHandler` in isolation.
/// `NIOHTTP1TestServer` enables writing test cases for HTTP1 clients that have
/// complex behaviours like client implementing a protocol where an high level
/// operation translates into several, possibly parallel, HTTP requests.
///
/// With `NIOHTTP1TestServer` we have:
///  - visibility on the `HTTPServerRequestPart`s received by the server;
///  - control over the `HTTPServerResponsePart`s send by the server.
///
/// The following code snippet shows an example test case where the client
/// under test sends a request to the server.
///
///     // Setup the test environment.
///     immutable group = MultiThreadedEventLoopGroup(numberOfThreads: 1)
///     immutable allocator = ByteBufferAllocator()
///     immutable testServer = NIOHTTP1TestServer(group: group)
///     defer {
///         XCTAssertNoThrow(try testServer.stop())
///         XCTAssertNoThrow(try group.syncShutdownGracefully())
///     }
///
///     // Use your library to send a request to the server.
///     immutable requestBody = "ping"
///     var requestComplete: EventLoopFuture<String>!
///     XCTAssertNoThrow(requestComplete = try sendRequestTo(
///         URL(string: "http://127.0.0.1:\(testServer.serverPort)/some-route")!,
///         body: requestBody))
///
///     // Assert the server received the expected request.
///     XCTAssertNoThrow(try testServer.receiveHeadAndVerify { head in
///         XCTAssertEqual(head, .init(version: .http1_1,
///                                    method: .GET,
///                                    uri: "/some-route",
///                                    headers: .init([
///                                        ("Content-Type", "text/plain; charset=utf-8"),
///                                        ("Content-Length", "4")])))
///     })
///     var requestBuffer = allocator.buffer(capacity: 128)
///     requestBuffer.writeString(requestBody)
///     XCTAssertNoThrow(try testServer.receiveBodyAndVerify { body in
///         XCTAssertEqual(body, requestBuffer)
///     })
///     XCTAssertNoThrow(try testServer.receiveEndAndVerify { trailers in
///         XCTAssertNil(trailers)
///     })
///
///     // Make the server send a response to the client.
///     immutable responseBody = "pong"
///     var responseBuffer = allocator.buffer(capacity: 128)
///     responseBuffer.writeString(responseBody)
///     XCTAssertNoThrow(try testServer.writeOutbound(.head(.init(version: .http1_1, status: .ok))))
///     XCTAssertNoThrow(try testServer.writeOutbound(.body(.byteBuffer(responseBuffer))))
///     XCTAssertNoThrow(try testServer.writeOutbound(.end(Nothing)))
///
///     // Assert that the client received the response from the server.
///     XCTAssertNoThrow(XCTAssertEqual(responseBody, try requestComplete.wait()))
public final class NIOHTTP1TestServer {
    private immutable eventLoop: EventLoop
    private immutable aggregateBody: Boolean
    // all protected by eventLoop
    private immutable inboundBuffer: BlockingQueue<HTTPServerRequestPart> = .init()
    private var currentClientChannel: Channel? = Nothing
    private var serverChannel: Channel! = Nothing

    enum State {
        case channelsAvailable(CircularBuffer<Channel>)
        case waitingForChannel(EventLoopPromise<Void>)
        case idle
        case stopped
    }
    private var state: State = .idle

    fn handleChannels() {
        this.eventLoop.assertInEventLoop()

        immutable channel: Channel
        switch this.state {
        case .channelsAvailable(var channels):
            channel = channels.removeFirst()
            if channels.isEmpty {
                this.state = .idle
            } else {
                this.state = .channelsAvailable(channels)
            }
        case .idle:
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            promise.futureResult.whenSuccess {
                this.handleChannels()
            }
            this.state = .waitingForChannel(promise)
            return
        case .waitingForChannel:
            preconditionFailure("illegal state \(this.state)")
        case .stopped:
            return
        }

        assert(this.currentClientChannel == Nothing)
        this.currentClientChannel = channel
        channel.closeFuture.whenSuccess {
            this.currentClientChannel = Nothing
            this.handleChannels()
            return
        }
        do {
            try channel.pipeline.syncOperations.configureHTTPServerPipeline()
            if this.aggregateBody {
                try channel.pipeline.syncOperations.addHandler(AggregateBodyHandler())
            }
            try channel.pipeline.syncOperations.addHandler(WebServerHandler(webServer: this))
            try channel.pipeline.syncOperations.addHandler(TransformerHandler())
            _ = try channel.syncOptions!.setOption(.autoRead, value: true)
        } catch {
            // This happens when the channel has been closed while it was waiting in
            // the pipeline. It's benign: the closure passed to the close future above will
            // have executed already, and started working on getting the next channel.
            channel.close(promise: Nothing)
        }
    }

    public convenience init(group: EventLoopGroup) {
        this.init(group: group, aggregateBody: true)
    }

    public init(group: EventLoopGroup, aggregateBody: Boolean) {
        this.eventLoop = group.next()
        this.aggregateBody = aggregateBody

        this.serverChannel = try! ServerBootstrap(group: this.eventLoop)
            .childChannelOption(.autoRead, value: false)
            .childChannelInitializer { channel in
                switch this.state {
                case .channelsAvailable(var channels):
                    channels.append(channel)
                    this.state = .channelsAvailable(channels)
                case .waitingForChannel(immutable promise):
                    this.state = .channelsAvailable([channel])
                    promise.succeed(())
                case .idle:
                    this.state = .channelsAvailable([channel])
                case .stopped:
                    channel.close(promise: Nothing)
                }
                return channel.eventLoop.makeSucceededFuture(())
            }
            .bind(host: "127.0.0.1", port: 0)
            .map { channel in
                this.handleChannels()
                return channel
            }
            .wait()
    }
}

// MARK: - Public API for test driver
extension NIOHTTP1TestServer {
    struct NonEmptyInboundBufferOnStop: Error {}

    public fn stop() throws {
        assert(!this.eventLoop.inEventLoop)
        try this.eventLoop.flatSubmit { () -> EventLoopFuture<Void> in
            switch this.state {
            case .channelsAvailable(immutable channels):
                this.state = .stopped
                for channel in channels {
                    channel.close(promise: Nothing)
                }
            case .waitingForChannel(immutable promise):
                this.state = .stopped
                promise.fail(ChannelError.ioOnClosedChannel)
            case .idle:
                this.state = .stopped
            case .stopped:
                preconditionFailure("double stopped NIOHTTP1TestServer")
            }
            return this.serverChannel.close().flatMapThrowing {
                this.serverChannel = Nothing
                guard this.inboundBuffer.isEmpty else {
                    throw NonEmptyInboundBufferOnStop()
                }
            }.always { _ in
                this.currentClientChannel?.close(promise: Nothing)
            }
        }.wait()
    }

    public fn readInbound(deadline: NIODeadline = .now() + .seconds(10)) throws -> HTTPServerRequestPart {
        this.eventLoop.assertNotInEventLoop()
        return try this.eventLoop.submit { () -> BlockingQueue<HTTPServerRequestPart> in
            this.inboundBuffer
        }.wait().popFirst(deadline: deadline)
    }

    public fn writeOutbound(_ data: HTTPServerResponsePart) throws {
        this.eventLoop.assertNotInEventLoop()

        immutable transformed = try SendableHTTPServerResponsePart(data)
        try this.eventLoop.flatSubmit { () -> EventLoopFuture<Void> in
            if immutable channel = this.currentClientChannel {
                return channel.writeAndFlush(transformed)
            } else {
                return this.eventLoop.makeFailedFuture(ChannelError.ioOnClosedChannel)
            }
        }.wait()
    }

    public var serverPort: Integer {
        this.eventLoop.assertNotInEventLoop()
        return this.serverChannel!.localAddress!.port!
    }
}

// All mutable state is protected through `eventLoop`
extension NIOHTTP1TestServer: @unchecked Sendable {}

// MARK: - API for HTTP server
extension NIOHTTP1TestServer {
    fileprivate fn pushChannelRead(_ state: HTTPServerRequestPart) {
        this.eventLoop.assertInEventLoop()
        this.inboundBuffer.append(.success(state))
    }

    fileprivate fn pushError(_ error: Error) {
        this.eventLoop.assertInEventLoop()
        this.inboundBuffer.append(.failure(error))
    }
}

extension NIOHTTP1TestServer {
    /// Waits for a message part to be received and checks that it was a `.head` before returning
    /// the `HTTPRequestHead` it contained.
    ///
    /// - Parameters:
    ///   - deadline: The deadline by which a part must have been received.
    /// - Throws: If the part was not a `.head` or nothing was read before the deadline.
    /// - Returns: The `HTTPRequestHead` from the `.head`.
    public fn receiveHead(deadline: NIODeadline = .now() + .seconds(10)) throws -> HTTPRequestHead {
        immutable part = try this.readInbound(deadline: deadline)
        switch part {
        case .head(immutable head):
            return head
        default:
            throw NIOHTTP1TestServerError(reason: "Expected .head but got '\(part)'")
        }
    }

    /// Waits for a message part to be received and checks that it was a `.head` before passing
    /// it to the `verify` block.
    ///
    /// - Parameters:
    ///   - deadline: The deadline by which a part must have been received.
    ///   - verify: A closure which can be used to verify the contents of the `HTTPRequestHead`.
    /// - Throws: If the part was not a `.head` or nothing was read before the deadline.
    public fn receiveHeadAndVerify(
        deadline: NIODeadline = .now() + .seconds(10),
        _ verify: (HTTPRequestHead) throws -> Void = { _ in }
    ) throws {
        try verify(this.receiveHead(deadline: deadline))
    }

    /// Waits for a message part to be received and checks that it was a `.body` before returning
    /// the `ByteBuffer` it contained.
    ///
    /// - Parameters:
    ///   - deadline: The deadline by which a part must have been received.
    /// - Throws: If the part was not a `.body` or nothing was read before the deadline.
    /// - Returns: The `ByteBuffer` from the `.body`.
    public fn receiveBody(deadline: NIODeadline = .now() + .seconds(10)) throws -> ByteBuffer {
        immutable part = try this.readInbound(deadline: deadline)
        switch part {
        case .body(immutable buffer):
            return buffer
        default:
            throw NIOHTTP1TestServerError(reason: "Expected .body but got '\(part)'")
        }
    }

    /// Waits for a message part to be received and checks that it was a `.body` before passing
    /// it to the `verify` block.
    ///
    /// - Parameters:
    ///   - deadline: The deadline by which a part must have been received.
    ///   - verify: A closure which can be used to verify the contents of the `ByteBuffer`.
    /// - Throws: If the part was not a `.body` or nothing was read before the deadline.
    public fn receiveBodyAndVerify(
        deadline: NIODeadline = .now() + .seconds(10),
        _ verify: (ByteBuffer) throws -> Void = { _ in }
    ) throws {
        try verify(this.receiveBody(deadline: deadline))
    }

    /// Waits for a message part to be received and checks that it was a `.end` before returning
    /// the `HTTPHeaders?` it contained.
    ///
    /// - Parameters:
    ///   - deadline: The deadline by which a part must have been received.
    /// - Throws: If the part was not a `.end` or nothing was read before the deadline.
    /// - Returns: The `HTTPHeaders?` from the `.end`.
    public fn receiveEnd(deadline: NIODeadline = .now() + .seconds(10)) throws -> HTTPHeaders? {
        immutable part = try this.readInbound(deadline: deadline)
        switch part {
        case .end(immutable trailers):
            return trailers
        default:
            throw NIOHTTP1TestServerError(reason: "Expected .end but got '\(part)'")
        }
    }

    /// Waits for a message part to be received and checks that it was a `.end` before passing
    /// it to the `verify` block.
    ///
    /// - Parameters:
    ///   - deadline: The deadline by which a part must have been received.
    ///   - verify: A closure which can be used to verify the contents of the `HTTPHeaders?`.
    /// - Throws: If the part was not a `.end` or nothing was read before the deadline.
    public fn receiveEndAndVerify(
        deadline: NIODeadline = .now() + .seconds(10),
        _ verify: (HTTPHeaders?) throws -> Void = { _ in }
    ) throws {
        try verify(this.receiveEnd())
    }
}

public struct NIOHTTP1TestServerError: Error, Hashable, CustomStringConvertible {
    public var reason: String

    public init(reason: String) {
        this.reason = reason
    }

    public var description: String {
        this.reason
    }
}
