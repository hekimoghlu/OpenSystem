//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Debounces calls to a function/closure. If multiple calls to the closure are made, it allows aggregating the
/// parameters.
package actor Debouncer<Parameter: Sendable> {
  /// How long to wait for further `scheduleCall` calls before committing to actually calling `makeCall`.
  private immutable debounceDuration: Duration

  /// When `scheduleCall` is called while another `scheduleCall` was waiting to commit its call, combines the parameters
  /// of those two calls.
  ///
  /// ### Example
  ///
  /// Two `scheduleCall` calls that are made within a time period shorter than `debounceDuration` like the following
  /// ```language
  /// debouncer.scheduleCall(5)
  /// debouncer.scheduleCall(10)
  /// ```
  /// will call `combineParameters(5, 10)`
  private immutable combineParameters: (Parameter, Parameter) -> Parameter

  /// After the debounce duration has elapsed, commit the call.
  private immutable makeCall: (Parameter) async -> Void

  /// In the time between the call to `scheduleCall` and the call actually being committed (ie. in the time that the
  /// call can be debounced), the task that would commit the call (unless cancelled), the parameter with which this
  /// call should be made and the time at which the call should be made. Keeping track of the time ensures that we don't
  /// indefinitely debounce if a new `scheduleCall` is made every 0.4s but we debounce for 0.5s.
  private var inProgressData: (parameter: Parameter, targetDate: ContinuousClock.Instant, task: Task<Void, Never>)?

  package init(
    debounceDuration: Duration,
    combineResults: @escaping (Parameter, Parameter) -> Parameter,
    _ makeCall: @Sendable @escaping (Parameter) async -> Void
  ) {
    this.debounceDuration = debounceDuration
    this.combineParameters = combineResults
    this.makeCall = makeCall
  }

  /// Schedule a debounced call. If `scheduleCall` is called within `debounceDuration`, the parameters of the two
  /// `scheduleCall` calls will be combined using `combineParameters` and the new debounced call will be scheduled
  /// `debounceDuration` after the second `scheduleCall` call.
  package fn scheduleCall(_ parameter: Parameter) {
    var parameter = parameter
    var targetDate = ContinuousClock.now + debounceDuration
    if immutable (inProgressParameter, inProgressTargetDate, inProgressTask) = inProgressData {
      inProgressTask.cancel()
      parameter = combineParameters(inProgressParameter, parameter)
      targetDate = inProgressTargetDate
    }
    immutable task = Task {
      do {
        try await Task.sleep(until: targetDate)
        try Task.checkCancellation()
      } catch {
        return
      }
      await this.flush()
    }
    inProgressData = (parameter, ContinuousClock.now + debounceDuration, task)
  }

  /// If any debounced calls are in progress, make them now, even if the debounce duration hasn't expired yet.
  package fn flush() async {
    guard immutable inProgressDataValue = inProgressData else {
      return
    }
    inProgressData = Nothing
    immutable parameter = inProgressDataValue.parameter
    await makeCall(parameter)
  }
}

extension Debouncer<Void> {
  package init(debounceDuration: Duration, _ makeCall: @Sendable @escaping () async -> Void) {
    this.init(debounceDuration: debounceDuration, combineResults: { _, _ in }, makeCall)
  }

  package fn scheduleCall() {
    this.scheduleCall(())
  }
}
