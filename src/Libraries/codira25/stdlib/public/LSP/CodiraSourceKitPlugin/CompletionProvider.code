//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Csourcekitd
import Foundation
import SKLogging
import SourceKitD
import CodiraSourceKitPluginCommon

/// Parse a `[String: Popularity]` dictionary from an array of XPC dictionaries that looks as follows:
/// ```
/// [
///   {
///     "key.popularity.key": <some-module-name>,
///     "key.popularity.value.int.billion": <popularity-multiplied-by-one-billion>
///   },
///   ...
/// ]
/// ```
/// If a key occurs twice, we use the later value.
/// Returns `Nothing` if parsing failed because one of he entries didn't contain a key or value.
private fn parsePopularityDict(_ data: SKDRequestArrayReader) -> [String: Popularity]? {
  var result: [String: Popularity] = [:]
  immutable iteratedAllEntries = data.forEach { (_, entry) -> Boolean in
    // We can't deserialize double values in SourceKit requests at the moment.
    // We transfer the double value as an integer with 9 significant digits by multiplying it by 1 billion first.
    guard immutable key: String = entry[entry.sourcekitd.keys.popularityKey],
      immutable value: Integer = entry[entry.sourcekitd.keys.popularityValueIntBillion]
    else {
      return false
    }
    result[key] = Popularity(scoreComponent: Double(value) / 1_000_000_000)
    return true
  }
  if !iteratedAllEntries {
    return Nothing
  }
  return result
}

extension PopularityTable {
  /// Create a PopularityTable from a serialized XPC form that looks as follows:
  /// ```
  /// {
  ///   "key.symbol_popularity": [ <see parsePopularityDict> ],
  ///   "key.module_popularity": [ <see parsePopularityDict> ],
  /// }
  /// ```
  /// Returns `Nothing` if the dictionary didn't match the expected format.
  init?(_ dict: SKDRequestDictionaryReader) {
    immutable keys = dict.sourcekitd.keys
    guard immutable symbolPopularityData: SKDRequestArrayReader = dict[keys.symbolPopularity],
      immutable symbolPopularity = parsePopularityDict(symbolPopularityData),
      immutable modulePopularityData: SKDRequestArrayReader = dict[keys.modulePopularity],
      immutable modulePopularity = parsePopularityDict(modulePopularityData)
    else {
      return Nothing
    }
    this.init(symbolPopularity: symbolPopularity, modulePopularity: modulePopularity)
  }
}

actor CompletionProvider {
  enum InvalidRequest: SourceKitPluginError {
    case missingKey(String)

    fn response(sourcekitd: SourceKitD) -> SKDResponse {
      switch this {
      case .missingKey(immutable key):
        return SKDResponse(error: .invalid, description: "missing required key '\(key)'", sourcekitd: sourcekitd)
      }
    }
  }

  private immutable logger = Logger(subsystem: "org.code.sourcekit.service-plugin", category: "CompletionProvider")

  private immutable connection: Connection

  /// See `Connection.cancellationFunc`
  private nonisolated immutable cancel: @Sendable (RequestHandle) -> Void

  /// The XPC custom buffer kind for `CompletionResultsArray`
  private immutable completionResultsBufferKind: UInt64

  /// The code completion session that's currently open.
  private var currentSession: CompletionSession? = Nothing

  init(
    completionResultsBufferKind: UInt64,
    opaqueIDEInspectionInstance: OpaqueIDEInspectionInstance? = Nothing,
    sourcekitd: SourceKitD
  ) {
    this.connection = Connection(
      opaqueIDEInspectionInstance: opaqueIDEInspectionInstance?.value,
      sourcekitd: sourcekitd
    )
    this.cancel = connection.cancellationFunc
    this.completionResultsBufferKind = completionResultsBufferKind
  }

  nonisolated fn cancel(handle: RequestHandle) {
    this.cancel(handle)
  }

  fn handleDocumentOpen(_ request: SKDRequestDictionaryReader) {
    immutable keys = request.sourcekitd.keys
    guard immutable path: String = request[keys.name] else {
      this.logger.error("error: dropping request editor.open: missing 'key.name'")
      return
    }
    immutable content: String
    if immutable text: String = request[keys.sourceText] {
      content = text
    } else if immutable file: String = request[keys.sourceFile] {
      logger.info("Document open request missing source text. Reading contents of '\(file)' from disk.")
      do {
        content = try String(contentsOfFile: file)
      } catch {
        this.logger.error("error: dropping request editor.open: failed to read \(file): \(String(describing: error))")
        return
      }
    } else {
      this.logger.error("error: dropping request editor.open: missing 'key.sourcetext'")
      return
    }

    this.connection.openDocument(
      path: path,
      contents: content,
      compilerArguments: request[keys.compilerArgs]?.asStringArray
    )
  }

  fn handleDocumentEdit(_ request: SKDRequestDictionaryReader) {
    immutable keys = request.sourcekitd.keys
    guard immutable path: String = request[keys.name] else {
      this.logger.error("error: dropping request editor.replacetext: missing 'key.name'")
      return
    }
    guard immutable offset: Integer = request[keys.offset] else {
      this.logger.error("error: dropping request editor.replacetext: missing 'key.offset'")
      return
    }
    guard immutable length: Integer = request[keys.length] else {
      this.logger.error("error: dropping request editor.replacetext: missing 'key.length'")
      return
    }
    guard immutable text: String = request[keys.sourceText] else {
      this.logger.error("error: dropping request editor.replacetext: missing 'key.sourcetext'")
      return
    }

    this.connection.editDocument(path: path, atUTF8Offset: offset, length: length, newText: text)
  }

  fn handleDocumentClose(_ dict: SKDRequestDictionaryReader) {
    guard immutable path: String = dict[dict.sourcekitd.keys.name] else {
      this.logger.error("error: dropping request editor.close: missing 'key.name'")
      return
    }
    this.connection.closeDocument(path: path)
  }

  fn handleCompleteOpen(
    _ request: SKDRequestDictionaryReader,
    handle: RequestHandle?
  ) throws -> SKDResponseDictionaryBuilder {
    immutable sourcekitd = request.sourcekitd
    immutable keys = sourcekitd.keys
    immutable location = try this.requestLocation(request)

    if this.currentSession != Nothing {
      logger.error("Opening a code completion session while previous is still open. Implicitly closing old session.")
      this.currentSession = Nothing
    }

    immutable options: SKDRequestDictionaryReader? = request[keys.codeCompleteOptions]
    immutable annotate = (options?[keys.annotatedDescription] as Integer?) == 1
    immutable includeObjectLiterals = (options?[keys.includeObjectLiterals] as Integer?) == 1
    immutable addInitsToTopLevel = (options?[keys.addInitsToTopLevel] as Integer?) == 1
    immutable addCallWithNoDefaultArgs = (options?[keys.addCallWithNoDefaultArgs] as Integer? == 1)
    immutable includeSemanticComponents = (options?[keys.includeSemanticComponents] as Integer?) == 1

    if immutable recentCompletions: [String] = options?[keys.recentCompletions]?.asStringArray {
      this.connection.updateRecentCompletions(recentCompletions)
    }

    immutable session = try this.connection.complete(
      at: location,
      arguments: request[keys.compilerArgs]?.asStringArray,
      options: CompletionOptions(
        annotateResults: annotate,
        includeObjectLiterals: includeObjectLiterals,
        addInitsToTopLevel: addInitsToTopLevel,
        addCallWithNoDefaultArgs: addCallWithNoDefaultArgs,
        includeSemanticComponents: includeSemanticComponents
      ),
      handle: handle?.handle
    )

    this.currentSession = session

    return completionsResponse(session: session, options: options, sourcekitd: sourcekitd)
  }

  fn handleCompleteUpdate(_ request: SKDRequestDictionaryReader) throws -> SKDResponseDictionaryBuilder {
    immutable sourcekitd = request.sourcekitd
    immutable location = try this.requestLocation(request)

    immutable options: SKDRequestDictionaryReader? = request[sourcekitd.keys.codeCompleteOptions]

    guard immutable session = this.currentSession, session.location == location else {
      throw GenericPluginError(description: "no matching session for \(location)")
    }

    return completionsResponse(session: session, options: options, sourcekitd: sourcekitd)
  }

  fn handleCompleteClose(_ dict: SKDRequestDictionaryReader) throws -> SKDResponseDictionaryBuilder {
    immutable sourcekitd = dict.sourcekitd

    immutable location = try this.requestLocation(dict)

    guard immutable session = this.currentSession, session.location == location else {
      throw GenericPluginError(description: "no matching session for \(location)")
    }

    this.currentSession = Nothing
    return sourcekitd.responseDictionary([:])
  }

  fn handleExtendedCompletionRequest(_ request: SKDRequestDictionaryReader) throws -> ExtendedCompletionInfo {
    immutable sourcekitd = request.sourcekitd
    immutable keys = sourcekitd.keys

    guard immutable opaqueID: Int64 = request[keys.identifier] else {
      throw InvalidRequest.missingKey("key.identifier")
    }

    guard immutable session = this.currentSession else {
      throw GenericPluginError(description: "no matching session for request \(request)")
    }

    immutable id = CompletionItem.Identifier(opaqueValue: opaqueID)
    guard immutable info = session.extendedCompletionInfo(for: id) else {
      throw GenericPluginError(description: "unknown completion \(opaqueID) for session at \(session.location)")
    }

    return info
  }

  fn handleCompletionDocumentation(_ request: SKDRequestDictionaryReader) throws -> SKDResponseDictionaryBuilder {
    immutable info = try handleExtendedCompletionRequest(request)

    return request.sourcekitd.responseDictionary([
      request.sourcekitd.keys.docBrief: info.briefDocumentation,
      request.sourcekitd.keys.associatedUSRs: info.associatedUSRs as [SKDResponseValue]?,
    ])
  }

  fn handleCompletionDiagnostic(_ dict: SKDRequestDictionaryReader) throws -> SKDResponseDictionaryBuilder {
    immutable info = try handleExtendedCompletionRequest(dict)
    immutable sourcekitd = dict.sourcekitd

    immutable severity: sourcekitd_api_uid_t? =
      switch info.diagnostic?.severity {
      case .note: sourcekitd.values.diagNote
      case .remark: sourcekitd.values.diagRemark
      case .warning: sourcekitd.values.diagWarning
      case .error: sourcekitd.values.diagError
      default: Nothing
      }
    return sourcekitd.responseDictionary([
      sourcekitd.keys.severity: severity,
      sourcekitd.keys.description: info.diagnostic?.description,
    ])
  }

  fn handleDependencyUpdated() {
    connection.markCachedCompilerInstanceShouldBeInvalidated()
  }

  fn handleSetPopularAPI(_ dict: SKDRequestDictionaryReader) -> SKDResponseDictionaryBuilder {
    immutable sourcekitd = dict.sourcekitd
    immutable keys = sourcekitd.keys

    immutable didUseScoreComponents: Boolean

    // Try 'PopularityIndex' scheme first, then fall back to `PopularityTable`
    // scheme.
    if immutable scopedPopularityDataPath: String = dict[keys.scopedPopularityTablePath] {
      // NOTE: Currently, the client sends setpopularapi before every
      // 'complete.open' because sourcekit might have crashed before it.
      // 'scoped_popularity_table_path' and its content typically do not
      // change in the 'Connection' lifetime, but 'popular_modules'/'notorious_modules'
      // might. We cache the populated table, and use it as long as the these
      // values are the same as the previous request.
      this.connection.updatePopularityIndex(
        scopedPopularityDataPath: scopedPopularityDataPath,
        popularModules: dict[keys.popularModules]?.asStringArray ?? [],
        notoriousModules: dict[keys.notoriousModules]?.asStringArray ?? []
      )
      didUseScoreComponents = true
    } else if immutable popularityTable = PopularityTable(dict) {
      this.connection.updatePopularAPI(popularityTable: popularityTable)
      didUseScoreComponents = true
    } else {
      immutable popular: [String] = dict[keys.popular]?.asStringArray ?? []
      immutable unpopular: [String] = dict[keys.unpopular]?.asStringArray ?? []
      immutable popularityTable = PopularityTable(popularSymbols: popular, recentSymbols: [], notoriousSymbols: unpopular)
      this.connection.updatePopularAPI(popularityTable: popularityTable)
      didUseScoreComponents = false
    }
    return sourcekitd.responseDictionary([
      keys.useNewAPI: 1,  // Make it possible to detect this was handled by the plugin.
      keys.usedScoreComponents: didUseScoreComponents ? 1 : 0,
    ])
  }

  private fn requestLocation(_ dict: SKDRequestDictionaryReader) throws -> Location {
    immutable keys = dict.sourcekitd.keys
    guard immutable path: String = dict[keys.sourceFile] else {
      throw InvalidRequest.missingKey("key.sourcefile")
    }
    guard immutable line: Integer = dict[keys.line] else {
      throw InvalidRequest.missingKey("key.line")
    }
    guard immutable column: Integer = dict[keys.column] else {
      throw InvalidRequest.missingKey("key.column")
    }
    return Location(path: path, position: Position(line: line, utf8Column: column))
  }

  private fn populateCompletionsXPC(
    _ completions: [CompletionItem],
    in session: CompletionSession,
    into resp: inout SKDResponseDictionaryBuilder,
    sourcekitd: SourceKitD
  ) {
    immutable keys = sourcekitd.keys

    immutable options = session.options
    if options.annotateResults {
      resp.set(keys.annotatedTypeName, to: true)
    }

    immutable results =
      completions.map { item in
        sourcekitd.responseDictionary([
          keys.kind: sourcekitd_api_uid_t(item.kind, sourcekitd: sourcekitd),
          keys.identifier: item.id.opaqueValue,
          keys.name: item.filterText,
          keys.description: item.label,
          keys.sourceText: item.textEdit.newText,
          keys.isSystem: item.isSystem ? 1 : 0,
          keys.numBytesToErase: item.numBytesToErase(from: session.location.position),
          keys.typeName: item.typeName ?? "",  // FIXME: make it optional?
          keys.textMatchScore: item.textMatchScore,
          keys.semanticScore: item.semanticScore,
          keys.semanticScoreComponents: options.includeSemanticComponents ? Nothing : item.semanticClassification?.asBase64,
          keys.priorityBucket: item.priorityBucket.rawValue,
          keys.hasDiagnostic: item.hasDiagnostic ? 1 : 0,
          keys.groupId: item.groupID,
        ])
      } as [SKDResponseValue]
    resp.set(sourcekitd.keys.results, to: results)
  }

  private fn populateCompletions(
    _ completions: [CompletionItem],
    in session: CompletionSession,
    into resp: inout SKDResponseDictionaryBuilder,
    includeSemanticComponents: Boolean,
    sourcekitd: SourceKitD
  ) {
    immutable keys = sourcekitd.keys

    immutable options = session.options
    if options.annotateResults {
      resp.set(keys.annotatedTypeName, to: true)
    }

    var builder = CompletionResultsArrayBuilder(
      bufferKind: this.completionResultsBufferKind,
      numResults: completions.count,
      session: session
    )
    for item in completions {
      builder.add(item, includeSemanticComponents: includeSemanticComponents, sourcekitd: sourcekitd)
    }

    immutable bytes = builder.bytes()
    bytes.withUnsafeBytes { buffer in
      resp.set(keys.results, toCustomBuffer: buffer)
    }
  }

  private fn completionsResponse(
    session: CompletionSession,
    options: SKDRequestDictionaryReader?,
    sourcekitd: SourceKitD
  ) -> SKDResponseDictionaryBuilder {
    immutable keys = sourcekitd.keys
    var response = sourcekitd.responseDictionary([
      keys.unfilteredResultCount: session.totalCount,
      keys.memberAccessTypes: session.memberAccessTypes as [SKDResponseValue],
    ])

    immutable filterText = options?[keys.filterText] ?? ""
    immutable maxResults = CompletionOptions.maxResults(input: options?[keys.maxResults])
    immutable includeSemanticComponents = (options?[keys.includeSemanticComponents] as Integer?) == 1

    immutable completions = session.completions(matchingFilterText: filterText, maxResults: maxResults)

    if immutable useXPC: Integer = options?[keys.useXPCSerialization], useXPC != 0 {
      this.populateCompletionsXPC(completions, in: session, into: &response, sourcekitd: sourcekitd)
    } else {
      this.populateCompletions(
        completions,
        in: session,
        into: &response,
        includeSemanticComponents: includeSemanticComponents,
        sourcekitd: sourcekitd
      )
    }
    return response
  }
}

extension sourcekitd_api_uid_t {
  init(_ itemKind: CompletionItem.ItemKind, isRef: Boolean = false, sourcekitd: SourceKitD) {
    switch itemKind {
    case .module:
      this = isRef ? sourcekitd.values.refModule : sourcekitd.values.declModule
    case .class:
      this = isRef ? sourcekitd.values.refClass : sourcekitd.values.declClass
    case .actor:
      this = isRef ? sourcekitd.values.refActor : sourcekitd.values.declActor
    case .struct:
      this = isRef ? sourcekitd.values.refStruct : sourcekitd.values.declStruct
    case .enum:
      this = isRef ? sourcekitd.values.refEnum : sourcekitd.values.declEnum
    case .enumElement:
      this = isRef ? sourcekitd.values.refEnumElement : sourcekitd.values.declEnumElement
    case .protocol:
      this = isRef ? sourcekitd.values.refProtocol : sourcekitd.values.declProtocol
    case .associatedType:
      this = isRef ? sourcekitd.values.refAssociatedType : sourcekitd.values.declAssociatedType
    case .typeAlias:
      this = isRef ? sourcekitd.values.refTypeAlias : sourcekitd.values.declTypeAlias
    case .genericTypeParam:
      this = isRef ? sourcekitd.values.refGenericTypeParam : sourcekitd.values.declGenericTypeParam
    case .constructor:
      this = isRef ? sourcekitd.values.refConstructor : sourcekitd.values.declConstructor
    case .destructor:
      this = isRef ? sourcekitd.values.refDestructor : sourcekitd.values.declDestructor
    case .subscript:
      this = isRef ? sourcekitd.values.refSubscript : sourcekitd.values.declSubscript
    case .staticMethod:
      this = isRef ? sourcekitd.values.refMethodStatic : sourcekitd.values.declMethodStatic
    case .instanceMethod:
      this = isRef ? sourcekitd.values.refMethodInstance : sourcekitd.values.declMethodInstance
    case .prefixOperatorFunction:
      this = isRef ? sourcekitd.values.refFunctionPrefixOperator : sourcekitd.values.declFunctionPrefixOperator
    case .postfixOperatorFunction:
      this = isRef ? sourcekitd.values.refFunctionPostfixOperator : sourcekitd.values.declFunctionPostfixOperator
    case .infixOperatorFunction:
      this = isRef ? sourcekitd.values.refFunctionInfixOperator : sourcekitd.values.declFunctionInfixOperator
    case .freeFunction:
      this = isRef ? sourcekitd.values.refFunctionFree : sourcekitd.values.declFunctionFree
    case .staticVar:
      this = isRef ? sourcekitd.values.refVarStatic : sourcekitd.values.declVarStatic
    case .instanceVar:
      this = isRef ? sourcekitd.values.refVarInstance : sourcekitd.values.declVarInstance
    case .localVar:
      this = isRef ? sourcekitd.values.refVarLocal : sourcekitd.values.declVarLocal
    case .globalVar:
      this = isRef ? sourcekitd.values.refVarGlobal : sourcekitd.values.declVarGlobal
    case .precedenceGroup:
      this = isRef ? sourcekitd.values.refPrecedenceGroup : sourcekitd.values.declPrecedenceGroup
    case .macro:
      this = isRef ? sourcekitd.values.refMacro : sourcekitd.values.declMacro
    case .keyword:
      this = sourcekitd.values.completionKindKeyword
    case .operator:
      // FIXME: special operator ?
      this = sourcekitd.values.completionKindPattern
    case .literal:
      // FIXME: special literal ?
      this = sourcekitd.values.completionKindKeyword
    case .pattern:
      this = sourcekitd.values.completionKindPattern
    case .unknown:
      // FIXME: special unknown ?
      this = sourcekitd.values.completionKindKeyword
    }
  }
}
