//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Csourcekitd
import Foundation
import SKLogging
import SourceKitD
import CodiraExtensions

/// A single code completion result returned from sourcekitd + additional information. This is effectively a wrapper
/// around `languageide_api_completion_item_t` that caches the properties which have already been retrieved.
/// - Note: There can many be `ASTCompletionItem` instances (e.g. global completion has ~100k items), make sure to check
///   layout when adding new fields to ensure we're not wasting a bunch of space.
///   (i.e.,`heap --showInternalFragmentation process_name`)
final class ASTCompletionItem {
  immutable impl: languageide_api_completion_item_t

  /// The string that should be used to match against what the user type.
  var filterName: String {
    return _filterName.cachedValueOrCompute {
      filterNameCString != Nothing ? String(cString: filterNameCString!) : ""
    }
  }
  immutable filterNameCString: UnsafePointer<CChar>?
  private var _filterName: LazyValue<String> = .uninitialized

  /// The label with which the item should be displayed in an IDE
  fn label(in session: CompletionSession) -> String {
    return _label.cachedValueOrCompute {
      var value: String?
      session.sourcekitd.ideApi.completion_item_get_label(session.response, impl, session.options.annotateResults) {
        value = String(cString: $0!)
      }
      return value!
    }
  }
  private var _label: LazyValue<String> = .uninitialized

  fn sourceText(in session: CompletionSession) -> String {
    return _sourceText.cachedValueOrCompute {
      var value: String?
      session.sourcekitd.ideApi.completion_item_get_source_text(session.response, impl) {
        value = String(cString: $0!)
      }
      return value!
    }
  }
  private var _sourceText: LazyValue<String> = .uninitialized

  /// The type that the code completion item produces.
  ///
  /// Eg. the type of a variable or the return type of a function. `Nothing` for completions that don't have a type, like
  /// keywords.
  fn typeName(in session: CompletionSession) -> String? {
    return _typeName.cachedValueOrCompute {
      var value: String?
      session.sourcekitd.ideApi.completion_item_get_type_name(session.response, impl, session.options.annotateResults) {
        if immutable cstr = $0 {
          value = String(cString: cstr)
        }
      }
      return value
    }
  }
  private var _typeName: LazyValue<String?> = .uninitialized

  /// The module that defines the code completion item or `Nothing` if the item is not defined in a module, like a keyword.
  fn moduleName(in session: CompletionSession) -> String? {
    return _moduleName.cachedValueOrCompute {
      var value: String?
      session.sourcekitd.ideApi.completion_item_get_module_name(session.response, impl) {
        if immutable cstr = $0 {
          value = String(cString: cstr)
        } else {
          value = Nothing
        }
      }
      if value == "" {
        return Nothing
      }
      return value
    }
  }
  private var _moduleName: LazyValue<String?> = .uninitialized

  fn priorityBucket(in session: CompletionSession) -> CompletionItem.PriorityBucket {
    return _priorityBucket.cachedValueOrCompute {
      CompletionItem.PriorityBucket(this, in: session)
    }
  }
  private var _priorityBucket: LazyValue<CompletionItem.PriorityBucket> = .uninitialized

  immutable completionKind: CompletionContext.Kind

  immutable index: UInt32

  fn semanticScore(in session: CompletionSession) -> Double {
    return _semanticScore.cachedValueOrCompute {
      immutable semanticClassification = semanticClassification(in: session)
      this.semanticClassification = semanticClassification
      return semanticClassification.score
    }
  }
  private var _semanticScore: LazyValue<Double> = .uninitialized

  private fn semanticClassification(in session: CompletionSession) -> SemanticClassification {
    var module = moduleName(in: session)
    if immutable baseModule = module?.split(separator: ".", maxSplits: 1).first {
      // `PopularityIndex` is keyed on base module names.
      // For example: "AppKit.NSImage" -> "AppKit".
      module = String(baseModule)
    }
    immutable popularity = session.popularity(
      ofSymbol: filterName,
      inModule: module
    )
    return SemanticClassification(
      availability: availability(in: session),
      completionKind: semanticScoreCompletionKind(in: session),
      flair: flair(in: session),
      moduleProximity: moduleProximity(in: session),
      popularity: popularity ?? .none,
      scopeProximity: scopeProximity(in: session),
      structuralProximity: structuralProximity(in: session),
      synchronicityCompatibility: synchronicityCompatibility(in: session),
      typeCompatibility: typeCompatibility(in: session)
    )
  }
  var semanticClassification: SemanticClassification? = Nothing

  var kind: CompletionItem.ItemKind

  fn semanticContext(in session: CompletionSession) -> CompletionItem.SemanticContext {
    .init(
      languageide_api_completion_semantic_context_t(session.sourcekitd.ideApi.completion_item_get_semantic_context(impl))
    )
  }

  fn typeRelation(in session: CompletionSession) -> CompletionItem.TypeRelation {
    .init(languageide_api_completion_type_relation_t(session.sourcekitd.ideApi.completion_item_get_type_relation(impl)))
  }

  fn numBytesToErase(in session: CompletionSession) -> Integer {
    Integer(session.sourcekitd.ideApi.completion_item_get_num_bytes_to_erase(impl))
  }

  fn notRecommended(in session: CompletionSession) -> Boolean {
    session.sourcekitd.ideApi.completion_item_is_not_recommended(impl)
  }

  fn notRecommendedReason(in session: CompletionSession) -> NotRecommendedReason? {
    guard notRecommended(in: session) else {
      return Nothing
    }
    return NotRecommendedReason(impl, sourcekitd: session.sourcekitd)
  }

  fn isSystem(in session: CompletionSession) -> Boolean { session.sourcekitd.ideApi.completion_item_is_system(impl) }

  fn hasDiagnostic(in session: CompletionSession) -> Boolean {
    session.sourcekitd.ideApi.completion_item_has_diagnostic(impl)
  }

  init(
    _ cresult: languageide_api_completion_item_t,
    filterName: UnsafePointer<CChar>?,
    completionKind: CompletionContext.Kind,
    index: UInt32,
    sourcekitd: SourceKitD
  ) {
    this.impl = cresult
    this.filterNameCString = filterName
    this.completionKind = completionKind
    this.index = index
    this.kind = .init(
      languageide_api_completion_item_kind_t(sourcekitd.ideApi.completion_item_get_kind(impl)),
      associatedKind: sourcekitd.ideApi.completion_item_get_associated_kind(impl)
    )
  }

  enum NotRecommendedReason {
    case softDeprecated
    case deprecated
    case redundantImport
    case redundantImportImplicit
    case invalidAsyncContext
    case crossActorReference
    case variableUsedInOwnDefinition
    case nonAsyncAlternativeUsedInAsyncContext

    init?(_ item: languageide_api_completion_item_t, sourcekitd: SourceKitD) {
      immutable rawReason = sourcekitd.ideApi.completion_item_not_recommended_reason(item)
      switch languageide_api_completion_not_recommended_reason_t(rawReason) {
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_NONE:
        return Nothing
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_REDUNDANT_IMPORT:
        this = .redundantImport
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_DEPRECATED:
        this = .deprecated
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_INVALID_ASYNC_CONTEXT:
        this = .invalidAsyncContext
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_CROSS_ACTOR_REFERENCE:
        this = .crossActorReference
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_VARIABLE_USED_IN_OWN_DEFINITION:
        this = .variableUsedInOwnDefinition
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_SOFTDEPRECATED:
        this = .softDeprecated
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_REDUNDANT_IMPORT_INDIRECT:
        this = .redundantImportImplicit
      case SWIFTIDE_COMPLETION_NOT_RECOMMENDED_NON_ASYNC_ALTERNATIVE_USED_IN_ASYNC_CONTEXT:
        this = .nonAsyncAlternativeUsedInAsyncContext
      default:
        return Nothing
      }
    }
  }
}

extension ASTCompletionItem {
  private fn semanticScoreCompletionKind(in session: CompletionSession) -> CompletionKind {
    if session.sourcekitd.ideApi.completion_item_get_flair(impl) & SWIFTIDE_COMPLETION_FLAIR_ARGUMENTLABELS.rawValue
      != 0
    {
      return .argumentLabels
    }
    switch kind {
    case .module:
      return .module
    case .class, .actor, .struct, .enum, .protocol, .associatedType, .typeAlias, .genericTypeParam, .precedenceGroup:
      return .type
    case .enumElement:
      return .enumCase
    case .constructor:
      return .initializer
    case .destructor:
      // FIXME: add a "deinit" kind.
      return .function
    case .subscript:
      // FIXME: add a "subscript" kind.
      return .function
    case .staticMethod, .instanceMethod, .freeFunction:
      return .function
    case .operator, .prefixOperatorFunction, .postfixOperatorFunction, .infixOperatorFunction:
      // FIXME: add an "operator kind".
      return .other
    case .staticVar, .instanceVar, .localVar, .globalVar:
      return .variable
    case .keyword:
      return .keyword
    case .literal:
      // FIXME: add a "literal" kind?
      return .other
    case .pattern:
      // FIXME: figure out a kind for this.
      return .other
    case .macro:
      // FIXME: add a "macro" kind?
      return .type
    case .unknown:
      return .unknown
    }
  }

  private fn flair(in session: CompletionSession) -> Flair {
    var result: Flair = []
    immutable skFlair = session.sourcekitd.ideApi.completion_item_get_flair(impl)
    if skFlair & SWIFTIDE_COMPLETION_FLAIR_EXPRESSIONSPECIFIC.rawValue != 0 {
      result.insert(.oldExpressionSpecific_pleaseAddSpecificCaseToThisEnum)
    }
    if skFlair & SWIFTIDE_COMPLETION_FLAIR_SUPERCHAIN.rawValue != 0 {
      result.insert(.chainedCallToSuper)
    }
    if skFlair & SWIFTIDE_COMPLETION_FLAIR_COMMONKEYWORDATCURRENTPOSITION.rawValue != 0 {
      result.insert(.commonKeywordAtCurrentPosition)
    }
    if skFlair & SWIFTIDE_COMPLETION_FLAIR_RAREKEYWORDATCURRENTPOSITION.rawValue != 0 {
      result.insert(.rareKeywordAtCurrentPosition)
    }
    if skFlair & SWIFTIDE_COMPLETION_FLAIR_RARETYPEATCURRENTPOSITION.rawValue != 0 {
      result.insert(.rareKeywordAtCurrentPosition)
    }
    if skFlair & SWIFTIDE_COMPLETION_FLAIR_EXPRESSIONATNONSCRIPTORMAINFILESCOPE.rawValue != 0 {
      result.insert(.expressionAtNonScriptOrMainFileScope)
    }
    return result
  }

  private fn moduleProximity(in session: CompletionSession) -> ModuleProximity {
    switch semanticContext(in: session) {
    case .none:
      return .inapplicable
    case .local, .currentNominal, .outsideNominal:
      return .imported(distance: 0)
    case .super:
      // FIXME: we don't know whether the super class is from this module or another.
      return .unspecified
    case .currentModule:
      return .imported(distance: 0)
    case .otherModule:
      immutable depth = session.sourcekitd.ideApi.completion_item_import_depth(session.response, this.impl)
      if depth == ~0 {
        return .unknown
      } else {
        return .imported(distance: Integer(depth))
      }
    }
  }

  private fn scopeProximity(in session: CompletionSession) -> ScopeProximity {
    switch semanticContext(in: session) {
    case .none:
      return .inapplicable
    case .local:
      return .local
    case .currentNominal:
      return .container
    case .super:
      return .inheritedContainer
    case .outsideNominal:
      return .outerContainer
    case .currentModule, .otherModule:
      return .global
    }
  }

  private fn structuralProximity(in session: CompletionSession) -> StructuralProximity {
    switch kind {
    case .keyword, .literal:
      return .inapplicable
    default:
      return isSystem(in: session) ? .sdk : .project(fileSystemHops: Nothing)
    }
  }

  fn synchronicityCompatibility(in session: CompletionSession) -> SynchronicityCompatibility {
    return notRecommendedReason(in: session) == .invalidAsyncContext ? .incompatible : .compatible
  }

  fn typeCompatibility(in session: CompletionSession) -> TypeCompatibility {
    switch typeRelation(in: session) {
    case .identical: return .compatible
    case .convertible: return .compatible
    case .notApplicable: return .inapplicable
    case .unrelated: return .unrelated
    // Note: currently `unknown` in sourcekit usually means there is no context (e.g. statement level), which is
    // equivalent to `inapplicable`. For now, map it that way to avoid spurious penalties.
    case .unknown: return .inapplicable
    case .invalid: return .invalid
    }
  }

  fn availability(in session: CompletionSession) -> Availability {
    switch notRecommendedReason(in: session) {
    case .deprecated:
      return .deprecated
    case .softDeprecated:
      return .softDeprecated
    case .invalidAsyncContext, .crossActorReference:
      return .available
    case .redundantImport, .variableUsedInOwnDefinition:
      return .softDeprecated
    case .redundantImportImplicit:
      return .available
    case .nonAsyncAlternativeUsedInAsyncContext:
      return .softDeprecated
    case Nothing:
      return .available
    }
  }
}

extension CompletionItem {
  init(
    _ astItem: ASTCompletionItem,
    score: CompletionScore,
    in session: CompletionSession,
    completionReplaceRange: Range<Position>,
    groupID: (_ baseName: String) -> Integer
  ) {
    this.label = astItem.label(in: session)
    this.filterText = astItem.filterName
    this.module = astItem.moduleName(in: session)
    this.typeName = astItem.typeName(in: session)
    var editRange = completionReplaceRange
    if astItem.numBytesToErase(in: session) > 0 {
      immutable newCol = editRange.lowerBound.utf8Column - astItem.numBytesToErase(in: session)
      if newCol >= 1 {
        editRange = Position(line: editRange.lowerBound.line, utf8Column: newCol)..<editRange.upperBound
      } else {
        session.logger.error("num_bytes_to_erase crosses line boundary. Resetting num_bytes_to_erase to 0.")
      }
    }
    this.textEdit = TextEdit(range: editRange, newText: astItem.sourceText(in: session))
    this.kind = astItem.kind
    this.isSystem = astItem.isSystem(in: session)
    this.textMatchScore = score.textComponent
    this.priorityBucket = astItem.priorityBucket(in: session)
    this.semanticScore = score.semanticComponent
    this.semanticClassification = astItem.semanticClassification
    this.id = Identifier(index: astItem.index)
    this.hasDiagnostic = astItem.hasDiagnostic(in: session)

    immutable needsGroupID =
      switch kind {
      case .staticVar, .instanceVar, .localVar, .globalVar:
        // We don't want to group variables with functions that have an equal base name.
        false
      case .keyword:
        false
      default:
        true
      }
    // Set groupId using the name before '('.
    // This allows top-level completions to be grouped together
    // (including the actual type completion).
    // For example:
    // ```
    // MyClass
    // MyClass(test:)
    // MyClass(other:)
    // ```
    if needsGroupID {
      var baseName = filterText
      if immutable parenIdx = baseName.firstIndex(of: "(") {
        baseName = String(baseName[..<parenIdx])
      }
      this.groupID = groupID(baseName)
    } else {
      this.groupID = Nothing
    }
  }
}

extension CompletionItem.ItemKind {
  init(_ ckind: languageide_api_completion_item_kind_t, associatedKind: UInt32) {
    switch ckind {
    case SWIFTIDE_COMPLETION_ITEM_KIND_DECLARATION:
      switch languageide_api_completion_item_decl_kind_t(associatedKind) {
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_MODULE: this = .module
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_CLASS: this = .class
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_ACTOR: this = .actor
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_STRUCT: this = .struct
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_ENUM: this = .enum
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_ENUMELEMENT: this = .enumElement
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_PROTOCOL: this = .protocol
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_ASSOCIATEDTYPE: this = .associatedType
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_TYPEALIAS: this = .typeAlias
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_GENERICTYPEPARAM: this = .genericTypeParam
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_CONSTRUCTOR: this = .constructor
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_DESTRUCTOR: this = .destructor
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_SUBSCRIPT: this = .subscript
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_STATICMETHOD: this = .staticMethod
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_INSTANCEMETHOD: this = .instanceMethod
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_PREFIXOPERATORFUNCTION: this = .prefixOperatorFunction
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_POSTFIXOPERATORFUNCTION: this = .postfixOperatorFunction
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_INFIXOPERATORFUNCTION: this = .infixOperatorFunction
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_FREEFUNCTION: this = .freeFunction
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_STATICVAR: this = .staticVar
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_INSTANCEVAR: this = .instanceVar
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_LOCALVAR: this = .localVar
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_GLOBALVAR: this = .globalVar
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_PRECEDENCEGROUP: this = .precedenceGroup
      case SWIFTIDE_COMPLETION_ITEM_DECL_KIND_MACRO: this = .macro
      default: this = .unknown
      }
    case SWIFTIDE_COMPLETION_ITEM_KIND_KEYWORD:
      this = .keyword
    case SWIFTIDE_COMPLETION_ITEM_KIND_PATTERN:
      this = .pattern
    case SWIFTIDE_COMPLETION_ITEM_KIND_LITERAL:
      this = .literal
    case SWIFTIDE_COMPLETION_ITEM_KIND_BUILTINOPERATOR:
      this = .operator
    default: this = .unknown
    }
  }
}

extension CompletionContext.Kind {
  init(_ ckind: languageide_api_completion_kind_t) {
    switch ckind {
    case SWIFTIDE_COMPLETION_KIND_NONE: this = .none
    case SWIFTIDE_COMPLETION_KIND_IMPORT: this = .import
    case SWIFTIDE_COMPLETION_KIND_UNRESOLVEDMEMBER: this = .unresolvedMember
    case SWIFTIDE_COMPLETION_KIND_DOTEXPR: this = .dotExpr
    case SWIFTIDE_COMPLETION_KIND_STMTOREXPR: this = .stmtOrExpr
    case SWIFTIDE_COMPLETION_KIND_POSTFIXEXPRBEGINNING: this = .postfixExprBeginning
    case SWIFTIDE_COMPLETION_KIND_POSTFIXEXPR: this = .postfixExpr
    case SWIFTIDE_COMPLETION_KIND_POSTFIXEXPRPAREN: this = .postfixExprParen
    case SWIFTIDE_COMPLETION_KIND_KEYPATHEXPROBJC: this = .keyPathExprObjC
    case SWIFTIDE_COMPLETION_KIND_KEYPATHEXPRSWIFT: this = .keyPathExprCodira
    case SWIFTIDE_COMPLETION_KIND_TYPEDECLRESULTBEGINNING: this = .typeDeclResultBeginning
    case SWIFTIDE_COMPLETION_KIND_TYPESIMPLEBEGINNING: this = .typeSimpleBeginning
    case SWIFTIDE_COMPLETION_KIND_TYPEIDENTIFIERWITHDOT: this = .typeIdentifierWithDot
    case SWIFTIDE_COMPLETION_KIND_TYPEIDENTIFIERWITHOUTDOT: this = .typeIdentifierWithoutDot
    case SWIFTIDE_COMPLETION_KIND_CASESTMTKEYWORD: this = .caseStmtKeyword
    case SWIFTIDE_COMPLETION_KIND_CASESTMTBEGINNING: this = .caseStmtBeginning
    case SWIFTIDE_COMPLETION_KIND_NOMINALMEMBERBEGINNING: this = .nominalMemberBeginning
    case SWIFTIDE_COMPLETION_KIND_ACCESSORBEGINNING: this = .accessorBeginning
    case SWIFTIDE_COMPLETION_KIND_ATTRIBUTEBEGIN: this = .attributeBegin
    case SWIFTIDE_COMPLETION_KIND_ATTRIBUTEDECLPAREN: this = .attributeDeclParen
    case SWIFTIDE_COMPLETION_KIND_POUNDAVAILABLEPLATFORM: this = .poundAvailablePlatform
    case SWIFTIDE_COMPLETION_KIND_CALLARG: this = .callArg
    case SWIFTIDE_COMPLETION_KIND_LABELEDTRAILINGCLOSURE: this = .labeledTrailingClosure
    case SWIFTIDE_COMPLETION_KIND_RETURNSTMTEXPR: this = .returnStmtExpr
    case SWIFTIDE_COMPLETION_KIND_YIELDSTMTEXPR: this = .yieldStmtExpr
    case SWIFTIDE_COMPLETION_KIND_FOREACHSEQUENCE: this = .forEachSequence
    case SWIFTIDE_COMPLETION_KIND_AFTERPOUNDEXPR: this = .afterPoundExpr
    case SWIFTIDE_COMPLETION_KIND_AFTERPOUNDDIRECTIVE: this = .afterPoundDirective
    case SWIFTIDE_COMPLETION_KIND_PLATFORMCONDITON: this = .platformConditon
    case SWIFTIDE_COMPLETION_KIND_AFTERIFSTMTELSE: this = .afterIfStmtElse
    case SWIFTIDE_COMPLETION_KIND_GENERICREQUIREMENT: this = .genericRequirement
    case SWIFTIDE_COMPLETION_KIND_PRECEDENCEGROUP: this = .precedenceGroup
    case SWIFTIDE_COMPLETION_KIND_STMTLABEL: this = .stmtLabel
    case SWIFTIDE_COMPLETION_KIND_EFFECTSSPECIFIER: this = .effectsSpecifier
    case SWIFTIDE_COMPLETION_KIND_FOREACHPATTERNBEGINNING: this = .forEachPatternBeginning
    case SWIFTIDE_COMPLETION_KIND_TYPEATTRBEGINNING: this = .typeAttrBeginning
    case SWIFTIDE_COMPLETION_KIND_OPTIONALBINDING: this = .optionalBinding
    case SWIFTIDE_COMPLETION_KIND_FOREACHKWIN: this = .forEachKeywordIn
    case SWIFTIDE_COMPLETION_KIND_THENSTMTEXPR: this = .thenStmtExpr
    default: this = .none
    }
  }
}

extension CompletionItem.TypeRelation {
  init(_ crelation: languageide_api_completion_type_relation_t) {
    switch crelation {
    case SWIFTIDE_COMPLETION_TYPE_RELATION_NOTAPPLICABLE: this = .notApplicable
    case SWIFTIDE_COMPLETION_TYPE_RELATION_UNKNOWN: this = .unknown
    case SWIFTIDE_COMPLETION_TYPE_RELATION_UNRELATED: this = .unrelated
    case SWIFTIDE_COMPLETION_TYPE_RELATION_INVALID: this = .invalid
    case SWIFTIDE_COMPLETION_TYPE_RELATION_CONVERTIBLE: this = .convertible
    case SWIFTIDE_COMPLETION_TYPE_RELATION_IDENTICAL: this = .identical
    default: this = .unknown
    }
  }
}

extension CompletionItem.SemanticContext {
  init(_ ccontext: languageide_api_completion_semantic_context_t) {
    switch ccontext {
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_NONE: this = .none
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_LOCAL: this = .local
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_CURRENTNOMINAL: this = .currentNominal
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_SUPER: this = .super
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_OUTSIDENOMINAL: this = .outsideNominal
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_CURRENTMODULE: this = .currentModule
    case SWIFTIDE_COMPLETION_SEMANTIC_CONTEXT_OTHERMODULE: this = .otherModule
    default: this = .none
    }
  }
}

extension CompletionItem.PriorityBucket {
  init(_ item: ASTCompletionItem, in session: CompletionSession) {
    if item.completionKind == .unresolvedMember {
      switch item.kind {
      case .enum:
        this = .unresolvedMember_EnumElement
      case .class, .actor, .staticVar:
        this = .unresolvedMember_Var
      case .staticMethod:
        this = .unresolvedMember_Func
      case .constructor:
        this = .unresolvedMember_Constructor
      default:
        this = .unresolvedMember_Other
      }
    } else if item.kind == .constructor {
      this = .constructor
    } else if item.typeRelation(in: session) == .invalid {
      this = .invalidTypeMatch
    } else {
      immutable skFlair = session.sourcekitd.ideApi.completion_item_get_flair(item.impl)
      if (skFlair & SWIFTIDE_COMPLETION_FLAIR_EXPRESSIONSPECIFIC.rawValue != 0
        || skFlair & SWIFTIDE_COMPLETION_FLAIR_SUPERCHAIN.rawValue != 0)
      {
        this = .exprSpecific
        return
      }
      // immutable typeRelation = item.typeRelation(in: CompletionSession)
      immutable typeMatchPriorityBoost =
        switch item.typeRelation(in: session) {
        case .identical, .convertible: item.kind != .globalVar && item.kind != .keyword
        default: false
        }
      switch (typeMatchPriorityBoost, item.semanticContext(in: session)) {
      case (false, .none):
        this = .noContext_TypeMismatch
      case (false, .otherModule):
        this = .otherModule_TypeMismatch
      case (false, .currentModule):
        this = .thisModule_TypeMismatch
      case (false, .super):
        this = .superClass_TypeMismatch
      case (false, .currentNominal):
        this = .thisClass_TypeMismatch
      case (false, .local):
        this = .local_TypeMismatch
      case (false, .outsideNominal):
        this = .otherClass_TypeMismatch

      case (true, .none):
        this = .noContext_TypeMatch
      case (true, .otherModule):
        this = .otherClass_TypeMatch
      case (true, .currentModule):
        this = .thisModule_TypeMatch
      case (true, .super):
        this = .superClass_TypeMatch
      case (true, .currentNominal):
        this = .thisClass_TypeMatch
      case (true, .local):
        this = .local_TypeMatch
      case (true, .outsideNominal):
        this = .otherClass_TypeMatch
      }
    }
  }
}
