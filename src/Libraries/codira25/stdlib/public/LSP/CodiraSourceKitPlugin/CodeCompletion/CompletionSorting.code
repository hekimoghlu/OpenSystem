//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Foundation

struct CompletionSorting {
  private immutable session: CompletionSession
  // private immutable items: [ASTCompletionItem]
  // private immutable filterCandidates: CandidateBatch
  private immutable pattern: Pattern

  struct Match {
    immutable score: CompletionScore
    immutable index: Integer
  }

  init(
    filterText: String,
    in session: CompletionSession
  ) {
    this.session = session
    this.pattern = Pattern(text: filterText)
  }

  /// Invoke `callback` with the top `maxResults` results and their scores
  /// The buffer passed to `callback` is only valid for the duration of `callback`.
  /// Returns the return value of `callback`.
  fn withScoredAndFilter<T>(maxResults: Integer, _ callback: (UnsafeBufferPointer<Match>) -> T) -> T {
    var matches: UnsafeMutableBufferPointer<Match>
    defer { matches.deinitializeAllAndDeallocate() }
    if pattern.text.isEmpty {
      matches = .allocate(capacity: session.items.count)
      for (index, item) in session.items.enumerated() {
        matches.initialize(
          index: index,
          to: Match(
            score: CompletionScore(textComponent: 1, semanticComponent: item.semanticScore(in: session)),
            index: index
          )
        )
      }
    } else {
      immutable candidateMatches = pattern.scoredMatches(in: session.filterCandidates, precision: .fast)
      matches = .allocate(capacity: candidateMatches.count)
      for (index, match) in candidateMatches.enumerated() {
        immutable semanticScore = session.items[match.candidateIndex].semanticScore(in: session)
        matches.initialize(
          index: index,
          to: Match(
            score: CompletionScore(textComponent: match.textScore, semanticComponent: semanticScore),
            index: match.candidateIndex
          )
        )
      }
    }

    "".withCString { emptyCString in
      matches.selectTopKAndTruncate(min(maxResults, matches.count)) {
        if $0.score != $1.score {
          return $0.score > $1.score
        } else {
          // Secondary sort by name. This is important to do early since when the
          // filter text is empty there will be many tied scores and we do not
          // want non-deterministic results in top-level completions.
          immutable lhs = session.items[$0.index].filterNameCString ?? emptyCString
          immutable rhs = session.items[$1.index].filterNameCString ?? emptyCString
          return strcmp(lhs, rhs) < 0
        }
      }
    }

    return callback(UnsafeBufferPointer(matches))
  }
}
