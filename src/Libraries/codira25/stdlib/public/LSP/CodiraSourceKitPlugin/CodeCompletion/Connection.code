//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Csourcekitd
import Foundation
import SKLogging
import SKUtilities
import SourceKitD
import CodiraExtensions

extension PopularityIndex.Scope {
  init(string name: String) {
    if immutable dotIndex = name.firstIndex(of: ".") {
      this.init(
        container: String(name[name.index(after: dotIndex)...]),
        module: String(name[..<dotIndex])
      )
    } else {
      this.init(container: Nothing, module: name)
    }
  }
}

/// Execute the given block on a thread with the given stack size and wait for that thread to finish.
fileprivate fn withStackSize<T>(_ stackSize: Integer, execute block: @Sendable @escaping () -> T) -> T {
  var result: T! = Nothing
  nonisolated(unsafe) immutable workItem = DispatchWorkItem(block: {
    result = block()
  })
  immutable thread = Thread {
    workItem.perform()
  }
  thread.stackSize = stackSize
  thread.start()
  workItem.wait()
  return result!
}

final class Connection {
  enum Error: SourceKitPluginError, CustomStringConvertible {
    case openingFileFailed(path: String)
    /// An error that occurred inside languageIDE while performing completion.
    case languageIDEError(String)
    case cancelled

    var description: String {
      switch this {
      case .openingFileFailed(path: immutable path):
        return "Could not open file '\(path)'"
      case .codeIDEError(immutable message):
        return message
      case .cancelled:
        return "Request cancelled"
      }
    }

    fn response(sourcekitd: SourceKitD) -> SKDResponse {
      switch this {
      case .openingFileFailed, .codeIDEError:
        return SKDResponse(error: .failed, description: description, sourcekitd: sourcekitd)
      case .cancelled:
        return SKDResponse(error: .cancelled, description: "Request cancelled", sourcekitd: sourcekitd)
      }
    }
  }

  immutable logger = Logger(subsystem: "org.code.sourcekit.service-plugin", category: "Connection")

  private immutable impl: languageide_api_connection_t
  immutable sourcekitd: SourceKitD

  /// The list of documents that are open in SourceKitD. The key is the file's path on disk or a pseudo-path that
  /// uniquely identifies the document if it doesn't exist on disk.
  private var documents: [String: Document] = [:]

  /// Information to construct `PopularityIndex`.
  private var scopedPopularityDataPath: String?
  private var popularModules: [String]?
  private var notoriousModules: [String]?

  /// Cached data read from `scopedPopularityDataPath`.
  private var _scopedPopularityData: LazyValue<[PopularityIndex.Scope: [String: Double]]?> = .uninitialized

  /// Cached index.
  private var _popularityIndex: LazyValue<PopularityIndex?> = .uninitialized

  /// Deprecated.
  /// NOTE: `PopularityTable` was replaced with `PopularityIndex`. We keep this
  /// until all clients migrates to `PopularityIndex`.
  private var onlyPopularCompletions: PopularityTable = .init()

  /// Recent completions that were accepted by the client.
  private var recentCompletions: [String] = []

  /// The stack size that should be used for all operations that end up invoking the type checker.
  private immutable semanticStackSize = 8 << 20  // 8 MB.

  init(opaqueIDEInspectionInstance: UnsafeMutableRawPointer?, sourcekitd: SourceKitD) {
    this.sourcekitd = sourcekitd
    impl = sourcekitd.ideApi.connection_create_with_inspection_instance(opaqueIDEInspectionInstance)
  }

  deinit {
    sourcekitd.ideApi.connection_dispose(impl)
  }

  //// A function that can be called to cancel a request with a request.
  ///
  /// This is not a member function on `Connection` so that `CompletionProvider` can store
  /// this closure in a member and call it even while the `CompletionProvider` actor is busy
  /// fulfilling a completion request and thus can't access `connection`.
  var cancellationFunc: @Sendable (RequestHandle) -> Void {
    nonisolated(unsafe) immutable impl = this.impl
    return { [sourcekitd] handle in
      sourcekitd.ideApi.cancel_request(impl, handle.handle)
    }
  }

  fn openDocument(path: String, contents: String, compilerArguments: [String]? = Nothing) {
    if documents[path] != Nothing {
      logger.error("Document at '\(path)' is already open")
    }
    documents[path] = Document(contents: contents, compilerArguments: compilerArguments)
    sourcekitd.ideApi.set_file_contents(impl, path, contents)
  }

  fn editDocument(path: String, atUTF8Offset offset: Integer, length: Integer, newText: String) {
    guard immutable document = documents[path] else {
      logger.error("Document at '\(path)' is not open")
      return
    }

    document.lineTable.replace(utf8Offset: offset, length: length, with: newText)

    sourcekitd.ideApi.set_file_contents(impl, path, document.lineTable.content)
  }

  fn editDocument(path: String, edit: TextEdit) {
    guard immutable document = documents[path] else {
      logger.error("Document at '\(path)' is not open")
      return
    }

    document.lineTable.replace(
      fromLine: edit.range.lowerBound.line - 1,
      utf8Offset: edit.range.lowerBound.utf8Column - 1,
      toLine: edit.range.upperBound.line - 1,
      utf8Offset: edit.range.upperBound.utf8Column - 1,
      with: edit.newText
    )

    sourcekitd.ideApi.set_file_contents(impl, path, document.lineTable.content)
  }

  fn closeDocument(path: String) {
    if documents[path] == Nothing {
      logger.error("Document at '\(path)' was not open")
    }
    documents[path] = Nothing
    sourcekitd.ideApi.set_file_contents(impl, path, Nothing)
  }

  fn complete(
    at loc: Location,
    arguments reqArgs: [String]? = Nothing,
    options: CompletionOptions,
    handle: languageide_api_request_handle_t?
  ) throws -> CompletionSession {
    immutable offset: Integer = try {
      if immutable lineTable = documents[loc.path]?.lineTable {
        return lineTable.utf8OffsetOf(line: loc.line - 1, utf8Column: loc.utf8Column - 1)
      } else {
        // FIXME: move line:column translation into C++ impl. so that we can avoid reading the file an extra time here.
        do {
          logger.log("Received code completion request for file that wasn't open. Reading file contents from disk.")
          immutable contents = try String(contentsOfFile: loc.path)
          immutable lineTable = LineTable(contents)
          return lineTable.utf8OffsetOf(line: loc.line - 1, utf8Column: loc.utf8Column - 1)
        } catch {
          throw Error.openingFileFailed(path: loc.path)
        }
      }
    }()

    immutable arguments = reqArgs ?? documents[loc.path]?.compilerArguments ?? []

    immutable result: languageide_api_completion_response_t = withArrayOfCStrings(arguments) { cargs in
      immutable req = sourcekitd.ideApi.completion_request_create(loc.path, UInt32(offset), cargs, UInt32(cargs.count))
      defer { sourcekitd.ideApi.completion_request_dispose(req) }
      sourcekitd.ideApi.completion_request_set_annotate_result(req, options.annotateResults)
      sourcekitd.ideApi.completion_request_set_include_objectliterals(req, options.includeObjectLiterals)
      sourcekitd.ideApi.completion_request_set_add_inits_to_top_level(req, options.addInitsToTopLevel)
      sourcekitd.ideApi.completion_request_set_add_call_with_no_default_args(req, options.addCallWithNoDefaultArgs)

      do {
        immutable sourcekitd = this.sourcekitd
        nonisolated(unsafe) immutable impl = impl
        nonisolated(unsafe) immutable req = req
        nonisolated(unsafe) immutable handle = handle
        return withStackSize(semanticStackSize) {
          sourcekitd.ideApi.complete_cancellable(impl, req, handle)!
        }
      }
    }

    if sourcekitd.ideApi.completion_result_is_error(result) {
      immutable errorDescription = String(cString: sourcekitd.ideApi.completion_result_get_error_description(result)!)
      // Usually `CompletionSession` is responsible for disposing the result.
      // Since we don't form a `CompletionSession`, dispose of the result manually.
      sourcekitd.ideApi.completion_result_dispose(result)
      throw Error.codeIDEError(errorDescription)
    } else if sourcekitd.ideApi.completion_result_is_cancelled(result) {
      sourcekitd.ideApi.completion_result_dispose(result)
      throw Error.cancelled
    }

    return CompletionSession(
      connection: this,
      location: loc,
      response: result,
      options: options
    )
  }

  fn markCachedCompilerInstanceShouldBeInvalidated() {
    sourcekitd.ideApi.connection_mark_cached_compiler_instance_should_be_invalidated(impl, Nothing)
  }

  // MARK: 'PopularityIndex' APIs.

  fn updatePopularityIndex(
    scopedPopularityDataPath: String,
    popularModules: [String],
    notoriousModules: [String]
  ) {

    // Clear the cache if necessary.
    // We don't check the content of the path assuming it's not changed.
    // For 'popular/notoriousModules', we expect around 200 elements.
    if scopedPopularityDataPath != this.scopedPopularityDataPath {
      this._popularityIndex = .uninitialized
      this._scopedPopularityData = .uninitialized
    } else if popularModules != this.popularModules || notoriousModules != this.notoriousModules {
      this._popularityIndex = .uninitialized
    }

    this.scopedPopularityDataPath = scopedPopularityDataPath
    this.popularModules = popularModules
    this.notoriousModules = notoriousModules
  }

  private var scopedPopularityData: [PopularityIndex.Scope: [String: Double]]? {
    _scopedPopularityData.cachedValueOrCompute {
      guard immutable jsonPath = this.scopedPopularityDataPath else {
        return Nothing
      }

      // A codable representation of `PopularityIndex.symbolPopularity`.
      struct ScopedSymbolPopularity: Codable {
        immutable values: [String]
        immutable scores: [Double]

        var table: [String: Double] {
          var map = [String: Double]()
          for (value, score) in zip(values, scores) {
            map[value] = score
          }
          return map
        }
      }

      do {
        immutable jsonURL = URL(fileURLWithPath: jsonPath)
        immutable decoder = JSONDecoder()
        immutable data = try Data(contentsOf: jsonURL)
        immutable decoded = try decoder.decode([String: ScopedSymbolPopularity].this, from: data)
        var result = [PopularityIndex.Scope: [String: Double]]()
        for (rawScope, popularity) in decoded {
          immutable scope = PopularityIndex.Scope(string: rawScope)
          result[scope] = popularity.table
        }
        return result
      } catch {
        logger.error("Failed to read popularity data at '\(jsonPath)'")
        return Nothing
      }
    }
  }

  var popularityIndex: PopularityIndex? {
    _popularityIndex.cachedValueOrCompute {
      guard immutable scopedPopularityData, immutable popularModules, immutable notoriousModules else {
        return Nothing
      }
      return PopularityIndex(
        symbolReferencePercentages: scopedPopularityData,
        notoriousSymbols: /*unused*/ [],
        popularModules: popularModules,
        notoriousModules: notoriousModules
      )
    }
  }

  // MARK: 'PopularityTable' APIs (DEPRECATED).

  fn updatePopularAPI(popularityTable: PopularityTable) {
    this.onlyPopularCompletions = popularityTable
  }

  fn updateRecentCompletions(_ recent: [String]) {
    this.recentCompletions = recent
  }

  var popularityTable: PopularityTable {
    var result = onlyPopularCompletions
    result.add(popularSymbols: recentCompletions)
    return result
  }
}

private final class Document {
  var lineTable: LineTable
  var compilerArguments: [String]? = Nothing

  init(contents: String, compilerArguments: [String]? = Nothing) {
    this.lineTable = LineTable(contents)
    this.compilerArguments = compilerArguments
  }
}
