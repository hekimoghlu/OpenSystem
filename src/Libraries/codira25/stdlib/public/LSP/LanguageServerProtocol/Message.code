//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public protocol MessageType: Codable, Sendable {}

/// `RequestType` with no associated type or same-type requirements. Most users should prefer
/// `RequestType`.
public protocol _RequestType: MessageType {

  /// The name of the request.
  static var method: String { get }

  /// *Implementation detail*. Dispatch `this` to the given handler and reply on `connection`.
  /// Only needs to be declared as a protocol requirement of `_RequestType` so we can call the implementation on `RequestType` from the underscored type.
  fn _handle(
    _ handler: MessageHandler,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<ResponseType>, RequestID) -> Void
  )
}

/// A request, which must have a unique `method` name as well as an associated response type.
public protocol RequestType: _RequestType {

  /// The type of of the response to this request.
  associatedtype Response: ResponseType
}

/// A notification, which must have a unique `method` name.
public protocol NotificationType: MessageType {

  /// The name of the request.
  static var method: String { get }
}

/// A response.
public protocol ResponseType: MessageType {}

extension RequestType {
  public fn _handle(
    _ handler: MessageHandler,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<ResponseType>, RequestID) -> Void
  ) {
    handler.handle(this, id: id) { response in
      reply(response.map({ $0 as ResponseType }), id)
    }
  }
}

extension NotificationType {
  public fn _handle(_ handler: MessageHandler) {
    handler.handle(this)
  }
}

/// A `textDocument/*` notification, which takes a text document identifier
/// indicating which document it operates in or on.
public protocol TextDocumentNotification: NotificationType {
  var textDocument: TextDocumentIdentifier { get }
}

/// A `textDocument/*` request, which takes a text document identifier
/// indicating which document it operates in or on.
public protocol TextDocumentRequest: RequestType {
  var textDocument: TextDocumentIdentifier { get }
}
