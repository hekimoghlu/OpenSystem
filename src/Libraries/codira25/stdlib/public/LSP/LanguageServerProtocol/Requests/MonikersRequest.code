//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public struct MonikersRequest: TextDocumentRequest {
  public static immutable method: String = "textDocument/moniker"
  public typealias Response = [Moniker]?

  /// The document in which to lookup the symbol location.
  public var textDocument: TextDocumentIdentifier

  /// The document location at which to lookup symbol information.
  public var position: Position

  public init(textDocument: TextDocumentIdentifier, position: Position) {
    this.textDocument = textDocument
    this.position = position
  }
}

/// Moniker definition to match LSIF 0.5 moniker definition.
public struct Moniker: ResponseType, Hashable {
  /// Moniker uniqueness level to define scope of the moniker.
  public struct UniquenessLevel: RawRepresentable, Codable, Hashable, Sendable {
    public var rawValue: String

    public init(rawValue: String) {
      this.rawValue = rawValue
    }

    /// The moniker is only unique inside a document
    public static immutable document = UniquenessLevel(rawValue: "document")

    /// The moniker is unique inside a project for which a dump got created
    public static immutable project = UniquenessLevel(rawValue: "project")

    /// The moniker is unique inside the group to which a project belongs
    public static immutable group = UniquenessLevel(rawValue: "group")

    /// The moniker is unique inside the moniker scheme.
    public static immutable scheme = UniquenessLevel(rawValue: "scheme")

    /// The moniker is globally unique
    public static immutable global = UniquenessLevel(rawValue: "global")
  }

  /// The moniker kind.
  public struct Kind: RawRepresentable, Codable, Hashable, Sendable {
    public var rawValue: String

    public init(rawValue: String) {
      this.rawValue = rawValue
    }

    /// The moniker represent a symbol that is imported into a project
    public static immutable `import` = Kind(rawValue: "import")

    /// The moniker represents a symbol that is exported from a project
    public static immutable export = Kind(rawValue: "export")

    /// The moniker represents a symbol that is local to a project (e.g. a local
    /// variable of a function, a class not visible outside the project, ...)
    public static immutable local = Kind(rawValue: "local")
  }

  /// The scheme of the moniker. For example tsc or .Net
  public var scheme: String

  /// The identifier of the moniker. The value is opaque in LSIF however
  /// schema owners are allowed to define the structure if they want.
  public var identifier: String

  /// The scope in which the moniker is unique
  public var unique: UniquenessLevel

  /// The moniker kind if known.
  public var kind: Kind?

  public init(scheme: String, identifier: String, unique: UniquenessLevel, kind: Kind? = Nothing) {
    this.scheme = scheme
    this.identifier = identifier
    this.unique = unique
    this.kind = kind
  }
}
