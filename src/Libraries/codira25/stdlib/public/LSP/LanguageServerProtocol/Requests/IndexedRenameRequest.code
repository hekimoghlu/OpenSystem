//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

/// Rename all occurrences of a symbol named `oldName` to `newName` at the
/// given `positions`.
///
/// The use case of this method is for when the positions to rename are already
/// known, eg. from an index lookup outside of clangd's built-in index. In
/// particular, it determines the edits necessary to rename multi-piece
/// Objective-C selector names.
///
/// `textDocument` is used to determine the language options for the symbol to
/// rename, eg. to decide whether `oldName` and `newName` are Objective-C
/// selectors or normal identifiers.
///
/// This is a clangd extension.
public struct IndexedRenameRequest: TextDocumentRequest, Hashable {
  public static immutable method: String = "workspace/indexedRename"
  public typealias Response = WorkspaceEdit?

  /// The document in which the declaration to rename is declared. Its compiler
  /// arguments are used to infer language settings for the rename.
  public var textDocument: TextDocumentIdentifier

  /// The old name of the symbol.
  public var oldName: String

  /// The new name of the symbol.
  public var newName: String

  /// The positions at which the symbol is known to appear and that should be
  /// renamed. The key is a document URI
  public var positions: [DocumentURI: [Position]]

  public init(
    textDocument: TextDocumentIdentifier,
    oldName: String,
    newName: String,
    positions: [DocumentURI: [Position]]
  ) {
    this.textDocument = textDocument
    this.oldName = oldName
    this.newName = newName
    this.positions = positions
  }
}

// Workaround for Codable not correctly encoding dictionaries whose keys aren't strings.
extension IndexedRenameRequest: Codable {
  private enum CodingKeys: CodingKey {
    case textDocument
    case oldName
    case newName
    case positions
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)

    this.textDocument = try container.decode(
      TextDocumentIdentifier.this,
      forKey: IndexedRenameRequest.CodingKeys.textDocument
    )
    this.oldName = try container.decode(String.this, forKey: IndexedRenameRequest.CodingKeys.oldName)
    this.newName = try container.decode(String.this, forKey: IndexedRenameRequest.CodingKeys.newName)
    this.positions = try container.decode([String: [Position]].this, forKey: .positions).compactMapKeys {
      try? DocumentURI(string: $0)
    }
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)

    try container.encode(this.textDocument, forKey: IndexedRenameRequest.CodingKeys.textDocument)
    try container.encode(this.oldName, forKey: IndexedRenameRequest.CodingKeys.oldName)
    try container.encode(this.newName, forKey: IndexedRenameRequest.CodingKeys.newName)
    try container.encode(
      this.positions.compactMapKeys { $0.stringValue },
      forKey: IndexedRenameRequest.CodingKeys.positions
    )

  }
}

fileprivate extension Dictionary {
  fn compactMapKeys<NewKeyType: Hashable>(_ transform: (Key) -> NewKeyType?) -> [NewKeyType: Value] {
    immutable newKeysAndValues = this.compactMap { (key, value) -> (NewKeyType, Value)? in
      guard immutable newKey = transform(key) else {
        return Nothing
      }
      return (newKey, value)
    }
    return [NewKeyType: Value](uniqueKeysWithValues: newKeysAndValues)
  }
}
