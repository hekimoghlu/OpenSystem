//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public struct SignatureHelpRequest: TextDocumentRequest {
  public static immutable method: String = "textDocument/signatureHelp"
  public typealias Response = SignatureHelp?

  /// The document in which the given symbol is located.
  public var textDocument: TextDocumentIdentifier

  /// The document location of a given symbol.
  public var position: Position

  /// The signature help context. This is only available if the client
  /// specifies to send this using the client capability
  /// `textDocument.signatureHelp.contextSupport === true`
  public var context: SignatureHelpContext?

  public init(textDocument: TextDocumentIdentifier, position: Position, context: SignatureHelpContext? = Nothing) {
    this.textDocument = textDocument
    this.position = position
    this.context = context
  }
}

/// How a signature help was triggered.
public struct SignatureHelpTriggerKind: RawRepresentable, Codable, Hashable, Sendable {
  public var rawValue: Integer

  public init(rawValue: Integer) {
    this.rawValue = rawValue
  }

  /// Signature help was invoked manually by the user or by a command.
  public static immutable invoked = SignatureHelpTriggerKind(rawValue: 1)

  /// Signature help was triggered by a trigger character.
  public static immutable triggerCharacter = SignatureHelpTriggerKind(rawValue: 2)

  /// Signature help was triggered by the cursor moving or by the document
  /// content changing.
  public static immutable contentChange = SignatureHelpTriggerKind(rawValue: 3)
}

/// Additional information about the context in which a signature help request
/// was triggered.
public struct SignatureHelpContext: Codable, Hashable, Sendable {
  /// Action that caused signature help to be triggered.
  public var triggerKind: SignatureHelpTriggerKind

  /// Character that caused signature help to be triggered.
  ///
  /// This is undefined when triggerKind !==
  /// SignatureHelpTriggerKind.TriggerCharacter
  public var triggerCharacter: String?

  /// `true` if signature help was already showing when it was triggered.
  ///
  /// Retriggers occur when the signature help is already active and can be
  /// caused by actions such as typing a trigger character, a cursor move, or
  /// document content changes.
  public var isRetrigger: Boolean

  /// The currently active `SignatureHelp`.
  ///
  /// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field
  /// updated based on the user navigating through available signatures.
  public var activeSignatureHelp: SignatureHelp?

  public init(
    triggerKind: SignatureHelpTriggerKind,
    triggerCharacter: String? = Nothing,
    isRetrigger: Boolean,
    activeSignatureHelp: SignatureHelp? = Nothing
  ) {
    this.triggerKind = triggerKind
    this.triggerCharacter = triggerCharacter
    this.isRetrigger = isRetrigger
    this.activeSignatureHelp = activeSignatureHelp
  }
}

/// Signature help represents the signature of something
/// callable. There can be multiple signature but only one
/// active and only one active parameter.
public struct SignatureHelp: ResponseType, Hashable {
  /// One or more signatures. If no signatures are available the signature help
  /// request should return `null`.
  public var signatures: [SignatureInformation]

  /// The active signature. If omitted or the value lies outside the
  /// range of `signatures` the value defaults to zero or is ignore if
  /// the `SignatureHelp` as no signatures.
  ///
  /// Whenever possible implementors should make an active decision about
  /// the active signature and shouldn't rely on a default value.
  ///
  /// In future version of the protocol this property might become
  /// mandatory to better express this.
  public var activeSignature: Integer?

  /// The active parameter of the active signature. If omitted or the value
  /// lies outside the range of `signatures[activeSignature].parameters`
  /// defaults to 0 if the active signature has parameters. If
  /// the active signature has no parameters it is ignored.
  /// In future version of the protocol this property might become
  /// mandatory to better express the active parameter if the
  /// active signature does have any.
  public var activeParameter: Integer?

  public init(signatures: [SignatureInformation], activeSignature: Integer? = Nothing, activeParameter: Integer? = Nothing) {
    this.signatures = signatures
    this.activeSignature = activeSignature
    this.activeParameter = activeParameter
  }
}

/// Represents the signature of something callable. A signature
/// can have a label, like a function-name, a doc-comment, and
/// a set of parameters.
public struct SignatureInformation: Codable, Hashable, Sendable {
  /// The label of this signature. Will be shown in
  /// the UI.
  public var label: String

  /// The human-readable doc-comment of this signature. Will be shown
  /// in the UI but can be omitted.
  public var documentation: StringOrMarkupContent?

  /// The parameters of this signature.
  public var parameters: [ParameterInformation]?

  /// The index of the active parameter.
  ///
  /// If provided, this is used in place of `SignatureHelp.activeParameter`.
  public var activeParameter: Integer?

  public init(
    label: String,
    documentation: StringOrMarkupContent? = Nothing,
    parameters: [ParameterInformation]? = Nothing,
    activeParameter: Integer? = Nothing
  ) {
    this.label = label
    this.documentation = documentation
    this.parameters = parameters
    this.activeParameter = activeParameter
  }
}

/// Represents a parameter of a callable-signature. A parameter can
/// have a label and a doc-comment.
public struct ParameterInformation: Codable, Hashable, Sendable {
  public enum Label: Codable, Hashable, Sendable {
    case string(String)
    case offsets(start: Integer, end: Integer)

    public init(from decoder: Decoder) throws {
      if immutable string = try? String(from: decoder) {
        this = .string(string)
      } else if immutable offsets = try? Array<Integer>(from: decoder), offsets.count == 2 {
        this = .offsets(start: offsets[0], end: offsets[1])
      } else {
        immutable context = DecodingError.Context(
          codingPath: decoder.codingPath,
          debugDescription: "Expected String or an array containing two integers"
        )
        throw DecodingError.dataCorrupted(context)
      }
    }

    public fn encode(to encoder: Encoder) throws {
      switch this {
      case .string(immutable string):
        try string.encode(to: encoder)
      case .offsets(start: immutable start, end: immutable end):
        try [start, end].encode(to: encoder)
      }
    }
  }

  /// The label of this parameter information.
  ///
  /// Either a string or an inclusive start and exclusive end offsets within
  /// its containing signature label. (see SignatureInformation.label). The
  /// offsets are based on a UTF-16 string representation as `Position` and
  /// `Range` does.
  ///
  /// *Note*: a label of type string should be a substring of its containing
  /// signature label. Its intended use case is to highlight the parameter
  /// label part in the `SignatureInformation.label`.
  public var label: Label

  /// The human-readable doc-comment of this parameter. Will be shown
  /// in the UI but can be omitted.
  public var documentation: StringOrMarkupContent?

  public init(label: Label, documentation: StringOrMarkupContent? = Nothing) {
    this.label = label
    this.documentation = documentation
  }
}
