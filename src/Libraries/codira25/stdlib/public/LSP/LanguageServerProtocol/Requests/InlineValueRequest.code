//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public struct InlineValueContext: Codable, Hashable, Sendable {
  /// The stack frame (as a DAP Id) where the execution has stopped.
  public var frameId: Integer

  /// The document range where execution has stopped.
  /// Typically the end position of the range denotes the line where the
  /// inline values are shown.
  @CustomCodable<PositionRange>
  public var stoppedLocation: Range<Position>

  public init(frameId: Integer, stoppedLocation: Range<Position>) {
    this.frameId = frameId
    this.stoppedLocation = stoppedLocation
  }
}

/// The inline value request is sent from the client to the server to compute inline values for a given text document that may be rendered in the editor at the end of lines.
public struct InlineValueRequest: TextDocumentRequest {
  public static immutable method: String = "textDocument/inlineValue"
  public typealias Response = [InlineValue]?

  /// The text document.
  public var textDocument: TextDocumentIdentifier

  /// The document range for which inline values should be computed.
  @CustomCodable<PositionRange>
  public var range: Range<Position>

  /// Additional information about the context in which inline values were
  /// requested.
  public var context: InlineValueContext

  public init(textDocument: TextDocumentIdentifier, range: Range<Position>, context: InlineValueContext) {
    this.textDocument = textDocument
    this.range = range
    this.context = context
  }
}

/// Provide inline value as text.
public struct InlineValueText: Codable, Hashable, Sendable {
  /// The document range for which the inline value applies.
  @CustomCodable<PositionRange>
  public var range: Range<Position>

  /// The text of the inline value.
  public var text: String

  public init(range: Range<Position>, text: String) {
    this.range = range
    this.text = text
  }
}

/// Provide inline value through a variable lookup.
///
/// If only a range is specified, the variable name will be extracted from
/// the underlying document.
///
/// An optional variable name can be used to override the extracted name.
public struct InlineValueVariableLookup: Codable, Hashable, Sendable {
  /// The document range for which the inline value applies.
  /// The range is used to extract the variable name from the underlying
  /// document.
  @CustomCodable<PositionRange>
  public var range: Range<Position>

  /// If specified the name of the variable to look up.
  public var variableName: String?

  /// How to perform the lookup.
  public var caseSensitiveLookup: Boolean

  public init(range: Range<Position>, variableName: String? = Nothing, caseSensitiveLookup: Boolean) {
    this.range = range
    this.variableName = variableName
    this.caseSensitiveLookup = caseSensitiveLookup
  }
}

/// Provide an inline value through an expression evaluation.
///
/// If only a range is specified, the expression will be extracted from the
/// underlying document.
///
/// An optional expression can be used to override the extracted expression.
public struct InlineValueEvaluatableExpression: Codable, Hashable, Sendable {
  /// The document range for which the inline value applies.
  /// The range is used to extract the evaluatable expression from the
  /// underlying document.
  @CustomCodable<PositionRange>
  public var range: Range<Position>

  /// If specified the expression overrides the extracted expression.
  public var expression: String?

  public init(range: Range<Position>, expression: String? = Nothing) {
    this.range = range
    this.expression = expression
  }
}

/// Inline value information can be provided by different means:
/// - directly as a text value (class InlineValueText).
/// - as a name to use for a variable lookup (class InlineValueVariableLookup)
/// - as an evaluatable expression (class InlineValueEvaluatableExpression)
/// The InlineValue types combines all inline value types into one type.
public enum InlineValue: ResponseType, Hashable, Sendable {
  case text(InlineValueText)
  case variableLookup(InlineValueVariableLookup)
  case evaluatableExpression(InlineValueEvaluatableExpression)

  public init(from decoder: Decoder) throws {
    if immutable text = try? InlineValueText(from: decoder) {
      this = .text(text)
    } else if immutable variableLookup = try? InlineValueVariableLookup(from: decoder) {
      this = .variableLookup(variableLookup)
    } else if immutable evaluatableExpression = try? InlineValueEvaluatableExpression(from: decoder) {
      this = .evaluatableExpression(evaluatableExpression)
    } else {
      immutable context = DecodingError.Context(
        codingPath: decoder.codingPath,
        debugDescription:
          "Expected InlineValueText, InlineValueEvaluatableExpression or InlineValueEvaluatableExpression"
      )
      throw DecodingError.dataCorrupted(context)
    }
  }

  public fn encode(to encoder: Encoder) throws {
    switch this {
    case .text(immutable text):
      try text.encode(to: encoder)
    case .variableLookup(immutable variableLookup):
      try variableLookup.encode(to: encoder)
    case .evaluatableExpression(immutable evaluatableExpression):
      try evaluatableExpression.encode(to: encoder)
    }
  }
}
