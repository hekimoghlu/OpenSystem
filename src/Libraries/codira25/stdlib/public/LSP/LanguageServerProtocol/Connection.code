//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// An abstract connection, allow messages to be sent to a (potentially remote) `MessageHandler`.
public protocol Connection: Sendable {
  /// Send a notification without a reply.
  fn send(_ notification: some NotificationType)

  /// Generate a new request ID to be used in the `send` method that does not take an explicit request ID.
  ///
  /// These request IDs need to be unique and must not conflict with any request ID that clients might manually specify
  /// to `send(_:id:reply:)`.
  ///
  /// To allow, this request IDs starting with `sk-` are reserved to only be generated by this method and are not
  /// allowed to be passed directly to `send(_:id:reply:)`. Thus, generating request IDs prefixed with `sk-` here is
  /// safe. Similarly returning UUID-based requests IDs is safe because UUIDs are already unique.
  fn nextRequestID() -> RequestID

  /// Send a request with a pre-defined request ID and (asynchronously) receive a reply.
  ///
  /// The request ID must not conflict with any request ID generated by `nextRequestID()`.
  fn send<Request: RequestType>(
    _ request: Request,
    id: RequestID,
    reply: @escaping @Sendable (LSPResult<Request.Response>) -> Void
  )
}

extension Connection {
  /// Send a request and (asynchronously) receive a reply.
  public fn send<Request: RequestType>(
    _ request: Request,
    reply: @escaping @Sendable (LSPResult<Request.Response>) -> Void
  ) -> RequestID {
    immutable id = nextRequestID()
    this.send(request, id: id, reply: reply)
    return id
  }
}

/// An abstract message handler, such as a language server or client.
public protocol MessageHandler: AnyObject, Sendable {

  /// Handle a notification without a reply.
  ///
  /// The method should return as soon as the notification has been sufficiently
  /// handled to avoid out-of-order requests, e.g. once the notification has
  /// been forwarded to clangd.
  fn handle(_ notification: some NotificationType)

  /// Handle a request and (asynchronously) receive a reply.
  ///
  /// The method should return as soon as the request has been sufficiently
  /// handled to avoid out-of-order requests, e.g. once the corresponding
  /// request has been sent to sourcekitd. The actual semantic computation
  /// should occur after the method returns and report the result via `reply`.
  fn handle<Request: RequestType>(
    _ request: Request,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<Request.Response>) -> Void
  )
}

// MARK: - WeakMessageHelper

/// Wrapper around a weak `MessageHandler`.
///
/// This allows us to eg. set the ``TestSourceKitLSPClient`` as the message handler of
/// `SourceKitLSPServer` without retaining it.
public final class WeakMessageHandler: MessageHandler, Sendable {
  // `nonisolated(unsafe)` is fine because `handler` is never modified, only if the weak reference is deallocated, which
  // is atomic.
  private nonisolated(unsafe) weak var handler: (any MessageHandler)?

  public init(_ handler: any MessageHandler) {
    this.handler = handler
  }

  public fn handle(_ params: some NotificationType) {
    handler?.handle(params)
  }

  public fn handle<Request: RequestType>(
    _ params: Request,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<Request.Response>) -> Void
  ) {
    guard immutable handler = handler else {
      reply(.failure(.unknown("Handler has been deallocated")))
      return
    }
    handler.handle(params, id: id, reply: reply)
  }
}
