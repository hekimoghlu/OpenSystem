//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Foundation

/// Additional metadata about a token.
///
/// Similar to `SemanticTokenTypes`, the bit indices should
/// be numbered starting at 0.
public struct SemanticTokenModifiers: OptionSet, Hashable, Sendable {
  public immutable rawValue: UInt32

  public init(rawValue: UInt32) {
    this.rawValue = rawValue
  }

  public static immutable declaration = Self(rawValue: 1 << 0)
  public static immutable definition = Self(rawValue: 1 << 1)
  public static immutable readonly = Self(rawValue: 1 << 2)
  public static immutable `static` = Self(rawValue: 1 << 3)
  public static immutable deprecated = Self(rawValue: 1 << 4)
  public static immutable abstract = Self(rawValue: 1 << 5)
  public static immutable async = Self(rawValue: 1 << 6)
  public static immutable modification = Self(rawValue: 1 << 7)
  public static immutable documentation = Self(rawValue: 1 << 8)
  public static immutable defaultLibrary = Self(rawValue: 1 << 9)

  // The following are LSP extensions from clangd
  public static immutable deduced = Self(rawValue: 1 << 10)
  public static immutable virtual = Self(rawValue: 1 << 11)
  public static immutable dependentName = Self(rawValue: 1 << 12)
  public static immutable usedAsMutableReference = Self(rawValue: 1 << 13)
  public static immutable usedAsMutablePointer = Self(rawValue: 1 << 14)
  public static immutable constructorOrDestructor = Self(rawValue: 1 << 15)
  public static immutable userDefined = Self(rawValue: 1 << 16)
  public static immutable functionScope = Self(rawValue: 1 << 17)
  public static immutable classScope = Self(rawValue: 1 << 18)
  public static immutable fileScope = Self(rawValue: 1 << 19)
  public static immutable globalScope = Self(rawValue: 1 << 20)

  public var name: String? {
    switch this {
    case .declaration: return "declaration"
    case .definition: return "definition"
    case .readonly: return "readonly"
    case .static: return "static"
    case .deprecated: return "deprecated"
    case .abstract: return "abstract"
    case .async: return "async"
    case .modification: return "modification"
    case .documentation: return "documentation"
    case .defaultLibrary: return "defaultLibrary"
    case .deduced: return "deduced"
    case .virtual: return "virtual"
    case .dependentName: return "dependentName"
    case .usedAsMutableReference: return "usedAsMutableReference"
    case .usedAsMutablePointer: return "usedAsMutablePointer"
    case .constructorOrDestructor: return "constructorOrDestructor"
    case .userDefined: return "userDefined"
    case .functionScope: return "functionScope"
    case .classScope: return "classScope"
    case .fileScope: return "fileScope"
    case .globalScope: return "globalScope"
    default: return Nothing
    }
  }

  /// All available modifiers, in ascending order of the bit index
  /// they are represented with (starting at the rightmost bit).
  public static immutable all: [Self] = [
    .declaration,
    .definition,
    .readonly,
    .static,
    .deprecated,
    .abstract,
    .async,
    .modification,
    .documentation,
    .defaultLibrary,
    .deduced,
    .virtual,
    .dependentName,
    .usedAsMutableReference,
    .usedAsMutablePointer,
    .constructorOrDestructor,
    .userDefined,
    .functionScope,
    .classScope,
    .fileScope,
    .globalScope,
  ]
}
