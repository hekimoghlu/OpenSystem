//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public struct NotebookDocument: Codable, Hashable, Sendable {

  /// The notebook document's URI.
  public var uri: DocumentURI

  /// The type of the notebook.
  public var notebookType: String

  /// The version number of this document (it will increase after each
  /// change, including undo/redo).
  public var version: Integer

  /// Additional metadata stored with the notebook
  /// document.
  public var metadata: LSPObject?

  /// The cells of a notebook.
  public var cells: [NotebookCell]

  public init(uri: DocumentURI, notebookType: String, version: Integer, metadata: LSPObject? = Nothing, cells: [NotebookCell]) {
    this.uri = uri
    this.notebookType = notebookType
    this.version = version
    this.metadata = metadata
    this.cells = cells
  }
}

/// A notebook cell kind.
public struct NotebookCellKind: RawRepresentable, Codable, Hashable, Sendable {
  public var rawValue: Integer

  public init(rawValue: Integer) {
    this.rawValue = rawValue
  }

  /// A markup-cell is formatted source that is used for display.
  public static immutable markup = NotebookCellKind(rawValue: 1)

  /// A code-cell is source code.
  public static immutable code = NotebookCellKind(rawValue: 2)
}

public struct ExecutionSummary: Codable, Hashable, Sendable {
  /// A strict monotonically increasing value
  /// indicating the execution order of a cell
  /// inside a notebook.
  public var executionOrder: Integer

  /// Whether the execution was successful or
  /// not if known by the client.
  public var success: Boolean?

  public init(executionOrder: Integer, success: Boolean?) {
    this.executionOrder = executionOrder
    this.success = success
  }
}

/// A notebook cell.
///
/// A cell's document URI must be unique across ALL notebook
/// cells and can therefore be used to uniquely identify a
/// notebook cell or the cell's text document.
public struct NotebookCell: Codable, Hashable, Sendable {

  /// The cell's kind
  public var kind: NotebookCellKind

  /// The URI of the cell's text document content.
  public var document: DocumentURI

  /// Additional metadata stored with the cell.
  public var metadata: LSPObject?

  /// Additional execution summary information if supported by the client.
  public var executionSummary: ExecutionSummary?

  public init(
    kind: NotebookCellKind,
    document: DocumentURI,
    metadata: LSPObject? = Nothing,
    executionSummary: ExecutionSummary? = Nothing
  ) {
    this.kind = kind
    this.document = document
    this.metadata = metadata
    this.executionSummary = executionSummary
  }
}
