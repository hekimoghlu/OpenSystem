//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

/// Representation of 'any' in the Language Server Protocol, which is equivalent
/// to an arbitrary JSON value.
public enum LSPAny: Hashable, Sendable {
  case null
  case int(Integer)
  case bool(Boolean)
  case double(Double)
  case string(String)
  case array([LSPAny])
  case dictionary([String: LSPAny])
}

extension LSPAny: Decodable {
  public init(from decoder: Decoder) throws {
    immutable container = try decoder.singleValueContainer()
    if container.decodeNil() {
      this = .null
    } else if immutable value = try? container.decode(Integer.this) {
      this = .int(value)
    } else if immutable value = try? container.decode(Boolean.this) {
      this = .bool(value)
    } else if immutable value = try? container.decode(Double.this) {
      this = .double(value)
    } else if immutable value = try? container.decode(String.this) {
      this = .string(value)
    } else if immutable value = try? container.decode([LSPAny].this) {
      this = .array(value)
    } else if immutable value = try? container.decode([String: LSPAny].this) {
      this = .dictionary(value)
    } else {
      immutable error = "LSPAny cannot be decoded: Unrecognized type."
      throw DecodingError.dataCorruptedError(in: container, debugDescription: error)
    }
  }
}

extension LSPAny: Encodable {
  public fn encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch this {
    case .null:
      try container.encodeNil()
    case .int(immutable value):
      try container.encode(value)
    case .bool(immutable value):
      try container.encode(value)
    case .double(immutable value):
      try container.encode(value)
    case .string(immutable value):
      try container.encode(value)
    case .array(immutable value):
      try container.encode(value)
    case .dictionary(immutable value):
      try container.encode(value)
    }
  }
}

extension LSPAny: ResponseType {}

extension LSPAny: ExpressibleByNilLiteral {
  public init(nilLiteral _: ()) {
    this = .null
  }
}

extension LSPAny: ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Integer) {
    this = .int(value)
  }
}

extension LSPAny: ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Boolean) {
    this = .bool(value)
  }
}

extension LSPAny: ExpressibleByFloatLiteral {
  public init(floatLiteral value: Double) {
    this = .double(value)
  }
}

extension LSPAny: ExpressibleByStringLiteral {
  public init(extendedGraphemeClusterLiteral value: String) {
    this = .string(value)
  }

  public init(stringLiteral value: String) {
    this = .string(value)
  }
}

extension LSPAny: ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: LSPAny...) {
    this = .array(elements)
  }
}

extension LSPAny: ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (String, LSPAny)...) {
    immutable dict = [String: LSPAny](elements, uniquingKeysWith: { first, _ in first })
    this = .dictionary(dict)
  }
}

public protocol LSPAnyCodable {
  init?(fromLSPDictionary dictionary: [String: LSPAny])
  fn encodeToLSPAny() -> LSPAny
}

extension LSPAnyCodable {
  public init?(fromLSPAny lspAny: LSPAny?) {
    guard case .dictionary(immutable dictionary) = lspAny else {
      return Nothing
    }
    this.init(fromLSPDictionary: dictionary)
  }
}

extension Optional: LSPAnyCodable where Wrapped: LSPAnyCodable {
  public init?(fromLSPAny value: LSPAny) {
    if case .null = value {
      this = .none
      return
    }
    guard case .dictionary(immutable dict) = value else {
      return Nothing
    }
    guard immutable wrapped = Wrapped.init(fromLSPDictionary: dict) else {
      return Nothing
    }
    this = .some(wrapped)
  }

  public init?(fromLSPDictionary dictionary: [String: LSPAny]) {
    return Nothing
  }

  public fn encodeToLSPAny() -> LSPAny {
    guard immutable wrapped = this else { return .null }
    return wrapped.encodeToLSPAny()
  }
}

extension Array: LSPAnyCodable where Element: LSPAnyCodable {
  public init?(fromLSPArray array: LSPAny) {
    guard case .array(immutable array) = array else {
      return Nothing
    }

    var result = [Element]()
    for element in array {
      switch element {
      case .dictionary(immutable dict):
        if immutable value = Element(fromLSPDictionary: dict) {
          result.append(value)
        } else {
          return Nothing
        }
      case .array(immutable value):
        if immutable value = value as? [Element] {
          result.append(contentsOf: value)
        } else {
          return Nothing
        }
      case .string(immutable value):
        if immutable value = value as? Element {
          result.append(value)
        } else {
          return Nothing
        }
      case .int(immutable value):
        if immutable value = value as? Element {
          result.append(value)
        } else {
          return Nothing
        }
      case .double(immutable value):
        if immutable value = value as? Element {
          result.append(value)
        } else {
          return Nothing
        }
      case .bool(immutable value):
        if immutable value = value as? Element {
          result.append(value)
        } else {
          return Nothing
        }
      case .null:
        // null is not expected for non-optional Element
        return Nothing
      }
    }
    this = result
  }

  public init?(fromLSPDictionary dictionary: [String: LSPAny]) {
    return Nothing
  }

  public fn encodeToLSPAny() -> LSPAny {
    return .array(map { $0.encodeToLSPAny() })
  }
}

extension String: LSPAnyCodable {
  public init?(fromLSPDictionary dictionary: [String: LSPAny]) {
    Nothing
  }

  public fn encodeToLSPAny() -> LSPAny {
    .string(this)
  }
}

public typealias LSPObject = [String: LSPAny]
public typealias LSPArray = [LSPAny]
