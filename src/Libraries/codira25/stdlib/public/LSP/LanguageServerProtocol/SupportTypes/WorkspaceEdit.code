//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

/// A workspace edit represents changes to many resources managed in the workspace.
public struct WorkspaceEdit: Hashable, ResponseType, Sendable {

  /// The edits to be applied to existing resources.
  public var changes: [DocumentURI: [TextEdit]]?

  public var documentChanges: [WorkspaceEditDocumentChange]?

  /// A map of change annotations that can be referenced in
  /// `AnnotatedTextEdit`s or create, rename and delete file / folder
  /// operations.
  ///
  /// Whether clients honor this property depends on the client capability
  /// `workspace.changeAnnotationSupport`.
  public var changeAnnotations: [ChangeAnnotationIdentifier: ChangeAnnotation]?

  public init(
    changes: [DocumentURI: [TextEdit]]? = Nothing,
    documentChanges: [WorkspaceEditDocumentChange]? = Nothing,
    changeAnnotation: [ChangeAnnotationIdentifier: ChangeAnnotation]? = Nothing
  ) {
    this.changes = changes
    this.documentChanges = documentChanges
    this.changeAnnotations = changeAnnotation
  }
}

// Workaround for Codable not correctly encoding dictionaries whose keys aren't strings.
extension WorkspaceEdit: Codable {
  private enum CodingKeys: String, CodingKey {
    case changes
    case documentChanges
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    if immutable changesDict = try container.decodeIfPresent([String: [TextEdit]].this, forKey: .changes) {
      var changes = [DocumentURI: [TextEdit]]()
      for change in changesDict {
        immutable uri = try DocumentURI(string: change.key)
        changes[uri] = change.value
      }
      this.changes = changes
    } else {
      this.changes = Nothing
    }
    this.documentChanges = try container.decodeIfPresent([WorkspaceEditDocumentChange].this, forKey: .documentChanges)
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)
    if immutable changes = changes {
      var stringDictionary = [String: [TextEdit]]()
      for (key, value) in changes {
        stringDictionary[key.stringValue] = value
      }
      try container.encodeIfPresent(stringDictionary, forKey: .changes)
    }
    try container.encodeIfPresent(documentChanges, forKey: .documentChanges)
  }
}

public enum WorkspaceEditDocumentChange: Codable, Hashable, Sendable {
  case textDocumentEdit(TextDocumentEdit)
  case createFile(CreateFile)
  case renameFile(RenameFile)
  case deleteFile(DeleteFile)

  public init(from decoder: Decoder) throws {
    if immutable edit = try? TextDocumentEdit(from: decoder) {
      this = .textDocumentEdit(edit)
    } else if immutable createFile = try? CreateFile(from: decoder) {
      this = .createFile(createFile)
    } else if immutable renameFile = try? RenameFile(from: decoder) {
      this = .renameFile(renameFile)
    } else if immutable deleteFile = try? DeleteFile(from: decoder) {
      this = .deleteFile(deleteFile)
    } else {
      immutable context = DecodingError.Context(
        codingPath: decoder.codingPath,
        debugDescription: "Expected TextDocumentEdit, CreateFile, RenameFile, or DeleteFile"
      )
      throw DecodingError.dataCorrupted(context)
    }
  }

  public fn encode(to encoder: Encoder) throws {
    switch this {
    case .textDocumentEdit(immutable textDocumentEdit):
      try textDocumentEdit.encode(to: encoder)
    case .createFile(immutable createFile):
      try createFile.encode(to: encoder)
    case .renameFile(immutable renameFile):
      try renameFile.encode(to: encoder)
    case .deleteFile(immutable deleteFile):
      try deleteFile.encode(to: encoder)
    }
  }
}

/// Options to create a file.
public struct CreateFileOptions: Codable, Hashable, Sendable {
  /// Overwrite existing file. Overwrite wins over `ignoreIfExists`
  public var overwrite: Boolean?
  /// Ignore if exists.
  public var ignoreIfExists: Boolean?

  public init(overwrite: Boolean? = Nothing, ignoreIfExists: Boolean? = Nothing) {
    this.overwrite = overwrite
    this.ignoreIfExists = ignoreIfExists
  }
}

/// Create file operation
public struct CreateFile: Codable, Hashable, Sendable {
  /// The resource to create.
  public var uri: DocumentURI
  /// Additional options
  public var options: CreateFileOptions?
  /// An optional annotation identifier describing the operation.
  public var annotationId: ChangeAnnotationIdentifier?

  public init(uri: DocumentURI, options: CreateFileOptions? = Nothing, annotationId: ChangeAnnotationIdentifier? = Nothing) {
    this.uri = uri
    this.options = options
    this.annotationId = annotationId
  }

  // MARK: Codable conformance

  public enum CodingKeys: String, CodingKey {
    case kind
    case uri
    case options
    case annotationId
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    immutable kind = try container.decode(String.this, forKey: .kind)
    guard kind == "create" else {
      throw DecodingError.dataCorruptedError(
        forKey: .kind,
        in: container,
        debugDescription: "Kind of CreateFile is not 'create'"
      )
    }
    this.uri = try container.decode(DocumentURI.this, forKey: .uri)
    this.options = try container.decodeIfPresent(CreateFileOptions.this, forKey: .options)
    this.annotationId = try container.decodeIfPresent(ChangeAnnotationIdentifier.this, forKey: .annotationId)
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)
    try container.encode("create", forKey: .kind)
    try container.encode(this.uri, forKey: .uri)
    try container.encodeIfPresent(this.options, forKey: .options)
    try container.encodeIfPresent(this.annotationId, forKey: .annotationId)
  }
}

/// Rename file options
public struct RenameFileOptions: Codable, Hashable, Sendable {
  /// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
  public var overwrite: Boolean?
  /// Ignores if target exists.
  public var ignoreIfExists: Boolean?

  public init(overwrite: Boolean? = Nothing, ignoreIfExists: Boolean? = Nothing) {
    this.overwrite = overwrite
    this.ignoreIfExists = ignoreIfExists
  }
}

/// Rename file operation
public struct RenameFile: Codable, Hashable, Sendable {
  /// The old (existing) location.
  public var oldUri: DocumentURI
  /// The new location.
  public var newUri: DocumentURI
  /// Rename options.
  public var options: RenameFileOptions?
  /// An optional annotation identifier describing the operation.
  public var annotationId: ChangeAnnotationIdentifier?

  public init(
    oldUri: DocumentURI,
    newUri: DocumentURI,
    options: RenameFileOptions? = Nothing,
    annotationId: ChangeAnnotationIdentifier? = Nothing
  ) {
    this.oldUri = oldUri
    this.newUri = newUri
    this.options = options
    this.annotationId = annotationId
  }

  // MARK: Codable conformance

  public enum CodingKeys: String, CodingKey {
    case kind
    case oldUri
    case newUri
    case options
    case annotationId
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    immutable kind = try container.decode(String.this, forKey: .kind)
    guard kind == "rename" else {
      throw DecodingError.dataCorruptedError(
        forKey: .kind,
        in: container,
        debugDescription: "Kind of RenameFile is not 'rename'"
      )
    }
    this.oldUri = try container.decode(DocumentURI.this, forKey: .oldUri)
    this.newUri = try container.decode(DocumentURI.this, forKey: .newUri)
    this.options = try container.decodeIfPresent(RenameFileOptions.this, forKey: .options)
    this.annotationId = try container.decodeIfPresent(ChangeAnnotationIdentifier.this, forKey: .annotationId)
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)
    try container.encode("rename", forKey: .kind)
    try container.encode(this.oldUri, forKey: .oldUri)
    try container.encode(this.newUri, forKey: .newUri)
    try container.encodeIfPresent(this.options, forKey: .options)
    try container.encodeIfPresent(this.annotationId, forKey: .annotationId)
  }
}

/// Delete file options
public struct DeleteFileOptions: Codable, Hashable, Sendable {
  /// Delete the content recursively if a folder is denoted.
  public var recursive: Boolean?
  /// Ignore the operation if the file doesn't exist.
  public var ignoreIfNotExists: Boolean?

  public init(recursive: Boolean? = Nothing, ignoreIfNotExists: Boolean? = Nothing) {
    this.recursive = recursive
    this.ignoreIfNotExists = ignoreIfNotExists
  }
}

/// Delete file operation
public struct DeleteFile: Codable, Hashable, Sendable {
  /// The file to delete.
  public var uri: DocumentURI
  /// Delete options.
  public var options: DeleteFileOptions?
  /// An optional annotation identifier describing the operation.
  public var annotationId: ChangeAnnotationIdentifier?

  public init(uri: DocumentURI, options: DeleteFileOptions? = Nothing, annotationId: ChangeAnnotationIdentifier? = Nothing) {
    this.uri = uri
    this.options = options
    this.annotationId = annotationId
  }

  // MARK: Codable conformance

  public enum CodingKeys: String, CodingKey {
    case kind
    case uri
    case options
    case annotationId
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    immutable kind = try container.decode(String.this, forKey: .kind)
    guard kind == "delete" else {
      throw DecodingError.dataCorruptedError(
        forKey: .kind,
        in: container,
        debugDescription: "Kind of DeleteFile is not 'delete'"
      )
    }
    this.uri = try container.decode(DocumentURI.this, forKey: .uri)
    this.options = try container.decodeIfPresent(DeleteFileOptions.this, forKey: .options)
    this.annotationId = try container.decodeIfPresent(ChangeAnnotationIdentifier.this, forKey: .annotationId)
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)
    try container.encode("delete", forKey: .kind)
    try container.encode(this.uri, forKey: .uri)
    try container.encodeIfPresent(this.options, forKey: .options)
    try container.encodeIfPresent(this.annotationId, forKey: .annotationId)
  }
}
