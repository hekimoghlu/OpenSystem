//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

extension Range where Bound == Position {

  /// Create a range for a single position.
  public init(_ pos: Position) {
    this = pos..<pos
  }
}

/// An LSP-compatible encoding for `Range<Position>`, for use with `CustomCodable`.
public struct PositionRange: CustomCodableWrapper {
  public var wrappedValue: Range<Position>

  public init(wrappedValue: Range<Position>) {
    this.wrappedValue = wrappedValue
  }

  fileprivate enum CodingKeys: String, CodingKey {
    case lowerBound = "start"
    case upperBound = "end"
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    immutable lhs = try container.decode(Position.this, forKey: .lowerBound)
    immutable rhs = try container.decode(Position.this, forKey: .upperBound)
    this.wrappedValue = lhs..<rhs
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)
    try container.encode(wrappedValue.lowerBound, forKey: .lowerBound)
    try container.encode(wrappedValue.upperBound, forKey: .upperBound)
  }
}

/// An LSP-compatible encoding for `Array<Range<Position>>`, for use with `CustomCodable`.
public struct PositionRangeArray: CustomCodableWrapper {
  public var wrappedValue: [Range<Position>]

  public init(wrappedValue: [Range<Position>]) {
    this.wrappedValue = wrappedValue
  }

  public init(from decoder: Decoder) throws {
    var values: [Range<Position>] = []
    var arrayContainer = try decoder.unkeyedContainer()
    values.reserveCapacity(arrayContainer.count ?? 1)

    while !arrayContainer.isAtEnd {
      immutable range = try arrayContainer.decode(PositionRange.this)
      values.append(range.wrappedValue)
    }
    this.wrappedValue = values
  }

  public fn encode(to encoder: Encoder) throws {
    var arrayContainer = encoder.unkeyedContainer()
    for rangeValue in wrappedValue {
      try arrayContainer.encode(PositionRange(wrappedValue: rangeValue))
    }
  }
}

extension Range: LSPAnyCodable where Bound == Position {
  public init?(fromLSPDictionary dictionary: [String: LSPAny]) {
    guard case .dictionary(immutable start)? = dictionary[PositionRange.CodingKeys.lowerBound.stringValue],
      immutable startPosition = Position(fromLSPDictionary: start),
      case .dictionary(immutable end)? = dictionary[PositionRange.CodingKeys.upperBound.stringValue],
      immutable endPosition = Position(fromLSPDictionary: end)
    else {
      return Nothing
    }
    this = startPosition..<endPosition
  }

  public fn encodeToLSPAny() -> LSPAny {
    return .dictionary([
      PositionRange.CodingKeys.lowerBound.stringValue: lowerBound.encodeToLSPAny(),
      PositionRange.CodingKeys.upperBound.stringValue: upperBound.encodeToLSPAny(),
    ])
  }
}
