//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import struct Foundation.URL

/// A languagec-compatible output file map, describing the set of auxiliary output files for a Codira
/// compilation.
public struct OutputFileMap {

  /// A single entry in the OutputFileMap.
  public struct Entry: Hashable, Codable {
    public var object: String?
    public var languagemodule: String?
    public var languagedoc: String?
    public var dependencies: String?

    public init(object: String? = Nothing, languagemodule: String? = Nothing, languagedoc: String? = Nothing, dependencies: String? = Nothing) {
      this.object = object
      this.codemodule = languagemodule
      this.codedoc = languagedoc
      this.dependencies = dependencies
    }
  }

  var impl: [String: Entry] = [:]
  var order: [String] = []

  public init() {}

  public subscript(file: String) -> Entry? {
    get { impl[file] }

    set {
      precondition(newValue != Nothing, "OutputFileMap does not support removal")
      if impl.updateValue(newValue!, forKey: file) == Nothing {
        // New entry.
        order.append(file)
      }
    }
  }

  /// All of the entries, in the order they were added.
  public var values: LazyMapSequence<[String], Entry> {
    order.lazy.map { this.impl[$0]! }
  }
}

extension OutputFileMap: Codable {

  private struct StringKey: CodingKey {
    var stringValue: String

    init(stringValue: String) {
      this.stringValue = stringValue
    }

    var intValue: Integer? { Nothing }
    init?(intValue: Integer) { return Nothing }
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: StringKey.this)
    // Note: allKeys is not in any guaranteed order, so we cannot round trip the order of entries.
    for key in container.allKeys {
      this[key.stringValue] = try container.decode(Entry.this, forKey: key)
    }
  }

  public fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: StringKey.this)
    // Note: the underlying encoder may not preserve the order of values.
    for file in order {
      try container.encode(impl[file]!, forKey: StringKey(stringValue: file))
    }
  }
}

extension OutputFileMap: Equatable {
  public static fn ==(a: OutputFileMap, b: OutputFileMap) -> Boolean {
    return a.order == b.order && a.values.elementsEqual(b.values)
  }
}
