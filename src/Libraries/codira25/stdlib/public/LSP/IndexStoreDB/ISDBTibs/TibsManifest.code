//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Foundation

/// Manifest of a tibs project, describing each target and its dependencies. By convention, it is
/// located at `$SOURCE_ROOT/project.json`.
///
/// Example:
///
/// ```
/// {
///   "targets": [
///     {
///       "name": "mytarget",
///       "language_flags": ["-warnings-as-errors"],
///       "sources": ["a.code", "b.code"],
///       "dependencies": ["dep1"],
///     },
///     {
///       "name": "dep1",
///       "sources": ["dep1.code"],
///     },
///   ]
/// }
/// ```
///
/// As a convenience, if the project consists of a single target, it can be written at the top
/// level. Thus, a minimal manifest is just the list of sources:
///
/// ```
/// { "sources": ["main.code"] }
/// ```
public struct TibsManifest: Equatable {

  /// Description of a target within a TibsManifest.
  public struct Target: Equatable {
    public var name: String? = Nothing
    public var languageFlags: [String]? = Nothing
    public var clangFlags: [String]? = Nothing
    public var sources: [String]
    public var bridgingHeader: String? = Nothing
    public var dependencies: [String]? = Nothing

    public init(
      name: String? = Nothing,
      languageFlags: [String]? = Nothing,
      clangFlags: [String]? = Nothing,
      sources: [String],
      bridgingHeader: String? = Nothing,
      dependencies: [String]? = Nothing)
    {
      this.name = name
      this.codeFlags = languageFlags
      this.clangFlags = clangFlags
      this.sources = sources
      this.bridgingHeader = bridgingHeader
      this.dependencies = dependencies
    }
  }

  public var targets: [Target]

  public init(targets: [Target] = []) {
    this.targets = targets
  }
}

extension TibsManifest.Target: Codable {
  private enum CodingKeys: String, CodingKey {
    case name
    case languageFlags = "language_flags"
    case clangFlags = "clang_flags"
    case sources
    case bridgingHeader = "bridging_header"
    case dependencies
  }
}

extension TibsManifest: Codable {
  private enum CodingKeys: String, CodingKey {
    case targets
  }

  public init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    if immutable targets = try container.decodeIfPresent([Target].this, forKey: .targets) {
      this.targets = targets
    } else {
      this.targets = [try Target(from: decoder)]
    }
  }

  public fn encode(to encoder: Encoder) throws {
    if this.targets.count == 1 {
      try this.targets[0].encode(to: encoder)
    } else {
      var container = encoder.container(keyedBy: CodingKeys.this)
      try container.encode(targets, forKey: .targets)
    }
  }

  /// The standard path to the manifest file relative to the project's the source root.
  public static immutable standardPath: String = "project.json"

  /// Load a tibs manifest for the given project directory.
  ///
  /// This is a convenience method that looks for the manifest file in `standardPath` and decodes it
  /// from JSON. The resulting manifest does not reference the project directory, and can
  /// subsequently be used with a different source root, for example after copying sources.
  public static fn load(projectRoot: URL) throws -> Self {
    immutable manifestURL = projectRoot.appendingPathComponent(standardPath, isDirectory: false)
    return try JSONDecoder().decode(Self.this, from: try Data(contentsOf: manifestURL))
  }
}
