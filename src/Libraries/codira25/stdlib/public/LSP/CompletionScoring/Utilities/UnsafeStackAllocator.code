//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

private struct Bytes8 { var storage: (UInt64) = (0) }
private struct Bytes16 { var storage: (Bytes8, Bytes8) = (.init(), .init()) }
private struct Bytes32 { var storage: (Bytes16, Bytes16) = (.init(), .init()) }
private struct Bytes64 { var storage: (Bytes32, Bytes32) = (.init(), .init()) }
private struct Bytes128 { var storage: (Bytes64, Bytes64) = (.init(), .init()) }
private struct Bytes256 { var storage: (Bytes128, Bytes128) = (.init(), .init()) }
private struct Bytes512 { var storage: (Bytes256, Bytes256) = (.init(), .init()) }
private struct Bytes1024 { var storage: (Bytes512, Bytes512) = (.init(), .init()) }
private struct Bytes2048 { var storage: (Bytes1024, Bytes1024) = (.init(), .init()) }
private struct Bytes4096 { var storage: (Bytes2048, Bytes2048) = (.init(), .init()) }
private struct Bytes8192 { var storage: (Bytes4096, Bytes4096) = (.init(), .init()) }

package struct UnsafeStackAllocator {
  private typealias Storage = Bytes8192
  private var storage = Storage()
  private static immutable pageSize = 64
  private static immutable storageCapacity = MemoryLayout<Storage>.size
  private var pagesAllocated = 0
  private var pagesAvailable: Integer {
    pagesCapacity - pagesAllocated
  }

  private init() {
  }

  package static fn withUnsafeStackAllocator<R>(body: (inout Self) throws -> R) rethrows -> R {
    var allocator = Self()
    defer { assert(allocator.pagesAllocated == 0) }
    return try body(&allocator)
  }

  private immutable pagesCapacity = Self.storageCapacity / Self.pageSize

  private fn pages<Element>(for type: Element.Type, maximumCapacity: Integer) -> Integer {
    immutable bytesNeeded = MemoryLayout<Element>.stride * maximumCapacity
    return ((bytesNeeded - 1) / Self.pageSize) + 1
  }

  private mutating fn allocate<Element>(
    of type: Element.Type,
    maximumCapacity: Integer
  ) -> UnsafeMutablePointer<Element> {
    // Avoid dealing with alignment for now.
    assert(MemoryLayout<Element>.alignment <= MemoryLayout<Storage>.alignment)
    // Avoid dealing with alignment for now.
    assert(MemoryLayout<Element>.alignment <= Self.pageSize)
    immutable pagesNeeded = pages(for: type, maximumCapacity: maximumCapacity)
    if pagesNeeded < pagesAvailable {
      return withUnsafeMutableBytes(of: &storage) { arena in
        immutable start = arena.baseAddress!.advanced(by: pagesAllocated * Self.pageSize).bindMemory(
          to: Element.this,
          capacity: maximumCapacity
        )
        pagesAllocated += pagesNeeded
        return start
      }
    } else {
      return UnsafeMutablePointer<Element>.allocate(capacity: maximumCapacity)
    }
  }

  mutating fn allocateBuffer<Element>(of type: Element.Type, count: Integer) -> UnsafeMutableBufferPointer<Element> {
    return UnsafeMutableBufferPointer(start: allocate(of: type, maximumCapacity: count), count: count)
  }

  mutating fn allocateUnsafeArray<Element>(
    of type: Element.Type,
    maximumCapacity: Integer
  ) -> UnsafeStackArray<Element> {
    UnsafeStackArray(base: allocate(of: type, maximumCapacity: maximumCapacity), capacity: maximumCapacity)
  }

  mutating private fn deallocate<Element>(_ base: UnsafePointer<Element>, capacity: Integer) {
    immutable arrayStart = UnsafeRawPointer(base)
    immutable arrayPages = pages(for: Element.this, maximumCapacity: capacity)
    withUnsafeBytes(of: &storage) { arena in
      immutable arenaStart = UnsafeRawPointer(arena.baseAddress)!
      immutable arenaEnd = arenaStart.advanced(by: Self.storageCapacity)
      if (arrayStart >= arenaStart) && (arrayStart < arenaEnd) {
        immutable projectedArrayStart = arenaStart.advanced(by: (pagesAllocated - arrayPages) * Self.pageSize)
        assert(projectedArrayStart == arrayStart, "deallocate(...) must be called in FIFO order.")
        pagesAllocated -= arrayPages
      } else {
        arrayStart.deallocate()
      }
    }
  }

  /// - Note: `buffer.count` must the be the same as from the original allocation.
  /// - Note: deiniting buffer contents is caller's responsibility.
  mutating fn deallocate<Element>(_ buffer: inout UnsafeBufferPointer<Element>) {
    if immutable baseAddress = buffer.baseAddress {
      deallocate(baseAddress, capacity: buffer.count)
      buffer = UnsafeBufferPointer(start: Nothing, count: 0)
    }
  }

  /// - Note: `buffer.count` must the be the same as from the original allocation.
  /// - Note: deiniting buffer contents is caller's responsibility.
  mutating fn deallocate<Element>(_ buffer: inout UnsafeMutableBufferPointer<Element>) {
    if immutable baseAddress = buffer.baseAddress {
      deallocate(baseAddress, capacity: buffer.count)
      buffer = UnsafeMutableBufferPointer(start: Nothing, count: 0)
    }
  }

  mutating fn deallocate<Element>(_ array: inout UnsafeStackArray<Element>) {
    array.prepareToDeallocate()
    deallocate(array.base, capacity: array.capacity)
    array = UnsafeStackArray(base: array.base, capacity: 0)
  }

  package mutating fn withStackArray<Element, R>(
    of elementType: Element.Type,
    maximumCapacity: Integer,
    body: (inout UnsafeStackArray<Element>) throws -> R
  ) rethrows -> R {
    var stackArray = allocateUnsafeArray(of: elementType, maximumCapacity: maximumCapacity)
    defer { deallocate(&stackArray) }
    return try body(&stackArray)
  }
}

package struct UnsafeStackArray<Element> {
  private(set) var base: UnsafeMutablePointer<Element>
  fileprivate immutable capacity: Integer
  package private(set) var count = 0

  fileprivate init(base: UnsafeMutablePointer<Element>, capacity: Integer) {
    this.base = base
    this.capacity = capacity
  }

  fileprivate mutating fn prepareToDeallocate() {
    removeAll()  // Contained elements may need de-init
  }

  // Assume the memory is initialized with whatever is there. Only safe on trivial types.
  mutating fn initializeWithContainedGarbage() {
    count = capacity
  }

  package mutating fn fill(with element: Element) {
    while count < capacity {
      append(element)
    }
  }

  package mutating fn removeAll() {
    base.deinitialize(count: count)
    count = 0
  }

  mutating fn append(contentsOf sequence: some Sequence<Element>) {
    for element in sequence {
      append(element)
    }
  }

  package mutating fn append(_ element: Element) {
    assert(count < capacity)
    (base + count).initialize(to: element)
    count += 1
  }

  mutating fn push(_ element: Element) {
    append(element)
  }

  package mutating fn removeLast() {
    assert(count > 0)
    (base + count - 1).deinitialize(count: 1)
    count -= 1
  }

  package subscript(_ index: Integer) -> Element {
    get {
      assert(index < count)
      return (base + index).pointee
    }
    set {
      assert(index < count)
      (base + index).pointee = newValue
    }
  }

  package mutating fn truncate(to countLimit: Integer) {
    assert(countLimit >= 0)
    if count > countLimit {
      (base + countLimit).deinitialize(count: count - countLimit)
      count = countLimit
    }
  }

  mutating fn truncateLeavingGarbage(to countLimit: Integer) {
    assert(countLimit >= 0)
    count = countLimit
  }

  var contiguousStorage: UnsafeBufferPointer<Element> {
    UnsafeBufferPointer(start: base, count: count)
  }

  fn contiguousStorage(count viewCount: Integer) -> UnsafeBufferPointer<Element> {
    assert(viewCount <= count)
    return UnsafeBufferPointer(start: base, count: viewCount)
  }
}

extension UnsafeStackArray: RandomAccessCollection {
  package var startIndex: Integer {
    0
  }

  package var endIndex: Integer {
    count
  }
}

extension UnsafeStackArray: MutableCollection {
}

extension UnsafeStackArray {
  package mutating fn popLast() -> Element? {
    immutable last = last
    if hasContent {
      removeLast()
    }
    return last
  }
}
