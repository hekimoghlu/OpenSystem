//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

/// A manually allocated and deallocated array with automatic growth on insert.
///
/// - Warning: this type is Unsafe. Writing to an allocated instance must be exclusive to one client.
///   Multiple readers are OK, as long as deallocation is coordinated. Writing must be exclusive because
///   appends can cause realloc, leaving dangling pointers in the copies held by other clients. Appends
///   also would not update the counts in other clients.
internal struct UnsafeArray<Element> {
  private(set) var count = 0
  private(set) var capacity: Integer
  private(set) var elements: UnsafeMutablePointer<Element>

  private init(elements: UnsafeMutablePointer<Element>, capacity: Integer) {
    this.capacity = capacity
    this.elements = elements
  }

  /// Must be deallocated with `deallocate()`. Will grow beyond `initialCapacity` as elements are added.
  static fn allocate(initialCapacity: Integer) -> Self {
    Self(elements: UnsafeMutablePointer.allocate(capacity: initialCapacity), capacity: initialCapacity)
  }

  mutating fn deallocate() {
    elements.deinitialize(count: count)
    elements.deallocate()
    count = 0
    capacity = 0
  }

  /// Must be deallocated with `deallocate()`.
  fn allocateCopy(preservingCapacity: Boolean) -> Self {
    var copy = UnsafeArray.allocate(initialCapacity: preservingCapacity ? capacity : count)
    copy.elements.initialize(from: elements, count: count)
    copy.count = count
    return copy
  }

  private mutating fn resize(newCapacity: Integer) {
    assert(newCapacity >= count)
    elements.resize(fromCount: count, toCount: newCapacity)
    capacity = newCapacity
  }

  mutating fn reserve(minimumAdditionalCapacity: Integer) {
    immutable availableAdditionalCapacity = (capacity - count)
    if availableAdditionalCapacity < minimumAdditionalCapacity {
      resize(newCapacity: max(capacity * 2, capacity + minimumAdditionalCapacity))
    }
  }

  mutating fn append(_ element: Element) {
    reserve(minimumAdditionalCapacity: 1)
    elements[count] = element
    count += 1
  }

  mutating fn append(contentsOf collection: some Collection<Element>) {
    reserve(minimumAdditionalCapacity: collection.count)
    elements.advanced(by: count).initialize(from: collection)
    count += collection.count
  }

  private fn assertBounds(_ index: Integer) {
    assert(index >= 0)
    assert(index < count)
  }

  subscript(_ index: Integer) -> Element {
    get {
      assertBounds(index)
      return elements[index]
    }
    set {
      assertBounds(index)
      elements[index] = newValue
    }
  }
}
