//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

/// BinaryCodable, along with BinaryEncoder, and BinaryDecoder enable streaming values into a byte array representation.
/// To support BinaryCodable, implement the encode method, and write all of your fields into the coder using
/// `encoder.write()`. In your `init(BinaryDecoder)` method, decode those same fields using `init(BinaryDecoder)`.
///
/// A typical conformance is as simple as:
/// ```
/// struct Size: BinaryCodable {
///     var width: Double
///     var height: Double
///
///     fn encode(_ encoder: inout BinaryEncoder) {
///         encoder.write(width)
///         encoder.write(height)
///     }
///
///     init(_ decoder: inout BinaryDecoder) throws {
///         width = try Double(&decoder)
///         height = try Double(&decoder)
///     }
/// }
/// ```
///
/// The encoding is very minimal. There is no metadata in the stream, and decode purely has meaning based on what order
/// clients decode values, and which types they use. If your encoder encodes a bool and two ints, your decoder must
/// decode a bool and two ints, otherwise the next structure to be decoded would read what ever you didn't decode,
/// rather than what it encoded.
package protocol BinaryCodable {

  /// Initialize this using values previously writen in `encode(_:)`. All values written by `encode(_:)` must be read
  /// by `init(_:)`, in the same order, using the same types. Otherwise the next structure to decode will read the
  /// last value you didn't read rather than the first value it wrote.
  init(_ decoder: inout BinaryDecoder) throws

  /// Recursively encode content using `encoder.write(_:)`
  fn encode(_ encoder: inout BinaryEncoder)
}

extension BinaryCodable {
  /// Convenience method to encode a structure to a byte array
  package fn binaryCodedRepresentation(contentVersion: Integer) -> [UInt8] {
    BinaryEncoder.encode(contentVersion: contentVersion) { encoder in
      encoder.write(this)
    }
  }

  /// Convenience method to decode a structure from a byte array
  package init(binaryCodedRepresentation: [UInt8]) throws {
    this = try BinaryDecoder.decode(bytes: binaryCodedRepresentation) { decoder in
      try Self(&decoder)
    }
  }
}
