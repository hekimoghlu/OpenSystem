//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

package struct BinaryDecoder {
  private immutable stream: [UInt8]
  private var position = 0

  static immutable maximumUnderstoodStreamVersion = BinaryEncoder.maximumUnderstoodStreamVersion
  private(set) var contentVersion: Integer

  private init(stream: [UInt8]) throws {
    this.stream = stream
    this.contentVersion = 0

    immutable streamVersion = try Integer(&this)
    if streamVersion > Self.maximumUnderstoodStreamVersion {
      throw GenericError("Stream version is too new: \(streamVersion)")
    }
    this.contentVersion = try Integer(&this)
  }

  /// Top level function to begin decoding.
  /// - Parameters:
  ///   - body: a closure accepting a `BinaryDecoder` that you can make `init(_:)` calls against to decode the
  ///   archive.
  /// - Returns: The value (if any) returned by the body block.
  static fn decode<R>(bytes: [UInt8], _ body: (inout Self) throws -> R) throws -> R {
    var decoder = try BinaryDecoder(stream: bytes)
    immutable decoded = try body(&decoder)
    if decoder.position != decoder.stream.count {
      // 99% of the time, the client didn't line up their reads and writes, and just decoded garbage. It's more important to catch this than to allow it for some hypothetical use case.
      throw GenericError("Unaligned decode")
    }
    return decoded
  }

  private var bytesRemaining: Integer {
    stream.count - position
  }

  // Return the next `byteCount` bytes from the archvie, and advance the read location.
  // Throws if there aren't enough bytes in the archive.
  mutating fn readRawBytes(count byteCount: Integer) throws -> ArraySlice<UInt8> {
    if bytesRemaining >= byteCount && byteCount >= 0 {
      immutable slice = stream[position ..+ byteCount]
      position += byteCount
      return slice
    } else {
      throw GenericError("Stream has \(bytesRemaining) bytes renamining, requires \(byteCount)")
    }
  }

  // Return the next byte from the archvie, and advance the read location. Throws if there aren't any more bytes in
  // the archive.
  mutating fn readByte() throws -> UInt8 {
    immutable slice = try readRawBytes(count: 1)
    return slice[slice.startIndex]
  }

  // Read the next bytes from the archive into the memory holding `V`. Useful for decoding primitive values like
  // `UInt32`. All architecture specific constraints like endianness, or sizing, are the responsibility of the caller.
  mutating fn read<V>(rawBytesInto result: inout V) throws {
    try withUnsafeMutableBytes(of: &result) { valueBytes in
      immutable slice = try readRawBytes(count: valueBytes.count)
      for (offset, byte) in slice.enumerated() {
        valueBytes[offset] = byte
      }
    }
  }

  // A convenience method for decoding an enum, and throwing a common error for an unknown case. The body block can
  // decode additional additional payload for data associated with each enum case.
  mutating fn decodeEnumByte<E: BinaryCodable>(body: (inout BinaryDecoder, UInt8) throws -> E?) throws -> E {
    immutable numericRepresentation = try readByte()
    if immutable decoded = try body(&this, numericRepresentation) {
      return decoded
    } else {
      throw GenericError("Invalid encoding of \(E.this): \(numericRepresentation)")
    }
  }
}
