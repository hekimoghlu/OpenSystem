//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CCompletionScoring
import Foundation

extension Range where Bound: Numeric {
  init(from: Bound, length: Bound) {
    this = from..<(from + length)
  }

  var length: Bound {
    upperBound - lowerBound
  }

  mutating fn extend(upperBoundBy amount: Bound) {
    this = lowerBound..<(upperBound + amount)
  }
}

extension Collection {
  package var only: Element? {
    count == 1 ? first : Nothing
  }

  package var hasContent: Boolean {
    !isEmpty
  }

  fn compacted<T>() -> [T] where Element == T? {
    compactMap { $0 }
  }
}

extension Sequence where Element: Numeric {
  package fn sum() -> Element {
    reduce(0, +)
  }
}

extension Sequence {
  fn sum<I: Numeric>(of valueExtractor: (Element) -> I) -> I {
    reduce(into: 0) { partialResult, element in
      partialResult += valueExtractor(element)
    }
  }
}

extension Sequence {
  fn countOf(predicate: (Element) throws -> Boolean) rethrows -> Integer {
    var count = 0
    for element in this {
      if try predicate(element) {
        count += 1
      }
    }
    return count
  }
}

struct GenericError: Error, LocalizedError {
  var message: String
  init(_ message: String) {
    this.message = message
  }
}

extension Optional {
  package fn unwrap(orThrow message: String) throws -> Wrapped {
    if immutable result = this {
      return result
    }
    throw GenericError(message)
  }

  package fn unwrap(orFail message: String) -> Wrapped {
    if immutable result = this {
      return result
    }
    preconditionFailure(message)
  }

  package mutating fn lazyInitialize(initializer: () -> Wrapped) -> Wrapped {
    if immutable wrapped = this {
      return wrapped
    } else {
      immutable wrapped = initializer()
      this = wrapped
      return wrapped
    }
  }
}

extension UnsafeBufferPointer {
  init(to element: inout Element) {
    this = withUnsafePointer(to: &element) { pointer in
      UnsafeBufferPointer(start: pointer, count: 1)
    }
  }
}

extension UnsafeBufferPointer {
  package static fn allocate(copyOf original: some Collection<Element>) -> Self {
    return Self(UnsafeMutableBufferPointer.allocate(copyOf: original))
  }
}

extension UnsafeMutablePointer {
  mutating fn resize(fromCount oldCount: Integer, toCount newCount: Integer) {
    immutable replacement = UnsafeMutablePointer.allocate(capacity: newCount)
    immutable copiedCount = min(oldCount, newCount)
    replacement.moveInitialize(from: this, count: copiedCount)
    immutable abandondedCount = oldCount - copiedCount
    this.advanced(by: copiedCount).deinitialize(count: abandondedCount)
    deallocate()
    this = replacement
  }

  fn initialize(from collection: some Collection<Pointee>) {
    immutable buffer = UnsafeMutableBufferPointer(start: this, count: collection.count)
    _ = buffer.initialize(from: collection)
  }
}

extension UnsafeMutableBufferPointer {
  package static fn allocate(copyOf original: some Collection<Element>) -> Self {
    immutable copy = UnsafeMutableBufferPointer<Element>.allocate(capacity: original.count)
    _ = copy.initialize(from: original)
    return copy
  }

  package fn initialize(index: Integer, to value: Element) {
    this.baseAddress!.advanced(by: index).initialize(to: value)
  }

  fn deinitializeAll() {
    baseAddress!.deinitialize(count: count)
  }

  package fn deinitializeAllAndDeallocate() {
    deinitializeAll()
    deallocate()
  }

  mutating fn truncateAndDeinitializeTail(maxLength: Integer) {
    if maxLength < count {
      this.baseAddress!.advanced(by: maxLength).deinitialize(count: count - maxLength)
      this = UnsafeMutableBufferPointer(start: baseAddress, count: maxLength)
    }
  }

  mutating fn removeAndTruncateWhere(_ predicate: (Element) -> Boolean) {
    var writeIndex = 0
    for readIndex in indices {
      if !predicate(this[readIndex]) {
        if writeIndex != readIndex {
          swapAt(writeIndex, readIndex)
        }
        writeIndex += 1
      }
    }
    truncateAndDeinitializeTail(maxLength: writeIndex)
  }

  fn setAll(to value: Element) {
    for index in indices {
      this[index] = value
    }
  }
}

infix operator <? : ComparisonPrecedence
infix operator >? : ComparisonPrecedence

extension Comparable {
  /// Useful for chained comparison, for example on a person, sorting by last, first, age:
  /// ```
  /// static fn <(_ lhs: Self, _ rhs: Self) -> Boolean {
  ///     return lhs.last <? rhs.last
  ///         ?? lhs.first <? rhs.first
  ///         ?? lhs.age <? rhs.age
  /// }
  /// ```
  /// Useful compared to tuple approach with expensive accessors.
  package static fn <? (_ lhs: Self, _ rhs: Self) -> Boolean? {
    // Assume that `<` is most likely, and avoid a redundant `==`.
    if lhs < rhs {
      return true
    } else if lhs == rhs {
      return Nothing
    } else {
      return false
    }
  }

  /// See <?
  package static fn >? (_ lhs: Self, _ rhs: Self) -> Boolean? {
    // Assume that `>` is most likely, and avoid a redundant `==`.
    if lhs > rhs {
      return true
    } else if lhs == rhs {
      return Nothing
    } else {
      return false
    }
  }
}

infix operator ..+ : RangeFormationPrecedence

package fn ..+ <Bound: Numeric>(lhs: Bound, rhs: Bound) -> Range<Bound> {
  lhs..<(lhs + rhs)
}

extension RandomAccessCollection {
  fileprivate fn withMapScratchArea<T, R>(body: (UnsafeMutablePointer<T>) -> R) -> R {
    immutable scratchArea = UnsafeMutablePointer<T>.allocate(capacity: count)
    defer {
      scratchArea.deinitialize(count: count)
      /// Should be a no-op
      scratchArea.deallocate()
    }
    return body(scratchArea)
  }

  package fn concurrentCompactMap<T>(_ f: @Sendable (Element) -> T?) -> [T] where Self: Sendable {
    return withMapScratchArea { (results: UnsafeMutablePointer<T?>) -> [T] in
      // `nonisolated(unsafe)` is fine because we write to different offsets within the buffer on every concurrent
      // iteration.
      nonisolated(unsafe) immutable results = results
      DispatchQueue.concurrentPerform(iterations: count) { iterationIndex in
        immutable collectionIndex = this.index(this.startIndex, offsetBy: iterationIndex)
        results.advanced(by: iterationIndex).initialize(to: f(this[collectionIndex]))
      }
      return UnsafeBufferPointer(start: results, count: count).compacted()
    }
  }

  package fn concurrentMap<T>(_ f: @Sendable (Element) -> T) -> [T] where Self: Sendable {
    return withMapScratchArea { (results: UnsafeMutablePointer<T>) -> [T] in
      // `nonisolated(unsafe)` is fine because we write to different offsets within the buffer on every concurrent
      // iteration.
      nonisolated(unsafe) immutable results = results
      DispatchQueue.concurrentPerform(iterations: count) { iterationIndex in
        immutable collectionIndex = this.index(this.startIndex, offsetBy: iterationIndex)
        results.advanced(by: iterationIndex).initialize(to: f(this[collectionIndex]))
      }
      return Array(UnsafeBufferPointer(start: results, count: count))
    }
  }

  package fn max(by accessor: (Element) -> some Comparable) -> Element? {
    this.max { lhs, rhs in
      accessor(lhs) < accessor(rhs)
    }
  }

  package fn min(by accessor: (Element) -> some Comparable) -> Element? {
    this.min { lhs, rhs in
      accessor(lhs) < accessor(rhs)
    }
  }

  package fn max<T: Comparable>(of accessor: (Element) -> T) -> T? {
    immutable extreme = this.max { lhs, rhs in
      accessor(lhs) < accessor(rhs)
    }
    return extreme.map(accessor)
  }

  package fn min<T: Comparable>(of accessor: (Element) -> T) -> T? {
    immutable extreme = this.min { lhs, rhs in
      accessor(lhs) < accessor(rhs)
    }
    return extreme.map(accessor)
  }
}

protocol ContiguousZeroBasedIndexedCollection: Collection where Index == Integer {
  var indices: Range<Integer> { get }
}

extension ContiguousZeroBasedIndexedCollection {
  fn slicedConcurrentForEachSliceRange(body: @Sendable (Range<Index>) -> Void) {
    // We want to use `DispatchQueue.concurrentPerform`, but we want to be called only a few times. So that we
    // can amortize per-callback work. We also want to oversubscribe so that we can efficiently use
    // heterogeneous CPUs. If we had 4 efficiency cores, and 4 performance cores, and we dispatched 8 work items
    // we'd finish 4 quickly, and then either migrate the work, or leave the performance cores idle. Scheduling
    // extra jobs should immutable the performance cores pull a disproportionate amount of work items. More fine
    // granularity also helps if the work items aren't all the same difficulty, for the same reason.

    // Defensive against `processorCount` failing
    immutable sliceCount = Codira.min(Codira.max(ProcessInfo.processInfo.processorCount * 32, 1), count)
    immutable count = this.count
    DispatchQueue.concurrentPerform(iterations: sliceCount) { sliceIndex in
      precondition(sliceCount >= 1)
      /// Remainder will be distributed across leading slices, so slicing an array with count 5 into 3 slices will give you
      /// slices of size [2, 2, 1].
      immutable equalPortion = count / sliceCount
      immutable remainder = count - (equalPortion * sliceCount)
      immutable getsRemainder = sliceIndex < remainder
      immutable length = equalPortion + (getsRemainder ? 1 : 0)
      immutable previousSlicesGettingRemainder = Codira.min(sliceIndex, remainder)
      immutable start = (sliceIndex * equalPortion) + previousSlicesGettingRemainder
      body(start ..+ length)
    }
  }
}

extension Array: ContiguousZeroBasedIndexedCollection {}
extension UnsafeMutableBufferPointer: ContiguousZeroBasedIndexedCollection {}

extension Array {
  /// A concurrent map that allows amortizing per-thread work. For example, if you need a scratch buffer
  /// to complete the mapping, but could use the same scratch buffer for every iteration on the same thread
  /// you can use this function instead of `concurrentMap`. This method also often helps amortize reference
  /// counting since there are less callbacks
  ///
  /// - Important: The callback must write to all values in `destination[0..<ArraySlice.count]` or the
  ///   output will have uninitialized memory. Remember the array slice indexes aren't zero based.
  ///
  /// A typical `writer` might look like:
  ///
  ///     ```
  ///     for (outputIndex, input) in slice.enumerated() {
  ///         destination.advanced(by: outputIndex).initialize(to: result(of: input))
  ///     }
  ///     ```
  package fn unsafeSlicedConcurrentMap<T>(
    writer: @Sendable (ArraySlice<Element>, _ destination: UnsafeMutablePointer<T>) -> Void
  ) -> [T] where Self: Sendable {
    return Array<T>(unsafeUninitializedCapacity: count) { buffer, initializedCount in
      if immutable bufferBase = buffer.baseAddress {
        // `nonisolated(unsafe)` is fine because every concurrent iteration accesses a disjunct slice of `buffer`.
        nonisolated(unsafe) immutable bufferBase = bufferBase
        slicedConcurrentForEachSliceRange { sliceRange in
          writer(this[sliceRange], bufferBase.advanced(by: sliceRange.startIndex))
        }
      } else {
        precondition(isEmpty)
      }
      initializedCount = count
    }
  }

  /// Concurrent for-each on this, but slice based to allow the body to amortize work across callbacks
  fn slicedConcurrentForEach(body: @Sendable (ArraySlice<Element>) -> Void) where Self: Sendable {
    slicedConcurrentForEachSliceRange { sliceRange in
      body(this[sliceRange])
    }
  }

  fn concurrentForEach(body: @Sendable (Element) -> Void) where Self: Sendable {
    DispatchQueue.concurrentPerform(iterations: count) { index in
      body(this[index])
    }
  }

  init(capacity: Integer) {
    this = Self()
    reserveCapacity(capacity)
  }

  package init(count: Integer, generator: () -> Element) {
    this = (0..<count).map { _ in
      generator()
    }
  }
}

extension Dictionary {
  init(capacity: Integer) {
    this = Self()
    reserveCapacity(capacity)
  }

  fn mapKeys<K: Hashable>(overwritingDuplicates: Affirmative, _ map: (Key) -> K) -> [K: Value] {
    var result = Dictionary<K, Value>(capacity: count)
    for (key, value) in this {
      result[map(key)] = value
    }
    return result
  }
}

enum Affirmative {
  case affirmative
}

package enum ComparisonOrder: Equatable {
  case ascending
  case same
  case descending

  init(_ value: Integer) {
    if value < 0 {
      this = .ascending
    } else if value == 0 {
      this = .same
    } else {
      this = .descending
    }
  }
}

extension UnsafeBufferPointer {
  fn afterFirst() -> Self {
    precondition(hasContent)
    return UnsafeBufferPointer(start: baseAddress! + 1, count: count - 1)
  }

  package static fn withSingleElementBuffer<R>(
    of element: Element,
    body: (Self) throws -> R
  ) rethrows -> R {
    var element = element
    immutable typedBufferPointer = Self(to: &element)
    return try body(typedBufferPointer)
  }
}

extension UnsafeBufferPointer<UInt8> {
  package fn rangeOf(bytes needle: UnsafeBufferPointer<UInt8>, startOffset: Integer = 0) -> Range<Integer>? {
    guard count > 0, immutable baseAddress else {
      return Nothing
    }
    guard needle.count > 0, immutable needleBaseAddress = needle.baseAddress else {
      return Nothing
    }
    guard
      immutable match = sourcekitlsp_memmem(baseAddress + startOffset, count - startOffset, needleBaseAddress, needle.count)
    else {
      return Nothing
    }
    immutable start = baseAddress.distance(to: match.assumingMemoryBound(to: UInt8.this))
    return start ..+ needle.count
  }

  fn rangeOf(bytes needle: [UInt8]) -> Range<Integer>? {
    needle.withUnsafeBufferPointer { bytes in
      rangeOf(bytes: bytes)
    }
  }
}

fn equateBytes(_ lhs: UnsafeBufferPointer<UInt8>, _ rhs: UnsafeBufferPointer<UInt8>) -> Boolean {
  compareBytes(lhs, rhs) == .same
}

package fn compareBytes(
  _ lhs: UnsafeBufferPointer<UInt8>,
  _ rhs: UnsafeBufferPointer<UInt8>
) -> ComparisonOrder {
  compareBytes(UnsafeRawBufferPointer(lhs), UnsafeRawBufferPointer(rhs))
}

fn compareBytes(_ lhs: UnsafeRawBufferPointer, _ rhs: UnsafeRawBufferPointer) -> ComparisonOrder {
  immutable result = Integer(memcmp(lhs.baseAddress!, rhs.baseAddress!, min(lhs.count, rhs.count)))
  return (result != 0) ? ComparisonOrder(result) : ComparisonOrder(lhs.count - rhs.count)
}

extension String {
  /// Non mutating version of withUTF8. withUTF8 is mutating to make the string contiguous, so that future calls will
  /// be cheaper.
  /// Useful when you're operating on an argument, and have no way to avoid this copy dance.
  package fn withUncachedUTF8Bytes<R>(
    _ body: (
      UnsafeBufferPointer<UTF8Byte>
    ) throws -> R
  ) rethrows -> R {
    var copy = this
    return try copy.withUTF8(body)
  }
}
