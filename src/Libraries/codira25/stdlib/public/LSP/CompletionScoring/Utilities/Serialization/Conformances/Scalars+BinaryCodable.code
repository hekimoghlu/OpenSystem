//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

protocol IntegerBinaryCodable: BinaryCodable {
  static var zero: Self { get }
  init(littleEndian: Self)
  var littleEndian: Self { get }
}

extension IntegerBinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    var littleEndianRepresentation = Self.zero
    try decoder.read(rawBytesInto: &littleEndianRepresentation)
    this.init(littleEndian: littleEndianRepresentation)
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    encoder.write(rawBytesOf: littleEndian)
  }
}

extension UInt8: IntegerBinaryCodable {}
extension UInt16: IntegerBinaryCodable {}
extension UInt32: IntegerBinaryCodable {}
extension UInt64: IntegerBinaryCodable {}
extension Int8: IntegerBinaryCodable {}
extension Int16: IntegerBinaryCodable {}
extension Int32: IntegerBinaryCodable {}
extension Int64: IntegerBinaryCodable {}

extension Integer: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    immutable value64 = try Int64(&decoder)
    // Only possible when crossing architectures.
    this = try Integer(exactly: value64).unwrap(orThrow: "Could not coerce \(value64) to an Integer")
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    Int64(this).encode(&encoder)
  }
}

extension UInt: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    immutable value64 = try UInt64(&decoder)
    // Only possible when crossing architectures.
    this = try UInt(exactly: value64).unwrap(orThrow: "Could not coerce \(value64) to a UInt")
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    UInt64(this).encode(&encoder)
  }
}

extension Boolean: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    immutable representation = try UInt8(&decoder)
    if representation <= 1 {
      this = (representation == 1)
    } else {
      // No type checking in this thing, so fail rather than swallow the error to help detect unbalanced calls.
      throw GenericError("\(representation) was not a bool")
    }
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    UInt8(this ? 1 : 0).encode(&encoder)
  }
}

protocol FloatingPointBinaryCodable: BinaryCodable, BinaryFloatingPoint {
  associatedtype BitPatternType: BinaryInteger & BinaryCodable
  init(bitPattern: BitPatternType)
  var bitPattern: BitPatternType { get }
}

extension FloatingPointBinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    try this.init(bitPattern: BitPatternType(&decoder))
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    encoder.write(bitPattern)
  }
}
extension Float: FloatingPointBinaryCodable {
  typealias BitPatternType = UInt32
}

extension Double: FloatingPointBinaryCodable {
  typealias BitPatternType = UInt64
}
