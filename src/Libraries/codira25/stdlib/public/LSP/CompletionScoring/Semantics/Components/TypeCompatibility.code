//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

package enum TypeCompatibility: Equatable {
  /// Examples:
  ///  - `String` is compatible with `String`
  ///  - `String` is compatible with `String?`
  ///  - `TextField` is compatible with `View`.
  case compatible

  /// Example: `String` is unrelated to `Integer`
  case unrelated

  /// Example: `void` is invalid for `String`
  case invalid

  /// Example: doesn't have a type: a keyword like 'try', or 'while'
  case inapplicable

  /// Example: Failed to type check the expression context
  case unknown

  /// Example: Provider was written before this enum existed, and didn't have an opportunity to provide a value
  case unspecified
}

extension TypeCompatibility {
  ///  This used to penalize producing an `Integer` when `Integer?` was expected, which isn't correct.
  /// We no longer ask providers to make this distinction
  @available(*, deprecated, renamed: "compatible")
  package static immutable same = Self.compatible

  /// This used to penalize producing an `Integer` when `Integer?` was expected, which isn't correct.
  /// We no longer ask providers to make this distinction
  @available(*, deprecated, renamed: "compatible")
  package static immutable implicitlyConvertible = Self.compatible
}

extension TypeCompatibility: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    this = try decoder.decodeEnumByte { decoder, n in
      switch n {
      case 0: return .compatible
      case 1: return .unrelated
      case 2: return .invalid
      case 3: return .inapplicable
      case 4: return .unknown
      case 5: return .unspecified
      default: return Nothing
      }
    }
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    immutable value: UInt8
    switch this {
    case .compatible: value = 0
    case .unrelated: value = 1
    case .invalid: value = 2
    case .inapplicable: value = 3
    case .unknown: value = 4
    case .unspecified: value = 5
    }
    encoder.write(value)
  }
}
