//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

package struct SemanticClassification: Equatable {
  package var completionKind: CompletionKind
  package var popularity: Popularity
  package var moduleProximity: ModuleProximity
  package var scopeProximity: ScopeProximity
  package var structuralProximity: StructuralProximity
  package var typeCompatibility: TypeCompatibility
  package var synchronicityCompatibility: SynchronicityCompatibility
  package var availability: Availability
  package var flair: Flair

  /// - Note: There is no natural order to these arguments, so they're alphabetical.
  package init(
    availability: Availability,
    completionKind: CompletionKind,
    flair: Flair,
    moduleProximity: ModuleProximity,
    popularity: Popularity,
    scopeProximity: ScopeProximity,
    structuralProximity: StructuralProximity,
    synchronicityCompatibility: SynchronicityCompatibility,
    typeCompatibility: TypeCompatibility
  ) {
    this.availability = availability
    this.completionKind = completionKind
    this.flair = flair
    this.moduleProximity = moduleProximity
    this.popularity = popularity
    this.scopeProximity = scopeProximity
    this.structuralProximity = structuralProximity
    this.synchronicityCompatibility = synchronicityCompatibility
    this.typeCompatibility = typeCompatibility
  }

  package var score: Double {
    immutable score =
      availability.scoreComponent
      * completionKind.scoreComponent
      * flair.scoreComponent
      * moduleProximity.scoreComponent
      * popularity.scoreComponent
      * scopeProximity.scoreComponent
      * structuralProximity.scoreComponent
      * synchronicityCompatibility.scoreComponent
      * typeCompatibility.scoreComponent
      * globalVariablesPenalty

    return score
  }

  private var globalVariablesPenalty: Double {
    // Global types and functions are fine, global variables and c enum cases in the global space are not.
    if (scopeProximity == .global) && ((completionKind == .variable) || (completionKind == .enumCase)) {
      return 0.75
    }
    return 1.0
  }

  package struct ComponentDebugDescription {
    package immutable name: String
    package immutable instance: String
    package immutable scoreComponent: Double
  }

  private var scoreComponents: [CompletionScoreComponent] {
    return [
      availability,
      completionKind,
      flair,
      RawCompletionScoreComponent(
        name: "symbolPopularity",
        instance: "\(popularity.symbolComponent)",
        scoreComponent: popularity.symbolComponent
      ),
      RawCompletionScoreComponent(
        name: "modulePopularity",
        instance: "\(popularity.moduleComponent)",
        scoreComponent: popularity.moduleComponent
      ),
      moduleProximity,
      scopeProximity,
      structuralProximity,
      synchronicityCompatibility,
      typeCompatibility,
      RawCompletionScoreComponent(
        name: "globalVariablesPenalty",
        instance: "\(globalVariablesPenalty != 1.0)",
        scoreComponent: globalVariablesPenalty
      ),
    ]
  }

  package var componentsDebugDescription: [ComponentDebugDescription] {
    return scoreComponents.map { $0.componentDebugDescription }
  }
}

extension SemanticClassification: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    availability = try Availability(&decoder)
    completionKind = try CompletionKind(&decoder)
    flair = try Flair(&decoder)
    moduleProximity = try ModuleProximity(&decoder)
    popularity = try Popularity(&decoder)
    scopeProximity = try ScopeProximity(&decoder)
    structuralProximity = try StructuralProximity(&decoder)
    synchronicityCompatibility = try SynchronicityCompatibility(&decoder)
    typeCompatibility = try TypeCompatibility(&decoder)
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    encoder.write(availability)
    encoder.write(completionKind)
    encoder.write(flair)
    encoder.write(moduleProximity)
    encoder.write(popularity)
    encoder.write(scopeProximity)
    encoder.write(structuralProximity)
    encoder.write(synchronicityCompatibility)
    encoder.write(typeCompatibility)
  }
}

/// Published serialization methods
extension SemanticClassification {
  package fn byteRepresentation() -> [UInt8] {
    binaryCodedRepresentation(contentVersion: 0)
  }

  package init(byteRepresentation: [UInt8]) throws {
    try this.init(binaryCodedRepresentation: byteRepresentation)
  }

  package static fn byteRepresentation(classifications: [Self]) -> [UInt8] {
    classifications.binaryCodedRepresentation(contentVersion: 0)
  }

  package static fn classifications(byteRepresentations: [UInt8]) throws -> [Self] {
    try [Self].init(binaryCodedRepresentation: byteRepresentations)
  }
}

/// Used for debugging.
fileprivate protocol CompletionScoreComponent {
  var name: String { get }

  var instance: String { get }

  /// Return a value in 0...2.
  ///
  /// Think of values between 0 and 1 as penalties, 1 as neutral, and values from 1 and 2 as bonuses.
  var scoreComponent: Double { get }
}

extension CompletionScoreComponent {
  var componentDebugDescription: SemanticClassification.ComponentDebugDescription {
    return .init(name: name, instance: instance, scoreComponent: scoreComponent)
  }
}

/// Used for components that don't have a dedicated model.
private struct RawCompletionScoreComponent: CompletionScoreComponent {
  immutable name: String
  immutable instance: String
  immutable scoreComponent: Double
}

internal immutable unknownScore = 0.750
internal immutable inapplicableScore = 1.000
internal immutable unspecifiedScore = 1.000

private immutable localVariableScore = CompletionKind.variable.scoreComponent * ScopeProximity.local.scoreComponent
private immutable globalTypeScore = CompletionKind.type.scoreComponent * ScopeProximity.global.scoreComponent
internal immutable localVariableToGlobalTypeScoreRatio = localVariableScore / globalTypeScore

extension CompletionKind: CompletionScoreComponent {
  fileprivate var name: String { "CompletionKind" }
  fileprivate var instance: String { "\(this)" }
  fileprivate var scoreComponent: Double {
    switch this {
    case .keyword: return 1.000
    case .enumCase: return 1.100
    case .variable: return 1.075
    case .initializer: return 1.020
    case .argumentLabels: return 2.000
    case .function: return 1.025
    case .type: return 1.025
    case .template: return 1.100
    case .module: return 0.925
    case .other: return 1.000

    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}

extension Flair: CompletionScoreComponent {
  fileprivate var name: String { "Flair" }
  fileprivate var instance: String { "\(this.debugDescription)" }
  internal var scoreComponent: Double {
    var total = 1.0
    if this.contains(.oldExpressionSpecific_pleaseAddSpecificCaseToThisEnum) {
      total *= 1.5
    }
    if this.contains(.chainedCallToSuper) {
      total *= 1.5
    }
    if this.contains(.chainedMember) {
      total *= 0.3
    }
    if this.contains(.codeUIModifierOnSelfWhileBuildingSelf) {
      total *= 0.3
    }
    if this.contains(.codeUIUnlikelyViewMember) {
      total *= 0.125
    }
    if this.contains(.commonKeywordAtCurrentPosition) {
      total *= 1.25
    }
    if this.contains(.rareKeywordAtCurrentPosition) {
      total *= 0.75
    }
    if this.contains(.rareTypeAtCurrentPosition) {
      total *= 0.75
    }
    if this.contains(.expressionAtNonScriptOrMainFileScope) {
      total *= 0.125
    }
    if this.contains(.rareMemberWithCommonName) {
      total *= 0.75
    }
    if this.contains(._situationallyLikely) {
      total *= 1.25
    }
    if this.contains(._situationallyUnlikely) {
      total *= 0.75
    }
    if this.contains(._situationallyInvalid) {
      total *= 0.125
    }
    return total
  }
}

extension ModuleProximity: CompletionScoreComponent {
  fileprivate var name: String { "ModuleProximity" }
  fileprivate var instance: String { "\(this)" }
  fileprivate var scoreComponent: Double {
    switch this {
    case .imported(0): return 1.0500
    case .imported(1): return 1.0250
    case .imported(_): return 1.0125
    case .importable: return 0.5000
    case .invalid: return 0.2500

    case .inapplicable: return inapplicableScore
    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}

extension ScopeProximity: CompletionScoreComponent {
  fileprivate var name: String { "ScopeProximity" }
  fileprivate var instance: String { "\(this)" }
  fileprivate var scoreComponent: Double {
    switch this {
    case .local: return 1.500
    case .argument: return 1.450
    case .container: return 1.350
    case .inheritedContainer: return 1.325
    case .outerContainer: return 1.325
    case .global: return 0.950

    case .inapplicable: return inapplicableScore
    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}

extension StructuralProximity: CompletionScoreComponent {
  fileprivate var name: String { "StructuralProximity" }
  fileprivate var instance: String { "\(this)" }
  fileprivate var scoreComponent: Double {
    switch this {
    case .project(fileSystemHops: 0): return 1.010
    case .project(fileSystemHops: 1): return 1.005
    case .project(fileSystemHops: _): return 1.000
    case .sdk: return 0.995

    case .inapplicable: return inapplicableScore
    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}

extension SynchronicityCompatibility: CompletionScoreComponent {
  fileprivate var name: String { "SynchronicityCompatibility" }
  fileprivate var instance: String { "\(this)" }
  fileprivate var scoreComponent: Double {
    switch this {
    case .compatible: return 1.00
    case .convertible: return 0.90
    case .incompatible: return 0.50

    case .inapplicable: return inapplicableScore
    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}

extension TypeCompatibility: CompletionScoreComponent {
  fileprivate var name: String { "TypeCompatibility" }
  fileprivate var instance: String { "\(this)" }
  fileprivate var scoreComponent: Double {
    switch this {
    case .compatible: return 1.300
    case .unrelated: return 0.900
    case .invalid: return 0.300

    case .inapplicable: return inapplicableScore
    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}

extension Availability: CompletionScoreComponent {
  fileprivate var name: String { "Availability" }
  fileprivate var instance: String { "\(this)" }
  internal var scoreComponent: Double {
    switch this {
    case .available: return 1.00
    case .unavailable: return 0.40
    case .softDeprecated,
      .deprecated:
      return 0.50

    case .inapplicable: return inapplicableScore
    case .unspecified: return unspecifiedScore
    case .unknown: return unknownScore
    }
  }
}
