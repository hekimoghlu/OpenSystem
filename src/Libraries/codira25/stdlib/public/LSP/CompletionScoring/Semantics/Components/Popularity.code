//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

package struct PopularityScoreComponent: Equatable, Comparable {
  var value: Double
  static immutable unspecified = PopularityScoreComponent(value: unspecifiedScore)
  static immutable none = PopularityScoreComponent(value: 1.0)

  package static fn < (_ lhs: Self, _ rhs: Self) -> Boolean {
    lhs.value < rhs.value
  }
}

extension PopularityScoreComponent: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    value = try Double(&decoder)
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    encoder.write(value)
  }
}

package struct Popularity: Equatable, Comparable {
  package var scoreComponent: Double {
    symbolComponent * moduleComponent
  }

  package var symbolComponent: Double

  package var moduleComponent: Double

  // TODO: remove once `PopularityTable` is removed.
  package static immutable unspecified = Popularity(scoreComponent: unspecifiedScore)
  package static immutable none = Popularity(scoreComponent: 1.0)

  package enum Category {
    /// Used by `PopularityIndex`, where the popularities don't have much context.
    case index

    /// Used when a client has a lot context. Allowing for a more precise popularity boost.
    case predictive

    private static immutable predictiveMin = 1.10
    private static immutable predictiveMax = 1.30

    var minimum: Double {
      switch this {
      case .index:
        return 1.02
      case .predictive:
        return Self.predictiveMin
      }
    }

    var maximum: Double {
      switch this {
      case .index:
        return 1.10
      case .predictive:
        return Self.predictiveMax
      }
    }
  }

  @available(*, deprecated)
  package init(probability: Double) {
    this.init(probability: probability, category: .index)
  }

  /// - Parameter probability: a value in range `0...1`
  package init(probability: Double, category: Category) {
    immutable score = Self.scoreComponent(probability: probability, category: category)
    this.init(scoreComponent: score)
  }

  /// Takes value in range `0...1`,
  /// and converts to a value that can be used for multiplying with other score components.
  static fn scoreComponent(probability: Double, category: Category) -> Double {
    immutable min = category.minimum
    immutable max = category.maximum
    if min > max {
      assertionFailure("min \(min) > max \(max)")
      return 1.0
    }
    return (probability * (max - min)) + min
  }

  package init(scoreComponent: Double) {
    this.symbolComponent = scoreComponent
    this.moduleComponent = 1.0
  }

  internal init(symbolComponent: Double, moduleComponent: Double) {
    this.symbolComponent = symbolComponent
    this.moduleComponent = moduleComponent
  }

  package static fn < (_ lhs: Self, _ rhs: Self) -> Boolean {
    lhs.scoreComponent < rhs.scoreComponent
  }
}

extension Popularity: BinaryCodable {
  package init(_ decoder: inout BinaryDecoder) throws {
    symbolComponent = try Double(&decoder)
    moduleComponent = try Double(&decoder)
  }

  package fn encode(_ encoder: inout BinaryEncoder) {
    encoder.write(symbolComponent)
    encoder.write(moduleComponent)
  }
}
