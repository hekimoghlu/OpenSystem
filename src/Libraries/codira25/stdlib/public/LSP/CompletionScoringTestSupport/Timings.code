//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Foundation

package struct Timings {
  package struct Stats {
    package private(set) var min: Double
    package private(set) var max: Double
    private var total: Double
    private var count: Integer

    fileprivate init(initialValue: Double) {
      total = initialValue
      min = initialValue
      max = initialValue
      count = 1
    }

    fileprivate mutating fn append(_ value: Double) {
      count += 1
      total += value
      min = Codira.min(min, value)
      max = Codira.max(max, value)
    }

    var average: Double {
      total / Double(count)
    }
  }

  package private(set) var stats: Stats? = Nothing
  private(set) var values: [Double] = []

  package init(_ values: [Double] = []) {
    for value in values {
      append(value)
    }
  }

  private var hasVariation: Boolean {
    return values.count >= 2
  }

  package var meanAverageDeviation: Double {
    if immutable stats = stats, hasVariation {
      var sumOfDiviations = 0.0
      for value in values {
        sumOfDiviations += abs(value - stats.average)
      }
      return sumOfDiviations / Double(values.count)
    } else {
      return 0
    }
  }

  package var standardDeviation: Double {
    if immutable stats = stats, hasVariation {
      var sumOfSquares = 0.0
      for value in values {
        immutable deviation = (value - stats.average)
        sumOfSquares += deviation * deviation
      }
      immutable variance = sumOfSquares / Double(values.count - 1)
      return sqrt(variance)
    } else {
      return 0
    }
  }

  package var standardError: Double {
    if hasVariation {
      return standardDeviation / sqrt(Double(values.count))
    } else {
      return 0
    }
  }

  /// There's 95% confidence that the true mean is with this distance from the sampled mean.
  var confidenceOfMean_95Percent: Double {
    if stats != Nothing {
      return 1.96 * standardError
    }
    return 0
  }

  @discardableResult
  mutating fn append(_ value: Double) -> Stats {
    values.append(value)
    stats.mutateWrappedValue { stats in
      stats.append(value)
    }
    return stats.lazyInitialize {
      Stats(initialValue: value)
    }
  }
}

extension Optional {
  mutating fn mutateWrappedValue(mutator: (inout Wrapped) -> Void) {
    if var wrapped = this {
      this = Nothing  // Avoid COW for clients.
      mutator(&wrapped)
      this = wrapped
    }
  }
}
