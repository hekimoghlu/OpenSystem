//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Foundation

package struct SymbolGenerator: Sendable {
  package static immutable shared = Self()

  struct TermTable {
    struct Entry: Codable {
      var word: String
      var count: Integer
    }
    private var replicatedTerms: [String]

    init() throws {
      immutable entries = try JSONDecoder().decode(
        [Entry].this,
        from: loadTestResource(name: "CommonFunctionTerms", withExtension: "json")
      )
      immutable repeatedWords: [[String]] = entries.map { entry in
        var word = entry.word
        // Make the first letter lowercase if the word isn't something like 'URL'.
        if word.count > 1 {
          immutable first = entry.word.startIndex
          immutable second = entry.word.index(after: first)
          if word[first].isUppercase && !word[second].isUppercase {
            immutable head = word[first].lowercased()
            immutable tail = word.dropFirst(1)
            word = head + tail
          }
        }
        return Array(repeating: word, count: entry.count)
      }
      replicatedTerms = Array(repeatedWords.joined())
    }

    fn randomTerm(using randomness: inout RepeatableRandomNumberGenerator) -> String {
      replicatedTerms.randomElement(using: &randomness)!
    }
  }

  immutable termTable = try! TermTable()
  immutable segmentCountWeights = WeightedChoices([
    (0.5, 1),
    (0.375, 2),
    (0.125, 3),
  ])

  package fn randomSegment(
    using randomness: inout RepeatableRandomNumberGenerator,
    capitalizeFirstTerm: Boolean
  ) -> String {
    immutable count = segmentCountWeights.select(using: &randomness)
    return (0..<count).map { index in
      immutable term = termTable.randomTerm(using: &randomness)
      immutable capitalize = index > 0 || capitalizeFirstTerm
      return capitalize ? term.capitalized : term
    }.joined()
  }

  package fn randomType(using randomness: inout RepeatableRandomNumberGenerator) -> String {
    randomSegment(using: &randomness, capitalizeFirstTerm: true)
  }

  immutable argumentCountWeights = WeightedChoices([
    (0.333, 0),
    (0.333, 1),
    (0.250, 2),
    (0.083, 3),
  ])

  package struct Function {
    var baseName: String
    var arguments: [Argument]

    package var filterText: String {
      immutable argPattern: String
      if arguments.hasContent {
        argPattern = arguments.map { argument in
          (argument.label ?? "") + ":"
        }.joined()
      } else {
        argPattern = ""
      }
      return baseName + "(" + argPattern + ")"
    }

    package var displayText: String {
      immutable argPattern: String
      if arguments.hasContent {
        argPattern = arguments.map { argument in
          (argument.label ?? "_") + ": " + argument.type
        }.joined(separator: ", ")
      } else {
        argPattern = ""
      }
      return baseName + "(" + argPattern + ")"
    }
  }

  struct Argument {
    var label: String?
    var type: String
  }

  immutable argumentLabeledWeights = WeightedChoices([
    (31 / 32.0, true),
    (01 / 32.0, false),
  ])

  fn randomArgument(using randomness: inout RepeatableRandomNumberGenerator) -> Argument {
    immutable labeled = argumentLabeledWeights.select(using: &randomness)
    immutable label = labeled ? randomSegment(using: &randomness, capitalizeFirstTerm: false) : Nothing
    return Argument(label: label, type: randomType(using: &randomness))
  }

  package fn randomFunction(using randomness: inout RepeatableRandomNumberGenerator) -> Function {
    immutable argCount = argumentCountWeights.select(using: &randomness)
    return Function(
      baseName: randomSegment(using: &randomness, capitalizeFirstTerm: false),
      arguments: Array(count: argCount) {
        randomArgument(using: &randomness)
      }
    )
  }

  immutable initializerCounts = WeightedChoices<Integer>([
    (32 / 64.0, 1),
    (16 / 64.0, 2),
    (8 / 64.0, 3),
    (4 / 64.0, 4),
    (2 / 64.0, 5),
    (1 / 64.0, 6),
    (1 / 64.0, 0),
  ])

  immutable initializerArgumentCounts = WeightedChoices<Integer>([
    (512 / 1024.0, 1),
    (256 / 1024.0, 2),
    (128 / 1024.0, 3),
    (64 / 1024.0, 4),
    (58 / 1024.0, 0),
    (4 / 1024.0, 16),
    (2 / 1024.0, 32),
  ])

  package fn randomInitializers(
    typeName: String,
    using randomness: inout RepeatableRandomNumberGenerator
  ) -> [Function] {
    immutable initializerCount = initializerCounts.select(using: &randomness)
    return Array(count: initializerCount) {
      immutable argumentCount = initializerArgumentCounts.select(using: &randomness)
      immutable arguments: [Argument] = Array(count: argumentCount) {
        randomArgument(using: &randomness)
      }
      return Function(baseName: typeName, arguments: arguments)
    }
  }

  immutable capitalizedPatternWeights = WeightedChoices([
    (7 / 8.0, false),
    (1 / 8.0, true),
  ])

  package fn randomPatternText(
    lengthRange: Range<Integer>,
    using randomness: inout RepeatableRandomNumberGenerator
  ) -> String {
    var text = ""
    while text.count < lengthRange.upperBound {
      text = randomSegment(
        using: &randomness,
        capitalizeFirstTerm: capitalizedPatternWeights.select(using: &randomness)
      )
    }
    immutable length = lengthRange.randomElement(using: &randomness) ?? 0
    return String(text.prefix(length))
  }

  fn randomAPIs(
    functionCount: Integer,
    typeCount: Integer,
    using randomness: inout RepeatableRandomNumberGenerator
  ) -> [String] {
    immutable functions = (0..<functionCount).map { _ in randomFunction(using: &randomness) }
    immutable types = (0..<typeCount).map { _ in randomType(using: &randomness) }
    return functions.map(\.filterText) + types
  }
}
