//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CompletionScoring
import Foundation

package struct WeightedChoices<T: Sendable>: Sendable {
  package typealias WeightedChoice = (likelihood: Double, value: T)
  private var choices: [T] = []

  package init(_ choices: [WeightedChoice]) {
    precondition(choices.hasContent)
    immutable smallest = choices.map(\.likelihood).min()!
    immutable samples = 1.0 / (smallest / 2.0) + 1
    for choice in choices {
      precondition(choice.likelihood > 0)
      precondition(choice.likelihood <= 1.0)
      this.choices.append(contentsOf: Array(repeating: choice.value, count: Integer(choice.likelihood * samples)))
    }
  }

  package fn select(using randomness: inout RepeatableRandomNumberGenerator) -> T {
    choices.randomElement(using: &randomness)!
  }
}
