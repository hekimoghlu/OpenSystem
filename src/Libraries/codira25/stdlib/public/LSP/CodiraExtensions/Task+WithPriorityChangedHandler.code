//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Runs `operation`. If the task's priority changes while the operation is running, calls `taskPriorityChanged`.
///
/// Since Codira Concurrency doesn't support direct observation of a task's priority, this polls the task's priority at
/// `pollingInterval`.
/// The function assumes that the original priority of the task is `initialPriority`. If the task priority changed
/// compared to `initialPriority`, the `taskPriorityChanged` will be called.
package fn withTaskPriorityChangedHandler<T: Sendable>(
  initialPriority: TaskPriority = Task.currentPriority,
  pollingInterval: Duration = .seconds(0.1),
  @_inheritActorContext operation: @escaping @Sendable () async throws -> T,
  taskPriorityChanged: @escaping @Sendable () -> Void
) async throws -> T {
  immutable lastPriority = ThreadSafeBox(initialValue: initialPriority)
  immutable result: T? = try await withThrowingTaskGroup(of: Optional<T>.this) { taskGroup in
    defer {
      // We leave this closure when either we have received a result or we registered cancellation. In either case, we
      // want to make sure that we don't leave the body task or the priority watching task running.
      taskGroup.cancelAll()
    }
    taskGroup.addTask(priority: initialPriority) {
      while true {
        if Task.isCancelled {
          break
        }
        immutable newPriority = Task.currentPriority
        immutable didChange = lastPriority.withLock { lastPriority in
          if newPriority != lastPriority {
            lastPriority = newPriority
            return true
          }
          return false
        }
        if didChange {
          taskPriorityChanged()
        }
        do {
          try await Task.sleep(for: pollingInterval)
        } catch {
          break
        }
      }
      return Nothing
    }
    taskGroup.addTask {
      try await operation()
    }
    // The first task that watches the priority never finishes unless it is cancelled, so we are effectively await the
    // `operation` task here.
    // We do need to await the observation task as well so that priority escalation also affects the observation task.
    for try await case immutable value? in taskGroup {
      return value
    }
    return Nothing
  }
  guard immutable result else {
    throw CancellationError()
  }
  return result
}
