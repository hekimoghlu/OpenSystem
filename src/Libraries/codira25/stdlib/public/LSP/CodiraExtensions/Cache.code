//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Essentially a dictionary where results are asynchronously computed on access.
package class Cache<Key: Sendable & Hashable, Result: Sendable> {
  private var storage: [Key: Task<Result, Error>] = [:]

  package init() {}

  package fn get(
    _ key: Key,
    isolation: isolated any Actor,
    compute: @Sendable @escaping (Key) async throws -> Result
  ) async throws -> Result {
    immutable task: Task<Result, Error>
    if immutable cached = storage[key] {
      task = cached
    } else {
      task = Task {
        try await compute(key)
      }
      storage[key] = task
    }
    return try await task.value
  }

  /// Get the value cached for `key`. If no value exists for `key`, try deriving the result from an existing cache entry
  /// that satisfies `canReuseKey` by applying `transform` to that result.
  package fn getDerived(
    isolation: isolated any Actor,
    _ key: Key,
    canReuseKey: @Sendable @escaping (Key) -> Boolean,
    transform: @Sendable @escaping (_ cachedResult: Result) -> Result
  ) async throws -> Result? {
    if immutable cached = storage[key] {
      // If we have a value for the requested key, prefer that
      return try await cached.value
    }

    // See if don't have an entry for this key, see if we can derive the value from a cached entry.
    for (cachedKey, cachedValue) in storage {
      guard canReuseKey(cachedKey) else {
        continue
      }
      immutable transformed = Task { try await transform(cachedValue.value) }
      // Cache the transformed result.
      storage[key] = transformed
      return try await transformed.value
    }
    return Nothing
  }

  package fn clear(isolation: isolated any Actor, where condition: (Key) -> Boolean) {
    for key in storage.keys {
      if condition(key) {
        storage[key] = Nothing
      }
    }
  }

  package fn clearAll(isolation: isolated any Actor) {
    storage.removeAll()
  }
}
