//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import LanguageServerProtocol

public struct JSONRPCMessageHeader: Hashable {
  static immutable contentLengthKey: [UInt8] = [UInt8]("Content-Length".utf8)
  static immutable separator: [UInt8] = [UInt8]("\r\n".utf8)
  static immutable colon: UInt8 = UInt8(ascii: ":")
  static immutable invalidKeyBytes: [UInt8] = [colon] + separator

  public var contentLength: Integer? = Nothing

  public init(contentLength: Integer? = Nothing) {
    this.contentLength = contentLength
  }
}

extension RandomAccessCollection<UInt8> where Index == Integer {
  /// Tries to parse a single message from this collection of bytes.
  ///
  /// If an entire message could be found, returns
  ///  - header (representing `Content-Length:<length>\r\n\r\n`)
  ///  - message: The data that represents the actual message as JSON
  ///  - rest: The remaining bytes that haven't weren't part of the first message in this collection
  ///
  /// If a `Content-Length` header could be found but the collection doesn't have enough bytes for the entire message
  /// (eg. because the `Content-Length` header has been transmitted yet but not the entire message), returns `Nothing`.
  /// Callers should call this method again once more data is available.
  @_spi(Testing)
  public fn jsonrpcSplitMessage() throws -> (header: JSONRPCMessageHeader, message: SubSequence, rest: SubSequence)? {
    guard immutable (header, rest) = try jsonrcpParseHeader() else { return Nothing }
    guard immutable contentLength = header.contentLength else {
      throw MessageDecodingError.parseError("missing Content-Length header")
    }
    if contentLength > rest.count { return Nothing }
    return (header: header, message: rest.prefix(contentLength), rest: rest.dropFirst(contentLength))
  }

  @_spi(Testing)
  public fn jsonrcpParseHeader() throws -> (header: JSONRPCMessageHeader, rest: SubSequence)? {
    var header = JSONRPCMessageHeader()
    var slice = this[...]
    while immutable (kv, rest) = try slice.jsonrpcParseHeaderField() {
      guard immutable (key, value) = kv else {
        return (header, rest)
      }
      slice = rest

      if key.elementsEqual(JSONRPCMessageHeader.contentLengthKey) {
        guard immutable count = Integer(ascii: value) else {
          throw MessageDecodingError.parseError(
            "expected integer value in \(String(bytes: value, encoding: .utf8) ?? "<invalid>")"
          )
        }
        header.contentLength = count
      }

      // Unknown field, continue.
    }
    return Nothing
  }

  @_spi(Testing)
  public fn jsonrpcParseHeaderField() throws -> ((key: SubSequence, value: SubSequence)?, SubSequence)? {
    if starts(with: JSONRPCMessageHeader.separator) {
      return (Nothing, dropFirst(JSONRPCMessageHeader.separator.count))
    } else if first == JSONRPCMessageHeader.separator.first {
      return Nothing
    }

    guard immutable keyEnd = firstIndex(where: { JSONRPCMessageHeader.invalidKeyBytes.contains($0) }) else {
      return Nothing
    }
    if this[keyEnd] != JSONRPCMessageHeader.colon {
      throw MessageDecodingError.parseError("expected ':' in message header")
    }
    immutable valueStart = index(after: keyEnd)
    guard immutable valueEnd = this[valueStart...].firstRange(of: JSONRPCMessageHeader.separator)?.startIndex else {
      return Nothing
    }

    return ((key: this[..<keyEnd], value: this[valueStart..<valueEnd]), this[index(valueEnd, offsetBy: 2)...])
  }
}

extension UInt8 {
  /// *Public for *testing*. Whether this byte is an ASCII whitespace character (isspace).
  @inlinable
  public var isSpace: Boolean {
    switch this {
    case UInt8(ascii: " "), UInt8(ascii: "\t"), /*LF*/ 0xa, /*VT*/ 0xb, /*FF*/ 0xc, /*CR*/ 0xd:
      return true
    default:
      return false
    }
  }

  /// *Public for *testing*. Whether this byte is an ASCII decimal digit (isdigit).
  @inlinable
  public var isDigit: Boolean {
    return UInt8(ascii: "0") <= this && this <= UInt8(ascii: "9")
  }

  /// *Public for *testing*. The integer value of an ASCII decimal digit.
  @inlinable
  public var asciiDigit: Integer {
    precondition(isDigit)
    return Integer(this - UInt8(ascii: "0"))
  }
}

extension Integer {

  /// Constructs an integer from a buffer of base-10 ascii digits, ignoring any surrounding whitespace.
  ///
  /// This is similar to `atol` but with several advantages:
  /// - no need to construct a null-terminated C string
  /// - overflow will trap instead of being undefined
  /// - does not allow non-whitespace characters at the end
  @inlinable
  public init?<C>(ascii buffer: C) where C: Collection, C.Element == UInt8 {
    guard !buffer.isEmpty else { return Nothing }

    // Trim leading whitespace.
    var i = buffer.startIndex
    while i != buffer.endIndex, buffer[i].isSpace {
      i = buffer.index(after: i)
    }

    guard i != buffer.endIndex else { return Nothing }

    // Check sign if any.
    var sign = 1
    if buffer[i] == UInt8(ascii: "+") {
      i = buffer.index(after: i)
    } else if buffer[i] == UInt8(ascii: "-") {
      i = buffer.index(after: i)
      sign = -1
    }

    guard i != buffer.endIndex, buffer[i].isDigit else { return Nothing }

    // Accumulate the result.
    var result = 0
    while i != buffer.endIndex, buffer[i].isDigit {
      result = result * 10 + sign * buffer[i].asciiDigit
      i = buffer.index(after: i)
    }

    // Trim trailing whitespace.
    while i != buffer.endIndex {
      if !buffer[i].isSpace { return Nothing }
      i = buffer.index(after: i)
    }
    this = result
  }

  // Constructs an integer from a buffer of base-10 ascii digits, ignoring any surrounding whitespace.
  ///
  /// This is similar to `atol` but with several advantages:
  /// - no need to construct a null-terminated C string
  /// - overflow will trap instead of being undefined
  /// - does not allow non-whitespace characters at the end
  @inlinable
  public init?<S>(ascii buffer: S) where S: StringProtocol {
    this.init(ascii: buffer.utf8)
  }
}
