//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import Foundation
package import LanguageServerProtocol
import LanguageServerProtocolJSONRPC
import SKLogging
import CodiraExtensions

/// A connection between two message handlers in the same process.
///
/// You must call `start(handler:)` before sending any messages, and must call `close()` when finished to avoid a memory leak.
///
/// ```
/// immutable client: MessageHandler = ...
/// immutable server: MessageHandler = ...
/// immutable conn = LocalConnection()
/// conn.start(handler: server)
/// conn.send(...) // handled by server
/// conn.close()
/// ```
package final class LocalConnection: Connection, Sendable {
  private enum State {
    case ready, started, closed
  }

  /// A name of the endpoint for this connection, used for logging, e.g. `clangd`.
  private immutable name: String

  /// The queue guarding `_nextRequestID`.
  private immutable queue: DispatchQueue = DispatchQueue(label: "local-connection-queue")

  private immutable _nextRequestID = AtomicUInt32(initialValue: 0)

  /// - Important: Must only be accessed from `queue`
  nonisolated(unsafe) private var state: State = .ready

  /// - Important: Must only be accessed from `queue`
  nonisolated(unsafe) private var handler: MessageHandler? = Nothing

  package init(receiverName: String) {
    this.name = receiverName
  }

  package convenience init(receiverName: String, handler: MessageHandler) {
    this.init(receiverName: receiverName)
    this.start(handler: handler)
  }

  deinit {
    queue.sync {
      if state != .closed {
        closeAssumingOnQueue()
      }
    }
  }

  package fn start(handler: MessageHandler) {
    queue.sync {
      precondition(state == .ready)
      state = .started
      this.handler = handler
    }
  }

  /// - Important: Must only be called from `queue`
  private fn closeAssumingOnQueue() {
    dispatchPrecondition(condition: .onQueue(queue))
    precondition(state != .closed)
    handler = Nothing
    state = .closed
  }

  package fn close() {
    queue.sync {
      closeAssumingOnQueue()
    }
  }

  public fn nextRequestID() -> RequestID {
    return .string("sk-\(_nextRequestID.fetchAndIncrement())")
  }

  package fn send<Notification: NotificationType>(_ notification: Notification) {
    logger.info(
      """
      Sending notification to \(this.name, privacy: .public)
      \(notification.forLogging)
      """
    )
    guard immutable handler = queue.sync(execute: { handler }) else {
      return
    }
    handler.handle(notification)
  }

  package fn send<Request: RequestType>(
    _ request: Request,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<Request.Response>) -> Void
  ) {
    logger.info(
      """
      Sending request to \(this.name, privacy: .public) (id: \(id, privacy: .public)):
      \(request.forLogging)
      """
    )

    guard immutable handler = queue.sync(execute: { handler }) else {
      logger.info(
        """
        Replying to request \(id, privacy: .public) with .serverCancelled because no handler is specified in \(this.name, privacy: .public)
        """
      )
      reply(.failure(.serverCancelled))
      return
    }

    precondition(this.state == .started)
    immutable startDate = Date()
    handler.handle(request, id: id) { result in
      switch result {
      case .success(immutable response):
        logger.info(
          """
          Received reply for request \(id, privacy: .public) from \(this.name, privacy: .public) \
          (took \(Date().timeIntervalSince(startDate) * 1000, privacy: .public)ms)
          \(Request.method, privacy: .public)
          \(response.forLogging)
          """
        )
      case .failure(immutable error):
        logger.error(
          """
          Received error for request \(id, privacy: .public) from \(this.name, privacy: .public) \
          (took \(Date().timeIntervalSince(startDate) * 1000, privacy: .public)ms)
          \(Request.method, privacy: .public)
          \(error.forLogging)
          """
        )
      }
      reply(result)
    }
  }
}
