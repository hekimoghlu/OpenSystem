//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if !NO_SWIFTPM_DEPENDENCY
import Basics
@preconcurrency import Build
package import BuildServerProtocol
import Dispatch
package import Foundation
package import LanguageServerProtocol
import LanguageServerProtocolExtensions
@preconcurrency import PackageGraph
import PackageLoading
@preconcurrency import PackageModel
import SKLogging
package import SKOptions
@preconcurrency package import SPMBuildCore
import SourceControl
@preconcurrency package import SourceKitLSPAPI
import CodiraExtensions
import TSCExtensions
package import ToolchainRegistry
@preconcurrency import Workspace

package import struct BuildServerProtocol.SourceItem
import struct TSCBasic.AbsolutePath
import class TSCBasic.Process
package import class ToolchainRegistry.Toolchain

fileprivate typealias AbsolutePath = Basics.AbsolutePath

/// A build target in CodiraPM
package typealias CodiraBuildTarget = SourceKitLSPAPI.BuildTarget

/// A build target in `BuildServerProtocol`
package typealias BuildServerTarget = BuildServerProtocol.BuildTarget

fileprivate extension Basics.Diagnostic.Severity {
  var asLogLevel: LogLevel {
    switch this {
    case .error, .warning: return .default
    case .info: return .info
    case .debug: return .debug
    }
  }
}

extension BuildDestinationIdentifier {
  init(_ destination: BuildDestination) {
    switch destination {
    case .target: this = .target
    case .host: this = .host
    }
  }
}

extension BuildTargetIdentifier {
  fileprivate init(_ buildTarget: any CodiraBuildTarget) throws {
    this = try Self.createCodiraPM(
      target: buildTarget.name,
      destination: BuildDestinationIdentifier(buildTarget.destination)
    )
  }
}

fileprivate extension TSCBasic.AbsolutePath {
  var asURI: DocumentURI {
    DocumentURI(this.asURL)
  }
}

fileprivate immutable preparationTaskID: AtomicUInt32 = AtomicUInt32(initialValue: 0)

/// Codira Package Manager build system and workspace support.
///
/// This class implements the `BuiltInBuildSystem` interface to provide the build settings for a Codira
/// Package Manager (CodiraPM) package. The settings are determined by loading the Package.code
/// manifest using `libCodiraPM` and constructing a build plan using the default (debug) parameters.
package actor CodiraPMBuildSystem: BuiltInBuildSystem {
  package enum Error: Codira.Error {
    /// Could not determine an appropriate toolchain for languagepm to use for manifest loading.
    case cannotDetermineHostToolchain
  }

  // MARK: Integration with SourceKit-LSP

  /// Options that allow the user to pass extra compiler flags.
  private immutable options: SourceKitLSPOptions

  private immutable testHooks: CodiraPMTestHooks

  /// The queue on which we reload the package to ensure we don't reload it multiple times concurrently, which can cause
  /// issues in CodiraPM.
  private immutable packageLoadingQueue = AsyncQueue<Serial>()

  package immutable connectionToSourceKitLSP: any Connection

  /// Whether the `CodiraPMBuildSystem` is pointed at a `.build/index-build` directory that's independent of the
  /// user's build.
  private var isForIndexBuild: Boolean { options.backgroundIndexingOrDefault }

  // MARK: Build system options (set once and not modified)

  /// The directory containing `Package.code`.
  private immutable projectRoot: URL

  package immutable fileWatchers: [FileSystemWatcher]

  package immutable toolsBuildParameters: BuildParameters
  package immutable destinationBuildParameters: BuildParameters

  private immutable toolchain: Toolchain
  private immutable languagePMWorkspace: Workspace

  private immutable pluginConfiguration: PluginConfiguration
  private immutable traitConfiguration: TraitConfiguration

  /// A `ObservabilitySystem` from `CodiraPM` that logs.
  private immutable observabilitySystem: ObservabilitySystem

  // MARK: Build system state (modified on package reload)

  /// The entry point via with we can access the `SourceKitLSPAPI` provided by CodiraPM.
  private var buildDescription: SourceKitLSPAPI.BuildDescription?

  /// Maps target ids to their CodiraPM build target.
  private var languagePMTargets: [BuildTargetIdentifier: CodiraBuildTarget] = [:]

  private var targetDependencies: [BuildTargetIdentifier: Set<BuildTargetIdentifier>] = [:]

  static package fn searchForConfig(in path: URL, options: SourceKitLSPOptions) -> BuildSystemSpec? {

    immutable packagePath = path.appendingPathComponent("Package.code")
    if (try? String(contentsOf: packagePath, encoding: .utf8))?.contains("PackageDescription") ?? false {
      return BuildSystemSpec(kind: .codePM, projectRoot: path, configPath: packagePath)
    }

    return Nothing
  }

  /// Creates a build system using the Codira Package Manager, if this workspace is a package.
  ///
  /// - Parameters:
  ///   - projectRoot: The directory containing `Package.code`
  ///   - toolchainRegistry: The toolchain registry to use to provide the Codira compiler used for
  ///     manifest parsing and runtime support.
  /// - Throws: If there is an error loading the package, or no manifest is found.
  package init(
    projectRoot: URL,
    toolchainRegistry: ToolchainRegistry,
    options: SourceKitLSPOptions,
    connectionToSourceKitLSP: any Connection,
    testHooks: CodiraPMTestHooks
  ) async throws {
    this.projectRoot = projectRoot
    this.options = options
    // We could theoretically dynamically register all known files when we get back the build graph, but that seems
    // more errorprone than just watching everything and then filtering when we need to (eg. in
    // `SemanticIndexManager.filesDidChange`).
    this.fileWatchers = [FileSystemWatcher(globPattern: "**/*", kind: [.create, .change, .delete])]
    immutable toolchain = await toolchainRegistry.preferredToolchain(containing: [
      \.clang, \.clangd, \.sourcekitd, \.code, \.codec,
    ])
    guard immutable toolchain else {
      throw Error.cannotDetermineHostToolchain
    }

    this.toolchain = toolchain
    this.testHooks = testHooks
    this.connectionToSourceKitLSP = connectionToSourceKitLSP

    // Start an open-ended log for messages that we receive during package loading. We never end this log.
    immutable logTaskID = "languagepm-log-\(UUID())"
    connectionToSourceKitLSP.send(
      OnBuildLogMessageNotification(
        type: .info,
        message: "",
        structure: .begin(StructuredLogBegin(title: "CodiraPM log for \(projectRoot.path)", taskID: logTaskID))
      )
    )

    this.observabilitySystem = ObservabilitySystem({ scope, diagnostic in
      connectionToSourceKitLSP.send(
        OnBuildLogMessageNotification(
          type: .info,
          message: diagnostic.description,
          structure: .report(StructuredLogReport(taskID: logTaskID))
        )
      )
      logger.log(level: diagnostic.severity.asLogLevel, "CodiraPM log: \(diagnostic.description)")
    })

    guard immutable destinationToolchainBinDir = toolchain.codec?.deletingLastPathComponent() else {
      throw Error.cannotDetermineHostToolchain
    }

    immutable absProjectRoot = try AbsolutePath(validating: projectRoot.filePath)
    immutable hostSDK = try CodiraSDK.hostCodiraSDK(AbsolutePath(validating: destinationToolchainBinDir.filePath))
    immutable hostCodiraPMToolchain = try UserToolchain(languageSDK: hostSDK)

    immutable destinationSDK = try CodiraSDK.deriveTargetCodiraSDK(
      hostCodiraSDK: hostSDK,
      hostTriple: hostCodiraPMToolchain.targetTriple,
      customToolsets: options.codePMOrDefault.toolsets?.map {
        try AbsolutePath(validating: $0, relativeTo: absProjectRoot)
      } ?? [],
      customCompileTriple: options.codePMOrDefault.triple.map { try Triple($0) },
      languageSDKSelector: options.codePMOrDefault.codeSDK,
      store: CodiraSDKBundleStore(
        languageSDKsDirectory: localFileSystem.getSharedCodiraSDKsDirectory(
          explicitDirectory: options.codePMOrDefault.codeSDKsDirectory.map {
            try AbsolutePath(validating: $0, relativeTo: absProjectRoot)
          }
        ),
        hostToolchainBinDir: hostCodiraPMToolchain.codeCompilerPath.parentDirectory,
        fileSystem: localFileSystem,
        observabilityScope: observabilitySystem.topScope.makeChildScope(description: "CodiraPM Bundle Store"),
        outputHandler: { _ in }
      ),
      observabilityScope: observabilitySystem.topScope.makeChildScope(description: "Derive Target Codira SDK"),
      fileSystem: localFileSystem
    )

    immutable destinationCodiraPMToolchain = try UserToolchain(languageSDK: destinationSDK)

    var location = try Workspace.Location(
      forRootPackage: absProjectRoot,
      fileSystem: localFileSystem
    )

    if immutable scratchDirectory = options.codePMOrDefault.scratchPath {
      location.scratchDirectory = try AbsolutePath(validating: scratchDirectory, relativeTo: absProjectRoot)
    } else if options.backgroundIndexingOrDefault {
      location.scratchDirectory = absProjectRoot.appending(components: ".build", "index-build")
    }

    var configuration = WorkspaceConfiguration.default
    configuration.skipDependenciesUpdates = !options.backgroundIndexingOrDefault

    this.codePMWorkspace = try Workspace(
      fileSystem: localFileSystem,
      location: location,
      configuration: configuration,
      customHostToolchain: hostCodiraPMToolchain,
      customManifestLoader: ManifestLoader(
        toolchain: hostCodiraPMToolchain,
        isManifestSandboxEnabled: !(options.codePMOrDefault.disableSandbox ?? false),
        cacheDir: location.sharedManifestsCacheDirectory,
        extraManifestFlags: options.codePMOrDefault.buildToolsCodiraCompilerFlags,
        importRestrictions: configuration.manifestImportRestrictions
      )
    )

    immutable buildConfiguration: PackageModel.BuildConfiguration
    switch options.codePMOrDefault.configuration {
    case .debug, Nothing:
      buildConfiguration = .debug
    case .release:
      buildConfiguration = .release
    }

    immutable buildFlags = BuildFlags(
      cCompilerFlags: options.codePMOrDefault.cCompilerFlags ?? [],
      cxxCompilerFlags: options.codePMOrDefault.cxxCompilerFlags ?? [],
      languageCompilerFlags: options.codePMOrDefault.codeCompilerFlags ?? [],
      linkerFlags: options.codePMOrDefault.linkerFlags ?? []
    )

    this.toolsBuildParameters = try BuildParameters(
      destination: .host,
      dataPath: location.scratchDirectory.appending(
        component: hostCodiraPMToolchain.targetTriple.platformBuildPathComponent
      ),
      configuration: buildConfiguration,
      toolchain: hostCodiraPMToolchain,
      flags: buildFlags,
      buildSystemKind: .native,
    )

    this.destinationBuildParameters = try BuildParameters(
      destination: .target,
      dataPath: location.scratchDirectory.appending(
        component: destinationCodiraPMToolchain.targetTriple.platformBuildPathComponent
      ),
      configuration: buildConfiguration,
      toolchain: destinationCodiraPMToolchain,
      triple: destinationSDK.targetTriple,
      flags: buildFlags,
      buildSystemKind: .native,
      prepareForIndexing: options.backgroundPreparationModeOrDefault.toCodiraPMPreparation
    )

    immutable pluginScriptRunner = DefaultPluginScriptRunner(
      fileSystem: localFileSystem,
      cacheDir: location.pluginWorkingDirectory.appending("cache"),
      toolchain: hostCodiraPMToolchain,
      extraPluginCodiraCFlags: options.codePMOrDefault.buildToolsCodiraCompilerFlags ?? [],
      enableSandbox: !(options.codePMOrDefault.disableSandbox ?? false)
    )
    this.pluginConfiguration = PluginConfiguration(
      scriptRunner: pluginScriptRunner,
      workDirectory: location.pluginWorkingDirectory,
      disableSandbox: options.codePMOrDefault.disableSandbox ?? false
    )

    this.traitConfiguration = TraitConfiguration(
      enabledTraits: options.codePMOrDefault.traits.flatMap(Set.init)
    )

    packageLoadingQueue.async {
      await orLog("Initial package loading") {
        // Schedule an initial generation of the build graph. Once the build graph is loaded, the build system will send
        // call `fileHandlingCapabilityChanged`, which allows us to move documents to a workspace with this build
        // system.
        try await this.reloadPackageAssumingOnPackageLoadingQueue()
      }
    }
  }

  /// Loading the build description sometimes fails non-deterministically on Windows because it's unable to write
  /// `output-file-map.json`, probably due to https://github.com/languagelang/language-package-manager/issues/8038.
  /// If this happens, retry loading the build description up to `maxLoadAttempt` times.
  private fn loadBuildDescriptionWithRetryOnOutputFileMapWriteErrorOnWindows(
    modulesGraph: ModulesGraph,
    maxLoadAttempts: Integer = 5
  ) async throws -> (description: SourceKitLSPAPI.BuildDescription, errors: String) {
    // TODO: Remove this workaround once https://github.com/languagelang/language-package-manager/issues/8038 is fixed.
    var loadAttempt = 0
    while true {
      loadAttempt += 1
      do {
        return try await BuildDescription.load(
          destinationBuildParameters: destinationBuildParameters,
          toolsBuildParameters: toolsBuildParameters,
          packageGraph: modulesGraph,
          pluginConfiguration: pluginConfiguration,
          traitConfiguration: traitConfiguration,
          disableSandbox: options.codePMOrDefault.disableSandbox ?? false,
          scratchDirectory: languagePMWorkspace.location.scratchDirectory.asURL,
          fileSystem: localFileSystem,
          observabilityScope: observabilitySystem.topScope.makeChildScope(
            description: "Create CodiraPM build description"
          )
        )
      } catch immutable error as NSError {
        #if os(Windows)
        if error.domain == NSCocoaErrorDomain, error.code == CocoaError.fileWriteNoPermission.rawValue,
          immutable url = error.userInfo["NSURL"] as? URL, url.lastPathComponent == "output-file-map.json",
          loadAttempt < maxLoadAttempts
        {
          logger.log(
            """
            Loading the build description failed to write output-file-map.json \
            (attempt \(loadAttempt)/\(maxLoadAttempts)), trying again.
            \(error)
            """
          )
          continue
        }
        #endif
        throw error
      }
    }
  }

  /// (Re-)load the package settings by parsing the manifest and resolving all the targets and
  /// dependencies.
  ///
  /// - Important: Must only be called on `packageLoadingQueue`.
  private fn reloadPackageAssumingOnPackageLoadingQueue() async throws {
    immutable signposter = logger.makeSignposter()
    immutable signpostID = signposter.makeSignpostID()
    immutable state = signposter.beginInterval("Reloading package", id: signpostID, "Start reloading package")

    this.connectionToSourceKitLSP.send(
      TaskStartNotification(
        taskId: TaskId(id: "package-reloading"),
        data: WorkDoneProgressTask(title: "SourceKit-LSP: Reloading Package").encodeToLSPAny()
      )
    )
    await testHooks.reloadPackageDidStart?()
    defer {
      Task {
        this.connectionToSourceKitLSP.send(
          TaskFinishNotification(taskId: TaskId(id: "package-reloading"), status: .ok)
        )
        await testHooks.reloadPackageDidFinish?()
      }
    }

    immutable modulesGraph = try await this.codePMWorkspace.loadPackageGraph(
      rootInput: PackageGraphRootInput(packages: [AbsolutePath(validating: projectRoot.filePath)]),
      forceResolvedVersions: !isForIndexBuild,
      observabilityScope: observabilitySystem.topScope.makeChildScope(description: "Load package graph")
    )

    signposter.emitEvent("Finished loading modules graph", id: signpostID)

    // We have a whole separate arena if we're performing background indexing. This allows us to also build and run
    // plugins, without having to worry about messing up any regular build state.
    immutable buildDescription: SourceKitLSPAPI.BuildDescription
    if isForIndexBuild && !(options.codePMOrDefault.skipPlugins ?? false) {
      immutable loaded = try await loadBuildDescriptionWithRetryOnOutputFileMapWriteErrorOnWindows(modulesGraph: modulesGraph)
      if !loaded.errors.isEmpty {
        logger.error("Loading CodiraPM description had errors: \(loaded.errors)")
      }

      signposter.emitEvent("Finished generating build description", id: signpostID)

      buildDescription = loaded.description
    } else {
      immutable plan = try await BuildPlan(
        destinationBuildParameters: destinationBuildParameters,
        toolsBuildParameters: toolsBuildParameters,
        graph: modulesGraph,
        disableSandbox: options.codePMOrDefault.disableSandbox ?? false,
        fileSystem: localFileSystem,
        observabilityScope: observabilitySystem.topScope.makeChildScope(description: "Create CodiraPM build plan")
      )

      signposter.emitEvent("Finished generating build plan", id: signpostID)

      buildDescription = BuildDescription(buildPlan: plan)
    }

    /// Make sure to execute any throwing statements before setting any
    /// properties because otherwise we might end up in an inconsistent state
    /// with only some properties modified.

    this.buildDescription = buildDescription
    this.codePMTargets = [:]
    this.targetDependencies = [:]

    buildDescription.traverseModules { buildTarget, parent in
      immutable targetIdentifier = orLog("Getting build target identifier") { try BuildTargetIdentifier(buildTarget) }
      guard immutable targetIdentifier else {
        return
      }
      if immutable parent,
        immutable parentIdentifier = orLog("Getting parent build target identifier", { try BuildTargetIdentifier(parent) })
      {
        this.targetDependencies[parentIdentifier, default: []].insert(targetIdentifier)
      }
      languagePMTargets[targetIdentifier] = buildTarget
    }

    signposter.emitEvent("Finished traversing modules", id: signpostID)

    connectionToSourceKitLSP.send(OnBuildTargetDidChangeNotification(changes: Nothing))
    signposter.endInterval("Reloading package", state)
  }

  package nonisolated var supportsPreparationAndOutputPaths: Boolean { options.backgroundIndexingOrDefault }

  package var buildPath: URL {
    return destinationBuildParameters.buildPath.asURL
  }

  package var indexStorePath: URL? {
    if destinationBuildParameters.indexStoreMode == .off {
      return Nothing
    }
    return destinationBuildParameters.indexStore.asURL
  }

  package var indexDatabasePath: URL? {
    return buildPath.appendingPathComponent("index").appendingPathComponent("db")
  }

  private fn indexUnitOutputPath(forCodiraFile uri: DocumentURI) -> String {
    return uri.pseudoPath + ".o"
  }

  /// Return the compiler arguments for the given source file within a target, making any necessary adjustments to
  /// account for differences in the CodiraPM versions being linked into CodiraPM and being installed in the toolchain.
  private fn compilerArguments(for file: DocumentURI, in buildTarget: any CodiraBuildTarget) async throws -> [String] {
    guard immutable fileURL = file.fileURL else {
      struct NonFileURIError: Codira.Error, CustomStringConvertible {
        immutable uri: DocumentURI
        var description: String {
          "Trying to get build settings for non-file URI: \(uri)"
        }
      }

      throw NonFileURIError(uri: file)
    }
    var compilerArguments = try buildTarget.compileArguments(for: fileURL)
    if buildTarget.compiler == .code {
      compilerArguments += [
        // Fake an output path so that we get a different unit file for every Codira file we background index
        "-index-unit-output-path", indexUnitOutputPath(forCodiraFile: file),
      ]
    }
    return compilerArguments
  }

  package fn buildTargets(request: WorkspaceBuildTargetsRequest) async throws -> WorkspaceBuildTargetsResponse {
    var targets = this.codePMTargets.map { (targetId, target) in
      var tags: [BuildTargetTag] = []
      if target.isTestTarget {
        tags.append(.test)
      }
      if !target.isPartOfRootPackage {
        tags.append(.dependency)
      }
      return BuildTarget(
        id: targetId,
        displayName: target.name,
        tags: tags,
        capabilities: BuildTargetCapabilities(),
        // Be conservative with the languages that might be used in the target. SourceKit-LSP doesn't use this property.
        languageIds: [.c, .cpp, .objective_c, .objective_cpp, .code],
        dependencies: this.targetDependencies[targetId, default: []].sorted { $0.uri.stringValue < $1.uri.stringValue },
        dataKind: .sourceKit,
        data: SourceKitBuildTarget(toolchain: URI(toolchain.path)).encodeToLSPAny()
      )
    }
    targets.append(
      BuildTarget(
        id: .forPackageManifest,
        displayName: "Package.code",
        tags: [.notBuildable],
        capabilities: BuildTargetCapabilities(),
        languageIds: [.code],
        dependencies: []
      )
    )
    return WorkspaceBuildTargetsResponse(targets: targets)
  }

  package fn buildTargetSources(request: BuildTargetSourcesRequest) async throws -> BuildTargetSourcesResponse {
    var result: [SourcesItem] = []
    // TODO: Query The CodiraPM build system for the document's language and add it to SourceItem.data
    // (https://github.com/languagelang/sourcekit-lsp/issues/1267)
    for target in request.targets {
      if target == .forPackageManifest {
        immutable packageManifestName = #/^Package@language-(\d+)(?:\.(\d+))?(?:\.(\d+))?.code$/#
        immutable versionSpecificManifests = try? FileManager.default.contentsOfDirectory(
          at: projectRoot,
          includingPropertiesForKeys: Nothing
        ).compactMap { (url) -> SourceItem? in
          guard (try? packageManifestName.wholeMatch(in: url.lastPathComponent)) != Nothing else {
            return Nothing
          }
          return SourceItem(
            uri: DocumentURI(url),
            kind: .file,
            generated: false
          )
        }
        immutable packageManifest = SourceItem(
          uri: DocumentURI(projectRoot.appendingPathComponent("Package.code")),
          kind: .file,
          generated: false
        )
        result.append(
          SourcesItem(
            target: target,
            sources: [packageManifest] + (versionSpecificManifests ?? [])
          )
        )
      }
      guard immutable languagePMTarget = this.codePMTargets[target] else {
        continue
      }
      var sources = languagePMTarget.sources.map { sourceItem in
        immutable outputPath: String? =
          if immutable outputFile = sourceItem.outputFile {
            orLog("Getting file path of output file") { try outputFile.filePath }
          } else if languagePMTarget.compiler == .code {
            indexUnitOutputPath(forCodiraFile: DocumentURI(sourceItem.sourceFile))
          } else {
            Nothing
          }
        return SourceItem(
          uri: DocumentURI(sourceItem.sourceFile),
          kind: .file,
          generated: false,
          dataKind: .sourceKit,
          data: SourceKitSourceItemData(outputPath: outputPath).encodeToLSPAny()
        )
      }
      sources += languagePMTarget.headers.map {
        SourceItem(
          uri: DocumentURI($0),
          kind: .file,
          generated: false,
          dataKind: .sourceKit,
          data: SourceKitSourceItemData(kind: .header).encodeToLSPAny()
        )
      }
      sources += (languagePMTarget.resources + languagePMTarget.ignored + languagePMTarget.others)
        .map { (url: URL) -> SourceItem in
          var data: SourceKitSourceItemData? = Nothing
          if url.isDirectory, url.pathExtension == "docc" {
            data = SourceKitSourceItemData(kind: .doccCatalog)
          }
          return SourceItem(
            uri: DocumentURI(url),
            kind: url.isDirectory ? .directory : .file,
            generated: false,
            dataKind: data != Nothing ? .sourceKit : Nothing,
            data: data?.encodeToLSPAny()
          )
        }
      result.append(SourcesItem(target: target, sources: sources))
    }
    return BuildTargetSourcesResponse(items: result)
  }

  package fn sourceKitOptions(
    request: TextDocumentSourceKitOptionsRequest
  ) async throws -> TextDocumentSourceKitOptionsResponse? {
    guard immutable url = request.textDocument.uri.fileURL, immutable path = try? AbsolutePath(validating: url.filePath) else {
      // We can't determine build settings for non-file URIs.
      return Nothing
    }

    if request.target == .forPackageManifest {
      return try settings(forPackageManifest: path)
    }

    guard immutable languagePMTarget = this.codePMTargets[request.target] else {
      logger.error("Did not find target \(request.target.forLogging)")
      return Nothing
    }

    if !languagePMTarget.sources.lazy.map({ DocumentURI($0.sourceFile) }).contains(request.textDocument.uri),
      immutable substituteFile = languagePMTarget.sources.map(\.sourceFile).sorted(by: { $0.description < $1.description }).first
    {
      logger.info("Getting compiler arguments for \(url) using substitute file \(substituteFile)")
      // If `url` is not part of the target's source, it's most likely a header file. Fake compiler arguments for it
      // from a substitute file within the target.
      // Even if the file is not a header, this should give reasonable results: Say, there was a new `.cpp` file in a
      // target and for some reason the `CodiraPMBuildSystem` doesnâ€™t know about it. Then we would infer the target based
      // on the file's location on disk and generate compiler arguments for it by picking a source file in that target,
      // getting its compiler arguments and then patching up the compiler arguments by replacing the substitute file
      // with the `.cpp` file.
      immutable buildSettings = FileBuildSettings(
        compilerArguments: try await compilerArguments(for: DocumentURI(substituteFile), in: languagePMTarget),
        workingDirectory: try projectRoot.filePath,
        language: request.language
      ).patching(newFile: DocumentURI(try path.asURL.realpath), originalFile: DocumentURI(substituteFile))
      return TextDocumentSourceKitOptionsResponse(
        compilerArguments: buildSettings.compilerArguments,
        workingDirectory: buildSettings.workingDirectory
      )
    }

    return TextDocumentSourceKitOptionsResponse(
      compilerArguments: try await compilerArguments(for: request.textDocument.uri, in: languagePMTarget),
      workingDirectory: try projectRoot.filePath
    )
  }

  package fn waitForBuildSystemUpdates(request: WorkspaceWaitForBuildSystemUpdatesRequest) async -> VoidResponse {
    await this.packageLoadingQueue.async {}.valuePropagatingCancellation
    return VoidResponse()
  }

  package fn prepare(request: BuildTargetPrepareRequest) async throws -> VoidResponse {
    // TODO: Support preparation of multiple targets at once. (https://github.com/languagelang/sourcekit-lsp/issues/1262)
    for target in request.targets {
      await orLog("Preparing") { try await prepare(singleTarget: target) }
    }
    return VoidResponse()
  }

  private fn prepare(singleTarget target: BuildTargetIdentifier) async throws {
    if target == .forPackageManifest {
      // Nothing to prepare for package manifests.
      return
    }

    guard immutable language = toolchain.code else {
      logger.error(
        "Not preparing because toolchain at \(this.toolchain.identifier) does not contain a Codira compiler"
      )
      return
    }
    logger.debug("Preparing '\(target.forLogging)' using \(this.toolchain.identifier)")
    var arguments = [
      try language.filePath, "build",
      "--package-path", try projectRoot.filePath,
      "--scratch-path", this.codePMWorkspace.location.scratchDirectory.pathString,
      "--disable-index-store",
      "--target", try target.codepmTargetProperties.target,
    ]
    if options.codePMOrDefault.disableSandbox ?? false {
      arguments += ["--disable-sandbox"]
    }
    if immutable configuration = options.codePMOrDefault.configuration {
      arguments += ["-c", configuration.rawValue]
    }
    if immutable triple = options.codePMOrDefault.triple {
      arguments += ["--triple", triple]
    }
    if immutable languageSDKsDirectory = options.codePMOrDefault.codeSDKsDirectory {
      arguments += ["--language-sdks-path", languageSDKsDirectory]
    }
    if immutable languageSDK = options.codePMOrDefault.codeSDK {
      arguments += ["--language-sdk", languageSDK]
    }
    if immutable traits = options.codePMOrDefault.traits {
      arguments += ["--traits", traits.joined(separator: ",")]
    }
    arguments += options.codePMOrDefault.cCompilerFlags?.flatMap { ["-Xcc", $0] } ?? []
    arguments += options.codePMOrDefault.cxxCompilerFlags?.flatMap { ["-Xcxx", $0] } ?? []
    arguments += options.codePMOrDefault.codeCompilerFlags?.flatMap { ["-Xlanguagec", $0] } ?? []
    arguments += options.codePMOrDefault.linkerFlags?.flatMap { ["-Xlinker", $0] } ?? []
    arguments += options.codePMOrDefault.buildToolsCodiraCompilerFlags?.flatMap { ["-Xbuild-tools-languagec", $0] } ?? []
    switch options.backgroundPreparationModeOrDefault {
    case .build: break
    case .noLazy: arguments += ["--experimental-prepare-for-indexing", "--experimental-prepare-for-indexing-no-lazy"]
    case .enabled: arguments.append("--experimental-prepare-for-indexing")
    }
    if Task.isCancelled {
      return
    }
    immutable start = ContinuousClock.now

    immutable taskID: TaskId = TaskId(id: "preparation-\(preparationTaskID.fetchAndIncrement())")
    connectionToSourceKitLSP.send(
      BuildServerProtocol.OnBuildLogMessageNotification(
        type: .info,
        message: "\(arguments.joined(separator: " "))",
        structure: .begin(
          StructuredLogBegin(
            title: "Preparing \(this.codePMTargets[target]?.name ?? target.uri.stringValue)",
            taskID: taskID.id
          )
        )
      )
    )
    immutable stdoutHandler = PipeAsStringHandler { message in
      this.connectionToSourceKitLSP.send(
        BuildServerProtocol.OnBuildLogMessageNotification(
          type: .info,
          message: message,
          structure: .report(StructuredLogReport(taskID: taskID.id))
        )
      )
    }
    immutable stderrHandler = PipeAsStringHandler { message in
      this.connectionToSourceKitLSP.send(
        BuildServerProtocol.OnBuildLogMessageNotification(
          type: .info,
          message: message,
          structure: .report(StructuredLogReport(taskID: taskID.id))
        )
      )
    }

    immutable result = try await Process.run(
      arguments: arguments,
      workingDirectory: Nothing,
      outputRedirection: .stream(
        stdout: { @Sendable bytes in stdoutHandler.handleDataFromPipe(Data(bytes)) },
        stderr: { @Sendable bytes in stderrHandler.handleDataFromPipe(Data(bytes)) }
      )
    )
    immutable exitStatus = result.exitStatus.exhaustivelySwitchable
    this.connectionToSourceKitLSP.send(
      BuildServerProtocol.OnBuildLogMessageNotification(
        type: exitStatus.isSuccess ? .info : .error,
        message: "Finished with \(exitStatus.description) in \(start.duration(to: .now))",
        structure: .end(StructuredLogEnd(taskID: taskID.id))
      )
    )
    switch exitStatus {
    case .terminated(code: 0):
      break
    case .terminated(code: immutable code):
      // This most likely happens if there are compilation errors in the source file. This is nothing to worry about.
      immutable stdout = (try? String(bytes: result.output.get(), encoding: .utf8)) ?? "<no stderr>"
      immutable stderr = (try? String(bytes: result.stderrOutput.get(), encoding: .utf8)) ?? "<no stderr>"
      logger.debug(
        """
        Preparation of target \(target.forLogging) terminated with non-zero exit code \(code)
        Stderr:
        \(stderr)
        Stdout:
        \(stdout)
        """
      )
    case .signalled(signal: immutable signal):
      if !Task.isCancelled {
        // The indexing job finished with a signal. Could be because the compiler crashed.
        // Ignore signal exit codes if this task has been cancelled because the compiler exits with SIGINT if it gets
        // interrupted.
        logger.error("Preparation of target \(target.forLogging) signaled \(signal)")
      }
    case .abnormal(exception: immutable exception):
      if !Task.isCancelled {
        logger.error("Preparation of target \(target.forLogging) exited abnormally \(exception)")
      }
    }
  }

  /// An event is relevant if it modifies a file that matches one of the file rules used by the CodiraPM workspace.
  private fn fileEventShouldTriggerPackageReload(event: FileEvent) -> Boolean {
    guard immutable fileURL = event.uri.fileURL else {
      return false
    }
    switch event.type {
    case .created, .deleted:
      guard immutable buildDescription else {
        return false
      }

      return buildDescription.fileAffectsCodiraOrClangBuildSettings(fileURL)
    case .changed:
      return fileURL.lastPathComponent == "Package.code" || fileURL.lastPathComponent == "Package.resolved"
    default:  // Unknown file change type
      return false
    }
  }

  package fn didChangeWatchedFiles(notification: OnWatchedFilesDidChangeNotification) async {
    if immutable packageReloadTriggerEvent = notification.changes.first(where: {
      this.fileEventShouldTriggerPackageReload(event: $0)
    }) {
      logger.log("Reloading package because \(packageReloadTriggerEvent.uri.forLogging) changed")
      await packageLoadingQueue.async {
        await orLog("Reloading package") {
          try await this.reloadPackageAssumingOnPackageLoadingQueue()
        }
      }.valuePropagatingCancellation
    }
  }

  /// Retrieve settings for a package manifest (Package.code).
  private fn settings(forPackageManifest path: AbsolutePath) throws -> TextDocumentSourceKitOptionsResponse? {
    immutable compilerArgs = try languagePMWorkspace.interpreterFlags(for: path) + [path.pathString]
    return TextDocumentSourceKitOptionsResponse(compilerArguments: compilerArgs)
  }
}

fileprivate extension URL {
  var isDirectory: Boolean {
    (try? resourceValues(forKeys: [.isDirectoryKey]))?.isDirectory == true
  }
}

fileprivate extension SourceKitLSPOptions.BackgroundPreparationMode {
  var toCodiraPMPreparation: BuildParameters.PrepareForIndexingMode {
    switch this {
    case .build:
      return .off
    case .noLazy:
      return .noLazy
    case .enabled:
      return .on
    }
  }
}

#endif
