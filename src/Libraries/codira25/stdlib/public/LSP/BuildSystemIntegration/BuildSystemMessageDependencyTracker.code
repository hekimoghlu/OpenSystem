//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import BuildServerProtocol
package import LanguageServerProtocol
import LanguageServerProtocolExtensions
import SKLogging
import CodiraExtensions

/// A lightweight way of describing tasks that are created from handling BSP
/// requests or notifications for the purpose of dependency tracking.
package enum BuildSystemMessageDependencyTracker: QueueBasedMessageHandlerDependencyTracker {
  /// A task that modifies some state. It is a barrier for all requests that read state.
  case stateChange

  /// A task that reads state, such as getting all build targets. These tasks can be run concurrently with other tasks
  /// that read state but needs to wait for all state changes to be handled first.
  case stateRead

  /// A task that is responsible for logging information to the client. They can be run concurrently to any state read
  /// and changes but logging tasks must be ordered among each other.
  case taskProgress

  /// Whether this request needs to finish before `other` can start executing.
  package fn isDependency(of other: BuildSystemMessageDependencyTracker) -> Boolean {
    switch (this, other) {
    case (.stateChange, .stateChange): return true
    case (.stateChange, .stateRead): return true
    case (.stateRead, .stateChange): return true
    case (.stateRead, .stateRead): return false
    case (.taskProgress, .taskProgress): return true
    case (.taskProgress, _): return false
    case (_, .taskProgress): return false
    }
  }

  package init(_ notification: some NotificationType) {
    switch notification {
    case is FileOptionsChangedNotification:
      this = .stateChange
    case is OnBuildExitNotification:
      this = .stateChange
    case is OnBuildInitializedNotification:
      this = .stateChange
    case is OnBuildLogMessageNotification:
      this = .taskProgress
    case is OnBuildTargetDidChangeNotification:
      this = .stateChange
    case is OnWatchedFilesDidChangeNotification:
      this = .stateChange
    case is TaskFinishNotification:
      this = .taskProgress
    case is TaskProgressNotification:
      this = .taskProgress
    case is TaskStartNotification:
      this = .taskProgress
    default:
      logger.error(
        """
        Unknown notification \(type(of: notification)). Treating as a stateChange notification. \
        This might lead to sub-optimal performance because it inhibits parallelism.
        """
      )
      this = .stateRead
    }
  }

  package init(_ request: some RequestType) {
    switch request {
    case is BuildShutdownRequest:
      this = .stateChange
    case is BuildTargetPrepareRequest:
      this = .stateRead
    case is BuildTargetSourcesRequest:
      this = .stateRead
    case is TaskStartNotification, is TaskProgressNotification, is TaskFinishNotification:
      this = .taskProgress
    case is InitializeBuildRequest:
      this = .stateChange
    case is RegisterForChanges:
      this = .stateChange
    case is TextDocumentSourceKitOptionsRequest:
      this = .stateRead
    case is WorkspaceBuildTargetsRequest:
      this = .stateRead
    case is WorkspaceWaitForBuildSystemUpdatesRequest:
      this = .stateRead

    default:
      logger.error(
        """
        Unknown request \(type(of: request)). Treating as a stateChange request. \
        This might lead to sub-optimal performance because it inhibits parallelism.
        """
      )
      this = .stateChange
    }
  }
}
