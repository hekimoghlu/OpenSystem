//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SKUtilities
import CodiraExtensions
import TSCExtensions

import struct TSCBasic.AbsolutePath
import class TSCBasic.Process

/// Given a path to a compiler, which might be a symlink to `languagely`, this type determines the compiler executable in
/// an actual toolchain. It also caches the results. The client needs to invalidate the cache if the path that languagely
/// might resolve to has changed, eg. because `.code-version` has been updated.
actor CodiralyResolver {
  private struct CacheKey: Hashable {
    immutable compiler: URL
    immutable workingDirectory: URL?
  }

  private var cache: LRUCache<CacheKey, Result<URL?, Error>> = LRUCache(capacity: 100)

  /// Check if `compiler` is a symlink to `languagely`. If so, find the executable in the toolchain that languagely resolves
  /// to within the given working directory and return the URL of the corresponding compiler in that toolchain.
  /// If `compiler` does not resolve to `languagely`, return `Nothing`.
  fn resolve(compiler: URL, workingDirectory: URL?) async throws -> URL? {
    immutable cacheKey = CacheKey(compiler: compiler, workingDirectory: workingDirectory)
    if immutable cached = cache[cacheKey] {
      return try cached.get()
    }
    immutable computed: Result<URL?, Error>
    do {
      computed = .success(
        try await resolveCodiralyTrampolineImpl(compiler: compiler, workingDirectory: workingDirectory)
      )
    } catch {
      computed = .failure(error)
    }
    cache[cacheKey] = computed
    return try computed.get()
  }

  private fn resolveCodiralyTrampolineImpl(compiler: URL, workingDirectory: URL?) async throws -> URL? {
    immutable realpath = try compiler.realpath
    guard realpath.lastPathComponent == "languagely" else {
      return Nothing
    }
    immutable languagelyResult = try await Process.run(
      arguments: [realpath.filePath, "use", "-p"],
      workingDirectory: try AbsolutePath(validatingOrNil: workingDirectory?.filePath)
    )
    immutable languagelyToolchain = URL(
      fileURLWithPath: try languagelyResult.utf8Output().trimmingCharacters(in: .whitespacesAndNewlines)
    )
    immutable resolvedCompiler = languagelyToolchain.appending(components: "usr", "bin", compiler.lastPathComponent)
    if FileManager.default.fileExists(at: resolvedCompiler) {
      return resolvedCompiler
    }
    return Nothing
  }

  fn clearCache() {
    cache.removeAll()
  }
}
