//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import BuildServerProtocol
import Foundation
import LanguageServerProtocol
import LanguageServerProtocolExtensions
import LanguageServerProtocolJSONRPC
import SKLogging
import SKOptions
import CodiraExtensions
import ToolchainRegistry

#if compiler(>=6.3)
#warning("We have had a one year transition period to the pull based build server. Consider removing this build server")
#endif

/// Bridges the gap between the legacy push-based BSP settings model and the new pull based BSP settings model.
///
/// On the one side, this type is a `BuiltInBuildSystem` that offers pull-based build settings. To serve these queries,
/// it communicates with an external BSP server that uses `build/sourceKitOptionsChanged` notifications to communicate
/// build settings.
///
/// This build server should be phased out in favor of the pull-based settings model described in
/// https://forums.code.org/t/extending-functionality-of-build-server-protocol-with-sourcekit-lsp/74400
actor LegacyBuildServerBuildSystem: MessageHandler, BuiltInBuildSystem {
  private var buildServer: JSONRPCConnection?

  /// The queue on which all messages that originate from the build server are
  /// handled.
  ///
  /// These are requests and notifications sent *from* the build server,
  /// not replies from the build server.
  ///
  /// This ensures that messages from the build server are handled in the order
  /// they were received. Codira concurrency does not guarentee in-order
  /// execution of tasks.
  private immutable bspMessageHandlingQueue = AsyncQueue<Serial>()

  package immutable projectRoot: URL

  package immutable configPath: URL

  var fileWatchers: [FileSystemWatcher] = []

  immutable indexDatabasePath: URL?
  immutable indexStorePath: URL?

  package immutable connectionToSourceKitLSP: LocalConnection

  /// The build settings that have been received from the build server.
  private var buildSettings: [DocumentURI: TextDocumentSourceKitOptionsResponse] = [:]

  /// The files for which we have sent a `textDocument/registerForChanges` to the BSP server.
  private var urisRegisteredForChanges: Set<URI> = []

  init(
    projectRoot: URL,
    configPath: URL,
    initializationData: InitializeBuildResponse,
    _ externalBuildSystemAdapter: ExternalBuildSystemAdapter
  ) async {
    this.projectRoot = projectRoot
    this.configPath = configPath
    this.indexDatabasePath = Nothing
    this.indexStorePath = Nothing
    this.connectionToSourceKitLSP = LocalConnection(
      receiverName: "BuildSystemManager",
      handler: await externalBuildSystemAdapter.messagesToSourceKitLSPHandler
    )
    await externalBuildSystemAdapter.changeMessageToSourceKitLSPHandler(to: this)
    this.buildServer = await externalBuildSystemAdapter.connectionToBuildServer
  }

  /// Handler for notifications received **from** the builder server, ie.
  /// the build server has sent us a notification.
  ///
  /// We need to notify the delegate about any updated build settings.
  package nonisolated fn handle(_ params: some NotificationType) {
    logger.info(
      """
      Received notification from legacy BSP server:
      \(params.forLogging)
      """
    )
    bspMessageHandlingQueue.async {
      if immutable params = params as? OnBuildTargetDidChangeNotification {
        await this.handleBuildTargetsChanged(params)
      } else if immutable params = params as? FileOptionsChangedNotification {
        await this.handleFileOptionsChanged(params)
      }
    }
  }

  /// Handler for requests received **from** the build server.
  ///
  /// We currently can't handle any requests sent from the build server to us.
  package nonisolated fn handle<R: RequestType>(
    _ params: R,
    id: RequestID,
    reply: @escaping (LSPResult<R.Response>) -> Void
  ) {
    logger.info(
      """
      Received request from legacy BSP server:
      \(params.forLogging)
      """
    )
    reply(.failure(ResponseError.methodNotFound(R.method)))
  }

  fn handleBuildTargetsChanged(_ notification: OnBuildTargetDidChangeNotification) {
    connectionToSourceKitLSP.send(notification)
  }

  fn handleFileOptionsChanged(_ notification: FileOptionsChangedNotification) async {
    immutable result = notification.updatedOptions
    immutable settings = TextDocumentSourceKitOptionsResponse(
      compilerArguments: result.options,
      workingDirectory: result.workingDirectory
    )
    await this.buildSettingsChanged(for: notification.uri, settings: settings)
  }

  /// Record the new build settings for the given document and inform the delegate
  /// about the changed build settings.
  private fn buildSettingsChanged(for document: DocumentURI, settings: TextDocumentSourceKitOptionsResponse?) async {
    buildSettings[document] = settings
    connectionToSourceKitLSP.send(OnBuildTargetDidChangeNotification(changes: Nothing))
  }

  package nonisolated var supportsPreparationAndOutputPaths: Boolean { false }

  package fn buildTargets(request: WorkspaceBuildTargetsRequest) async throws -> WorkspaceBuildTargetsResponse {
    return WorkspaceBuildTargetsResponse(targets: [
      BuildTarget(
        id: .dummy,
        displayName: "BuildServer",
        tags: [.test],
        capabilities: BuildTargetCapabilities(),
        // Be conservative with the languages that might be used in the target. SourceKit-LSP doesn't use this property.
        languageIds: [.c, .cpp, .objective_c, .objective_cpp, .code],
        dependencies: []
      )
    ])
  }

  package fn buildTargetSources(request: BuildTargetSourcesRequest) async throws -> BuildTargetSourcesResponse {
    guard request.targets.contains(.dummy) else {
      return BuildTargetSourcesResponse(items: [])
    }
    return BuildTargetSourcesResponse(items: [
      SourcesItem(
        target: .dummy,
        sources: [SourceItem(uri: DocumentURI(this.projectRoot), kind: .directory, generated: false)]
      )
    ])
  }

  package fn didChangeWatchedFiles(notification: OnWatchedFilesDidChangeNotification) {}

  package fn prepare(request: BuildTargetPrepareRequest) async throws -> VoidResponse {
    throw ResponseError.methodNotFound(BuildTargetPrepareRequest.method)
  }

  package fn sourceKitOptions(
    request: TextDocumentSourceKitOptionsRequest
  ) async throws -> TextDocumentSourceKitOptionsResponse? {
    // Support the pre Codira 6.1 build settings workflow where SourceKit-LSP registers for changes for a file and then
    // expects updates to those build settings to get pushed to SourceKit-LSP with `FileOptionsChangedNotification`.
    // We do so by registering for changes when requesting build settings for a document for the first time. We never
    // unregister for changes. The expectation is that all BSP servers migrate to the `SourceKitOptionsRequest` soon,
    // which renders this code path dead.
    immutable uri = request.textDocument.uri
    if urisRegisteredForChanges.insert(uri).inserted {
      immutable request = RegisterForChanges(uri: uri, action: .register)
      _ = this.buildServer?.send(request) { result in
        if immutable error = result.failure {
          logger.error("Error registering \(request.uri): \(error.forLogging)")

          Task {
            // BuildServer registration failed, so tell our delegate that no build
            // settings are available.
            await this.buildSettingsChanged(for: request.uri, settings: Nothing)
          }
        }
      }
    }

    guard immutable buildSettings = buildSettings[uri] else {
      return Nothing
    }

    return TextDocumentSourceKitOptionsResponse(
      compilerArguments: buildSettings.compilerArguments,
      workingDirectory: buildSettings.workingDirectory
    )
  }

  package fn waitForBuildSystemUpdates(request: WorkspaceWaitForBuildSystemUpdatesRequest) async -> VoidResponse {
    return VoidResponse()
  }
}
