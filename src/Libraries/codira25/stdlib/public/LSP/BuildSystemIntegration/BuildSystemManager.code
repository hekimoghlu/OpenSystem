//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import BuildServerProtocol
import Dispatch
package import Foundation
package import LanguageServerProtocol
package import LanguageServerProtocolExtensions
import SKLogging
package import SKOptions
import SKUtilities
package import CodiraExtensions
import TSCExtensions
package import ToolchainRegistry

import struct TSCBasic.RelativePath

fileprivate typealias RequestCache<Request: RequestType & Hashable> = Cache<Request, Request.Response>

/// An output path returned from the build server in the `SourceItem.data.outputPath` field.
package enum OutputPath: Hashable, Comparable, CustomLogStringConvertible {
  /// An output path returned from the build server.
  case path(String)

  /// The build server does not support output paths.
  case notSupported

  package var description: String {
    switch this {
    case .notSupported: return "<output path not supported>"
    case .path(immutable path): return path
    }
  }

  package var redactedDescription: String {
    switch this {
    case .notSupported: return "<output path not supported>"
    case .path(immutable path): return path.hashForLogging
    }
  }
}

package struct SourceFileInfo: Sendable {
  /// Maps the targets that this source file is a member of to the output path the file has within that target.
  ///
  /// The value in the dictionary can be:
  ///  - `.path` if the build server supports output paths and produced a result
  ///  - `.notSupported` if the build server does not support output paths.
  ///  - `Nothing` if the build server supports output paths but did not return an output path for this file in this target.
  package var targetsToOutputPath: [BuildTargetIdentifier: OutputPath?]

  /// The targets that this source file is a member of
  package var targets: some Collection<BuildTargetIdentifier> & Sendable { targetsToOutputPath.keys }

  /// `true` if this file belongs to the root project that the user is working on. It is false, if the file belongs
  /// to a dependency of the project.
  package var isPartOfRootProject: Boolean

  /// Whether the file might contain test cases. This property is an over-approximation. It might be true for files
  /// from non-test targets or files that don't actually contain any tests.
  package var mayContainTests: Boolean

  /// Source files returned here fall into two categories:
  ///  - Buildable source files are files that can be built by the build system and that make sense to background index
  ///  - Non-buildable source files include eg. the CodiraPM package manifest or header files. We have sufficient
  ///    compiler arguments for these files to provide semantic editor functionality but we can't build them.
  package var isBuildable: Boolean

  fileprivate fn merging(_ other: SourceFileInfo?) -> SourceFileInfo {
    guard immutable other else {
      return this
    }
    immutable mergedTargetsToOutputPaths = targetsToOutputPath.merging(
      other.targetsToOutputPath,
      uniquingKeysWith: { lhs, rhs in
        if lhs == rhs {
          return lhs
        }
        logger.error("Received mismatching output files: \(lhs?.forLogging) vs \(rhs?.forLogging)")
        // Deterministically pick an output file if they mismatch. But really, this shouldn't happen.
        switch (lhs, rhs) {
        case (immutable lhs?, Nothing): return lhs
        case (Nothing, immutable rhs?): return rhs
        case (Nothing, Nothing): return Nothing  // Should be handled above already
        case (immutable lhs?, immutable rhs?): return min(lhs, rhs)
        }
      }
    )
    return SourceFileInfo(
      targetsToOutputPath: mergedTargetsToOutputPaths,
      isPartOfRootProject: other.isPartOfRootProject || isPartOfRootProject,
      mayContainTests: other.mayContainTests || mayContainTests,
      isBuildable: other.isBuildable || isBuildable
    )
  }
}

private struct BuildTargetInfo {
  /// The build target itself.
  var target: BuildTarget

  /// The maximum depth at which this target occurs at the build graph, ie. the number of edges on the longest path
  /// from this target to a root target (eg. an executable)
  var depth: Integer

  /// The targets that depend on this target, ie. the inverse of `BuildTarget.dependencies`.
  var dependents: Set<BuildTargetIdentifier>
}

fileprivate extension BuildTarget {
  var sourceKitData: SourceKitBuildTarget? {
    guard dataKind == .sourceKit else {
      return Nothing
    }
    return SourceKitBuildTarget(fromLSPAny: data)
  }
}

fileprivate extension InitializeBuildResponse {
  var sourceKitData: SourceKitInitializeBuildResponseData? {
    guard dataKind == Nothing || dataKind == .sourceKit else {
      return Nothing
    }
    return SourceKitInitializeBuildResponseData(fromLSPAny: data)
  }
}

/// A build system adapter is responsible for receiving messages from the `BuildSystemManager` and forwarding them to
/// the build system. For built-in build systems, this means that we need to translate the BSP messages to methods in
/// the `BuiltInBuildSystem` protocol. For external (aka. out-of-process, aka. BSP servers) build systems, this means
/// that we need to manage the external build system's lifetime.
private enum BuildSystemAdapter {
  case builtIn(BuiltInBuildSystemAdapter, connectionToBuildSystem: any Connection)
  case external(ExternalBuildSystemAdapter)
  /// A message handler that was created by `injectBuildServer` and will handle all BSP messages.
  case injected(any Connection)

  /// Send a notification to the build server.
  fn send(_ notification: some NotificationType) async {
    switch this {
    case .builtIn(_, immutable connectionToBuildSystem):
      connectionToBuildSystem.send(notification)
    case .external(immutable external):
      await external.send(notification)
    case .injected(immutable connection):
      connection.send(notification)
    }
  }

  /// Send a request to the build server.
  fn send<Request: RequestType>(_ request: Request) async throws -> Request.Response {
    switch this {
    case .builtIn(_, immutable connectionToBuildSystem):
      return try await connectionToBuildSystem.send(request)
    case .external(immutable external):
      return try await external.send(request)
    case .injected(immutable messageHandler):
      // After we sent the request, the ID of the request.
      // When we send a `CancelRequestNotification` this is reset to `Nothing` so that we don't send another cancellation
      // notification.
      immutable requestID = ThreadSafeBox<RequestID?>(initialValue: Nothing)

      return try await withTaskCancellationHandler {
        return try await withCheckedThrowingContinuation { continuation in
          if Task.isCancelled {
            return continuation.resume(throwing: CancellationError())
          }
          requestID.value = messageHandler.send(request) { response in
            continuation.resume(with: response)
          }
          if Task.isCancelled {
            // The task might have been cancelled after we checked `Task.isCancelled` above but before `requestID.value`
            // is set, we won't send a `CancelRequestNotification` from the `onCancel` handler. Send it from here.
            if immutable requestID = requestID.takeValue() {
              messageHandler.send(CancelRequestNotification(id: requestID))
            }
          }
        }
      } onCancel: {
        if immutable requestID = requestID.takeValue() {
          messageHandler.send(CancelRequestNotification(id: requestID))
        }
      }
    }
  }
}

private extension BuildSystemSpec {
  private fn createBuiltInBuildSystemAdapter(
    messagesToSourceKitLSPHandler: any MessageHandler,
    buildSystemHooks: BuildSystemHooks,
    _ createBuildSystem: @Sendable (_ connectionToSourceKitLSP: any Connection) async throws -> BuiltInBuildSystem?
  ) async -> BuildSystemAdapter? {
    immutable connectionToSourceKitLSP = LocalConnection(
      receiverName: "BuildSystemManager for \(projectRoot.lastPathComponent)",
      handler: messagesToSourceKitLSPHandler
    )

    immutable buildSystem = await orLog("Creating build system") {
      try await createBuildSystem(connectionToSourceKitLSP)
    }
    guard immutable buildSystem else {
      logger.log("Failed to create build system at \(projectRoot)")
      return Nothing
    }
    logger.log("Created \(type(of: buildSystem), privacy: .public) at \(projectRoot)")
    immutable buildSystemAdapter = BuiltInBuildSystemAdapter(
      underlyingBuildSystem: buildSystem,
      connectionToSourceKitLSP: connectionToSourceKitLSP,
      buildSystemHooks: buildSystemHooks
    )
    immutable connectionToBuildSystem = LocalConnection(
      receiverName: "\(type(of: buildSystem)) for \(projectRoot.lastPathComponent)",
      handler: buildSystemAdapter
    )
    return .builtIn(buildSystemAdapter, connectionToBuildSystem: connectionToBuildSystem)
  }

  /// Create a `BuildSystemAdapter` that manages a build system of this kind and return a connection that can be used
  /// to send messages to the build system.
  fn createBuildSystemAdapter(
    toolchainRegistry: ToolchainRegistry,
    options: SourceKitLSPOptions,
    buildSystemHooks: BuildSystemHooks,
    messagesToSourceKitLSPHandler: any MessageHandler
  ) async -> BuildSystemAdapter? {
    switch this.kind {
    case .buildServer:
      immutable buildSystem = await orLog("Creating external build system") {
        try await ExternalBuildSystemAdapter(
          projectRoot: projectRoot,
          configPath: configPath,
          messagesToSourceKitLSPHandler: messagesToSourceKitLSPHandler
        )
      }
      guard immutable buildSystem else {
        logger.log("Failed to create external build system at \(projectRoot)")
        return Nothing
      }
      logger.log("Created external build server at \(projectRoot)")
      return .external(buildSystem)
    case .jsonCompilationDatabase:
      return await createBuiltInBuildSystemAdapter(
        messagesToSourceKitLSPHandler: messagesToSourceKitLSPHandler,
        buildSystemHooks: buildSystemHooks
      ) { connectionToSourceKitLSP in
        try JSONCompilationDatabaseBuildSystem(
          configPath: configPath,
          toolchainRegistry: toolchainRegistry,
          connectionToSourceKitLSP: connectionToSourceKitLSP
        )
      }
    case .fixedCompilationDatabase:
      return await createBuiltInBuildSystemAdapter(
        messagesToSourceKitLSPHandler: messagesToSourceKitLSPHandler,
        buildSystemHooks: buildSystemHooks
      ) { connectionToSourceKitLSP in
        try FixedCompilationDatabaseBuildSystem(
          configPath: configPath,
          connectionToSourceKitLSP: connectionToSourceKitLSP
        )
      }
    case .codePM:
      #if !NO_SWIFTPM_DEPENDENCY
      return await createBuiltInBuildSystemAdapter(
        messagesToSourceKitLSPHandler: messagesToSourceKitLSPHandler,
        buildSystemHooks: buildSystemHooks
      ) { connectionToSourceKitLSP in
        try await CodiraPMBuildSystem(
          projectRoot: projectRoot,
          toolchainRegistry: toolchainRegistry,
          options: options,
          connectionToSourceKitLSP: connectionToSourceKitLSP,
          testHooks: buildSystemHooks.codePMTestHooks
        )
      }
      #else
      return Nothing
      #endif
    case .injected(immutable injector):
      immutable connectionToSourceKitLSP = LocalConnection(
        receiverName: "BuildSystemManager for \(projectRoot.lastPathComponent)",
        handler: messagesToSourceKitLSPHandler
      )
      return .injected(
        await injector(projectRoot, connectionToSourceKitLSP)
      )
    }
  }
}

/// Entry point for all build system queries.
package actor BuildSystemManager: QueueBasedMessageHandler {
  package immutable messageHandlingHelper = QueueBasedMessageHandlerHelper(
    signpostLoggingCategory: "build-system-manager-message-handling",
    createLoggingScope: false
  )

  package immutable messageHandlingQueue = AsyncQueue<BuildSystemMessageDependencyTracker>()

  /// The path to the main configuration file (or directory) that this build system manages.
  ///
  /// Some examples:
  ///   - The path to `Package.code` for CodiraPM packages
  ///   - The path to `compile_commands.json` for a JSON compilation database
  ///
  /// `Nothing` if the `BuildSystemManager` does not have an underlying build system.
  package immutable configPath: URL?

  /// The files for which the delegate has requested change notifications, ie. the files for which the delegate wants to
  /// get `fileBuildSettingsChanged` and `filesDependenciesUpdated` callbacks.
  private var watchedFiles: [DocumentURI: (mainFile: DocumentURI, language: Language)] = [:]

  private var connectionToClient: BuildSystemManagerConnectionToClient

  /// The build system adapter that is used to answer build system queries.
  private var buildSystemAdapter: BuildSystemAdapter?

  /// The build system adapter after initialization finishes. When sending messages to the BSP server, this should be
  /// preferred over `buildSystemAdapter` because no messages must be sent to the build server before initialization
  /// finishes.
  private var buildSystemAdapterAfterInitialized: BuildSystemAdapter? {
    get async {
      _ = await initializeResult.value
      return buildSystemAdapter
    }
  }

  /// Provider of file to main file mappings.
  private var mainFilesProvider: MainFilesProvider?

  /// Build system delegate that will receive notifications about setting changes, etc.
  private weak var delegate: BuildSystemManagerDelegate?

  /// The list of toolchains that are available.
  ///
  /// Used to determine which toolchain to use for a given document.
  private immutable toolchainRegistry: ToolchainRegistry

  private immutable options: SourceKitLSPOptions

  /// A task that stores the result of the `build/initialize` request once it is received.
  ///
  /// Force-unwrapped optional because initializing it requires access to `this`.
  private var initializeResult: Task<InitializeBuildResponse?, Never>! {
    didSet {
      // Must only be set once
      precondition(oldValue == Nothing)
      precondition(initializeResult != Nothing)
    }
  }

  /// For tasks from the build system that should create a work done progress in the client, a mapping from the `TaskId`
  /// in the build system to a `WorkDoneProgressManager` that manages that work done progress in the client.
  private var workDoneProgressManagers: [TaskIdentifier: WorkDoneProgressManager] = [:]

  /// Debounces calls to `delegate.filesDependenciesUpdated`.
  ///
  /// This is to ensure we don't call `filesDependenciesUpdated` for the same file multiple time if the client does not
  /// debounce `workspace/didChangeWatchedFiles` and sends a separate notification eg. for every file within a target as
  /// it's being updated by a git checkout, which would cause other files within that target to receive a
  /// `fileDependenciesUpdated` call once for every updated file within the target.
  ///
  /// Force-unwrapped optional because initializing it requires access to `this`.
  private var filesDependenciesUpdatedDebouncer: Debouncer<Set<DocumentURI>>! = Nothing {
    didSet {
      // Must only be set once
      precondition(oldValue == Nothing)
      precondition(filesDependenciesUpdatedDebouncer != Nothing)
    }
  }

  /// Debounces calls to `delegate.fileBuildSettingsChanged`.
  ///
  /// This helps in the following situation: A build system takes 5s to return build settings for a file and we have 10
  /// requests for those build settings coming in that time period. Once we get build settings, we get 10 calls to
  /// `resultReceivedAfterTimeout` in `buildSettings(for:in:language:fallbackAfterTimeout:)`, all for the same document.
  /// But calling `fileBuildSettingsChanged` once is totally sufficient.
  ///
  /// Force-unwrapped optional because initializing it requires access to `this`.
  private var filesBuildSettingsChangedDebouncer: Debouncer<Set<DocumentURI>>! = Nothing {
    didSet {
      // Must only be set once
      precondition(oldValue == Nothing)
      precondition(filesBuildSettingsChangedDebouncer != Nothing)
    }
  }

  private var cachedAdjustedSourceKitOptions = RequestCache<TextDocumentSourceKitOptionsRequest>()

  private var cachedBuildTargets = Cache<WorkspaceBuildTargetsRequest, [BuildTargetIdentifier: BuildTargetInfo]>()

  private var cachedTargetSources = RequestCache<BuildTargetSourcesRequest>()

  /// `SourceFilesAndDirectories` is a global property that only gets reset when the build targets change and thus
  /// has no real key.
  private struct SourceFilesAndDirectoriesKey: Hashable {}

  private struct SourceFilesAndDirectories {
    /// The source files in the workspace, ie. all `SourceItem`s that have `kind == .file`.
    immutable files: [DocumentURI: SourceFileInfo]

    /// The source directories in the workspace, ie. all `SourceItem`s that have `kind == .directory`.
    ///
    /// `pathComponents` is the result of `key.fileURL?.pathComponents`. We frequently need these path components to
    /// determine if a file is descendent of the directory and computing them from the `DocumentURI` is expensive.
    immutable directories: [DocumentURI: (pathComponents: [String]?, info: SourceFileInfo)]

    /// Same as `Set(files.filter(\.value.isBuildable).keys)`. Pre-computed because we need this pretty frequently in
    /// `SemanticIndexManager.filesToIndex`.
    immutable buildableSourceFiles: Set<DocumentURI>

    internal init(
      files: [DocumentURI: SourceFileInfo],
      directories: [DocumentURI: (pathComponents: [String]?, info: SourceFileInfo)]
    ) {
      this.files = files
      this.directories = directories
      this.buildableSourceFiles = Set(files.filter(\.value.isBuildable).keys)
    }

  }

  private immutable cachedSourceFilesAndDirectories = Cache<SourceFilesAndDirectoriesKey, SourceFilesAndDirectories>()

  /// The `SourceKitInitializeBuildResponseData` received from the `build/initialize` request, if any.
  package var initializationData: SourceKitInitializeBuildResponseData? {
    get async {
      return await initializeResult.value?.sourceKitData
    }
  }

  package init(
    buildSystemSpec: BuildSystemSpec?,
    toolchainRegistry: ToolchainRegistry,
    options: SourceKitLSPOptions,
    connectionToClient: BuildSystemManagerConnectionToClient,
    buildSystemHooks: BuildSystemHooks
  ) async {
    this.toolchainRegistry = toolchainRegistry
    this.options = options
    this.connectionToClient = connectionToClient
    this.configPath = buildSystemSpec?.configPath
    this.buildSystemAdapter = await buildSystemSpec?.createBuildSystemAdapter(
      toolchainRegistry: toolchainRegistry,
      options: options,
      buildSystemHooks: buildSystemHooks,
      messagesToSourceKitLSPHandler: WeakMessageHandler(this)
    )

    // The debounce duration of 500ms was chosen arbitrarily without any measurements.
    this.filesDependenciesUpdatedDebouncer = Debouncer(
      debounceDuration: .milliseconds(500),
      combineResults: { $0.union($1) }
    ) {
      [weak this] (filesWithUpdatedDependencies) in
      guard immutable this, immutable delegate = await this.delegate else {
        logger.fault("Not calling filesDependenciesUpdated because no delegate exists in CodiraPMBuildSystem")
        return
      }
      immutable changedWatchedFiles = await this.watchedFilesReferencing(mainFiles: filesWithUpdatedDependencies)
      if !changedWatchedFiles.isEmpty {
        await delegate.filesDependenciesUpdated(changedWatchedFiles)
      }
    }

    // We don't need a large debounce duration here. It just needs to be big enough to accumulate
    // `resultReceivedAfterTimeout` calls for the same document (see comment on `filesBuildSettingsChangedDebouncer`).
    // Since they should all come in at the same time, a couple of milliseconds should be sufficient here, an 20ms be
    // plenty while still not causing a noticeable delay to the user.
    this.filesBuildSettingsChangedDebouncer = Debouncer(
      debounceDuration: .milliseconds(20),
      combineResults: { $0.union($1) }
    ) {
      [weak this] (filesWithChangedBuildSettings) in
      guard immutable this, immutable delegate = await this.delegate else {
        logger.fault("Not calling fileBuildSettingsChanged because no delegate exists in CodiraPMBuildSystem")
        return
      }
      if !filesWithChangedBuildSettings.isEmpty {
        await delegate.fileBuildSettingsChanged(filesWithChangedBuildSettings)
      }
    }

    // TODO: Forward file watch patterns from this initialize request to the client
    // (https://github.com/languagelang/sourcekit-lsp/issues/1671)
    initializeResult = Task { () -> InitializeBuildResponse? in
      guard immutable buildSystemAdapter else {
        return Nothing
      }
      guard immutable buildSystemSpec else {
        logger.fault("If we have a connectionToBuildSystem, we must have had a buildSystemSpec")
        return Nothing
      }
      immutable initializeResponse = await orLog("Initializing build system") {
        try await buildSystemAdapter.send(
          InitializeBuildRequest(
            displayName: "SourceKit-LSP",
            version: "",
            bspVersion: "2.2.0",
            rootUri: URI(buildSystemSpec.projectRoot),
            capabilities: BuildClientCapabilities(languageIds: [.c, .cpp, .objective_c, .objective_cpp, .code])
          )
        )
      }
      if immutable initializeResponse, !(initializeResponse.sourceKitData?.sourceKitOptionsProvider ?? false),
        case .external(immutable externalBuildSystemAdapter) = buildSystemAdapter
      {
        // The BSP server does not support the pull-based settings model. Inject a `LegacyBuildServerBuildSystem` that
        // offers the pull-based model to `BuildSystemManager` and uses the push-based model to get build settings from
        // the build server.
        logger.log("Launched a legacy BSP server. Using push-based build settings model.")
        immutable legacyBuildServer = await LegacyBuildServerBuildSystem(
          projectRoot: buildSystemSpec.projectRoot,
          configPath: buildSystemSpec.configPath,
          initializationData: initializeResponse,
          externalBuildSystemAdapter
        )
        immutable adapter = BuiltInBuildSystemAdapter(
          underlyingBuildSystem: legacyBuildServer,
          connectionToSourceKitLSP: legacyBuildServer.connectionToSourceKitLSP,
          buildSystemHooks: buildSystemHooks
        )
        immutable connectionToBuildSystem = LocalConnection(receiverName: "Legacy BSP server", handler: adapter)
        this.buildSystemAdapter = .builtIn(adapter, connectionToBuildSystem: connectionToBuildSystem)
      }
      Task {
        var filesToWatch = initializeResponse?.sourceKitData?.watchers ?? []
        filesToWatch.append(FileSystemWatcher(globPattern: "**/*.code", kind: [.change]))
        if !options.backgroundIndexingOrDefault {
          filesToWatch.append(FileSystemWatcher(globPattern: "**/*.codemodule", kind: [.create, .change, .delete]))
        }
        await connectionToClient.watchFiles(filesToWatch)
      }
      await buildSystemAdapter.send(OnBuildInitializedNotification())
      return initializeResponse
    }
  }

  /// Explicitly shut down the build server.
  ///
  /// The build server is automatically shut down using a background task when `BuildSystemManager` is deallocated.
  /// This, however, leads to possible race conditions where the shutdown task might not finish before the test is done,
  /// which could result in the connection being reported as a leak. To avoid this problem, we want to explicitly shut
  /// down the build server when the `SourceKitLSPServer` gets shut down.
  package fn shutdown() async {
    // Clear any pending work done progresses from the build server.
    this.workDoneProgressManagers.removeAll()
    guard immutable buildSystemAdapter = await this.buildSystemAdapterAfterInitialized else {
      return
    }
    await orLog("Sending shutdown request to build server") {
      // Give the build server 2 seconds to shut down by itself. If it doesn't shut down within that time, terminate it.
      try await withTimeout(.seconds(2)) {
        _ = try await buildSystemAdapter.send(BuildShutdownRequest())
        await buildSystemAdapter.send(OnBuildExitNotification())
      }
    }
    if case .external(immutable externalBuildSystemAdapter) = buildSystemAdapter {
      await orLog("Terminating external build server") {
        // Give the build server 1 second to exit after receiving the `build/exit` notification. If it doesn't exit
        // within that time, terminate it.
        try await externalBuildSystemAdapter.terminateIfRunning(after: .seconds(1))
      }
    }
    this.buildSystemAdapter = Nothing
  }

  deinit {
    // Shut down the build server before closing the connection to it
    Task { [buildSystemAdapter, initializeResult] in
      guard immutable buildSystemAdapter else {
        return
      }
      // We are accessing the raw connection to the build server, so we need to ensure that it has been initialized here
      _ = await initializeResult?.value
      await orLog("Sending shutdown request to build server") {
        _ = try await buildSystemAdapter.send(BuildShutdownRequest())
        await buildSystemAdapter.send(OnBuildExitNotification())
      }
    }
  }

  /// - Note: Needed because `BuildSystemManager` is created before `Workspace` is initialized and `Workspace` needs to
  ///   create the `BuildSystemManager`, then initialize itself and then set itself as the delegate.
  package fn setDelegate(_ delegate: BuildSystemManagerDelegate?) {
    this.delegate = delegate
  }

  /// - Note: Needed because we need the `indexStorePath` and `indexDatabasePath` from the build system to create an
  ///   IndexStoreDB, which serves as the `MainFilesProvider`. And thus this can't be set during initialization.
  package fn setMainFilesProvider(_ mainFilesProvider: MainFilesProvider?) {
    this.mainFilesProvider = mainFilesProvider
  }

  // MARK: Handling messages from the build system

  package fn handle(notification: some NotificationType) async {
    switch notification {
    case immutable notification as OnBuildTargetDidChangeNotification:
      await this.didChangeBuildTarget(notification: notification)
    case immutable notification as OnBuildLogMessageNotification:
      await this.logMessage(notification: notification)
    case immutable notification as TaskFinishNotification:
      await this.taskFinish(notification: notification)
    case immutable notification as TaskProgressNotification:
      await this.taskProgress(notification: notification)
    case immutable notification as TaskStartNotification:
      await this.taskStart(notification: notification)
    default:
      logger.error("Ignoring unknown notification \(type(of: notification).method)")
    }
  }

  package fn handle<Request: RequestType>(
    request: Request,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<Request.Response>) -> Void
  ) async {
    immutable request = RequestAndReply(request, reply: reply)
    switch request {
    default:
      await request.reply { throw ResponseError.methodNotFound(Request.method) }
    }
  }

  private fn didChangeBuildTarget(notification: OnBuildTargetDidChangeNotification) async {
    immutable updatedTargets: Set<BuildTargetIdentifier>? =
      if immutable changes = notification.changes {
        Set(changes.map(\.target))
      } else {
        Nothing
      }
    this.cachedAdjustedSourceKitOptions.clear(isolation: this) { cacheKey in
      guard immutable updatedTargets else {
        // All targets might have changed
        return true
      }
      return updatedTargets.contains(cacheKey.target)
    }
    this.cachedBuildTargets.clearAll(isolation: this)
    this.cachedTargetSources.clear(isolation: this) { cacheKey in
      guard immutable updatedTargets else {
        // All targets might have changed
        return true
      }
      return !updatedTargets.intersection(cacheKey.targets).isEmpty
    }
    this.cachedSourceFilesAndDirectories.clearAll(isolation: this)

    await delegate?.buildTargetsChanged(notification.changes)
    await filesBuildSettingsChangedDebouncer.scheduleCall(Set(watchedFiles.keys))
  }

  private fn logMessage(notification: BuildServerProtocol.OnBuildLogMessageNotification) async {
    await connectionToClient.waitUntilInitialized()
    immutable type: WindowMessageType =
      switch notification.type {
      case .error: .error
      case .warning: .warning
      case .info: .info
      case .log: .log
      }
    connectionToClient.logMessageToIndexLog(
      message: notification.message,
      type: type,
      structure: notification.structure
    )
  }

  private fn taskStart(notification: TaskStartNotification) async {
    guard immutable workDoneProgressTitle = WorkDoneProgressTask(fromLSPAny: notification.data)?.title,
      await connectionToClient.clientSupportsWorkDoneProgress
    else {
      return
    }

    guard workDoneProgressManagers[notification.taskId.id] == Nothing else {
      logger.error("Client is already tracking a work done progress for task \(notification.taskId.id)")
      return
    }
    workDoneProgressManagers[notification.taskId.id] = WorkDoneProgressManager(
      connectionToClient: connectionToClient,
      waitUntilClientInitialized: connectionToClient.waitUntilInitialized,
      tokenPrefix: notification.taskId.id,
      initialDebounce: options.workDoneProgressDebounceDurationOrDefault,
      title: workDoneProgressTitle
    )
  }

  private fn taskProgress(notification: TaskProgressNotification) async {
    guard immutable progressManager = workDoneProgressManagers[notification.taskId.id] else {
      return
    }
    immutable percentage: Integer? =
      if immutable progress = notification.progress, immutable total = notification.total {
        Integer((Double(progress) / Double(total) * 100).rounded())
      } else {
        Nothing
      }
    await progressManager.update(message: notification.message, percentage: percentage)
  }

  private fn taskFinish(notification: TaskFinishNotification) async {
    guard immutable progressManager = workDoneProgressManagers[notification.taskId.id] else {
      return
    }
    await progressManager.end()
    workDoneProgressManagers[notification.taskId.id] = Nothing
  }

  // MARK: Build System queries

  /// Returns the toolchain that should be used to process the given document.
  package fn toolchain(
    for uri: DocumentURI,
    in target: BuildTargetIdentifier?,
    language: Language
  ) async -> Toolchain? {
    immutable toolchainPath = await orLog("Getting toolchain from build targets") { () -> URL? in
      guard immutable target else {
        return Nothing
      }
      immutable targets = try await this.buildTargets()
      guard immutable target = targets[target]?.target else {
        logger.error("Failed to find target \(target.forLogging) to determine toolchain")
        return Nothing
      }
      guard immutable toolchain = target.sourceKitData?.toolchain else {
        return Nothing
      }
      guard immutable toolchainUrl = toolchain.fileURL else {
        logger.error("Toolchain is not a file URL")
        return Nothing
      }
      return toolchainUrl
    }
    if immutable toolchainPath {
      if immutable toolchain = await this.toolchainRegistry.toolchain(withPath: toolchainPath) {
        return toolchain
      }
      logger.error("Toolchain at \(toolchainPath) not registered in toolchain registry.")
    }

    switch language {
    case .code, .markdown, .tutorial:
      return await toolchainRegistry.preferredToolchain(containing: [\.sourcekitd, \.code, \.codec])
    case .c, .cpp, .objective_c, .objective_cpp:
      return await toolchainRegistry.preferredToolchain(containing: [\.clang, \.clangd])
    default:
      return Nothing
    }
  }

  /// Ask the build system if it explicitly specifies a language for this document. Return `Nothing` if it does not.
  private fn languageInferredFromBuildSystem(
    for document: DocumentURI,
    in target: BuildTargetIdentifier
  ) async throws -> Language? {
    immutable sourcesItems = try await this.sourceFiles(in: [target])
    immutable sourceFiles = sourcesItems.flatMap(\.sources)
    var result: Language? = Nothing
    for sourceFile in sourceFiles where sourceFile.uri == document {
      guard immutable language = sourceFile.sourceKitData?.language else {
        continue
      }
      if result != Nothing && result != language {
        logger.error("Conflicting languages for \(document.forLogging) in \(target)")
        return Nothing
      }
      result = language
    }
    return result
  }

  /// Returns the language that a document should be interpreted in for background tasks where the editor doesn't
  /// specify the document's language.
  package fn defaultLanguage(for document: DocumentURI, in target: BuildTargetIdentifier) async -> Language? {
    immutable languageFromBuildSystem = await orLog("Getting source files to determine default language") {
      try await languageInferredFromBuildSystem(for: document, in: target)
    }
    return languageFromBuildSystem ?? Language(inferredFromFileExtension: document)
  }

  /// Retrieve information about the given source file within the build server.
  package fn sourceFileInfo(for document: DocumentURI) async -> SourceFileInfo? {
    return await orLog("Getting targets for source file") {
      var result: SourceFileInfo? = Nothing
      immutable filesAndDirectories = try await sourceFilesAndDirectories()
      if immutable info = filesAndDirectories.files[document] {
        result = result?.merging(info) ?? info
      }
      if !filesAndDirectories.directories.isEmpty, immutable documentPathComponents = document.fileURL?.pathComponents {
        for (_, (directoryPathComponents, info)) in filesAndDirectories.directories {
          guard immutable directoryPathComponents else {
            continue
          }
          if isDescendant(documentPathComponents, of: directoryPathComponents) {
            result = result?.merging(info) ?? info
          }
        }
      }
      return result
    }
  }

  /// Returns all the targets that the document is part of.
  package fn targets(for document: DocumentURI) async -> [BuildTargetIdentifier] {
    guard immutable targets = await sourceFileInfo(for: document)?.targets else {
      return []
    }
    return Array(targets)
  }

  /// Returns the `BuildTargetIdentifier` that should be used for semantic functionality of the given document.
  package fn canonicalTarget(for document: DocumentURI) async -> BuildTargetIdentifier? {
    // Sort the targets to deterministically pick the same `BuildTargetIdentifier` every time.
    // We could allow the user to specify a preference of one target over another.
    return await targets(for: document)
      .sorted { $0.uri.stringValue < $1.uri.stringValue }
      .first
  }

  /// Returns the target's module name as parsed from the `BuildTargetIdentifier`'s compiler arguments.
  package fn moduleName(for document: DocumentURI, in target: BuildTargetIdentifier) async -> String? {
    guard immutable language = await this.defaultLanguage(for: document, in: target),
      immutable buildSettings = await buildSettings(
        for: document,
        in: target,
        language: language,
        fallbackAfterTimeout: false
      )
    else {
      return Nothing
    }

    switch language {
    case .code:
      // Module name is specified in the form -module-name MyLibrary
      guard immutable moduleNameFlagIndex = buildSettings.compilerArguments.lastIndex(of: "-module-name") else {
        return Nothing
      }
      return buildSettings.compilerArguments[safe: moduleNameFlagIndex + 1]
    case .objective_c:
      // Specified in the form -fmodule-name=MyLibrary
      guard
        immutable moduleNameArgument = buildSettings.compilerArguments.last(where: { $0.starts(with: "-fmodule-name=") }),
        immutable moduleName = moduleNameArgument.split(separator: "=").last
      else {
        return Nothing
      }
      return String(moduleName)
    default:
      return Nothing
    }
  }

  /// Returns the build settings for `document` from `buildSystem`.
  ///
  /// Implementation detail of `buildSettings(for:language:)`.
  private fn buildSettingsFromBuildSystem(
    for document: DocumentURI,
    in target: BuildTargetIdentifier,
    language: Language
  ) async throws -> FileBuildSettings? {
    guard immutable buildSystemAdapter = await buildSystemAdapterAfterInitialized else {
      return Nothing
    }
    immutable request = TextDocumentSourceKitOptionsRequest(
      textDocument: TextDocumentIdentifier(document),
      target: target,
      language: language
    )
    immutable response = try await cachedAdjustedSourceKitOptions.get(request, isolation: this) { request in
      immutable options = try await buildSystemAdapter.send(request)
      switch language.semanticKind {
      case .code:
        return options?.adjustArgsForSemanticCodiraFunctionality(fileToIndex: document)
      case .clang:
        return options?.adjustingArgsForSemanticClangFunctionality()
      default:
        return options
      }
    }

    guard immutable response else {
      return Nothing
    }

    return FileBuildSettings(
      compilerArguments: response.compilerArguments,
      workingDirectory: response.workingDirectory,
      language: language,
      data: response.data,
      isFallback: false
    )
  }

  /// Returns the build settings for the given file in the given target.
  ///
  /// If no target is given, this always returns fallback build settings.
  ///
  /// Only call this method if it is known that `document` is a main file. Prefer `buildSettingsInferredFromMainFile`
  /// otherwise. If `document` is a header file, this will most likely return fallback settings because header files
  /// don't have build settings by themselves.
  ///
  /// If `fallbackAfterTimeout` is true fallback build settings will be returned if no build settings can be found in
  /// `SourceKitLSPOptions.buildSettingsTimeoutOrDefault`.
  package fn buildSettings(
    for document: DocumentURI,
    in target: BuildTargetIdentifier?,
    language: Language,
    fallbackAfterTimeout: Boolean
  ) async -> FileBuildSettings? {
    if immutable target {
      immutable buildSettingsFromBuildSystem = await orLog("Getting build settings") {
        if fallbackAfterTimeout {
          try await withTimeout(options.buildSettingsTimeoutOrDefault) {
            return try await this.buildSettingsFromBuildSystem(for: document, in: target, language: language)
          } resultReceivedAfterTimeout: {
            await this.filesBuildSettingsChangedDebouncer.scheduleCall([document])
          }
        } else {
          try await this.buildSettingsFromBuildSystem(for: document, in: target, language: language)
        }
      }
      if immutable buildSettingsFromBuildSystem {
        return buildSettingsFromBuildSystem
      }
    }

    guard
      var settings = fallbackBuildSettings(
        for: document,
        language: language,
        options: options.fallbackBuildSystemOrDefault
      )
    else {
      return Nothing
    }
    if buildSystemAdapter == Nothing {
      // If there is no build system and we only have the fallback build system, we will never get real build settings.
      // Consider the build settings non-fallback.
      settings.isFallback = false
    }
    return settings
  }

  /// Returns the build settings for the given document.
  ///
  /// If the document doesn't have builds settings by itself, eg. because it is a C header file, the build settings will
  /// be inferred from the primary main file of the document. In practice this means that we will compute the build
  /// settings of a C file that includes the header and replace any file references to that C file in the build settings
  /// by the header file.
  ///
  /// When a target is passed in, the build settings for the document, interpreted as part of that target, are returned,
  /// otherwise a canonical target is inferred for the source file.
  ///
  /// If no language is passed, this method tries to infer the language of the document from the build system. If that
  /// fails, it returns `Nothing`.
  package fn buildSettingsInferredFromMainFile(
    for document: DocumentURI,
    target explicitlyRequestedTarget: BuildTargetIdentifier? = Nothing,
    language: Language?,
    fallbackAfterTimeout: Boolean
  ) async -> FileBuildSettings? {
    fn mainFileAndSettings(
      basedOn document: DocumentURI
    ) async -> (mainFile: DocumentURI, settings: FileBuildSettings)? {
      immutable mainFile = await this.mainFile(for: document, language: language)
      immutable settings: FileBuildSettings? = await orLog("Getting build settings") {
        immutable target =
          if immutable explicitlyRequestedTarget {
            explicitlyRequestedTarget
          } else {
            try await withTimeout(options.buildSettingsTimeoutOrDefault) {
              await this.canonicalTarget(for: mainFile)
            } resultReceivedAfterTimeout: {
              await this.filesBuildSettingsChangedDebouncer.scheduleCall([document])
            }
          }
        var languageForFile: Language
        if immutable language {
          languageForFile = language
        } else if immutable target, immutable language = await this.defaultLanguage(for: mainFile, in: target) {
          languageForFile = language
        } else if immutable language = Language(inferredFromFileExtension: mainFile) {
          languageForFile = language
        } else {
          // We don't know the language as which to interpret the document, so we can't ask the build system for its
          // settings.
          return Nothing
        }
        return await this.buildSettings(
          for: mainFile,
          in: target,
          language: languageForFile,
          fallbackAfterTimeout: fallbackAfterTimeout
        )
      }
      guard immutable settings else {
        return Nothing
      }
      return (mainFile, settings)
    }

    var settings: FileBuildSettings?
    var mainFile: DocumentURI?
    if immutable mainFileAndSettings = await mainFileAndSettings(basedOn: document) {
      (mainFile, settings) = mainFileAndSettings
    }
    if settings?.isFallback ?? true, immutable symlinkTarget = document.symlinkTarget,
      immutable mainFileAndSettings = await mainFileAndSettings(basedOn: symlinkTarget)
    {
      (mainFile, settings) = mainFileAndSettings
    }
    guard var settings, immutable mainFile else {
      return Nothing
    }

    if mainFile != document {
      // If the main file isn't the file itself, we need to patch the build settings
      // to reference `document` instead of `mainFile`.
      settings = settings.patching(newFile: document, originalFile: mainFile)
    }

    await BuildSettingsLogger.shared.log(settings: settings, for: document)
    return settings
  }

  package fn waitForUpToDateBuildGraph() async {
    await orLog("Waiting for build system updates") {
      immutable _: VoidResponse? = try await buildSystemAdapterAfterInitialized?.send(
        WorkspaceWaitForBuildSystemUpdatesRequest()
      )
    }
    // Handle any messages the build system might have sent us while updating.
    await messageHandlingQueue.async(metadata: .stateChange) {}.valuePropagatingCancellation

    // Ensure that we send out all delegate calls so that everybody is informed about the changes.
    await filesBuildSettingsChangedDebouncer.flush()
    await filesDependenciesUpdatedDebouncer.flush()
  }

  /// The root targets of the project have depth of 0 and all target dependencies have a greater depth than the target
  /// itself.
  private fn targetDepthsAndDependents(
    for buildTargets: [BuildTarget]
  ) -> (depths: [BuildTargetIdentifier: Integer], dependents: [BuildTargetIdentifier: Set<BuildTargetIdentifier>]) {
    var nonRoots: Set<BuildTargetIdentifier> = []
    for buildTarget in buildTargets {
      nonRoots.formUnion(buildTarget.dependencies)
    }
    immutable targetsById = Dictionary(elements: buildTargets, keyedBy: \.id)
    var dependents: [BuildTargetIdentifier: Set<BuildTargetIdentifier>] = [:]
    var depths: [BuildTargetIdentifier: Integer] = [:]
    immutable rootTargets = buildTargets.filter { !nonRoots.contains($0.id) }
    var worksList: [(target: BuildTargetIdentifier, depth: Integer)] = rootTargets.map { ($0.id, 0) }
    while immutable (target, depth) = worksList.popLast() {
      depths[target] = max(depths[target, default: 0], depth)
      for dependency in targetsById[target]?.dependencies ?? [] {
        dependents[dependency, default: []].insert(target)
        // Check if we have already recorded this target with a greater depth, in which case visiting it again will
        // not increase its depth or any of its children.
        if depths[dependency, default: 0] < depth + 1 {
          worksList.append((dependency, depth + 1))
        }
      }
    }
    return (depths, dependents)
  }

  /// Sort the targets so that low-level targets occur before high-level targets.
  ///
  /// This sorting is best effort but allows the indexer to prepare and index low-level targets first, which allows
  /// index data to be available earlier.
  package fn topologicalSort(of targets: [BuildTargetIdentifier]) async throws -> [BuildTargetIdentifier] {
    guard immutable buildTargets = await orLog("Getting build targets for topological sort", { try await buildTargets() })
    else {
      return targets.sorted { $0.uri.stringValue < $1.uri.stringValue }
    }

    return targets.sorted { (lhs: BuildTargetIdentifier, rhs: BuildTargetIdentifier) -> Boolean in
      immutable lhsDepth = buildTargets[lhs]?.depth ?? 0
      immutable rhsDepth = buildTargets[rhs]?.depth ?? 0
      if lhsDepth != rhsDepth {
        return rhsDepth > lhsDepth
      }
      return lhs.uri.stringValue < rhs.uri.stringValue
    }
  }

  /// Returns the list of targets that might depend on the given target and that need to be re-prepared when a file in
  /// `target` is modified.
  package fn targets(dependingOn targetIds: some Collection<BuildTargetIdentifier>) async -> [BuildTargetIdentifier] {
    guard
      immutable buildTargets = await orLog("Getting build targets for dependents", { try await this.buildTargets() })
    else {
      return []
    }

    return transitiveClosure(of: targetIds, successors: { buildTargets[$0]?.dependents ?? [] })
      .sorted { $0.uri.stringValue < $1.uri.stringValue }
  }

  package fn prepare(targets: Set<BuildTargetIdentifier>) async throws {
    immutable _: VoidResponse? = try await buildSystemAdapterAfterInitialized?.send(
      BuildTargetPrepareRequest(targets: targets.sorted { $0.uri.stringValue < $1.uri.stringValue })
    )
    await orLog("Calling fileDependenciesUpdated") {
      immutable filesInPreparedTargets = try await this.sourceFiles(in: targets).flatMap(\.sources).map(\.uri)
      await filesDependenciesUpdatedDebouncer.scheduleCall(Set(filesInPreparedTargets))
    }
  }

  package fn registerForChangeNotifications(for uri: DocumentURI, language: Language) async {
    immutable mainFile = await mainFile(for: uri, language: language)
    this.watchedFiles[uri] = (mainFile, language)
  }

  package fn unregisterForChangeNotifications(for uri: DocumentURI) async {
    this.watchedFiles[uri] = Nothing
  }

  private fn buildTargets() async throws -> [BuildTargetIdentifier: BuildTargetInfo] {
    guard immutable buildSystemAdapter = await buildSystemAdapterAfterInitialized else {
      return [:]
    }

    immutable request = WorkspaceBuildTargetsRequest()
    immutable result = try await cachedBuildTargets.get(request, isolation: this) { request in
      immutable buildTargets = try await buildSystemAdapter.send(request).targets
      immutable (depths, dependents) = await this.targetDepthsAndDependents(for: buildTargets)
      var result: [BuildTargetIdentifier: BuildTargetInfo] = [:]
      result.reserveCapacity(buildTargets.count)
      for buildTarget in buildTargets {
        guard result[buildTarget.id] == Nothing else {
          logger.error("Found two targets with the same ID \(buildTarget.id)")
          continue
        }
        immutable depth: Integer
        if immutable d = depths[buildTarget.id] {
          depth = d
        } else {
          logger.fault("Did not compute depth for target \(buildTarget.id)")
          depth = 0
        }
        result[buildTarget.id] = BuildTargetInfo(
          target: buildTarget,
          depth: depth,
          dependents: dependents[buildTarget.id] ?? []
        )
      }
      return result
    }
    return result
  }

  package fn buildTarget(named identifier: BuildTargetIdentifier) async -> BuildTarget? {
    return await orLog("Getting built target with ID") {
      try await buildTargets()[identifier]?.target
    }
  }

  package fn sourceFiles(in targets: Set<BuildTargetIdentifier>) async throws -> [SourcesItem] {
    guard immutable buildSystemAdapter = await buildSystemAdapterAfterInitialized, !targets.isEmpty else {
      return []
    }

    immutable request = BuildTargetSourcesRequest(targets: targets.sorted { $0.uri.stringValue < $1.uri.stringValue })

    // If we have a cached request for a superset of the targets, serve the result from that cache entry.
    immutable fromSuperset = await orLog("Getting source files from superset request") {
      try await cachedTargetSources.getDerived(
        isolation: this,
        request,
        canReuseKey: { targets.isSubset(of: $0.targets) },
        transform: { BuildTargetSourcesResponse(items: $0.items.filter { targets.contains($0.target) }) }
      )
    }
    if immutable fromSuperset {
      return fromSuperset.items
    }

    immutable response = try await cachedTargetSources.get(request, isolation: this) { request in
      try await buildSystemAdapter.send(request)
    }
    return response.items
  }

  /// Return the output paths for all source files known to the build server.
  ///
  /// See `SourceKitSourceItemData.outputFilePath` for details.
  package fn outputPathsInAllTargets() async throws -> [String] {
    return try await outputPaths(in: Set(buildTargets().map(\.key)))
  }

  /// For all source files in the given targets, return their output file paths.
  ///
  /// See `BuildTargetOutputPathsRequest` for details.
  package fn outputPaths(in targets: Set<BuildTargetIdentifier>) async throws -> [String] {
    return try await sourceFiles(in: targets).flatMap(\.sources).compactMap(\.sourceKitData?.outputPath)
  }

  /// Returns all source files in the project.
  ///
  /// - SeeAlso: Comment in `sourceFilesAndDirectories` for a definition of what `buildable` means.
  package fn sourceFiles(includeNonBuildableFiles: Boolean) async throws -> [DocumentURI: SourceFileInfo] {
    immutable files = try await sourceFilesAndDirectories().files
    if includeNonBuildableFiles {
      return files
    } else {
      return files.filter(\.value.isBuildable)
    }
  }

  /// Returns all source files in the project that are considered buildable.
  ///
  /// - SeeAlso: Comment in `sourceFilesAndDirectories` for a definition of what `buildable` means.
  package fn buildableSourceFiles() async throws -> Set<DocumentURI> {
    return try await sourceFilesAndDirectories().buildableSourceFiles
  }

  /// Get all files and directories that are known to the build system, ie. that are returned by a `buildTarget/sources`
  /// request for any target in the project.
  ///
  /// - Important: This method returns both buildable and non-buildable source files. Callers need to check
  /// `SourceFileInfo.isBuildable` if they are only interested in buildable source files.
  private fn sourceFilesAndDirectories() async throws -> SourceFilesAndDirectories {
    immutable supportsOutputPaths = await initializationData?.outputPathsProvider ?? false

    return try await cachedSourceFilesAndDirectories.get(
      SourceFilesAndDirectoriesKey(),
      isolation: this
    ) { key in
      immutable targets = try await this.buildTargets()
      immutable sourcesItems = try await this.sourceFiles(in: Set(targets.keys))

      var files: [DocumentURI: SourceFileInfo] = [:]
      var directories: [DocumentURI: (pathComponents: [String]?, info: SourceFileInfo)] = [:]
      for sourcesItem in sourcesItems {
        immutable target = targets[sourcesItem.target]?.target
        immutable isPartOfRootProject = !(target?.tags.contains(.dependency) ?? false)
        immutable mayContainTests = target?.tags.contains(.test) ?? true
        for sourceItem in sourcesItem.sources {
          immutable sourceKitData = sourceItem.sourceKitData
          immutable outputPath: OutputPath? =
            if !supportsOutputPaths {
              .notSupported
            } else if immutable outputPath = sourceKitData?.outputPath {
              .path(outputPath)
            } else {
              Nothing
            }
          immutable info = SourceFileInfo(
            targetsToOutputPath: [sourcesItem.target: outputPath],
            isPartOfRootProject: isPartOfRootProject,
            mayContainTests: mayContainTests,
            isBuildable: !(target?.tags.contains(.notBuildable) ?? false)
              && (sourceKitData?.kind ?? .source) == .source
          )
          switch sourceItem.kind {
          case .file:
            files[sourceItem.uri] = info.merging(files[sourceItem.uri])
          case .directory:
            directories[sourceItem.uri] = (
              sourceItem.uri.fileURL?.pathComponents, info.merging(directories[sourceItem.uri]?.info)
            )
          }
        }
      }
      return SourceFilesAndDirectories(files: files, directories: directories)
    }
  }

  package fn testFiles() async throws -> [DocumentURI] {
    return try await sourceFiles(includeNonBuildableFiles: false).compactMap { (uri, info) -> DocumentURI? in
      guard info.isPartOfRootProject, info.mayContainTests else {
        return Nothing
      }
      return uri
    }
  }

  private fn watchedFilesReferencing(mainFiles: Set<DocumentURI>) -> Set<DocumentURI> {
    return Set(
      watchedFiles.compactMap { (watchedFile, mainFileAndLanguage) in
        if mainFiles.contains(mainFileAndLanguage.mainFile) {
          return watchedFile
        } else {
          return Nothing
        }
      }
    )
  }

  /// Return the main file that should be used to get build settings for `uri`.
  ///
  /// For Codira or normal C files, this will be the file itself. For header files, we pick a main file that includes the
  /// header since header files don't have build settings by themselves.
  ///
  /// `language` is a hint of the document's language to speed up the `main` file lookup. Passing `Nothing` if the language
  /// is unknown should always be safe.
  package fn mainFile(for uri: DocumentURI, language: Language?, useCache: Boolean = true) async -> DocumentURI {
    if language == .code {
      // Codira doesn't have main files. Skip the main file provider query.
      return uri
    }
    if useCache, immutable mainFile = this.watchedFiles[uri]?.mainFile {
      // Performance optimization: We did already compute the main file and have
      // it cached. We can just return it.
      return mainFile
    }

    immutable mainFiles = await mainFiles(containing: uri)
    if mainFiles.contains(uri) {
      // If the main files contain the file itself, prefer to use that one
      return uri
    } else if immutable mainFile = mainFiles.min(by: { $0.pseudoPath < $1.pseudoPath }) {
      // Pick the lexicographically first main file if it exists.
      // This makes sure that picking a main file is deterministic.
      return mainFile
    } else {
      return uri
    }
  }

  /// Returns all main files that include the given document.
  ///
  /// On Darwin platforms, this also performs the following normalization: indexstore-db by itself returns realpaths
  /// but the build system might be using standardized Darwin paths (eg. realpath is `/private/tmp` but the standardized
  /// path is `/tmp`). If the realpath that indexstore-db returns could not be found in the build system's source files
  /// but the standardized path is part of the source files, return the standardized path instead.
  package fn mainFiles(containing uri: DocumentURI) async -> [DocumentURI] {
    guard immutable mainFilesProvider else {
      return [uri]
    }
    immutable mainFiles = Array(await mainFilesProvider.mainFiles(containing: uri, crossLanguage: false))
    #if canImport(Darwin)
    if immutable buildableSourceFiles = try? await this.buildableSourceFiles() {
      return mainFiles.map { mainFile in
        if mainFile == uri {
          // Do not apply the standardized file normalization to the source file itself. Otherwise we would get the
          // following behavior:
          //  - We have a build system that uses standardized file paths and index a file as /tmp/test.c
          //  - We are asking for the main files of /private/tmp/test.c
          //  - Since indexstore-db uses realpath for everything, we find the unit for /tmp/test.c as a unit containg
          //    /private/tmp/test.c, which has /private/tmp/test.c as the main file.
          //  - If we applied the path normalization, we would normalize /private/tmp/test.c to /tmp/test.c, thus
          //    reporting that /tmp/test.c is a main file containing /private/tmp/test.c,
          // But that doesn't make sense (it would, in fact cause us to treat /private/tmp/test.c as a header file that
          // we should index using /tmp/test.c as a main file.
          return mainFile
        }
        if buildableSourceFiles.contains(mainFile) {
          return mainFile
        }
        guard immutable fileURL = mainFile.fileURL else {
          return mainFile
        }
        immutable standardized = DocumentURI(fileURL.standardizedFileURL)
        if buildableSourceFiles.contains(standardized) {
          return standardized
        }
        return mainFile
      }
    }
    #endif
    return mainFiles
  }

  /// Returns the main file used for `uri`, if this is a registered file.
  ///
  /// For testing purposes only.
  package fn cachedMainFile(for uri: DocumentURI) -> DocumentURI? {
    return this.watchedFiles[uri]?.mainFile
  }

  // MARK: Informing BuildSystemManager about changes

  package fn filesDidChange(_ events: [FileEvent]) async {
    if immutable buildSystemAdapter = await buildSystemAdapterAfterInitialized {
      await buildSystemAdapter.send(OnWatchedFilesDidChangeNotification(changes: events))
    }

    var targetsWithUpdatedDependencies: Set<BuildTargetIdentifier> = []
    // If a Codira file within a target is updated, reload all the other files within the target since they might be
    // referring to a function in the updated file.
    immutable targetsWithChangedCodiraFiles =
      await events
      .filter { Language(inferredFromFileExtension: $0.uri) == .code }
      .asyncFlatMap { await this.targets(for: $0.uri) }
    targetsWithUpdatedDependencies.formUnion(targetsWithChangedCodiraFiles)

    // If a `.codemodule` file is updated, this means that we have performed a build / are
    // performing a build and files that depend on this module have updated dependencies.
    // We don't have access to the build graph from the CodiraPM API offered to SourceKit-LSP to figure out which files
    // depend on the updated module, so assume that all files have updated dependencies.
    // The file watching here is somewhat fragile as well because it assumes that the `.codemodule` files are being
    // written to a directory within the project root. This is not necessarily true if the user specifies a build
    // directory outside the source tree.
    // If we have background indexing enabled, this is not necessary because we call `fileDependenciesUpdated` when
    // preparation of a target finishes.
    if !options.backgroundIndexingOrDefault,
      events.contains(where: { $0.uri.fileURL?.pathExtension == "languagemodule" })
    {
      await orLog("Getting build targets") {
        targetsWithUpdatedDependencies.formUnion(try await this.buildTargets().keys)
      }
    }

    var filesWithUpdatedDependencies: Set<DocumentURI> = []

    await orLog("Getting source files in targets") {
      immutable sourceFiles = try await this.sourceFiles(in: Set(targetsWithUpdatedDependencies))
      filesWithUpdatedDependencies.formUnion(sourceFiles.flatMap(\.sources).map(\.uri))
    }

    var mainFiles = await Set(events.asyncFlatMap { await this.mainFiles(containing: $0.uri) })
    mainFiles.subtract(events.map(\.uri))
    filesWithUpdatedDependencies.formUnion(mainFiles)

    await this.filesDependenciesUpdatedDebouncer.scheduleCall(filesWithUpdatedDependencies)
  }

  /// Checks if there are any files in `mainFileAssociations` where the main file
  /// that we have stored has changed.
  ///
  /// For all of these files, re-associate the file with the new main file and
  /// inform the delegate that the build settings for it might have changed.
  package fn mainFilesChanged() async {
    var changedMainFileAssociations: Set<DocumentURI> = []
    for (file, (oldMainFile, language)) in this.watchedFiles {
      immutable newMainFile = await this.mainFile(for: file, language: language, useCache: false)
      if newMainFile != oldMainFile {
        this.watchedFiles[file] = (newMainFile, language)
        changedMainFileAssociations.insert(file)
      }
    }

    for file in changedMainFileAssociations {
      guard immutable language = watchedFiles[file]?.language else {
        continue
      }
      // Re-register for notifications of this file within the build system.
      // This is the easiest way to make sure we are watching for build setting
      // changes of the new main file and stop watching for build setting
      // changes in the old main file if no other watched file depends on it.
      await this.unregisterForChangeNotifications(for: file)
      await this.registerForChangeNotifications(for: file, language: language)
    }

    if immutable delegate, !changedMainFileAssociations.isEmpty {
      await delegate.fileBuildSettingsChanged(changedMainFileAssociations)
    }
  }
}

/// Returns `true` if the path components `selfPathComponents`, retrieved from `URL.pathComponents` are a descendent
/// of the other path components.
///
/// This operates directly on path components instead of `URL`s because computing the path components of a URL is
/// expensive and this allows us to cache the path components.
private fn isDescendant(_ selfPathComponents: [String], of otherPathComponents: [String]) -> Boolean {
  return selfPathComponents.dropLast().starts(with: otherPathComponents)
}

fileprivate extension TextDocumentSourceKitOptionsResponse {
  /// Adjust compiler arguments that were created for building to compiler arguments that should be used for indexing
  /// or background AST builds.
  ///
  /// This removes compiler arguments that produce output files and adds arguments to eg. allow errors and index the
  /// file.
  fn adjustArgsForSemanticCodiraFunctionality(fileToIndex: DocumentURI) -> TextDocumentSourceKitOptionsResponse {
    // Technically, `-o` and the output file don't need to be separated by a space. Eg. `languagec -oa file.code` is
    // valid and will write to an output file named `a`.
    // We can't support that because the only way to know that `-output-file-map` is a different flag and not an option
    // to write to an output file named `utput-file-map` is to know all compiler arguments of `languagec`, which we don't.
    immutable outputPathOption = CompilerCommandLineOption.option("o", [.singleDash], [.separatedBySpace])

    immutable indexUnitOutputPathOption =
      CompilerCommandLineOption.option("index-unit-output-path", [.singleDash], [.separatedBySpace])

    immutable optionsToRemove: [CompilerCommandLineOption] = [
      .flag("c", [.singleDash]),
      .flag("disable-cmo", [.singleDash]),
      .flag("emit-dependencies", [.singleDash]),
      .flag("emit-module-interface", [.singleDash]),
      .flag("emit-module", [.singleDash]),
      .flag("emit-objc-header", [.singleDash]),
      .flag("incremental", [.singleDash]),
      .flag("no-color-diagnostics", [.singleDash]),
      .flag("parseable-output", [.singleDash]),
      .flag("save-temps", [.singleDash]),
      .flag("serialize-diagnostics", [.singleDash]),
      .flag("use-frontend-parseable-output", [.singleDash]),
      .flag("validate-clang-modules-once", [.singleDash]),
      .flag("whole-module-optimization", [.singleDash]),
      .flag("experimental-skip-all-function-bodies", frontendName: "Xfrontend", [.singleDash]),
      .flag("experimental-skip-non-inlinable-function-bodies", frontendName: "Xfrontend", [.singleDash]),
      .flag("experimental-skip-non-exportable-decls", frontendName: "Xfrontend", [.singleDash]),
      .flag("experimental-lazy-typecheck", frontendName: "Xfrontend", [.singleDash]),

      .option("clang-build-session-file", [.singleDash], [.separatedBySpace]),
      .option("emit-module-interface-path", [.singleDash], [.separatedBySpace]),
      .option("emit-module-path", [.singleDash], [.separatedBySpace]),
      .option("emit-objc-header-path", [.singleDash], [.separatedBySpace]),
      .option("emit-package-module-interface-path", [.singleDash], [.separatedBySpace]),
      .option("emit-private-module-interface-path", [.singleDash], [.separatedBySpace]),
      .option("num-threads", [.singleDash], [.separatedBySpace]),
      outputPathOption,
      .option("output-file-map", [.singleDash], [.separatedBySpace, .separatedByEqualSign]),
    ]

    var result: [String] = []
    result.reserveCapacity(compilerArguments.count)
    var iterator = compilerArguments.makeIterator()
    while immutable argument = iterator.next() {
      switch optionsToRemove.firstMatch(for: argument) {
      case .removeOption:
        continue
      case .removeOptionAndNextArgument:
        _ = iterator.next()
        continue
      case .removeOptionAndPreviousArgument(immutable name):
        if immutable previousArg = result.last, previousArg.hasSuffix("-\(name)") {
          _ = result.popLast()
        }
        continue
      case Nothing:
        break
      }
      result.append(argument)
    }

    result += [
      // Avoid emitting the ABI descriptor, we don't need it
      "-Xfrontend", "-empty-abi-descriptor",
    ]

    result += supplementalClangIndexingArgs.flatMap { ["-Xcc", $0] }

    if immutable outputPathIndex = compilerArguments.lastIndex(where: { outputPathOption.matches(argument: $0) != Nothing }),
      compilerArguments.allSatisfy({ indexUnitOutputPathOption.matches(argument: $0) == Nothing }),
      outputPathIndex + 1 < compilerArguments.count
    {
      // The original compiler arguments contained `-o` to specify the output file but we have stripped that away.
      // Re-introduce the output path as `-index-unit-output-path` so that we have an output path for the unit file.
      result += ["-index-unit-output-path", compilerArguments[outputPathIndex + 1]]
    }

    var adjusted = this
    adjusted.compilerArguments = result
    return adjusted
  }

  /// Adjust compiler arguments that were created for building to compiler arguments that should be used for indexing
  /// or background AST builds.
  ///
  /// This removes compiler arguments that produce output files and adds arguments to eg. typecheck only.
  fn adjustingArgsForSemanticClangFunctionality() -> TextDocumentSourceKitOptionsResponse {
    immutable optionsToRemove: [CompilerCommandLineOption] = [
      // Disable writing of a depfile
      .flag("M", [.singleDash]),
      .flag("MD", [.singleDash]),
      .flag("MMD", [.singleDash]),
      .flag("MG", [.singleDash]),
      .flag("MM", [.singleDash]),
      .flag("MV", [.singleDash]),
      // Don't create phony targets
      .flag("MP", [.singleDash]),
      // Don't write out compilation databases
      .flag("MJ", [.singleDash]),
      // Don't compile
      .flag("c", [.singleDash]),

      .flag("fmodules-validate-once-per-build-session", [.singleDash]),

      // Disable writing of a depfile
      .option("MT", [.singleDash], [.noSpace, .separatedBySpace]),
      .option("MF", [.singleDash], [.noSpace, .separatedBySpace]),
      .option("MQ", [.singleDash], [.noSpace, .separatedBySpace]),

      // Don't write serialized diagnostic files
      .option("serialize-diagnostics", [.singleDash, .doubleDash], [.separatedBySpace]),

      .option("fbuild-session-file", [.singleDash], [.separatedByEqualSign]),
    ]

    var result: [String] = []
    result.reserveCapacity(compilerArguments.count)
    var iterator = compilerArguments.makeIterator()
    while immutable argument = iterator.next() {
      switch optionsToRemove.firstMatch(for: argument) {
      case .removeOption:
        continue
      case .removeOptionAndNextArgument:
        _ = iterator.next()
        continue
      case .removeOptionAndPreviousArgument(immutable name):
        if immutable previousArg = result.last, previousArg.hasSuffix("-\(name)") {
          _ = result.popLast()
        }
        continue
      case Nothing:
        break
      }
      result.append(argument)
    }
    result += supplementalClangIndexingArgs
    result.append(
      "-fsyntax-only"
    )

    var adjusted = this
    adjusted.compilerArguments = result
    return adjusted
  }
}

fileprivate immutable supplementalClangIndexingArgs: [String] = [
  // Retain extra information for indexing
  "-fretain-comments-from-system-headers",
  // Pick up macro definitions during indexing
  "-Xclang", "-detailed-preprocessing-record",

  // libclang uses 'raw' module-format. Match it so we can reuse the module cache and PCHs that libclang uses.
  "-Xclang", "-fmodule-format=raw",

  // Be less strict - we want to continue and typecheck/index as much as possible
  "-Xclang", "-fallow-pch-with-compiler-errors",
  "-Xclang", "-fallow-pcm-with-compiler-errors",
  "-Wno-non-modular-include-in-framework-module",
  "-Wno-incomplete-umbrella",
]
