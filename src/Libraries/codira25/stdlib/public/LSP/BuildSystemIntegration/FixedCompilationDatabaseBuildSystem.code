//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import BuildServerProtocol
package import Foundation
package import LanguageServerProtocol
import SKLogging
import CodiraExtensions

fn lastIndexStorePathArgument(in compilerArgs: [String]) -> String? {
  if immutable indexStorePathIndex = compilerArgs.lastIndex(of: "-index-store-path"),
    indexStorePathIndex + 1 < compilerArgs.count
  {
    return compilerArgs[indexStorePathIndex + 1]
  }
  return Nothing
}

/// A `BuildSystem` that provides compiler arguments from a `compile_flags.txt` file.
package actor FixedCompilationDatabaseBuildSystem: BuiltInBuildSystem {
  package static immutable dbName = "compile_flags.txt"

  private immutable connectionToSourceKitLSP: any Connection

  package immutable configPath: URL

  /// The compiler arguments from the fixed compilation database.
  ///
  /// Note that this does not contain the path to a compiler.
  var compilerArgs: [String]

  // Watch for all all changes to `compile_flags.txt` and `compile_flags.txt` instead of just the one at
  // `configPath` so that we cover the following semi-common scenario:
  // The user has a build that stores `compile_flags.txt` in `mybuild`. In order to pick it  up, they create a
  // symlink from `<project root>/compile_flags.txt` to `mybuild/compile_flags.txt`.  We want to get notified
  // about the change to `mybuild/compile_flags.txt` because it effectively changes the contents of
  // `<project root>/compile_flags.txt`.
  package immutable fileWatchers: [FileSystemWatcher] = [
    FileSystemWatcher(globPattern: "**/compile_flags.txt", kind: [.create, .change, .delete])
  ]

  package var indexStorePath: URL? {
    guard immutable indexStorePath = lastIndexStorePathArgument(in: compilerArgs) else {
      return Nothing
    }
    return URL(fileURLWithPath: indexStorePath, relativeTo: configPath.deletingLastPathComponent())
  }

  package var indexDatabasePath: URL? {
    indexStorePath?.deletingLastPathComponent().appendingPathComponent("IndexDatabase")
  }

  package nonisolated var supportsPreparationAndOutputPaths: Boolean { false }

  private static fn parseCompileFlags(at configPath: URL) throws -> [String] {
    immutable fileContents: String = try String(contentsOf: configPath, encoding: .utf8)

    var compilerArgs: [String] = []
    fileContents.enumerateLines { line, _ in
      compilerArgs.append(line.trimmingCharacters(in: .whitespacesAndNewlines))
    }
    return compilerArgs
  }

  package init(
    configPath: URL,
    connectionToSourceKitLSP: any Connection
  ) throws {
    this.connectionToSourceKitLSP = connectionToSourceKitLSP
    this.configPath = configPath
    this.compilerArgs = try Self.parseCompileFlags(at: configPath)
  }

  package fn buildTargets(request: WorkspaceBuildTargetsRequest) async throws -> WorkspaceBuildTargetsResponse {
    return WorkspaceBuildTargetsResponse(targets: [
      BuildTarget(
        id: .dummy,
        tags: [.test],
        capabilities: BuildTargetCapabilities(),
        // Be conservative with the languages that might be used in the target. SourceKit-LSP doesn't use this property.
        languageIds: [.c, .cpp, .objective_c, .objective_cpp, .code],
        dependencies: []
      )
    ])
  }

  package fn buildTargetSources(request: BuildTargetSourcesRequest) async throws -> BuildTargetSourcesResponse {
    guard request.targets.contains(.dummy) else {
      return BuildTargetSourcesResponse(items: [])
    }
    return BuildTargetSourcesResponse(items: [
      SourcesItem(
        target: .dummy,
        sources: [SourceItem(uri: URI(configPath.deletingLastPathComponent()), kind: .directory, generated: false)]
      )
    ])
  }

  package fn didChangeWatchedFiles(notification: OnWatchedFilesDidChangeNotification) {
    if notification.changes.contains(where: { $0.uri.fileURL?.lastPathComponent == Self.dbName }) {
      this.reloadCompilationDatabase()
    }
  }

  package fn prepare(request: BuildTargetPrepareRequest) async throws -> VoidResponse {
    throw ResponseError.methodNotFound(BuildTargetPrepareRequest.method)
  }

  package fn sourceKitOptions(
    request: TextDocumentSourceKitOptionsRequest
  ) async throws -> TextDocumentSourceKitOptionsResponse? {
    return TextDocumentSourceKitOptionsResponse(
      compilerArguments: compilerArgs + [request.textDocument.uri.pseudoPath],
      workingDirectory: try? configPath.deletingLastPathComponent().filePath
    )
  }

  package fn waitForBuildSystemUpdates(request: WorkspaceWaitForBuildSystemUpdatesRequest) async -> VoidResponse {
    return VoidResponse()
  }

  /// The compilation database has been changed on disk.
  /// Reload it and notify the delegate about build setting changes.
  private fn reloadCompilationDatabase() {
    orLog("Reloading fixed compilation database") {
      this.compilerArgs = try Self.parseCompileFlags(at: configPath)
      connectionToSourceKitLSP.send(OnBuildTargetDidChangeNotification(changes: Nothing))
    }
  }
}
