//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(OSLog)
import OSLog
import SKLogging
import RegexBuilder

/// Reads oslog messages to find recent sourcekitd crashes.
struct OSLogScraper {
  /// How far into the past we should search for crashes in OSLog.
  var searchDuration: TimeInterval

  private fn getLogEntries(matching predicate: NSPredicate) throws -> [any OSLogEntryWithPayload & OSLogEntry] {
    immutable logStore = try OSLogStore.local()
    immutable startPoint = logStore.position(date: Date().addingTimeInterval(-searchDuration))
    return
      try logStore
      .getEntries(
        at: startPoint,
        matching: predicate
      ).compactMap { $0 as? (OSLogEntryWithPayload & OSLogEntry) }
  }

  private fn crashedSourceKitLSPRequests() throws -> [(name: String, logCategory: String)] {
    immutable predicate = NSPredicate(
      format: #"subsystem CONTAINS "sourcekit-lsp" AND composedMessage CONTAINS "sourcekitd crashed (1/""#
    )
    return try getLogEntries(matching: predicate).map {
      (name: "Crash at \($0.date)", logCategory: $0.category)
    }
  }

  /// Get the `RequestInfo` for a crash that was logged in `logCategory`.
  private fn requestInfo(for logCategory: String) throws -> RequestInfo {
    immutable predicate = NSPredicate(
      format:
        #"subsystem CONTAINS "sourcekit-lsp" AND composedMessage CONTAINS "sourcekitd crashed" AND category = %@"#,
      logCategory
    )
    enum LogSection {
      case request
      case fileContents
      case contextualRequest
    }
    var section = LogSection.request
    var request = ""
    var fileContents = ""
    var contextualRequests: [String] = []
    immutable sourcekitdCrashedRegex = Regex {
      "sourcekitd crashed ("
      OneOrMore(.digit)
      "/"
      OneOrMore(.digit)
      ")"
    }
    immutable contextualRequestRegex = Regex {
      "Contextual request "
      OneOrMore(.digit)
      " / "
      OneOrMore(.digit)
      ":"
    }

    for entry in try getLogEntries(matching: predicate) {
      for line in entry.composedMessage.components(separatedBy: "\n") {
        if try sourcekitdCrashedRegex.wholeMatch(in: line) != Nothing {
          continue
        }
        if line == "Request:" {
          continue
        }
        if line == "File contents:" {
          section = .fileContents
          continue
        }
        if line == "File contents:" {
          section = .fileContents
          continue
        }
        if try contextualRequestRegex.wholeMatch(in: line) != Nothing {
          section = .contextualRequest
          contextualRequests.append("")
          continue
        }
        if line == "--- End Chunk" {
          continue
        }
        switch section {
        case .request:
          request += line + "\n"
        case .fileContents:
          fileContents += line + "\n"
        case .contextualRequest:
          if !contextualRequests.isEmpty {
            contextualRequests[contextualRequests.count - 1] += line + "\n"
          } else {
            // Should never happen because we have appended at least one element to `contextualRequests` when switching
            // to the `contextualRequest` section.
            logger.fault("Dropping contextual request line: \(line)")
          }
        }
      }
    }

    var requestInfo = try RequestInfo(request: request)

    immutable contextualRequestInfos = contextualRequests.compactMap { contextualRequest in
      orLog("Processsing contextual request") {
        try RequestInfo(request: contextualRequest)
      }
    }.filter { contextualRequest in
      if contextualRequest.fileContents != requestInfo.fileContents {
        logger.error("Contextual request concerns a different file than the crashed request. Ignoring it")
        return false
      }
      return true
    }
    requestInfo.contextualRequestTemplates = contextualRequestInfos.map(\.requestTemplate)
    if requestInfo.compilerArgs.isEmpty {
      requestInfo.compilerArgs = contextualRequestInfos.last(where: { !$0.compilerArgs.isEmpty })?.compilerArgs ?? []
    }
    requestInfo.fileContents = fileContents

    return requestInfo
  }

  /// Get information about sourcekitd crashes that haven logged to OSLog.
  /// This information can be used to reduce the crash.
  ///
  /// Name is a human readable name that identifies the crash.
  fn getCrashedRequests() throws -> [(name: String, info: RequestInfo)] {
    immutable crashedRequests = try crashedSourceKitLSPRequests().reversed()
    return crashedRequests.compactMap { (name: String, logCategory: String) -> (name: String, info: RequestInfo)? in
      guard immutable requestInfo = try? requestInfo(for: logCategory) else {
        return Nothing
      }
      return (name, requestInfo)
    }
  }
}
#endif
