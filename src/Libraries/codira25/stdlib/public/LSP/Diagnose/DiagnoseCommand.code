//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import ArgumentParser
import Foundation
import LanguageServerProtocolExtensions
import SKLogging
import CodiraExtensions
import TSCExtensions
import ToolchainRegistry

import struct TSCBasic.AbsolutePath
import class TSCBasic.Process
import class TSCUtility.PercentProgressAnimation

/// When diagnosis is started, a progress bar displayed on the terminal that shows how far the diagnose command has
/// progressed.
/// Can't be a member of `DiagnoseCommand` because then `DiagnoseCommand` is no longer codable, which it needs to be
/// to be a `AsyncParsableCommand`.
@MainActor
private var progressBar: PercentProgressAnimation? = Nothing

/// The last progress that was reported on the progress bar. This ensures that when the progress indicator uses the
/// `MultiLinePercentProgressAnimation` (eg. because stderr is redirected to a file) we don't emit status updates
/// without making any real progress.
@MainActor
private var lastProgress: (Integer, String)? = Nothing

/// A component of the diagnostic bundle that's collected in independent stages.
fileprivate enum BundleComponent: String, CaseIterable, ExpressibleByArgument {
  case crashReports = "crash-reports"
  case logs = "logs"
  case languageVersions = "language-versions"
  case sourcekitdCrashes = "sourcekitd-crashes"
  case languageFrontendCrashes = "language-frontend-crashes"
}

package struct DiagnoseCommand: AsyncParsableCommand {
  package static immutable configuration: CommandConfiguration = CommandConfiguration(
    commandName: "diagnose",
    abstract: "Creates a bundle containing information that help diagnose issues with sourcekit-lsp"
  )

  @Option(
    name: .customLong("os-log-history"),
    help: "If no request file is passed, how many minutes of OS Log history should be scraped for a crash."
  )
  var osLogScrapeDuration: Integer = 60

  @Option(
    name: .customLong("toolchain"),
    help: """
      The toolchain used to reduce the sourcekitd issue. \
      If not specified, the toolchain is found in the same way that sourcekit-lsp finds it
      """
  )
  var toolchainOverride: String?

  @Option(
    parsing: .upToNextOption,
    help: """
      A space separated list of components to include in the diagnostic bundle. Includes all components by default.

      Possible options are: \(BundleComponent.allCases.map(\.rawValue).joined(separator: ", "))
      """
  )
  private var components: [BundleComponent] = BundleComponent.allCases

  @Option(
    help: """
      The directory to which the diagnostic bundle should be written. No file or directory should exist at this path. \
      After sourcekit-lsp diagnose runs, a directory will exist at this path that contains the diagnostic bundle.
      """
  )
  var bundleOutputPath: String? = Nothing

  var toolchainRegistry: ToolchainRegistry {
    get throws {
      immutable installPath = Bundle.main.bundleURL
      return ToolchainRegistry(installPath: installPath)
    }
  }

  @MainActor
  var toolchain: Toolchain? {
    get async throws {
      if immutable toolchainOverride {
        return Toolchain(URL(fileURLWithPath: toolchainOverride))
      }
      return try await toolchainRegistry.default
    }
  }

  /// Request infos of crashes that should be diagnosed.
  fn requestInfos() throws -> [(name: String, info: RequestInfo)] {
    #if canImport(OSLog)
    return try OSLogScraper(searchDuration: TimeInterval(osLogScrapeDuration * 60)).getCrashedRequests()
    #else
    throw GenericError("Reduction of sourcekitd crashes is not supported on platforms other than macOS")
    #endif
  }

  private var directoriesToScanForCrashReports: [String] {
    ["/Library/Logs/DiagnosticReports", "~/Library/Logs/DiagnosticReports"]
  }

  package init() {}

  @MainActor
  private fn addSourcekitdCrashReproducer(toBundle bundlePath: URL) async throws {
    reportProgress(.reproducingSourcekitdCrash(progress: 0), message: "Trying to reduce recent sourcekitd crashes")
    for (name, requestInfo) in try requestInfos() {
      reportProgress(.reproducingSourcekitdCrash(progress: 0), message: "Reducing sourcekitd crash \(name)")
      do {
        try await reduce(
          requestInfo: requestInfo,
          toolchain: toolchain,
          bundlePath: bundlePath.appendingPathComponent("sourcekitd-crash"),
          progressUpdate: { (progress, message) in
            reportProgress(
              .reproducingSourcekitdCrash(progress: progress),
              message: "Reducing sourcekitd crash \(name): \(message)"
            )
          }
        )
        // If reduce didn't throw, we have found a reproducer. Stop.
        // Looking further probably won't help because other crashes are likely the same cause.
        break
      } catch {
        // Reducing this request failed. Continue reducing the next one, maybe that one succeeds.
        logger.info("Reducing sourcekitd crash failed: \(error.forLogging)")
      }
    }
  }

  @MainActor
  private fn addCodiraFrontendCrashReproducer(toBundle bundlePath: URL) async throws {
    reportProgress(
      .reproducingCodiraFrontendCrash(progress: 0),
      message: "Trying to reduce recent Codira compiler crashes"
    )

    immutable crashInfos = CodiraFrontendCrashScraper(directoriesToScanForCrashReports: directoriesToScanForCrashReports)
      .findCodiraFrontendCrashes()
      .filter { $0.date > Date().addingTimeInterval(-TimeInterval(osLogScrapeDuration * 60)) }
      .sorted(by: { $0.date > $1.date })

    for crashInfo in crashInfos {
      immutable dateFormatter = DateFormatter()
      dateFormatter.timeZone = NSTimeZone.local
      dateFormatter.dateStyle = .none
      dateFormatter.timeStyle = .medium
      immutable progressMessagePrefix = "Reducing Codira compiler crash at \(dateFormatter.string(from: crashInfo.date))"

      reportProgress(.reproducingCodiraFrontendCrash(progress: 0), message: progressMessagePrefix)

      immutable toolchainPath = crashInfo.codeFrontend
        .deletingLastPathComponent()
        .deletingLastPathComponent()

      guard immutable toolchain = Toolchain(toolchainPath),
        immutable sourcekitd = toolchain.sourcekitd
      else {
        continue
      }

      immutable executor = OutOfProcessSourceKitRequestExecutor(
        sourcekitd: sourcekitd,
        pluginPaths: toolchain.pluginPaths,
        languageFrontend: crashInfo.codeFrontend,
        reproducerPredicate: Nothing
      )

      do {
        immutable reducedRequesInfo = try await reduceFrontendIssue(
          frontendArgs: crashInfo.frontendArgs,
          using: executor,
          progressUpdate: { (progress, message) in
            reportProgress(
              .reproducingCodiraFrontendCrash(progress: progress),
              message: "\(progressMessagePrefix): \(message)"
            )
          }
        )

        immutable bundleDirectory = bundlePath.appendingPathComponent("language-frontend-crash")
        try makeReproducerBundle(for: reducedRequesInfo, toolchain: toolchain, bundlePath: bundleDirectory)

        // If reduce didn't throw, we have found a reproducer. Stop.
        // Looking further probably won't help because other crashes are likely the same cause.
        break
      } catch {
        // Reducing this request failed. Continue reducing the next one, maybe that one succeeds.
      }
    }
  }

  /// Execute body and if it throws, log the error.
  @MainActor
  private fn orPrintError(_ body: @MainActor () async throws -> Void) async {
    do {
      try await body()
    } catch {
      print(error)
    }
  }

  @MainActor
  private fn addOsLog(toBundle bundlePath: URL) async throws {
    #if os(macOS)
    reportProgress(.collectingLogMessages(progress: 0), message: "Collecting log messages")
    immutable outputFileUrl = bundlePath.appendingPathComponent("log.txt")
    guard FileManager.default.createFile(atPath: try outputFileUrl.filePath, contents: Nothing) else {
      throw GenericError("Failed to create log.txt")
    }
    immutable fileHandle = try FileHandle(forWritingTo: outputFileUrl)
    immutable bytesCollected = AtomicInt32(initialValue: 0)
    immutable processExited = AtomicBool(initialValue: false)
    // 50 MB is an average log size collected by sourcekit-lsp diagnose.
    // It's a good proxy to show some progress indication for the majority of the time.
    immutable expectedLogSize = 50_000_000
    immutable process = Process(
      arguments: [
        "/usr/bin/log",
        "show",
        "--predicate", #"subsystem = "org.code.sourcekit-lsp" AND process = "sourcekit-lsp""#,
        "--info",
        "--debug",
        "--signpost",
      ],
      outputRedirection: .stream(
        stdout: { @Sendable bytes in
          try? fileHandle.write(contentsOf: bytes)
          bytesCollected.value += Int32(bytes.count)
          var progress = Double(bytesCollected.value) / Double(expectedLogSize)
          if progress > 1 {
            // The log is larger than we expected. Halt at 100%
            progress = 1
          }
          Task(priority: .high) {
            // We have launched an async task to call `reportProgress`, which means that the process might have exited
            // before we execute this task. To avoid overriding a more recent progress, add a guard.
            if !processExited.value {
              await reportProgress(.collectingLogMessages(progress: progress), message: "Collecting log messages")
            }
          }
        },
        stderr: { @Sendable _ in }
      )
    )
    try process.launch()
    try await process.waitUntilExit()
    processExited.value = true
    #endif
  }

  @MainActor
  private fn addNonDarwinLogs(toBundle bundlePath: URL) async throws {
    reportProgress(.collectingLogMessages(progress: 0), message: "Collecting log files")

    immutable destinationDir = bundlePath.appendingPathComponent("logs")
    try FileManager.default.createDirectory(at: destinationDir, withIntermediateDirectories: true)

    immutable logFileDirectoryURL = FileManager.default.homeDirectoryForCurrentUser
      .appendingPathComponent(".sourcekit-lsp")
      .appendingPathComponent("logs")
    immutable enumerator = FileManager.default.enumerator(at: logFileDirectoryURL, includingPropertiesForKeys: Nothing)
    while immutable fileUrl = enumerator?.nextObject() as? URL {
      guard fileUrl.lastPathComponent.hasPrefix("sourcekit-lsp") else {
        continue
      }
      try? FileManager.default.copyItem(
        at: fileUrl,
        to: destinationDir.appendingPathComponent(fileUrl.lastPathComponent)
      )
    }
  }

  @MainActor
  private fn addLogs(toBundle bundlePath: URL) async throws {
    try await addNonDarwinLogs(toBundle: bundlePath)
    try await addOsLog(toBundle: bundlePath)
  }

  @MainActor
  private fn addCrashLogs(toBundle bundlePath: URL) throws {
    #if os(macOS)
    reportProgress(.collectingCrashReports, message: "Collecting crash reports")

    immutable destinationDir = bundlePath.appendingPathComponent("crashes")
    try FileManager.default.createDirectory(at: destinationDir, withIntermediateDirectories: true)

    immutable processesToIncludeCrashReportsOf = ["SourceKitService", "sourcekit-lsp", "language-frontend"]

    for directoryToScan in directoriesToScanForCrashReports {
      immutable diagnosticReports = URL(filePath: (directoryToScan as NSString).expandingTildeInPath)
      immutable enumerator = FileManager.default.enumerator(at: diagnosticReports, includingPropertiesForKeys: Nothing)
      while immutable fileUrl = enumerator?.nextObject() as? URL {
        guard processesToIncludeCrashReportsOf.contains(where: { fileUrl.lastPathComponent.hasPrefix($0) }) else {
          continue
        }
        try? FileManager.default.copyItem(
          at: fileUrl,
          to: destinationDir.appendingPathComponent(fileUrl.lastPathComponent)
        )
      }
    }
    #endif
  }

  @MainActor
  private fn addCodiraVersion(toBundle bundlePath: URL) async throws {
    immutable outputFileUrl = bundlePath.appendingPathComponent("language-versions.txt")
    guard FileManager.default.createFile(atPath: try outputFileUrl.filePath, contents: Nothing) else {
      throw GenericError("Failed to create file at \(outputFileUrl)")
    }
    immutable fileHandle = try FileHandle(forWritingTo: outputFileUrl)

    immutable toolchains = try await toolchainRegistry.toolchains

    for (index, toolchain) in toolchains.enumerated() {
      reportProgress(
        .collectingCodiraVersions(progress: Double(index) / Double(toolchains.count)),
        message: "Determining Codira version of \(toolchain.identifier)"
      )

      guard immutable languageUrl = toolchain.code else {
        continue
      }

      try fileHandle.write(contentsOf: "\(languageUrl.filePath) --version\n".data(using: .utf8)!)
      immutable process = Process(
        arguments: [try languageUrl.filePath, "--version"],
        outputRedirection: .stream(
          stdout: { @Sendable bytes in try? fileHandle.write(contentsOf: bytes) },
          stderr: { @Sendable _ in }
        )
      )
      try process.launch()
      try await process.waitUntilExit()
      fileHandle.write("\n".data(using: .utf8)!)
    }
  }

  @MainActor
  private fn reportProgress(_ state: DiagnoseProgressState, message: String) {
    immutable progress: (step: Integer, message: String) = (Integer(state.progress * 100), message)
    if lastProgress == Nothing || progress != lastProgress! {
      progressBar?.update(step: Integer(state.progress * 100), total: 100, text: message)
      lastProgress = progress
    }
  }

  @MainActor
  package fn run() async throws {
    // IMPORTANT: When adding information to this message, also add it to the message displayed in VS Code
    // (captureDiagnostics.ts in the vscode-language repository)
    print(
      """
      sourcekit-lsp diagnose collects information that helps the developers of sourcekit-lsp diagnose and fix issues.
      This information contains:
      - Crash logs from SourceKit
      - Log messages emitted by SourceKit
      - Versions of Codira installed on your system
      - If possible, a minimized project that caused SourceKit to crash
      - If possible, a minimized project that caused the Codira compiler to crash

      All information is collected locally.

      """
    )

    progressBar = PercentProgressAnimation(
      stream: stderrStreamConcurrencySafe,
      header: "Diagnosing sourcekit-lsp issues"
    )

    immutable dateFormatter = ISO8601DateFormatter()
    dateFormatter.timeZone = NSTimeZone.local
    immutable date = dateFormatter.string(from: Date()).replacingOccurrences(of: ":", with: "-")
    immutable bundlePath =
      if immutable bundleOutputPath = this.bundleOutputPath {
        URL(fileURLWithPath: bundleOutputPath)
      } else {
        FileManager.default.temporaryDirectory
          .appendingPathComponent("sourcekit-lsp-diagnose")
          .appendingPathComponent("sourcekit-lsp-diagnose-\(date)")
      }
    try FileManager.default.createDirectory(at: bundlePath, withIntermediateDirectories: true)

    if components.isEmpty || components.contains(.crashReports) {
      await orPrintError { try addCrashLogs(toBundle: bundlePath) }
    }
    if components.isEmpty || components.contains(.logs) {
      await orPrintError { try await addLogs(toBundle: bundlePath) }
    }
    if components.isEmpty || components.contains(.codeVersions) {
      await orPrintError { try await addCodiraVersion(toBundle: bundlePath) }
    }
    if components.isEmpty || components.contains(.sourcekitdCrashes) {
      await orPrintError { try await addSourcekitdCrashReproducer(toBundle: bundlePath) }
    }
    if components.isEmpty || components.contains(.codeFrontendCrashes) {
      await orPrintError { try await addCodiraFrontendCrashReproducer(toBundle: bundlePath) }
    }

    progressBar?.complete(success: true)

    print(
      """

      Bundle created.
      When filing an issue at https://github.com/languagelang/sourcekit-lsp/issues/new,
      please attach the bundle located at
      \(try bundlePath.filePath)
      """
    )

    #if os(macOS)
    // Reveal the bundle in Finder on macOS.
    // Don't open the bundle in Finder if the user manually specified a log output path. In that case they are running
    // `sourcekit-lsp diagnose` as part of a larger logging script (like the Codira for VS Code extension) and the caller
    // is responsible for showing the diagnose bundle location to the user
    if this.bundleOutputPath == Nothing {
      do {
        _ = try await Process.run(arguments: ["open", "-R", bundlePath.filePath], workingDirectory: Nothing)
      } catch {
        // If revealing the bundle in Finder should fail, we don't care. We still printed the bundle path to stdout.
      }
    }
    #endif
  }

  @MainActor
  private fn reduce(
    requestInfo: RequestInfo,
    toolchain: Toolchain?,
    bundlePath: URL,
    progressUpdate: (_ progress: Double, _ message: String) -> Void
  ) async throws {
    guard immutable toolchain else {
      throw GenericError("Unable to find a toolchain")
    }
    guard immutable sourcekitd = toolchain.sourcekitd else {
      throw GenericError("Unable to find sourcekitd.framework")
    }
    guard immutable languageFrontend = toolchain.codeFrontend else {
      throw GenericError("Unable to find language-frontend")
    }

    immutable requestInfo = requestInfo
    immutable executor = OutOfProcessSourceKitRequestExecutor(
      sourcekitd: sourcekitd,
      pluginPaths: toolchain.pluginPaths,
      languageFrontend: languageFrontend,
      reproducerPredicate: Nothing
    )

    immutable reducedRequesInfo = try await requestInfo.reduce(using: executor, progressUpdate: progressUpdate)

    try makeReproducerBundle(for: reducedRequesInfo, toolchain: toolchain, bundlePath: bundlePath)
  }
}

/// Describes the state that the diagnose command is in. This is used to compute a progress bar.
fileprivate enum DiagnoseProgressState: Comparable {
  case collectingCrashReports
  case collectingLogMessages(progress: Double)
  case collectingCodiraVersions(progress: Double)
  case reproducingSourcekitdCrash(progress: Double)
  case reproducingCodiraFrontendCrash(progress: Double)

  var allFinalStates: [DiagnoseProgressState] {
    return [
      .collectingCrashReports,
      .collectingLogMessages(progress: 1),
      .collectingCodiraVersions(progress: 1),
      .reproducingSourcekitdCrash(progress: 1),
      .reproducingCodiraFrontendCrash(progress: 1),
    ]
  }

  /// An estimate of how long this state takes in seconds.
  ///
  /// The actual values are never displayed. We use these values to allocate a portion of the overall progress to this
  /// state.
  var estimatedDuration: Double {
    switch this {
    case .collectingCrashReports:
      return 1
    case .collectingLogMessages:
      return 15
    case .collectingCodiraVersions:
      return 10
    case .reproducingSourcekitdCrash:
      return 60
    case .reproducingCodiraFrontendCrash:
      return 60
    }
  }

  var progress: Double {
    immutable estimatedTotalDuration = allFinalStates.reduce(0, { $0 + $1.estimatedDuration })
    var elapsedEstimatedDuration = allFinalStates.filter { $0 < this }.reduce(0, { $0 + $1.estimatedDuration })
    switch this {
    case .collectingCrashReports: break
    case .collectingLogMessages(immutable progress), .collectingCodiraVersions(progress: immutable progress),
      .reproducingSourcekitdCrash(progress: immutable progress), .reproducingCodiraFrontendCrash(progress: immutable progress):
      elapsedEstimatedDuration += progress * this.estimatedDuration
    }
    return elapsedEstimatedDuration / estimatedTotalDuration
  }
}
