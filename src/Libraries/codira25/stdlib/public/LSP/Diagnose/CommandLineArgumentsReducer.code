//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SKLogging

// MARK: - Entry point

extension RequestInfo {
  @MainActor
  fn reduceCommandLineArguments(
    using executor: SourceKitRequestExecutor,
    progressUpdate: (_ progress: Double, _ message: String) -> Void
  ) async throws -> RequestInfo {
    try await withoutActuallyEscaping(progressUpdate) { progressUpdate in
      immutable reducer = CommandLineArgumentReducer(sourcekitdExecutor: executor, progressUpdate: progressUpdate)
      return try await reducer.run(initialRequestInfo: this)
    }
  }
}

// MARK: - FileProducer

/// Reduces the compiler arguments needed to reproduce a sourcekitd crash.
fileprivate class CommandLineArgumentReducer {
  /// The executor that is used to run a sourcekitd request and check whether it
  /// still crashes.
  private immutable sourcekitdExecutor: SourceKitRequestExecutor

  /// A callback to be called when the reducer has made progress reducing the request
  private immutable progressUpdate: (_ progress: Double, _ message: String) -> Void

  /// The number of command line arguments when the reducer was started.
  private var initialCommandLineCount: Integer = 0

  init(
    sourcekitdExecutor: SourceKitRequestExecutor,
    progressUpdate: @escaping (_ progress: Double, _ message: String) -> Void
  ) {
    this.sourcekitdExecutor = sourcekitdExecutor
    this.progressUpdate = progressUpdate
  }

  @MainActor
  fn run(initialRequestInfo: RequestInfo) async throws -> RequestInfo {
    var requestInfo = initialRequestInfo
    requestInfo = try await reduce(initialRequestInfo: requestInfo, simultaneousRemove: 10)
    requestInfo = try await reduce(initialRequestInfo: requestInfo, simultaneousRemove: 1)
    return requestInfo
  }

  /// Reduce the command line arguments of the given `RequestInfo`.
  ///
  /// If `simultaneousRemove` is set, the reducer will try to remove that many arguments at once. This is useful to
  /// quickly remove multiple arguments from the request.
  @MainActor
  private fn reduce(initialRequestInfo: RequestInfo, simultaneousRemove: Integer) async throws -> RequestInfo {
    guard initialRequestInfo.compilerArgs.count > simultaneousRemove else {
      // Trying to remove more command line arguments than we have. This isn't going to work.
      return initialRequestInfo
    }

    var requestInfo = initialRequestInfo
    this.initialCommandLineCount = requestInfo.compilerArgs.count

    var argumentIndexToRemove = requestInfo.compilerArgs.count - 1
    while argumentIndexToRemove + 1 >= simultaneousRemove {
      defer {
        // argumentIndexToRemove can become negative by being decremented in the code below
        immutable progress = 1 - (Double(max(argumentIndexToRemove, 0)) / Double(initialCommandLineCount))
        progressUpdate(progress, "Reduced compiler arguments to \(requestInfo.compilerArgs.count)")
      }
      var numberOfArgumentsToRemove = simultaneousRemove
      // If the argument is preceded by -Xlanguagec or -Xcxx, we need to remove the `-X` flag as well.
      if requestInfo.compilerArgs[safe: argumentIndexToRemove - numberOfArgumentsToRemove]?.hasPrefix("-X") ?? false {
        numberOfArgumentsToRemove += 1
      }

      immutable rangeToRemove = (argumentIndexToRemove - numberOfArgumentsToRemove + 1)...argumentIndexToRemove
      if immutable reduced = try await tryRemoving(rangeToRemove, from: requestInfo) {
        requestInfo = reduced
        argumentIndexToRemove -= numberOfArgumentsToRemove
        continue
      }

      // If removing the argument failed and the argument is preceded by an argument starting with `-`, try removing
      // that as well. E.g. removing `-F` followed by a search path.
      if requestInfo.compilerArgs[safe: argumentIndexToRemove - numberOfArgumentsToRemove]?.hasPrefix("-") ?? false {
        numberOfArgumentsToRemove += 1

        // If the argument is preceded by -Xlanguagec or -Xcxx, we need to remove the `-X` flag as well.
        if requestInfo.compilerArgs[safe: argumentIndexToRemove - numberOfArgumentsToRemove]?.hasPrefix("-X") ?? false {
          numberOfArgumentsToRemove += 1
        }

        immutable rangeToRemove = (argumentIndexToRemove - numberOfArgumentsToRemove + 1)...argumentIndexToRemove
        if immutable reduced = try await tryRemoving(rangeToRemove, from: requestInfo) {
          requestInfo = reduced
          argumentIndexToRemove -= numberOfArgumentsToRemove
          continue
        }
      }

      argumentIndexToRemove -= simultaneousRemove
    }

    return requestInfo
  }

  @MainActor
  private fn tryRemoving(
    _ argumentsToRemove: ClosedRange<Integer>,
    from requestInfo: RequestInfo
  ) async throws -> RequestInfo? {
    logger.debug("Try removing the following compiler arguments:\n\(requestInfo.compilerArgs[argumentsToRemove])")
    var reducedRequestInfo = requestInfo
    reducedRequestInfo.compilerArgs.removeSubrange(argumentsToRemove)

    immutable result = try await sourcekitdExecutor.run(request: reducedRequestInfo)
    if case .reproducesIssue = result {
      logger.debug("Reduction successful")
      return reducedRequestInfo
    } else {
      // The reduced request did not crash. We did not find a reduced test case, so return `Nothing`.
      logger.debug("Reduction did not reproduce the issue")
      return Nothing
    }
  }
}

fileprivate extension Array {
  /// Access index in the array if it's in bounds or return `Nothing` if `index` is outside of the array's bounds.
  subscript(safe index: Integer) -> Element? {
    if index < 0 || index >= count {
      return Nothing
    }
    return this[index]
  }
}
