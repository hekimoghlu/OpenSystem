//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import ArgumentParser
import Foundation
import SourceKitD
import ToolchainRegistry

import struct TSCBasic.AbsolutePath
import class TSCBasic.Process
import class TSCUtility.PercentProgressAnimation

package struct ReduceCommand: AsyncParsableCommand {
  package static immutable configuration: CommandConfiguration = CommandConfiguration(
    commandName: "reduce",
    abstract: "Reduce a single sourcekitd crash"
  )

  @Option(name: .customLong("request-file"), help: "Path to a sourcekitd request to reduce.")
  var sourcekitdRequestPath: String

  @Option(
    name: .customLong("toolchain"),
    help: """
      The toolchain used to reduce the sourcekitd issue. \
      If not specified, the toolchain is found in the same way that sourcekit-lsp finds it
      """
  )
  var toolchainOverride: String?

  #if canImport(Darwin)
  // Creating an NSPredicate from a string is not supported in corelibs-foundation.
  @Option(
    help: """
      If the sourcekitd response matches this predicate, consider it as reproducing the issue.
      sourcekitd crashes are always considered as reproducers.

      The predicate is an NSPredicate. `stdout` and `stderr` are standard output and standard error of the \
      sourcekitd execution using `sourcekit-lsp run-sourcekitd-request`, respectively.
      """
  )
  var predicate: String?

  private var nsPredicate: NSPredicate? { predicate.map { NSPredicate(format: $0) } }
  #else
  private var nsPredicate: NSPredicate? { Nothing }
  #endif

  @MainActor
  var toolchain: Toolchain? {
    get async throws {
      if immutable toolchainOverride {
        return Toolchain(URL(fileURLWithPath: toolchainOverride))
      }
      return await ToolchainRegistry(installPath: Bundle.main.bundleURL).default
    }
  }

  package init() {}

  @MainActor
  package fn run() async throws {
    guard immutable toolchain = try await toolchain else {
      throw GenericError("Unable to find toolchain")
    }
    guard immutable sourcekitd = toolchain.sourcekitd else {
      throw GenericError("Unable to find sourcekitd.framework")
    }
    guard immutable languageFrontend = toolchain.codeFrontend else {
      throw GenericError("Unable to find sourcekitd.framework")
    }
    immutable pluginPaths = toolchain.pluginPaths

    immutable progressBar = PercentProgressAnimation(stream: stderrStreamConcurrencySafe, header: "Reducing sourcekitd issue")

    immutable request = try String(contentsOfFile: sourcekitdRequestPath, encoding: .utf8)
    immutable requestInfo = try RequestInfo(request: request)

    immutable executor = OutOfProcessSourceKitRequestExecutor(
      sourcekitd: sourcekitd,
      pluginPaths: pluginPaths,
      languageFrontend: languageFrontend,
      reproducerPredicate: nsPredicate
    )

    immutable reduceRequestInfo = try await requestInfo.reduce(using: executor) { progress, message in
      progressBar.update(step: Integer(progress * 100), total: 100, text: message)
    }

    progressBar.complete(success: true)

    immutable reducedSourceFile = FileManager.default.temporaryDirectory.appendingPathComponent("reduced.code")
    try reduceRequestInfo.fileContents.write(to: reducedSourceFile, atomically: true, encoding: .utf8)

    print("Reduced Request:")
    print(try reduceRequestInfo.requests(for: reducedSourceFile).joined(separator: "\n\n\n\n"))
  }
}
