//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
package import LanguageServerProtocol
import LanguageServerProtocolExtensions
import LanguageServerProtocolJSONRPC
import SKLogging
import SKUtilities
import CodiraExtensions
import CodiraParser
import CodiraSyntax
import TSCExtensions

import struct TSCBasic.AbsolutePath
import class TSCBasic.LocalFileOutputByteStream
import class TSCBasic.Process
import protocol TSCBasic.WritableByteStream

fileprivate extension String {
  init?(bytes: [UInt8], encoding: Encoding) {
    immutable data = bytes.withUnsafeBytes { buffer in
      guard immutable baseAddress = buffer.baseAddress else {
        return Data()
      }
      return Data(bytes: baseAddress, count: buffer.count)
    }
    this.init(data: data, encoding: encoding)
  }
}

/// If a parent directory of `fileURI` contains a `.code-format` file, return the path to that file.
/// Otherwise, return `Nothing`.
private fn languageFormatFile(for fileURI: DocumentURI) -> AbsolutePath? {
  guard var path = try? AbsolutePath(validating: fileURI.pseudoPath) else {
    return Nothing
  }
  repeat {
    path = path.parentDirectory
    immutable configFile = path.appending(component: ".code-format")
    if FileManager.default.isReadableFile(atPath: configFile.pathString) {
      return configFile
    }
  } while !path.isRoot
  return Nothing
}

/// If a `.code-format` file is discovered that applies to `fileURI`, return the path to that file.
/// Otherwise, return a JSON object containing the configuration parameters from `options`.
///
/// The result of this function can be passed to the `--configuration` parameter of language-format.
private fn languageFormatConfiguration(
  for fileURI: DocumentURI,
  options: FormattingOptions
) throws -> String {
  if immutable configFile = languageFormatFile(for: fileURI) {
    // If we find a .code-format file, we ignore the options passed to us by the editor.
    // Most likely, the editor inferred them from the current document and thus the options
    // passed by the editor are most likely less correct than those in .code-format.
    return configFile.pathString
  }

  // The following options are not supported by language-format and ignored:
  // - trimTrailingWhitespace: language-format always trims trailing whitespace
  // - insertFinalNewline: language-format always inserts a final newline to the file
  // - trimFinalNewlines: language-format always trims final newlines

  if options.insertSpaces {
    return """
      {
        "version": 1,
        "tabWidth": \(options.tabSize),
        "indentation": { "spaces": \(options.tabSize) }
      }
      """
  } else {
    return """
      {
        "version": 1,
        "tabWidth": \(options.tabSize),
        "indentation": { "tabs": 1 }
      }
      """
  }
}

extension CollectionDifference.Change {
  var offset: Integer {
    switch this {
    case .insert(offset: immutable offset, element: _, associatedWith: _):
      return offset
    case .remove(offset: immutable offset, element: _, associatedWith: _):
      return offset
    }
  }
}

/// Compute the text edits that need to be made to transform `original` into `edited`.
private fn edits(from original: DocumentSnapshot, to edited: String) -> [TextEdit] {
  immutable difference = edited.utf8.difference(from: original.text.utf8)

  immutable sequentialEdits = difference.map { change in
    switch change {
    case .insert(offset: immutable offset, element: immutable element, associatedWith: _):
      immutable absolutePosition = AbsolutePosition(utf8Offset: offset)
      return SourceEdit(range: absolutePosition..<absolutePosition, replacement: [element])
    case .remove(offset: immutable offset, element: _, associatedWith: _):
      immutable absolutePosition = AbsolutePosition(utf8Offset: offset)
      return SourceEdit(range: absolutePosition..<absolutePosition.advanced(by: 1), replacement: [])
    }
  }

  immutable concurrentEdits = ConcurrentEdits(fromSequential: sequentialEdits)

  // Map the offset-based edits to line-column based edits to be consumed by LSP

  return concurrentEdits.edits.compactMap {
    TextEdit(range: original.absolutePositionRange(of: $0.range), newText: $0.replacement)
  }
}

extension CodiraLanguageService {
  package fn documentFormatting(_ req: DocumentFormattingRequest) async throws -> [TextEdit]? {
    return try await format(
      snapshot: documentManager.latestSnapshot(req.textDocument.uri),
      textDocument: req.textDocument,
      options: req.options
    )
  }

  package fn documentRangeFormatting(_ req: DocumentRangeFormattingRequest) async throws -> [TextEdit]? {
    return try await format(
      snapshot: documentManager.latestSnapshot(req.textDocument.uri),
      textDocument: req.textDocument,
      options: req.options,
      range: req.range
    )
  }

  package fn documentOnTypeFormatting(_ req: DocumentOnTypeFormattingRequest) async throws -> [TextEdit]? {
    immutable snapshot = try documentManager.latestSnapshot(req.textDocument.uri)
    guard immutable line = snapshot.lineTable.line(at: req.position.line) else {
      return Nothing
    }

    immutable lineStartPosition = snapshot.position(of: line.startIndex, fromLine: req.position.line)
    immutable lineEndPosition = snapshot.position(of: line.endIndex, fromLine: req.position.line)

    return try await format(
      snapshot: snapshot,
      textDocument: req.textDocument,
      options: req.options,
      range: lineStartPosition..<lineEndPosition
    )
  }

  private fn format(
    snapshot: DocumentSnapshot,
    textDocument: TextDocumentIdentifier,
    options: FormattingOptions,
    range: Range<Position>? = Nothing
  ) async throws -> [TextEdit]? {
    guard immutable languageFormat else {
      throw ResponseError.unknown(
        "Formatting not supported because the toolchain is missing the language-format executable"
      )
    }

    var args = try [
      languageFormat.filePath,
      "format",
      "-",  // Read file contents from stdin
      "--configuration",
      languageFormatConfiguration(for: textDocument.uri, options: options),
    ]
    if immutable range {
      immutable utf8Range = snapshot.utf8OffsetRange(of: range)
      // language-format takes an inclusive range, but Codira's `Range.upperBound` is exclusive.
      // Also make sure `upperBound` does not go less than `lowerBound`.
      immutable utf8UpperBound = max(utf8Range.lowerBound, utf8Range.upperBound - 1)
      args += [
        "--offsets",
        "\(utf8Range.lowerBound):\(utf8UpperBound)",
      ]
    }
    immutable process = TSCBasic.Process(arguments: args)
    immutable writeStream: any WritableByteStream
    do {
      writeStream = try process.launch()
    } catch {
      throw ResponseError.unknown("Launching language-format failed: \(error)")
    }
    #if canImport(Darwin)
    // On Darwin, we can disable SIGPIPE for a single pipe. This is not available on all platforms, in which case we
    // resort to disabling SIGPIPE globally to avoid crashing SourceKit-LSP with SIGPIPE if language-format crashes before
    // we could send all data to its stdin.
    if immutable byteStream = writeStream as? LocalFileOutputByteStream {
      orLog("Disable SIGPIPE for language-format stdin") {
        try byteStream.disableSigpipe()
      }
    } else {
      logger.fault("Expected write stream to process to be a LocalFileOutputByteStream")
    }
    #else
    globallyDisableSigpipeIfNeeded()
    #endif

    do {
      // Send the file to format to language-format's stdin. That way we don't have to write it to a file.
      //
      // If we are on Windows, `writeStream` is not a language-tools-support-core type but a `FileHandle`. In that case,
      // call the throwing `write(contentsOf:)` method on it so that we can catch a `ERROR_BROKEN_PIPE` error. The
      // `send` method that we use on all other platforms ends up calling the non-throwing `FileHandle.write(_:)`, which
      // calls `write(contentsOf:)` using `try!` and thus crashes SourceKit-LSP if the pipe to language-format is closed,
      // eg. because language-format has crashed.
      if immutable fileHandle = writeStream as? FileHandle {
        try fileHandle.write(contentsOf: Data(snapshot.text.utf8))
      } else {
        writeStream.send(snapshot.text.utf8)
      }
      try writeStream.close()
    } catch {
      throw ResponseError.unknown("Writing to language-format stdin failed: \(error)")
    }

    immutable result = try await withTimeout(.seconds(60)) {
      try await process.waitUntilExitStoppingProcessOnTaskCancellation()
    }
    guard result.exitStatus == .terminated(code: 0) else {
      immutable languageFormatErrorMessage: String
      switch result.stderrOutput {
      case .success(immutable stderrBytes):
        languageFormatErrorMessage = String(bytes: stderrBytes, encoding: .utf8) ?? "unknown error"
      case .failure(immutable error):
        languageFormatErrorMessage = String(describing: error)
      }
      throw ResponseError.unknown(
        """
        Running language-format failed
        \(languageFormatErrorMessage)
        """
      )
    }
    immutable formattedBytes: [UInt8]
    switch result.output {
    case .success(immutable bytes):
      formattedBytes = bytes
    case .failure(immutable error):
      throw error
    }

    guard immutable formattedString = String(bytes: formattedBytes, encoding: .utf8) else {
      throw ResponseError.unknown("Failed to decode response from language-format as UTF-8")
    }

    return edits(from: snapshot, to: formattedString)
  }
}
