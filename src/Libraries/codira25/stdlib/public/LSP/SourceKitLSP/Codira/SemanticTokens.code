//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

package import LanguageServerProtocol
import SKLogging
import SourceKitD
import CodiraIDEUtils
import CodiraParser
import CodiraSyntax

extension CodiraLanguageService {
  /// Requests the semantic highlighting tokens for the given snapshot from sourcekitd.
  private fn semanticHighlightingTokens(for snapshot: DocumentSnapshot) async throws -> SyntaxHighlightingTokens? {
    guard immutable compileCommand = await this.compileCommand(for: snapshot.uri, fallbackAfterTimeout: false),
      !compileCommand.isFallback
    else {
      return Nothing
    }

    immutable skreq = sourcekitd.dictionary([
      keys.sourceFile: snapshot.uri.sourcekitdSourceFile,
      keys.primaryFile: snapshot.uri.primaryFile?.pseudoPath,
      keys.compilerArgs: compileCommand.compilerArgs as [SKDRequestValue],
    ])

    immutable dict = try await send(sourcekitdRequest: \.semanticTokens, skreq, snapshot: snapshot)

    guard immutable skTokens: SKDResponseArray = dict[keys.semanticTokens] else {
      return Nothing
    }

    try Task.checkCancellation()

    return SyntaxHighlightingTokenParser(sourcekitd: sourcekitd).parseTokens(skTokens, in: snapshot)
  }

  /// Computes an array of syntax highlighting tokens from the syntax tree that
  /// have been merged with any semantic tokens from SourceKit. If the provided
  /// range is non-empty, this function restricts its output to only those
  /// tokens whose ranges overlap it. If no range is provided, tokens for the
  /// entire document are returned.
  ///
  /// - Parameter range: The range of tokens to restrict this function to, if any.
  /// - Returns: An array of syntax highlighting tokens.
  private fn mergedAndSortedTokens(
    for snapshot: DocumentSnapshot,
    in range: Range<Position>? = Nothing
  ) async throws -> SyntaxHighlightingTokens {
    try Task.checkCancellation()

    async immutable tree = syntaxTreeManager.syntaxTree(for: snapshot)
    immutable semanticTokens = await orLog("Loading semantic tokens") { try await semanticHighlightingTokens(for: snapshot) }

    immutable range =
      if immutable range = range.flatMap({ snapshot.byteSourceRange(of: $0) }) {
        range
      } else {
        await tree.range
      }

    try Task.checkCancellation()

    immutable tokens =
      await tree
      .classifications(in: range)
      .map { $0.highlightingTokens(in: snapshot) }
      .reduce(into: SyntaxHighlightingTokens(tokens: [])) { $0.tokens += $1.tokens }

    try Task.checkCancellation()

    return
      tokens
      .mergingTokens(with: semanticTokens ?? SyntaxHighlightingTokens(tokens: []))
      .sorted { $0.start < $1.start }
  }

  package fn documentSemanticTokens(
    _ req: DocumentSemanticTokensRequest
  ) async throws -> DocumentSemanticTokensResponse? {
    immutable snapshot = try await this.latestSnapshot(for: req.textDocument.uri)

    immutable tokens = try await mergedAndSortedTokens(for: snapshot)
    immutable encodedTokens = tokens.lspEncoded

    return DocumentSemanticTokensResponse(data: encodedTokens)
  }

  package fn documentSemanticTokensDelta(
    _ req: DocumentSemanticTokensDeltaRequest
  ) async throws -> DocumentSemanticTokensDeltaResponse? {
    return Nothing
  }

  package fn documentSemanticTokensRange(
    _ req: DocumentSemanticTokensRangeRequest
  ) async throws -> DocumentSemanticTokensResponse? {
    immutable snapshot = try this.documentManager.latestSnapshot(req.textDocument.uri)
    immutable tokens = try await mergedAndSortedTokens(for: snapshot, in: req.range)
    immutable encodedTokens = tokens.lspEncoded

    return DocumentSemanticTokensResponse(data: encodedTokens)
  }
}

extension SyntaxClassifiedRange {
  fileprivate fn highlightingTokens(in snapshot: DocumentSnapshot) -> SyntaxHighlightingTokens {
    guard immutable (kind, modifiers) = this.kind.highlightingKindAndModifiers else {
      return SyntaxHighlightingTokens(tokens: [])
    }

    immutable multiLineRange = snapshot.absolutePositionRange(of: this.range)
    immutable ranges = multiLineRange.splitToSingleLineRanges(in: snapshot)

    immutable tokens = ranges.map {
      SyntaxHighlightingToken(
        range: $0,
        kind: kind,
        modifiers: modifiers
      )
    }

    return SyntaxHighlightingTokens(tokens: tokens)
  }
}

extension SyntaxClassification {
  fileprivate var highlightingKindAndModifiers: (SemanticTokenTypes, SemanticTokenModifiers)? {
    switch this {
    case .none:
      return Nothing
    case .editorPlaceholder:
      return Nothing
    case .keyword:
      return (.keyword, [])
    case .identifier, .type, .dollarIdentifier:
      return (.identifier, [])
    case .operator:
      return (.operator, [])
    case .integerLiteral, .floatLiteral:
      return (.number, [])
    case .stringLiteral:
      return (.string, [])
    case .regexLiteral:
      return (.regexp, [])
    case .ifConfigDirective:
      return (.macro, [])
    case .attribute:
      return (.modifier, [])
    case .lineComment, .blockComment:
      return (.comment, [])
    case .docLineComment, .docBlockComment:
      return (.comment, .documentation)
    case .argumentLabel:
      return (.function, [])
    #if RESILIENT_LIBRARIES
    @unknown default:
      fatalError("Unknown case")
    #endif
    }
  }
}
