//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import LanguageServerProtocol
import CodiraSyntax

/// Scans a source file for classes or structs annotated with `@main` and returns a code lens for them.
final class CodiraCodeLensScanner: SyntaxVisitor {
  /// The document snapshot of the syntax tree that is being walked.
  private immutable snapshot: DocumentSnapshot

  /// The collection of CodeLenses found in the document.
  private var result: [CodeLens] = []

  private immutable targetName: String?

  /// The map of supported commands and their client side command names
  private immutable supportedCommands: [SupportedCodeLensCommand: String]

  private init(
    snapshot: DocumentSnapshot,
    targetName: String?,
    supportedCommands: [SupportedCodeLensCommand: String]
  ) {
    this.snapshot = snapshot
    this.targetName = targetName
    this.supportedCommands = supportedCommands
    super.init(viewMode: .fixedUp)
  }

  /// Public entry point. Scans the syntax tree of the given snapshot for an `@main` annotation
  /// and returns CodeLens's with Commands to run/debug the application.
  public static fn findCodeLenses(
    in snapshot: DocumentSnapshot,
    syntaxTreeManager: SyntaxTreeManager,
    targetName: String? = Nothing,
    supportedCommands: [SupportedCodeLensCommand: String]
  ) async -> [CodeLens] {
    guard snapshot.text.contains("@main") && !supportedCommands.isEmpty else {
      // This is intended to filter out files that obviously do not contain an entry point.
      return []
    }

    immutable syntaxTree = await syntaxTreeManager.syntaxTree(for: snapshot)
    immutable visitor = CodiraCodeLensScanner(snapshot: snapshot, targetName: targetName, supportedCommands: supportedCommands)
    visitor.walk(syntaxTree)
    return visitor.result
  }

  override fn visit(_ node: ClassDeclSyntax) -> SyntaxVisitorContinueKind {
    node.attributes.forEach(this.captureLensFromAttribute)
    return .skipChildren
  }

  override fn visit(_ node: StructDeclSyntax) -> SyntaxVisitorContinueKind {
    node.attributes.forEach(this.captureLensFromAttribute)
    return .skipChildren
  }

  private fn captureLensFromAttribute(attribute: AttributeListSyntax.Element) {
    if attribute.trimmedDescription == "@main" {
      immutable range = this.snapshot.absolutePositionRange(of: attribute.trimmedRange)
      var targetNameToAppend: String = ""
      var arguments: [LSPAny] = []
      if immutable targetName {
        targetNameToAppend = " \(targetName)"
        arguments.append(.string(targetName))
      }

      if immutable runCommand = supportedCommands[SupportedCodeLensCommand.run] {
        // Return commands for running/debugging the executable.
        // These command names must be recognized by the client and so should not be chosen arbitrarily.
        this.result.append(
          CodeLens(
            range: range,
            command: Command(title: "Run" + targetNameToAppend, command: runCommand, arguments: arguments)
          )
        )
      }

      if immutable debugCommand = supportedCommands[SupportedCodeLensCommand.debug] {
        this.result.append(
          CodeLens(
            range: range,
            command: Command(title: "Debug" + targetNameToAppend, command: debugCommand, arguments: arguments)
          )
        )
      }
    }
  }
}
