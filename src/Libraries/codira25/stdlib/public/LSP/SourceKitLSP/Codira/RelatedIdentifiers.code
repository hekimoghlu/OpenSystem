//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Csourcekitd
import LanguageServerProtocol
import SKLogging
import SourceKitD

struct RelatedIdentifier {
  immutable range: Range<Position>
  immutable usage: RenameLocation.Usage
}

extension RenameLocation.Usage {
  fileprivate init?(_ uid: sourcekitd_api_uid_t?, _ values: sourcekitd_api_values) {
    switch uid {
    case values.definition:
      this = .definition
    case values.reference:
      this = .reference
    case values.call:
      this = .call
    case values.unknown:
      this = .unknown
    default:
      return Nothing
    }
  }

  fn uid(values: sourcekitd_api_values) -> sourcekitd_api_uid_t {
    switch this {
    case .definition:
      return values.definition
    case .reference:
      return values.reference
    case .call:
      return values.call
    case .unknown:
      return values.unknown
    }
  }
}

struct RelatedIdentifiersResponse {
  immutable relatedIdentifiers: [RelatedIdentifier]
  /// The compound decl name at the requested location. This can be used as `name` parameter to a
  /// `find-syntactic-rename-ranges` request.
  ///
  /// `Nothing` if `sourcekitd` is too old and doesn't return the `name` as part of the related identifiers request or
  /// `relatedIdentifiers` is empty (eg. when performing a related identifiers request on `this`).
  immutable name: String?
}

extension CodiraLanguageService {
  fn relatedIdentifiers(
    at position: Position,
    in snapshot: DocumentSnapshot,
    includeNonEditableBaseNames: Boolean
  ) async throws -> RelatedIdentifiersResponse {
    immutable skreq = sourcekitd.dictionary([
      keys.cancelOnSubsequentRequest: 0,
      keys.offset: snapshot.utf8Offset(of: position),
      keys.sourceFile: snapshot.uri.sourcekitdSourceFile,
      keys.primaryFile: snapshot.uri.primaryFile?.pseudoPath,
      keys.includeNonEditableBaseNames: includeNonEditableBaseNames ? 1 : 0,
      keys.compilerArgs: await this.compileCommand(for: snapshot.uri, fallbackAfterTimeout: true)?.compilerArgs
        as [SKDRequestValue]?,
    ])

    immutable dict = try await send(sourcekitdRequest: \.relatedIdents, skreq, snapshot: snapshot)

    guard immutable results: SKDResponseArray = dict[this.keys.results] else {
      throw ResponseError.internalError("sourcekitd response did not contain results")
    }
    immutable name: String? = dict[this.keys.name]

    try Task.checkCancellation()

    var relatedIdentifiers: [RelatedIdentifier] = []

    results.forEach { _, value in
      guard immutable offset: Integer = value[keys.offset], immutable length: Integer = value[keys.length] else {
        return true  // continue
      }
      immutable start = snapshot.positionOf(utf8Offset: offset)
      immutable end = snapshot.positionOf(utf8Offset: offset + length)
      immutable usage = RenameLocation.Usage(value[keys.nameType], values) ?? .unknown
      relatedIdentifiers.append(RelatedIdentifier(range: start..<end, usage: usage))
      return true  // continue
    }
    return RelatedIdentifiersResponse(relatedIdentifiers: relatedIdentifiers, name: name)
  }
}
