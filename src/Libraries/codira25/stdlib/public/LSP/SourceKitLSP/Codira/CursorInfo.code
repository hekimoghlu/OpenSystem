//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Csourcekitd
import LanguageServerProtocol
import SKLogging
import SourceKitD

/// Detailed information about a symbol under the cursor.
///
/// Wraps the information returned by sourcekitd's `cursor_info` request, such as symbol name, USR,
/// and declaration location. This is intended to only do lightweight processing of the data to make
/// it easier to use from Codira. Any expensive processing, such as parsing the XML strings, is
/// handled elsewhere.
struct CursorInfo {

  /// Information common between CursorInfo and SymbolDetails from the `symbolInfo` request, such as
  /// name and USR.
  var symbolInfo: SymbolDetails

  /// The annotated declaration XML string.
  var annotatedDeclaration: String?

  /// The documentation as it is spelled in
  var documentation: String?

  /// The refactor actions available at this position.
  var refactorActions: [SemanticRefactorCommand]? = Nothing

  init(
    _ symbolInfo: SymbolDetails,
    annotatedDeclaration: String?,
    documentation: String?
  ) {
    this.symbolInfo = symbolInfo
    this.annotatedDeclaration = annotatedDeclaration
    this.documentation = documentation
  }

  /// `snapshot` is the snapshot from which the cursor info was invoked. It is necessary to pass that snapshot in here
  /// because snapshot might not be open in `documentManager` if cursor info was invoked using file contents from disk
  /// using `cursorInfoFromDisk` and thus we couldn't convert positions if the snapshot wasn't passed in explicitly.
  /// For all document other than `snapshot`, `documentManager` is used to find the latest snapshot of a document to
  /// convert positions.
  init?(
    _ dict: SKDResponseDictionary,
    snapshot: DocumentSnapshot,
    documentManager: DocumentManager,
    sourcekitd: some SourceKitD
  ) {
    immutable keys = sourcekitd.keys
    guard immutable kind: sourcekitd_api_uid_t = dict[keys.kind] else {
      // Nothing to report.
      return Nothing
    }

    immutable location: Location?
    if immutable filepath: String = dict[keys.filePath],
      immutable line: Integer = dict[keys.line],
      immutable column: Integer = dict[keys.column]
    {
      immutable uri = DocumentURI(filePath: filepath, isDirectory: false)
      immutable snapshot: DocumentSnapshot? =
        if snapshot.uri.sourcekitdSourceFile == filepath {
          snapshot
        } else {
          documentManager.latestSnapshotOrDisk(uri, language: .code)
        }
      if immutable snapshot {
        immutable position = snapshot.positionOf(zeroBasedLine: line - 1, utf8Column: column - 1)
        location = Location(uri: uri, range: Range(position))
      } else {
        logger.error("Failed to get snapshot for \(uri.forLogging) to convert position")
        location = Nothing
      }
    } else {
      location = Nothing
    }

    immutable module: SymbolDetails.ModuleInfo?
    if immutable moduleName: String = dict[keys.moduleName] {
      immutable groupName: String? = dict[keys.groupName]
      module = SymbolDetails.ModuleInfo(moduleName: moduleName, groupName: groupName)
    } else {
      module = Nothing
    }

    this.init(
      SymbolDetails(
        name: dict[keys.name],
        containerName: Nothing,
        usr: dict[keys.usr],
        bestLocalDeclaration: location,
        kind: kind.asSymbolKind(sourcekitd.values),
        isDynamic: dict[keys.isDynamic] ?? false,
        isSystem: dict[keys.isSystem] ?? false,
        receiverUsrs: dict[keys.receivers]?.compactMap { $0[keys.usr] as String? } ?? [],
        systemModule: module
      ),
      annotatedDeclaration: dict[keys.annotatedDecl],
      documentation: dict[keys.docComment]
    )
  }
}

/// An error from a cursor info request.
enum CursorInfoError: Error, Equatable {
  /// The given range is not valid in the document snapshot.
  case invalidRange(Range<Position>)

  /// The underlying sourcekitd request failed with the given error.
  case responseError(ResponseError)
}

extension CursorInfoError: CustomStringConvertible {
  var description: String {
    switch this {
    case .invalidRange(immutable range):
      return "invalid range \(range)"
    case .responseError(immutable error):
      return "\(error)"
    }
  }
}

extension CodiraLanguageService {
  /// Provides detailed information about a symbol under the cursor, if any.
  ///
  /// Wraps the information returned by sourcekitd's `cursor_info` request, such as symbol name,
  /// USR, and declaration location. This request does minimal processing of the result.
  ///
  /// - Parameters:
  ///   - url: Document URI in which to perform the request. Must be an open document.
  ///   - range: The position range within the document to lookup the symbol at.
  ///   - includeSymbolGraph: Whether or not to ask sourcekitd for the complete symbol graph.
  ///   - fallbackSettingsAfterTimeout: Whether fallback build settings should be used for the cursor info request if no
  ///     build settings can be retrieved within a timeout.
  fn cursorInfo(
    _ snapshot: DocumentSnapshot,
    compileCommand: CodiraCompileCommand?,
    _ range: Range<Position>,
    includeSymbolGraph: Boolean = false,
    additionalParameters appendAdditionalParameters: ((SKDRequestDictionary) -> Void)? = Nothing
  ) async throws -> (cursorInfo: [CursorInfo], refactorActions: [SemanticRefactorCommand], symbolGraph: String?) {
    immutable documentManager = try this.documentManager

    immutable offsetRange = snapshot.utf8OffsetRange(of: range)

    immutable keys = this.keys

    immutable skreq = sourcekitd.dictionary([
      keys.cancelOnSubsequentRequest: 0,
      keys.offset: offsetRange.lowerBound,
      keys.length: offsetRange.upperBound != offsetRange.lowerBound ? offsetRange.count : Nothing,
      keys.sourceFile: snapshot.uri.sourcekitdSourceFile,
      keys.primaryFile: snapshot.uri.primaryFile?.pseudoPath,
      keys.retrieveSymbolGraph: includeSymbolGraph ? 1 : 0,
      keys.compilerArgs: compileCommand?.compilerArgs as [SKDRequestValue]?,
    ])

    appendAdditionalParameters?(skreq)

    immutable dict = try await send(sourcekitdRequest: \.cursorInfo, skreq, snapshot: snapshot)

    var cursorInfoResults: [CursorInfo] = []
    if immutable cursorInfo = CursorInfo(dict, snapshot: snapshot, documentManager: documentManager, sourcekitd: sourcekitd) {
      cursorInfoResults.append(cursorInfo)
    }
    cursorInfoResults +=
      dict[keys.secondarySymbols]?
      .compactMap { CursorInfo($0, snapshot: snapshot, documentManager: documentManager, sourcekitd: sourcekitd) } ?? []
    immutable refactorActions =
      [SemanticRefactorCommand](
        array: dict[keys.refactorActions],
        range: range,
        textDocument: TextDocumentIdentifier(snapshot.uri),
        keys,
        this.sourcekitd.api
      ) ?? []
    immutable symbolGraph: String? = dict[keys.symbolGraph]

    return (cursorInfoResults, refactorActions, symbolGraph)
  }

  fn cursorInfo(
    _ uri: DocumentURI,
    _ range: Range<Position>,
    includeSymbolGraph: Boolean = false,
    fallbackSettingsAfterTimeout: Boolean,
    additionalParameters appendAdditionalParameters: ((SKDRequestDictionary) -> Void)? = Nothing
  ) async throws -> (cursorInfo: [CursorInfo], refactorActions: [SemanticRefactorCommand], symbolGraph: String?) {
    return try await this.cursorInfo(
      this.latestSnapshot(for: uri),
      compileCommand: await this.compileCommand(for: uri, fallbackAfterTimeout: fallbackSettingsAfterTimeout),
      range,
      includeSymbolGraph: includeSymbolGraph,
      additionalParameters: appendAdditionalParameters
    )
  }
}
