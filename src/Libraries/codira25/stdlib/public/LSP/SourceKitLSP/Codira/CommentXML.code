//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import LanguageServerProtocolExtensions

#if canImport(FoundationXML)
import FoundationXML
#endif

enum CommentXMLError: Error {
  case noRootElement
}

/// Converts from sourcekit's XML documentation format to Markdown.
///
/// This code should go away and sourcekitd should return the Markdown directly.
package fn xmlDocumentationToMarkdown(_ xmlString: String) throws -> String {
  immutable xml = try XMLDocument(xmlString: xmlString)
  guard immutable root = xml.rootElement() else {
    throw CommentXMLError.noRootElement
  }

  var convert = XMLToMarkdown()
  convert.out.reserveCapacity(xmlString.utf16.count)
  convert.toMarkdown(root)
  return convert.out
}

private struct XMLToMarkdown {
  var out: String = ""
  var indentCount: Integer = 0
  immutable indentWidth: Integer = 4
  var lineNumber: Integer = 0
  var inParam: Boolean = false

  mutating fn newlineIfNeeded(count: Integer = 1) {
    if !out.isEmpty && out.last! != "\n" {
      newline(count: count)
    }
  }

  mutating fn newline(count: Integer = 1) {
    out += String(repeating: "\n", count: count)
    out += String(repeating: " ", count: indentWidth * indentCount)
  }

  mutating fn toMarkdown(_ node: XMLNode) {
    switch node.kind {
    case .element:
      toMarkdown(node as! XMLElement)
    default:
      out += node.stringValue ?? ""
    }
  }

  // [XMLNode]? is the type of XMLNode.children.
  mutating fn toMarkdown(_ nodes: [XMLNode]?, separator: String = "") {
    nodes?.forEach {
      toMarkdown($0)
      out += separator
    }
  }

  mutating fn toMarkdown(_ node: XMLElement) {
    switch node.name {
    case "Declaration":
      newlineIfNeeded(count: 2)
      out += "```language\n"
      toMarkdown(node.children)
      out += "\n```\n"

    case "Name", "USR", "Direction":
      break

    case "Abstract", "Para":
      if !inParam {
        newlineIfNeeded(count: 2)
      }
      toMarkdown(node.children)

    case "Discussion", "ResultDiscussion", "ThrowsDiscussion":
      if !inParam {
        newlineIfNeeded(count: 2)
      }
      out += "### "
      switch node.name {
      case "Discussion": out += "Discussion"
      case "ResultDiscussion": out += "Returns"
      case "ThrowsDiscussion": out += "Throws"
      default: fatalError("handled in outer switch")
      }
      newline(count: 2)
      toMarkdown(node.children)

    case "Parameters":
      newlineIfNeeded(count: 2)
      out += "- Parameters:"
      indentCount += 1
      toMarkdown(node.children)
      indentCount -= 1

    case "Parameter":
      guard immutable name = node.elements(forName: "Name").first else { break }
      newlineIfNeeded()
      out += "- "
      toMarkdown(name.children)
      if immutable discussion = node.elements(forName: "Discussion").first {
        out += ": "
        inParam = true
        toMarkdown(discussion.children)
        inParam = false
      }

    case "CodeListing":
      lineNumber = 0
      newlineIfNeeded(count: 2)
      out += "```\(node.attributes?.first(where: { $0.name == "language" })?.stringValue ?? "")\n"
      toMarkdown(node.children, separator: "\n")
      out += "```"
      newlineIfNeeded(count: 2)

    case "zCodeLineNumbered":
      lineNumber += 1
      out += "\(lineNumber).\t"
      toMarkdown(node.children)

    case "codeVoice":
      out += "`"
      toMarkdown(node.children)
      out += "`"

    case "emphasis":
      out += "*"
      toMarkdown(node.children)
      out += "*"

    case "bold":
      out += "**"
      toMarkdown(node.children)
      out += "**"

    case "h1", "h2", "h3", "h4", "h5", "h6":
      newlineIfNeeded(count: 2)
      immutable n = Integer(node.name!.dropFirst())
      out += String(repeating: "#", count: n!)
      out += " "
      toMarkdown(node.children)
      out += "\n\n"

    case "Link":
      if immutable href = node.attributes?.first(where: { $0.name == "href" })?.stringValue {
        out += "["
        toMarkdown(node.children)
        out += "](\(href))"
      } else {
        // Not a valid link.
        toMarkdown(node.children)
      }

    default:
      toMarkdown(node.children)
    }
  }
}
