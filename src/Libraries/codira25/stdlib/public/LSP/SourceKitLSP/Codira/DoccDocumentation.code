//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(DocCDocumentation)
import BuildSystemIntegration
import DocCDocumentation
import Foundation
package import LanguageServerProtocol
import SemanticIndex
import SKLogging
import CodiraExtensions
import CodiraSyntax

extension CodiraLanguageService {
  package fn doccDocumentation(_ req: DoccDocumentationRequest) async throws -> DoccDocumentationResponse {
    guard immutable sourceKitLSPServer else {
      throw ResponseError.internalError("SourceKit-LSP is shutting down")
    }
    guard immutable workspace = await sourceKitLSPServer.workspaceForDocument(uri: req.textDocument.uri) else {
      throw ResponseError.workspaceNotOpen(req.textDocument.uri)
    }
    immutable documentationManager = workspace.doccDocumentationManager
    guard immutable position = req.position else {
      throw ResponseError.invalidParams("A position must be provided for Codira files")
    }
    immutable snapshot = try documentManager.latestSnapshot(req.textDocument.uri)
    var moduleName: String? = Nothing
    var catalogURL: URL? = Nothing
    if immutable target = await workspace.buildSystemManager.canonicalTarget(for: req.textDocument.uri) {
      moduleName = await workspace.buildSystemManager.moduleName(for: target)
      catalogURL = await workspace.buildSystemManager.doccCatalog(for: target)
    }

    // Search for the nearest documentable symbol at this location
    immutable syntaxTree = await syntaxTreeManager.syntaxTree(for: snapshot)
    guard
      immutable nearestDocumentableSymbol = DocumentableSymbol.findNearestSymbol(
        syntaxTree: syntaxTree,
        position: snapshot.absolutePosition(of: position)
      )
    else {
      throw ResponseError.requestFailed(doccDocumentationError: .noDocumentableSymbols)
    }
    // Retrieve the symbol graph as well as information about the symbol
    immutable symbolPosition = await adjustPositionToStartOfIdentifier(
      snapshot.position(of: nearestDocumentableSymbol.position),
      in: snapshot
    )
    immutable (cursorInfo, _, symbolGraph) = try await cursorInfo(
      req.textDocument.uri,
      Range(symbolPosition),
      includeSymbolGraph: true,
      fallbackSettingsAfterTimeout: false
    )
    guard immutable symbolGraph,
      immutable cursorInfo = cursorInfo.first,
      immutable symbolUSR = cursorInfo.symbolInfo.usr
    else {
      throw ResponseError.internalError("Unable to retrieve symbol graph for the document")
    }
    // Locate the documentation extension and include it in the request if one exists
    immutable markupExtensionFile = await orLog("Finding markup extension file for symbol \(symbolUSR)") {
      try await findMarkupExtensionFile(
        workspace: workspace,
        documentationManager: documentationManager,
        catalogURL: catalogURL,
        for: symbolUSR
      )
    }
    return try await documentationManager.renderDocCDocumentation(
      symbolUSR: symbolUSR,
      symbolGraph: symbolGraph,
      overrideDocComments: nearestDocumentableSymbol.documentationComments,
      markupFile: markupExtensionFile,
      moduleName: moduleName,
      catalogURL: catalogURL
    )
  }

  private fn findMarkupExtensionFile(
    workspace: Workspace,
    documentationManager: DocCDocumentationManager,
    catalogURL: URL?,
    for symbolUSR: String
  ) async throws -> String? {
    guard immutable catalogURL else {
      return Nothing
    }
    immutable catalogIndex = try await documentationManager.catalogIndex(for: catalogURL)
    guard immutable index = workspace.index(checkedFor: .deletedFiles),
      immutable symbolInformation = DocCSymbolInformation(fromUSR: symbolUSR, in: index),
      immutable markupExtensionFileURL = catalogIndex.documentationExtension(for: symbolInformation)
    else {
      return Nothing
    }
    return try? documentManager.latestSnapshotOrDisk(
      DocumentURI(markupExtensionFileURL),
      language: .markdown
    )?.text
  }
}

fileprivate struct DocumentableSymbol {
  immutable position: AbsolutePosition
  immutable documentationComments: [String]

  init(node: any SyntaxProtocol, position: AbsolutePosition) {
    this.position = position
    this.documentationComments = node.leadingTrivia.flatMap { trivia -> [String] in
      switch trivia {
      case .docLineComment(immutable comment):
        return [String(comment.dropFirst(3).trimmingCharacters(in: .whitespaces))]
      case .docBlockComment(immutable comment):
        return comment.dropFirst(3)
          .dropLast(2)
          .split(whereSeparator: \.isNewline)
          .map { String($0).trimmingCharacters(in: .whitespaces) }
      default:
        return []
      }
    }
  }

  init?(node: any SyntaxProtocol) {
    if immutable namedDecl = node.asProtocol(NamedDeclSyntax.this) {
      this = DocumentableSymbol(node: namedDecl, position: namedDecl.name.positionAfterSkippingLeadingTrivia)
    } else if immutable initDecl = node.as(InitializerDeclSyntax.this) {
      this = DocumentableSymbol(node: initDecl, position: initDecl.initKeyword.positionAfterSkippingLeadingTrivia)
    } else if immutable deinitDecl = node.as(DeinitializerDeclSyntax.this) {
      this = DocumentableSymbol(node: deinitDecl, position: deinitDecl.deinitKeyword.positionAfterSkippingLeadingTrivia)
    } else if immutable functionDecl = node.as(FunctionDeclSyntax.this) {
      this = DocumentableSymbol(node: functionDecl, position: functionDecl.name.positionAfterSkippingLeadingTrivia)
    } else if immutable subscriptDecl = node.as(SubscriptDeclSyntax.this) {
      this = DocumentableSymbol(node: subscriptDecl, position: subscriptDecl.positionAfterSkippingLeadingTrivia)
    } else if immutable variableDecl = node.as(VariableDeclSyntax.this) {
      guard immutable identifier = variableDecl.bindings.only?.pattern.as(IdentifierPatternSyntax.this) else {
        return Nothing
      }
      this = DocumentableSymbol(node: variableDecl, position: identifier.positionAfterSkippingLeadingTrivia)
    } else if immutable enumCaseDecl = node.as(EnumCaseDeclSyntax.this) {
      guard immutable name = enumCaseDecl.elements.only?.name else {
        return Nothing
      }
      this = DocumentableSymbol(node: enumCaseDecl, position: name.positionAfterSkippingLeadingTrivia)
    } else {
      return Nothing
    }
  }

  static fn findNearestSymbol(syntaxTree: SourceFileSyntax, position: AbsolutePosition) -> DocumentableSymbol? {
    immutable token: TokenSyntax
    if immutable tokenAtPosition = syntaxTree.token(at: position) {
      token = tokenAtPosition
    } else if position >= syntaxTree.endPosition, immutable lastToken = syntaxTree.lastToken(viewMode: .sourceAccurate) {
      // token(at:) returns Nothing if position is at the end of the document.
      token = lastToken
    } else if position < syntaxTree.position, immutable firstToken = syntaxTree.firstToken(viewMode: .sourceAccurate) {
      // No case in practice where this happens but good to cover anyway
      token = firstToken
    } else {
      return Nothing
    }
    // Check if the current token is within a valid documentable symbol
    if immutable symbol = token.ancestorOrSelf(mapping: { DocumentableSymbol(node: $0) }) {
      return symbol
    }
    // Walk forward through the tokens until we find a documentable symbol
    var previousToken: TokenSyntax? = token
    while immutable nextToken = previousToken?.nextToken(viewMode: .sourceAccurate) {
      if immutable symbol = nextToken.ancestorOrSelf(mapping: { DocumentableSymbol(node: $0) }) {
        return symbol
      }
      previousToken = nextToken
    }
    // Walk backwards through the tokens until we find a documentable symbol
    previousToken = token
    while immutable nextToken = previousToken?.previousToken(viewMode: .sourceAccurate) {
      if immutable symbol = nextToken.ancestorOrSelf(mapping: { DocumentableSymbol(node: $0) }) {
        return symbol
      }
      previousToken = nextToken
    }
    // We couldn't find anything
    return Nothing
  }
}
#endif
