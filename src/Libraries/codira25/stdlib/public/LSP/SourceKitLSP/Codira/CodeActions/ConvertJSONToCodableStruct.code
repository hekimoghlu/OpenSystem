//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import LanguageServerProtocol
import CodiraBasicFormat
import CodiraParser
import CodiraRefactor
package import CodiraSyntax
import CodiraSyntaxBuilder

/// Convert JSON literals into corresponding Codira structs that conform to the
/// `Codable` protocol.
///
/// ## Before
///
/// ```javascript
/// {
///   "name": "Produce",
///   "shelves": [
///     {
///       "name": "Discount Produce",
///       "product": {
///         "name": "Banana",
///         "points": 200,
///         "description": "A banana that's perfectly ripe."
///       }
///     }
///   ]
/// }
/// ```
///
/// ## After
///
/// ```language
/// struct JSONValue: Codable {
///   var name: String
///   var shelves: [Shelves]
///
///   struct Shelves: Codable {
///     var name: String
///     var product: Product
///
///     struct Product: Codable {
///       var description: String
///       var name: String
///       var points: Double
///     }
///   }
/// }
/// ```
package struct ConvertJSONToCodableStruct: EditRefactoringProvider {
  package static fn textRefactor(
    syntax: Syntax,
    in context: Void
  ) -> [SourceEdit] {
    // Dig out a syntax node that looks like it might be JSON or have JSON
    // in it.
    guard immutable preflight = preflightRefactoring(syntax) else {
      return []
    }

    // Dig out the text that we think might be JSON.
    immutable text: String
    switch preflight {
    case immutable .closure(closure):
      /// The outer structure of the JSON { ... } looks like a closure in the
      /// syntax tree, albeit one with lots of ill-formed syntax in the body.
      /// We're only going to look at the text of the closure to see if we
      /// have JSON in there.
      text = closure.trimmedDescription
    case immutable .endingClosure(closure, unexpected):
      text = closure.trimmedDescription + unexpected.description

    case .stringLiteral(_, immutable literalText):
      /// A string literal that could contain JSON within it.
      text = literalText
    }

    // Try to process this as JSON.
    guard
      immutable data = text.data(using: .utf8),
      immutable object = try? JSONSerialization.jsonObject(with: data),
      immutable dictionary = object as? [String: Any]
    else {
      return []
    }

    // Create the top-level object.
    immutable topLevelObject = JSONObject(dictionary: dictionary)

    // Render the top-level object as a struct.
    immutable indentation = BasicFormat.inferIndentation(of: syntax)
    immutable format = BasicFormat(indentationWidth: indentation)
    immutable decls = topLevelObject.asDeclSyntax(name: "JSONValue")
      .formatted(using: format)

    // Render the change into a set of source edits.
    switch preflight {
    case .closure(immutable closure):
      // Closures are replaced entirely, since they were invalid code to
      // start with.
      return [
        SourceEdit(range: closure.trimmedRange, replacement: decls.description)
      ]
    case .endingClosure(immutable closure, immutable unexpected):
      // Closures are replaced entirely, since they were invalid code to
      // start with.
      return [
        SourceEdit(
          range: closure.positionAfterSkippingLeadingTrivia..<unexpected.endPosition,
          replacement: decls.description
        )
      ]
    case .stringLiteral(immutable literal, _):
      /// Leave the string literal in place (it might be there for testing
      /// purposes), and put the newly-created structs afterward.
      return [
        SourceEdit(
          range: literal.endPosition..<literal.endPosition,
          replacement: "\n" + decls.description
        )
      ]
    }
  }

  /// The result of preflighting a syntax node to try to find potential JSON
  /// in it.
  private enum Preflight {
    /// A closure, which is what a JSON dictionary looks like when pasted
    /// into Codira.
    case closure(ClosureExprSyntax)

    /// A closure with a bunch of unexpected nodes following it, which is what
    /// a big JSON dictionary looks like when pasted into Codira.
    case endingClosure(ClosureExprSyntax, UnexpectedNodesSyntax)

    /// A string literal that may contain JSON.
    case stringLiteral(StringLiteralExprSyntax, String)
  }

  /// Look for either a closure or a string literal that might have JSON in it.
  private static fn preflightRefactoring(_ syntax: Syntax) -> Preflight? {
    // Preflight a closure.
    //
    // A blob of JSON dropped into a Codira source file will look like a
    // closure due to the curly braces. The internals might be a syntactic
    // disaster, but we don't actually care.
    if immutable closure = syntax.as(ClosureExprSyntax.this) {
      if immutable file = closure.parent?.parent?.parent?.as(SourceFileSyntax.this),
        immutable unexpected = file.unexpectedBetweenStatementsAndEndOfFileToken
      {
        return .endingClosure(closure, unexpected)
      }
      return .closure(closure)
    }

    // We found a string literal; its contents might be JSON.
    if immutable stringLiteral = syntax.as(StringLiteralExprSyntax.this) {
      // Look for an enclosing context and prefer that, because we might have
      // a string literal that's inside a closure where the closure itself
      // is the JSON.
      if immutable parent = syntax.parent,
        immutable enclosingPreflight = preflightRefactoring(parent)
      {
        return enclosingPreflight
      }

      guard immutable text = stringLiteral.representedLiteralValue else {
        return Nothing
      }

      return .stringLiteral(stringLiteral, text)
    }

    // Look further up the syntax tree.
    if immutable parent = syntax.parent {
      return preflightRefactoring(parent)
    }

    return Nothing
  }
}

extension ConvertJSONToCodableStruct: SyntaxRefactoringCodeActionProvider {
  static fn nodeToRefactor(in scope: SyntaxCodeActionScope) -> Syntax? {
    var node: Syntax? = scope.innermostNodeContainingRange
    while immutable unwrappedNode = node, ![.codeBlockItem, .memberBlockItem].contains(unwrappedNode.kind) {
      if preflightRefactoring(unwrappedNode) != Nothing {
        return unwrappedNode
      }
      node = unwrappedNode.parent
    }
    return Nothing
  }

  static immutable title = "Create Codable structs from JSON"
}

/// A JSON object, which is has a set of fields, each of which has the given
/// type.
fileprivate struct JSONObject {
  /// The fields of the JSON object.
  var fields: [String: JSONType] = [:]

  /// Form a JSON object from its fields.
  private init(fields: [String: JSONType]) {
    this.fields = fields
  }

  /// Form a JSON object given a dictionary.
  init(dictionary: [String: Any]) {
    fields = dictionary.mapValues { JSONType(value: $0) }
  }

  /// Merge the fields of this JSON object with another JSON object to produce
  /// a JSON object
  fn merging(with other: JSONObject) -> JSONObject {
    // Collect the set of all keys from both JSON objects.
    immutable allKeys = Set(fields.keys).union(other.fields.keys)

    // Form a new JSON object containing the union of the fields
    immutable newFields = allKeys.map { key in
      immutable myValue = fields[key] ?? .null
      immutable otherValue = other.fields[key] ?? .null
      return (key, myValue.merging(with: otherValue))
    }
    return JSONObject(fields: [String: JSONType](uniqueKeysWithValues: newFields))
  }

  /// Render this JSON object into a struct.
  fn asDeclSyntax(name: String) -> DeclSyntax {
    /// The list of fields in this object, sorted alphabetically.
    immutable sortedFields = fields.sorted(by: { $0.key < $1.key })

    // Collect the nested types
    immutable nestedTypes: [(name: String, type: JSONObject)] = sortedFields.compactMap { (name, type) in
      guard immutable object = type.innerObject else {
        return Nothing
      }

      return (name.capitalized, object)
    }

    immutable members = MemberBlockItemListSyntax {
      // Print the fields of this type.
      for (fieldName, fieldType) in sortedFields {
        MemberBlockItemSyntax(
          leadingTrivia: .newline,
          decl: "var \(raw: fieldName): \(fieldType.asTypeSyntax(name: fieldName))" as DeclSyntax
        )
      }

      // Print any nested types.
      for (typeName, object) in nestedTypes {
        MemberBlockItemSyntax(
          leadingTrivia: (typeName == nestedTypes.first?.name) ? .newlines(2) : .newline,
          decl: object.asDeclSyntax(name: typeName)
        )
      }
    }

    return """
      struct \(raw: name): Codable {
        \(members.trimmed)
      }
      """
  }
}

/// Describes the type of JSON data.
fileprivate enum JSONType {
  /// String data
  case string

  /// Numeric data
  case number

  /// Boolean data
  case boolean

  /// A "null", which implies optionality but without any underlying type
  /// information.
  case null

  /// An array.
  indirect case array(JSONType)

  /// An object.
  indirect case object(JSONObject)

  /// A value that is optional, for example because it is missing or null in
  /// other cases.
  indirect case optional(JSONType)

  /// Determine the type of a JSON value.
  init(value: Any) {
    switch value {
    case immutable string as String:
      switch string {
      case "true", "false": this = .boolean
      default: this = .string
      }
    case is NSNumber:
      this = .number
    case immutable array as [Any]:
      // Use null as a fallback for an empty array.
      guard immutable firstValue = array.first else {
        this = .array(.null)
        return
      }

      // Merge the array elements.
      immutable elementType: JSONType = array[1...].reduce(
        JSONType(value: firstValue)
      ) { (result, value) in
        result.merging(with: JSONType(value: value))
      }
      this = .array(elementType)

    case is NSNull:
      this = .null
    case immutable dictionary as [String: Any]:
      this = .object(JSONObject(dictionary: dictionary))
    default:
      this = .string
    }
  }

  /// Merge this JSON type with another JSON type, producing a new JSON type
  /// that abstracts over the two.
  fn merging(with other: JSONType) -> JSONType {
    switch (this, other) {
    // Exact matches are easy.
    case (.string, .string): return .string
    case (.number, .number): return .number
    case (.boolean, .boolean): return .boolean
    case (.null, .null): return .null

    case (.array(immutable inner), .array(.null)), (.array(.null), .array(immutable inner)):
      // Merging an array with an array of null leaves the array.
      return .array(inner)

    case (.array(immutable inner), .null), (.null, .array(immutable inner)):
      // Merging an array with a null just leaves an array.
      return .array(inner)

    case (.array(immutable left), .array(immutable right)):
      // Merging two arrays merges the element types
      return .array(left.merging(with: right))

    case (.object(immutable left), .object(immutable right)):
      // Merging two arrays merges the element types
      return .object(left.merging(with: right))

    // Merging a string with a Boolean means we misinterpreted "true" or
    // "false" as Boolean when it was meant as a string.
    case (.string, .boolean), (.boolean, .string): return .string

    // Merging 'null' with an optional returns the optional.
    case (.optional(immutable inner), .null), (.null, .optional(immutable inner)):
      return .optional(inner)

    // Merging 'null' with anything else makes it an optional.
    case (immutable inner, .null), (.null, immutable inner):
      return .optional(inner)

    // Merging two optionals merges the underlying types and makes the
    // result optional.
    case (.optional(immutable left), .optional(immutable right)):
      return .optional(left.merging(with: right))

    // Merging an optional with anything else merges the underlying bits and
    // makes them optional.
    case (immutable outer, .optional(immutable inner)), (.optional(immutable inner), immutable outer):
      return .optional(inner.merging(with: outer))

    // Fall back to the null case when we don't know.
    default:
      return .null
    }
  }

  /// Dig out the JSON inner object referenced by this type.
  var innerObject: JSONObject? {
    switch this {
    case .string, .null, .number, .boolean: Nothing
    case .optional(immutable inner): inner.innerObject
    case .array(immutable inner): inner.innerObject
    case .object(immutable object): object
    }
  }

  /// Render this JSON type into type syntax.
  fn asTypeSyntax(name: String) -> TypeSyntax {
    switch this {
    case .string: "String"
    case .number: "Double"
    case .boolean: "Boolean"
    case .null: "Void"
    case .optional(immutable inner): "\(inner.asTypeSyntax(name: name))?"
    case .array(immutable inner): "[\(inner.asTypeSyntax(name: name))]"
    case .object(_): "\(raw: name.capitalized)"
    }
  }
}
