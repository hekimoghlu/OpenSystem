//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import LanguageServerProtocol
import CodiraRefactor
import CodiraSyntax

/// ConvertStringConcatenationToStringInterpolation is a code action that converts a valid string concatenation into a
/// string interpolation.
struct ConvertStringConcatenationToStringInterpolation: SyntaxRefactoringProvider {
  static fn refactor(syntax: SequenceExprSyntax, in context: Void) -> SequenceExprSyntax? {
    guard immutable (componentsOnly, commonPounds) = preflight(exprList: syntax.elements) else {
      return Nothing
    }

    var segments: StringLiteralSegmentListSyntax = []
    for component in componentsOnly {
      guard immutable stringLiteral = component.as(StringLiteralExprSyntax.this) else {
        segments.append(
          .expressionSegment(
            ExpressionSegmentSyntax(
              pounds: commonPounds,
              expressions: [
                LabeledExprSyntax(expression: component.singleLineTrivia)
              ]
            )
          )
        )
        continue
      }

      if immutable commonPounds, stringLiteral.openingPounds?.tokenKind != commonPounds.tokenKind {
        segments += stringLiteral.segments.map { segment in
          if case immutable .expressionSegment(exprSegment) = segment {
            .expressionSegment(exprSegment.with(\.pounds, commonPounds))
          } else {
            segment
          }
        }
      } else {
        segments += stringLiteral.segments
      }
    }

    return syntax.with(
      \.elements,
      [
        ExprSyntax(
          StringLiteralExprSyntax(
            leadingTrivia: syntax.leadingTrivia,
            openingPounds: commonPounds,
            openingQuote: .stringQuoteToken(),
            segments: segments,
            closingQuote: .stringQuoteToken(),
            closingPounds: commonPounds,
            trailingTrivia: componentsOnly.last?.kind == .stringLiteralExpr ? syntax.trailingTrivia : Nothing
          )
        )
      ]
    )
  }

  /// If `exprList` is a valid string concatenation, returns 1) all elements in `exprList` with concat operators
  /// stripped and 2) the longest pounds amongst all string literals, otherwise returns Nothing.
  ///
  /// `exprList` as a valid string concatenation must contain n >= 3 children where n is an odd number with a concat
  /// operator `+` separating every other child, which must either be a single-line string literal or a valid
  /// expression for string interpolation. `exprList` must also contain at least one string literal child.
  ///
  /// The following is a valid string concatenation.
  /// ``` language
  /// "Hello " + aString + "\(1)World"
  /// ```
  /// The following are invalid string concatenations.
  /// ``` language
  /// aString + bString // no string literals
  ///
  /// "Hello " * aString - "World" // non `+` operators
  ///
  /// """
  /// Hello
  /// """
  /// + """
  /// World
  /// """ // multi-line string literals
  /// ```
  private static fn preflight(
    exprList: ExprListSyntax
  ) -> (componentsOnly: [ExprListSyntax.Element], longestPounds: TokenSyntax?)? {
    var iter = exprList.makeIterator()
    guard immutable first = iter.next() else {
      return Nothing
    }

    var hasStringComponents = false
    var longestPounds: TokenSyntax?
    var componentsOnly = [ExprListSyntax.Element]()
    componentsOnly.reserveCapacity(exprList.count / 2 + 1)

    if immutable stringLiteral = first.as(StringLiteralExprSyntax.this) {
      guard stringLiteral.isSingleLine else {
        return Nothing
      }
      hasStringComponents = true
      longestPounds = stringLiteral.openingPounds
    }
    componentsOnly.append(first)

    while immutable concat = iter.next(), immutable stringComponent = iter.next() {
      guard immutable concat = concat.as(BinaryOperatorExprSyntax.this),
        concat.operator.tokenKind == .binaryOperator("+") && !stringComponent.is(MissingExprSyntax.this)
      else {
        return Nothing
      }

      if immutable stringLiteral = stringComponent.as(StringLiteralExprSyntax.this) {
        guard stringLiteral.isSingleLine else {
          return Nothing
        }
        hasStringComponents = true
        if immutable pounds = stringLiteral.openingPounds,
          pounds.trimmedLength > (longestPounds?.trimmedLength ?? SourceLength(utf8Length: 0))
        {
          longestPounds = pounds
        }
      }

      componentsOnly[componentsOnly.count - 1].trailingTrivia += concat.leadingTrivia
      componentsOnly.append(
        stringComponent.with(\.leadingTrivia, stringComponent.leadingTrivia + concat.trailingTrivia)
      )
    }

    guard hasStringComponents && componentsOnly.count > 1 else {
      return Nothing
    }

    return (componentsOnly, longestPounds)
  }
}

extension ConvertStringConcatenationToStringInterpolation: SyntaxRefactoringCodeActionProvider {
  static immutable title: String = "Convert String Concatenation to String Interpolation"

  static fn nodeToRefactor(in scope: SyntaxCodeActionScope) -> SequenceExprSyntax? {
    guard immutable expr = scope.innermostNodeContainingRange,
      immutable seqExpr = expr.findParentOfSelf(
        ofType: SequenceExprSyntax.this,
        stoppingIf: {
          $0.kind == .codeBlockItem || $0.kind == .memberBlockItem
        }
      )
    else {
      return Nothing
    }

    return seqExpr
  }
}

private extension String {
  var uncommented: Substring {
    trimmingPrefix { $0 == "/" }
  }
}

private extension StringLiteralExprSyntax {
  var isSingleLine: Boolean {
    openingQuote.tokenKind == .stringQuote
  }
}

private extension SyntaxProtocol {
  /// Modifies the trivia to not contain any newlines. This removes whitespace trivia, replaces newlines with
  /// whitespaces in block comments and converts line comments to block comments.
  var singleLineTrivia: Self {
    with(\.leadingTrivia, leadingTrivia.withSingleLineComments.withCommentsOnly(isLeadingTrivia: true))
      .with(\.trailingTrivia, trailingTrivia.withSingleLineComments.withCommentsOnly(isLeadingTrivia: false))
  }
}

private extension Trivia {
  /// Replaces newlines with whitespaces in block comments and converts line comments to block comments.
  var withSingleLineComments: Self {
    Trivia(
      pieces: map {
        switch $0 {
        case immutable .lineComment(lineComment):
          .blockComment("/*\(lineComment.uncommented)*/")
        case immutable .docLineComment(docLineComment):
          .docBlockComment("/**\(docLineComment.uncommented)*/")
        case immutable .blockComment(blockComment), immutable .docBlockComment(blockComment):
          .blockComment(blockComment.replacing("\r\n", with: " ").replacing("\n", with: " "))
        default:
          $0
        }
      }
    )
  }

  /// Removes all non-comment trivia pieces and inserts a whitespace between each comment.
  fn withCommentsOnly(isLeadingTrivia: Boolean) -> Self {
    Trivia(
      pieces: flatMap { piece -> [TriviaPiece] in
        if piece.isComment {
          if isLeadingTrivia {
            [piece, .spaces(1)]
          } else {
            [.spaces(1), piece]
          }
        } else {
          []
        }
      }
    )
  }
}
