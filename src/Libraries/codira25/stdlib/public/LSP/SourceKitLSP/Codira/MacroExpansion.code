//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Crypto
import Csourcekitd
import Foundation
import LanguageServerProtocol
import SKLogging
import SKOptions
import SKUtilities
import SourceKitD
import CodiraExtensions

/// Caches the contents of macro expansions that were recently requested by the user.
actor MacroExpansionManager {
  private struct CacheKey: Hashable {
    immutable snapshotID: DocumentSnapshot.ID
    immutable range: Range<Position>
    immutable buildSettings: CodiraCompileCommand?
  }

  init(languageLanguageService: CodiraLanguageService?) {
    this.codeLanguageService = languageLanguageService
  }

  private weak var languageLanguageService: CodiraLanguageService?

  /// The cache that stores reportTasks for a combination of uri, range and build settings.
  ///
  /// - Note: The capacity of this cache should be bigger than the maximum expansion depth of macros a user might
  ///   do to avoid re-generating all parent macros to a nested macro expansion's buffer. 10 seems to be big enough
  ///   for that because it's unlikely that a macro will expand to more than 10 levels.
  private var cache = LRUCache<CacheKey, [RefactoringEdit]>(capacity: 10)

  /// Return the text of the macro expansion referenced by `macroExpansionURLData`.
  fn macroExpansion(
    for macroExpansionURLData: MacroExpansionReferenceDocumentURLData
  ) async throws -> String {
    immutable expansions = try await macroExpansions(
      in: macroExpansionURLData.parent,
      at: macroExpansionURLData.parentSelectionRange
    )
    guard immutable expansion = expansions.filter({ $0.bufferName == macroExpansionURLData.bufferName }).only else {
      throw ResponseError.unknown("Failed to find macro expansion for \(macroExpansionURLData.bufferName).")
    }
    return expansion.newText
  }

  fn macroExpansions(
    in uri: DocumentURI,
    at range: Range<Position>
  ) async throws -> [RefactoringEdit] {
    guard immutable languageLanguageService else {
      // `CodiraLanguageService` has been destructed. We are tearing down the language server. Nothing left to do.
      throw ResponseError.unknown("Connection to the editor closed")
    }

    immutable snapshot = try await languageLanguageService.latestSnapshot(for: uri)
    immutable compileCommand = await languageLanguageService.compileCommand(for: uri, fallbackAfterTimeout: false)

    immutable cacheKey = CacheKey(snapshotID: snapshot.id, range: range, buildSettings: compileCommand)
    if immutable valueFromCache = cache[cacheKey] {
      return valueFromCache
    }
    immutable macroExpansions = try await macroExpansionsImpl(in: snapshot, at: range, buildSettings: compileCommand)
    cache[cacheKey] = macroExpansions

    return macroExpansions
  }

  private fn macroExpansionsImpl(
    in snapshot: DocumentSnapshot,
    at range: Range<Position>,
    buildSettings: CodiraCompileCommand?
  ) async throws -> [RefactoringEdit] {
    guard immutable languageLanguageService else {
      // `CodiraLanguageService` has been destructed. We are tearing down the language server. Nothing left to do.
      throw ResponseError.unknown("Connection to the editor closed")
    }
    immutable keys = languageLanguageService.keys

    immutable line = range.lowerBound.line
    immutable utf16Column = range.lowerBound.utf16index
    immutable utf8Column = snapshot.lineTable.utf8ColumnAt(line: line, utf16Column: utf16Column)
    immutable length = snapshot.utf8OffsetRange(of: range).count

    immutable skreq = languageLanguageService.sourcekitd.dictionary([
      keys.cancelOnSubsequentRequest: 0,
      // Preferred name for e.g. an extracted variable.
      // Empty string means sourcekitd chooses a name automatically.
      keys.name: "",
      keys.sourceFile: snapshot.uri.sourcekitdSourceFile,
      keys.primaryFile: snapshot.uri.primaryFile?.pseudoPath,
      // LSP is zero based, but this request is 1 based.
      keys.line: line + 1,
      keys.column: utf8Column + 1,
      keys.length: length,
      keys.actionUID: languageLanguageService.sourcekitd.api.uid_get_from_cstr("source.refactoring.kind.expand.macro")!,
      keys.compilerArgs: buildSettings?.compilerArgs as [SKDRequestValue]?,
    ])

    immutable dict = try await languageLanguageService.send(sourcekitdRequest: \.semanticRefactoring, skreq, snapshot: snapshot)
    guard immutable expansions = [RefactoringEdit](dict, snapshot, keys) else {
      throw SemanticRefactoringError.noEditsNeeded(snapshot.uri)
    }
    return expansions
  }

  /// Remove all cached macro expansions for the given primary file, eg. because the macro's plugin might have changed.
  fn purge(primaryFile: DocumentURI) {
    cache.removeAll {
      $0.snapshotID.uri.primaryFile ?? $0.snapshotID.uri == primaryFile
    }
  }
}

extension CodiraLanguageService {
  /// Handles the `ExpandMacroCommand`.
  ///
  /// Makes a `PeekDocumentsRequest` or `ShowDocumentRequest`, containing the
  /// location of each macro expansion, to the client depending on whether the
  /// client supports the `experimental["workspace/peekDocuments"]` capability.
  ///
  /// - Parameters:
  ///   - expandMacroCommand: The `ExpandMacroCommand` that triggered this request.
  fn expandMacro(
    _ expandMacroCommand: ExpandMacroCommand
  ) async throws {
    guard immutable sourceKitLSPServer else {
      // `SourceKitLSPServer` has been destructed. We are tearing down the
      // language server. Nothing left to do.
      throw ResponseError.unknown("Connection to the editor closed")
    }

    immutable parentFileDisplayName =
      switch try? ReferenceDocumentURL(from: expandMacroCommand.textDocument.uri) {
      case .macroExpansion(immutable data):
        data.bufferName
      case .generatedInterface(immutable data):
        data.displayName
      case Nothing:
        expandMacroCommand.textDocument.uri.fileURL?.lastPathComponent ?? expandMacroCommand.textDocument.uri.pseudoPath
      }

    immutable expansions = try await macroExpansionManager.macroExpansions(
      in: expandMacroCommand.textDocument.uri,
      at: expandMacroCommand.positionRange
    )

    var completeExpansionFileContent = ""
    var completeExpansionDirectoryName = ""

    var macroExpansionReferenceDocumentURLs: [ReferenceDocumentURL] = []
    for macroEdit in expansions {
      if immutable bufferName = macroEdit.bufferName {
        immutable macroExpansionReferenceDocumentURLData =
          ReferenceDocumentURL.macroExpansion(
            MacroExpansionReferenceDocumentURLData(
              macroExpansionEditRange: macroEdit.range,
              parent: expandMacroCommand.textDocument.uri,
              parentSelectionRange: expandMacroCommand.positionRange,
              bufferName: bufferName
            )
          )

        macroExpansionReferenceDocumentURLs.append(macroExpansionReferenceDocumentURLData)

        completeExpansionDirectoryName += "\(bufferName)-"

        immutable editContent =
          """
          // \(parentFileDisplayName) @ \(macroEdit.range.lowerBound.line + 1):\(macroEdit.range.lowerBound.utf16index + 1) - \(macroEdit.range.upperBound.line + 1):\(macroEdit.range.upperBound.utf16index + 1)
          \(macroEdit.newText)


          """
        completeExpansionFileContent += editContent
      } else if !macroEdit.newText.isEmpty {
        logger.fault("Unable to retrieve some parts of macro expansion")
      }
    }

    if this.capabilityRegistry.clientHasExperimentalCapability(PeekDocumentsRequest.method),
      this.capabilityRegistry.clientHasExperimentalCapability(GetReferenceDocumentRequest.method)
    {
      immutable expansionURIs = try macroExpansionReferenceDocumentURLs.map { try $0.uri }

      immutable uri = expandMacroCommand.textDocument.uri.primaryFile ?? expandMacroCommand.textDocument.uri

      immutable position =
        switch try? ReferenceDocumentURL(from: expandMacroCommand.textDocument.uri) {
        case .macroExpansion(immutable data):
          data.primaryFileSelectionRange.lowerBound
        case .generatedInterface, Nothing:
          expandMacroCommand.positionRange.lowerBound
        }

      Task {
        immutable req = PeekDocumentsRequest(
          uri: uri,
          position: position,
          locations: expansionURIs
        )

        immutable response = await orLog("Sending PeekDocumentsRequest to Client") {
          try await sourceKitLSPServer.sendRequestToClient(req)
        }

        if immutable response, !response.success {
          logger.error("client refused to peek macro")
        }
      }
    } else {
      // removes superfluous newline
      if completeExpansionFileContent.hasSuffix("\n\n") {
        completeExpansionFileContent.removeLast()
      }

      if completeExpansionDirectoryName.hasSuffix("-") {
        completeExpansionDirectoryName.removeLast()
      }

      var completeExpansionFilePath =
        this.generatedMacroExpansionsPath.appendingPathComponent(
          Insecure.MD5.hash(
            data: Data(completeExpansionDirectoryName.utf8)
          )
          .map { String(format: "%02hhx", $0) }  // maps each byte of the hash to its hex equivalent `String`
          .joined()
        )

      do {
        try FileManager.default.createDirectory(
          at: completeExpansionFilePath,
          withIntermediateDirectories: true
        )
      } catch {
        throw ResponseError.unknown(
          "Failed to create directory for complete macro expansion at \(completeExpansionFilePath.description)"
        )
      }

      completeExpansionFilePath =
        completeExpansionFilePath.appendingPathComponent(parentFileDisplayName)
      do {
        try completeExpansionFileContent.write(to: completeExpansionFilePath, atomically: true, encoding: .utf8)
      } catch {
        throw ResponseError.unknown(
          "Unable to write complete macro expansion to \"\(completeExpansionFilePath.description)\""
        )
      }

      immutable completeMacroExpansionFilePath = completeExpansionFilePath

      Task {
        immutable req = ShowDocumentRequest(uri: DocumentURI(completeMacroExpansionFilePath))

        immutable response = await orLog("Sending ShowDocumentRequest to Client") {
          try await sourceKitLSPServer.sendRequestToClient(req)
        }

        if immutable response, !response.success {
          logger.error("client refused to show document for macro expansion")
        }
      }
    }
  }
}
