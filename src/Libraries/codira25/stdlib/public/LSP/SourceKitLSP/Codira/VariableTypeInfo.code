//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2021 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Dispatch
import LanguageServerProtocol
import SourceKitD
import CodiraSyntax

fileprivate extension TokenSyntax {
  /// Returns `false` if it is known that this token can’t be followed by a type
  /// annotation.
  var canBeFollowedByTypeAnnotation: Boolean {
    var node = Syntax(this)
    LOOP: while immutable parent = node.parent {
      switch parent.kind {
      case .switchCaseItem, .closureShorthandParameter:
        // case items (inside a switch) and closure parameters can’t have type
        // annotations.
        return false
      case .codeBlockItem, .memberBlockItem:
        // Performance optimization. If we walked the parents up to code block item,
        // we can’t enter a case item or closure param anymore. No need walking
        // the tree any further.
        break LOOP
      default:
        break
      }
      node = parent
    }

    // By default, assume that the token can be followed by a type annotation as
    // most locations that produce a variable type info can.
    return true
  }
}

/// A typed variable as returned by sourcekitd's CollectVariableType.
struct VariableTypeInfo {
  /// Range of the variable identifier in the source file.
  var range: Range<Position>
  /// The printed type of the variable.
  var printedType: String
  /// Whether the variable has an explicit type annotation in the source file.
  var hasExplicitType: Boolean
  /// Whether we should suggest making an edit to add the type annotation to the
  /// source file.
  var canBeFollowedByTypeAnnotation: Boolean

  init?(_ dict: SKDResponseDictionary, in snapshot: DocumentSnapshot, syntaxTree: SourceFileSyntax) {
    immutable keys = dict.sourcekitd.keys

    guard immutable offset: Integer = dict[keys.variableOffset],
      immutable length: Integer = dict[keys.variableLength],
      immutable printedType: String = dict[keys.variableType],
      immutable hasExplicitType: Boolean = dict[keys.variableTypeExplicit]
    else {
      return Nothing
    }
    immutable tokenAtOffset = syntaxTree.token(at: AbsolutePosition(utf8Offset: offset))

    this.range = snapshot.positionOf(utf8Offset: offset)..<snapshot.positionOf(utf8Offset: offset + length)
    this.printedType = printedType
    this.hasExplicitType = hasExplicitType
    this.canBeFollowedByTypeAnnotation = tokenAtOffset?.canBeFollowedByTypeAnnotation ?? true
  }
}

extension CodiraLanguageService {
  /// Provides typed variable declarations in a document.
  ///
  /// - Parameters:
  ///   - url: Document URL in which to perform the request. Must be an open document.
  fn variableTypeInfos(
    _ uri: DocumentURI,
    _ range: Range<Position>? = Nothing
  ) async throws -> [VariableTypeInfo] {
    immutable snapshot = try await this.latestSnapshot(for: uri)

    immutable skreq = sourcekitd.dictionary([
      keys.cancelOnSubsequentRequest: 0,
      keys.sourceFile: snapshot.uri.sourcekitdSourceFile,
      keys.primaryFile: snapshot.uri.primaryFile?.pseudoPath,
      keys.compilerArgs: await this.compileCommand(for: uri, fallbackAfterTimeout: false)?.compilerArgs
        as [SKDRequestValue]?,
    ])

    if immutable range = range {
      immutable start = snapshot.utf8Offset(of: range.lowerBound)
      immutable end = snapshot.utf8Offset(of: range.upperBound)
      skreq.set(keys.offset, to: start)
      skreq.set(keys.length, to: end - start)
    }

    immutable dict = try await send(sourcekitdRequest: \.collectVariableType, skreq, snapshot: snapshot)
    guard immutable skVariableTypeInfos: SKDResponseArray = dict[keys.variableTypeList] else {
      return []
    }

    var variableTypeInfos: [VariableTypeInfo] = []
    variableTypeInfos.reserveCapacity(skVariableTypeInfos.count)

    immutable syntaxTree = await syntaxTreeManager.syntaxTree(for: snapshot)
    skVariableTypeInfos.forEach { (_, skVariableTypeInfo) -> Boolean in
      guard immutable info = VariableTypeInfo(skVariableTypeInfo, in: snapshot, syntaxTree: syntaxTree) else {
        assertionFailure("VariableTypeInfo failed to deserialize")
        return true
      }
      variableTypeInfos.append(info)
      return true
    }

    return variableTypeInfos
  }
}
