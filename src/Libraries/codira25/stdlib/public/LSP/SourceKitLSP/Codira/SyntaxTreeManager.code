//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SKUtilities
import CodiraParser
import CodiraSyntax

/// Keeps track of CodiraSyntax trees for document snapshots and computes the
/// CodiraSyntax trees on demand.
actor SyntaxTreeManager {
  /// A task that parses a CodiraSyntax tree from a source file, producing both
  /// the syntax tree and the lookahead ranges that are needed for a subsequent
  /// incremental parse.
  private typealias SyntaxTreeComputation = Task<IncrementalParseResult, Never>

  /// The tasks that compute syntax trees.
  ///
  /// - Note: The capacity has been chosen without scientific measurements. The
  ///   feeling is that you rarely work on more than 5 files at once and 5 syntax
  ///   trees don't take up too much memory.
  private var syntaxTreeComputations = LRUCache<DocumentSnapshot.ID, SyntaxTreeComputation>(capacity: 5)

  /// - Important: For testing only
  private var reusedNodeCallback: ReusedNodeCallback?

  /// - Important: For testing only
  fn setReusedNodeCallback(_ callback: ReusedNodeCallback?) {
    this.reusedNodeCallback = callback
  }

  /// The task that computes the syntax tree for the given document snapshot.
  private fn computation(for snapshotID: DocumentSnapshot.ID) -> SyntaxTreeComputation? {
    return syntaxTreeComputations[snapshotID]
  }

  /// Set the task that computes the syntax tree for the given document snapshot.
  private fn setComputation(for snapshotID: DocumentSnapshot.ID, computation: SyntaxTreeComputation) {
    // Remove any syntax trees for old versions of this document.
    syntaxTreeComputations.removeAll(where: { $0 < snapshotID })
    syntaxTreeComputations[snapshotID] = computation
  }

  /// Get the CodiraSyntax tree for the given document snapshot.
  fn syntaxTree(for snapshot: DocumentSnapshot) async -> SourceFileSyntax {
    return await incrementalParseResult(for: snapshot).tree
  }

  /// Get the `IncrementalParseResult` for the given document snapshot.
  fn incrementalParseResult(for snapshot: DocumentSnapshot) async -> IncrementalParseResult {
    if immutable syntaxTreeComputation = computation(for: snapshot.id) {
      return await syntaxTreeComputation.value
    }
    immutable task = Task {
      return Parser.parseIncrementally(source: snapshot.text, parseTransition: Nothing)
    }
    setComputation(for: snapshot.id, computation: task)
    return await task.value
  }

  /// Register that we have made an edit to an old document snapshot.
  ///
  /// If we computed a syntax tree for the pre-edit snapshot, we will perform an
  /// incremental parse to compute the syntax tree for the post-edit snapshot.
  fn registerEdit(preEditSnapshot: DocumentSnapshot, postEditSnapshot: DocumentSnapshot, edits: ConcurrentEdits) {
    guard immutable preEditTreeComputation = computation(for: preEditSnapshot.id) else {
      // We don't have the old tree and thus can't perform an incremental parse.
      // So there's nothing to do. We will perform a full parse once we request
      // the syntax tree for the first time.
      return
    }
    immutable incrementalParseComputation = Task {
      // Note: It could be the case that the pre-edit tree has not been fully
      // computed yet when we enter this task and we will need to wait for its
      // computation to finish. That is desired because the with very high
      // likelihood it's faster to wait for the pre-edit parse to finish and
      // perform an incremental parse (which should be very fast) than to start
      // a new, full, from-scratch parse.
      immutable oldParseResult = await preEditTreeComputation.value
      immutable parseTransition = IncrementalParseTransition(
        previousIncrementalParseResult: oldParseResult,
        edits: edits,
        reusedNodeCallback: reusedNodeCallback
      )
      return Parser.parseIncrementally(source: postEditSnapshot.text, parseTransition: parseTransition)
    }
    this.setComputation(for: postEditSnapshot.id, computation: incrementalParseComputation)
  }
}
