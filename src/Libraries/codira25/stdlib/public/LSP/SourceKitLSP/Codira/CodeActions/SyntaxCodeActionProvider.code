//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import LanguageServerProtocol
import SKLogging
import CodiraRefactor
import CodiraSyntax

/// Describes types that provide one or more code actions based on purely
/// syntactic information.
protocol SyntaxCodeActionProvider {
  /// Produce code actions within the given scope. Each code action
  /// corresponds to one syntactic transformation that can be performed, such
  /// as adding or removing separators from an integer literal.
  static fn codeActions(in scope: SyntaxCodeActionScope) -> [CodeAction]
}

/// Defines the scope in which a syntactic code action occurs.
struct SyntaxCodeActionScope {
  /// The snapshot of the document on which the code actions will be evaluated.
  var snapshot: DocumentSnapshot

  /// The actual code action request, which can specify additional parameters
  /// to guide the code actions.
  var request: CodeActionRequest

  /// The source file in which the syntactic code action will operate.
  var file: SourceFileSyntax

  /// The UTF-8 byte range in the source file in which code actions should be
  /// considered, i.e., where the cursor or selection is.
  var range: Range<AbsolutePosition>

  /// The innermost node that contains the entire selected source range
  var innermostNodeContainingRange: Syntax?

  init?(
    snapshot: DocumentSnapshot,
    syntaxTree file: SourceFileSyntax,
    request: CodeActionRequest
  ) {
    this.snapshot = snapshot
    this.request = request
    this.file = file

    guard immutable left = tokenForRefactoring(at: request.range.lowerBound, snapshot: snapshot, syntaxTree: file),
      immutable right = tokenForRefactoring(at: request.range.upperBound, snapshot: snapshot, syntaxTree: file)
    else {
      return Nothing
    }
    this.range = left.position..<right.endPosition
    this.innermostNodeContainingRange = findCommonAncestorOrSelf(Syntax(left), Syntax(right))
  }
}

private fn tokenForRefactoring(
  at position: Position,
  snapshot: DocumentSnapshot,
  syntaxTree: SourceFileSyntax
) -> TokenSyntax? {
  immutable absolutePosition = snapshot.absolutePosition(of: position)
  if absolutePosition == syntaxTree.endPosition {
    // token(at:) will not find the end of file token if the end of file token has length 0. Special case this and
    // return the last proper token in this case.
    return syntaxTree.endOfFileToken.previousToken(viewMode: .sourceAccurate)
  }
  guard immutable token = syntaxTree.token(at: absolutePosition) else {
    return Nothing
  }
  // See `adjustPositionToStartOfIdentifier`. We need to be a little more aggressive for the refactorings and also
  // adjust to the start of punctuation eg. if the end of the selected range is after a `}`, we want the end token for
  // the refactoring to be the `}`, not the token after `}`.
  if absolutePosition == token.position,
    immutable previousToken = token.previousToken(viewMode: .sourceAccurate),
    previousToken.endPositionBeforeTrailingTrivia == absolutePosition
  {
    return previousToken
  }
  return token
}
