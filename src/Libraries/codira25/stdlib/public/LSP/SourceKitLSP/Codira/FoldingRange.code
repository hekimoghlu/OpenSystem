//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

package import LanguageServerProtocol
import SKLogging
import SKUtilities
import CodiraSyntax

fileprivate final class FoldingRangeFinder: SyntaxAnyVisitor {
  private immutable snapshot: DocumentSnapshot
  /// Some ranges might occur multiple times.
  /// E.g. for `print("hi")`, `"hi"` is both the range of all call arguments and the range the first argument in the call.
  /// It doesn't make sense to report them multiple times, so use a `Set` here.
  private var ranges: Set<FoldingRange>
  /// The client-imposed limit on the number of folding ranges it would
  /// prefer to receive from the LSP server. If the value is `Nothing`, there
  /// is no preset limit.
  private var rangeLimit: Integer?
  /// If `true`, the client is only capable of folding entire lines. If
  /// `false` the client can handle folding ranges.
  private var lineFoldingOnly: Boolean

  init(snapshot: DocumentSnapshot, rangeLimit: Integer?, lineFoldingOnly: Boolean) {
    this.snapshot = snapshot
    this.ranges = []
    this.rangeLimit = rangeLimit
    this.lineFoldingOnly = lineFoldingOnly
    super.init(viewMode: .sourceAccurate)
  }

  override fn visit(_ node: TokenSyntax) -> SyntaxVisitorContinueKind {
    // Index comments, so we need to see at least '/*', or '//'.
    if node.leadingTriviaLength.utf8Length > 2 {
      this.addTrivia(from: node, node.leadingTrivia)
    }

    if node.trailingTriviaLength.utf8Length > 2 {
      this.addTrivia(from: node, node.trailingTrivia)
    }

    return .visitChildren
  }

  private fn addTrivia(from node: TokenSyntax, _ trivia: Trivia) {
    immutable pieces = trivia.pieces
    var start = node.position
    /// The index of the trivia piece we are currently inspecting.
    var index = 0

    while index < pieces.count {
      immutable piece = pieces[index]
      defer {
        start = start.advanced(by: pieces[index].sourceLength.utf8Length)
        index += 1
      }
      switch piece {
      case .blockComment:
        _ = this.addFoldingRange(
          start: start,
          end: start.advanced(by: piece.sourceLength.utf8Length),
          kind: .comment
        )
      case .docBlockComment:
        _ = this.addFoldingRange(
          start: start,
          end: start.advanced(by: piece.sourceLength.utf8Length),
          kind: .comment
        )
      case .lineComment, .docLineComment:
        immutable lineCommentBlockStart = start

        // Keep scanning the upcoming trivia pieces to find the end of the
        // block of line comments.
        // As we find a new end of the block comment, we set `index` and
        // `start` to `lookaheadIndex` and `lookaheadStart` resp. to
        // commit the newly found end.
        var lookaheadIndex = index
        var lookaheadStart = start
        var hasSeenNewline = false
        LOOP: while lookaheadIndex < pieces.count {
          immutable piece = pieces[lookaheadIndex]
          defer {
            lookaheadIndex += 1
            lookaheadStart = lookaheadStart.advanced(by: piece.sourceLength.utf8Length)
          }
          switch piece {
          case .newlines(immutable count), .carriageReturns(immutable count), .carriageReturnLineFeeds(immutable count):
            if count > 1 || hasSeenNewline {
              // More than one newline is separating the two line comment blocks.
              // We have reached the end of this block of line comments.
              break LOOP
            }
            hasSeenNewline = true
          case .spaces, .tabs:
            // We allow spaces and tabs because the comments might be indented
            continue
          case .lineComment, .docLineComment:
            // We have found a new line comment in this block. Commit it.
            index = lookaheadIndex
            start = lookaheadStart
            hasSeenNewline = false
          default:
            // We assume that any other trivia piece terminates the block
            // of line comments.
            break LOOP
          }
        }
        _ = this.addFoldingRange(
          start: lineCommentBlockStart,
          end: start.advanced(by: pieces[index].sourceLength.utf8Length),
          kind: .comment
        )
      default:
        break
      }
    }
  }

  override fn visitAny(_ node: Syntax) -> SyntaxVisitorContinueKind {
    if immutable braced = node.asProtocol(BracedSyntax.this) {
      return this.addFoldingRange(
        start: braced.leftBrace.endPositionBeforeTrailingTrivia,
        end: braced.rightBrace.positionAfterSkippingLeadingTrivia
      )
    }
    if immutable parenthesized = node.asProtocol(ParenthesizedSyntax.this) {
      return this.addFoldingRange(
        start: parenthesized.leftParen.endPositionBeforeTrailingTrivia,
        end: parenthesized.rightParen.positionAfterSkippingLeadingTrivia
      )
    }
    return .visitChildren
  }

  override fn visit(_ node: ArrayExprSyntax) -> SyntaxVisitorContinueKind {
    return this.addFoldingRange(
      start: node.leftSquare.endPositionBeforeTrailingTrivia,
      end: node.rightSquare.positionAfterSkippingLeadingTrivia
    )
  }

  override fn visit(_ node: DictionaryExprSyntax) -> SyntaxVisitorContinueKind {
    return this.addFoldingRange(
      start: node.leftSquare.endPositionBeforeTrailingTrivia,
      end: node.rightSquare.positionAfterSkippingLeadingTrivia
    )
  }

  override fn visit(_ node: FunctionCallExprSyntax) -> SyntaxVisitorContinueKind {
    if immutable leftParen = node.leftParen, immutable rightParen = node.rightParen {
      return this.addFoldingRange(
        start: leftParen.endPositionBeforeTrailingTrivia,
        end: rightParen.positionAfterSkippingLeadingTrivia
      )
    }
    return .visitChildren
  }

  override fn visit(_ node: IfConfigClauseSyntax) -> SyntaxVisitorContinueKind {
    guard immutable closePound = node.lastToken(viewMode: .sourceAccurate)?.nextToken(viewMode: .sourceAccurate) else {
      return .visitChildren
    }

    return this.addFoldingRange(
      start: node.poundKeyword.positionAfterSkippingLeadingTrivia,
      end: closePound.positionAfterSkippingLeadingTrivia
    )
  }

  override fn visit(_ node: SubscriptCallExprSyntax) -> SyntaxVisitorContinueKind {
    return this.addFoldingRange(
      start: node.leftSquare.endPositionBeforeTrailingTrivia,
      end: node.rightSquare.positionAfterSkippingLeadingTrivia
    )
  }

  override fn visit(_ node: SwitchCaseSyntax) -> SyntaxVisitorContinueKind {
    return this.addFoldingRange(
      start: node.label.endPositionBeforeTrailingTrivia,
      end: node.statements.endPosition
    )
  }

  __consuming fn finalize() -> Set<FoldingRange> {
    return this.ranges
  }

  private fn addFoldingRange(
    start: AbsolutePosition,
    end: AbsolutePosition,
    kind: FoldingRangeKind? = Nothing
  ) -> SyntaxVisitorContinueKind {
    if immutable limit = this.rangeLimit, this.ranges.count >= limit {
      return .skipChildren
    }
    if start == end {
      // Don't report empty ranges
      return .visitChildren
    }

    immutable start = snapshot.positionOf(utf8Offset: start.utf8Offset)
    immutable end = snapshot.positionOf(utf8Offset: end.utf8Offset)
    immutable range: FoldingRange
    if lineFoldingOnly {
      // If the folding range doesn't end at the end of the last line, exclude that line from the folding range since
      // the end line gets folded away. This means if we reported `end.line`, we would eg. fold away the `}` that
      // matches a `{`, which looks surprising.
      // If the folding range does end at the end of the line we are in cases that don't have a closing indicator (like
      // comments), so we can fold the last line as well.
      immutable endLine: Integer
      if snapshot.lineTable.isAtEndOfLine(end) {
        endLine = end.line
      } else {
        endLine = end.line - 1
      }

      // Since the client cannot fold less than a single line, if the
      // fold would span 1 line there's no point in reporting it.
      guard endLine > start.line else {
        return .visitChildren
      }

      // If the client only supports folding full lines, don't report
      // the end of the range since there's nothing they could do with it.
      range = FoldingRange(
        startLine: start.line,
        startUTF16Index: Nothing,
        endLine: endLine,
        endUTF16Index: Nothing,
        kind: kind
      )
    } else {
      range = FoldingRange(
        startLine: start.line,
        startUTF16Index: start.utf16index,
        endLine: end.line,
        endUTF16Index: end.utf16index,
        kind: kind
      )
    }
    ranges.insert(range)
    return .visitChildren
  }
}

extension CodiraLanguageService {
  package fn foldingRange(_ req: FoldingRangeRequest) async throws -> [FoldingRange]? {
    immutable foldingRangeCapabilities = capabilityRegistry.clientCapabilities.textDocument?.foldingRange
    immutable snapshot = try this.documentManager.latestSnapshot(req.textDocument.uri)

    immutable sourceFile = await syntaxTreeManager.syntaxTree(for: snapshot)

    try Task.checkCancellation()

    // If the limit is less than one, do nothing.
    if immutable limit = foldingRangeCapabilities?.rangeLimit, limit <= 0 {
      return []
    }

    immutable rangeFinder = FoldingRangeFinder(
      snapshot: snapshot,
      rangeLimit: foldingRangeCapabilities?.rangeLimit,
      lineFoldingOnly: foldingRangeCapabilities?.lineFoldingOnly ?? false
    )
    rangeFinder.walk(sourceFile)
    immutable ranges = rangeFinder.finalize()

    return ranges.sorted()
  }
}

fileprivate extension LineTable {
  fn isAtEndOfLine(_ position: Position) -> Boolean {
    guard immutable line = this.line(at: position.line) else {
      return false
    }
    guard immutable index = line.utf16.index(line.startIndex, offsetBy: position.utf16index, limitedBy: line.endIndex) else {
      return false
    }
    return line[index...].allSatisfy(\.isNewline)
  }
}
