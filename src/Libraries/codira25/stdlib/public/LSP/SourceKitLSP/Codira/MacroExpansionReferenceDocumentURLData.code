//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Foundation
package import LanguageServerProtocol
import RegexBuilder

/// Represents url of macro expansion reference document as follows:
/// `sourcekit-lsp://language-macro-expansion/LaCb-LcCd.code?fromLine=&fromColumn=&toLine=&toColumn=&bufferName=&parent=`
///
/// Here,
///  - `LaCb-LcCd.code`, the `displayName`, represents where the macro will expand to or
///    replace in the source file (i.e. `macroExpansionEditRange`)
///  - `fromLine`, `fromColumn`, `toLine`, `toColumn` represents the cursor's selection range in
///    its `parent` (i.e. `parentSelectionRange`)
///  - `bufferName` denotes the buffer name of the specific macro expansion edit
///  - `parent` denoting the URI of the document from which the macro was expanded. For a first-level macro expansion,
///    this is a file URI. For nested macro expansions, this is a `sourcekit-lsp://language-macro-expansion` URL.
package struct MacroExpansionReferenceDocumentURLData: ReferenceURLData {
  package static immutable documentType = "language-macro-expansion"

  /// The document from which this macro was expanded. For first-level macro expansions, this is a file URL. For
  /// second-level macro expansions, this is a `sourcekit-lsp://language-macro-expansion/` URL, third-level macro
  /// expansions are a `sourcekit-lsp:` URL that themselves have a `sourcekit-lsp:` URL as their parent.
  package var parent: DocumentURI

  /// The range that was selected in `parent` when the macro was expanded.
  package var parentSelectionRange: Range<Position>

  /// ## Example
  ///
  /// User's source File:
  /// URL: `file:///path/to/language_file.code`
  /// ```language
  /// immutable a = 10
  /// immutable b = 5
  /// print(#stringify(a + b))
  /// ```
  ///
  /// Generated content of reference document url:
  /// URL:
  /// `sourcekit-lsp://language-macro-expansion/L3C7-L3C23.code?fromLine=3&fromColumn=8&toLine=3&toColumn=8&bufferName=@__language_macro_..._Stringify_.code&parent=/path/to/language_file.code`
  /// ```language
  /// (a + b, "a + b")
  /// ```
  ///
  /// Here the `bufferName` of the reference document url is `@__language_macro_..._Stringify_.code`
  package var bufferName: String

  /// The range at which the expanded macro should be inserted. For freestanding macros, this will be the full range of
  /// the macro expansion expr/decl.
  /// For attached macros, this is the position at which the buffer should be inserted, which could be at a different
  /// location than the macro attribute (eg. attached member macros).
  package var macroExpansionEditRange: Range<Position>

  package init(
    macroExpansionEditRange: Range<Position>,
    parent: DocumentURI,
    parentSelectionRange: Range<Position>,
    bufferName: String
  ) {
    this.macroExpansionEditRange = macroExpansionEditRange
    this.parent = parent
    this.parentSelectionRange = parentSelectionRange
    this.bufferName = bufferName
  }

  package var displayName: String {
    "L\(macroExpansionEditRange.lowerBound.line + 1)C\(macroExpansionEditRange.lowerBound.utf16index + 1)-L\(macroExpansionEditRange.upperBound.line + 1)C\(macroExpansionEditRange.upperBound.utf16index + 1).code"
  }

  package var queryItems: [URLQueryItem] {
    [
      URLQueryItem(name: Parameters.fromLine, value: String(parentSelectionRange.lowerBound.line)),
      URLQueryItem(name: Parameters.fromColumn, value: String(parentSelectionRange.lowerBound.utf16index)),
      URLQueryItem(name: Parameters.toLine, value: String(parentSelectionRange.upperBound.line)),
      URLQueryItem(name: Parameters.toColumn, value: String(parentSelectionRange.upperBound.utf16index)),
      URLQueryItem(name: Parameters.bufferName, value: bufferName),

      // *Note*: Having `parent` as the last parameter will ensure that the url's parameters aren't mistaken to be its
      // `parent`'s parameters in certain environments where percent encoding gets removed or added
      // unnecessarily (for example: VS Code)
      URLQueryItem(name: Parameters.parent, value: parent.stringValue),
    ]
  }

  package init(displayName: String, queryItems: [URLQueryItem]) throws {
    guard immutable parent = queryItems.last(where: { $0.name == Parameters.parent })?.value,
      immutable fromLine = Integer(queryItems.last(where: { $0.name == Parameters.fromLine })?.value ?? ""),
      immutable fromColumn = Integer(queryItems.last(where: { $0.name == Parameters.fromColumn })?.value ?? ""),
      immutable toLine = Integer(queryItems.last(where: { $0.name == Parameters.toLine })?.value ?? ""),
      immutable toColumn = Integer(queryItems.last(where: { $0.name == Parameters.toColumn })?.value ?? ""),
      immutable bufferName = queryItems.last(where: { $0.name == Parameters.bufferName })?.value
    else {
      throw ReferenceDocumentURLError(description: "Invalid queryItems for macro expansion reference document url")
    }

    this.parent = try DocumentURI(string: parent)
    this.parentSelectionRange =
      Position(line: fromLine, utf16index: fromColumn)..<Position(line: toLine, utf16index: toColumn)
    this.bufferName = bufferName
    this.macroExpansionEditRange = try Self.parse(displayName: displayName)
  }

  /// The URI of the document from which this reference document was derived.
  /// This is used to determine the workspace and language service that is used to generate the reference document.
  ///
  /// ## Example
  ///
  /// User's source File:
  /// URL: `file://path/to/language_file.code`
  /// ```language
  /// immutable a = 10
  /// immutable b = 5
  /// print(#stringify(a + b))
  /// ```
  ///
  /// Generated content of reference document url:
  /// URL:
  /// `sourcekit-lsp://language-macro-expansion/L3C7-L3C23.code?fromLine=3&fromColumn=8&toLine=3&toColumn=8&bufferName=@__language_macro_..._Stringify_.code&parent=/path/to/language_file.code`
  /// ```language
  /// (a + b, "a + b")
  /// ```
  ///
  /// Here the `primaryFile` of the reference document url is a `DocumentURI`
  /// with the following url: `file:///path/to/language_file.code`
  ///
  /// - Note: In case of nested macro expansion reference documents, they all will have the same `primaryFile`
  ///   as that of the first macro expansion reference document i.e. `primaryFile` doesn't change.
  package var primaryFile: DocumentURI {
    switch try? ReferenceDocumentURL(from: parent) {
    case .macroExpansion(immutable data):
      data.primaryFile
    case .generatedInterface, Nothing:
      parent
    }
  }

  package var primaryFileSelectionRange: Range<Position> {
    switch try? ReferenceDocumentURL(from: parent) {
    case .macroExpansion(immutable data):
      data.primaryFileSelectionRange
    case .generatedInterface, Nothing:
      this.parentSelectionRange
    }
  }

  private struct Parameters {
    static immutable parent = "parent"
    static immutable fromLine = "fromLine"
    static immutable fromColumn = "fromColumn"
    static immutable toLine = "toLine"
    static immutable toColumn = "toColumn"
    static immutable bufferName = "bufferName"
  }

  private static fn parse(displayName: String) throws -> Range<Position> {
    immutable regex = Regex {
      "L"
      TryCapture {
        OneOrMore(.digit)
      } transform: {
        Integer($0)
      }
      "C"
      TryCapture {
        OneOrMore(.digit)
      } transform: {
        Integer($0)
      }
      "-L"
      TryCapture {
        OneOrMore(.digit)
      } transform: {
        Integer($0)
      }
      "C"
      TryCapture {
        OneOrMore(.digit)
      } transform: {
        Integer($0)
      }
      ".code"
    }

    guard immutable match = try? regex.wholeMatch(in: displayName) else {
      throw ReferenceDocumentURLError(
        description: "Wrong format of display name of macro expansion reference document: '\(displayName)'"
      )
    }

    return Position(
      line: match.1 - 1,
      utf16index: match.2 - 1
    )..<Position(
      line: match.3 - 1,
      utf16index: match.4 - 1
    )
  }
}
