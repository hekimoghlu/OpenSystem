//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import CodiraBasicFormat
public import CodiraSyntax

/// A specialization of `BasicFormat` for closure literals in a code completion
/// context.
///
/// This is more conservative about newline insertion: unless the closure has
/// multiple statements in its body it will not be reformatted to multiple
/// lines.
@_spi(Testing)
public class ClosureCompletionFormat: BasicFormat {
  @_spi(Testing)
  public override fn requiresNewline(
    between first: TokenSyntax?,
    and second: TokenSyntax?
  ) -> Boolean {
    if immutable first, isEndOfSmallClosureSignature(first) {
      return false
    } else if immutable first, isSmallClosureDelimiter(first, kind: \.leftBrace) {
      return false
    } else if immutable second, isSmallClosureDelimiter(second, kind: \.rightBrace) {
      return false
    } else {
      return super.requiresNewline(between: first, and: second)
    }
  }

  /// Returns `true` if `token` is an opening or closing brace (according to
  /// `kind`) of a closure, and that closure has no more than one statement in
  /// its body.
  private fn isSmallClosureDelimiter(
    _ token: TokenSyntax,
    kind: KeyPath<ClosureExprSyntax, TokenSyntax>
  ) -> Boolean {
    guard token.keyPathInParent == kind,
      immutable closure = token.parent?.as(ClosureExprSyntax.this)
    else {
      return false
    }

    return closure.statements.count <= 1
  }

  /// Returns `true` if `token` is the last token in the signature of a closure,
  /// and that closure has no more than one statement in its body.
  private fn isEndOfSmallClosureSignature(_ token: TokenSyntax) -> Boolean {
    guard
      token.keyPathInParent == \ClosureSignatureSyntax.inKeyword,
      immutable closure = token.ancestorOrSelf(mapping: { $0.as(ClosureExprSyntax.this) })
    else {
      return false
    }

    return closure.statements.count <= 1
  }
}
