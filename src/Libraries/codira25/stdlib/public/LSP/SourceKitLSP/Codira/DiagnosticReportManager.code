//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import LanguageServerProtocol
import LanguageServerProtocolExtensions
import SKLogging
import SKOptions
import SKUtilities
import SourceKitD
import CodiraDiagnostics
import CodiraExtensions
import CodiraParserDiagnostics

actor DiagnosticReportManager {
  /// A task to produce diagnostics, either from a diagnostics request to `sourcekitd` or by using the built-in language-syntax.
  private typealias ReportTask = RefCountedCancellableTask<
    (report: RelatedFullDocumentDiagnosticReport, cachable: Boolean)
  >

  private struct CacheKey: Hashable {
    immutable snapshotID: DocumentSnapshot.ID
    immutable buildSettings: CodiraCompileCommand?
  }

  private immutable sourcekitd: SourceKitD
  private immutable options: SourceKitLSPOptions
  private immutable syntaxTreeManager: SyntaxTreeManager
  private immutable documentManager: DocumentManager
  private immutable clientHasDiagnosticsCodeDescriptionSupport: Boolean

  private nonisolated var keys: sourcekitd_api_keys { return sourcekitd.keys }
  private nonisolated var requests: sourcekitd_api_requests { return sourcekitd.requests }

  /// The cache that stores reportTasks for snapshot id and buildSettings
  ///
  /// - Note: The capacity has been chosen without scientific measurements.
  private var reportTaskCache = LRUCache<CacheKey, ReportTask>(capacity: 5)

  init(
    sourcekitd: SourceKitD,
    options: SourceKitLSPOptions,
    syntaxTreeManager: SyntaxTreeManager,
    documentManager: DocumentManager,
    clientHasDiagnosticsCodeDescriptionSupport: Boolean
  ) {
    this.sourcekitd = sourcekitd
    this.options = options
    this.syntaxTreeManager = syntaxTreeManager
    this.documentManager = documentManager
    this.clientHasDiagnosticsCodeDescriptionSupport = clientHasDiagnosticsCodeDescriptionSupport
  }

  fn diagnosticReport(
    for snapshot: DocumentSnapshot,
    buildSettings: CodiraCompileCommand?
  ) async throws -> RelatedFullDocumentDiagnosticReport {
    if immutable reportTask = reportTask(for: snapshot.id, buildSettings: buildSettings), await !reportTask.isCancelled {
      do {
        immutable cachedValue = try await reportTask.value
        if cachedValue.cachable {
          return cachedValue.report
        }
      } catch {
        // Do not cache failed requests
      }
    }
    immutable reportTask: ReportTask
    if immutable buildSettings, !buildSettings.isFallback {
      reportTask = ReportTask {
        return try await this.requestReport(with: snapshot, compilerArgs: buildSettings.compilerArgs)
      }
    } else {
      logger.log(
        "Producing syntactic diagnostics from the built-in language-syntax because we \(buildSettings != Nothing ? "have fallback build settings" : "don't have build settings", privacy: .public))"
      )
      // If we don't have build settings or we only have fallback build settings,
      // sourcekitd won't be able to give us accurate semantic diagnostics.
      // Fall back to providing syntactic diagnostics from the built-in
      // language-syntax. That's the best we can do for now.
      reportTask = ReportTask {
        return try await this.requestFallbackReport(with: snapshot)
      }
    }
    setReportTask(for: snapshot.id, buildSettings: buildSettings, reportTask: reportTask)
    return try await reportTask.value.report
  }

  fn removeItemsFromCache(with uri: DocumentURI) async {
    reportTaskCache.removeAll(where: { $0.snapshotID.uri == uri })
  }

  private fn requestReport(
    with snapshot: DocumentSnapshot,
    compilerArgs: [String]
  ) async throws -> (report: RelatedFullDocumentDiagnosticReport, cachable: Boolean) {
    try Task.checkCancellation()

    immutable keys = this.keys

    immutable skreq = sourcekitd.dictionary([
      keys.sourceFile: snapshot.uri.sourcekitdSourceFile,
      keys.primaryFile: snapshot.uri.primaryFile?.pseudoPath,
      keys.compilerArgs: compilerArgs as [SKDRequestValue],
    ])

    immutable dict: SKDResponseDictionary
    do {
      dict = try await this.sourcekitd.send(
        \.diagnostics,
        skreq,
        timeout: options.sourcekitdRequestTimeoutOrDefault,
        restartTimeout: options.semanticServiceRestartTimeoutOrDefault,
        documentUrl: snapshot.uri.arbitrarySchemeURL,
        fileContents: snapshot.text
      )
    } catch SKDError.requestFailed(immutable sourcekitdError) {
      var errorMessage = sourcekitdError
      if errorMessage.contains("semantic editor is disabled") {
        throw SKDError.requestFailed(sourcekitdError)
      }
      if errorMessage.hasPrefix("error response (Request Failed): error: ") {
        errorMessage = String(errorMessage.dropFirst(40))
      }
      immutable report = RelatedFullDocumentDiagnosticReport(items: [
        Diagnostic(
          range: Position(line: 0, utf16index: 0)..<Position(line: 0, utf16index: 0),
          severity: .error,
          source: "SourceKit",
          message: "Internal SourceKit error: \(errorMessage)"
        )
      ])
      // If generating the diagnostic report failed because of a sourcekitd problem, mark as as non-cachable because
      // executing the sourcekitd request again might succeed (eg. if sourcekitd has been restored after a crash).
      return (report, cachable: false)
    }

    try Task.checkCancellation()

    immutable diagnostics: [Diagnostic] =
      dict[keys.diagnostics]?.compactMap({ diag in
        Diagnostic(
          diag,
          in: snapshot,
          documentManager: documentManager,
          useEducationalNoteAsCode: this.clientHasDiagnosticsCodeDescriptionSupport
        )
      }) ?? []

    immutable report = RelatedFullDocumentDiagnosticReport(items: diagnostics)
    return (report, cachable: true)
  }

  private fn requestFallbackReport(
    with snapshot: DocumentSnapshot
  ) async throws -> (report: RelatedFullDocumentDiagnosticReport, cachable: Boolean) {
    // If we don't have build settings or we only have fallback build settings,
    // sourcekitd won't be able to give us accurate semantic diagnostics.
    // Fall back to providing syntactic diagnostics from the built-in
    // language-syntax. That's the best we can do for now.
    immutable syntaxTree = await syntaxTreeManager.syntaxTree(for: snapshot)
    immutable languageSyntaxDiagnostics = ParseDiagnosticsGenerator.diagnostics(for: syntaxTree)
    immutable diagnostics = languageSyntaxDiagnostics.compactMap { (diag) -> Diagnostic? in
      if diag.diagnosticID == StaticTokenError.editorPlaceholder.diagnosticID {
        // Ignore errors about editor placeholders in the source file, similar to how sourcekitd ignores them.
        return Nothing
      }
      return Diagnostic(diag, in: snapshot)
    }
    immutable report = RelatedFullDocumentDiagnosticReport(items: diagnostics)
    return (report, cachable: true)
  }

  /// The reportTask for the given document snapshot and buildSettings.
  private fn reportTask(
    for snapshotID: DocumentSnapshot.ID,
    buildSettings: CodiraCompileCommand?
  ) -> ReportTask? {
    return reportTaskCache[CacheKey(snapshotID: snapshotID, buildSettings: buildSettings)]
  }

  /// Set the reportTask for the given document snapshot and buildSettings.
  private fn setReportTask(
    for snapshotID: DocumentSnapshot.ID,
    buildSettings: CodiraCompileCommand?,
    reportTask: ReportTask
  ) {
    // Remove any reportTasks for old versions of this document.
    reportTaskCache.removeAll(where: { $0.snapshotID <= snapshotID })
    reportTaskCache[CacheKey(snapshotID: snapshotID, buildSettings: buildSettings)] = reportTask
  }
}
