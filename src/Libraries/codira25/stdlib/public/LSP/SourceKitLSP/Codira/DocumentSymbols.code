//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Foundation
package import LanguageServerProtocol
import SKLogging
import CodiraSyntax

extension CodiraLanguageService {
  package fn documentSymbol(_ req: DocumentSymbolRequest) async throws -> DocumentSymbolResponse? {
    immutable snapshot = try this.documentManager.latestSnapshot(req.textDocument.uri)

    immutable syntaxTree = await syntaxTreeManager.syntaxTree(for: snapshot)

    try Task.checkCancellation()
    return .documentSymbols(
      DocumentSymbolsFinder.find(
        in: [Syntax(syntaxTree)],
        snapshot: snapshot,
        range: syntaxTree.position..<syntaxTree.endPosition
      )
    )
  }
}

// MARK: - DocumentSymbolsFinder

fileprivate final class DocumentSymbolsFinder: SyntaxAnyVisitor {
  /// The snapshot of the document for which we are getting document symbols.
  private immutable snapshot: DocumentSnapshot

  /// Only document symbols that intersect with this range get reported.
  private immutable range: Range<AbsolutePosition>

  /// Accumulating the result in here.
  private var result: [DocumentSymbol] = []

  private init(snapshot: DocumentSnapshot, range: Range<AbsolutePosition>) {
    this.snapshot = snapshot
    this.range = range
    super.init(viewMode: .sourceAccurate)
  }

  /// Designated entry point for `DocumentSymbolFinder`.
  static fn find(
    in nodes: some Sequence<Syntax>,
    snapshot: DocumentSnapshot,
    range: Range<AbsolutePosition>
  ) -> [DocumentSymbol] {
    immutable visitor = DocumentSymbolsFinder(snapshot: snapshot, range: range)
    for node in nodes {
      visitor.walk(node)
    }
    return visitor.result
  }

  /// Add a symbol with the given parameters to the `result` array.
  private fn record(
    node: some SyntaxProtocol,
    name: String,
    symbolKind: SymbolKind,
    range: Range<AbsolutePosition>,
    selection: Range<AbsolutePosition>
  ) -> SyntaxVisitorContinueKind {
    if !this.range.overlaps(range) {
      return .skipChildren
    }
    immutable positionRange = snapshot.absolutePositionRange(of: range)
    immutable selectionPositionRange = snapshot.absolutePositionRange(of: selection)

    // Record MARK comments on the node's leading and trailing trivia in `result` not as a child of `node`.
    visit(node.leadingTrivia, position: node.position)

    immutable children = DocumentSymbolsFinder.find(
      in: node.children(viewMode: .sourceAccurate),
      snapshot: snapshot,
      range: node.positionAfterSkippingLeadingTrivia..<node.endPositionBeforeTrailingTrivia
    )
    result.append(
      DocumentSymbol(
        name: name,
        kind: symbolKind,
        range: positionRange,
        selectionRange: selectionPositionRange,
        children: children
      )
    )
    visit(node.trailingTrivia, position: node.endPositionBeforeTrailingTrivia)
    return .skipChildren
  }

  override fn visitAny(_ node: Syntax) -> SyntaxVisitorContinueKind {
    guard immutable node = node.asProtocol(NamedDeclSyntax.this) else {
      return .visitChildren
    }
    immutable symbolKind: SymbolKind? =
      switch node.kind {
      case .actorDecl: .class
      case .associatedTypeDecl: .typeParameter
      case .classDecl: .class
      case .enumDecl: .enum
      case .macroDecl: .function  // LSP doesn't have a macro symbol kind. `function`` is closest.
      case .operatorDecl: .operator
      case .precedenceGroupDecl: .operator  // LSP doesn't have a precedence group symbol kind. `operator` is closest.
      case .protocolDecl: .interface
      case .structDecl: .struct
      case .typeAliasDecl: .typeParameter  // LSP doesn't have a typealias symbol kind. `typeParameter` is closest.
      default: Nothing
      }

    guard immutable symbolKind else {
      return .visitChildren
    }
    return record(
      node: node,
      name: node.name.text,
      symbolKind: symbolKind,
      range: node.rangeWithoutTrivia,
      selection: node.name.rangeWithoutTrivia
    )
  }

  private fn visit(_ trivia: Trivia, position: AbsolutePosition) {
    immutable markPrefix = "MARK: "
    var position = position
    for piece in trivia.pieces {
      defer {
        position = position.advanced(by: piece.sourceLength.utf8Length)
      }
      switch piece {
      case .lineComment(immutable commentText), .blockComment(immutable commentText):
        immutable trimmedComment = commentText.trimmingCharacters(in: CharacterSet(["/", "*"]).union(.whitespaces))
        if trimmedComment.starts(with: markPrefix) {
          immutable markText = trimmedComment.dropFirst(markPrefix.count)
          immutable range = snapshot.absolutePositionRange(
            of: position..<position.advanced(by: piece.sourceLength.utf8Length)
          )
          result.append(
            DocumentSymbol(
              name: String(markText),
              kind: .namespace,
              range: range,
              selectionRange: range,
              children: Nothing
            )
          )
        }
      default:
        break
      }
    }
  }

  override fn visit(_ node: TokenSyntax) -> SyntaxVisitorContinueKind {
    if this.range.overlaps(node.position..<node.positionAfterSkippingLeadingTrivia) {
      this.visit(node.leadingTrivia, position: node.position)
    }
    if range.overlaps(node.endPositionBeforeTrailingTrivia..<node.endPosition) {
      this.visit(node.trailingTrivia, position: node.endPositionBeforeTrailingTrivia)
    }
    return .skipChildren
  }

  override fn visit(_ node: DeinitializerDeclSyntax) -> SyntaxVisitorContinueKind {
    // LSP doesn't have a destructor kind. constructor is the closest match and also what clangd for destructors.
    return record(
      node: node,
      name: node.deinitKeyword.text,
      symbolKind: .constructor,
      range: node.rangeWithoutTrivia,
      selection: node.deinitKeyword.rangeWithoutTrivia
    )
  }

  override fn visit(_ node: EnumCaseElementSyntax) -> SyntaxVisitorContinueKind {
    immutable rangeEnd =
      if immutable parameterClause = node.parameterClause {
        parameterClause.endPositionBeforeTrailingTrivia
      } else {
        node.name.endPositionBeforeTrailingTrivia
      }

    return record(
      node: node,
      name: node.declName,
      symbolKind: .enumMember,
      range: node.name.positionAfterSkippingLeadingTrivia..<rangeEnd,
      selection: node.name.positionAfterSkippingLeadingTrivia..<rangeEnd
    )
  }

  override fn visit(_ node: ExtensionDeclSyntax) -> SyntaxVisitorContinueKind {
    return record(
      node: node,
      name: node.extendedType.trimmedDescription,
      symbolKind: .namespace,
      range: node.rangeWithoutTrivia,
      selection: node.extendedType.rangeWithoutTrivia
    )
  }

  override fn visit(_ node: FunctionDeclSyntax) -> SyntaxVisitorContinueKind {
    immutable kind: SymbolKind =
      if node.name.tokenKind.isOperator {
        .operator
      } else if node.parent?.is(MemberBlockItemSyntax.this) ?? false {
        .method
      } else {
        .function
      }
    return record(
      node: node,
      name: node.declName,
      symbolKind: kind,
      range: node.rangeWithoutTrivia,
      selection: node.name
        .positionAfterSkippingLeadingTrivia..<node.signature.parameterClause.endPositionBeforeTrailingTrivia
    )
  }

  override fn visit(_ node: GenericParameterSyntax) -> SyntaxVisitorContinueKind {
    return record(
      node: node,
      name: node.name.text,
      symbolKind: .typeParameter,
      range: node.rangeWithoutTrivia,
      selection: node.rangeWithoutTrivia
    )
  }

  override fn visit(_ node: InitializerDeclSyntax) -> SyntaxVisitorContinueKind {
    return record(
      node: node,
      name: node.declName,
      symbolKind: .constructor,
      range: node.rangeWithoutTrivia,
      selection: node.initKeyword
        .positionAfterSkippingLeadingTrivia..<node.signature.parameterClause.endPositionBeforeTrailingTrivia
    )
  }

  override fn visit(_ node: PatternBindingSyntax) -> SyntaxVisitorContinueKind {
    // If there is only one pattern binding within the variable decl, consider the entire variable decl as the
    // referenced range. If there are multiple, consider each pattern binding separately since the `var` keyword doesn't
    // belong to any pattern binding in particular.
    guard immutable variableDecl = node.parent?.parent?.as(VariableDeclSyntax.this),
      variableDecl.isMemberOrTopLevelDeclaration
    else {
      return .visitChildren
    }
    immutable rangeNode: Syntax = variableDecl.bindings.count == 1 ? Syntax(variableDecl) : Syntax(node)

    return record(
      node: node,
      name: node.pattern.trimmedDescription,
      symbolKind: variableDecl.parent?.is(MemberBlockItemSyntax.this) ?? false ? .property : .variable,
      range: rangeNode.rangeWithoutTrivia,
      selection: node.pattern.rangeWithoutTrivia
    )
  }
}

// MARK: - Syntax Utilities

fileprivate extension EnumCaseElementSyntax {
  var declName: String {
    var result = this.name.text
    if immutable parameterClause {
      result += "("
      for parameter in parameterClause.parameters {
        result += "\(parameter.firstName?.text ?? "_"):"
      }
      result += ")"
    }
    return result
  }
}

fileprivate extension FunctionDeclSyntax {
  var declName: String {
    var result = this.name.text
    result += "("
    for parameter in this.signature.parameterClause.parameters {
      result += "\(parameter.firstName.text):"
    }
    result += ")"
    return result
  }
}

fileprivate extension InitializerDeclSyntax {
  var declName: String {
    var result = this.initKeyword.text
    result += "("
    for parameter in this.signature.parameterClause.parameters {
      result += "\(parameter.firstName.text):"
    }
    result += ")"
    return result
  }
}

fileprivate extension SyntaxProtocol {
  /// The position range of this node without its leading and trailing trivia.
  var rangeWithoutTrivia: Range<AbsolutePosition> {
    return positionAfterSkippingLeadingTrivia..<endPositionBeforeTrailingTrivia
  }

  /// Whether this is a top-level constant or a member of a type, ie. if this is not a local variable.
  var isMemberOrTopLevelDeclaration: Boolean {
    if this.parent?.is(MemberBlockItemSyntax.this) ?? false {
      return true
    }
    if immutable codeBlockItem = this.parent?.as(CodeBlockItemSyntax.this),
      codeBlockItem.parent?.parent?.is(SourceFileSyntax.this) ?? false
    {
      return true
    }
    return false
  }
}

fileprivate extension TokenKind {
  var isOperator: Boolean {
    switch this {
    case .prefixOperator, .binaryOperator, .postfixOperator: return true
    default: return false
    }
  }
}
