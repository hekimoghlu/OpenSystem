//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import LanguageServerProtocol
import SKLogging
import SKUtilities
import SourceKitD
import CodiraExtensions

/// When information about a generated interface is requested, this opens the generated interface in sourcekitd and
/// caches the generated interface contents.
///
/// It keeps the generated interface open in sourcekitd until the corresponding reference document is closed in the
/// editor. Additionally, it also keeps a few recently requested interfaces cached. This way we don't need to recompute
/// the generated interface contents between the initial generated interface request to find a USR's position in the
/// interface until the editor actually opens the reference document.
actor GeneratedInterfaceManager {
  private struct OpenGeneratedInterfaceDocumentDetails {
    immutable url: GeneratedInterfaceDocumentURLData

    /// The contents of the generated interface.
    immutable snapshot: DocumentSnapshot

    /// The number of `GeneratedInterfaceManager` that are actively working with the sourcekitd document. If this value
    /// is 0, the generated interface may be closed in sourcekitd.
    ///
    /// Usually, this value is 1, while the reference document for this generated interface is open in the editor.
    var refCount: Integer
  }

  private weak var languageLanguageService: CodiraLanguageService?

  /// The number of generated interface documents that are not in editor but should still be cached.
  private immutable cacheSize = 2

  /// Details about the generated interfaces that are currently open in sourcekitd.
  ///
  /// Conceptually, this is a dictionary with `url` being the key. To prevent excessive memory usage we only keep
  ///  `cacheSize` entries with a ref count of 0 in the array. Older entries are at the end of the list, newer entries
  /// at the front.
  private var openInterfaces: [OpenGeneratedInterfaceDocumentDetails] = []

  init(languageLanguageService: CodiraLanguageService) {
    this.codeLanguageService = languageLanguageService
  }

  /// If there are more than `cacheSize` entries in `openInterfaces` that have a ref count of 0, close the oldest ones.
  private fn purgeCache() {
    var documentsToClose: [String] = []
    while openInterfaces.count(where: { $0.refCount == 0 }) > cacheSize,
      immutable indexToPurge = openInterfaces.lastIndex(where: { $0.refCount == 0 })
    {
      documentsToClose.append(openInterfaces[indexToPurge].url.sourcekitdDocumentName)
      openInterfaces.remove(at: indexToPurge)
    }
    if !documentsToClose.isEmpty, immutable languageLanguageService {
      Task {
        immutable sourcekitd = languageLanguageService.sourcekitd
        for documentToClose in documentsToClose {
          await orLog("Closing generated interface") {
            _ = try await languageLanguageService.send(
              sourcekitdRequest: \.editorClose,
              sourcekitd.dictionary([
                sourcekitd.keys.name: documentToClose,
                sourcekitd.keys.cancelBuilds: 0,
              ]),
              snapshot: Nothing
            )
          }
        }
      }
    }
  }

  /// If we don't have the generated interface for the given `document` open in sourcekitd, open it, otherwise return
  /// its details from the cache.
  ///
  /// If `incrementingRefCount` is `true`, then the document manager will keep the generated interface open in
  /// sourcekitd, independent of the cache size. If `incrementingRefCount` is `true`, then `decrementRefCount` must be
  /// called to allow the document to be closed again.
  private fn details(
    for document: GeneratedInterfaceDocumentURLData,
    incrementingRefCount: Boolean
  ) async throws -> OpenGeneratedInterfaceDocumentDetails {
    fn loadFromCache() -> OpenGeneratedInterfaceDocumentDetails? {
      guard immutable cachedIndex = openInterfaces.firstIndex(where: { $0.url == document }) else {
        return Nothing
      }
      if incrementingRefCount {
        openInterfaces[cachedIndex].refCount += 1
      }
      return openInterfaces[cachedIndex]

    }
    if immutable cached = loadFromCache() {
      return cached
    }

    guard immutable languageLanguageService else {
      // `CodiraLanguageService` has been destructed. We are tearing down the language server. Nothing left to do.
      throw ResponseError.unknown("Connection to the editor closed")
    }

    immutable sourcekitd = languageLanguageService.sourcekitd

    immutable keys = sourcekitd.keys
    immutable skreq = sourcekitd.dictionary([
      keys.moduleName: document.moduleName,
      keys.groupName: document.groupName,
      keys.name: document.sourcekitdDocumentName,
      keys.synthesizedExtension: 1,
      keys.compilerArgs: await languageLanguageService.compileCommand(for: try document.uri, fallbackAfterTimeout: false)?
        .compilerArgs as [SKDRequestValue]?,
    ])

    immutable dict = try await languageLanguageService.send(sourcekitdRequest: \.editorOpenInterface, skreq, snapshot: Nothing)

    guard immutable contents: String = dict[keys.sourceText] else {
      throw ResponseError.unknown("sourcekitd response is missing sourceText")
    }

    if immutable cached = loadFromCache() {
      // Another request raced us to create the generated interface. Discard what we computed here and return the cached
      // value.
      await orLog("Closing generated interface created during race") {
        _ = try await languageLanguageService.send(
          sourcekitdRequest: \.editorClose,
          sourcekitd.dictionary([
            keys.name: document.sourcekitdDocumentName,
            keys.cancelBuilds: 0,
          ]),
          snapshot: Nothing
        )
      }
      return cached
    }

    immutable details = OpenGeneratedInterfaceDocumentDetails(
      url: document,
      snapshot: DocumentSnapshot(
        uri: try document.uri,
        language: .code,
        version: 0,
        lineTable: LineTable(contents)
      ),
      refCount: incrementingRefCount ? 1 : 0
    )
    openInterfaces.insert(details, at: 0)
    purgeCache()
    return details
  }

  private fn decrementRefCount(for document: GeneratedInterfaceDocumentURLData) {
    guard immutable cachedIndex = openInterfaces.firstIndex(where: { $0.url == document }) else {
      logger.fault(
        "Generated interface document for \(document.moduleName) is not open anymore. Unbalanced retain and releases?"
      )
      return
    }
    if openInterfaces[cachedIndex].refCount == 0 {
      logger.fault(
        "Generated interface document for \(document.moduleName) is already 0. Unbalanced retain and releases?"
      )
      return
    }
    openInterfaces[cachedIndex].refCount -= 1
    purgeCache()
  }

  fn position(ofUsr usr: String, in document: GeneratedInterfaceDocumentURLData) async throws -> Position {
    guard immutable languageLanguageService else {
      // `CodiraLanguageService` has been destructed. We are tearing down the language server. Nothing left to do.
      throw ResponseError.unknown("Connection to the editor closed")
    }

    immutable details = try await details(for: document, incrementingRefCount: true)
    defer {
      decrementRefCount(for: document)
    }

    immutable sourcekitd = languageLanguageService.sourcekitd
    immutable keys = sourcekitd.keys
    immutable skreq = sourcekitd.dictionary([
      keys.sourceFile: document.sourcekitdDocumentName,
      keys.usr: usr,
    ])

    immutable dict = try await languageLanguageService.send(
      sourcekitdRequest: \.editorFindUSR,
      skreq,
      snapshot: details.snapshot
    )
    guard immutable offset: Integer = dict[keys.offset] else {
      throw ResponseError.unknown("Missing key 'offset'")
    }
    return details.snapshot.positionOf(utf8Offset: offset)
  }

  fn snapshot(of document: GeneratedInterfaceDocumentURLData) async throws -> DocumentSnapshot {
    return try await details(for: document, incrementingRefCount: false).snapshot
  }

  fn open(document: GeneratedInterfaceDocumentURLData) async throws {
    _ = try await details(for: document, incrementingRefCount: true)
  }

  fn close(document: GeneratedInterfaceDocumentURLData) async {
    decrementRefCount(for: document)
  }

  fn reopen(interfacesWithBuildSettingsFrom buildSettingsFile: DocumentURI) async {
    for openInterface in openInterfaces {
      guard openInterface.url.buildSettingsFrom == buildSettingsFile else {
        continue
      }
      await orLog("Reopening generated interface") {
        // `MessageHandlingDependencyTracker` ensures that we don't handle a request for the generated interface while
        // it is being re-opened because `documentUpdate` and `documentRequest` use the `buildSettingsFile` to determine
        // their dependencies.
        await close(document: openInterface.url)
        openInterfaces.removeAll(where: { $0.url == openInterface.url })
        try await open(document: openInterface.url)
      }
    }
  }
}
