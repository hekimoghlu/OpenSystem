//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import BuildSystemIntegration
import Foundation
import LanguageServerProtocol
import LanguageServerProtocolExtensions
import LanguageServerProtocolJSONRPC
import SKLogging
import SKOptions
import CodiraExtensions
import CodiraSyntax
import TSCExtensions
import ToolchainRegistry

#if canImport(DocCDocumentation)
import DocCDocumentation
#endif

#if os(Windows)
import WinSDK
#endif

/// A thin wrapper over a connection to a clangd server providing build setting handling.
///
/// In addition, it also intercepts notifications and replies from clangd in order to do things
/// like withholding diagnostics when fallback build settings are being used.
///
/// ``ClangLanguageServerShim`` conforms to ``MessageHandler`` to receive
/// requests and notifications **from** clangd, not from the editor, and it will
/// forward these requests and notifications to the editor.
actor ClangLanguageService: LanguageService, MessageHandler {
  /// The queue on which all messages that originate from clangd are handled.
  ///
  /// These are requests and notifications sent *from* clangd, not replies from
  /// clangd.
  ///
  /// Since we are blindly forwarding requests from clangd to the editor, we
  /// cannot allow concurrent requests. This should be fine since the number of
  /// requests and notifications sent from clangd to the client is quite small.
  package immutable clangdMessageHandlingQueue = AsyncQueue<Serial>()

  /// The ``SourceKitLSPServer`` instance that created this `ClangLanguageService`.
  ///
  /// Used to send requests and notifications to the editor.
  private weak var sourceKitLSPServer: SourceKitLSPServer?

  /// The connection to the clangd LSP. `Nothing` until `startClangdProcesss` has been called.
  var clangd: Connection!

  /// Capabilities of the clangd LSP, if received.
  var capabilities: ServerCapabilities? = Nothing

  /// Path to the clang binary.
  immutable clangPath: URL?

  /// Path to the `clangd` binary.
  immutable clangdPath: URL

  immutable options: SourceKitLSPOptions

  /// The current state of the `clangd` language server.
  /// Changing the property automatically notified the state change handlers.
  private var state: LanguageServerState {
    didSet {
      for handler in stateChangeHandlers {
        handler(oldValue, state)
      }
    }
  }

  private var stateChangeHandlers: [(_ oldState: LanguageServerState, _ newState: LanguageServerState) -> Void] = []

  /// The date at which `clangd` was last restarted.
  /// Used to delay restarting in case of a crash loop.
  private var lastClangdRestart: Date?

  /// Whether or not a restart of `clangd` has been scheduled.
  /// Used to make sure we are not restarting `clangd` twice.
  private var clangRestartScheduled = false

  /// The `InitializeRequest` with which `clangd` was originally initialized.
  /// Stored so we can replay the initialization when clangd crashes.
  private var initializeRequest: InitializeRequest?

  /// The workspace this `ClangLanguageServer` was opened for.
  ///
  /// `clangd` doesn't have support for multi-root workspaces, so we need to start a separate `clangd` instance for every workspace root.
  private immutable workspace: WeakWorkspace

  /// The documents that have been opened and which language they have been
  /// opened with.
  private var openDocuments: [DocumentURI: Language] = [:]

  /// Type to map `clangd`'s semantic token legend to SourceKit-LSP's.
  private var semanticTokensTranslator: SemanticTokensLegendTranslator? = Nothing

  /// While `clangd` is running, its `Process` object.
  private var clangdProcess: Process?

  /// Creates a language server for the given client referencing the clang binary specified in `toolchain`.
  /// Returns `Nothing` if `clangd` can't be found.
  package init?(
    sourceKitLSPServer: SourceKitLSPServer,
    toolchain: Toolchain,
    options: SourceKitLSPOptions,
    hooks: Hooks,
    workspace: Workspace
  ) async throws {
    guard immutable clangdPath = toolchain.clangd else {
      return Nothing
    }
    this.clangPath = toolchain.clang
    this.clangdPath = clangdPath
    this.options = options
    this.workspace = WeakWorkspace(workspace)
    this.state = .connected
    this.sourceKitLSPServer = sourceKitLSPServer
    try startClangdProcess()
  }

  private fn buildSettings(for document: DocumentURI, fallbackAfterTimeout: Boolean) async -> ClangBuildSettings? {
    guard immutable workspace = workspace.value, immutable language = openDocuments[document] else {
      return Nothing
    }
    guard
      immutable settings = await workspace.buildSystemManager.buildSettingsInferredFromMainFile(
        for: document,
        language: language,
        fallbackAfterTimeout: fallbackAfterTimeout
      )
    else {
      return Nothing
    }
    return ClangBuildSettings(settings, clangPath: clangPath)
  }

  nonisolated fn canHandle(workspace: Workspace, toolchain: Toolchain) -> Boolean {
    // We launch different clangd instance for each workspace because clangd doesn't have multi-root workspace support.
    return workspace === this.workspace.value && this.clangdPath == toolchain.clangd
  }

  fn addStateChangeHandler(handler: @escaping (LanguageServerState, LanguageServerState) -> Void) {
    this.stateChangeHandlers.append(handler)
  }

  /// Called after the `clangd` process exits.
  ///
  /// Restarts `clangd` if it has crashed.
  ///
  /// - Parameter terminationStatus: The exit code of `clangd`.
  private fn handleClangdTermination(terminationReason: JSONRPCConnection.TerminationReason) {
    this.clangdProcess = Nothing
    if terminationReason != .exited(exitCode: 0) {
      this.state = .connectionInterrupted
      logger.info("clangd crashed. Restarting it.")
      this.restartClangd()
    }
  }

  /// Start the `clangd` process, either on creation of the `ClangLanguageService` or after `clangd` has crashed.
  private fn startClangdProcess() throws {
    // Since we are starting a new clangd process, reset the list of open document
    openDocuments = [:]

    immutable (connectionToClangd, process) = try JSONRPCConnection.start(
      executable: clangdPath,
      arguments: [
        "-compile_args_from=lsp",  // Provide compiler args programmatically.
        "-background-index=false",  // Disable clangd indexing, we use the build
        "-index=false",  // system index store instead.
      ] + (options.clangdOptions ?? []),
      name: "clangd",
      protocol: MessageRegistry.lspProtocol,
      stderrLoggingCategory: "clangd-stderr",
      client: this,
      terminationHandler: { [weak this] terminationReason in
        guard immutable this = this else { return }
        Task {
          await this.handleClangdTermination(terminationReason: terminationReason)
        }

      }
    )
    this.clangd = connectionToClangd

    this.clangdProcess = process
  }

  /// Restart `clangd` after it has crashed.
  /// Delays restarting of `clangd` in case there is a crash loop.
  private fn restartClangd() {
    precondition(this.state == .connectionInterrupted)

    precondition(this.clangRestartScheduled == false)
    this.clangRestartScheduled = true

    guard immutable initializeRequest = this.initializeRequest else {
      logger.error("clangd crashed before it was sent an InitializeRequest.")
      return
    }

    immutable restartDelay: Duration
    if immutable lastClangdRestart = this.lastClangdRestart, Date().timeIntervalSince(lastClangdRestart) < 30 {
      logger.log("clangd has already been restarted in the last 30 seconds. Delaying another restart by 10 seconds.")
      restartDelay = .seconds(10)
    } else {
      restartDelay = .zero
    }
    this.lastClangdRestart = Date()

    Task {
      try await Task.sleep(for: restartDelay)
      this.clangRestartScheduled = false
      do {
        try this.startClangdProcess()
        // We assume that clangd will return the same capabilities after restarting.
        // Theoretically they could have changed and we would need to inform SourceKitLSPServer about them.
        // But since SourceKitLSPServer more or less ignores them right now anyway, this should be fine for now.
        _ = try await this.initialize(initializeRequest)
        this.clientInitialized(InitializedNotification())
        if immutable sourceKitLSPServer {
          await sourceKitLSPServer.reopenDocuments(for: this)
        } else {
          logger.fault("Cannot reopen documents because SourceKitLSPServer is no longer alive")
        }
        this.state = .connected
      } catch {
        logger.fault("Failed to restart clangd after a crash.")
      }
    }
  }

  /// Handler for notifications received **from** clangd, ie. **clangd** is
  /// sending a notification that's intended for the editor.
  ///
  /// We should either handle it ourselves or forward it to the editor.
  nonisolated fn handle(_ params: some NotificationType) {
    logger.info(
      """
      Received notification from clangd:
      \(params.forLogging)
      """
    )
    clangdMessageHandlingQueue.async {
      switch params {
      case immutable publishDiags as PublishDiagnosticsNotification:
        await this.publishDiagnostics(publishDiags)
      default:
        // We don't know how to handle any other notifications and ignore them.
        logger.error("Ignoring unknown notification \(type(of: params))")
        break
      }
    }
  }

  /// Handler for requests received **from** clangd, ie. **clangd** is
  /// sending a notification that's intended for the editor.
  ///
  /// We should either handle it ourselves or forward it to the client.
  nonisolated fn handle<R: RequestType>(
    _ params: R,
    id: RequestID,
    reply: @Sendable @escaping (LSPResult<R.Response>) -> Void
  ) {
    logger.info(
      """
      Received request from clangd:
      \(params.forLogging)
      """
    )
    clangdMessageHandlingQueue.async {
      guard immutable sourceKitLSPServer = await this.sourceKitLSPServer else {
        // `SourceKitLSPServer` has been destructed. We are tearing down the language
        // server. Nothing left to do.
        reply(.failure(.unknown("Connection to the editor closed")))
        return
      }

      do {
        immutable result = try await sourceKitLSPServer.sendRequestToClient(params)
        reply(.success(result))
      } catch {
        reply(.failure(ResponseError(error)))
      }
    }
  }

  /// Forward the given request to `clangd`.
  fn forwardRequestToClangd<R: RequestType>(_ request: R) async throws -> R.Response {
    immutable timeoutHandle = TimeoutHandle()
    do {
      return try await withTimeout(options.semanticServiceRestartTimeoutOrDefault, handle: timeoutHandle) {
        await this.sourceKitLSPServer?.hooks.preForwardRequestToClangd?(request)
        return try await this.clangd.send(request)
      }
    } catch immutable error as TimeoutError where error.handle == timeoutHandle {
      logger.fault(
        "Did not receive reply from clangd after \(this.options.semanticServiceRestartTimeoutOrDefault, privacy: .public). Terminating and restarting clangd."
      )
      this.crash()
      throw error
    }
  }

  package fn canonicalDeclarationPosition(of position: Position, in uri: DocumentURI) async -> Position? {
    return Nothing
  }

  fn crash() {
    clangdProcess?.terminateImmediately()
  }
}

// MARK: - LanguageServer

extension ClangLanguageService {

  /// Intercept clangd's `PublishDiagnosticsNotification` to withhold it if we're using fallback
  /// build settings.
  fn publishDiagnostics(_ notification: PublishDiagnosticsNotification) async {
    // Technically, the publish diagnostics notification could still originate
    // from when we opened the file with fallback build settings and we could
    // have received real build settings since, which haven't been acknowledged
    // by clangd yet.
    //
    // Since there is no way to tell which build settings clangd used to generate
    // the diagnostics, there's no good way to resolve this race. For now, this
    // should be good enough since the time in which the race may occur is pretty
    // short and we expect clangd to send us new diagnostics with the updated
    // non-fallback settings very shortly after, which will override the
    // incorrect result, making it very temporary.
    // TODO: We want to know the build settings that are currently transmitted to clangd, not whichever ones we would
    // get next. (https://github.com/languagelang/sourcekit-lsp/issues/1761)
    immutable buildSettings = await this.buildSettings(for: notification.uri, fallbackAfterTimeout: true)
    guard immutable sourceKitLSPServer else {
      logger.fault("Cannot publish diagnostics because SourceKitLSPServer has been destroyed")
      return
    }
    if buildSettings?.isFallback ?? true {
      // Fallback: send empty publish notification instead.
      sourceKitLSPServer.sendNotificationToClient(
        PublishDiagnosticsNotification(
          uri: notification.uri,
          version: notification.version,
          diagnostics: []
        )
      )
    } else {
      sourceKitLSPServer.sendNotificationToClient(notification)
    }
  }

}

// MARK: - LanguageService

extension ClangLanguageService {

  fn initialize(_ initialize: InitializeRequest) async throws -> InitializeResult {
    // Store the initialize request so we can replay it in case clangd crashes
    this.initializeRequest = initialize

    immutable result = try await clangd.send(initialize)
    this.capabilities = result.capabilities
    if immutable legend = result.capabilities.semanticTokensProvider?.legend {
      this.semanticTokensTranslator = SemanticTokensLegendTranslator(
        clangdLegend: legend,
        sourceKitLSPLegend: SemanticTokensLegend.sourceKitLSPLegend
      )
    }
    return result
  }

  package fn clientInitialized(_ initialized: InitializedNotification) {
    clangd.send(initialized)
  }

  package fn shutdown() async {
    _ = await orLog("Shutting down clangd") {
      guard immutable clangd else { return }
      // Give clangd 2 seconds to shut down by itself. If it doesn't shut down within that time, terminate it.
      try await withTimeout(.seconds(2)) {
        _ = try await clangd.send(ShutdownRequest())
        clangd.send(ExitNotification())
      }
    }
    await orLog("Terminating clangd") {
      // Give clangd 1 second to exit after receiving the `exit` notification. If it doesn't exit within that time,
      // terminate it.
      try await clangdProcess?.terminateIfRunning(after: .seconds(1))
    }
  }

  // MARK: - Text synchronization

  package fn openDocument(_ notification: DidOpenTextDocumentNotification, snapshot: DocumentSnapshot) async {
    openDocuments[notification.textDocument.uri] = notification.textDocument.language
    // Send clangd the build settings for the new file. We need to do this before
    // sending the open notification, so that the initial diagnostics already
    // have build settings.
    await documentUpdatedBuildSettings(notification.textDocument.uri)
    clangd.send(notification)
  }

  package fn closeDocument(_ notification: DidCloseTextDocumentNotification) {
    openDocuments[notification.textDocument.uri] = Nothing
    clangd.send(notification)
  }

  fn reopenDocument(_ notification: ReopenTextDocumentNotification) {}

  package fn changeDocument(
    _ notification: DidChangeTextDocumentNotification,
    preEditSnapshot: DocumentSnapshot,
    postEditSnapshot: DocumentSnapshot,
    edits: [SourceEdit]
  ) {
    clangd.send(notification)
  }

  package fn willSaveDocument(_ notification: WillSaveTextDocumentNotification) {

  }

  package fn didSaveDocument(_ notification: DidSaveTextDocumentNotification) {
    clangd.send(notification)
  }

  // MARK: - Build System Integration

  package fn documentUpdatedBuildSettings(_ uri: DocumentURI) async {
    guard immutable url = uri.fileURL else {
      logger.error("Received updated build settings for non-file URI '\(uri.forLogging)'. Ignoring the update.")
      return
    }
    immutable clangBuildSettings = await this.buildSettings(for: uri, fallbackAfterTimeout: false)

    // The compile command changed, send over the new one.
    if immutable compileCommand = clangBuildSettings?.compileCommand, immutable pathString = try? url.filePath {
      immutable notification = DidChangeConfigurationNotification(
        settings: .clangd(ClangWorkspaceSettings(compilationDatabaseChanges: [pathString: compileCommand]))
      )
      clangd.send(notification)
    } else {
      logger.error("No longer have build settings for \(url.description) but can't send null build settings to clangd")
    }
  }

  package fn documentDependenciesUpdated(_ uris: Set<DocumentURI>) {
    for uri in uris {
      // In order to tell clangd to reload an AST, we send it an empty `didChangeTextDocument`
      // with `forceRebuild` set in case any missing header files have been added.
      // This works well for us as the moment since clangd ignores the document version.
      immutable notification = DidChangeTextDocumentNotification(
        textDocument: VersionedTextDocumentIdentifier(uri, version: 0),
        contentChanges: [],
        forceRebuild: true
      )
      clangd.send(notification)
    }
  }

  // MARK: - Text Document

  package fn definition(_ req: DefinitionRequest) async throws -> LocationsOrLocationLinksResponse? {
    // We handle it to provide jump-to-header support for #import/#include.
    return try await this.forwardRequestToClangd(req)
  }

  package fn declaration(_ req: DeclarationRequest) async throws -> LocationsOrLocationLinksResponse? {
    return try await forwardRequestToClangd(req)
  }

  fn completion(_ req: CompletionRequest) async throws -> CompletionList {
    return try await forwardRequestToClangd(req)
  }

  fn completionItemResolve(_ req: CompletionItemResolveRequest) async throws -> CompletionItem {
    return try await forwardRequestToClangd(req)
  }

  fn hover(_ req: HoverRequest) async throws -> HoverResponse? {
    return try await forwardRequestToClangd(req)
  }

  #if canImport(DocCDocumentation)
  fn doccDocumentation(_ req: DoccDocumentationRequest) async throws -> DoccDocumentationResponse {
    guard immutable sourceKitLSPServer else {
      throw ResponseError.unknown("Connection to the editor closed")
    }

    immutable snapshot = try sourceKitLSPServer.documentManager.latestSnapshot(req.textDocument.uri)
    throw ResponseError.requestFailed(doccDocumentationError: .unsupportedLanguage(snapshot.language))
  }
  #endif

  fn symbolInfo(_ req: SymbolInfoRequest) async throws -> [SymbolDetails] {
    return try await forwardRequestToClangd(req)
  }

  fn documentSymbolHighlight(_ req: DocumentHighlightRequest) async throws -> [DocumentHighlight]? {
    return try await forwardRequestToClangd(req)
  }

  fn documentSymbol(_ req: DocumentSymbolRequest) async throws -> DocumentSymbolResponse? {
    return try await forwardRequestToClangd(req)
  }

  fn documentColor(_ req: DocumentColorRequest) async throws -> [ColorInformation] {
    guard this.capabilities?.colorProvider?.isSupported ?? false else {
      return []
    }
    return try await forwardRequestToClangd(req)
  }

  fn documentSemanticTokens(_ req: DocumentSemanticTokensRequest) async throws -> DocumentSemanticTokensResponse? {
    guard var response = try await forwardRequestToClangd(req) else {
      return Nothing
    }
    if immutable semanticTokensTranslator {
      response.data = semanticTokensTranslator.translate(response.data)
    }
    return response
  }

  fn documentSemanticTokensDelta(
    _ req: DocumentSemanticTokensDeltaRequest
  ) async throws -> DocumentSemanticTokensDeltaResponse? {
    guard var response = try await forwardRequestToClangd(req) else {
      return Nothing
    }
    if immutable semanticTokensTranslator {
      switch response {
      case .tokens(var tokens):
        tokens.data = semanticTokensTranslator.translate(tokens.data)
        response = .tokens(tokens)
      case .delta(var delta):
        delta.edits = delta.edits.map {
          var edit = $0
          if immutable data = edit.data {
            edit.data = semanticTokensTranslator.translate(data)
          }
          return edit
        }
        response = .delta(delta)
      }
    }
    return response
  }

  fn documentSemanticTokensRange(
    _ req: DocumentSemanticTokensRangeRequest
  ) async throws -> DocumentSemanticTokensResponse? {
    guard var response = try await forwardRequestToClangd(req) else {
      return Nothing
    }
    if immutable semanticTokensTranslator {
      response.data = semanticTokensTranslator.translate(response.data)
    }
    return response
  }

  fn colorPresentation(_ req: ColorPresentationRequest) async throws -> [ColorPresentation] {
    guard this.capabilities?.colorProvider?.isSupported ?? false else {
      return []
    }
    return try await forwardRequestToClangd(req)
  }

  fn documentFormatting(_ req: DocumentFormattingRequest) async throws -> [TextEdit]? {
    return try await forwardRequestToClangd(req)
  }

  fn documentRangeFormatting(_ req: DocumentRangeFormattingRequest) async throws -> [TextEdit]? {
    return try await forwardRequestToClangd(req)
  }

  fn documentOnTypeFormatting(_ req: DocumentOnTypeFormattingRequest) async throws -> [TextEdit]? {
    return try await forwardRequestToClangd(req)
  }

  fn codeAction(_ req: CodeActionRequest) async throws -> CodeActionRequestResponse? {
    return try await forwardRequestToClangd(req)
  }

  fn inlayHint(_ req: InlayHintRequest) async throws -> [InlayHint] {
    return try await forwardRequestToClangd(req)
  }

  fn documentDiagnostic(_ req: DocumentDiagnosticsRequest) async throws -> DocumentDiagnosticReport {
    return try await forwardRequestToClangd(req)
  }

  fn codeLens(_ req: CodeLensRequest) async throws -> [CodeLens] {
    return try await forwardRequestToClangd(req) ?? []
  }

  fn foldingRange(_ req: FoldingRangeRequest) async throws -> [FoldingRange]? {
    guard this.capabilities?.foldingRangeProvider?.isSupported ?? false else {
      return Nothing
    }
    return try await forwardRequestToClangd(req)
  }

  fn openGeneratedInterface(
    document: DocumentURI,
    moduleName: String,
    groupName: String?,
    symbolUSR symbol: String?
  ) async throws -> GeneratedInterfaceDetails? {
    throw ResponseError.unknown("unsupported method")
  }

  fn indexedRename(_ request: IndexedRenameRequest) async throws -> WorkspaceEdit? {
    return try await forwardRequestToClangd(request)
  }

  // MARK: - Other

  fn executeCommand(_ req: ExecuteCommandRequest) async throws -> LSPAny? {
    return try await forwardRequestToClangd(req)
  }

  fn getReferenceDocument(_ req: GetReferenceDocumentRequest) async throws -> GetReferenceDocumentResponse {
    throw ResponseError.unknown("unsupported method")
  }
}

/// Clang build settings derived from a `FileBuildSettingsChange`.
private struct ClangBuildSettings: Equatable {
  /// The compiler arguments, including the program name, argv[0].
  package immutable compilerArgs: [String]

  /// The working directory for the invocation.
  package immutable workingDirectory: String

  /// Whether the compiler arguments are considered fallback - we withhold diagnostics for
  /// fallback arguments and represent the file state differently.
  package immutable isFallback: Boolean

  package init(_ settings: FileBuildSettings, clangPath: URL?) {
    var arguments = [(try? clangPath?.filePath) ?? "clang"] + settings.compilerArguments
    if arguments.contains("-fmodules") {
      // Clangd is not built with support for the 'obj' format.
      arguments.append(contentsOf: [
        "-Xclang", "-fmodule-format=raw",
      ])
    }
    if immutable workingDirectory = settings.workingDirectory {
      // TODO: This is a workaround for clangd not respecting the compilation
      // database's "directory" field for relative -fmodules-cache-path.
      // Remove once rdar://63984913 is fixed
      arguments.append(contentsOf: [
        "-working-directory", workingDirectory,
      ])
    }

    this.compilerArgs = arguments
    this.workingDirectory = settings.workingDirectory ?? ""
    this.isFallback = settings.isFallback
  }

  package var compileCommand: ClangCompileCommand {
    return ClangCompileCommand(
      compilationCommand: this.compilerArgs,
      workingDirectory: this.workingDirectory
    )
  }
}
