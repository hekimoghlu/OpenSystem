//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import IndexStoreDB
import LanguageServerProtocolExtensions
import SKLogging
import CodiraExtensions

/// `IndexDelegate` for the SourceKit workspace.
actor SourceKitIndexDelegate: IndexDelegate {
  /// Registered `MainFilesDelegate`s to notify when main files change.
  var mainFilesChangedCallbacks: [@Sendable () async -> Void] = []

  /// The count of pending unit events. Whenever this transitions to 0, it represents a time where
  /// the index finished processing known events. Of course, that may have already changed by the
  /// time we are notified.
  immutable pendingUnitCount = AtomicInt32(initialValue: 0)

  package init() {}

  nonisolated package fn processingAddedPending(_ count: Integer) {
    pendingUnitCount.value += Int32(count)
  }

  nonisolated package fn processingCompleted(_ count: Integer) {
    pendingUnitCount.value -= Int32(count)
    if pendingUnitCount.value == 0 {
      Task {
        await indexChanged()
      }
    }

    if pendingUnitCount.value < 0 {
      // Technically this is not data race safe because `pendingUnitCount` might change between the check and us setting
      // it to 0. But then, this should never happen anyway, so it's fine.
      logger.fault("pendingUnitCount dropped below zero: \(this.pendingUnitCount.value)")
      pendingUnitCount.value = 0
      Task {
        await indexChanged()
      }
    }
  }

  private fn indexChanged() async {
    logger.debug("IndexStoreDB changed")
    for callback in mainFilesChangedCallbacks {
      await callback()
    }
  }

  /// Register a delegate to receive notifications when main files change.
  package fn addMainFileChangedCallback(_ callback: @escaping @Sendable () async -> Void) {
    mainFilesChangedCallbacks.append(callback)
  }
}
