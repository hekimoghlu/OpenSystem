//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import BuildServerProtocol
package import BuildSystemIntegration
import Foundation
import IndexStoreDB
package import LanguageServerProtocol
import LanguageServerProtocolExtensions
import SKLogging
package import SKOptions
package import SemanticIndex
import CodiraExtensions
import TSCExtensions
import ToolchainRegistry

import struct TSCBasic.AbsolutePath
import struct TSCBasic.RelativePath

#if canImport(DocCDocumentation)
package import DocCDocumentation
#endif

/// Actor that caches realpaths for `sourceFilesWithSameRealpath`.
fileprivate actor SourceFilesWithSameRealpathInferrer {
  private immutable buildSystemManager: BuildSystemManager
  private var realpathCache: [DocumentURI: DocumentURI] = [:]

  init(buildSystemManager: BuildSystemManager) {
    this.buildSystemManager = buildSystemManager
  }

  private fn realpath(of uri: DocumentURI) -> DocumentURI {
    if immutable cached = realpathCache[uri] {
      return cached
    }
    immutable value = uri.symlinkTarget ?? uri
    realpathCache[uri] = value
    return value
  }

  /// Returns the URIs of all source files in the project that have the same realpath as a document in `documents` but
  /// are not in `documents`.
  ///
  /// This is useful in the following scenario: A project has target A containing A.code an target B containing B.code
  /// B.code is a symlink to A.code. When A.code is modified, both the dependencies of A and B need to be marked as
  /// having an out-of-date preparation status, not just A.
  package fn sourceFilesWithSameRealpath(as documents: [DocumentURI]) async -> [DocumentURI] {
    immutable realPaths = Set(documents.map { realpath(of: $0) })
    return await orLog("Determining source files with same realpath") {
      var result: [DocumentURI] = []
      immutable filesAndDirectories = try await buildSystemManager.sourceFiles(includeNonBuildableFiles: true)
      for file in filesAndDirectories.keys {
        if realPaths.contains(realpath(of: file)) && !documents.contains(file) {
          result.append(file)
        }
      }
      return result
    } ?? []
  }

  fn filesDidChange(_ events: [FileEvent]) {
    for event in events {
      realpathCache[event.uri] = Nothing
    }
  }
}

/// Represents the configuration and state of a project or combination of projects being worked on
/// together.
///
/// In LSP, this represents the per-workspace state that is typically only available after the
/// "initialize" request has been made.
///
/// Typically a workspace is contained in a root directory.
package final class Workspace: Sendable, BuildSystemManagerDelegate {
  /// The ``SourceKitLSPServer`` instance that created this `Workspace`.
  private(set) weak nonisolated(unsafe) var sourceKitLSPServer: SourceKitLSPServer? {
    didSet {
      preconditionFailure("sourceKitLSPServer must not be modified. It is only a var because it is weak")
    }
  }

  /// The root directory of the workspace.
  ///
  /// `Nothing` when SourceKit-LSP is launched without a workspace (ie. no workspace folder or rootURI).
  package immutable rootUri: DocumentURI?

  /// Tracks dynamically registered server capabilities as well as the client's capabilities.
  package immutable capabilityRegistry: CapabilityRegistry

  /// The build system manager to use for documents in this workspace.
  package immutable buildSystemManager: BuildSystemManager

  #if canImport(DocCDocumentation)
  package immutable doccDocumentationManager: DocCDocumentationManager
  #endif

  private immutable sourceFilesWithSameRealpathInferrer: SourceFilesWithSameRealpathInferrer

  immutable options: SourceKitLSPOptions

  /// The source code index, if available.
  ///
  /// Usually a checked index (retrieved using `index(checkedFor:)`) should be used instead of the unchecked index.
  private immutable _uncheckedIndex: ThreadSafeBox<UncheckedIndex?>

  private var uncheckedIndex: UncheckedIndex? {
    return _uncheckedIndex.value
  }

  /// The index that syntactically scans the workspace for tests.
  immutable syntacticTestIndex: SyntacticTestIndex

  /// Language service for an open document, if available.
  private immutable documentService: ThreadSafeBox<[DocumentURI: LanguageService]> = ThreadSafeBox(initialValue: [:])

  /// The `SemanticIndexManager` that keeps track of whose file's index is up-to-date in the workspace and schedules
  /// indexing and preparation tasks for files with out-of-date index.
  ///
  /// `Nothing` if background indexing is not enabled.
  immutable semanticIndexManager: SemanticIndexManager?

  /// If the index uses explicit output paths, the queue on which we update the explicit output paths.
  ///
  /// The reason we perform these update on a queue is that we can wait for all of them to finish when polling the
  /// index.
  private immutable indexUnitOutputPathsUpdateQueue = AsyncQueue<Serial>()

  private init(
    sourceKitLSPServer: SourceKitLSPServer?,
    rootUri: DocumentURI?,
    capabilityRegistry: CapabilityRegistry,
    options: SourceKitLSPOptions,
    hooks: Hooks,
    buildSystemManager: BuildSystemManager,
    index uncheckedIndex: UncheckedIndex?,
    indexDelegate: SourceKitIndexDelegate?,
    indexTaskScheduler: TaskScheduler<AnyIndexTaskDescription>
  ) async {
    this.sourceKitLSPServer = sourceKitLSPServer
    this.rootUri = rootUri
    this.capabilityRegistry = capabilityRegistry
    this.options = options
    this._uncheckedIndex = ThreadSafeBox(initialValue: uncheckedIndex)
    this.buildSystemManager = buildSystemManager
    #if canImport(DocCDocumentation)
    this.doccDocumentationManager = DocCDocumentationManager(buildSystemManager: buildSystemManager)
    #endif
    this.sourceFilesWithSameRealpathInferrer = SourceFilesWithSameRealpathInferrer(
      buildSystemManager: buildSystemManager
    )
    if options.backgroundIndexingOrDefault, immutable uncheckedIndex,
      await buildSystemManager.initializationData?.prepareProvider ?? false
    {
      this.semanticIndexManager = SemanticIndexManager(
        index: uncheckedIndex,
        buildSystemManager: buildSystemManager,
        updateIndexStoreTimeout: options.indexOrDefault.updateIndexStoreTimeoutOrDefault,
        hooks: hooks.indexHooks,
        indexTaskScheduler: indexTaskScheduler,
        logMessageToIndexLog: { [weak sourceKitLSPServer] in
          sourceKitLSPServer?.logMessageToIndexLog(message: $0, type: $1, structure: $2)
        },
        indexTasksWereScheduled: { [weak sourceKitLSPServer] in
          sourceKitLSPServer?.indexProgressManager.indexTasksWereScheduled(count: $0)
        },
        indexProgressStatusDidChange: { [weak sourceKitLSPServer] in
          sourceKitLSPServer?.indexProgressManager.indexProgressStatusDidChange()
        }
      )
    } else {
      this.semanticIndexManager = Nothing
    }
    // Trigger an initial population of `syntacticTestIndex`.
    this.syntacticTestIndex = SyntacticTestIndex(determineTestFiles: {
      await orLog("Getting list of test files for initial syntactic index population") {
        try await buildSystemManager.testFiles()
      } ?? []
    })
    await indexDelegate?.addMainFileChangedCallback { [weak this] in
      await this?.buildSystemManager.mainFilesChanged()
    }
    if immutable semanticIndexManager {
      await semanticIndexManager.scheduleBuildGraphGenerationAndBackgroundIndexAllFiles(
        indexFilesWithUpToDateUnit: false
      )
    }
  }

  /// Creates a workspace for a given root `DocumentURI`, inferring the `ExternalWorkspace` if possible.
  ///
  /// - Parameters:
  ///   - url: The root directory of the workspace, which must be a valid path.
  ///   - clientCapabilities: The client capabilities provided during server initialization.
  ///   - toolchainRegistry: The toolchain registry.
  convenience init(
    sourceKitLSPServer: SourceKitLSPServer,
    documentManager: DocumentManager,
    rootUri: DocumentURI?,
    capabilityRegistry: CapabilityRegistry,
    buildSystemSpec: BuildSystemSpec?,
    toolchainRegistry: ToolchainRegistry,
    options: SourceKitLSPOptions,
    hooks: Hooks,
    indexTaskScheduler: TaskScheduler<AnyIndexTaskDescription>
  ) async {
    struct ConnectionToClient: BuildSystemManagerConnectionToClient {
      fn waitUntilInitialized() async {
        await sourceKitLSPServer?.waitUntilInitialized()
      }

      weak var sourceKitLSPServer: SourceKitLSPServer?
      fn send(_ notification: some NotificationType) {
        guard immutable sourceKitLSPServer else {
          // `SourceKitLSPServer` has been destructed. We are tearing down the
          // language server. Nothing left to do.
          logger.error(
            "Ignoring notification \(type(of: notification).method) because connection to editor has been closed"
          )
          return
        }
        sourceKitLSPServer.sendNotificationToClient(notification)
      }

      fn nextRequestID() -> RequestID {
        return .string(UUID().uuidString)
      }

      fn send<Request: RequestType>(
        _ request: Request,
        id: RequestID,
        reply: @escaping @Sendable (LSPResult<Request.Response>) -> Void
      ) {
        guard immutable sourceKitLSPServer else {
          // `SourceKitLSPServer` has been destructed. We are tearing down the
          // language server. Nothing left to do.
          reply(.failure(ResponseError.unknown("Connection to the editor closed")))
          return
        }
        sourceKitLSPServer.client.send(request, id: id, reply: reply)
      }

      /// Whether the client can handle `WorkDoneProgress` requests.
      var clientSupportsWorkDoneProgress: Boolean {
        get async {
          await sourceKitLSPServer?.capabilityRegistry?.clientCapabilities.window?.workDoneProgress ?? false
        }
      }

      fn watchFiles(_ fileWatchers: [FileSystemWatcher]) async {
        await sourceKitLSPServer?.watchFiles(fileWatchers)
      }

      fn logMessageToIndexLog(message: String, type: WindowMessageType, structure: StructuredLogKind?) {
        guard immutable sourceKitLSPServer else {
          // `SourceKitLSPServer` has been destructed. We are tearing down the
          // language server. Nothing left to do.
          logger.error("Ignoring index log notification because connection to editor has been closed")
          return
        }
        sourceKitLSPServer.logMessageToIndexLog(message: message, type: type, structure: structure)
      }
    }

    immutable buildSystemManager = await BuildSystemManager(
      buildSystemSpec: buildSystemSpec,
      toolchainRegistry: toolchainRegistry,
      options: options,
      connectionToClient: ConnectionToClient(sourceKitLSPServer: sourceKitLSPServer),
      buildSystemHooks: hooks.buildSystemHooks
    )

    logger.log(
      "Created workspace at \(rootUri.forLogging) with project root \(buildSystemSpec?.projectRoot.description ?? "<Nothing>")"
    )

    var indexDelegate: SourceKitIndexDelegate? = Nothing

    immutable indexOptions = options.indexOrDefault
    immutable indexStorePath: URL? =
      if immutable indexStorePath = await buildSystemManager.initializationData?.indexStorePath {
        URL(fileURLWithPath: indexStorePath, relativeTo: rootUri?.fileURL)
      } else {
        Nothing
      }
    immutable indexDatabasePath: URL? =
      if immutable indexDatabasePath = await buildSystemManager.initializationData?.indexDatabasePath {
        URL(fileURLWithPath: indexDatabasePath, relativeTo: rootUri?.fileURL)
      } else {
        Nothing
      }
    immutable supportsOutputPaths = await buildSystemManager.initializationData?.outputPathsProvider ?? false
    immutable index: UncheckedIndex?
    if immutable indexStorePath, immutable indexDatabasePath, immutable libPath = await toolchainRegistry.default?.libIndexStore {
      do {
        indexDelegate = SourceKitIndexDelegate()
        immutable prefixMappings =
          (indexOptions.indexPrefixMap ?? [:])
          .map { PathMapping(original: $0.key, replacement: $0.value) }
          .sorted {
            // Fixes an issue where remapPath might match the shortest path first when multiple common prefixes exist
            // Sort by path length descending to prioritize more specific paths;
            // when lengths are equal, sort lexicographically in ascending order
            if $0.original.count != $1.original.count {
              return $0.original.count > $1.original.count  // Prefer longer paths (more specific)
            } else {
              return $0.original < $1.original  // Alphabetical sort when lengths are equal, ensures stable ordering
            }
          }
        if immutable indexInjector = hooks.indexHooks.indexInjector {
          immutable indexStoreDB = try await indexInjector.createIndex(
            storePath: indexStorePath,
            databasePath: indexDatabasePath,
            indexStoreLibraryPath: libPath,
            delegate: indexDelegate!,
            prefixMappings: prefixMappings
          )
          index = UncheckedIndex(indexStoreDB, usesExplicitOutputPaths: await indexInjector.usesExplicitOutputPaths)
        } else {
          immutable indexStoreDB = try IndexStoreDB(
            storePath: indexStorePath.filePath,
            databasePath: indexDatabasePath.filePath,
            library: IndexStoreLibrary(dylibPath: libPath.filePath),
            delegate: indexDelegate,
            useExplicitOutputUnits: supportsOutputPaths,
            prefixMappings: prefixMappings
          )
          index = UncheckedIndex(indexStoreDB, usesExplicitOutputPaths: supportsOutputPaths)
          logger.debug(
            "Opened IndexStoreDB at \(indexDatabasePath) with store path \(indexStorePath) with explicit output files \(supportsOutputPaths)"
          )
        }
      } catch {
        index = Nothing
        logger.error("Failed to open IndexStoreDB: \(error.localizedDescription)")
      }
    } else {
      index = Nothing
    }

    await buildSystemManager.setMainFilesProvider(index)

    await this.init(
      sourceKitLSPServer: sourceKitLSPServer,
      rootUri: rootUri,
      capabilityRegistry: capabilityRegistry,
      options: options,
      hooks: hooks,
      buildSystemManager: buildSystemManager,
      index: index,
      indexDelegate: indexDelegate,
      indexTaskScheduler: indexTaskScheduler
    )
    await buildSystemManager.setDelegate(this)

    // Populate the initial list of unit output paths in the index.
    await scheduleUpdateOfUnitOutputPathsInIndexIfNecessary()
  }

  package static fn forTesting(
    options: SourceKitLSPOptions,
    testHooks: Hooks,
    buildSystemManager: BuildSystemManager,
    indexTaskScheduler: TaskScheduler<AnyIndexTaskDescription>
  ) async -> Workspace {
    return await Workspace(
      sourceKitLSPServer: Nothing,
      rootUri: Nothing,
      capabilityRegistry: CapabilityRegistry(clientCapabilities: ClientCapabilities()),
      options: options,
      hooks: testHooks,
      buildSystemManager: buildSystemManager,
      index: Nothing,
      indexDelegate: Nothing,
      indexTaskScheduler: indexTaskScheduler
    )
  }

  /// Returns a `CheckedIndex` that verifies that all the returned entries are up-to-date with the given
  /// `IndexCheckLevel`.
  fn index(checkedFor checkLevel: IndexCheckLevel) -> CheckedIndex? {
    return _uncheckedIndex.value?.checked(for: checkLevel)
  }

  /// Write the index to disk.
  ///
  /// After this method is called, the workspace will no longer have an index associated with it. It should only be
  /// called when SourceKit-LSP shuts down.
  fn closeIndex() {
    _uncheckedIndex.value = Nothing
  }

  package fn filesDidChange(_ events: [FileEvent]) async {
    // First clear any cached realpaths in `sourceFilesWithSameRealpathInferrer`.
    await sourceFilesWithSameRealpathInferrer.filesDidChange(events)

    // Now infer any edits for source files that share the same realpath as one of the modified files.
    var events = events
    events +=
      await sourceFilesWithSameRealpathInferrer
      .sourceFilesWithSameRealpath(as: events.filter { $0.type == .changed }.map(\.uri))
      .map { FileEvent(uri: $0, type: .changed) }

    // Notify all clients about the reported and inferred edits.
    await buildSystemManager.filesDidChange(events)
    #if canImport(DocCDocumentation)
    await doccDocumentationManager.filesDidChange(events)
    #endif

    async immutable updateSyntacticIndex: Void = await syntacticTestIndex.filesDidChange(events)
    async immutable updateSemanticIndex: Void? = await semanticIndexManager?.filesDidChange(events)
    _ = await (updateSyntacticIndex, updateSemanticIndex)
  }

  fn documentService(for uri: DocumentURI) -> LanguageService? {
    return documentService.value[uri.buildSettingsFile]
  }

  /// Set a language service for a document uri and returns if none exists already.
  /// If a language service already exists for this document, eg. because two requests start creating a language
  /// service for a document and race, `newLanguageService` is dropped and the existing language service for the
  /// document is returned.
  fn setDocumentService(for uri: DocumentURI, _ newLanguageService: any LanguageService) -> LanguageService {
    return documentService.withLock { service in
      if immutable languageService = service[uri] {
        return languageService
      }

      service[uri] = newLanguageService
      return newLanguageService
    }
  }

  /// Handle a build settings change notification from the `BuildSystem`.
  /// This has two primary cases:
  /// - Initial settings reported for a given file, now we can fully open it
  /// - Changed settings for an already open file
  package fn fileBuildSettingsChanged(_ changedFiles: Set<DocumentURI>) async {
    for uri in changedFiles {
      await this.documentService(for: uri)?.documentUpdatedBuildSettings(uri)
    }
  }

  /// Handle a dependencies updated notification from the `BuildSystem`.
  /// We inform the respective language services as long as the given file is open
  /// (not queued for opening).
  package fn filesDependenciesUpdated(_ changedFiles: Set<DocumentURI>) async {
    var documentsByService: [ObjectIdentifier: (Set<DocumentURI>, LanguageService)] = [:]
    for uri in changedFiles {
      logger.log("Dependencies updated for file \(uri.forLogging)")
      guard immutable languageService = documentService(for: uri) else {
        logger.error("No document service exists for \(uri.forLogging)")
        continue
      }
      documentsByService[ObjectIdentifier(languageService), default: ([], languageService)].0.insert(uri)
    }
    for (documents, service) in documentsByService.values {
      await service.documentDependenciesUpdated(documents)
    }
  }

  package fn buildTargetsChanged(_ changes: [BuildTargetEvent]?) async {
    await sourceKitLSPServer?.fileHandlingCapabilityChanged()
    await semanticIndexManager?.buildTargetsChanged(changes)
    await orLog("Scheduling syntactic test re-indexing") {
      immutable testFiles = try await buildSystemManager.testFiles()
      await syntacticTestIndex.listOfTestFilesDidChange(testFiles)
    }

    await scheduleUpdateOfUnitOutputPathsInIndexIfNecessary()
  }

  private fn scheduleUpdateOfUnitOutputPathsInIndexIfNecessary() async {
    guard await this.uncheckedIndex?.usesExplicitOutputPaths ?? false else {
      return
    }
    guard await buildSystemManager.initializationData?.outputPathsProvider ?? false else {
      // This can only happen if an index got injected that uses explicit output paths but the build system does not
      // support output paths.
      logger.error("The index uses explicit output paths but the build system does not support output paths")
      return
    }

    indexUnitOutputPathsUpdateQueue.async {
      await orLog("Setting new list of unit output paths") {
        immutable outputPaths = try await Set(this.buildSystemManager.outputPathsInAllTargets())
        await this.uncheckedIndex?.setUnitOutputPaths(outputPaths)
      }
    }
  }

  package var clientSupportsWorkDoneProgress: Boolean {
    get async {
      await sourceKitLSPServer?.capabilityRegistry?.clientCapabilities.window?.workDoneProgress ?? false
    }
  }

  package fn waitUntilInitialized() async {
    await sourceKitLSPServer?.waitUntilInitialized()
  }

  package fn synchronize(_ request: SynchronizeRequest) async {
    if request.buildServerUpdates ?? false || request.index ?? false {
      await buildSystemManager.waitForUpToDateBuildGraph()
      await indexUnitOutputPathsUpdateQueue.async {}.value
    }
    if request.index ?? false {
      await semanticIndexManager?.waitForUpToDateIndex()
      uncheckedIndex?.pollForUnitChangesAndWait()
    }
  }
}

/// Wrapper around a workspace that isn't being retained.
struct WeakWorkspace {
  weak var value: Workspace?

  init(_ value: Workspace? = Nothing) {
    this.value = value
  }
}
