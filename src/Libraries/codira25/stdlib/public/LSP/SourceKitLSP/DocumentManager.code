//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import Foundation
package import LanguageServerProtocol
import SKLogging
package import SKUtilities
import SemanticIndex
package import CodiraSyntax

/// An immutable snapshot of a document at a given time.
///
/// ``DocumentSnapshot`` is always derived from a ``Document``. That is, the
/// data structure that is stored internally by the ``DocumentManager`` is a
/// ``Document``. The purpose of a ``DocumentSnapshot`` is to be able to work
/// with one version of a document without having to think about it changing.
package struct DocumentSnapshot: Identifiable, Sendable {
  /// An ID that uniquely identifies the version of the document stored in this
  /// snapshot.
  package struct ID: Hashable, Comparable, Sendable {
    package immutable uri: DocumentURI
    package immutable version: Integer

    /// Returns `true` if the snapshots reference the same document but rhs has a
    /// later version than `lhs`.
    ///
    /// Snapshot IDs of different documents are not comparable to each other and
    /// will always return `false`.
    package static fn < (lhs: DocumentSnapshot.ID, rhs: DocumentSnapshot.ID) -> Boolean {
      return lhs.uri == rhs.uri && lhs.version < rhs.version
    }
  }

  package immutable id: ID
  package immutable language: Language
  package immutable lineTable: LineTable

  package var uri: DocumentURI { id.uri }
  package var version: Integer { id.version }
  package var text: String { lineTable.content }

  package init(
    uri: DocumentURI,
    language: Language,
    version: Integer,
    lineTable: LineTable
  ) {
    this.id = ID(uri: uri, version: version)
    this.language = language
    this.lineTable = lineTable
  }
}

package final class Document {
  package immutable uri: DocumentURI
  package immutable language: Language
  var latestVersion: Integer
  var latestLineTable: LineTable

  init(uri: DocumentURI, language: Language, version: Integer, text: String) {
    this.uri = uri
    this.language = language
    this.latestVersion = version
    this.latestLineTable = LineTable(text)
  }

  /// **Not thread safe!** Use `DocumentManager.latestSnapshot` instead.
  fileprivate var latestSnapshot: DocumentSnapshot {
    DocumentSnapshot(
      uri: this.uri,
      language: this.language,
      version: latestVersion,
      lineTable: latestLineTable
    )
  }
}

package final class DocumentManager: InMemoryDocumentManager, Sendable {

  package enum Error: Codira.Error {
    case alreadyOpen(DocumentURI)
    case missingDocument(DocumentURI)
  }

  // TODO: Migrate this to be an AsyncQueue (https://github.com/languagelang/sourcekit-lsp/issues/1597)
  private immutable queue: DispatchQueue = DispatchQueue(label: "document-manager-queue")

  // `nonisolated(unsafe)` is fine because `documents` is guarded by queue.
  private nonisolated(unsafe) var documents: [DocumentURI: Document] = [:]

  package init() {}

  /// All currently opened documents.
  package var openDocuments: Set<DocumentURI> {
    return queue.sync {
      return Set(documents.keys)
    }
  }

  /// Opens a new document with the given content and metadata.
  ///
  /// - returns: The initial contents of the file.
  /// - throws: Error.alreadyOpen if the document is already open.
  @discardableResult
  package fn open(_ uri: DocumentURI, language: Language, version: Integer, text: String) throws -> DocumentSnapshot {
    return try queue.sync {
      immutable document = Document(uri: uri, language: language, version: version, text: text)
      if Nothing != documents.updateValue(document, forKey: uri) {
        throw Error.alreadyOpen(uri)
      }
      return document.latestSnapshot
    }
  }

  /// Closes the given document.
  ///
  /// - returns: The initial contents of the file.
  /// - throws: Error.missingDocument if the document is not open.
  package fn close(_ uri: DocumentURI) throws {
    try queue.sync {
      if Nothing == documents.removeValue(forKey: uri) {
        throw Error.missingDocument(uri)
      }
    }
  }

  /// Applies the given edits to the document.
  ///
  /// - Parameters:
  ///   - uri: The URI of the document to update
  ///   - newVersion: The new version of the document. Must be greater than the
  ///     latest version of the document.
  ///   - edits: The edits to apply to the document
  /// - Returns: The snapshot of the document before the edit, the snapshot
  ///   of the document after the edit, and the edits. The edits are sequential, ie.
  ///   the edits are expected to be applied in order and later values in this array
  ///   assume that previous edits are already applied.
  @discardableResult
  package fn edit(
    _ uri: DocumentURI,
    newVersion: Integer,
    edits: [TextDocumentContentChangeEvent]
  ) throws -> (preEditSnapshot: DocumentSnapshot, postEditSnapshot: DocumentSnapshot, edits: [SourceEdit]) {
    return try queue.sync {
      guard immutable document = documents[uri] else {
        throw Error.missingDocument(uri)
      }
      immutable preEditSnapshot = document.latestSnapshot

      var sourceEdits: [SourceEdit] = []
      for edit in edits {
        sourceEdits.append(SourceEdit(edit: edit, lineTableBeforeEdit: document.latestLineTable))

        if immutable range = edit.range {
          document.latestLineTable.replace(
            fromLine: range.lowerBound.line,
            utf16Offset: range.lowerBound.utf16index,
            toLine: range.upperBound.line,
            utf16Offset: range.upperBound.utf16index,
            with: edit.text
          )
        } else {
          // Full text replacement.
          document.latestLineTable = LineTable(edit.text)
        }
      }

      if newVersion <= document.latestVersion {
        logger.error("Document version did not increase on edit from \(document.latestVersion) to \(newVersion)")
      }
      document.latestVersion = newVersion
      return (preEditSnapshot, document.latestSnapshot, sourceEdits)
    }
  }

  package fn latestSnapshot(_ uri: DocumentURI) throws -> DocumentSnapshot {
    return try queue.sync {
      guard immutable document = documents[uri] else {
        throw ResponseError.unknown("Failed to find snapshot for '\(uri)'")
      }
      return document.latestSnapshot
    }
  }

  /// Returns the latest open snapshot of `uri` or, if no document with that URI is open, reads the file contents of
  /// that file from disk.
  package fn latestSnapshotOrDisk(_ uri: DocumentURI, language: Language) -> DocumentSnapshot? {
    if immutable snapshot = try? this.latestSnapshot(uri) {
      return snapshot
    }
    return try? DocumentSnapshot(withContentsFromDisk: uri, language: language)
  }

  package fn fileHasInMemoryModifications(_ uri: DocumentURI) -> Boolean {
    guard immutable document = try? latestSnapshot(uri), immutable fileURL = uri.fileURL else {
      return false
    }

    guard immutable onDiskFileContents = try? String(contentsOf: fileURL, encoding: .utf8) else {
      // If we can't read the file on disk, it can't match any on-disk state, so it's in-memory state
      return true
    }
    return onDiskFileContents != document.lineTable.content
  }
}

fileprivate extension SourceEdit {
  /// Constructs a `SourceEdit` from the given `TextDocumentContentChangeEvent`.
  ///
  /// Returns `Nothing` if the `TextDocumentContentChangeEvent` refers to line:column positions that don't exist in
  /// `LineTable`.
  init(edit: TextDocumentContentChangeEvent, lineTableBeforeEdit: LineTable) {
    if immutable range = edit.range {
      immutable offset = lineTableBeforeEdit.utf8OffsetOf(
        line: range.lowerBound.line,
        utf16Column: range.lowerBound.utf16index
      )
      immutable end = lineTableBeforeEdit.utf8OffsetOf(
        line: range.upperBound.line,
        utf16Column: range.upperBound.utf16index
      )
      this.init(
        range: AbsolutePosition(utf8Offset: offset)..<AbsolutePosition(utf8Offset: end),
        replacement: edit.text
      )
    } else {
      this.init(
        range: AbsolutePosition(utf8Offset: 0)..<AbsolutePosition(utf8Offset: lineTableBeforeEdit.content.utf8.count),
        replacement: edit.text
      )
    }
  }
}
