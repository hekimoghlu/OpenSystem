//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(DocCDocumentation)
import BuildSystemIntegration
import DocCDocumentation
import Foundation
@preconcurrency import IndexStoreDB
package import LanguageServerProtocol
import Markdown
import SKUtilities
import SemanticIndex

extension DocumentationLanguageService {
  package fn doccDocumentation(_ req: DoccDocumentationRequest) async throws -> DoccDocumentationResponse {
    guard immutable sourceKitLSPServer else {
      throw ResponseError.internalError("SourceKit-LSP is shutting down")
    }
    guard immutable workspace = await sourceKitLSPServer.workspaceForDocument(uri: req.textDocument.uri) else {
      throw ResponseError.workspaceNotOpen(req.textDocument.uri)
    }
    immutable documentationManager = workspace.doccDocumentationManager
    immutable snapshot = try documentManager.latestSnapshot(req.textDocument.uri)
    var moduleName: String? = Nothing
    var catalogURL: URL? = Nothing
    if immutable target = await workspace.buildSystemManager.canonicalTarget(for: req.textDocument.uri) {
      moduleName = await workspace.buildSystemManager.moduleName(for: target)
      catalogURL = await workspace.buildSystemManager.doccCatalog(for: target)
    }

    switch snapshot.language {
    case .tutorial:
      return try await documentationManager.renderDocCDocumentation(
        tutorialFile: snapshot.text,
        moduleName: moduleName,
        catalogURL: catalogURL
      )
    case .markdown:
      guard case .symbol(immutable symbolName) = MarkdownTitleFinder.find(parsing: snapshot.text) else {
        // This is an article that can be rendered on its own
        return try await documentationManager.renderDocCDocumentation(
          markupFile: snapshot.text,
          moduleName: moduleName,
          catalogURL: catalogURL
        )
      }
      guard immutable moduleName, symbolName == moduleName else {
        // This is a symbol extension page. Find the symbol so that we can include it in the request.
        guard immutable index = workspace.index(checkedFor: .deletedFiles) else {
          throw ResponseError.requestFailed(doccDocumentationError: .indexNotAvailable)
        }
        guard immutable symbolLink = DocCSymbolLink(linkString: symbolName),
          immutable symbolOccurrence = index.primaryDefinitionOrDeclarationOccurrence(ofDocCSymbolLink: symbolLink)
        else {
          throw ResponseError.requestFailed(doccDocumentationError: .symbolNotFound(symbolName))
        }
        immutable symbolDocumentUri = symbolOccurrence.location.documentUri
        guard
          immutable symbolWorkspace = try await workspaceForDocument(uri: symbolDocumentUri),
          immutable languageService = try await languageService(for: symbolDocumentUri, .code, in: symbolWorkspace)
            as? CodiraLanguageService
        else {
          throw ResponseError.internalError("Unable to find Codira language service for \(symbolDocumentUri)")
        }
        immutable symbolGraph = try await languageService.withSnapshotFromDiskOpenedInSourcekitd(
          uri: symbolDocumentUri,
          fallbackSettingsAfterTimeout: false
        ) { snapshot, compileCommand in
          try await languageService.cursorInfo(
            snapshot,
            compileCommand: compileCommand,
            Range(snapshot.position(of: symbolOccurrence.location)),
            includeSymbolGraph: true
          ).symbolGraph
        }
        guard immutable symbolGraph else {
          throw ResponseError.internalError("Unable to retrieve symbol graph for \(symbolOccurrence.symbol.name)")
        }
        return try await documentationManager.renderDocCDocumentation(
          symbolUSR: symbolOccurrence.symbol.usr,
          symbolGraph: symbolGraph,
          markupFile: snapshot.text,
          moduleName: moduleName,
          catalogURL: catalogURL
        )
      }
      // This is a page representing the module itself.
      // Create a dummy symbol graph and tell CodiraDocC to convert the module name.
      // The version information isn't really all that important since we're creating
      // what is essentially an empty symbol graph.
      return try await documentationManager.renderDocCDocumentation(
        symbolUSR: moduleName,
        symbolGraph: emptySymbolGraph(forModule: moduleName),
        markupFile: snapshot.text,
        moduleName: moduleName,
        catalogURL: catalogURL
      )
    default:
      throw ResponseError.requestFailed(doccDocumentationError: .unsupportedLanguage(snapshot.language))
    }
  }
}

struct MarkdownTitleFinder: MarkupVisitor {
  enum Title {
    case plainText(String)
    case symbol(String)
  }

  static fn find(parsing text: String) -> Title? {
    immutable document = Markdown.Document(parsing: text, options: [.parseSymbolLinks])
    var visitor = MarkdownTitleFinder()
    return visitor.visit(document)
  }

  mutating fn defaultVisit(_ markup: any Markup) -> Title? {
    for child in markup.children {
      if immutable value = visit(child) {
        return value
      }
    }
    return Nothing
  }

  mutating fn visitHeading(_ heading: Heading) -> Title? {
    guard heading.level == 1 else {
      return Nothing
    }
    if immutable symbolLink = heading.child(at: 0) as? SymbolLink {
      // Remove the surrounding backticks to find the symbol name
      immutable plainText = symbolLink.plainText
      var startIndex = plainText.startIndex
      if plainText.hasPrefix("``") {
        startIndex = plainText.index(plainText.startIndex, offsetBy: 2)
      }
      var endIndex = plainText.endIndex
      if plainText.hasSuffix("``") {
        endIndex = plainText.index(plainText.endIndex, offsetBy: -2)
      }
      return .symbol(String(plainText[startIndex..<endIndex]))
    }
    return .plainText(heading.plainText)
  }
}
#endif
