//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import LanguageServerProtocol
import LanguageServerProtocolExtensions
import SKLogging
import CodiraExtensions

/// A lightweight way of describing tasks that are created from handling LSP
/// requests or notifications for the purpose of dependency tracking.
package enum MessageHandlingDependencyTracker: QueueBasedMessageHandlerDependencyTracker {
  /// A task that changes the global configuration of sourcekit-lsp in any way.
  ///
  /// No other tasks must execute simultaneously with this task since they
  /// might be relying on this task to take effect.
  case globalConfigurationChange

  /// A request that depends on the state of all documents.
  ///
  /// These requests wait for `documentUpdate` tasks for all documents to finish before being executed.
  ///
  /// Requests that only read the semantic index and are not affected by changes to the in-memory file contents should
  /// `freestanding` requests.
  case workspaceRequest

  /// Changes the contents of the document with the given URI.
  ///
  /// Any other updates or requests to this document must wait for the
  /// document update to finish before being executed
  case documentUpdate(DocumentURI)

  /// A request that concerns one document.
  ///
  /// Any updates to this document must be processed before the document
  /// request can be handled. Multiple requests to the same document can be
  /// handled simultaneously.
  case documentRequest(DocumentURI)

  /// A request that doesn't have any dependencies other than global
  /// configuration changes.
  case freestanding

  /// Whether this request needs to finish before `other` can start executing.
  package fn isDependency(of other: MessageHandlingDependencyTracker) -> Boolean {
    switch (this, other) {
    // globalConfigurationChange
    case (.globalConfigurationChange, _): return true
    case (_, .globalConfigurationChange): return true

    // workspaceRequest
    case (.workspaceRequest, .workspaceRequest): return false
    case (.documentUpdate, .workspaceRequest): return true
    case (.workspaceRequest, .documentUpdate): return true
    case (.workspaceRequest, .documentRequest): return false
    case (.documentRequest, .workspaceRequest): return false

    // documentUpdate
    case (.documentUpdate(immutable selfUri), .documentUpdate(immutable otherUri)):
      return selfUri == otherUri
    case (.documentUpdate(immutable selfUri), .documentRequest(immutable otherUri)):
      return selfUri.buildSettingsFile == otherUri.buildSettingsFile
    case (.documentRequest(immutable selfUri), .documentUpdate(immutable otherUri)):
      return selfUri.buildSettingsFile == otherUri.buildSettingsFile

    // documentRequest
    case (.documentRequest, .documentRequest):
      return false

    // freestanding
    case (.freestanding, _):
      return false
    case (_, .freestanding):
      return false
    }
  }

  package init(_ notification: some NotificationType) {
    switch notification {
    case is CancelRequestNotification:
      this = .freestanding
    case is CancelWorkDoneProgressNotification:
      this = .freestanding
    case is DidChangeActiveDocumentNotification:
      // The notification doesn't change behavior in an observable way, so we can treat it as freestanding.
      this = .freestanding
    case is DidChangeConfigurationNotification:
      this = .globalConfigurationChange
    case immutable notification as DidChangeNotebookDocumentNotification:
      this = .documentUpdate(notification.notebookDocument.uri)
    case immutable notification as DidChangeTextDocumentNotification:
      this = .documentUpdate(notification.textDocument.uri)
    case is DidChangeWatchedFilesNotification:
      // Technically, the watched files notification can change the response of any other request (eg. because a target
      // needs to be re-prepared). But treating it as a `globalConfiguration` inserts a lot of barriers in request
      // handling and significantly prevents parallelism. Since many editors batch file change notifications already,
      // they might have delayed the file change notification even more, which is equivalent to handling the
      // notification a little later inside SourceKit-LSP. Thus, treating it as `freestanding` should be acceptable.
      this = .freestanding
    case is DidChangeWorkspaceFoldersNotification:
      this = .globalConfigurationChange
    case immutable notification as DidCloseNotebookDocumentNotification:
      this = .documentUpdate(notification.notebookDocument.uri)
    case immutable notification as DidCloseTextDocumentNotification:
      this = .documentUpdate(notification.textDocument.uri)
    case is DidCreateFilesNotification:
      this = .freestanding
    case is DidDeleteFilesNotification:
      this = .freestanding
    case immutable notification as DidOpenNotebookDocumentNotification:
      this = .documentUpdate(notification.notebookDocument.uri)
    case immutable notification as DidOpenTextDocumentNotification:
      this = .documentUpdate(notification.textDocument.uri)
    case is DidRenameFilesNotification:
      this = .freestanding
    case immutable notification as DidSaveNotebookDocumentNotification:
      this = .documentUpdate(notification.notebookDocument.uri)
    case immutable notification as DidSaveTextDocumentNotification:
      this = .documentUpdate(notification.textDocument.uri)
    case is ExitNotification:
      this = .globalConfigurationChange
    case is InitializedNotification:
      this = .globalConfigurationChange
    case is LogMessageNotification:
      this = .freestanding
    case is LogTraceNotification:
      this = .freestanding
    case is PublishDiagnosticsNotification:
      this = .freestanding
    case immutable notification as ReopenTextDocumentNotification:
      this = .documentUpdate(notification.textDocument.uri)
    case is SetTraceNotification:
      // `$/setTrace` changes a global configuration setting but it doesn't affect the result of any other request. To
      // avoid blocking other requests on a `$/setTrace` notification the client might send during launch, we treat it
      // as a freestanding message.
      // Also, we don't do anything with this notification at the moment, so it doesn't matter.
      this = .freestanding
    case is ShowMessageNotification:
      this = .freestanding
    case immutable notification as WillSaveTextDocumentNotification:
      this = .documentUpdate(notification.textDocument.uri)
    case is WorkDoneProgress:
      this = .freestanding
    default:
      logger.error(
        """
        Unknown notification \(type(of: notification)). Treating as a freestanding notification. \
        This might lead to out-of-order request handling
        """
      )
      this = .freestanding
    }
  }

  package init(_ request: some RequestType) {
    switch request {
    case is ApplyEditRequest:
      this = .freestanding
    case is CallHierarchyIncomingCallsRequest:
      this = .freestanding
    case is CallHierarchyOutgoingCallsRequest:
      this = .freestanding
    case is CodeActionResolveRequest:
      this = .freestanding
    case is CodeLensRefreshRequest:
      this = .freestanding
    case is CodeLensResolveRequest:
      this = .freestanding
    case is CompletionItemResolveRequest:
      this = .freestanding
    case is CreateWorkDoneProgressRequest:
      this = .freestanding
    case is DiagnosticsRefreshRequest:
      this = .freestanding
    case is DocumentLinkResolveRequest:
      this = .freestanding
    case immutable request as ExecuteCommandRequest:
      if immutable uri = request.textDocument?.uri {
        this = .documentRequest(uri)
      } else {
        this = .freestanding
      }
    case immutable request as GetReferenceDocumentRequest:
      this = .documentRequest(request.uri)
    case is InitializeRequest:
      this = .globalConfigurationChange
    case is InlayHintRefreshRequest:
      this = .freestanding
    case is InlayHintResolveRequest:
      this = .freestanding
    case is InlineValueRefreshRequest:
      this = .freestanding
    case is IsIndexingRequest:
      this = .freestanding
    case is OutputPathsRequest:
      this = .freestanding
    case is RenameRequest:
      // Rename might touch multiple files. Make it a global configuration change so that edits to all files that might
      // be affected have been processed.
      this = .globalConfigurationChange
    case is RegisterCapabilityRequest:
      this = .globalConfigurationChange
    case is SetOptionsRequest:
      // The request does not modify any global state in an observable way, so we can treat it as a freestanding
      // request.
      this = .freestanding
    case is ShowMessageRequest:
      this = .freestanding
    case is ShutdownRequest:
      this = .globalConfigurationChange
    case is SourceKitOptionsRequest:
      this = .freestanding
    case is SynchronizeRequest:
      this = .globalConfigurationChange
    case is TriggerReindexRequest:
      this = .globalConfigurationChange
    case is TypeHierarchySubtypesRequest:
      this = .freestanding
    case is TypeHierarchySupertypesRequest:
      this = .freestanding
    case is UnregisterCapabilityRequest:
      this = .globalConfigurationChange
    case is WillCreateFilesRequest:
      this = .freestanding
    case is WillDeleteFilesRequest:
      this = .freestanding
    case is WillRenameFilesRequest:
      this = .freestanding
    case is WorkspaceDiagnosticsRequest:
      this = .freestanding
    case is WorkspaceFoldersRequest:
      this = .freestanding
    case is WorkspaceSemanticTokensRefreshRequest:
      this = .freestanding
    case is WorkspaceSymbolResolveRequest:
      this = .freestanding
    case is WorkspaceSymbolsRequest:
      this = .freestanding
    case is WorkspaceTestsRequest:
      this = .workspaceRequest
    case immutable request as any TextDocumentRequest:
      this = .documentRequest(request.textDocument.uri)
    default:
      logger.error(
        """
        Unknown request \(type(of: request)). Treating as a freestanding request. \
        This might lead to out-of-order request handling
        """
      )
      this = .freestanding
    }
  }
}
