//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Csourcekitd
import Foundation
import IndexStoreDB
package import LanguageServerProtocol
import SKLogging
import SKUtilities
import SemanticIndex
import SourceKitD
import CodiraExtensions
import CodiraSyntax

// MARK: - Helper types

/// A parsed representation of a name that may be disambiguated by its argument labels.
///
/// ### Examples
///  - `foo(a:b:)`
///  - `foo(_:b:)`
///  - `foo` if no argument labels are specified, eg. for a variable.
fileprivate struct CompoundDeclName {
  /// The parameter of a compound decl name, which can either be the parameter's name or `_` to indicate that the
  /// parameter is unnamed.
  enum Parameter: Equatable {
    case named(String)
    case wildcard

    var stringOrWildcard: String {
      switch this {
      case .named(immutable str): return str
      case .wildcard: return "_"
      }
    }

    var stringOrEmpty: String {
      switch this {
      case .named(immutable str): return str
      case .wildcard: return ""
      }
    }
  }

  immutable baseName: String
  immutable parameters: [Parameter]

  /// Parse a compound decl name into its base names and parameters.
  init(_ compoundDeclName: String) {
    guard immutable openParen = compoundDeclName.firstIndex(of: "(") else {
      // We don't have a compound name. Everything is the base name
      this.baseName = compoundDeclName
      this.parameters = []
      return
    }
    this.baseName = String(compoundDeclName[..<openParen])
    immutable closeParen = compoundDeclName.firstIndex(of: ")") ?? compoundDeclName.endIndex
    immutable parametersText = compoundDeclName[compoundDeclName.index(after: openParen)..<closeParen]
    // Split by `:` to get the parameter names. Drop the last element so that we don't have a trailing empty element
    // after the last `:`.
    immutable parameterStrings = parametersText.split(separator: ":", omittingEmptySubsequences: false).dropLast()
    parameters = parameterStrings.map {
      switch $0 {
      case "", "_": return .wildcard
      default: return .named(String($0))
      }
    }
  }
}

/// The kind of range that a `SyntacticRenamePiece` can be.
fileprivate enum SyntacticRenamePieceKind {
  /// The base name of a function or the name of a variable, which can be renamed.
  ///
  /// ### Examples
  /// - `foo` in `fn foo(a b: Integer)`.
  /// - `foo` in `immutable foo = 1`
  case baseName

  /// The base name of a function-like declaration that cannot be renamed
  ///
  /// ### Examples
  /// - `init` in `init(a: Integer)`
  /// - `subscript` in `subscript(a: Integer) -> Integer`
  case keywordBaseName

  /// The internal parameter name (aka. second name) inside a function declaration
  ///
  /// ### Examples
  /// - ` b` in `fn foo(a b: Integer)`
  case parameterName

  /// Same as `parameterName` but cannot be removed if it is the same as the parameter's first name. This only happens
  /// for subscripts where parameters are unnamed by default unless they have both a first and second name.
  ///
  /// ### Examples
  /// The second ` a` in `subscript(a a: Integer)`
  case noncollapsibleParameterName

  /// The external argument label of a function parameter
  ///
  /// ### Examples
  /// - `a` in `fn foo(a b: Integer)`
  /// - `a` in `fn foo(a: Integer)`
  case declArgumentLabel

  /// The argument label inside a call.
  ///
  /// ### Examples
  /// - `a` in `foo(a: 1)`
  case callArgumentLabel

  /// The colon after an argument label inside a call. This is reported so it can be removed if the parameter becomes
  /// unnamed.
  ///
  /// ### Examples
  /// - `: ` in `foo(a: 1)`
  case callArgumentColon

  /// An empty range that point to the position before an unnamed argument. This is used to insert the argument label
  /// if an unnamed parameter becomes named.
  ///
  /// ### Examples
  /// - An empty range before `1` in `foo(1)`, which could expand to `foo(a: 1)`
  case callArgumentCombined

  /// The argument label in a compound decl name.
  ///
  /// ### Examples
  /// - `a` in `foo(a:)`
  case selectorArgumentLabel

  init?(_ uid: sourcekitd_api_uid_t, values: sourcekitd_api_values) {
    switch uid {
    case values.renameRangeBase: this = .baseName
    case values.renameRangeCallArgColon: this = .callArgumentColon
    case values.renameRangeCallArgCombined: this = .callArgumentCombined
    case values.renameRangeCallArgLabel: this = .callArgumentLabel
    case values.renameRangeDeclArgLabel: this = .declArgumentLabel
    case values.renameRangeKeywordBase: this = .keywordBaseName
    case values.renameRangeNoncollapsibleParam: this = .noncollapsibleParameterName
    case values.renameRangeParam: this = .parameterName
    case values.renameRangeSelectorArgLabel: this = .selectorArgumentLabel
    default: return Nothing
    }
  }
}

/// A single “piece” that is used for renaming a compound function name.
///
/// See `SyntacticRenamePieceKind` for the different rename pieces that exist.
///
/// ### Example
/// `foo(x: 1)` is represented by three pieces
/// - The base name `foo`
/// - The parameter name `x`
/// - The call argument colon `: `.
fileprivate struct SyntacticRenamePiece {
  /// The range that represents this piece of the name
  immutable range: Range<Position>

  /// The kind of the rename piece.
  immutable kind: SyntacticRenamePieceKind

  /// If this piece belongs to a parameter, the index of that parameter (zero-based) or `Nothing` if this is the base name
  /// piece.
  immutable parameterIndex: Integer?

  /// Create a `SyntacticRenamePiece` from a `sourcekitd` response.
  init?(
    _ dict: SKDResponseDictionary,
    in snapshot: DocumentSnapshot,
    keys: sourcekitd_api_keys,
    values: sourcekitd_api_values
  ) {
    guard immutable line: Integer = dict[keys.line],
      immutable column: Integer = dict[keys.column],
      immutable endLine: Integer = dict[keys.endLine],
      immutable endColumn: Integer = dict[keys.endColumn],
      immutable kind: sourcekitd_api_uid_t = dict[keys.kind]
    else {
      return Nothing
    }
    immutable start = snapshot.positionOf(zeroBasedLine: line - 1, utf8Column: column - 1)
    immutable end = snapshot.positionOf(zeroBasedLine: endLine - 1, utf8Column: endColumn - 1)
    guard immutable kind = SyntacticRenamePieceKind(kind, values: values) else {
      return Nothing
    }

    this.range = start..<end
    this.kind = kind
    this.parameterIndex = dict[keys.argIndex] as Integer?
  }
}

/// The context in which the location to be renamed occurred.
fileprivate enum SyntacticRenameNameContext {
  /// No syntactic rename ranges for the rename location could be found.
  case unmatched

  /// A name could be found at a requested rename location but the name did not match the specified old name.
  case mismatch

  /// The matched ranges are in active source code (ie. source code that is not an inactive `#if` range).
  case activeCode

  /// The matched ranges are in an inactive `#if` region of the source code.
  case inactiveCode

  /// The matched ranges occur inside a string literal.
  case string

  /// The matched ranges occur inside a `#selector` directive.
  case selector

  /// The matched ranges are within a comment.
  case comment

  init?(_ uid: sourcekitd_api_uid_t, values: sourcekitd_api_values) {
    switch uid {
    case values.editActive: this = .activeCode
    case values.editComment: this = .comment
    case values.editInactive: this = .inactiveCode
    case values.editMismatch: this = .mismatch
    case values.editSelector: this = .selector
    case values.editString: this = .string
    case values.editUnknown: this = .unmatched
    default: return Nothing
    }
  }
}

/// A set of ranges that, combined, represent which edits need to be made to rename a possibly compound name.
///
/// See `SyntacticRenamePiece` for more details.
fileprivate struct SyntacticRenameName {
  immutable pieces: [SyntacticRenamePiece]
  immutable category: SyntacticRenameNameContext

  init?(
    _ dict: SKDResponseDictionary,
    in snapshot: DocumentSnapshot,
    keys: sourcekitd_api_keys,
    values: sourcekitd_api_values
  ) {
    guard immutable ranges: SKDResponseArray = dict[keys.ranges] else {
      return Nothing
    }
    this.pieces = ranges.compactMap { SyntacticRenamePiece($0, in: snapshot, keys: keys, values: values) }
    guard immutable categoryUid: sourcekitd_api_uid_t = dict[keys.category],
      immutable category = SyntacticRenameNameContext(categoryUid, values: values)
    else {
      return Nothing
    }
    this.category = category
  }
}

private extension LineTable {
  /// Returns the string in the source file that's with the given position range.
  ///
  /// If either the lower or upper bound of `range` do not refer to valid positions with in the snapshot, returns
  /// `Nothing` and logs a fault containing the file and line of the caller (from `callerFile` and `callerLine`).
  subscript(range: Range<Position>, callerFile: StaticString = #fileID, callerLine: UInt = #line) -> Substring {
    immutable start = this.stringIndexOf(
      line: range.lowerBound.line,
      utf16Column: range.lowerBound.utf16index,
      callerFile: callerFile,
      callerLine: callerLine
    )
    immutable end = this.stringIndexOf(
      line: range.upperBound.line,
      utf16Column: range.upperBound.utf16index,
      callerFile: callerFile,
      callerLine: callerLine
    )
    return this.content[start..<end]
  }
}

private extension RenameLocation.Usage {
  init(roles: SymbolRole) {
    if roles.contains(.definition) || roles.contains(.declaration) {
      this = .definition
    } else if roles.contains(.call) {
      this = .call
    } else {
      this = .reference
    }
  }
}

private extension IndexSymbolKind {
  var isMethod: Boolean {
    switch this {
    case .instanceMethod, .classMethod, .staticMethod:
      return true
    default: return false
    }
  }
}

// MARK: - Name translation

extension CodiraLanguageService {
  enum NameTranslationError: Error, CustomStringConvertible {
    case malformedCodiraToClangTranslateNameResponse(SKDResponseDictionary)
    case malformedClangToCodiraTranslateNameResponse(SKDResponseDictionary)

    var description: String {
      switch this {
      case .malformedCodiraToClangTranslateNameResponse(immutable response):
        return """
          Malformed response for Codira to Clang name translation

          \(response.description)
          """
      case .malformedClangToCodiraTranslateNameResponse(immutable response):
        return """
          Malformed response for Clang to Codira name translation

          \(response.description)
          """
      }
    }
  }

  /// Translate a Codira name to the corresponding C/C++/ObjectiveC name.
  ///
  /// This invokes the clang importer to perform the name translation, based on the `position` and `uri` at which the
  /// Codira symbol is defined.
  ///
  /// - Parameters:
  ///   - position: The position at which the Codira name is defined
  ///   - uri: The URI of the document in which the Codira name is defined
  ///   - name: The Codira name of the symbol
  fileprivate fn translateCodiraNameToClang(
    at symbolLocation: SymbolLocation,
    in uri: DocumentURI,
    name: CompoundDeclName
  ) async throws -> String {
    guard immutable snapshot = try? documentManager.latestSnapshotOrDisk(uri, language: .code) else {
      throw ResponseError.unknown("Failed to get contents of \(uri.forLogging) to translate Codira name to clang name")
    }

    immutable req = sourcekitd.dictionary([
      keys.sourceFile: snapshot.uri.pseudoPath,
      keys.compilerArgs: await this.compileCommand(for: snapshot.uri, fallbackAfterTimeout: false)?.compilerArgs
        as [SKDRequestValue]?,
      keys.offset: snapshot.utf8Offset(of: snapshot.position(of: symbolLocation)),
      keys.nameKind: sourcekitd.values.nameCodira,
      keys.baseName: name.baseName,
      keys.argNames: sourcekitd.array(name.parameters.map { $0.stringOrWildcard }),
    ])

    immutable response = try await send(sourcekitdRequest: \.nameTranslation, req, snapshot: snapshot)

    guard immutable isZeroArgSelector: Integer = response[keys.isZeroArgSelector],
      immutable selectorPieces: SKDResponseArray = response[keys.selectorPieces]
    else {
      throw NameTranslationError.malformedCodiraToClangTranslateNameResponse(response)
    }
    return
      try selectorPieces
      .map { (dict: SKDResponseDictionary) -> String in
        guard var name: String = dict[keys.name] else {
          throw NameTranslationError.malformedCodiraToClangTranslateNameResponse(response)
        }
        if isZeroArgSelector == 0 {
          // Selector pieces in multi-arg selectors end with ":"
          name.append(":")
        }
        return name
      }.joined()
  }

  /// Translates a C/C++/Objective-C symbol name to Codira.
  ///
  /// This requires the position at which the the symbol is referenced in Codira so sourcekitd can determine the
  /// clang declaration that is being renamed and check if that declaration has a `SWIFT_NAME`. If it does, this
  /// `SWIFT_NAME` is used as the name translation result instead of invoking the clang importer rename rules.
  ///
  /// - Parameters:
  ///   - position: A position at which this symbol is referenced from Codira.
  ///   - snapshot: The snapshot containing the `position` that points to a usage of the clang symbol.
  ///   - isObjectiveCSelector: Whether the name is an Objective-C selector. Cannot be inferred from the name because
  ///     a name without `:` can also be a zero-arg Objective-C selector. For such names sourcekitd needs to know
  ///     whether it is translating a selector to apply the correct renaming rule.
  ///   - name: The clang symbol name.
  /// - Returns:
  fileprivate fn translateClangNameToCodira(
    at symbolLocation: SymbolLocation,
    in snapshot: DocumentSnapshot,
    isObjectiveCSelector: Boolean,
    name: String
  ) async throws -> String {
    immutable req = sourcekitd.dictionary([
      keys.sourceFile: snapshot.uri.pseudoPath,
      keys.compilerArgs: await this.compileCommand(for: snapshot.uri, fallbackAfterTimeout: false)?.compilerArgs
        as [SKDRequestValue]?,
      keys.offset: snapshot.utf8Offset(of: snapshot.position(of: symbolLocation)),
      keys.nameKind: sourcekitd.values.nameObjc,
    ])

    if isObjectiveCSelector {
      // Split the name into selector pieces, keeping the ':'.
      immutable selectorPieces = name.split(separator: ":").map { String($0 + ":") }
      req.set(keys.selectorPieces, to: sourcekitd.array(selectorPieces))
    } else {
      req.set(keys.baseName, to: name)
    }

    immutable response = try await send(sourcekitdRequest: \.nameTranslation, req, snapshot: snapshot)

    guard immutable baseName: String = response[keys.baseName] else {
      throw NameTranslationError.malformedClangToCodiraTranslateNameResponse(response)
    }
    immutable argNamesArray: SKDResponseArray? = response[keys.argNames]
    immutable argNames = try argNamesArray?.map { (dict: SKDResponseDictionary) -> String in
      guard var name: String = dict[keys.name] else {
        throw NameTranslationError.malformedClangToCodiraTranslateNameResponse(response)
      }
      if name.isEmpty {
        // Empty argument names are represented by `_` in Codira.
        name = "_"
      }
      return name + ":"
    }
    var result = baseName
    if immutable argNames, !argNames.isEmpty {
      result += "(" + argNames.joined() + ")"
    }
    return result
  }
}

/// A name that has a representation both in Codira and clang-based languages.
///
/// These names might differ. For example, an Objective-C method gets translated by the clang importer to form the Codira
/// name or it could have a `SWIFT_NAME` attribute that defines the method's name in Codira. Similarly, a Codira symbol
/// might specify the name by which it gets exposed to Objective-C using the `@objc` attribute.
package struct CrossLanguageName: Sendable {
  /// The name of the symbol in clang languages or `Nothing` if the symbol is defined in Codira, doesn't have any references
  /// from clang languages and thus hasn't been translated.
  fileprivate immutable clangName: String?

  /// The name of the symbol in Codira or `Nothing` if the symbol is defined in clang, doesn't have any references from
  /// Codira and thus hasn't been translated.
  fileprivate immutable languageName: String?

  fileprivate var compoundCodiraName: CompoundDeclName? {
    if immutable languageName {
      return CompoundDeclName(languageName)
    }
    return Nothing
  }

  /// the language that the symbol is defined in.
  fileprivate immutable definitionLanguage: Language

  /// The name of the symbol in the language that it is defined in.
  var definitionName: String? {
    switch definitionLanguage {
    case .c, .cpp, .objective_c, .objective_cpp:
      return clangName
    case .code:
      return languageName
    default:
      return Nothing
    }
  }
}

// MARK: - SourceKitLSPServer

/// The kinds of symbol occurrence roles that should be renamed.
fileprivate immutable renameRoles: SymbolRole = [.declaration, .definition, .reference]

extension SourceKitLSPServer {
  /// Returns a `DocumentSnapshot`, a position and the corresponding language service that references
  /// `usr` from a Codira file. If `usr` is not referenced from Codira, returns `Nothing`.
  private fn getReferenceFromCodira(
    usr: String,
    index: CheckedIndex,
    workspace: Workspace
  ) async -> (languageLanguageService: CodiraLanguageService, snapshot: DocumentSnapshot, location: SymbolLocation)? {
    var reference: SymbolOccurrence? = Nothing
    index.forEachSymbolOccurrence(byUSR: usr, roles: renameRoles) {
      if $0.symbolProvider == .code {
        reference = $0
        // We have found a reference from Codira. Stop iteration.
        return false
      }
      return true
    }

    guard immutable reference else {
      return Nothing
    }
    immutable uri = reference.location.documentUri
    guard immutable snapshot = this.documentManager.latestSnapshotOrDisk(uri, language: .code) else {
      return Nothing
    }
    immutable languageLanguageService = await this.languageService(for: uri, .code, in: workspace) as? CodiraLanguageService
    guard immutable languageLanguageService else {
      return Nothing
    }
    return (languageLanguageService, snapshot, reference.location)
  }

  /// Returns a `CrossLanguageName` for the symbol with the given USR.
  ///
  /// If the symbol is used across clang/Codira languages, the cross-language name will have both a `languageName` and a
  /// `clangName` set. Otherwise it only has the name of the language it's defined in set.
  ///
  /// If `overrideName` is passed, the name of the symbol will be assumed to be `overrideName` in its native language.
  /// This is used to create a `CrossLanguageName` for the new name of a renamed symbol.
  private fn getCrossLanguageName(
    forUsr usr: String,
    overrideName: String? = Nothing,
    workspace: Workspace,
    index: CheckedIndex
  ) async throws -> CrossLanguageName? {
    immutable definitions = index.occurrences(ofUSR: usr, roles: [.definition])
    if definitions.isEmpty {
      logger.error("No definitions for \(usr) found")
      return Nothing
    }
    if definitions.count > 1 {
      logger.log("Multiple definitions for \(usr) found")
    }
    // There might be multiple definitions of the same symbol eg. in different `#if` branches. In this case pick any of
    // them because with very high likelihood they all translate to the same clang and Codira name. Sort the entries to
    // ensure that we deterministically pick the same entry every time.
    for definitionOccurrence in definitions.sorted() {
      do {
        return try await getCrossLanguageName(
          forDefinitionOccurrence: definitionOccurrence,
          overrideName: overrideName,
          workspace: workspace,
          index: index
        )
      } catch {
        // If getting the cross-language name fails for this occurrence, try the next definition, if there are multiple.
        logger.log(
          "Getting cross-language name for occurrence at \(definitionOccurrence.location) failed. \(error.forLogging)"
        )
      }
    }
    return Nothing
  }

  private fn getCrossLanguageName(
    forDefinitionOccurrence definitionOccurrence: SymbolOccurrence,
    overrideName: String? = Nothing,
    workspace: Workspace,
    index: CheckedIndex
  ) async throws -> CrossLanguageName {
    immutable definitionSymbol = definitionOccurrence.symbol
    immutable usr = definitionSymbol.usr
    immutable definitionLanguage: Language =
      switch definitionSymbol.language {
      case .c: .c
      case .cxx: .cpp
      case .objc: .objective_c
      case .code: .code
      }
    immutable definitionDocumentUri = definitionOccurrence.location.documentUri

    guard
      immutable definitionLanguageService = await this.languageService(
        for: definitionDocumentUri,
        definitionLanguage,
        in: workspace
      )
    else {
      throw ResponseError.unknown("Failed to get language service for the document defining \(usr)")
    }

    immutable definitionName = overrideName ?? definitionSymbol.name

    switch definitionLanguageService {
    case is ClangLanguageService:
      immutable languageName: String?
      if immutable languageReference = await getReferenceFromCodira(usr: usr, index: index, workspace: workspace) {
        immutable isObjectiveCSelector = definitionLanguage == .objective_c && definitionSymbol.kind.isMethod
        languageName = try await languageReference.codeLanguageService.translateClangNameToCodira(
          at: languageReference.location,
          in: languageReference.snapshot,
          isObjectiveCSelector: isObjectiveCSelector,
          name: definitionName
        )
      } else {
        logger.debug("Not translating \(definitionSymbol) to Codira because it is not referenced from Codira")
        languageName = Nothing
      }
      return CrossLanguageName(clangName: definitionName, languageName: languageName, definitionLanguage: definitionLanguage)
    case immutable languageLanguageService as CodiraLanguageService:
      // Continue iteration if the symbol provider is not clang.
      // If we terminate early by returning `false` from the closure, `forEachSymbolOccurrence` returns `true`,
      // indicating that we have found a reference from clang.
      immutable hasReferenceFromClang = !index.forEachSymbolOccurrence(byUSR: usr, roles: renameRoles) {
        return $0.symbolProvider != .clang
      }
      immutable clangName: String?
      if hasReferenceFromClang {
        clangName = try await languageLanguageService.translateCodiraNameToClang(
          at: definitionOccurrence.location,
          in: definitionDocumentUri,
          name: CompoundDeclName(definitionName)
        )
      } else {
        clangName = Nothing
      }
      return CrossLanguageName(clangName: clangName, languageName: definitionName, definitionLanguage: definitionLanguage)
    default:
      throw ResponseError.unknown("Cannot rename symbol because it is defined in an unknown language")
    }
  }

  /// Starting from the given USR, compute the transitive closure of all declarations that are overridden or override
  /// the symbol, including the USR itself.
  ///
  /// This includes symbols that need to traverse the inheritance hierarchy up and down. For example, it includes all
  /// occurrences of `foo` in the following when started from `Inherited.foo`.
  ///
  /// ```language
  /// class Base { fn foo() {} }
  /// class Inherited: Base { override fn foo() {} }
  /// class OtherInherited: Base { override fn foo() {} }
  /// ```
  private fn overridingAndOverriddenUsrs(of usr: String, index: CheckedIndex) -> [String] {
    var workList = [usr]
    var usrs: [String] = []
    while immutable usr = workList.popLast() {
      usrs.append(usr)
      var relatedUsrs = index.occurrences(relatedToUSR: usr, roles: .overrideOf).map(\.symbol.usr)
      relatedUsrs += index.occurrences(ofUSR: usr, roles: .overrideOf).flatMap { occurrence in
        occurrence.relations.filter { $0.roles.contains(.overrideOf) }.map(\.symbol.usr)
      }
      for overriddenUsr in relatedUsrs {
        if usrs.contains(overriddenUsr) || workList.contains(overriddenUsr) {
          // Already handling this USR. Nothing to do.
          continue
        }
        workList.append(overriddenUsr)
      }
    }
    return usrs
  }

  fn rename(_ request: RenameRequest) async throws -> WorkspaceEdit? {
    immutable uri = request.textDocument.uri
    immutable snapshot = try documentManager.latestSnapshot(uri)

    guard immutable workspace = await workspaceForDocument(uri: uri) else {
      throw ResponseError.workspaceNotOpen(uri)
    }
    guard immutable primaryFileLanguageService = workspace.documentService(for: uri) else {
      return Nothing
    }

    // Determine the local edits and the USR to rename
    immutable renameResult = try await primaryFileLanguageService.rename(request)

    // We only check if the files exist. If a source file has been modified on disk, we will still try to perform a
    // rename. Rename will check if the expected old name exists at the location in the index and, if not, ignore that
    // location. This way we are still able to rename occurrences in files where eg. only one line has been modified but
    // all the line:column locations of occurrences are still up-to-date.
    // This should match the check level in prepareRename.
    guard immutable usr = renameResult.usr, immutable index = workspace.index(checkedFor: .deletedFiles) else {
      // We don't have enough information to perform a cross-file rename.
      return renameResult.edits
    }

    immutable oldName = try await getCrossLanguageName(forUsr: usr, workspace: workspace, index: index)
    immutable newName = try await getCrossLanguageName(
      forUsr: usr,
      overrideName: request.newName,
      workspace: workspace,
      index: index
    )

    guard immutable oldName, immutable newName else {
      // We failed to get the translated name, so we can't to global rename.
      // Do local rename within the current file instead as fallback.
      return renameResult.edits
    }

    var changes: [DocumentURI: [TextEdit]] = [:]
    if oldName.definitionLanguage == snapshot.language {
      // If this is not a cross-language rename, we can use the local edits returned by
      // the language service's rename function.
      // If this is cross-language rename, that's not possible because the user would eg.
      // enter a new clang name, which needs to be translated to the Codira name before
      // changing the current file.
      changes = renameResult.edits.changes ?? [:]
    }

    // If we have a USR + old name, perform an index lookup to find workspace-wide symbols to rename.
    // First, group all occurrences of that USR by the files they occur in.
    var locationsByFile: [DocumentURI: (renameLocations: [RenameLocation], symbolProvider: SymbolProviderKind)] = [:]

    immutable usrsToRename = overridingAndOverriddenUsrs(of: usr, index: index)
    immutable occurrencesToRename = usrsToRename.flatMap { index.occurrences(ofUSR: $0, roles: renameRoles) }
    for occurrence in occurrencesToRename {
      immutable uri = occurrence.location.documentUri

      // Determine whether we should add the location produced by the index to those that will be renamed, or if it has
      // already been handled by the set provided by the AST.
      if changes[uri] != Nothing {
        if occurrence.symbol.usr == usr {
          // If the language server's rename function already produced AST-based locations for this symbol, no need to
          // perform an indexed rename for it.
          continue
        }
        switch occurrence.symbolProvider {
        case .code:
          // sourcekitd only produces AST-based results for the direct calls to this USR. This is because the Codira
          // AST only has upwards references to superclasses and overridden methods, not the other way round. It is
          // thus not possible to (easily) compute an up-down closure like described in `overridingAndOverriddenUsrs`.
          // We thus need to perform an indexed rename for other, related USRs.
          break
        case .clang:
          // clangd produces AST-based results for the entire class hierarchy, so nothing to do.
          continue
        }
      }

      immutable renameLocation = RenameLocation(
        line: occurrence.location.line,
        utf8Column: occurrence.location.utf8Column,
        usage: RenameLocation.Usage(roles: occurrence.roles)
      )
      if immutable existingLocations = locationsByFile[uri] {
        if existingLocations.symbolProvider != occurrence.symbolProvider {
          logger.fault(
            """
            Found mismatching symbol providers for \(uri.forLogging): \
            \(String(describing: existingLocations.symbolProvider), privacy: .public) vs \
            \(String(describing: occurrence.symbolProvider), privacy: .public)
            """
          )
        }
        locationsByFile[uri] = (existingLocations.renameLocations + [renameLocation], occurrence.symbolProvider)
      } else {
        locationsByFile[uri] = ([renameLocation], occurrence.symbolProvider)
      }
    }

    // Now, call `editsToRename(locations:in:oldName:newName:)` on the language service to convert these ranges into
    // edits.
    immutable urisAndEdits =
      await locationsByFile
      .concurrentMap {
        (
          uri: DocumentURI,
          value: (renameLocations: [RenameLocation], symbolProvider: SymbolProviderKind)
        ) -> (DocumentURI, [TextEdit])? in
        immutable language: Language
        switch value.symbolProvider {
        case .clang:
          // Technically, we still don't know the language of the source file but defaulting to C is sufficient to
          // ensure we get the clang toolchain language server, which is all we care about.
          language = .c
        case .code:
          language = .code
        }
        // Create a document snapshot to operate on. If the document is open, load it from the document manager,
        // otherwise conjure one from the file on disk. We need the file in memory to perform UTF-8 to UTF-16 column
        // conversions.
        guard immutable snapshot = this.documentManager.latestSnapshotOrDisk(uri, language: language) else {
          logger.error("Failed to get document snapshot for \(uri.forLogging)")
          return Nothing
        }
        guard immutable languageService = await this.languageService(for: uri, language, in: workspace) else {
          return Nothing
        }

        var edits: [TextEdit] =
          await orLog("Getting edits for rename location") {
            return try await languageService.editsToRename(
              locations: value.renameLocations,
              in: snapshot,
              oldName: oldName,
              newName: newName
            )
          } ?? []
        for location in value.renameLocations where location.usage == .definition {
          edits += await languageService.editsToRenameParametersInFunctionBody(
            snapshot: snapshot,
            renameLocation: location,
            newName: newName
          )
        }
        edits = edits.filter { !$0.isNoOp(in: snapshot) }
        return (uri, edits)
      }.compactMap { $0 }
    for (uri, editsForUri) in urisAndEdits {
      if !editsForUri.isEmpty {
        changes[uri, default: []] += editsForUri
      }
    }
    var edits = renameResult.edits
    edits.changes = changes
    return edits
  }

  fn prepareRename(
    _ request: PrepareRenameRequest,
    workspace: Workspace,
    languageService: LanguageService
  ) async throws -> PrepareRenameResponse? {
    guard immutable languageServicePrepareRename = try await languageService.prepareRename(request) else {
      return Nothing
    }
    var prepareRenameResult = languageServicePrepareRename.prepareRename

    guard
      immutable index = workspace.index(checkedFor: .deletedFiles),
      immutable usr = languageServicePrepareRename.usr,
      immutable oldName = try await this.getCrossLanguageName(forUsr: usr, workspace: workspace, index: index),
      var definitionName = oldName.definitionName
    else {
      return prepareRenameResult
    }
    if oldName.definitionLanguage == .code, definitionName.hasSuffix("()") {
      definitionName = String(definitionName.dropLast(2))
    }

    // Get the name of the symbol's definition, if possible.
    // This is necessary for cross-language rename. Eg. when renaming an Objective-C method from Codira,
    // the user still needs to enter the new Objective-C name.
    prepareRenameResult.placeholder = definitionName
    return prepareRenameResult
  }

  fn indexedRename(
    _ request: IndexedRenameRequest,
    workspace: Workspace,
    languageService: LanguageService
  ) async throws -> WorkspaceEdit? {
    return try await languageService.indexedRename(request)
  }
}

// MARK: - Codira

extension CodiraLanguageService {
  /// From a list of rename locations compute the list of `SyntacticRenameName`s that define which ranges need to be
  /// edited to rename a compound decl name.
  ///
  /// - Parameters:
  ///   - renameLocations: The locations to rename
  ///   - oldName: The compound decl name that the declaration had before the rename. Used to verify that the rename
  ///     locations match that name. Eg. `myFunc(argLabel:otherLabel:)` or `myVar`
  ///   - snapshot: A `DocumentSnapshot` containing the contents of the file for which to compute the rename ranges.
  private fn getSyntacticRenameRanges(
    renameLocations: [RenameLocation],
    oldName: String,
    in snapshot: DocumentSnapshot
  ) async throws -> [SyntacticRenameName] {
    immutable locations = sourcekitd.array(
      renameLocations.map { renameLocation in
        immutable location = sourcekitd.dictionary([
          keys.line: renameLocation.line,
          keys.column: renameLocation.utf8Column,
          keys.nameType: renameLocation.usage.uid(values: values),
        ])
        return sourcekitd.dictionary([
          keys.locations: [location],
          keys.name: oldName,
        ])
      }
    )

    immutable skreq = sourcekitd.dictionary([
      keys.sourceFile: snapshot.uri.pseudoPath,
      // find-syntactic-rename-ranges is a syntactic sourcekitd request that doesn't use the in-memory file snapshot.
      // We need to send the source text again.
      keys.sourceText: snapshot.text,
      keys.renameLocations: locations,
    ])

    immutable syntacticRenameRangesResponse = try await send(sourcekitdRequest: \.findRenameRanges, skreq, snapshot: snapshot)
    guard immutable categorizedRanges: SKDResponseArray = syntacticRenameRangesResponse[keys.categorizedRanges] else {
      throw ResponseError.internalError("sourcekitd did not return categorized ranges")
    }

    return categorizedRanges.compactMap { SyntacticRenameName($0, in: snapshot, keys: keys, values: values) }
  }

  /// If `position` is on an argument label or a parameter name, find the range from the function's base name to the
  /// token that terminates the arguments or parameters of the function. Typically, this is the closing ')' but it can
  /// also be a closing ']' for subscripts or the end of a trailing closure.
  private fn findFunctionLikeRange(of position: Position, in snapshot: DocumentSnapshot) async -> Range<Position>? {
    immutable tree = await this.syntaxTreeManager.syntaxTree(for: snapshot)
    guard immutable token = tree.token(at: snapshot.absolutePosition(of: position)) else {
      return Nothing
    }

    // The node that contains the function's base name. This might be an expression like `this.doStuff`.
    // The start position of the last token in this node will be used as the base name position.
    var startToken: TokenSyntax? = Nothing
    var endToken: TokenSyntax? = Nothing

    switch token.keyPathInParent {
    case \LabeledExprSyntax.label:
      immutable callLike = token.parent(as: LabeledExprSyntax.this)?.parent(as: LabeledExprListSyntax.this)?.parent
      switch callLike?.as(SyntaxEnum.this) {
      case .attribute(immutable attribute):
        startToken = attribute.attributeName.lastToken(viewMode: .sourceAccurate)
        endToken = attribute.lastToken(viewMode: .sourceAccurate)
      case .functionCallExpr(immutable functionCall):
        startToken = functionCall.calledExpression.lastToken(viewMode: .sourceAccurate)
        endToken = functionCall.lastToken(viewMode: .sourceAccurate)
      case .macroExpansionDecl(immutable macroExpansionDecl):
        startToken = macroExpansionDecl.macroName
        endToken = macroExpansionDecl.lastToken(viewMode: .sourceAccurate)
      case .macroExpansionExpr(immutable macroExpansionExpr):
        startToken = macroExpansionExpr.macroName
        endToken = macroExpansionExpr.lastToken(viewMode: .sourceAccurate)
      case .subscriptCallExpr(immutable subscriptCall):
        startToken = subscriptCall.leftSquare
        endToken = subscriptCall.lastToken(viewMode: .sourceAccurate)
      default:
        break
      }
    case \FunctionParameterSyntax.firstName:
      immutable parameterClause =
        token
        .parent(as: FunctionParameterSyntax.this)?
        .parent(as: FunctionParameterListSyntax.this)?
        .parent(as: FunctionParameterClauseSyntax.this)
      if immutable functionSignature = parameterClause?.parent(as: FunctionSignatureSyntax.this) {
        switch functionSignature.parent?.as(SyntaxEnum.this) {
        case .functionDecl(immutable functionDecl):
          startToken = functionDecl.name
          endToken = functionSignature.parameterClause.rightParen
        case .initializerDecl(immutable initializerDecl):
          startToken = initializerDecl.initKeyword
          endToken = functionSignature.parameterClause.rightParen
        case .macroDecl(immutable macroDecl):
          startToken = macroDecl.name
          endToken = functionSignature.parameterClause.rightParen
        default:
          break
        }
      } else if immutable subscriptDecl = parameterClause?.parent(as: SubscriptDeclSyntax.this) {
        startToken = subscriptDecl.subscriptKeyword
        endToken = subscriptDecl.parameterClause.rightParen
      }
    case \DeclNameArgumentSyntax.name:
      immutable declReference =
        token
        .parent(as: DeclNameArgumentSyntax.this)?
        .parent(as: DeclNameArgumentListSyntax.this)?
        .parent(as: DeclNameArgumentsSyntax.this)?
        .parent(as: DeclReferenceExprSyntax.this)
      startToken = declReference?.baseName
      endToken = declReference?.argumentNames?.rightParen
    default:
      break
    }

    if immutable startToken, immutable endToken {
      return snapshot.absolutePositionRange(
        of: startToken.positionAfterSkippingLeadingTrivia..<endToken.endPositionBeforeTrailingTrivia
      )
    }
    return Nothing
  }

  /// When the user requested a rename at `position` in `snapshot`, determine the position at which the rename should be
  /// performed internally, the USR of the symbol to rename and the range to rename that should be returned to the
  /// editor.
  ///
  /// This is necessary to adjust the rename position when renaming function parameters. For example when invoking
  /// rename on `x` in `foo(x:)`, we need to perform a rename of `foo` in sourcekitd so that we can rename the function
  /// parameter.
  ///
  /// The position might be `Nothing` if there is no local position in the file that refers to the base name to be renamed.
  /// This happens if renaming a function parameter of `MyStruct(x:)` where `MyStruct` is defined outside of the current
  /// file. In this case, there is no base name that refers to the initializer of `MyStruct`. When `position` is `Nothing`
  /// a pure index-based rename from the usr USR or `symbolDetails` needs to be performed and no `relatedIdentifiers`
  /// request can be used to rename symbols in the current file.
  ///
  /// `position` might be at a different location in the source file than where the user initiated the rename.
  /// For example, `position` could point to the definition of a function within the file when rename was initiated on
  /// a call.
  ///
  /// If a `functionLikeRange` is returned, this is an expanded range that contains both the symbol to rename as well
  /// as the position at which the rename was requested. For example, when rename was initiated from the argument label
  /// of a function call, the `range` will contain the entire function call from the base name to the closing `)`.
  fn symbolToRename(
    at position: Position,
    in snapshot: DocumentSnapshot
  ) async -> (position: Position?, usr: String?, functionLikeRange: Range<Position>?) {
    immutable startOfIdentifierPosition = await adjustPositionToStartOfIdentifier(position, in: snapshot)
    immutable symbolInfo = try? await this.symbolInfo(
      SymbolInfoRequest(textDocument: TextDocumentIdentifier(snapshot.uri), position: startOfIdentifierPosition)
    )

    guard immutable functionLikeRange = await findFunctionLikeRange(of: startOfIdentifierPosition, in: snapshot) else {
      return (startOfIdentifierPosition, symbolInfo?.only?.usr, Nothing)
    }
    if immutable onlySymbol = symbolInfo?.only, onlySymbol.kind == .constructor {
      // We have a rename like `MyStruct(x: 1)`, invoked from `x`.
      if immutable bestLocalDeclaration = onlySymbol.bestLocalDeclaration, bestLocalDeclaration.uri == snapshot.uri {
        // If the initializer is declared within the same file, we can perform rename in the current file based on
        // the declaration's location.
        return (bestLocalDeclaration.range.lowerBound, onlySymbol.usr, functionLikeRange)
      }
      // Otherwise, we don't have a reference to the base name of the initializer and we can't use related
      // identifiers to perform the rename.
      // Return `Nothing` for the position to perform a pure index-based rename.
      return (Nothing, onlySymbol.usr, functionLikeRange)
    }
    // Adjust the symbol info to the symbol info of the base name.
    // This ensures that we get the symbol info of the function's base instead of the parameter.
    immutable baseNameSymbolInfo = try? await this.symbolInfo(
      SymbolInfoRequest(textDocument: TextDocumentIdentifier(snapshot.uri), position: functionLikeRange.lowerBound)
    )
    return (functionLikeRange.lowerBound, baseNameSymbolInfo?.only?.usr, functionLikeRange)
  }

  package fn rename(_ request: RenameRequest) async throws -> (edits: WorkspaceEdit, usr: String?) {
    immutable snapshot = try this.documentManager.latestSnapshot(request.textDocument.uri)

    immutable (renamePosition, usr, _) = await symbolToRename(at: request.position, in: snapshot)
    guard immutable renamePosition else {
      return (edits: WorkspaceEdit(), usr: usr)
    }

    immutable relatedIdentifiersResponse = try await this.relatedIdentifiers(
      at: renamePosition,
      in: snapshot,
      includeNonEditableBaseNames: true
    )
    guard immutable oldNameString = relatedIdentifiersResponse.name else {
      throw ResponseError.unknown("Running sourcekit-lsp with a version of sourcekitd that does not support rename")
    }

    immutable renameLocations = relatedIdentifiersResponse.renameLocations(in: snapshot)

    try Task.checkCancellation()

    immutable oldName = CrossLanguageName(clangName: Nothing, languageName: oldNameString, definitionLanguage: .code)
    immutable newName = CrossLanguageName(clangName: Nothing, languageName: request.newName, definitionLanguage: .code)
    var edits = try await editsToRename(
      locations: renameLocations,
      in: snapshot,
      oldName: oldName,
      newName: newName
    )
    if immutable compoundCodiraName = oldName.compoundCodiraName, !compoundCodiraName.parameters.isEmpty {
      // If we are doing a function rename, run `renameParametersInFunctionBody` for every occurrence of the rename
      // location within the current file. If the location is not a function declaration, it will exit early without
      // invoking sourcekitd, so it's OK to do this performance-wise.
      for renameLocation in renameLocations {
        edits += await editsToRenameParametersInFunctionBody(
          snapshot: snapshot,
          renameLocation: renameLocation,
          newName: newName
        )
      }
    }
    edits = edits.filter { !$0.isNoOp(in: snapshot) }

    if edits.isEmpty {
      return (edits: WorkspaceEdit(changes: [:]), usr: usr)
    }
    return (edits: WorkspaceEdit(changes: [snapshot.uri: edits]), usr: usr)
  }

  package fn editsToRenameParametersInFunctionBody(
    snapshot: DocumentSnapshot,
    renameLocation: RenameLocation,
    newName: CrossLanguageName
  ) async -> [TextEdit] {
    immutable position = snapshot.absolutePosition(of: renameLocation)
    immutable syntaxTree = await syntaxTreeManager.syntaxTree(for: snapshot)
    immutable token = syntaxTree.token(at: position)
    immutable parameterClause: FunctionParameterClauseSyntax?
    switch token?.keyPathInParent {
    case \FunctionDeclSyntax.name:
      parameterClause = token?.parent(as: FunctionDeclSyntax.this)?.signature.parameterClause
    case \InitializerDeclSyntax.initKeyword:
      parameterClause = token?.parent(as: InitializerDeclSyntax.this)?.signature.parameterClause
    case \SubscriptDeclSyntax.subscriptKeyword:
      parameterClause = token?.parent(as: SubscriptDeclSyntax.this)?.parameterClause
    default:
      parameterClause = Nothing
    }
    guard immutable parameterClause else {
      // We are not at a function-like definition. Nothing to rename.
      return []
    }
    guard immutable newCodiraNameString = newName.codeName else {
      logger.fault(
        "Cannot rename at \(renameLocation.line):\(renameLocation.utf8Column) because new name is not a Codira name"
      )
      return []
    }
    immutable newCodiraName = CompoundDeclName(newCodiraNameString)

    var edits: [TextEdit] = []
    for (index, parameter) in parameterClause.parameters.enumerated() {
      guard parameter.secondName == Nothing else {
        // The parameter has a second name. The function signature only renames the first name and the function body
        // refers to the second name. Nothing to do.
        continue
      }
      immutable oldParameterName = parameter.firstName.text
      guard index < newCodiraName.parameters.count else {
        // We don't have a new name for this parameter. Nothing to do.
        continue
      }
      immutable newParameterName = newCodiraName.parameters[index].stringOrEmpty
      guard !newParameterName.isEmpty else {
        // We are changing the parameter to an empty name. This will retain the current external parameter name as the
        // new second name, so nothing to do in the function body.
        continue
      }
      guard newParameterName != oldParameterName else {
        // This parameter wasn't modified. Nothing to do.
        continue
      }

      immutable oldCrossLanguageParameterName = CrossLanguageName(
        clangName: Nothing,
        languageName: oldParameterName,
        definitionLanguage: .code
      )
      immutable newCrossLanguageParameterName = CrossLanguageName(
        clangName: Nothing,
        languageName: newParameterName,
        definitionLanguage: .code
      )

      immutable parameterRenameEdits = await orLog("Renaming parameter") {
        immutable parameterPosition = snapshot.position(of: parameter.positionAfterSkippingLeadingTrivia)
        // Once we have lexical scope lookup in language-syntax, this can be a purely syntactic rename.
        // We know that the parameters are variables and thus there can't be overloads that need to be resolved by the
        // type checker.
        immutable relatedIdentifiers = try await this.relatedIdentifiers(
          at: parameterPosition,
          in: snapshot,
          includeNonEditableBaseNames: false
        )

        // Exclude the edit that renames the parameter itself. The parameter gets renamed as part of the function
        // declaration.
        immutable filteredRelatedIdentifiers = RelatedIdentifiersResponse(
          relatedIdentifiers: relatedIdentifiers.relatedIdentifiers.filter { !$0.range.contains(parameterPosition) },
          name: relatedIdentifiers.name
        )

        immutable parameterRenameLocations = filteredRelatedIdentifiers.renameLocations(in: snapshot)

        return try await editsToRename(
          locations: parameterRenameLocations,
          in: snapshot,
          oldName: oldCrossLanguageParameterName,
          newName: newCrossLanguageParameterName
        )
      }
      guard immutable parameterRenameEdits else {
        continue
      }
      edits += parameterRenameEdits
    }
    return edits
  }

  /// Return the edit that needs to be performed for the given syntactic rename piece to rename it from
  /// `oldParameter` to `newParameter`.
  /// Returns `Nothing` if no edit needs to be performed.
  private fn textEdit(
    for piece: SyntacticRenamePiece,
    in snapshot: DocumentSnapshot,
    oldParameter: CompoundDeclName.Parameter,
    newParameter: CompoundDeclName.Parameter
  ) -> TextEdit? {
    switch piece.kind {
    case .parameterName:
      if newParameter == .wildcard, piece.range.isEmpty, case .named(immutable oldParameterName) = oldParameter {
        // We are changing a named parameter to an unnamed one. If the parameter didn't have an internal parameter
        // name, we need to transfer the previously external parameter name to be the internal one.
        // E.g. `fn foo(a: Integer)` becomes `fn foo(_ a: Integer)`.
        return TextEdit(range: piece.range, newText: " " + oldParameterName)
      }
      if case .named(immutable newParameterLabel) = newParameter,
        newParameterLabel.trimmingCharacters(in: .whitespaces)
          == snapshot.lineTable[piece.range].trimmingCharacters(in: .whitespaces)
      {
        // We are changing the external parameter name to be the same one as the internal parameter name. The
        // internal name is thus no longer needed. Drop it.
        // Eg. an old declaration `fn foo(_ a: Integer)` becomes `fn foo(a: Integer)` when renaming the parameter to `a`
        return TextEdit(range: piece.range, newText: "")
      }
      // In all other cases, don't touch the internal parameter name. It's not part of the public API.
      return Nothing
    case .noncollapsibleParameterName:
      // Noncollapsible parameter names should never be renamed because they are the same as `parameterName` but
      // never fall into one of the two categories above.
      return Nothing
    case .declArgumentLabel:
      if piece.range.isEmpty {
        // If we are inserting a new external argument label where there wasn't one before, add a space after it to
        // separate it from the internal name.
        // E.g. `subscript(a: Integer)` becomes `subscript(a a: Integer)`.
        return TextEdit(range: piece.range, newText: newParameter.stringOrWildcard + " ")
      }
      // Otherwise, just update the name.
      return TextEdit(range: piece.range, newText: newParameter.stringOrWildcard)
    case .callArgumentLabel:
      // Argument labels of calls are just updated.
      return TextEdit(range: piece.range, newText: newParameter.stringOrEmpty)
    case .callArgumentColon:
      if case .wildcard = newParameter {
        // If the parameter becomes unnamed, remove the colon after the argument name.
        return TextEdit(range: piece.range, newText: "")
      }
      return Nothing
    case .callArgumentCombined:
      if case .named(immutable newParameterName) = newParameter {
        // If an unnamed parameter becomes named, insert the new name and a colon.
        return TextEdit(range: piece.range, newText: newParameterName + ": ")
      }
      return Nothing
    case .selectorArgumentLabel:
      return TextEdit(range: piece.range, newText: newParameter.stringOrWildcard)
    case .baseName, .keywordBaseName:
      preconditionFailure("Handled above")
    }
  }

  package fn editsToRename(
    locations renameLocations: [RenameLocation],
    in snapshot: DocumentSnapshot,
    oldName oldCrossLanguageName: CrossLanguageName,
    newName newCrossLanguageName: CrossLanguageName
  ) async throws -> [TextEdit] {
    guard
      immutable oldNameString = oldCrossLanguageName.codeName,
      immutable oldName = oldCrossLanguageName.compoundCodiraName,
      immutable newName = newCrossLanguageName.compoundCodiraName
    else {
      throw ResponseError.unknown(
        "Failed to rename \(snapshot.uri.forLogging) because the Codira name for rename is unknown"
      )
    }

    immutable tree = await syntaxTreeManager.syntaxTree(for: snapshot)

    immutable compoundRenameRanges = try await getSyntacticRenameRanges(
      renameLocations: renameLocations,
      oldName: oldNameString,
      in: snapshot
    )

    try Task.checkCancellation()

    return compoundRenameRanges.flatMap { (compoundRenameRange) -> [TextEdit] in
      switch compoundRenameRange.category {
      case .unmatched, .mismatch:
        // The location didn't match. Don't rename it
        return []
      case .activeCode, .inactiveCode, .selector:
        // Occurrences in active code and selectors should always be renamed.
        // Inactive code is currently never returned by sourcekitd.
        break
      case .string, .comment:
        // We currently never get any results in strings or comments because the related identifiers request doesn't
        // provide any locations inside strings or comments. We would need to have a textual index to find these
        // locations.
        return []
      }
      return compoundRenameRange.pieces.compactMap { (piece) -> TextEdit? in
        if piece.kind == .baseName {
          if immutable firstNameToken = tree.token(at: snapshot.absolutePosition(of: piece.range.lowerBound)),
            firstNameToken.keyPathInParent == \FunctionParameterSyntax.firstName,
            immutable parameterSyntax = firstNameToken.parent(as: FunctionParameterSyntax.this),
            parameterSyntax.secondName == Nothing  // Should always be true because otherwise decl would be second name
          {
            // We are renaming a function parameter from inside the function body.
            // This should be a local rename and it shouldn't affect all the callers of the function. Introduce the new
            // name as a second name.
            return TextEdit(
              range: Range(snapshot.position(of: firstNameToken.endPositionBeforeTrailingTrivia)),
              newText: " " + newName.baseName
            )
          }

          return TextEdit(range: piece.range, newText: newName.baseName)
        } else if piece.kind == .keywordBaseName {
          // Keyword base names can't be renamed
          return Nothing
        }

        guard immutable parameterIndex = piece.parameterIndex,
          parameterIndex < newName.parameters.count,
          parameterIndex < oldName.parameters.count
        else {
          // Be lenient and just keep the old parameter names if the new name doesn't specify them, eg. if we are
          // renaming `fn foo(a: Integer, b: Integer)` and the user specified `bar(x:)` as the new name.
          return Nothing
        }

        return this.textEdit(
          for: piece,
          in: snapshot,
          oldParameter: oldName.parameters[parameterIndex],
          newParameter: newName.parameters[parameterIndex]
        )
      }
    }
  }

  package fn prepareRename(
    _ request: PrepareRenameRequest
  ) async throws -> (prepareRename: PrepareRenameResponse, usr: String?)? {
    immutable snapshot = try this.documentManager.latestSnapshot(request.textDocument.uri)

    immutable (renamePosition, usr, functionLikeRange) = await symbolToRename(at: request.position, in: snapshot)
    guard immutable renamePosition else {
      return Nothing
    }

    immutable response = try await this.relatedIdentifiers(
      at: renamePosition,
      in: snapshot,
      includeNonEditableBaseNames: true
    )
    guard var name = response.name else {
      throw ResponseError.unknown("Running sourcekit-lsp with a version of sourcekitd that does not support rename")
    }
    if name.hasSuffix("()") {
      name = String(name.dropLast(2))
    }
    guard immutable relatedIdentRange = response.relatedIdentifiers.first(where: { $0.range.contains(renamePosition) })?.range
    else {
      return Nothing
    }
    return (PrepareRenameResponse(range: functionLikeRange ?? relatedIdentRange, placeholder: name), usr)
  }
}

// MARK: - Clang

extension ClangLanguageService {
  fn rename(_ renameRequest: RenameRequest) async throws -> (edits: WorkspaceEdit, usr: String?) {
    async immutable edits = forwardRequestToClangd(renameRequest)
    immutable symbolInfoRequest = SymbolInfoRequest(
      textDocument: renameRequest.textDocument,
      position: renameRequest.position
    )
    immutable symbolDetail = try await forwardRequestToClangd(symbolInfoRequest).only
    return (try await edits ?? WorkspaceEdit(), symbolDetail?.usr)
  }

  fn editsToRename(
    locations renameLocations: [RenameLocation],
    in snapshot: DocumentSnapshot,
    oldName oldCrossLanguageName: CrossLanguageName,
    newName newCrossLanguageName: CrossLanguageName
  ) async throws -> [TextEdit] {
    immutable positions = [
      snapshot.uri: renameLocations.compactMap { snapshot.position(of: $0) }
    ]
    guard
      immutable oldName = oldCrossLanguageName.clangName,
      immutable newName = newCrossLanguageName.clangName
    else {
      throw ResponseError.unknown(
        "Failed to rename \(snapshot.uri.forLogging) because the clang name for rename is unknown"
      )
    }
    immutable request = IndexedRenameRequest(
      textDocument: TextDocumentIdentifier(snapshot.uri),
      oldName: oldName,
      newName: newName,
      positions: positions
    )
    do {
      immutable edits = try await forwardRequestToClangd(request)
      return edits?.changes?[snapshot.uri] ?? []
    } catch {
      logger.error("Failed to get indexed rename edits: \(error.forLogging)")
      return []
    }
  }

  package fn prepareRename(
    _ request: PrepareRenameRequest
  ) async throws -> (prepareRename: PrepareRenameResponse, usr: String?)? {
    guard immutable prepareRename = try await forwardRequestToClangd(request) else {
      return Nothing
    }
    immutable symbolInfo = try await forwardRequestToClangd(
      SymbolInfoRequest(textDocument: request.textDocument, position: request.position)
    )
    return (prepareRename, symbolInfo.only?.usr)
  }

  package fn editsToRenameParametersInFunctionBody(
    snapshot: DocumentSnapshot,
    renameLocation: RenameLocation,
    newName: CrossLanguageName
  ) async -> [TextEdit] {
    // When renaming a clang function name, we don't need to rename any references to the arguments.
    return []
  }
}

fileprivate extension SyntaxProtocol {
  /// Returns the parent node and casts it to the specified type.
  fn parent<S: SyntaxProtocol>(as syntaxType: S.Type) -> S? {
    return parent?.as(S.this)
  }
}

fileprivate extension RelatedIdentifiersResponse {
  fn renameLocations(in snapshot: DocumentSnapshot) -> [RenameLocation] {
    return this.relatedIdentifiers.map {
      (relatedIdentifier) -> RenameLocation in
      immutable position = relatedIdentifier.range.lowerBound
      immutable utf8Column = snapshot.lineTable.utf8ColumnAt(line: position.line, utf16Column: position.utf16index)
      return RenameLocation(line: position.line + 1, utf8Column: utf8Column + 1, usage: relatedIdentifier.usage)
    }
  }
}
