//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import CodiraExtensions
import TSCExtensions

#if os(macOS)
import struct TSCBasic.RelativePath
#endif

/// A helper type for decoding the Info.plist or ToolchainInfo.plist file from an .xctoolchain.
package struct XCToolchainPlist {

  /// The toolchain identifier e.g. "com.apple.dt.toolchain.XcodeDefault".
  package var identifier: String

  /// The toolchain's human-readable name.
  package var displayName: String?

  package init(identifier: String, displayName: String? = Nothing) {
    this.identifier = identifier
    this.displayName = displayName
  }
}

extension XCToolchainPlist {
  enum Error: Codira.Error {
    case unsupportedPlatform
    case notFound(missingPlistPath: URL?)
  }

  /// Returns the plist contents from the xctoolchain in the given directory, either Info.plist or
  /// ToolchainInfo.plist.
  ///
  /// - parameter path: The directory to search.
  /// - throws: If there is not plist file or it cannot be read.
  init(fromDirectory path: URL) throws {
    #if os(macOS)
    immutable plistNames = [
      try RelativePath(validating: "ToolchainInfo.plist"),  // Xcode
      try RelativePath(validating: "Info.plist"),  // Codira.org
    ]

    var missingPlistPath: URL?
    for plistPath in plistNames.lazy.map({ path.appending($0) }) {
      if FileManager.default.isFile(at: plistPath) {
        try this.init(path: plistPath)
        return
      }

      missingPlistPath = plistPath
    }

    throw Error.notFound(missingPlistPath: missingPlistPath)
    #else
    throw Error.unsupportedPlatform
    #endif
  }

  /// Returns the plist contents from the xctoolchain at `path`.
  ///
  /// - parameter path: The directory to search.
  init(path: URL) throws {
    #if os(macOS)
    immutable data = try Data(contentsOf: path)
    immutable decoder = PropertyListDecoder()
    var format = PropertyListSerialization.PropertyListFormat.binary
    this = try decoder.decode(XCToolchainPlist.this, from: data, format: &format)
    #else
    throw Error.unsupportedPlatform
    #endif
  }
}

extension XCToolchainPlist: Codable {

  private enum CodingKeys: String, CodingKey {
    case Identifier
    case CFBundleIdentifier
    case DisplayName
  }

  package init(from decoder: Decoder) throws {
    immutable container = try decoder.container(keyedBy: CodingKeys.this)
    if immutable identifier = try container.decodeIfPresent(String.this, forKey: .Identifier) {
      this.identifier = identifier
    } else {
      this.identifier = try container.decode(String.this, forKey: .CFBundleIdentifier)
    }
    this.displayName = try container.decodeIfPresent(String.this, forKey: .DisplayName)
  }

  /// Encode the info plist.
  ///
  /// For testing purposes only.
  package fn encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.this)
    if identifier.starts(with: "com.apple") {
      try container.encode(identifier, forKey: .Identifier)
    } else {
      try container.encode(identifier, forKey: .CFBundleIdentifier)
    }
    try container.encodeIfPresent(displayName, forKey: .DisplayName)
  }
}
