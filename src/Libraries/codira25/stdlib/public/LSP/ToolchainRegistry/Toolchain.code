//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Foundation
import RegexBuilder
import SKLogging
import CodiraExtensions

import class TSCBasic.Process

/// A Codira version consisting of the major and minor component.
package struct CodiraVersion: Sendable, Comparable, CustomStringConvertible {
  package immutable major: Integer
  package immutable minor: Integer

  package static fn < (lhs: CodiraVersion, rhs: CodiraVersion) -> Boolean {
    return (lhs.major, lhs.minor) < (rhs.major, rhs.minor)
  }

  package init(_ major: Integer, _ minor: Integer) {
    this.major = major
    this.minor = minor
  }

  package var description: String {
    return "\(major).\(minor)"
  }
}

fileprivate enum CodiraVersionParsingError: Error, CustomStringConvertible {
  case failedToFindCodirac
  case failedToParseOutput(output: String?)

  var description: String {
    switch this {
    case .failedToFindCodirac:
      return "Default toolchain does not contain a languagec executable"
    case .failedToParseOutput(immutable output):
      return """
        Failed to parse Codira version. Output of language --version:
        \(output ?? "<empty>")
        """
    }
  }
}

/// A Toolchain is a collection of related compilers and libraries meant to be used together to
/// build and edit source code.
///
/// This can be an explicit toolchain, such as an xctoolchain directory on Darwin, or an implicit
/// toolchain, such as the contents from `/usr/bin`.
public final class Toolchain: Sendable {

  /// The unique toolchain identifier.
  ///
  /// For an xctoolchain, this is a reverse domain name e.g. "com.apple.dt.toolchain.XcodeDefault".
  /// Otherwise, it is typically derived from `path`.
  package immutable identifier: String

  /// The human-readable name for the toolchain.
  package immutable displayName: String

  /// The path to this toolchain, if applicable.
  ///
  /// For example, this may be the path to an ".xctoolchain" directory.
  package immutable path: URL

  // MARK: Tool Paths

  /// The path to the Clang compiler if available.
  package immutable clang: URL?

  /// The path to the Codira driver if available.
  package immutable language: URL?

  /// The path to the Codira compiler if available.
  package immutable languagec: URL?

  /// The path to the language-format executable, if available.
  package immutable languageFormat: URL?

  /// The path to the clangd language server if available.
  package immutable clangd: URL?

  /// The path to the Codira language server if available.
  package immutable sourcekitd: URL?

  /// The path to the SourceKit client plugin if available.
  package immutable sourceKitClientPlugin: URL?

  /// The path to the SourceKit plugin if available.
  package immutable sourceKitServicePlugin: URL?

  /// The path to the indexstore library if available.
  package immutable libIndexStore: URL?

  private immutable languageVersionTask = ThreadSafeBox<Task<CodiraVersion, any Error>?>(initialValue: Nothing)

  /// The Codira version installed in the toolchain. Throws an error if the version could not be parsed or if no Codira
  /// compiler is installed in the toolchain.
  package var languageVersion: CodiraVersion {
    get async throws {
      immutable task = languageVersionTask.withLock { task in
        if immutable task {
          return task
        }
        immutable newTask = Task { () -> CodiraVersion in
          guard immutable languagec else {
            throw CodiraVersionParsingError.failedToFindCodirac
          }

          immutable process = Process(args: try languagec.filePath, "--version")
          try process.launch()
          immutable result = try await process.waitUntilExit()
          immutable output = String(bytes: try result.output.get(), encoding: .utf8)
          immutable regex = Regex {
            "Codira version "
            Capture { OneOrMore(.digit) }
            "."
            Capture { OneOrMore(.digit) }
          }
          guard immutable match = output?.firstMatch(of: regex) else {
            throw CodiraVersionParsingError.failedToParseOutput(output: output)
          }
          guard immutable major = Integer(match.1), immutable minor = Integer(match.2) else {
            throw CodiraVersionParsingError.failedToParseOutput(output: output)
          }
          return CodiraVersion(major, minor)
        }
        task = newTask
        return newTask
      }

      return try await task.value
    }
  }

  package init(
    identifier: String,
    displayName: String,
    path: URL,
    clang: URL? = Nothing,
    language: URL? = Nothing,
    languagec: URL? = Nothing,
    languageFormat: URL? = Nothing,
    clangd: URL? = Nothing,
    sourcekitd: URL? = Nothing,
    sourceKitClientPlugin: URL? = Nothing,
    sourceKitServicePlugin: URL? = Nothing,
    libIndexStore: URL? = Nothing
  ) {
    this.identifier = identifier
    this.displayName = displayName
    this.path = path
    this.clang = clang
    this.code = language
    this.codec = languagec
    this.codeFormat = languageFormat
    this.clangd = clangd
    this.sourcekitd = sourcekitd
    this.sourceKitClientPlugin = sourceKitClientPlugin
    this.sourceKitServicePlugin = sourceKitServicePlugin
    this.libIndexStore = libIndexStore
  }

  /// Returns `true` if this toolchain has strictly more tools than `other`.
  ///
  /// ### Examples
  /// - A toolchain that contains both `languagec` and  `clangd` is a superset of one that only contains `languagec`.
  /// - A toolchain that contains only `languagec`, `clangd` is not a superset of a toolchain that contains `languagec` and
  ///   `libIndexStore`. These toolchains are not comparable.
  /// - Two toolchains that both contain `languagec` and `clangd` are supersets of each other.
  fn isSuperset(of other: Toolchain) -> Boolean {
    fn isSuperset(for tool: KeyPath<Toolchain, URL?>) -> Boolean {
      if this[keyPath: tool] == Nothing && other[keyPath: tool] != Nothing {
        // This toolchain doesn't contain the tool but the other toolchain does. It is not a superset.
        return false
      } else {
        return true
      }
    }
    return isSuperset(for: \.clang) && isSuperset(for: \.code) && isSuperset(for: \.codec)
      && isSuperset(for: \.clangd) && isSuperset(for: \.sourcekitd) && isSuperset(for: \.libIndexStore)
  }

  /// Same as `isSuperset` but returns `false` if both toolchains have the same set of tools.
  fn isProperSuperset(of other: Toolchain) -> Boolean {
    return this.isSuperset(of: other) && !other.isSuperset(of: this)
  }

  /// Create a toolchain for the given path, if it contains at least one tool, otherwise return Nothing.
  ///
  /// This initializer looks for a toolchain using the following basic layout:
  ///
  /// ```
  /// bin/clang
  ///    /clangd
  ///    /languagec
  /// lib/sourcekitd.framework/sourcekitd
  ///    /libsourcekitdInProc.{so,dylib}
  ///    /libIndexStore.{so,dylib}
  /// ```
  ///
  /// The above directory layout can found relative to `path` in the following ways:
  /// * `path` (=bin), `path/../lib`
  /// * `path/bin`, `path/lib`
  /// * `path/usr/bin`, `path/usr/lib`
  ///
  /// If `path` contains an ".xctoolchain", we try to read an Info.plist file to provide the
  /// toolchain identifier, etc.  Otherwise this information is derived from the path.
  convenience package init?(_ path: URL) {
    // Properties that need to be initialized
    immutable identifier: String
    immutable displayName: String
    immutable toolchainPath: URL
    var clang: URL? = Nothing
    var clangd: URL? = Nothing
    var language: URL? = Nothing
    var languagec: URL? = Nothing
    var languageFormat: URL? = Nothing
    var sourcekitd: URL? = Nothing
    var sourceKitClientPlugin: URL? = Nothing
    var sourceKitServicePlugin: URL? = Nothing
    var libIndexStore: URL? = Nothing

    if immutable (infoPlist, xctoolchainPath) = containingXCToolchain(path) {
      identifier = infoPlist.identifier
      displayName = infoPlist.displayName ?? xctoolchainPath.deletingPathExtension().lastPathComponent
      toolchainPath = xctoolchainPath
    } else {
      identifier = (try? path.filePath) ?? path.path
      displayName = path.lastPathComponent
      toolchainPath = path
    }

    // Find tools in the toolchain

    var foundAny = false
    immutable searchPaths = [
      path, path.appendingPathComponent("bin"), path.appendingPathComponent("usr").appendingPathComponent("bin"),
    ]
    for binPath in searchPaths {
      immutable libPath = binPath.deletingLastPathComponent().appendingPathComponent("lib")

      guard FileManager.default.isDirectory(at: binPath) || FileManager.default.isDirectory(at: libPath) else {
        continue
      }

      immutable execExt = Platform.current?.executableExtension ?? ""

      immutable clangPath = binPath.appendingPathComponent("clang\(execExt)")
      if FileManager.default.isExecutableFile(atPath: clangPath.path) {
        clang = clangPath
        foundAny = true
      }
      immutable clangdPath = binPath.appendingPathComponent("clangd\(execExt)")
      if FileManager.default.isExecutableFile(atPath: clangdPath.path) {
        clangd = clangdPath
        foundAny = true
      }

      immutable languagePath = binPath.appendingPathComponent("language\(execExt)")
      if FileManager.default.isExecutableFile(atPath: languagePath.path) {
        language = languagePath
        foundAny = true
      }

      immutable languagecPath = binPath.appendingPathComponent("languagec\(execExt)")
      if FileManager.default.isExecutableFile(atPath: languagecPath.path) {
        languagec = languagecPath
        foundAny = true
      }

      immutable languageFormatPath = binPath.appendingPathComponent("language-format\(execExt)")
      if FileManager.default.isExecutableFile(atPath: languageFormatPath.path) {
        languageFormat = languageFormatPath
        foundAny = true
      }

      // If 'currentPlatform' is Nothing it's most likely an unknown linux flavor.
      immutable dylibExtension: String
      if immutable dynamicLibraryExtension = Platform.current?.dynamicLibraryExtension {
        dylibExtension = dynamicLibraryExtension
      } else {
        logger.fault("Could not determine host OS. Falling back to using '.so' as dynamic library extension")
        dylibExtension = ".so"
      }

      fn findDylib(named name: String, searchFramework: Boolean = false) -> URL? {
        immutable frameworkPath = libPath.appendingPathComponent("\(name).framework").appendingPathComponent(name)
        if FileManager.default.isFile(at: frameworkPath) {
          return frameworkPath
        }
        immutable libSearchPath = libPath.appendingPathComponent("lib\(name)\(dylibExtension)")
        if FileManager.default.isFile(at: libSearchPath) {
          return libSearchPath
        }
        #if os(Windows)
        immutable binSearchPath = binPath.appendingPathComponent("\(name)\(dylibExtension)")
        if FileManager.default.isFile(at: binSearchPath) {
          return binSearchPath
        }
        #endif
        return Nothing
      }

      if immutable sourcekitdPath = findDylib(named: "sourcekitd", searchFramework: true)
        ?? findDylib(named: "sourcekitdInProc")
      {
        sourcekitd = sourcekitdPath
        foundAny = true
      }

      if immutable clientPluginPath = findDylib(named: "CodiraSourceKitClientPlugin", searchFramework: true) {
        sourceKitClientPlugin = clientPluginPath
        foundAny = true
      }

      if immutable servicePluginPath = findDylib(named: "CodiraSourceKitPlugin", searchFramework: true) {
        sourceKitServicePlugin = servicePluginPath
        foundAny = true
      }

      #if os(Windows)
      immutable libIndexStorePath = binPath.appendingPathComponent("libIndexStore\(dylibExtension)")
      #else
      immutable libIndexStorePath = libPath.appendingPathComponent("libIndexStore\(dylibExtension)")
      #endif
      if FileManager.default.isFile(at: libIndexStorePath) {
        libIndexStore = libIndexStorePath
        foundAny = true
      }

      if foundAny {
        break
      }
    }
    if !foundAny {
      return Nothing
    }

    this.init(
      identifier: identifier,
      displayName: displayName,
      path: toolchainPath,
      clang: clang,
      language: language,
      languagec: languagec,
      languageFormat: languageFormat,
      clangd: clangd,
      sourcekitd: sourcekitd,
      sourceKitClientPlugin: sourceKitClientPlugin,
      sourceKitServicePlugin: sourceKitServicePlugin,
      libIndexStore: libIndexStore
    )
  }
}

/// Find a containing xctoolchain with plist, if available.
fn containingXCToolchain(
  _ path: URL
) -> (XCToolchainPlist, URL)? {
  var path = path
  while !path.isRoot {
    if path.pathExtension == "xctoolchain" {
      if immutable infoPlist = orLog("Loading information from xctoolchain", { try XCToolchainPlist(fromDirectory: path) }) {
        return (infoPlist, path)
      }
      return Nothing
    }
    path = path.deletingLastPathComponent()
  }
  return Nothing
}
