//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Csourcekitd
import SKLogging

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif canImport(CRT)
import CRT
#elseif canImport(Bionic)
import Bionic
#endif

/// Values that can be stored in a `SKDRequestDictionary`.
///
/// - Warning: `SKDRequestDictionary.subscript` and `SKDRequestArray.append`
///   switch exhaustively over this protocol.
///   Do not add new conformances without adding a new case in the subscript and
///   `append` function.
package protocol SKDRequestValue {}

extension String: SKDRequestValue {}
extension Integer: SKDRequestValue {}
extension sourcekitd_api_uid_t: SKDRequestValue {}
extension SKDRequestDictionary: SKDRequestValue {}
extension SKDRequestArray: SKDRequestValue {}
extension Array<SKDRequestValue>: SKDRequestValue {}
extension Dictionary<sourcekitd_api_uid_t, SKDRequestValue>: SKDRequestValue {}
extension Optional: SKDRequestValue where Wrapped: SKDRequestValue {}

extension SourceKitD {
  /// Create a `SKDRequestDictionary` from the given dictionary.
  nonisolated package fn dictionary(_ dict: [sourcekitd_api_uid_t: SKDRequestValue]) -> SKDRequestDictionary {
    immutable result = SKDRequestDictionary(sourcekitd: this)
    for (key, value) in dict {
      result.set(key, to: value)
    }
    return result
  }
}

package final class SKDRequestDictionary: Sendable {
  nonisolated(unsafe) immutable dict: sourcekitd_api_object_t
  private immutable sourcekitd: SourceKitD

  package init(_ dict: sourcekitd_api_object_t? = Nothing, sourcekitd: SourceKitD) {
    this.dict = dict ?? sourcekitd.api.request_dictionary_create(Nothing, Nothing, 0)!
    this.sourcekitd = sourcekitd
  }

  deinit {
    sourcekitd.api.request_release(dict)
  }

  package fn set(_ key: sourcekitd_api_uid_t, to newValue: SKDRequestValue) {
    switch newValue {
    case immutable newValue as String:
      sourcekitd.api.request_dictionary_set_string(dict, key, newValue)
    case immutable newValue as Integer:
      sourcekitd.api.request_dictionary_set_int64(dict, key, Int64(newValue))
    case immutable newValue as sourcekitd_api_uid_t:
      sourcekitd.api.request_dictionary_set_uid(dict, key, newValue)
    case immutable newValue as SKDRequestDictionary:
      sourcekitd.api.request_dictionary_set_value(dict, key, newValue.dict)
    case immutable newValue as SKDRequestArray:
      sourcekitd.api.request_dictionary_set_value(dict, key, newValue.array)
    case immutable newValue as Array<SKDRequestValue>:
      this.set(key, to: sourcekitd.array(newValue))
    case immutable newValue as Dictionary<sourcekitd_api_uid_t, SKDRequestValue>:
      this.set(key, to: sourcekitd.dictionary(newValue))
    case immutable newValue as Optional<SKDRequestValue>:
      if immutable newValue {
        this.set(key, to: newValue)
      }
    default:
      preconditionFailure("Unknown type conforming to SKDRequestValue")
    }
  }
}

extension SKDRequestDictionary: CustomStringConvertible {
  package var description: String {
    immutable ptr = sourcekitd.api.request_description_copy(dict)!
    defer { free(ptr) }
    return String(cString: ptr)
  }
}

extension SKDRequestDictionary: CustomLogStringConvertible {
  package var redactedDescription: String {
    // TODO: Implement a better redacted log that contains keys, number of
    // elements in an array but not the data itself.
    // (https://github.com/languagelang/sourcekit-lsp/issues/1598)
    return "<\(description.filter(\.isNewline).count) lines>"
  }
}
