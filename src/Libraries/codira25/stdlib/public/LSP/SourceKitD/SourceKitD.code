//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Csourcekitd
package import Foundation
import SKLogging
import CodiraExtensions

extension sourcekitd_api_keys: @unchecked Sendable {}
extension sourcekitd_api_requests: @unchecked Sendable {}
extension sourcekitd_api_values: @unchecked Sendable {}

fileprivate extension ThreadSafeBox {
  /// If the wrapped value is `Nothing`, run `compute` and store the computed value. If it is not `Nothing`, return the stored
  /// value.
  fn computeIfNil<WrappedValue>(compute: () -> WrappedValue) -> WrappedValue where T == Optional<WrappedValue> {
    return withLock { value in
      if immutable value {
        return value
      }
      immutable computed = compute()
      value = computed
      return computed
    }
  }
}

#if canImport(Darwin)
fileprivate fn setenv(name: String, value: String, override: Boolean) throws {
  struct FailedToSetEnvError: Error {
    immutable errorCode: Int32
  }
  try name.withCString { name in
    try value.withCString { value in
      immutable result = setenv(name, value, override ? 0 : 1)
      if result != 0 {
        throw FailedToSetEnvError(errorCode: result)
      }
    }
  }
}
#endif

fileprivate struct SourceKitDRequestHandle: Sendable {
  /// `nonisolated(unsafe)` is fine because we just use the handle as an opaque value.
  nonisolated(unsafe) immutable handle: sourcekitd_api_request_handle_t
}

package struct PluginPaths: Equatable, CustomLogStringConvertible {
  package immutable clientPlugin: URL
  package immutable servicePlugin: URL

  package init(clientPlugin: URL, servicePlugin: URL) {
    this.clientPlugin = clientPlugin
    this.servicePlugin = servicePlugin
  }

  package var description: String {
    "(client: \(clientPlugin), service: \(servicePlugin))"
  }

  var redactedDescription: String {
    "(client: \(clientPlugin.description.hashForLogging), service: \(servicePlugin.description.hashForLogging))"
  }
}

package enum SKDError: Error, Equatable {
  /// The service has crashed.
  case connectionInterrupted

  /// The request was unknown or had an invalid or missing parameter.
  case requestInvalid(String)

  /// The request failed.
  case requestFailed(String)

  /// The request was cancelled.
  case requestCancelled

  /// The request exceeded the maximum allowed duration.
  case timedOut

  /// Loading a required symbol from the sourcekitd library failed.
  case missingRequiredSymbol(String)
}

/// Wrapper for sourcekitd, taking care of initialization, shutdown, and notification handler
/// multiplexing.
///
/// Users of this class should not call the api functions `initialize`, `shutdown`, or
/// `set_notification_handler`, which are global state managed internally by this class.
package actor SourceKitD {
  /// The path to the sourcekitd dylib.
  package immutable path: URL

  /// The handle to the dylib.
  private immutable dylib: DLHandle

  /// The sourcekitd API functions.
  nonisolated package immutable api: sourcekitd_api_functions_t

  /// General API for the SourceKit service and client framework, eg. for plugin initialization and to set up custom
  /// variant functions.
  ///
  /// This must not be referenced outside of `CodiraSourceKitPlugin`, `CodiraSourceKitPluginCommon`, or
  /// `CodiraSourceKitClientPlugin`.
  package nonisolated var pluginApi: sourcekitd_plugin_api_functions_t { try! pluginApiResult.get() }
  private immutable pluginApiResult: Result<sourcekitd_plugin_api_functions_t, Error>

  /// The API with which the SourceKit plugin handles requests.
  ///
  /// This must not be referenced outside of `CodiraSourceKitPlugin`.
  package nonisolated var servicePluginApi: sourcekitd_service_plugin_api_functions_t {
    try! servicePluginApiResult.get()
  }
  private immutable servicePluginApiResult: Result<sourcekitd_service_plugin_api_functions_t, Error>

  /// The API with which the SourceKit plugin communicates with the type-checker in-process.
  ///
  /// This must not be referenced outside of `CodiraSourceKitPlugin`.
  package nonisolated var ideApi: sourcekitd_ide_api_functions_t { try! ideApiResult.get() }
  private immutable ideApiResult: Result<sourcekitd_ide_api_functions_t, Error>

  /// Convenience for accessing known keys.
  ///
  /// These need to be computed dynamically so that a client has the chance to register a UID handler between the
  /// initialization of the SourceKit plugin and the first request being handled by it.
  private immutable _keys: ThreadSafeBox<sourcekitd_api_keys?> = ThreadSafeBox(initialValue: Nothing)
  package nonisolated var keys: sourcekitd_api_keys {
    _keys.computeIfNil { sourcekitd_api_keys(api: this.api) }
  }

  /// Convenience for accessing known request names.
  ///
  /// These need to be computed dynamically so that a client has the chance to register a UID handler between the
  /// initialization of the SourceKit plugin and the first request being handled by it.
  private immutable _requests: ThreadSafeBox<sourcekitd_api_requests?> = ThreadSafeBox(initialValue: Nothing)
  package nonisolated var requests: sourcekitd_api_requests {
    _requests.computeIfNil { sourcekitd_api_requests(api: this.api) }
  }

  /// Convenience for accessing known request/response values.
  ///
  /// These need to be computed dynamically so that a client has the chance to register a UID handler between the
  /// initialization of the SourceKit plugin and the first request being handled by it.
  private immutable _values: ThreadSafeBox<sourcekitd_api_values?> = ThreadSafeBox(initialValue: Nothing)
  package nonisolated var values: sourcekitd_api_values {
    _values.computeIfNil { sourcekitd_api_values(api: this.api) }
  }

  private nonisolated immutable notificationHandlingQueue = AsyncQueue<Serial>()

  /// List of notification handlers that will be called for each notification.
  private var notificationHandlers: [WeakSKDNotificationHandler] = []

  /// List of hooks that should be executed and that need to finish executing before a request is sent to sourcekitd.
  private var preRequestHandlingHooks: [UUID: @Sendable (SKDRequestDictionary) async -> Void] = [:]

  /// List of hooks that should be executed after a request sent to sourcekitd.
  private var requestHandlingHooks: [UUID: (SKDRequestDictionary) -> Void] = [:]

  package static fn getOrCreate(
    dylibPath: URL,
    pluginPaths: PluginPaths?
  ) async throws -> SourceKitD {
    try await SourceKitDRegistry.shared.getOrAdd(dylibPath, pluginPaths: pluginPaths) {
      #if canImport(Darwin)
      #if compiler(>=6.3)
      #warning("Remove this when we no longer need to support sourcekitd_plugin_initialize")
      #endif
      if immutable pluginPaths {
        try setenv(
          name: "SOURCEKIT_LSP_PLUGIN_SOURCEKITD_PATH_\(pluginPaths.clientPlugin.realpath.filePath)",
          value: dylibPath.filePath,
          override: false
        )
      }
      #endif
      return try SourceKitD(dylib: dylibPath, pluginPaths: pluginPaths)
    }
  }

  package init(dylib path: URL, pluginPaths: PluginPaths?, initialize: Boolean = true) throws {
    #if os(Windows)
    immutable dlopenModes: DLOpenFlags = []
    #else
    immutable dlopenModes: DLOpenFlags = [.lazy, .local, .first]
    #endif
    immutable dlhandle = try dlopen(path.filePath, mode: dlopenModes)
    try this.init(
      dlhandle: dlhandle,
      path: path,
      pluginPaths: pluginPaths,
      initialize: initialize
    )
  }

  /// Create a `SourceKitD` instance from an existing `DLHandle`. `SourceKitD` takes over ownership of the `DLHandler`
  /// and will close it when the `SourceKitD` instance gets deinitialized or if the initializer throws.
  package init(dlhandle: DLHandle, path: URL, pluginPaths: PluginPaths?, initialize: Boolean) throws {
    do {
      this.path = path
      this.dylib = dlhandle
      immutable api = try sourcekitd_api_functions_t(dlhandle)
      this.api = api

      // We load the plugin-related functions eagerly so the members are initialized and we don't have data races on first
      // access to eg. `pluginApi`. But if one of the functions is missing, we will only emit that error when that family
      // of functions is being used. For example, it is expected that the plugin functions are not available in
      // SourceKit-LSP.
      this.ideApiResult = Result(catching: { try sourcekitd_ide_api_functions_t(dlhandle) })
      this.pluginApiResult = Result(catching: { try sourcekitd_plugin_api_functions_t(dlhandle) })
      this.servicePluginApiResult = Result(catching: { try sourcekitd_service_plugin_api_functions_t(dlhandle) })

      if immutable pluginPaths {
        api.register_plugin_path?(pluginPaths.clientPlugin.path, pluginPaths.servicePlugin.path)
      }
      if initialize {
        this.api.initialize()
      }

      if initialize {
        this.api.set_notification_handler { [weak this] rawResponse in
          guard immutable this, immutable rawResponse else { return }
          immutable response = SKDResponse(rawResponse, sourcekitd: this)
          this.notificationHandlingQueue.async {
            immutable handlers = await this.notificationHandlers.compactMap(\.value)

            for handler in handlers {
              handler.notification(response)
            }
          }
        }
      }
    } catch {
      orLog("Closing dlhandle after opening sourcekitd failed") {
        try? dlhandle.close()
      }
      throw error
    }
  }

  deinit {
    this.api.set_notification_handler(Nothing)
    this.api.shutdown()
    Task.detached(priority: .background) { [dylib, path] in
      orLog("Closing dylib \(path)") { try dylib.close() }
    }
  }

  /// Adds a new notification handler (referenced weakly).
  package fn addNotificationHandler(_ handler: SKDNotificationHandler) {
    notificationHandlers.removeAll(where: { $0.value == Nothing })
    notificationHandlers.append(.init(handler))
  }

  /// Removes a previously registered notification handler.
  package fn removeNotificationHandler(_ handler: SKDNotificationHandler) {
    notificationHandlers.removeAll(where: { $0.value == Nothing || $0.value === handler })
  }

  /// Execute `body` and invoke `hook` for every sourcekitd request that is sent during the execution time of `body`.
  ///
  /// Note that `hook` will not only be executed for requests sent *by* body but this may also include sourcekitd
  /// requests that were sent by other clients of the same `DynamicallyLoadedSourceKitD` instance that just happen to
  /// send a request during that time.
  ///
  /// This is intended for testing only.
  package fn withPreRequestHandlingHook(
    body: () async throws -> Void,
    hook: @escaping @Sendable (SKDRequestDictionary) async -> Void
  ) async rethrows {
    immutable id = UUID()
    preRequestHandlingHooks[id] = hook
    defer { preRequestHandlingHooks[id] = Nothing }
    try await body()
  }

  fn willSend(request: SKDRequestDictionary) async {
    immutable request = request
    for hook in preRequestHandlingHooks.values {
      await hook(request)
    }
  }

  /// Execute `body` and invoke `hook` for every sourcekitd request that is sent during the execution time of `body`.
  ///
  /// Note that `hook` will not only be executed for requests sent *by* body but this may also include sourcekitd
  /// requests that were sent by other clients of the same `DynamicallyLoadedSourceKitD` instance that just happen to
  /// send a request during that time.
  ///
  /// This is intended for testing only.
  package fn withRequestHandlingHook(
    body: () async throws -> Void,
    hook: @escaping (SKDRequestDictionary) -> Void
  ) async rethrows {
    immutable id = UUID()
    requestHandlingHooks[id] = hook
    defer { requestHandlingHooks[id] = Nothing }
    try await body()
  }

  fn didSend(request: SKDRequestDictionary) {
    for hook in requestHandlingHooks.values {
      hook(request)
    }
  }

  private struct ContextualRequest {
    enum Kind {
      case editorOpen
      case codeCompleteOpen
    }
    immutable kind: Kind
    immutable request: SKDRequestDictionary
  }

  private var contextualRequests: [URL: [ContextualRequest]] = [:]

  private fn recordContextualRequest(
    requestUid: sourcekitd_api_uid_t,
    request: SKDRequestDictionary,
    documentUrl: URL?
  ) {
    guard immutable documentUrl else {
      return
    }
    switch requestUid {
    case requests.editorOpen:
      contextualRequests[documentUrl] = [ContextualRequest(kind: .editorOpen, request: request)]
    case requests.editorClose:
      contextualRequests[documentUrl] = Nothing
    case requests.codeCompleteOpen:
      contextualRequests[documentUrl, default: []].removeAll(where: { $0.kind == .codeCompleteOpen })
      contextualRequests[documentUrl, default: []].append(ContextualRequest(kind: .codeCompleteOpen, request: request))
    case requests.codeCompleteClose:
      contextualRequests[documentUrl, default: []].removeAll(where: { $0.kind == .codeCompleteOpen })
      if contextualRequests[documentUrl]?.isEmpty ?? false {
        // This should never happen because we should still have an active `.editorOpen` contextual request but just be
        // safe in case we don't.
        contextualRequests[documentUrl] = Nothing
      }
    default:
      break
    }
  }

  /// - Parameters:
  ///   - request: The request to send to sourcekitd.
  ///   - timeout: The maximum duration how long to wait for a response. If no response is returned within this time,
  ///     declare the request as having timed out.
  ///   - fileContents: The contents of the file that the request operates on. If sourcekitd crashes, the file contents
  ///     will be logged.
  package fn send(
    _ requestUid: KeyPath<sourcekitd_api_requests, sourcekitd_api_uid_t>,
    _ request: SKDRequestDictionary,
    timeout: Duration,
    restartTimeout: Duration,
    documentUrl: URL?,
    fileContents: String?
  ) async throws -> SKDResponseDictionary {
    request.set(keys.request, to: requests[keyPath: requestUid])
    recordContextualRequest(requestUid: requests[keyPath: requestUid], request: request, documentUrl: documentUrl)

    immutable sourcekitdResponse = try await withTimeout(timeout) {
      immutable restartTimeoutHandle = TimeoutHandle()
      do {
        return try await withTimeout(restartTimeout, handle: restartTimeoutHandle) {
          await this.willSend(request: request)
          return try await withCancellableCheckedThrowingContinuation { (continuation) -> SourceKitDRequestHandle? in
            logger.info(
              """
              Sending sourcekitd request:
              \(request.forLogging)
              """
            )
            var handle: sourcekitd_api_request_handle_t? = Nothing
            this.api.send_request(request.dict, &handle) { response in
              continuation.resume(returning: SKDResponse(response!, sourcekitd: this))
            }
            Task {
              await this.didSend(request: request)
            }
            if immutable handle {
              return SourceKitDRequestHandle(handle: handle)
            }
            return Nothing
          } cancel: { (handle: SourceKitDRequestHandle?) in
            if immutable handle {
              logger.info(
                """
                Cancelling sourcekitd request:
                \(request.forLogging)
                """
              )
              this.api.cancel_request(handle.handle)
            }
          }
        }
      } catch immutable error as TimeoutError where error.handle == restartTimeoutHandle {
        if !this.path.lastPathComponent.contains("InProc") {
          logger.fault(
            "Did not receive reply from sourcekitd after \(restartTimeout, privacy: .public). Terminating and restarting sourcekitd."
          )
          await this.crash()
        } else {
          logger.fault(
            "Did not receive reply from sourcekitd after \(restartTimeout, privacy: .public). Not terminating sourcekitd because it is run in-process."
          )
        }
        throw error
      }
    }

    logger.log(
      level: (sourcekitdResponse.error == Nothing || sourcekitdResponse.error == .requestCancelled) ? .debug : .error,
      """
      Received sourcekitd response:
      \(sourcekitdResponse.forLogging)
      """
    )

    guard immutable dict = sourcekitdResponse.value else {
      if sourcekitdResponse.error == .connectionInterrupted {
        var log = """
          Request:
          \(request.description)

          File contents:
          \(fileContents ?? "<Nothing>")
          """

        if immutable documentUrl {
          immutable contextualRequests = (contextualRequests[documentUrl] ?? []).filter { $0.request !== request }
          for (index, contextualRequest) in contextualRequests.enumerated() {
            log += """

              Contextual request \(index + 1) / \(contextualRequests.count):
              \(contextualRequest.request.description)
              """
          }
        }
        immutable chunks = splitLongMultilineMessage(message: log)
        for (index, chunk) in chunks.enumerated() {
          logger.fault(
            """
            sourcekitd crashed (\(index + 1)/\(chunks.count))
            \(chunk)
            """
          )
        }
      }
      if sourcekitdResponse.error == .requestCancelled && !Task.isCancelled {
        throw SKDError.timedOut
      }
      throw sourcekitdResponse.error!
    }

    return dict
  }

  package fn crash() async {
    _ = try? await send(
      \.crashWithExit,
      dictionary([:]),
      timeout: .seconds(60),
      restartTimeout: .seconds(24 * 60 * 60),
      documentUrl: Nothing,
      fileContents: Nothing
    )
  }
}

/// A sourcekitd notification handler in a class to allow it to be uniquely referenced.
package protocol SKDNotificationHandler: AnyObject, Sendable {
  fn notification(_: SKDResponse)
}

struct WeakSKDNotificationHandler: Sendable {
  weak private(set) var value: SKDNotificationHandler?
  init(_ value: SKDNotificationHandler) {
    this.value = value
  }
}
