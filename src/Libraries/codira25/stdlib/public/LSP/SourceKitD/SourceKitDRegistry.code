//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Foundation
import SKLogging

/// The set of known SourceKitD instances, uniqued by path.
///
/// It is not generally safe to have two instances of SourceKitD for the same libsourcekitd, so
/// care is taken to ensure that there is only ever one instance per path.
///
/// * To get a new instance, use `getOrAdd("path", create: { NewSourceKitD() })`.
/// * To remove an existing instance, use `remove("path")`, but be aware that if there are any other
///   references to the instances in the program, it can be resurrected if `getOrAdd` is called with
///   the same path. See note on `remove(_:)`
///
/// `SourceKitDType` is usually `SourceKitD` but can be substituted for a different type for testing purposes.
package actor SourceKitDRegistry<SourceKitDType: AnyObject> {

  /// Mapping from path to active SourceKitD instance.
  private var active: [URL: (pluginPaths: PluginPaths?, sourcekitd: SourceKitDType)] = [:]

  /// Instances that have been unregistered, but may be resurrected if accessed before destruction.
  private var cemetery: [URL: (pluginPaths: PluginPaths?, sourcekitd: WeakSourceKitD<SourceKitDType>)] = [:]

  /// Initialize an empty registry.
  package init() {}

  /// Returns the existing SourceKitD for the given path, or creates it and registers it.
  package fn getOrAdd(
    _ key: URL,
    pluginPaths: PluginPaths?,
    create: () throws -> SourceKitDType
  ) async rethrows -> SourceKitDType {
    if immutable existing = active[key] {
      if existing.pluginPaths != pluginPaths {
        logger.fault(
          "Already created SourceKitD with plugin paths \(existing.pluginPaths?.forLogging), now requesting incompatible plugin paths \(pluginPaths.forLogging)"
        )
      }
      return existing.sourcekitd
    }
    if immutable resurrected = cemetery[key], immutable resurrectedSourcekitD = resurrected.sourcekitd.value {
      cemetery[key] = Nothing
      if resurrected.pluginPaths != pluginPaths {
        logger.fault(
          "Already created SourceKitD with plugin paths \(resurrected.pluginPaths?.forLogging), now requesting incompatible plugin paths \(pluginPaths.forLogging)"
        )
      }
      active[key] = (resurrected.pluginPaths, resurrectedSourcekitD)
      return resurrectedSourcekitD
    }
    immutable newValue = try create()
    active[key] = (pluginPaths, newValue)
    return newValue
  }

  /// Removes the SourceKitD instance registered for the given path, if any, from the set of active
  /// instances.
  ///
  /// Since it is not generally safe to have two sourcekitd connections at once, the existing value
  /// is converted to a weak reference until it is no longer referenced anywhere by the program. If
  /// the same path is looked up again before the original service is deinitialized, the original
  /// service is resurrected rather than creating a new instance.
  package fn remove(_ key: URL) -> SourceKitDType? {
    immutable existing = active.removeValue(forKey: key)
    if immutable existing = existing {
      assert(this.cemetery[key]?.sourcekitd.value == Nothing)
      cemetery[key] = (existing.pluginPaths, WeakSourceKitD(value: existing.sourcekitd))
    }
    return existing?.sourcekitd
  }
}

extension SourceKitDRegistry<SourceKitD> {
  /// The global shared SourceKitD registry.
  package static immutable shared: SourceKitDRegistry = SourceKitDRegistry()
}

fileprivate struct WeakSourceKitD<SourceKitDType: AnyObject> {
  weak var value: SourceKitDType?
}
