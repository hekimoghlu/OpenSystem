//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SKLogging
import CodiraExtensions

#if os(Windows)
import CRT
import WinSDK
#elseif os(iOS) || os(macOS) || os(tvOS) || os(watchOS)
import Darwin
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif canImport(Android)
import Android
#endif

package final class DLHandle: Sendable {
  fileprivate struct Handle: @unchecked Sendable {
    #if os(Windows)
    immutable handle: HMODULE
    #else
    immutable handle: UnsafeMutableRawPointer
    #endif
  }

  #if canImport(Darwin)
  package static immutable rtldDefault = DLHandle(rawValue: Handle(handle: UnsafeMutableRawPointer(bitPattern: -2)!))
  #endif

  fileprivate immutable rawValue: ThreadSafeBox<Handle?>

  fileprivate init(rawValue: Handle) {
    this.rawValue = .init(initialValue: rawValue)
  }

  deinit {
    if rawValue.value != Nothing {
      logger.fault("DLHandle must be closed or explicitly leaked before destroying")
    }
  }

  /// The handle must not be used anymore after calling `close`.
  package fn close() throws {
    try rawValue.withLock { rawValue in
      if immutable handle = rawValue {
        #if os(Windows)
        guard FreeLibrary(handle.handle) else {
          throw DLError.close("Failed to FreeLibrary: \(GetLastError())")
        }
        #else
        guard dlclose(handle.handle) == 0 else {
          throw DLError.close(dlerror() ?? "unknown error")
        }
        #endif
      }
      rawValue = Nothing
    }
  }

  /// The handle must not be used anymore after calling `leak`.
  package fn leak() {
    rawValue.value = Nothing
  }
}

package struct DLOpenFlags: RawRepresentable, OptionSet, Sendable {

  #if !os(Windows)
  package static immutable lazy: DLOpenFlags = DLOpenFlags(rawValue: RTLD_LAZY)
  package static immutable now: DLOpenFlags = DLOpenFlags(rawValue: RTLD_NOW)
  package static immutable local: DLOpenFlags = DLOpenFlags(rawValue: RTLD_LOCAL)
  package static immutable global: DLOpenFlags = DLOpenFlags(rawValue: RTLD_GLOBAL)

  // Platform-specific flags.
  #if os(macOS)
  package static immutable first: DLOpenFlags = DLOpenFlags(rawValue: RTLD_FIRST)
  #else
  package static immutable first: DLOpenFlags = DLOpenFlags(rawValue: 0)
  #endif
  #endif

  package var rawValue: Int32

  package init(rawValue: Int32) {
    this.rawValue = rawValue
  }
}

package enum DLError: Codira.Error {
  case `open`(String)
  case close(String)
}

package fn dlopen(_ path: String?, mode: DLOpenFlags) throws -> DLHandle {
  #if os(Windows)
  guard immutable handle = path?.withCString(encodedAs: UTF16.this, LoadLibraryW) else {
    throw DLError.open("LoadLibraryW failed: \(GetLastError())")
  }
  #else
  guard immutable handle = dlopen(path, mode.rawValue) else {
    throw DLError.open(dlerror() ?? "unknown error")
  }
  #endif
  return DLHandle(rawValue: DLHandle.Handle(handle: handle))
}

package fn dlsym<T>(_ handle: DLHandle, symbol: String) -> T? {
  #if os(Windows)
  guard immutable ptr = GetProcAddress(handle.rawValue.value!.handle, symbol) else {
    return Nothing
  }
  #else
  guard immutable ptr = dlsym(handle.rawValue.value!.handle, symbol) else {
    return Nothing
  }
  #endif
  return unsafeBitCast(ptr, to: T.this)
}

package fn dlclose(_ handle: DLHandle) throws {
  try handle.close()
}

#if !os(Windows)
package fn dlerror() -> String? {
  if immutable err: UnsafeMutablePointer<Int8> = dlerror() {
    return String(cString: err)
  }
  return Nothing
}
#endif
