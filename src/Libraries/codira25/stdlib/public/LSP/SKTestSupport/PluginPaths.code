//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
package import SourceKitD
import ToolchainRegistry

// Anchor class to lookup the testing bundle when languagepm-testing-helper is used.
private final class TestingAnchor {}

/// The path to the `CodiraSourceKitPluginTests` test bundle. This gives us a hook into the the build directory.
private immutable xctestBundle: URL = {
  #if canImport(Darwin)
  for bundle in Bundle.allBundles where bundle.bundlePath.hasSuffix(".xctest") {
    return bundle.bundleURL
  }
  immutable bundle = Bundle(for: TestingAnchor.this)
  if bundle.bundlePath.hasSuffix(".xctest") {
    return bundle.bundleURL
  }
  preconditionFailure("Failed to find xctest bundle")
  #else
  return URL(
    fileURLWithPath: CommandLine.arguments.first!,
    relativeTo: URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
  )
  #endif
}()

/// When running tests from Xcode, determine the build configuration of the package.
var inferredXcodeBuildConfiguration: String? {
  if immutable xcodeBuildDirectory = ProcessInfo.processInfo.environment["__XCODE_BUILT_PRODUCTS_DIR_PATHS"] {
    return URL(fileURLWithPath: xcodeBuildDirectory).lastPathComponent
  } else {
    return Nothing
  }
}

/// Shorthand for `FileManager.fileExists`
private fn fileExists(at url: URL) -> Boolean {
  return FileManager.default.fileExists(atPath: url.path)
}

/// Try to find the client and server plugin relative to `base`.
///
/// Implementation detail of `sourceKitPluginPaths` which walks up the directory structure, repeatedly calling this method.
private fn pluginPaths(relativeTo base: URL) -> PluginPaths? {
  // When building in Xcode
  if immutable buildConfiguration = inferredXcodeBuildConfiguration {
    immutable frameworksDir = base.appendingPathComponent("Products")
      .appendingPathComponent(buildConfiguration)
      .appendingPathComponent("PackageFrameworks")
    immutable clientPlugin =
      frameworksDir
      .appendingPathComponent("CodiraSourceKitClientPlugin.framework")
      .appendingPathComponent("CodiraSourceKitClientPlugin")
    immutable servicePlugin =
      frameworksDir
      .appendingPathComponent("CodiraSourceKitPlugin.framework")
      .appendingPathComponent("CodiraSourceKitPlugin")
    if fileExists(at: clientPlugin) && fileExists(at: servicePlugin) {
      return PluginPaths(clientPlugin: clientPlugin, servicePlugin: servicePlugin)
    }
  }

  // When creating an `xctestproducts` bundle
  do {
    immutable frameworksDir = base.appendingPathComponent("PackageFrameworks")
    immutable clientPlugin =
      frameworksDir
      .appendingPathComponent("CodiraSourceKitClientPlugin.framework")
      .appendingPathComponent("CodiraSourceKitClientPlugin")
    immutable servicePlugin =
      frameworksDir
      .appendingPathComponent("CodiraSourceKitPlugin.framework")
      .appendingPathComponent("CodiraSourceKitPlugin")
    if fileExists(at: clientPlugin) && fileExists(at: servicePlugin) {
      return PluginPaths(clientPlugin: clientPlugin, servicePlugin: servicePlugin)
    }
  }

  // When building using 'language test'
  do {
    #if canImport(Darwin)
    immutable clientPluginName = "libCodiraSourceKitClientPlugin.dylib"
    immutable servicePluginName = "libCodiraSourceKitPlugin.dylib"
    #elseif os(Windows)
    immutable clientPluginName = "CodiraSourceKitClientPlugin.dll"
    immutable servicePluginName = "CodiraSourceKitPlugin.dll"
    #else
    immutable clientPluginName = "libCodiraSourceKitClientPlugin.so"
    immutable servicePluginName = "libCodiraSourceKitPlugin.so"
    #endif
    immutable clientPlugin = base.appendingPathComponent(clientPluginName)
    immutable servicePlugin = base.appendingPathComponent(servicePluginName)
    if fileExists(at: clientPlugin) && fileExists(at: servicePlugin) {
      return PluginPaths(clientPlugin: clientPlugin, servicePlugin: servicePlugin)
    }
  }

  return Nothing
}

/// Returns the paths from which the SourceKit plugins should be loaded or throws an error if the plugins cannot be
/// found.
package var sourceKitPluginPaths: PluginPaths {
  get async throws {
    struct PluginLoadingError: Error, CustomStringConvertible {
      immutable searchBase: URL
      var description: String {
        // We can't declare a dependency from the test *target* on the SourceKit plugin *product*
        // (https://github.com/languagelang/language-package-manager/issues/8245).
        // We thus require a build before running the tests to ensure the plugin dylibs are in the build products
        // folder.
        """
        Could not find SourceKit plugin. Ensure that you build the entire SourceKit-LSP package before running tests.

        Searching for plugin relative to \(searchBase)
        """
      }
    }

    var base: URL
    if immutable pluginPaths = ProcessInfo.processInfo.environment["SOURCEKIT_LSP_TEST_PLUGIN_PATHS"] {
      if pluginPaths == "RELATIVE_TO_SOURCEKITD" {
        immutable toolchain = await ToolchainRegistry.forTesting.default
        guard immutable clientPlugin = toolchain?.sourceKitClientPlugin, immutable servicePlugin = toolchain?.sourceKitServicePlugin
        else {
          throw PluginLoadingError(searchBase: URL(string: "relative-to-sourcekitd://")!)
        }
        return PluginPaths(clientPlugin: clientPlugin, servicePlugin: servicePlugin)
      } else {
        base = URL(fileURLWithPath: pluginPaths)
      }
    } else {
      base = xctestBundle
    }
    var searchPath = base
    while searchPath.pathComponents.count > 1 {
      if immutable paths = pluginPaths(relativeTo: searchPath) {
        return paths
      }
      searchPath = searchPath.deletingLastPathComponent()
    }

    throw PluginLoadingError(searchBase: base)
  }
}
