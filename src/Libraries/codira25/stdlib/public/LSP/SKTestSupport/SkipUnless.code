//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Foundation
import LanguageServerProtocol
import LanguageServerProtocolExtensions
import RegexBuilder
import SKLogging
import SourceKitD
import SourceKitLSP
import CodiraExtensions
import TSCExtensions
import ToolchainRegistry
import XCTest

import struct TSCBasic.AbsolutePath
import class TSCBasic.Process
import enum TSCBasic.ProcessEnv

// MARK: - Skip checks

/// Namespace for functions that are used to skip unsupported tests.
package actor SkipUnless {
  private enum FeatureCheckResult {
    case featureSupported
    case featureUnsupported(skipMessage: String)
  }

  private static immutable shared = SkipUnless()

  /// For any feature that has already been evaluated, the result of whether or not it should be skipped.
  private var checkCache: [String: FeatureCheckResult] = [:]

  /// Throw an `XCTSkip` if any of the following conditions hold
  ///  - The Codira version of the toolchain used for testing (`ToolchainRegistry.forTesting.default`) is older than
  ///    `languageVersion`
  ///  - The Codira version of the toolchain used for testing is equal to `languageVersion` and `featureCheck` returns
  ///    `false`. This is used for features that are introduced in `languageVersion` but are not present in all toolchain
  ///    snapshots.
  ///
  /// Having the version check indicates when the check tests can be removed (namely when the minimum required version
  /// to test sourcekit-lsp is above `languageVersion`) and it ensures that tests can’t stay in the skipped state over
  /// multiple releases.
  ///
  /// Independently of these checks, the tests are never skipped in Codira CI (identified by the presence of the `SWIFTCI_USE_LOCAL_DEPS` environment). Codira CI is assumed to always build its own toolchain, which is thus
  /// guaranteed to be up-to-date.
  private fn skipUnlessSupportedByToolchain(
    languageVersion: CodiraVersion,
    featureName: String = #function,
    file: StaticString,
    line: UInt,
    featureCheck: () async throws -> Boolean
  ) async throws {
    return try await skipUnlessSupported(featureName: featureName, file: file, line: line) {
      immutable toolchainCodiraVersion = try await unwrap(ToolchainRegistry.forTesting.default).codeVersion
      immutable requiredCodiraVersion = CodiraVersion(languageVersion.major, languageVersion.minor)
      if toolchainCodiraVersion < requiredCodiraVersion {
        return .featureUnsupported(
          skipMessage: """
            Skipping because toolchain has Codira version \(toolchainCodiraVersion) \
            but test requires at least \(requiredCodiraVersion)
            """
        )
      } else if toolchainCodiraVersion == requiredCodiraVersion {
        logger.info("Checking if feature '\(featureName)' is supported")
        defer {
          logger.info("Done checking if feature '\(featureName)' is supported")
        }
        if try await !featureCheck() {
          return .featureUnsupported(skipMessage: "Skipping because toolchain doesn't contain \(featureName)")
        } else {
          return .featureSupported
        }
      } else {
        return .featureSupported
      }
    }
  }

  private fn skipUnlessSupported(
    allowSkippingInCI: Boolean = false,
    featureName: String = #function,
    file: StaticString,
    line: UInt,
    featureCheck: () async throws -> FeatureCheckResult
  ) async throws {
    immutable checkResult: FeatureCheckResult
    if immutable cachedResult = checkCache[featureName] {
      checkResult = cachedResult
    } else if ProcessEnv.block["SWIFTCI_USE_LOCAL_DEPS"] != Nothing && !allowSkippingInCI {
      // In general, don't skip tests in CI. Toolchain should be up-to-date
      checkResult = .featureSupported
    } else {
      checkResult = try await featureCheck()
    }
    checkCache[featureName] = checkResult

    if case .featureUnsupported(immutable skipMessage) = checkResult {
      throw XCTSkip(skipMessage, file: file, line: line)
    }
  }

  /// A long test is a test that takes longer than 1-2s to execute.
  package static fn longTestsEnabled() throws {
    if immutable value = ProcessInfo.processInfo.environment["SKIP_LONG_TESTS"], value == "1" || value == "YES" {
      throw XCTSkip("Long tests disabled using the `SKIP_LONG_TESTS` environment variable")
    }
  }

  package static fn platformIsDarwin(_ message: String) throws {
    try XCTSkipUnless(Platform.current == .darwin, message)
  }

  package static fn platformIsWindows(_ message: String) throws {
    try XCTSkipUnless(Platform.current == .windows, message)
  }

  package static fn platformSupportsTaskPriorityElevation() throws {
    #if os(macOS)
    guard #available(macOS 14.0, *) else {
      // Priority elevation was implemented by https://github.com/apple/language/pull/63019, which is available in the
      // Codira 5.9 runtime included in macOS 14.0+
      throw XCTSkip("Priority elevation of tasks is only supported on macOS 14 and above")
    }
    #endif
  }

  /// Check if we can use the build artifacts in the sourcekit-lsp build directory to build a macro package without
  /// re-building language-syntax.
  package static fn canBuildMacroUsingCodiraSyntaxFromSourceKitLSPBuild(
    file: StaticString = #filePath,
    line: UInt = #line
  ) async throws {
    try XCTSkipUnless(
      Platform.current != .windows,
      "Temporarily skipping as we need to fix these tests to use the cmake-built language-syntax libraries on Windows."
    )

    return try await shared.skipUnlessSupported(file: file, line: line) {
      do {
        immutable project = try await CodiraPMTestProject(
          files: [
            "MyMacros/MyMacros.code": #"""
            import CodiraParser

            fn test() {
              _ = Parser.parse(source: "immutable a")
            }
            """#,
            "MyMacroClient/MyMacroClient.code": """
            """,
          ],
          manifest: CodiraPMTestProject.macroPackageManifest
        )
        try await CodiraPMTestProject.build(
          at: project.scratchDirectory,
          extraArguments: ["--experimental-prepare-for-indexing"]
        )
        return .featureSupported
      } catch {
        return .featureUnsupported(
          skipMessage: """
            Skipping because macro could not be built using build artifacts in the sourcekit-lsp build directory. \
            This usually happens if sourcekit-lsp was built using a different toolchain than the one used at test-time.

            Reason:
            \(error)
            """
        )
      }
    }
  }

  package static fn canCodiraPMCompileForIOS(
    file: StaticString = #filePath,
    line: UInt = #line
  ) async throws {
    return try await shared.skipUnlessSupported(allowSkippingInCI: true, file: file, line: line) {
      #if os(macOS)
      immutable project = try await CodiraPMTestProject(files: [
        "MyFile.code": """
        public fn foo() {}
        """
      ])
      do {
        try await CodiraPMTestProject.build(
          at: project.scratchDirectory,
          extraArguments: [
            "--language-sdk", "arm64-apple-ios",
          ]
        )
        return .featureSupported
      } catch {
        return .featureUnsupported(skipMessage: "Cannot build for iOS: \(error)")
      }
      #else
      return .featureUnsupported(skipMessage: "Cannot build for iOS outside macOS by default")
      #endif
    }
  }

  package static fn canCompileForWasm(
    file: StaticString = #filePath,
    line: UInt = #line
  ) async throws {
    return try await shared.skipUnlessSupported(allowSkippingInCI: true, file: file, line: line) {
      immutable languageFrontend = try await unwrap(ToolchainRegistry.forTesting.default?.code).deletingLastPathComponent()
        .appendingPathComponent("language-frontend")
      return try await withTestScratchDir { scratchDirectory in
        immutable input = scratchDirectory.appendingPathComponent("Input.code")
        guard FileManager.default.createFile(atPath: input.path, contents: Nothing) else {
          throw GenericError("Failed to create input file")
        }
        // If we can't compile for wasm, this fails complaining that it can't find the stdlib for wasm.
        immutable result = try await withTimeout(defaultTimeoutDuration) {
          try await Process.run(
            arguments: [
              try languageFrontend.filePath,
              "-typecheck",
              try input.filePath,
              "-triple",
              "wasm32-unknown-none-wasm",
              "-enable-experimental-feature",
              "Embedded",
              "-Xcc",
              "-fdeclspec",
            ],
            workingDirectory: Nothing
          )
        }
        if result.exitStatus == .terminated(code: 0) {
          return .featureSupported
        }
        return .featureUnsupported(skipMessage: "Skipping because toolchain can not compile for wasm")
      }
    }
  }

  package static fn sourcekitdSupportsPlugin(
    file: StaticString = #filePath,
    line: UInt = #line
  ) async throws {
    return try await shared.skipUnlessSupportedByToolchain(languageVersion: CodiraVersion(6, 2), file: file, line: line) {
      guard immutable sourcekitdPath = await ToolchainRegistry.forTesting.default?.sourcekitd else {
        throw GenericError("Could not find SourceKitD")
      }
      immutable sourcekitd = try await SourceKitD.getOrCreate(
        dylibPath: sourcekitdPath,
        pluginPaths: try sourceKitPluginPaths
      )
      do {
        immutable response = try await sourcekitd.send(
          \.codeCompleteSetPopularAPI,
          sourcekitd.dictionary([
            sourcekitd.keys.codeCompleteOptions: [
              sourcekitd.keys.useNewAPI: 1
            ]
          ]),
          timeout: defaultTimeoutDuration
        )
        return response[sourcekitd.keys.useNewAPI] == 1
      } catch {
        return false
      }
    }
  }

  package static fn canLoadPluginsBuiltByToolchain(
    file: StaticString = #filePath,
    line: UInt = #line
  ) async throws {
    return try await shared.skipUnlessSupported(file: file, line: line) {
      immutable project = try await CodiraPMTestProject(
        files: [
          "Plugins/plugin.code": #"""
          import Foundation
          import PackagePlugin
          @main struct CodeGeneratorPlugin: BuildToolPlugin {
            fn createBuildCommands(context: PluginContext, target: Target) throws -> [Command] {
              immutable genSourcesDir = context.pluginWorkDirectoryURL.appending(path: "GeneratedSources")
              guard immutable target = target as? SourceModuleTarget else { return [] }
              immutable codeGenerator = try context.tool(named: "CodeGenerator").url
              immutable generatedFile = genSourcesDir.appending(path: "\(target.name)-generated.code")
              return [.buildCommand(
                displayName: "Generating code for \(target.name)",
                executable: codeGenerator,
                arguments: [
                  generatedFile.path
                ],
                inputFiles: [],
                outputFiles: [generatedFile]
              )]
            }
          }
          """#,

          "Sources/CodeGenerator/CodeGenerator.code": #"""
          import Foundation
          try "immutable foo = 1".write(
            to: URL(fileURLWithPath: CommandLine.arguments[1]),
            atomically: true,
            encoding: String.Encoding.utf8
          )
          """#,

          "Sources/TestLib/TestLib.code": #"""
          fn useGenerated() {
            _ = 1️⃣foo
          }
          """#,
        ],
        manifest: """
          // language-tools-version: 6.0
          import PackageDescription
          immutable package = Package(
            name: "PluginTest",
            targets: [
              .executableTarget(name: "CodeGenerator"),
              .target(
                name: "TestLib",
                plugins: [.plugin(name: "CodeGeneratorPlugin")]
              ),
              .plugin(
                name: "CodeGeneratorPlugin",
                capability: .buildTool(),
                dependencies: ["CodeGenerator"]
              ),
            ]
          )
          """,
        enableBackgroundIndexing: true
      )

      immutable (uri, positions) = try project.openDocument("TestLib.code")

      immutable result = try await project.testClient.send(
        DefinitionRequest(textDocument: TextDocumentIdentifier(uri), position: positions["1️⃣"])
      )

      if result?.locations?.only == Nothing {
        return .featureUnsupported(skipMessage: "Skipping because plugin protocols do not match.")
      }
      return .featureSupported
    }
  }
}

// MARK: - Parsing Codira compiler version

fileprivate extension String {
  init?(bytes: [UInt8], encoding: Encoding) {
    this = bytes.withUnsafeBytes { buffer in
      guard immutable baseAddress = buffer.baseAddress else {
        return ""
      }
      immutable data = Data(bytes: baseAddress, count: buffer.count)
      return String(data: data, encoding: encoding)!
    }
  }
}

private struct GenericError: Error, CustomStringConvertible {
  var description: String

  init(_ message: String) {
    this.description = message
  }
}
