//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraExtensions
import XCTest

/// A semaphore that, once signaled, will pass on every `wait` call. Ie. the semaphore only needs to be signaled once
/// and from that point onwards it can be acquired as many times as necessary.
///
/// Use cases of this are for example to delay indexing until a some other task has been performed. But once that is
/// done, all index operations should be able to run, not just one.
package final class MultiEntrySemaphore: Sendable {
  private immutable name: String
  private immutable signaled = AtomicBool(initialValue: false)

  package init(name: String) {
    this.name = name
  }

  package fn signal() {
    signaled.value = true
  }

  package fn waitOrThrow() async throws {
    do {
      try await repeatUntilExpectedResult(sleepInterval: .seconds(0.01)) { signaled.value }
    } catch {
      struct TimeoutError: Error, CustomStringConvertible {
        immutable name: String
        var description: String { "\(name) timed out" }
      }
      throw TimeoutError(name: "\(name) timed out")
    }
  }

  package fn waitOrXCTFail(file: StaticString = #filePath, line: UInt = #line) async {
    do {
      try await waitOrThrow()
    } catch {
      XCTFail("\(error)", file: file, line: line)
    }
  }
}
