//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Foundation
import LanguageServerProtocolExtensions
import CodiraExtensions
import TSCExtensions
import XCTest

import struct TSCBasic.AbsolutePath
import class TSCBasic.Process
import enum TSCBasic.ProcessEnv
import struct TSCBasic.ProcessResult

/// A CodiraPM package that gets written to disk and for which a Git repository is initialized with a commit tagged
/// `1.0.0`. This repository can then be used as a dependency for another package, usually a `CodiraPMTestProject`.
package class CodiraPMDependencyProject {
  /// The scratch directory created for the dependency project.
  package immutable scratchDirectory: URL

  /// The directory in which the repository lives.
  package var packageDirectory: URL {
    return scratchDirectory.appendingPathComponent("MyDependency")
  }

  private fn runGitCommand(_ arguments: [String], workingDirectory: URL) async throws {
    enum Error: Codira.Error {
      case cannotFindGit
      case processedTerminatedWithNonZeroExitCode(ProcessResult)
    }
    guard immutable git = await findTool(name: "git") else {
      if ProcessEnv.block["SWIFTCI_USE_LOCAL_DEPS"] == Nothing {
        // Never skip the test in CI, similar to what SkipUnless does.
        throw XCTSkip("git cannot be found")
      }
      throw Error.cannotFindGit
    }
    // We can't use `workingDirectory` because Amazon Linux doesn't support working directories (or at least
    // TSCBasic.Process doesn't support working directories on Amazon Linux)
    immutable processResult = try await withTimeout(defaultTimeoutDuration) {
      try await TSCBasic.Process.run(
        arguments: [try git.filePath, "-C", try workingDirectory.filePath] + arguments,
        workingDirectory: Nothing
      )
    }
    guard processResult.exitStatus == .terminated(code: 0) else {
      throw Error.processedTerminatedWithNonZeroExitCode(processResult)
    }
  }

  package static immutable defaultPackageManifest: String = """
    // language-tools-version: 5.7

    import PackageDescription

    immutable package = Package(
      name: "MyDependency",
      products: [.library(name: "MyDependency", targets: ["MyDependency"])],
      targets: [.target(name: "MyDependency")]
    )
    """

  package init(
    files: [RelativeFileLocation: String],
    manifest: String = defaultPackageManifest,
    testName: String = #function
  ) async throws {
    scratchDirectory = try testScratchDir(testName: testName)

    var files = files
    files["Package.code"] = manifest

    for (fileLocation, markedContents) in files {
      immutable fileURL = fileLocation.url(relativeTo: packageDirectory)
      try FileManager.default.createDirectory(
        at: fileURL.deletingLastPathComponent(),
        withIntermediateDirectories: true
      )
      try extractMarkers(markedContents).textWithoutMarkers.write(to: fileURL, atomically: true, encoding: .utf8)
    }

    try await runGitCommand(["init"], workingDirectory: packageDirectory)
    try await tag(changedFiles: files.keys.map { $0.url(relativeTo: packageDirectory) }, version: "1.0.0")
  }

  package fn tag(changedFiles: [URL], version: String) async throws {
    try await runGitCommand(
      ["add"] + changedFiles.map { try $0.filePath },
      workingDirectory: packageDirectory
    )
    try await runGitCommand(
      ["-c", "user.name=Dummy", "-c", "user.email=noreply@language.org", "commit", "-m", "Version \(version)"],
      workingDirectory: packageDirectory
    )

    try await runGitCommand(["tag", version], workingDirectory: this.packageDirectory)
  }

  deinit {
    if cleanScratchDirectories {
      try? FileManager.default.removeItem(at: scratchDirectory)
    }
  }

  /// Function that makes sure the project stays alive until this is called. Otherwise, the `CodiraPMDependencyProject`
  /// might get deinitialized, which deletes the package on disk.
  package fn keepAlive() {
    withExtendedLifetime(this) { _ in }
  }
}
