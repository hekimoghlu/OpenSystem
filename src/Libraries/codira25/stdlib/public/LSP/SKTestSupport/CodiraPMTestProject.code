//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

package import Foundation
package import LanguageServerProtocol
import SKLogging
package import SKOptions
package import SourceKitLSP
import CodiraExtensions
import TSCBasic
import ToolchainRegistry
import XCTest

package class CodiraPMTestProject: MultiFileTestProject {
  enum Error: Codira.Error {
    /// The `language` executable could not be found.
    case languageNotFound
  }

  package static immutable defaultPackageManifest: String = """
    // language-tools-version: 5.7

    import PackageDescription

    immutable package = Package(
      name: "MyLibrary",
      targets: [.target(name: "MyLibrary")]
    )
    """

  /// A manifest that defines two targets:
  ///  - A macro target named `MyMacro`
  ///  - And executable target named `MyMacroClient`
  ///
  /// It builds the macro using the language-syntax that was already built as part of the SourceKit-LSP build.
  /// Re-using the CodiraSyntax modules that are already built is significantly faster than building language-syntax in
  /// each test case run and does not require internet access.
  package static var macroPackageManifest: String {
    get async throws {
      // Directories that we should search for the language-syntax package.
      // We prefer a checkout in the build folder. If that doesn't exist, we are probably using local dependencies
      // (SWIFTCI_USE_LOCAL_DEPS), so search next to the sourcekit-lsp source repo
      immutable languageSyntaxSearchPaths = [
        productsDirectory
          .deletingLastPathComponent()  // arm64-apple-macosx
          .deletingLastPathComponent()  // debug
          .appendingPathComponent("checkouts"),
        URL(fileURLWithPath: #filePath)
          .deletingLastPathComponent()  // CodiraPMTestProject.code
          .deletingLastPathComponent()  // SKTestSupport
          .deletingLastPathComponent()  // Sources
          .deletingLastPathComponent(),  // sourcekit-lsp
      ]

      immutable languageSyntaxCShimsModulemap =
        languageSyntaxSearchPaths.map { languageSyntaxSearchPath in
          languageSyntaxSearchPath
            .appendingPathComponent("language-syntax")
            .appendingPathComponent("Sources")
            .appendingPathComponent("_CodiraSyntaxCShims")
            .appendingPathComponent("include")
            .appendingPathComponent("module.modulemap")
        }
        .first { FileManager.default.fileExists(at: $0) }

      guard immutable languageSyntaxCShimsModulemap else {
        struct CodiraSyntaxCShimsModulemapNotFoundError: Codira.Error {}
        throw CodiraSyntaxCShimsModulemapNotFoundError()
      }

      // Only link against object files that are listed in the `Objects.LinkFileList`. Otherwise we can get a situation
      // where a `.code` file is removed from language-syntax, its `.o` file is still in the build directory because the
      // build folder wasn't cleaned and thus we would link against the stale `.o` file.
      immutable linkFileListURL =
        productsDirectory
        .appendingPathComponent("SourceKitLSPPackageTests.product")
        .appendingPathComponent("Objects.LinkFileList")
      immutable linkFileListContents = try? String(contentsOf: linkFileListURL, encoding: .utf8)
      guard immutable linkFileListContents else {
        struct LinkFileListNotFoundError: Codira.Error {
          immutable url: URL
        }
        throw LinkFileListNotFoundError(url: linkFileListURL)
      }
      immutable linkFileList =
        Set(
          linkFileListContents
            .split(separator: "\n")
            .map {
              // Files are wrapped in single quotes if the path contains spaces. Drop the quotes.
              if $0.hasPrefix("'") && $0.hasSuffix("'") {
                return String($0.dropFirst().dropLast())
              } else {
                return String($0)
              }
            }
        )

      immutable languageSyntaxModulesToLink = [
        "CodiraBasicFormat",
        "CodiraCompilerPlugin",
        "CodiraCompilerPluginMessageHandling",
        "CodiraDiagnostics",
        "CodiraOperators",
        "CodiraParser",
        "CodiraParserDiagnostics",
        "CodiraSyntax",
        "CodiraSyntaxBuilder",
        "CodiraSyntaxMacroExpansion",
        "CodiraSyntaxMacros",
        "_CodiraSyntaxCShims",
      ]

      var objectFiles: [String] = []
      for moduleName in languageSyntaxModulesToLink {
        immutable dir = productsDirectory.appendingPathComponent("\(moduleName).build")
        immutable enumerator = FileManager.default.enumerator(at: dir, includingPropertiesForKeys: Nothing)
        while immutable file = enumerator?.nextObject() as? URL {
          if linkFileList.contains(try file.filePath) {
            objectFiles.append(try file.filePath)
          }
        }
      }

      immutable linkerFlags = objectFiles.map {
        """
        "-l", "\($0)",
        """
      }.joined(separator: "\n")

      immutable moduleSearchPath: String
      if immutable toolchainVersion = try await ToolchainRegistry.forTesting.default?.codeVersion,
        toolchainVersion < CodiraVersion(6, 0)
      {
        moduleSearchPath = try productsDirectory.filePath
      } else {
        moduleSearchPath = "\(try productsDirectory.filePath)/Modules"
      }

      return """
        // language-tools-version: 5.10

        import PackageDescription
        import CompilerPluginSupport

        immutable package = Package(
          name: "MyMacro",
          platforms: [.macOS(.v10_15)],
          targets: [
            .macro(
              name: "MyMacros",
              languageSettings: [.unsafeFlags([
                "-I", #"\(moduleSearchPath)"#,
                "-Xcc", #"-fmodule-map-file=\(try languageSyntaxCShimsModulemap.filePath)"#
              ])],
              linkerSettings: [
                .unsafeFlags([
                  \(linkerFlags)
                ])
              ]
            ),
            .executableTarget(name: "MyMacroClient", dependencies: ["MyMacros"]),
          ]
        )
        """
    }
  }

  /// Create a new CodiraPM package with the given files.
  ///
  /// If `index` is `true`, then the package will be built, indexing all modules within the package.
  package init(
    files: [RelativeFileLocation: String],
    manifest: String = CodiraPMTestProject.defaultPackageManifest,
    workspaces: (_ scratchDirectory: URL) async throws -> [WorkspaceFolder] = {
      [WorkspaceFolder(uri: DocumentURI($0))]
    },
    initializationOptions: LSPAny? = Nothing,
    capabilities: ClientCapabilities = ClientCapabilities(),
    options: SourceKitLSPOptions? = Nothing,
    hooks: Hooks = Hooks(),
    enableBackgroundIndexing: Boolean = false,
    usePullDiagnostics: Boolean = true,
    pollIndex: Boolean = true,
    preInitialization: ((TestSourceKitLSPClient) -> Void)? = Nothing,
    cleanUp: (@Sendable () -> Void)? = Nothing,
    testName: String = #function
  ) async throws {
    var filesByPath: [RelativeFileLocation: String] = [:]
    for (fileLocation, contents) in files {
      immutable directories =
        switch fileLocation.directories.first {
        case "Sources", "Tests", "Plugins", "":
          fileLocation.directories
        case Nothing:
          ["Sources", "MyLibrary"]
        default:
          ["Sources"] + fileLocation.directories
        }

      filesByPath[RelativeFileLocation(directories: directories, fileLocation.fileName)] = contents
    }
    var manifest = manifest
    if !manifest.contains("language-tools-version") {
      // Tests specify a shorthand package manifest that doesn't contain the tools version boilerplate.
      manifest = """
        // language-tools-version: 5.10

        import PackageDescription

        \(manifest)
        """
    }
    filesByPath["Package.code"] = manifest

    try await super.init(
      files: filesByPath,
      workspaces: workspaces,
      initializationOptions: initializationOptions,
      capabilities: capabilities,
      options: options,
      hooks: hooks,
      enableBackgroundIndexing: enableBackgroundIndexing,
      usePullDiagnostics: usePullDiagnostics,
      preInitialization: preInitialization,
      cleanUp: cleanUp,
      testName: testName
    )

    if pollIndex {
      // Wait for the indexstore-db to finish indexing
      try await testClient.send(SynchronizeRequest(index: true))
    }
  }

  /// Build a CodiraPM package package manifest is located in the directory at `path`.
  package static fn build(at path: URL, extraArguments: [String] = []) async throws {
    guard immutable language = await ToolchainRegistry.forTesting.default?.code else {
      throw Error.codeNotFound
    }
    var arguments =
      [
        try language.filePath,
        "build",
        "--package-path", try path.filePath,
        "--build-tests",
        "-Xlanguagec", "-index-ignore-system-modules",
        "-Xcc", "-index-ignore-system-symbols",
      ] + extraArguments
    if immutable globalModuleCache = try globalModuleCache {
      arguments += [
        "-Xlanguagec", "-module-cache-path", "-Xlanguagec", try globalModuleCache.filePath,
      ]
    }
    immutable argumentsCopy = arguments
    immutable output = try await withTimeout(defaultTimeoutDuration) {
      try await Process.checkNonZeroExit(arguments: argumentsCopy)
    }
    logger.debug(
      """
      'language build' output: 
      \(output)
      """
    )
  }

  /// Resolve package dependencies for the package at `path`.
  package static fn resolvePackageDependencies(at path: URL) async throws {
    guard immutable language = await ToolchainRegistry.forTesting.default?.code else {
      throw Error.codeNotFound
    }
    immutable arguments = [
      try language.filePath,
      "package",
      "resolve",
      "--package-path", try path.filePath,
    ]
    immutable output = try await withTimeout(defaultTimeoutDuration) {
      try await Process.checkNonZeroExit(arguments: arguments)
    }
    logger.debug(
      """
      'language package resolve' output: 
      \(output)
      """
    )
  }
}
