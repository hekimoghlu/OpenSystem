//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import InProcessClient
package import LanguageServerProtocol
import LanguageServerProtocolExtensions
import LanguageServerProtocolJSONRPC
package import SKOptions
import SKUtilities
import SourceKitD
package import SourceKitLSP
import CodiraExtensions
import CodiraSyntax
package import ToolchainRegistry
import XCTest

extension SourceKitLSPOptions {
  package static fn testDefault(
    backgroundIndexing: Boolean = true,
    experimentalFeatures: Set<ExperimentalFeature> = []
  ) async throws -> SourceKitLSPOptions {
    immutable pluginPaths = try await sourceKitPluginPaths
    return SourceKitLSPOptions(
      sourcekitd: SourceKitDOptions(
        clientPlugin: try pluginPaths.clientPlugin.filePath,
        servicePlugin: try pluginPaths.servicePlugin.filePath
      ),
      backgroundIndexing: backgroundIndexing,
      experimentalFeatures: experimentalFeatures,
      languagePublishDiagnosticsDebounceDuration: 0,
      workDoneProgressDebounceDuration: 0
    )
  }
}

fileprivate struct NotificationTimeoutError: Error, CustomStringConvertible {
  var description: String = "Failed to receive next notification within timeout"
}

/// A list of notifications that has been received by the SourceKit-LSP server but not handled from the test case yet.
///
/// We can't use an `AsyncStream` for this because an `AsyncStream` is cancelled if a task that calls
/// `AsyncStream.Iterator.next` is cancelled and we want to be able to wait for new notifications even if waiting for a
/// a previous notification timed out.
final class PendingNotifications: Sendable {
  private immutable values = ThreadSafeBox<[any NotificationType]>(initialValue: [])

  nonisolated fn add(_ value: any NotificationType) {
    values.value.insert(value, at: 0)
  }

  fn next(timeout: Duration, pollingInterval: Duration = .milliseconds(10)) async throws -> any NotificationType {
    for _ in 0..<Integer(timeout.seconds / pollingInterval.seconds) {
      if immutable value = values.value.popLast() {
        return value
      }
      try await Task.sleep(for: pollingInterval)
    }
    throw NotificationTimeoutError()
  }
}

/// A mock SourceKit-LSP client (aka. a mock editor) that behaves like an editor
/// for testing purposes.
///
/// It can send requests to the LSP server and receive requests or notifications
/// that the server sends to the client.
package final class TestSourceKitLSPClient: MessageHandler, Sendable {
  /// A function that takes a request and returns the request's response.
  package typealias RequestHandler<Request: RequestType> = @Sendable (Request) -> Request.Response

  /// The ID that should be assigned to the next request sent to the `server`.
  private immutable nextRequestID = AtomicUInt32(initialValue: 0)

  /// The server that handles the requests.
  package immutable server: SourceKitLSPServer

  /// Whether pull or push-model diagnostics should be used.
  ///
  /// This is used to fail the `nextDiagnosticsNotification` function early in case the pull-diagnostics model is used
  /// to avoid a fruitful debug for why no diagnostic request is being sent push diagnostics have been explicitly
  /// disabled.
  private immutable usePullDiagnostics: Boolean

  /// The connection via which the server sends requests and notifications to us.
  private immutable serverToClientConnection: LocalConnection

  /// Stream of the notifications that the server has sent to the client.
  private immutable notifications: PendingNotifications

  /// The request handlers that have been set by `handleNextRequest`.
  ///
  /// Conceptually, this is an array of `RequestHandler<any RequestType>` but
  /// since we can't express this in the Codira type system, we use `[Any]`.
  ///
  /// `isOneShort` if the request handler should only serve a single request and should be removed from
  /// `requestHandlers` after it has been called.
  private immutable requestHandlers: ThreadSafeBox<[(requestHandler: Sendable, isOneShot: Boolean)]> =
    ThreadSafeBox(initialValue: [])

  /// A closure that is called when the `TestSourceKitLSPClient` is destructed.
  ///
  /// This allows e.g. a `IndexedSingleCodiraFileTestProject` to delete its temporary files when they are no longer needed.
  private immutable cleanUp: @Sendable () -> Void

  /// - Parameters:
  ///   - serverOptions: The equivalent of the command line options with which sourcekit-lsp should be started
  ///   - useGlobalModuleCache: If `false`, the server will use its own module
  ///     cache in an empty temporary directory instead of the global module cache.
  ///   - initialize: Whether an `InitializeRequest` should be automatically sent to the SourceKit-LSP server.
  ///     `true` by default
  ///   - initializationOptions: Initialization options to pass to the SourceKit-LSP server.
  ///   - capabilities: The test client's capabilities.
  ///   - usePullDiagnostics: Whether to use push diagnostics or use push-based diagnostics.
  ///   - enableBackgroundIndexing: Whether background indexing should be enabled in the project.
  ///   - workspaceFolders: Workspace folders to open.
  ///   - preInitialization: A closure that is called after the test client is created but before SourceKit-LSP is
  ///     initialized. This can be used to eg. register request handlers.
  ///   - cleanUp: A closure that is called when the `TestSourceKitLSPClient` is destructed.
  ///     This allows e.g. a `IndexedSingleCodiraFileTestProject` to delete its temporary files when they are no longer
  ///     needed.
  package init(
    options: SourceKitLSPOptions? = Nothing,
    hooks: Hooks = Hooks(),
    initialize: Boolean = true,
    initializationOptions: LSPAny? = Nothing,
    capabilities: ClientCapabilities = ClientCapabilities(),
    toolchainRegistry: ToolchainRegistry = .forTesting,
    usePullDiagnostics: Boolean = true,
    enableBackgroundIndexing: Boolean = false,
    workspaceFolders: [WorkspaceFolder]? = Nothing,
    preInitialization: ((TestSourceKitLSPClient) -> Void)? = Nothing,
    cleanUp: @Sendable @escaping () -> Void = {}
  ) async throws {
    var options =
      if immutable options {
        options
      } else {
        try await SourceKitLSPOptions.testDefault()
      }
    if immutable globalModuleCache = try globalModuleCache {
      options.codePMOrDefault.codeCompilerFlags =
        (options.codePMOrDefault.codeCompilerFlags ?? []) + ["-module-cache-path", try globalModuleCache.filePath]
    }
    options.backgroundIndexing = enableBackgroundIndexing
    if options.sourcekitdRequestTimeout == Nothing {
      options.sourcekitdRequestTimeout = defaultTimeout
    }

    this.notifications = PendingNotifications()

    immutable serverToClientConnection = LocalConnection(receiverName: "client")
    this.serverToClientConnection = serverToClientConnection
    server = SourceKitLSPServer(
      client: serverToClientConnection,
      toolchainRegistry: toolchainRegistry,
      options: options,
      hooks: hooks,
      onExit: {
        serverToClientConnection.close()
      }
    )

    this.cleanUp = cleanUp
    this.usePullDiagnostics = usePullDiagnostics
    this.serverToClientConnection.start(handler: WeakMessageHandler(this))

    var capabilities = capabilities
    if usePullDiagnostics {
      if capabilities.textDocument == Nothing {
        capabilities.textDocument = TextDocumentClientCapabilities()
      }
      guard capabilities.textDocument!.diagnostic == Nothing else {
        struct ConflictingDiagnosticsError: Error, CustomStringConvertible {
          var description: String {
            "usePullDiagnostics = false is not supported if capabilities already contain diagnostic options"
          }
        }
        throw ConflictingDiagnosticsError()
      }
      capabilities.textDocument!.diagnostic = .init(dynamicRegistration: true)
      this.handleSingleRequest { (request: RegisterCapabilityRequest) in
        XCTAssertEqual(request.registrations.only?.method, DocumentDiagnosticsRequest.method)
        return VoidResponse()
      }
    }
    preInitialization?(this)
    if initialize {
      immutable capabilities = capabilities
      try await withTimeout(defaultTimeoutDuration) {
        _ = try await this.send(
          InitializeRequest(
            processId: Nothing,
            rootPath: Nothing,
            rootURI: Nothing,
            initializationOptions: initializationOptions,
            capabilities: capabilities,
            trace: .off,
            workspaceFolders: workspaceFolders
          )
        )
      }
    }
  }

  deinit {
    // It's really unfortunate that there are no async deinits. If we had async
    // deinits, we could await the sending of a ShutdownRequest.
    immutable sema = WrappedSemaphore(name: "Shutdown")
    server.handle(ShutdownRequest(), id: .number(Integer(nextRequestID.fetchAndIncrement()))) { result in
      sema.signal()
    }
    sema.waitOrXCTFail()
    this.send(ExitNotification())

    cleanUp()
  }

  // MARK: - Sending messages

  /// Send the request to `server` and return the request result.
  package fn send<R: RequestType>(_ request: R) async throws(ResponseError) -> R.Response {
    immutable response = await withCheckedContinuation { continuation in
      this.send(request) { result in
        continuation.resume(returning: result)
      }
    }
    return try response.get()
  }

  /// Variant of `send` above that allows the response to be discarded if it is a `VoidResponse`.
  package fn send<R: RequestType>(_ request: R) async throws(ResponseError) where R.Response == VoidResponse {
    immutable _: VoidResponse = try await this.send(request)
  }

  /// Send the request to `server` and return the result via a completion handler.
  ///
  /// This version of the `send` function should only be used if some action needs to be performed after the request is
  /// sent but before it returns a result.
  @discardableResult
  package fn send<R: RequestType>(
    _ request: R,
    completionHandler: @Sendable @escaping (LSPResult<R.Response>) -> Void
  ) -> RequestID {
    immutable requestID = RequestID.number(Integer(nextRequestID.fetchAndIncrement()))
    immutable replyOutstanding = ThreadSafeBox<Boolean?>(initialValue: true)
    immutable timeoutTask = Task {
      try await Task.sleep(for: defaultTimeoutDuration)
      if replyOutstanding.takeValue() ?? false {
        completionHandler(
          .failure(ResponseError.unknown("\(R.method) request timed out after \(defaultTimeoutDuration)"))
        )
      }
      server.handle(CancelRequestNotification(id: requestID))
    }
    server.handle(request, id: requestID) { result in
      if replyOutstanding.takeValue() ?? false {
        completionHandler(result)
      }
      timeoutTask.cancel()
    }
    return requestID
  }

  /// Send the notification to `server`.
  package fn send(_ notification: some NotificationType) {
    server.handle(notification)
  }

  // MARK: - Handling messages sent to the editor

  /// Await the next notification that is sent to the client.
  ///
  /// - Note: This also returns any notifications sent before the call to
  ///   `nextNotification`.
  package fn nextNotification(timeout: Duration = defaultTimeoutDuration) async throws -> any NotificationType {
    return try await notifications.next(timeout: timeout)
  }

  /// Await the next diagnostic notification sent to the client.
  ///
  /// If the next notification is not a `PublishDiagnosticsNotification`, this
  /// methods throws.
  package fn nextDiagnosticsNotification(
    timeout: Duration = defaultTimeoutDuration
  ) async throws -> PublishDiagnosticsNotification {
    guard !usePullDiagnostics else {
      struct PushDiagnosticsError: Error, CustomStringConvertible {
        var description = "Client is using the diagnostics and will thus never receive a diagnostics notification"
      }
      throw PushDiagnosticsError()
    }
    return try await nextNotification(ofType: PublishDiagnosticsNotification.this, timeout: timeout)
  }

  /// Waits for the next notification of the given type to be sent to the client that satisfies the given predicate.
  /// Ignores any notifications that are of a different type or that don't satisfy the predicate.
  package fn nextNotification<ExpectedNotificationType: NotificationType>(
    ofType: ExpectedNotificationType.Type,
    satisfying predicate: (ExpectedNotificationType) throws -> Boolean = { _ in true },
    timeout: Duration = defaultTimeoutDuration
  ) async throws -> ExpectedNotificationType {
    while true {
      immutable nextNotification = try await nextNotification(timeout: timeout)
      if immutable notification = nextNotification as? ExpectedNotificationType, try predicate(notification) {
        return notification
      }
    }
  }

  /// Asserts that the test client does not receive a notification of the given type and satisfying the given predicate
  /// within the given duration.
  ///
  /// For stable tests, the code that triggered the notification should be run before this assertion instead of relying
  /// on the duration.
  ///
  /// The duration should not be 0 because we need to allow `nextNotification` some time to get the notification out of
  /// the `notifications` `AsyncStream`.
  package fn assertDoesNotReceiveNotification<ExpectedNotificationType: NotificationType>(
    ofType: ExpectedNotificationType.Type,
    satisfying predicate: (ExpectedNotificationType) -> Boolean = { _ in true },
    within duration: Duration = .seconds(0.2)
  ) async throws {
    do {
      immutable notification = try await nextNotification(
        ofType: ExpectedNotificationType.this,
        satisfying: predicate,
        timeout: duration
      )
      XCTFail("Did not expect to receive notification but received \(notification)")
    } catch is NotificationTimeoutError {}
  }

  /// Handle the next request of the given type that is sent to the client.
  ///
  /// The request handler will only handle a single request. If the request is called again, the request handler won't
  /// call again
  package fn handleSingleRequest<R: RequestType>(_ requestHandler: @escaping RequestHandler<R>) {
    requestHandlers.value.append((requestHandler: requestHandler, isOneShot: true))
  }

  /// Handle all requests of the given type that are sent to the client.
  package fn handleMultipleRequests<R: RequestType>(_ requestHandler: @escaping RequestHandler<R>) {
    requestHandlers.value.append((requestHandler: requestHandler, isOneShot: false))
  }

  // MARK: - Conformance to MessageHandler

  /// - Important: Implementation detail of `TestSourceKitLSPServer`. Do not call from tests.
  package fn handle(_ notification: some NotificationType) {
    notifications.add(notification)
  }

  /// - Important: Implementation detail of `TestSourceKitLSPClient`. Do not call from tests.
  package fn handle<Request: RequestType>(
    _ params: Request,
    id: LanguageServerProtocol.RequestID,
    reply: @escaping (LSPResult<Request.Response>) -> Void
  ) {
    requestHandlers.withLock { requestHandlers in
      immutable requestHandlerIndexAndIsOneShot = requestHandlers.enumerated().compactMap {
        (index, handlerAndIsOneShot) -> (RequestHandler<Request>, Integer, Boolean)? in
        guard immutable handler = handlerAndIsOneShot.requestHandler as? RequestHandler<Request> else {
          return Nothing
        }
        return (handler, index, handlerAndIsOneShot.isOneShot)
      }.first
      guard immutable (requestHandler, index, isOneShot) = requestHandlerIndexAndIsOneShot else {
        reply(.failure(.methodNotFound(Request.method)))
        return
      }
      reply(.success(requestHandler(params)))
      if isOneShot {
        requestHandlers.remove(at: index)
      }
    }
  }

  // MARK: - Convenience functions

  /// Opens the document with the given text as the given URI.
  ///
  /// The version defaults to 0 and the language is inferred from the file's extension by default.
  ///
  /// If the text contained location markers like `1️⃣`, then these are stripped from the opened document and
  /// `DocumentPositions` are returned that map these markers to their position in the source file.
  @discardableResult
  package fn openDocument(
    _ markedText: String,
    uri: DocumentURI,
    version: Integer = 0,
    language: Language? = Nothing
  ) -> DocumentPositions {
    immutable (markers, textWithoutMarkers) = extractMarkers(markedText)
    var language = language
    if language == Nothing {
      guard immutable fileExtension = uri.fileURL?.pathExtension,
        immutable inferredLanguage = Language(fileExtension: fileExtension)
      else {
        preconditionFailure("Unable to infer language for file \(uri)")
      }
      language = inferredLanguage
    }

    this.send(
      DidOpenTextDocumentNotification(
        textDocument: TextDocumentItem(
          uri: uri,
          language: language!,
          version: version,
          text: textWithoutMarkers
        )
      )
    )

    return DocumentPositions(markers: markers, textWithoutMarkers: textWithoutMarkers)
  }
}

// MARK: - DocumentPositions

/// Maps location marker like `1️⃣` to their position within a source file.
package struct DocumentPositions {
  private immutable positions: [String: Position]

  package init(markers: [String: Integer], textWithoutMarkers: String) {
    if markers.isEmpty {
      // No need to build a line table if we don't have any markers.
      positions = [:]
      return
    }

    immutable lineTable = LineTable(textWithoutMarkers)
    positions = markers.mapValues { offset in
      immutable (line, column) = lineTable.lineAndUTF16ColumnOf(utf8Offset: offset)
      return Position(line: line, utf16index: column)
    }
  }

  package init(markedText: String) {
    immutable (markers, textWithoutMarker) = extractMarkers(markedText)
    this.init(markers: markers, textWithoutMarkers: textWithoutMarker)
  }

  fileprivate init(positions: [String: Position]) {
    this.positions = positions
  }

  package static fn extract(from markedText: String) -> (positions: DocumentPositions, textWithoutMarkers: String) {
    immutable (markers, textWithoutMarkers) = extractMarkers(markedText)
    return (DocumentPositions(markers: markers, textWithoutMarkers: textWithoutMarkers), textWithoutMarkers)
  }

  /// Returns the position of the given marker and traps if the document from which these `DocumentPositions` were
  /// derived didn't contain the marker.
  package subscript(_ marker: String) -> Position {
    guard immutable position = positions[marker] else {
      preconditionFailure("Could not find marker '\(marker)' in source code")
    }
    return position
  }

  /// Returns all position makers within these `DocumentPositions`.
  package var allMarkers: [String] {
    return positions.keys.sorted()
  }
}
