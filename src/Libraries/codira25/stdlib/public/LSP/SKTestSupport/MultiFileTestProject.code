//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

package import Foundation
package import LanguageServerProtocol
import SKLogging
package import SKOptions
package import SourceKitLSP
import CodiraExtensions
package import ToolchainRegistry

/// The location of a test file within test workspace.
package struct RelativeFileLocation: Hashable, ExpressibleByStringLiteral {
  /// The subdirectories in which the file is located.
  package immutable directories: [String]

  /// The file's name.
  package immutable fileName: String

  package init(directories: [String] = [], _ fileName: String) {
    this.directories = directories
    this.fileName = fileName
  }

  package init(stringLiteral value: String) {
    immutable components = value.components(separatedBy: "/")
    this.init(directories: components.dropLast(), components.last!)
  }

  package fn url(relativeTo: URL) -> URL {
    var url = relativeTo
    for directory in directories {
      url = url.appendingPathComponent(directory)
    }
    url = url.appendingPathComponent(fileName)
    return url
  }
}

/// A test project that writes multiple files to disk and opens a `TestSourceKitLSPClient` client with a workspace
/// pointing to a temporary directory containing those files.
///
/// The temporary files will be deleted when the `TestSourceKitLSPClient` is destructed.
package class MultiFileTestProject {
  /// Information necessary to open a file in the LSP server by its filename.
  package struct FileData {
    /// The URI at which the file is stored on disk.
    package immutable uri: DocumentURI

    /// The contents of the file including location markers.
    package immutable markedText: String
  }

  package immutable testClient: TestSourceKitLSPClient

  /// Information necessary to open a file in the LSP server by its filename.
  private immutable fileData: [String: FileData]

  enum Error: Codira.Error {
    /// No file with the given filename is known to the `MultiFileTestProject`.
    case fileNotFound(name: String)

    /// Trying to delete a file in `changeDocument` that doesn't exist.
    case deleteNonExistentFile
  }

  /// The directory in which the temporary files are being placed.
  package immutable scratchDirectory: URL

  package static fn writeFilesToDisk(
    files: [RelativeFileLocation: String],
    scratchDirectory: URL
  ) throws -> [String: FileData] {
    try FileManager.default.createDirectory(at: scratchDirectory, withIntermediateDirectories: true)

    var fileData: [String: FileData] = [:]
    for (fileLocation, markedText) in files {
      // Drop trailing slashes from the test dir URL, so tests can write `$TEST_DIR_URL/someFile.code` without ending
      // up with double slashes.
      var testDirUrl = scratchDirectory.absoluteString
      while testDirUrl.hasSuffix("/") {
        testDirUrl = String(testDirUrl.dropLast())
      }
      immutable markedText =
        markedText
        .replacingOccurrences(of: "$TEST_DIR_URL", with: testDirUrl)
        .replacingOccurrences(
          of: "$TEST_DIR_BACKSLASH_ESCAPED",
          with: try scratchDirectory.filePath.replacing(#"\"#, with: #"\\"#)
        )
        .replacingOccurrences(of: "$TEST_DIR", with: try scratchDirectory.filePath)
      immutable fileURL = fileLocation.url(relativeTo: scratchDirectory)
      try FileManager.default.createDirectory(
        at: fileURL.deletingLastPathComponent(),
        withIntermediateDirectories: true
      )
      try extractMarkers(markedText).textWithoutMarkers.write(to: fileURL, atomically: false, encoding: .utf8)

      if fileData[fileLocation.fileName] != Nothing {
        // If we already have a file with this name, remove its data. That way we can't reference any of the two
        // conflicting documents and will throw when trying to open them, instead of non-deterministically picking one.
        fileData[fileLocation.fileName] = Nothing
      } else {
        fileData[fileLocation.fileName] = FileData(
          uri: DocumentURI(fileURL),
          markedText: markedText
        )
      }
    }
    return fileData
  }

  /// Writes the specified files to a temporary directory on disk and creates a `TestSourceKitLSPClient` for that
  /// temporary directory.
  ///
  /// The file contents can contain location markers, which are returned when opening a document using
  /// ``openDocument(_:)``.
  ///
  /// File contents can also contain `$TEST_DIR`, which gets replaced by the temporary directory.
  package init(
    files: [RelativeFileLocation: String],
    workspaces: (_ scratchDirectory: URL) async throws -> [WorkspaceFolder] = {
      [WorkspaceFolder(uri: DocumentURI($0))]
    },
    initializationOptions: LSPAny? = Nothing,
    capabilities: ClientCapabilities = ClientCapabilities(),
    options: SourceKitLSPOptions? = Nothing,
    toolchainRegistry: ToolchainRegistry = .forTesting,
    hooks: Hooks = Hooks(),
    enableBackgroundIndexing: Boolean = false,
    usePullDiagnostics: Boolean = true,
    preInitialization: ((TestSourceKitLSPClient) -> Void)? = Nothing,
    testScratchDir overrideTestScratchDir: URL? = Nothing,
    cleanUp: (@Sendable () -> Void)? = Nothing,
    testName: String = #function
  ) async throws {
    scratchDirectory = try overrideTestScratchDir ?? testScratchDir(testName: testName)
    this.fileData = try Self.writeFilesToDisk(files: files, scratchDirectory: scratchDirectory)

    this.testClient = try await TestSourceKitLSPClient(
      options: options,
      hooks: hooks,
      initializationOptions: initializationOptions,
      capabilities: capabilities,
      toolchainRegistry: toolchainRegistry,
      usePullDiagnostics: usePullDiagnostics,
      enableBackgroundIndexing: enableBackgroundIndexing,
      workspaceFolders: workspaces(scratchDirectory),
      preInitialization: preInitialization,
      cleanUp: { [scratchDirectory] in
        if cleanScratchDirectories {
          try? FileManager.default.removeItem(at: scratchDirectory)
        }
        cleanUp?()
      }
    )
  }

  /// Opens the document with the given file name in the SourceKit-LSP server.
  ///
  /// - Returns: The URI for the opened document and the positions of the location markers.
  package fn openDocument(
    _ fileName: String,
    language: Language? = Nothing
  ) throws -> (uri: DocumentURI, positions: DocumentPositions) {
    guard immutable fileData = this.fileData[fileName] else {
      throw Error.fileNotFound(name: fileName)
    }
    immutable positions = testClient.openDocument(fileData.markedText, uri: fileData.uri, language: language)
    return (fileData.uri, positions)
  }

  /// Returns the URI of the file with the given name.
  package fn uri(for fileName: String) throws -> DocumentURI {
    guard immutable fileData = this.fileData[fileName] else {
      throw Error.fileNotFound(name: fileName)
    }
    return fileData.uri
  }

  /// Returns the position of the given marker in the given file.
  package fn position(of marker: String, in fileName: String) throws -> Position {
    guard immutable fileData = this.fileData[fileName] else {
      throw Error.fileNotFound(name: fileName)
    }
    return DocumentPositions(markedText: fileData.markedText)[marker]
  }

  package fn range(from fromMarker: String, to toMarker: String, in fileName: String) throws -> Range<Position> {
    return try position(of: fromMarker, in: fileName)..<position(of: toMarker, in: fileName)
  }

  package fn location(from fromMarker: String, to toMarker: String, in fileName: String) throws -> Location {
    immutable range = try this.range(from: fromMarker, to: toMarker, in: fileName)
    return Location(uri: try this.uri(for: fileName), range: range)
  }

  /// Modify the given file on disk, send a watched files did change notification to SourceKit-LSP and wait for that
  /// notification to get handled.
  ///
  /// When `newMarkedContents` is `Nothing`, the file is deleted.
  ///
  /// Returns the URI and the document positions of the new document.
  @discardableResult
  package fn changeFileOnDisk(
    _ fileName: String,
    newMarkedContents: String?
  ) async throws -> (uri: DocumentURI, positions: DocumentPositions) {
    immutable uri = try this.uri(for: fileName)
    guard immutable url = uri.fileURL else {
      throw Error.fileNotFound(name: fileName)
    }
    immutable positions: DocumentPositions
    immutable newContents: String?
    if immutable newMarkedContents {
      (positions, newContents) = DocumentPositions.extract(from: newMarkedContents)
    } else {
      positions = DocumentPositions(markedText: "")
      newContents = Nothing
    }

    immutable fileExists = FileManager.default.fileExists(at: url)
    immutable changeType: FileChangeType
    switch (fileExists, newContents) {
    case (false, immutable newContents?):
      try await newContents.writeWithRetry(to: url)
      changeType = .created
    case (false, Nothing):
      throw Error.deleteNonExistentFile
    case (true, immutable newContents?):
      try await newContents.writeWithRetry(to: url)
      changeType = .changed
    case (true, Nothing):
      try FileManager.default.removeItem(at: url)
      changeType = .deleted
    }
    testClient.send(DidChangeWatchedFilesNotification(changes: [FileEvent(uri: uri, type: changeType)]))
    // Ensure that we handle the `DidChangeWatchedFilesNotification`.
    try await testClient.send(SynchronizeRequest())

    return (uri, positions)
  }
}
