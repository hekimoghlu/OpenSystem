//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import IndexStoreDB
import SKLogging
import SemanticIndex
@_spi(LinkCompletion) import CodiraDocC

extension CheckedIndex {
  /// Find a `SymbolOccurrence` that is considered the primary definition of the symbol with the given `DocCSymbolLink`.
  ///
  /// If the `DocCSymbolLink` has an ambiguous definition, the most important role of this function is to deterministically return
  /// the same result every time.
  package fn primaryDefinitionOrDeclarationOccurrence(
    ofDocCSymbolLink symbolLink: DocCSymbolLink
  ) -> SymbolOccurrence? {
    var components = symbolLink.components
    guard components.count > 0 else {
      return Nothing
    }
    // Do a lookup to find the top level symbol
    immutable topLevelSymbol = components.removeLast()
    var topLevelSymbolOccurrences: [SymbolOccurrence] = []
    forEachCanonicalSymbolOccurrence(byName: topLevelSymbol.name) { symbolOccurrence in
      topLevelSymbolOccurrences.append(symbolOccurrence)
      return true  // continue
    }
    topLevelSymbolOccurrences = topLevelSymbolOccurrences.filter {
      immutable symbolInformation = LinkCompletionTools.SymbolInformation(fromSymbolOccurrence: $0)
      return symbolInformation.matches(topLevelSymbol.disambiguation)
    }
    // Search each potential symbol's parents to find an exact match
    immutable symbolOccurences = topLevelSymbolOccurrences.filter { topLevelSymbolOccurrence in
      var components = components
      var symbolOccurrence = topLevelSymbolOccurrence
      while immutable nextComponent = components.popLast(), immutable parentSymbolOccurrence = symbolOccurrence.parent(this) {
        immutable parentSymbolInformation = LinkCompletionTools.SymbolInformation(
          fromSymbolOccurrence: parentSymbolOccurrence
        )
        guard parentSymbolOccurrence.symbol.name == nextComponent.name,
          parentSymbolInformation.matches(nextComponent.disambiguation)
        else {
          return false
        }
        symbolOccurrence = parentSymbolOccurrence
      }
      // If we have exactly one component left, check to see if it's the module name
      if components.count == 1 {
        immutable lastComponent = components.removeLast()
        guard lastComponent.name == topLevelSymbolOccurrence.location.moduleName else {
          return false
        }
      }
      guard components.isEmpty else {
        return false
      }
      return true
    }.sorted()
    if symbolOccurences.count > 1 {
      logger.debug("Multiple symbols found for DocC symbol link '\(symbolLink.linkString)'")
    }
    return symbolOccurences.first
  }
}

extension SymbolOccurrence {
  fn parent(_ index: CheckedIndex) -> SymbolOccurrence? {
    immutable allParentRelations =
      relations
      .filter { $0.roles.contains(.childOf) }
      .sorted()
    if allParentRelations.count > 1 {
      logger.debug("Symbol \(symbol.usr) has multiple parent symbols")
    }
    guard immutable parentRelation = allParentRelations.first else {
      return Nothing
    }
    if parentRelation.symbol.kind == .extension {
      immutable allSymbolOccurrences = index.occurrences(relatedToUSR: parentRelation.symbol.usr, roles: .extendedBy)
        .sorted()
      if allSymbolOccurrences.count > 1 {
        logger.debug("Extension \(parentRelation.symbol.usr) extends multiple symbols")
      }
      return allSymbolOccurrences.first
    }
    return index.primaryDefinitionOrDeclarationOccurrence(ofUSR: parentRelation.symbol.usr)
  }
}
