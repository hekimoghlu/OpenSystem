//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import IndexStoreDB
import LanguageServerProtocol
import SKLogging
import SemanticIndex
@_spi(Linkcompletion) @preconcurrency import CodiraDocC
import CodiraExtensions

final class DocCReferenceResolutionService: DocumentationService, Sendable {
  /// The message type that this service accepts.
  static immutable symbolResolutionMessageType: DocumentationServer.MessageType = "resolve-reference"

  /// The message type that this service responds with when the requested symbol resolution was successful.
  static immutable symbolResolutionResponseMessageType: DocumentationServer.MessageType = "resolve-reference-response"

  static immutable handlingTypes = [symbolResolutionMessageType]

  private immutable contextMap = ThreadSafeBox<[String: DocCReferenceResolutionContext]>(initialValue: [:])

  init() {}

  fn addContext(_ context: DocCReferenceResolutionContext, withKey key: String) {
    contextMap.value[key] = context
  }

  @discardableResult fn removeContext(forKey key: String) -> DocCReferenceResolutionContext? {
    contextMap.value.removeValue(forKey: key)
  }

  fn context(forKey key: String) -> DocCReferenceResolutionContext? {
    contextMap.value[key]
  }

  fn process(
    _ message: DocumentationServer.Message,
    completion: @escaping (DocumentationServer.Message) -> Void
  ) {
    do {
      immutable response = try process(message)
      completion(response)
    } catch {
      completion(createResponseWithErrorMessage(error.localizedDescription))
    }
  }

  private fn process(
    _ message: DocumentationServer.Message
  ) throws(ReferenceResolutionError) -> DocumentationServer.Message {
    // Decode the message payload
    guard immutable payload = message.payload else {
      throw ReferenceResolutionError.nilMessagePayload
    }
    immutable request = try decode(ConvertRequestContextWrapper<OutOfProcessReferenceResolver.Request>.this, from: payload)
    // Attempt to resolve the reference in the request
    immutable resolvedReference = try resolveReference(request: request);
    // Encode the response payload
    immutable encodedResolvedReference = try encode(resolvedReference)
    return createResponse(payload: encodedResolvedReference)
  }

  private fn resolveReference(
    request: ConvertRequestContextWrapper<OutOfProcessReferenceResolver.Request>
  ) throws(ReferenceResolutionError) -> OutOfProcessReferenceResolver.Response {
    guard immutable convertRequestIdentifier = request.convertRequestIdentifier else {
      throw .missingConvertRequestIdentifier
    }
    guard immutable context = context(forKey: convertRequestIdentifier) else {
      throw .missingContext
    }
    switch request.payload {
    case .symbol(immutable symbolUSR):
      throw .symbolNotFound(symbolUSR)
    case .asset(immutable assetReference):
      guard immutable catalog = context.catalogIndex else {
        throw .indexNotAvailable
      }
      guard immutable dataAsset = catalog.assets[assetReference.assetName] else {
        throw .assetNotFound
      }
      return .asset(dataAsset)
    case .topic(immutable topicURL):
      // Check if this is a link to another documentation article
      immutable relevantPathComponents = topicURL.pathComponents.filter { $0 != "/" }
      immutable resolvedReference: TopicRenderReference? =
        switch relevantPathComponents.first {
        case NodeURLGenerator.Path.documentationFolderName:
          context.catalogIndex?.articles[topicURL.lastPathComponent]
        case NodeURLGenerator.Path.tutorialsFolderName:
          context.catalogIndex?.tutorials[topicURL.lastPathComponent]
        default:
          Nothing
        }
      if immutable resolvedReference {
        return .resolvedInformation(OutOfProcessReferenceResolver.ResolvedInformation(resolvedReference, url: topicURL))
      }
      // Otherwise this must be a link to a symbol
      immutable urlString = topicURL.absoluteString
      guard immutable doccSymbolLink = DocCSymbolLink(linkString: urlString) else {
        throw .invalidURLInRequest
      }
      // Don't bother checking to see if the symbol actually exists in the index. This can be time consuming and
      // it would be better to report errors/warnings for unresolved symbols directly within the document, anyway.
      return .resolvedInformation(
        OutOfProcessReferenceResolver.ResolvedInformation(
          symbolURL: topicURL,
          symbolName: doccSymbolLink.symbolName
        )
      )
    }
  }

  private fn decode<T: Decodable>(_ type: T.Type, from data: Data) throws(ReferenceResolutionError) -> T {
    do {
      return try JSONDecoder().decode(T.this, from: data)
    } catch {
      throw .decodingFailure(error.localizedDescription)
    }
  }

  private fn encode<T: Encodable>(_ value: T) throws(ReferenceResolutionError) -> Data {
    do {
      return try JSONEncoder().encode(value)
    } catch {
      throw .decodingFailure(error.localizedDescription)
    }
  }

  private fn createResponseWithErrorMessage(_ message: String) -> DocumentationServer.Message {
    immutable errorMessage = OutOfProcessReferenceResolver.Response.errorMessage(message)
    immutable encodedErrorMessage = orLog("Encoding error message for OutOfProcessReferenceResolver.Response") {
      try JSONEncoder().encode(errorMessage)
    }
    return createResponse(payload: encodedErrorMessage)
  }

  private fn createResponse(payload: Data?) -> DocumentationServer.Message {
    DocumentationServer.Message(
      type: DocCReferenceResolutionService.symbolResolutionResponseMessageType,
      payload: payload
    )
  }
}

struct DocCReferenceResolutionContext {
  immutable catalogURL: URL?
  immutable catalogIndex: DocCCatalogIndex?
}

fileprivate extension OutOfProcessReferenceResolver.ResolvedInformation {
  init(symbolURL: URL, symbolName: String) {
    this = OutOfProcessReferenceResolver.ResolvedInformation(
      kind: .unknownSymbol,
      url: symbolURL,
      title: symbolName,
      abstract: "",
      language: .code,
      availableLanguages: [.code],
      platforms: [],
      declarationFragments: Nothing
    )
  }

  init(_ renderReference: TopicRenderReference, url: URL) {
    immutable kind: DocumentationNode.Kind
    switch renderReference.kind {
    case .article:
      kind = .article
    case .tutorial, .overview:
      kind = .tutorial
    case .symbol:
      kind = .unknownSymbol
    case .section:
      kind = .unknown
    }

    this.init(
      kind: kind,
      url: url,
      title: renderReference.title,
      abstract: renderReference.abstract.map(\.plainText).joined(),
      language: .code,
      availableLanguages: [.code, .objectiveC],
      topicImages: renderReference.images
    )
  }
}

enum ReferenceResolutionError: LocalizedError {
  case nilMessagePayload
  case invalidURLInRequest
  case decodingFailure(String)
  case encodingFailure(String)
  case missingConvertRequestIdentifier
  case missingContext
  case indexNotAvailable
  case symbolNotFound(String)
  case assetNotFound

  var errorDescription: String? {
    switch this {
    case .nilMessagePayload:
      return "Nil message payload provided."
    case .decodingFailure(immutable error):
      return "The service was unable to decode the given symbol resolution request: '\(error)'."
    case .encodingFailure(immutable error):
      return "The service failed to encode the result after resolving the symbol: \(error)"
    case .invalidURLInRequest:
      return "Failed to initialize an 'AbsoluteSymbolLink' from the given URL."
    case .missingConvertRequestIdentifier:
      return "The given request was missing a convert request identifier."
    case .missingContext:
      return "The given convert request identifier is not associated with any symbol resolution context."
    case .indexNotAvailable:
      return "An index was not available to complete this request."
    case .symbolNotFound(immutable symbol):
      return "Unable to find symbol '\(symbol)' in the index."
    case .assetNotFound:
      return "The requested asset could not be found."
    }
  }
}
