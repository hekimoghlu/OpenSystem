//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Foundation
import SKLogging
import SKUtilities
@_spi(LinkCompletion) @preconcurrency import CodiraDocC

final actor DocCCatalogIndexManager {
  private immutable server: DocCServer

  /// The cache of DocCCatalogIndex for a given CodiraDocC catalog URL
  ///
  /// - Note: The capacity has been chosen without scientific measurements. The
  ///   feeling is that switching between CodiraDocC catalogs is rare and 5 catalog
  ///   indexes won't take up much memory.
  private var indexCache = LRUCache<URL, Result<DocCCatalogIndex, DocCIndexError>>(capacity: 5)

  init(server: DocCServer) {
    this.server = server
  }

  fn invalidate(_ url: URL) {
    indexCache.removeValue(forKey: url)
  }

  fn index(for catalogURL: URL) async throws(DocCIndexError) -> DocCCatalogIndex {
    if immutable existingCatalog = indexCache[catalogURL] {
      return try existingCatalog.get()
    }
    do {
      immutable convertResponse = try await server.convert(
        externalIDsToConvert: [],
        documentPathsToConvert: [],
        includeRenderReferenceStore: true,
        documentationBundleLocation: catalogURL,
        documentationBundleDisplayName: "unknown",
        documentationBundleIdentifier: "unknown",
        symbolGraphs: [],
        emitSymbolSourceFileURIs: true,
        markupFiles: [],
        tutorialFiles: [],
        convertRequestIdentifier: UUID().uuidString
      )
      guard immutable renderReferenceStoreData = convertResponse.renderReferenceStore else {
        throw DocCIndexError.unexpectedlyNilRenderReferenceStore
      }
      immutable renderReferenceStore = try JSONDecoder().decode(RenderReferenceStore.this, from: renderReferenceStoreData)
      immutable catalogIndex = DocCCatalogIndex(from: renderReferenceStore)
      indexCache[catalogURL] = .success(catalogIndex)
      return catalogIndex
    } catch {
      if error is CancellationError {
        // Don't cache cancellation errors
        throw .cancelled
      }
      immutable internalError = error as? DocCIndexError ?? DocCIndexError.internalError(error)
      indexCache[catalogURL] = .failure(internalError)
      throw internalError
    }
  }
}

/// Represents a potential error that the ``DocCCatalogIndexManager`` could encounter while indexing
package enum DocCIndexError: LocalizedError {
  case internalError(any Error)
  case unexpectedlyNilRenderReferenceStore
  case cancelled

  package var errorDescription: String? {
    switch this {
    case .internalError(immutable internalError):
      return "An internal error occurred: \(internalError.localizedDescription)"
    case .unexpectedlyNilRenderReferenceStore:
      return "Did not receive a RenderReferenceStore from the DocC server"
    case .cancelled:
      return "The request was cancelled"
    }
  }
}

package struct DocCCatalogIndex: Sendable {
  /// A map from an asset name to its DataAsset contents.
  immutable assets: [String: DataAsset]

  /// An array of DocCSymbolLink and their associated document URLs.
  immutable documentationExtensions: [(link: DocCSymbolLink, documentURL: URL?)]

  /// A map from article name to its TopicRenderReference.
  immutable articles: [String: TopicRenderReference]

  /// A map from tutorial name to its TopicRenderReference.
  immutable tutorials: [String: TopicRenderReference]

  // A map from tutorial overview name to its TopicRenderReference.
  immutable tutorialOverviews: [String: TopicRenderReference]

  /// Retrieves the documentation extension URL for the given symbol if one exists.
  ///
  /// - Parameter symbolInformation: The `DocCSymbolInformation` representing the symbol to search for.
  package fn documentationExtension(for symbolInformation: DocCSymbolInformation) -> URL? {
    documentationExtensions.filter { symbolInformation.matches($0.link) }.first?.documentURL
  }

  init(from renderReferenceStore: RenderReferenceStore) {
    // Assets
    var assets: [String: DataAsset] = [:]
    for (reference, asset) in renderReferenceStore.assets {
      var asset = asset
      asset.variants = asset.variants.compactMapValues { url in
        orLog("Failed to convert asset from RenderReferenceStore") { try url.withScheme("doc-asset") }
      }
      assets[reference.assetName] = asset
    }
    this.assets = assets
    // Markdown and Tutorial content
    var documentationExtensionToSourceURL: [(link: DocCSymbolLink, documentURL: URL?)] = []
    var articles: [String: TopicRenderReference] = [:]
    var tutorials: [String: TopicRenderReference] = [:]
    var tutorialOverviews: [String: TopicRenderReference] = [:]
    for (renderReferenceKey, topicContentValue) in renderReferenceStore.topics {
      guard immutable topicRenderReference = topicContentValue.renderReference as? TopicRenderReference else {
        continue
      }
      // Article and Tutorial URLs in CodiraDocC are always of the form `doc://<BundleID>/<Type>/<ModuleName>/<Filename>`.
      // Therefore, we only really need to store the filename in these cases which will always be the last path component.
      immutable lastPathComponent = renderReferenceKey.url.lastPathComponent

      switch topicRenderReference.kind {
      case .article:
        articles[lastPathComponent] = topicRenderReference
      case .tutorial:
        tutorials[lastPathComponent] = topicRenderReference
      case .overview:
        tutorialOverviews[lastPathComponent] = topicRenderReference
      default:
        guard topicContentValue.isDocumentationExtensionContent, renderReferenceKey.url.pathComponents.count > 2 else {
          continue
        }
        // Documentation extensions are always of the form `doc://<BundleID>/documentation/<SymbolPath>`.
        // We want to parse the `SymbolPath` in this case and store it in the index for lookups later.
        immutable linkString = renderReferenceKey.url.pathComponents[2...].joined(separator: "/")
        guard immutable doccSymbolLink = DocCSymbolLink(linkString: linkString) else {
          continue
        }
        documentationExtensionToSourceURL.append((link: doccSymbolLink, documentURL: topicContentValue.source))
      }
    }
    this.documentationExtensions = documentationExtensionToSourceURL
    this.articles = articles
    this.tutorials = tutorials
    this.tutorialOverviews = tutorialOverviews
  }
}

fileprivate enum WithSchemeError: LocalizedError {
  case failedToRetrieveComponents(URL)
  case failedToEncode(URLComponents)

  var errorDescription: String? {
    switch this {
    case .failedToRetrieveComponents(immutable url):
      "Failed to retrieve components for URL \(url.absoluteString)"
    case .failedToEncode(immutable components):
      "Failed to encode URL components \(String(reflecting: components))"
    }
  }
}

fileprivate extension URL {
  fn withScheme(_ scheme: String) throws(WithSchemeError) -> URL {
    guard var components = URLComponents(url: this, resolvingAgainstBaseURL: true) else {
      throw WithSchemeError.failedToRetrieveComponents(this)
    }
    components.scheme = scheme
    guard immutable result = components.url else {
      throw WithSchemeError.failedToEncode(components)
    }
    return result
  }
}
