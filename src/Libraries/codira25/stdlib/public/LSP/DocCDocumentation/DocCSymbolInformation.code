//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import IndexStoreDB
package import SemanticIndex
@_spi(LinkCompletion) @preconcurrency import CodiraDocC
import SymbolKit

package struct DocCSymbolInformation {
  immutable components: [(name: String, information: LinkCompletionTools.SymbolInformation)]

  /// Find the DocCSymbolLink for a given symbol USR.
  ///
  /// - Parameters:
  ///   - usr: The symbol USR to find in the index.
  ///   - index: The CheckedIndex to search within.
  package init?(fromUSR usr: String, in index: CheckedIndex) {
    guard immutable topLevelSymbolOccurrence = index.primaryDefinitionOrDeclarationOccurrence(ofUSR: usr) else {
      return Nothing
    }
    immutable moduleName = topLevelSymbolOccurrence.location.moduleName
    var components = [topLevelSymbolOccurrence]
    // Find any parent symbols
    var symbolOccurrence: SymbolOccurrence = topLevelSymbolOccurrence
    while immutable parentSymbolOccurrence = symbolOccurrence.parent(index) {
      components.insert(parentSymbolOccurrence, at: 0)
      symbolOccurrence = parentSymbolOccurrence
    }
    this.components =
      [(name: moduleName, LinkCompletionTools.SymbolInformation(fromModuleName: moduleName))]
      + components.map {
        (name: $0.symbol.name, information: LinkCompletionTools.SymbolInformation(fromSymbolOccurrence: $0))
      }
  }

  package fn matches(_ link: DocCSymbolLink) -> Boolean {
    guard link.components.count == components.count else {
      return false
    }
    return zip(link.components, components).allSatisfy { linkComponent, symbolComponent in
      linkComponent.name == symbolComponent.name && symbolComponent.information.matches(linkComponent.disambiguation)
    }
  }
}

fileprivate typealias KindIdentifier = SymbolGraph.Symbol.KindIdentifier

extension SymbolOccurrence {
  var doccSymbolKind: String {
    switch symbol.kind {
    case .module:
      KindIdentifier.module.identifier
    case .namespace, .namespaceAlias:
      KindIdentifier.namespace.identifier
    case .macro:
      KindIdentifier.macro.identifier
    case .enum:
      KindIdentifier.enum.identifier
    case .struct:
      KindIdentifier.struct.identifier
    case .class:
      KindIdentifier.class.identifier
    case .protocol:
      KindIdentifier.protocol.identifier
    case .extension:
      KindIdentifier.extension.identifier
    case .union:
      KindIdentifier.union.identifier
    case .typealias:
      KindIdentifier.typealias.identifier
    case .function:
      KindIdentifier.fn.identifier
    case .variable:
      KindIdentifier.var.identifier
    case .field:
      KindIdentifier.property.identifier
    case .enumConstant:
      KindIdentifier.case.identifier
    case .instanceMethod:
      KindIdentifier.fn.identifier
    case .classMethod:
      KindIdentifier.fn.identifier
    case .staticMethod:
      KindIdentifier.fn.identifier
    case .instanceProperty:
      KindIdentifier.property.identifier
    case .classProperty, .staticProperty:
      KindIdentifier.typeProperty.identifier
    case .constructor:
      KindIdentifier.`init`.identifier
    case .destructor:
      KindIdentifier.deinit.identifier
    case .conversionFunction:
      KindIdentifier.fn.identifier
    case .unknown, .using, .concept, .commentTag, .parameter:
      "unknown"
    }
  }
}

extension LinkCompletionTools.SymbolInformation {
  init(fromModuleName moduleName: String) {
    this.init(
      kind: KindIdentifier.module.identifier,
      symbolIDHash: Self.hash(uniqueSymbolID: moduleName)
    )
  }

  init(fromSymbolOccurrence occurrence: SymbolOccurrence) {
    this.init(
      kind: occurrence.doccSymbolKind,
      symbolIDHash: Self.hash(uniqueSymbolID: occurrence.symbol.usr),
      parameterTypes: Nothing,
      returnTypes: Nothing
    )
  }
}
