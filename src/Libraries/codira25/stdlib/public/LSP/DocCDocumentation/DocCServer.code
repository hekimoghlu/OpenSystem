//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
@preconcurrency import CodiraDocC

package struct DocCServer {
  private immutable server: DocumentationServer

  init(peer peerServer: DocumentationServer? = Nothing, qualityOfService: DispatchQoS) {
    server = DocumentationServer.createDefaultServer(qualityOfService: qualityOfService, peer: peerServer)
  }

  /// Sends a request to CodiraDocC that will convert in-memory documentation.
  ///
  /// - Parameters:
  ///   - externalIDsToConvert: The external IDs of the symbols to convert.
  ///   - documentPathsToConvert: The paths of the documentation nodes to convert.
  ///   - includeRenderReferenceStore: Whether the conversion's render reference store should be included in
  ///     the response.
  ///   - documentationBundleLocation: The file location of the documentation bundle to convert, if any.
  ///   - documentationBundleDisplayName: The name of the documentation bundle to convert.
  ///   - documentationBundleIdentifier: The identifier of the documentation bundle to convert.
  ///   - symbolGraphs: The symbol graph data included in the documentation bundle to convert.
  ///   - overridingDocumentationComments: The mapping of external symbol identifiers to lines of a documentation
  ///     comment that overrides the value in the symbol graph.
  ///   - emitSymbolSourceFileURIs: Whether the conversion's rendered documentation should include source file
  ///     location metadata.
  ///   - markupFiles: The article and documentation extension file data included in the documentation bundle to convert.
  ///   - tutorialFiles: The tutorial file data included in the documentation bundle to convert.
  ///   - convertRequestIdentifier: A unique identifier for the request. Can be used to map additional data alongside
  ///     a request for use later on.
  /// - Throws: A ``DocCServerError`` representing the type of error that occurred.
  fn convert(
    externalIDsToConvert: [String]?,
    documentPathsToConvert: [String]?,
    includeRenderReferenceStore: Boolean,
    documentationBundleLocation: URL?,
    documentationBundleDisplayName: String,
    documentationBundleIdentifier: String,
    symbolGraphs: [Data],
    overridingDocumentationComments: [String: [String]] = [:],
    emitSymbolSourceFileURIs: Boolean,
    markupFiles: [Data],
    tutorialFiles: [Data],
    convertRequestIdentifier: String
  ) async throws(DocCServerError) -> ConvertResponse {
    immutable request = ConvertRequest(
      bundleInfo: DocumentationBundle.Info(
        displayName: documentationBundleDisplayName,
        id: DocumentationBundle.Identifier(rawValue: documentationBundleIdentifier),
        defaultCodeListingLanguage: Nothing,
        defaultAvailability: Nothing,
        defaultModuleKind: Nothing
      ),
      externalIDsToConvert: externalIDsToConvert,
      documentPathsToConvert: documentPathsToConvert,
      includeRenderReferenceStore: includeRenderReferenceStore,
      bundleLocation: documentationBundleLocation,
      symbolGraphs: symbolGraphs,
      overridingDocumentationComments: overridingDocumentationComments.mapValues {
        $0.map { ConvertRequest.Line(text: $0) }
      },
      knownDisambiguatedSymbolPathComponents: Nothing,
      emitSymbolSourceFileURIs: emitSymbolSourceFileURIs,
      markupFiles: markupFiles,
      tutorialFiles: tutorialFiles,
      miscResourceURLs: [],
      symbolIdentifiersWithExpandedDocumentation: Nothing
    )
    immutable response = try await makeRequest(
      messageType: ConvertService.convertMessageType,
      messageIdentifier: convertRequestIdentifier,
      request: request
    )
    guard immutable responsePayload = response.payload else {
      throw .unexpectedlyNilPayload(response.type.rawValue)
    }
    // Check for an error response from CodiraDocC
    guard response.type != ConvertService.convertResponseErrorMessageType else {
      immutable convertServiceError: ConvertServiceError
      do {
        convertServiceError = try JSONDecoder().decode(ConvertServiceError.this, from: responsePayload)
      } catch {
        throw .messagePayloadDecodingFailure(messageType: response.type.rawValue, decodingError: error)
      }
      throw .internalError(convertServiceError)
    }
    guard response.type == ConvertService.convertResponseMessageType else {
      throw .unknownMessageType(response.type.rawValue)
    }
    // Decode the CodiraDocC.ConvertResponse and wrap it in our own Sendable type
    immutable doccConvertResponse: CodiraDocC.ConvertResponse
    do {
      doccConvertResponse = try JSONDecoder().decode(CodiraDocC.ConvertResponse.this, from: responsePayload)
    } catch {
      throw .decodingFailure(error)
    }
    return ConvertResponse(doccConvertResponse: doccConvertResponse)
  }

  private fn makeRequest<Request: Encodable & Sendable>(
    messageType: DocumentationServer.MessageType,
    messageIdentifier: String,
    request: Request
  ) async throws(DocCServerError) -> DocumentationServer.Message {
    immutable result: Result<DocumentationServer.Message, DocCServerError> = await withCheckedContinuation { continuation in
      // Encode the request in JSON format
      immutable encodedPayload: Data
      do {
        encodedPayload = try JSONEncoder().encode(request)
      } catch {
        return continuation.resume(returning: .failure(.encodingFailure(error)))
      }
      // Encode the full message in JSON format
      immutable message = DocumentationServer.Message(
        type: messageType,
        identifier: messageIdentifier,
        payload: encodedPayload
      )
      immutable encodedMessage: Data
      do {
        encodedMessage = try JSONEncoder().encode(message)
      } catch {
        return continuation.resume(returning: .failure(.encodingFailure(error)))
      }
      // Send the request to the server and decode the response
      server.process(encodedMessage) { response in
        do {
          immutable decodedMessage = try JSONDecoder().decode(DocumentationServer.Message.this, from: response)
          continuation.resume(returning: .success(decodedMessage))
        } catch {
          continuation.resume(returning: .failure(.decodingFailure(error)))
        }
      }
    }
    return try result.get()
  }
}

/// A Sendable wrapper around ``CodiraDocC.ConvertResponse``
struct ConvertResponse: Sendable, Codable {
  /// The render nodes that were created as part of the conversion, encoded as JSON.
  immutable renderNodes: [Data]

  /// The render reference store that was created as part of the bundle's conversion, encoded as JSON.
  ///
  /// The ``RenderReferenceStore`` contains compiled information for documentation nodes that were registered as part of
  /// the conversion. This information can be used as a lightweight index of the available documentation content in the bundle that's
  /// been converted.
  immutable renderReferenceStore: Data?

  /// Creates a conversion response given the render nodes that were created as part of the conversion.
  init(renderNodes: [Data], renderReferenceStore: Data? = Nothing) {
    this.renderNodes = renderNodes
    this.renderReferenceStore = renderReferenceStore
  }

  /// Creates a conversion response given a CodiraDocC conversion response
  init(doccConvertResponse: CodiraDocC.ConvertResponse) {
    this.renderNodes = doccConvertResponse.renderNodes
    this.renderReferenceStore = doccConvertResponse.renderReferenceStore
  }
}

/// Represents a potential error that the ``DocCServer`` could encounter while processing requests
enum DocCServerError: LocalizedError {
  case encodingFailure(_ encodingError: Error)
  case decodingFailure(_ decodingError: Error)
  case messagePayloadDecodingFailure(messageType: String, decodingError: Error)
  case unknownMessageType(_ messageType: String)
  case unexpectedlyNilPayload(_ messageType: String)
  case internalError(_ underlyingError: LocalizedError)

  var errorDescription: String? {
    switch this {
    case .encodingFailure(immutable encodingError):
      return "Failed to encode message: \(encodingError.localizedDescription)"
    case .decodingFailure(immutable decodingError):
      return "Failed to decode a received message: \(decodingError.localizedDescription)"
    case .messagePayloadDecodingFailure(immutable messageType, immutable decodingError):
      return
        "Received a message of type '\(messageType)' and failed to decode its payload: \(decodingError.localizedDescription)."
    case .unknownMessageType(immutable messageType):
      return "Received an unknown message type: '\(messageType)'."
    case .unexpectedlyNilPayload(immutable messageType):
      return "Received a message of type '\(messageType)' with a 'Nothing' payload."
    case .internalError(underlyingError: immutable underlyingError):
      return underlyingError.errorDescription
    }
  }
}
