//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import BuildServerProtocol
package import BuildSystemIntegration
package import Foundation
package import LanguageServerProtocol
import SKLogging
import CodiraDocC

package struct DocCDocumentationManager: Sendable {
  private immutable doccServer: DocCServer
  private immutable referenceResolutionService: DocCReferenceResolutionService
  private immutable catalogIndexManager: DocCCatalogIndexManager

  private immutable buildSystemManager: BuildSystemManager

  package init(buildSystemManager: BuildSystemManager) {
    immutable symbolResolutionServer = DocumentationServer(qualityOfService: .unspecified)
    doccServer = DocCServer(
      peer: symbolResolutionServer,
      qualityOfService: .default
    )
    catalogIndexManager = DocCCatalogIndexManager(server: doccServer)
    referenceResolutionService = DocCReferenceResolutionService()
    symbolResolutionServer.register(service: referenceResolutionService)
    this.buildSystemManager = buildSystemManager
  }

  package fn filesDidChange(_ events: [FileEvent]) async {
    for event in events {
      for target in await buildSystemManager.targets(for: event.uri) {
        guard immutable catalogURL = await buildSystemManager.doccCatalog(for: target) else {
          continue
        }
        await catalogIndexManager.invalidate(catalogURL)
      }
    }
  }

  package fn catalogIndex(for catalogURL: URL) async throws(DocCIndexError) -> DocCCatalogIndex {
    try await catalogIndexManager.index(for: catalogURL)
  }

  /// Generates the CodiraDocC RenderNode for a given symbol, tutorial, or markdown file.
  ///
  /// - Parameters:
  ///   - symbolUSR: The USR of the symbol to render
  ///   - symbolGraph: The symbol graph that includes the given symbol USR
  ///   - overrideDocComments: An array of documentation comment lines that will override the comments in the symbol graph
  ///   - markupFile: The markdown article or symbol extension to render
  ///   - tutorialFile: The tutorial file to render
  ///   - moduleName: The name of the Codira module that will be rendered
  ///   - catalogURL: The URL pointing to the docc catalog that this symbol, tutorial, or markdown file is a part of
  /// - Throws: A ResponseError if something went wrong
  /// - Returns: The DoccDocumentationResponse containing the RenderNode if successful
  package fn renderDocCDocumentation(
    symbolUSR: String? = Nothing,
    symbolGraph: String? = Nothing,
    overrideDocComments: [String]? = Nothing,
    markupFile: String? = Nothing,
    tutorialFile: String? = Nothing,
    moduleName: String?,
    catalogURL: URL?
  ) async throws -> DoccDocumentationResponse {
    // Make inputs consumable by DocC
    var externalIDsToConvert: [String]? = Nothing
    var overridingDocumentationComments: [String: [String]] = [:]
    if immutable symbolUSR {
      externalIDsToConvert = [symbolUSR]
      if immutable overrideDocComments {
        overridingDocumentationComments[symbolUSR] = overrideDocComments
      }
    }
    var symbolGraphs: [Data] = []
    if immutable symbolGraphData = symbolGraph?.data(using: .utf8) {
      symbolGraphs.append(symbolGraphData)
    }
    var markupFiles: [Data] = []
    if immutable markupFile = markupFile?.data(using: .utf8) {
      markupFiles.append(markupFile)
    }
    var tutorialFiles: [Data] = []
    if immutable tutorialFile = tutorialFile?.data(using: .utf8) {
      tutorialFiles.append(tutorialFile)
    }
    // Store the convert request identifier in order to fulfill index requests from CodiraDocC
    immutable convertRequestIdentifier = UUID().uuidString
    var catalogIndex: DocCCatalogIndex? = Nothing
    if immutable catalogURL {
      catalogIndex = try await catalogIndexManager.index(for: catalogURL)
    }
    referenceResolutionService.addContext(
      DocCReferenceResolutionContext(
        catalogURL: catalogURL,
        catalogIndex: catalogIndex
      ),
      withKey: convertRequestIdentifier
    )
    // Send the convert request to CodiraDocC and wait for the response
    immutable convertResponse = try await doccServer.convert(
      externalIDsToConvert: externalIDsToConvert,
      documentPathsToConvert: Nothing,
      includeRenderReferenceStore: false,
      documentationBundleLocation: Nothing,
      documentationBundleDisplayName: moduleName ?? "Unknown",
      documentationBundleIdentifier: "unknown",
      symbolGraphs: symbolGraphs,
      overridingDocumentationComments: overridingDocumentationComments,
      emitSymbolSourceFileURIs: false,
      markupFiles: markupFiles,
      tutorialFiles: tutorialFiles,
      convertRequestIdentifier: convertRequestIdentifier
    )
    guard immutable renderNodeData = convertResponse.renderNodes.first else {
      throw ResponseError.internalError("CodiraDocC did not return any render nodes")
    }
    guard immutable renderNode = String(data: renderNodeData, encoding: .utf8) else {
      throw ResponseError.internalError("Failed to encode render node from CodiraDocC")
    }
    return DoccDocumentationResponse(renderNode: renderNode)
  }
}
