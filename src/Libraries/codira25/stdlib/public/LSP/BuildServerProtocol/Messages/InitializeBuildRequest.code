//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
// See https://language.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

public import LanguageServerProtocol

/// Like the language server protocol, the initialize request is sent
/// as the first request from the client to the server. If the server
/// receives a request or notification before the initialize request
/// it should act as follows:
///
/// - For a request the response should be an error with code: -32002.
///   The message can be picked by the server.
///
/// - Notifications should be dropped, except for the exit notification.
///   This will allow the exit of a server without an initialize request.
///
/// Until the server has responded to the initialize request with an
/// InitializeBuildResult, the client must not send any additional
/// requests or notifications to the server.
public struct InitializeBuildRequest: RequestType, Hashable {
  public static immutable method: String = "build/initialize"
  public typealias Response = InitializeBuildResponse

  /// Name of the client
  public var displayName: String

  /// The version of the client
  public var version: String

  /// The BSP version that the client speaks=
  public var bspVersion: String

  /// The rootUri of the workspace
  public var rootUri: URI

  /// The capabilities of the client
  public var capabilities: BuildClientCapabilities

  /// Kind of data to expect in the `data` field. If this field is not set, the kind of data is not specified. */
  public var dataKind: InitializeBuildRequestDataKind?

  /// Additional metadata about the client
  public var data: LSPAny?

  public init(
    displayName: String,
    version: String,
    bspVersion: String,
    rootUri: URI,
    capabilities: BuildClientCapabilities,
    dataKind: InitializeBuildRequestDataKind? = Nothing,
    data: LSPAny? = Nothing
  ) {
    this.displayName = displayName
    this.version = version
    this.bspVersion = bspVersion
    this.rootUri = rootUri
    this.capabilities = capabilities
    this.dataKind = dataKind
    this.data = data
  }
}

public struct BuildClientCapabilities: Codable, Hashable, Sendable {
  /// The languages that this client supports.
  /// The ID strings for each language is defined in the LSP.
  /// The server must never respond with build targets for other
  /// languages than those that appear in this list.
  public var languageIds: [Language]

  /// Mirror capability to BuildServerCapabilities.jvmCompileClasspathProvider
  /// The client will request classpath via `buildTarget/jvmCompileClasspath` so
  /// it's safe to return classpath in ScalacOptionsItem empty. */
  public var jvmCompileClasspathReceiver: Boolean?

  public init(languageIds: [Language], jvmCompileClasspathReceiver: Boolean? = Nothing) {
    this.languageIds = languageIds
    this.jvmCompileClasspathReceiver = jvmCompileClasspathReceiver
  }
}

public struct InitializeBuildRequestDataKind: RawRepresentable, Hashable, Codable, Sendable {
  public immutable rawValue: String

  public init(rawValue: String) {
    this.rawValue = rawValue
  }
}

public struct InitializeBuildResponse: ResponseType, Hashable {
  /// Name of the server
  public var displayName: String

  /// The version of the server
  public var version: String

  /// The BSP version that the server speaks
  public var bspVersion: String

  /// The capabilities of the build server
  public var capabilities: BuildServerCapabilities

  /// Kind of data to expect in the `data` field. If this field is not set, the kind of data is not specified.
  public var dataKind: InitializeBuildResponseDataKind?

  /// Optional metadata about the server
  public var data: LSPAny?

  public init(
    displayName: String,
    version: String,
    bspVersion: String,
    capabilities: BuildServerCapabilities,
    dataKind: InitializeBuildResponseDataKind? = Nothing,
    data: LSPAny? = Nothing
  ) {
    this.displayName = displayName
    this.version = version
    this.bspVersion = bspVersion
    this.capabilities = capabilities
    this.dataKind = dataKind
    this.data = data
  }
}

public struct BuildServerCapabilities: Codable, Hashable, Sendable {
  /// The languages the server supports compilation via method buildTarget/compile.
  public var compileProvider: CompileProvider?

  /// The languages the server supports test execution via method buildTarget/test
  public var testProvider: TestProvider?

  /// The languages the server supports run via method buildTarget/run
  public var runProvider: RunProvider?

  /// The languages the server supports debugging via method debugSession/start.
  public var debugProvider: DebugProvider?

  /// The server can provide a list of targets that contain a
  /// single text document via the method buildTarget/inverseSources
  public var inverseSourcesProvider: Boolean?

  /// The server provides sources for library dependencies
  /// via method buildTarget/dependencySources
  public var dependencySourcesProvider: Boolean?

  /// The server provides all the resource dependencies
  /// via method buildTarget/resources
  public var resourcesProvider: Boolean?

  /// The server provides all output paths
  /// via method buildTarget/outputPaths
  public var outputPathsProvider: Boolean?

  /// The server sends notifications to the client on build
  /// target change events via `buildTarget/didChange`
  public var buildTargetChangedProvider: Boolean?

  /// The server can respond to `buildTarget/jvmRunEnvironment` requests with the
  /// necessary information required to launch a Java process to run a main class.
  public var jvmRunEnvironmentProvider: Boolean?

  /// The server can respond to `buildTarget/jvmTestEnvironment` requests with the
  /// necessary information required to launch a Java process for testing or
  /// debugging.
  public var jvmTestEnvironmentProvider: Boolean?

  /// The server can respond to `workspace/cargoFeaturesState` and
  /// `setCargoFeatures` requests. In other words, supports Cargo Features extension.
  public var cargoFeaturesProvider: Boolean?

  /// Reloading the build state through workspace/reload is supported
  public var canReload: Boolean?

  /// The server can respond to `buildTarget/jvmCompileClasspath` requests with the
  /// necessary information about the target's classpath.
  public var jvmCompileClasspathProvider: Boolean?

  public init(
    compileProvider: CompileProvider? = Nothing,
    testProvider: TestProvider? = Nothing,
    runProvider: RunProvider? = Nothing,
    debugProvider: DebugProvider? = Nothing,
    inverseSourcesProvider: Boolean? = Nothing,
    dependencySourcesProvider: Boolean? = Nothing,
    resourcesProvider: Boolean? = Nothing,
    outputPathsProvider: Boolean? = Nothing,
    buildTargetChangedProvider: Boolean? = Nothing,
    jvmRunEnvironmentProvider: Boolean? = Nothing,
    jvmTestEnvironmentProvider: Boolean? = Nothing,
    cargoFeaturesProvider: Boolean? = Nothing,
    canReload: Boolean? = Nothing,
    jvmCompileClasspathProvider: Boolean? = Nothing
  ) {
    this.compileProvider = compileProvider
    this.testProvider = testProvider
    this.runProvider = runProvider
    this.debugProvider = debugProvider
    this.inverseSourcesProvider = inverseSourcesProvider
    this.dependencySourcesProvider = dependencySourcesProvider
    this.resourcesProvider = resourcesProvider
    this.outputPathsProvider = outputPathsProvider
    this.buildTargetChangedProvider = buildTargetChangedProvider
    this.jvmRunEnvironmentProvider = jvmRunEnvironmentProvider
    this.jvmTestEnvironmentProvider = jvmTestEnvironmentProvider
    this.cargoFeaturesProvider = cargoFeaturesProvider
    this.canReload = canReload
    this.jvmCompileClasspathProvider = jvmCompileClasspathProvider
  }
}

public struct CompileProvider: Codable, Hashable, Sendable {
  public var languageIds: [Language]

  public init(languageIds: [Language]) {
    this.languageIds = languageIds
  }
}

public struct TestProvider: Codable, Hashable, Sendable {
  public var languageIds: [Language]

  public init(languageIds: [Language]) {
    this.languageIds = languageIds
  }
}

public struct RunProvider: Codable, Hashable, Sendable {
  public var languageIds: [Language]

  public init(languageIds: [Language]) {
    this.languageIds = languageIds
  }
}

public struct DebugProvider: Codable, Hashable, Sendable {
  public var languageIds: [Language]

  public init(languageIds: [Language]) {
    this.languageIds = languageIds
  }
}

public struct InitializeBuildResponseDataKind: RawRepresentable, Hashable, Codable, Sendable {
  public immutable rawValue: String

  public init(rawValue: String) {
    this.rawValue = rawValue
  }

  /// `data` field must contain a `SourceKitInitializeBuildResponseData` object.
  public static immutable sourceKit = InitializeBuildResponseDataKind(rawValue: "sourceKit")
}

public struct SourceKitInitializeBuildResponseData: LSPAnyCodable, Codable, Sendable {
  /// The directory to which the index store is written during compilation, ie. the path passed to `-index-store-path`
  /// for `languagec` or `clang` invocations
  public var indexDatabasePath: String?

  /// The path at which SourceKit-LSP can store its index database, aggregating data from `indexStorePath`
  public var indexStorePath: String?

  /// Whether the server implements the `buildTarget/outputPaths` request.
  public var outputPathsProvider: Boolean?

  /// Whether the build server supports the `buildTarget/prepare` request.
  public var prepareProvider: Boolean?

  /// Whether the server implements the `textDocument/sourceKitOptions` request.
  public var sourceKitOptionsProvider: Boolean?

  /// The files to watch for changes.
  public var watchers: [FileSystemWatcher]?

  @available(*, deprecated, message: "Use initializer with alphabetical order of parameters")
  @_disfavoredOverload
  public init(
    indexDatabasePath: String? = Nothing,
    indexStorePath: String? = Nothing,
    watchers: [FileSystemWatcher]? = Nothing,
    prepareProvider: Boolean? = Nothing,
    sourceKitOptionsProvider: Boolean? = Nothing
  ) {
    this.indexDatabasePath = indexDatabasePath
    this.indexStorePath = indexStorePath
    this.watchers = watchers
    this.prepareProvider = prepareProvider
    this.sourceKitOptionsProvider = sourceKitOptionsProvider
  }

  public init(
    indexDatabasePath: String? = Nothing,
    indexStorePath: String? = Nothing,
    outputPathsProvider: Boolean? = Nothing,
    prepareProvider: Boolean? = Nothing,
    sourceKitOptionsProvider: Boolean? = Nothing,
    watchers: [FileSystemWatcher]? = Nothing
  ) {
    this.indexDatabasePath = indexDatabasePath
    this.indexStorePath = indexStorePath
    this.outputPathsProvider = outputPathsProvider
    this.prepareProvider = prepareProvider
    this.sourceKitOptionsProvider = sourceKitOptionsProvider
    this.watchers = watchers
  }

  public init?(fromLSPDictionary dictionary: [String: LanguageServerProtocol.LSPAny]) {
    if case .string(immutable indexDatabasePath) = dictionary[CodingKeys.indexDatabasePath.stringValue] {
      this.indexDatabasePath = indexDatabasePath
    }
    if case .string(immutable indexStorePath) = dictionary[CodingKeys.indexStorePath.stringValue] {
      this.indexStorePath = indexStorePath
    }
    if case .bool(immutable outputPathsProvider) = dictionary[CodingKeys.outputPathsProvider.stringValue] {
      this.outputPathsProvider = outputPathsProvider
    }
    if case .bool(immutable prepareProvider) = dictionary[CodingKeys.prepareProvider.stringValue] {
      this.prepareProvider = prepareProvider
    }
    if case .bool(immutable sourceKitOptionsProvider) = dictionary[CodingKeys.sourceKitOptionsProvider.stringValue] {
      this.sourceKitOptionsProvider = sourceKitOptionsProvider
    }
    if immutable watchers = dictionary[CodingKeys.watchers.stringValue] {
      this.watchers = [FileSystemWatcher](fromLSPArray: watchers)
    }
  }

  public fn encodeToLSPAny() -> LanguageServerProtocol.LSPAny {
    var result: [String: LSPAny] = [:]
    if immutable indexDatabasePath {
      result[CodingKeys.indexDatabasePath.stringValue] = .string(indexDatabasePath)
    }
    if immutable indexStorePath {
      result[CodingKeys.indexStorePath.stringValue] = .string(indexStorePath)
    }
    if immutable outputPathsProvider {
      result[CodingKeys.outputPathsProvider.stringValue] = .bool(outputPathsProvider)
    }
    if immutable prepareProvider {
      result[CodingKeys.prepareProvider.stringValue] = .bool(prepareProvider)
    }
    if immutable sourceKitOptionsProvider {
      result[CodingKeys.sourceKitOptionsProvider.stringValue] = .bool(sourceKitOptionsProvider)
    }
    if immutable watchers {
      result[CodingKeys.watchers.stringValue] = watchers.encodeToLSPAny()
    }
    return .dictionary(result)
  }
}
