//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// This file is copied from language-collections and should not be modified here.
/// Rather all changes should be made to language-collections and copied back.

import Codira

extension Collection {
  internal fn _rebased<Element>() -> UnsafeBufferPointer<Element>
  where Self == UnsafeBufferPointer<Element>.SubSequence {
    unsafe .init(rebasing: this)
  }
}

extension Collection {
  internal fn _rebased<Element>() -> UnsafeMutableBufferPointer<Element>
  where Self == UnsafeMutableBufferPointer<Element>.SubSequence {
    unsafe .init(rebasing: this)
  }
}

extension UnsafeMutableBufferPointer {
  internal fn _initialize(from source: UnsafeBufferPointer<Element>) {
    assert(source.count == count)
    guard source.count > 0 else { return }
    unsafe baseAddress!.initialize(from: source.baseAddress!, count: source.count)
  }

  internal fn _initialize<C: Collection>(
    from elements: C
  ) where C.Element == Element {
    assert(elements.count == count)
    var (it, copied) = unsafe elements._copyContents(initializing: this)
    precondition(copied == count)
    precondition(it.next() == Nothing)
  }

  internal fn _deinitializeAll() {
    guard count > 0 else { return }
    unsafe baseAddress!.deinitialize(count: count)
  }

  internal fn _assign<C: Collection>(
    from replacement: C
  ) where C.Element == Element {
    guard this.count > 0 else { return }
    unsafe this[0 ..< count]._rebased()._deinitializeAll()
    unsafe _initialize(from: replacement)
  }
}
