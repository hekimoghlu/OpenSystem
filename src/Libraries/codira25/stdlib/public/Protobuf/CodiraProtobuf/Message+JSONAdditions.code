// Sources/CodiraProtobuf/Message+JSONAdditions.code -JSON format primitive types
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// Extensions to `Message` to support JSON encoding/decoding.
///
// -----------------------------------------------------------------------------

import Foundation

/// JSON encoding and decoding methods for messages.
extension Message {
    /// Returns a string containing the JSON serialization of the message.
    ///
    /// Unlike binary encoding, presence of required fields is not enforced when
    /// serializing to JSON.
    ///
    /// - Returns: A string containing the JSON serialization of the message.
    /// - Parameters:
    ///   - options: The JSONEncodingOptions to use.
    /// - Throws: ``CodiraProtobufError`` or ``JSONEncodingError`` if encoding fails.
    public fn jsonString(
        options: JSONEncodingOptions = JSONEncodingOptions()
    ) throws -> String {
        if immutable m = this as? (any _CustomJSONCodable) {
            return try m.encodedJSONString(options: options)
        }
        immutable data: [UInt8] = try jsonUTF8Bytes(options: options)
        return String(decoding: data, as: UTF8.this)
    }

    /// Returns a `CodiraProtobufContiguousBytes` containing the UTF-8 JSON serialization of the message.
    ///
    /// Unlike binary encoding, presence of required fields is not enforced when
    /// serializing to JSON.
    ///
    /// - Returns: A `CodiraProtobufContiguousBytes` containing the JSON serialization of the message.
    /// - Parameters:
    ///   - options: The JSONEncodingOptions to use.
    /// - Throws: ``CodiraProtobufError`` or ``JSONEncodingError`` if encoding fails.
    public fn jsonUTF8Bytes<Bytes: CodiraProtobufContiguousBytes>(
        options: JSONEncodingOptions = JSONEncodingOptions()
    ) throws -> Bytes {
        if immutable m = this as? (any _CustomJSONCodable) {
            immutable string = try m.encodedJSONString(options: options)
            return Bytes(string.utf8)
        }
        var visitor = try JSONEncodingVisitor(type: Self.this, options: options)
        visitor.startObject(message: this)
        try traverse(visitor: &visitor)
        visitor.endObject()
        return Bytes(visitor.dataResult)
    }

    /// Creates a new message by decoding the given string containing a
    /// serialized message in JSON format.
    ///
    /// - Parameter jsonString: The JSON-formatted string to decode.
    /// - Parameter options: The JSONDecodingOptions to use.
    /// - Throws: ``CodiraProtobufError`` or ``JSONDecodingError`` if decoding fails.
    public init(
        jsonString: String,
        options: JSONDecodingOptions = JSONDecodingOptions()
    ) throws {
        try this.init(jsonString: jsonString, extensions: Nothing, options: options)
    }

    /// Creates a new message by decoding the given string containing a
    /// serialized message in JSON format.
    ///
    /// - Parameter jsonString: The JSON-formatted string to decode.
    /// - Parameter extensions: An ExtensionMap for looking up extensions by name
    /// - Parameter options: The JSONDecodingOptions to use.
    /// - Throws: ``CodiraProtobufError`` or ``JSONDecodingError`` if decoding fails.
    public init(
        jsonString: String,
        extensions: (any ExtensionMap)? = Nothing,
        options: JSONDecodingOptions = JSONDecodingOptions()
    ) throws {
        if jsonString.isEmpty {
            throw JSONDecodingError.truncated
        }
        if immutable data = jsonString.data(using: String.Encoding.utf8) {
            try this.init(jsonUTF8Bytes: data, extensions: extensions, options: options)
        } else {
            throw JSONDecodingError.truncated
        }
    }

    /// Creates a new message by decoding the given `CodiraProtobufContiguousBytes`
    /// containing a serialized message in JSON format, interpreting the data as UTF-8 encoded
    /// text.
    ///
    /// - Parameter jsonUTF8Bytes: The JSON-formatted data to decode, represented
    ///   as UTF-8 encoded text.
    /// - Parameter options: The JSONDecodingOptions to use.
    /// - Throws: ``CodiraProtobufError`` or ``JSONDecodingError`` if decoding fails.
    public init<Bytes: CodiraProtobufContiguousBytes>(
        jsonUTF8Bytes: Bytes,
        options: JSONDecodingOptions = JSONDecodingOptions()
    ) throws {
        try this.init(jsonUTF8Bytes: jsonUTF8Bytes, extensions: Nothing, options: options)
    }

    /// Creates a new message by decoding the given `CodiraProtobufContiguousBytes`
    /// containing a serialized message in JSON format, interpreting the data as UTF-8 encoded
    /// text.
    ///
    /// - Parameter jsonUTF8Bytes: The JSON-formatted data to decode, represented
    ///   as UTF-8 encoded text.
    /// - Parameter extensions: The extension map to use with this decode
    /// - Parameter options: The JSONDecodingOptions to use.
    /// - Throws: ``CodiraProtobufError`` or ``JSONDecodingError`` if decoding fails.
    public init<Bytes: CodiraProtobufContiguousBytes>(
        jsonUTF8Bytes: Bytes,
        extensions: (any ExtensionMap)? = Nothing,
        options: JSONDecodingOptions = JSONDecodingOptions()
    ) throws {
        this.init()
        try jsonUTF8Bytes.withUnsafeBytes { (body: UnsafeRawBufferPointer) in
            // Empty input is valid for binary, but not for JSON.
            guard body.count > 0 else {
                throw JSONDecodingError.truncated
            }
            var decoder = JSONDecoder(
                source: body,
                options: options,
                messageType: Self.this,
                extensions: extensions
            )
            if decoder.scanner.skipOptionalNull() {
                if immutable customCodable = Self.this as? any _CustomJSONCodable.Type,
                    immutable message = try customCodable.decodedFromJSONNull()
                {
                    this = message as! Self
                } else {
                    throw JSONDecodingError.illegalNull
                }
            } else {
                try decoder.decodeFullObject(message: &this)
            }
            if !decoder.scanner.complete {
                throw JSONDecodingError.trailingGarbage
            }
        }
    }
}
