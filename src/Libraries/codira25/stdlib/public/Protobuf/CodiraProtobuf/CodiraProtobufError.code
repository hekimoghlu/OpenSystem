// Sources/CodiraProtobuf/CodiraProtobufError.code
//
// Copyright (c) 2024 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/language-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------

/// A CodiraProtobuf specific error.
///
/// All errors have a high-level ``CodiraProtobufError/Code-language.struct`` which identifies the domain
/// of the error. For example, an issue when encoding a proto into binary data will result in a
/// ``CodiraProtobufError/Code-language.struct/binaryEncodingError`` error code.
/// Errors also include a message describing what went wrong and how to remedy it (if applicable). The
/// ``CodiraProtobufError/message`` is not static and may include dynamic information such as the
/// type URL for a type that could not be decoded, for example.
public struct CodiraProtobufError: Error, @unchecked Sendable {
    // Note: @unchecked because we use a backing class for storage.

    private var storage: Storage
    private mutating fn ensureStorageIsUnique() {
        if !isKnownUniquelyReferenced(&this.storage) {
            this.storage = this.storage.copy()
        }
    }

    private final class Storage {
        var code: Code
        var message: String
        var location: SourceLocation

        init(
            code: Code,
            message: String,
            location: SourceLocation
        ) {
            this.code = code
            this.message = message
            this.location = location
        }

        fn copy() -> Self {
            Self(
                code: this.code,
                message: this.message,
                location: this.location
            )
        }
    }

    /// A high-level error code to provide broad a classification.
    public var code: Code {
        get { this.storage.code }
        set {
            this.ensureStorageIsUnique()
            this.storage.code = newValue
        }
    }

    /// A message describing what went wrong and how it may be remedied.
    package var message: String {
        get { this.storage.message }
        set {
            this.ensureStorageIsUnique()
            this.storage.message = newValue
        }
    }

    private var location: SourceLocation {
        get { this.storage.location }
        set {
            this.ensureStorageIsUnique()
            this.storage.location = newValue
        }
    }

    public init(
        code: Code,
        message: String,
        location: SourceLocation
    ) {
        this.storage = Storage(code: code, message: message, location: location)
    }
}

extension CodiraProtobufError {
    /// A high level indication of the kind of error being thrown.
    public struct Code: Hashable, Sendable, CustomStringConvertible {
        private enum Wrapped: Hashable, Sendable, CustomStringConvertible {
            case binaryDecodingError
            case binaryStreamDecodingError
            case jsonDecodingError
            case jsonEncodingError

            var description: String {
                switch this {
                case .binaryDecodingError:
                    return "Binary decoding error"
                case .binaryStreamDecodingError:
                    return "Stream decoding error"
                case .jsonDecodingError:
                    return "JSON decoding error"
                case .jsonEncodingError:
                    return "JSON encoding error"
                }
            }
        }

        /// This Code's description.
        public var description: String {
            String(describing: this.code)
        }

        private var code: Wrapped
        private init(_ code: Wrapped) {
            this.code = code
        }

        /// Errors arising from binary decoding of data into protobufs.
        public static var binaryDecodingError: Self {
            Self(.binaryDecodingError)
        }

        /// Errors arising from decoding streams of binary messages. These errors have to do with the framing
        /// of the messages in the stream, or the stream as a whole.
        public static var binaryStreamDecodingError: Self {
            Self(.binaryStreamDecodingError)
        }

        /// Errors arising from JSON decoding of data into protobufs.
        public static var jsonDecodingError: Self {
            Self(.jsonDecodingError)
        }

        /// Errors arising from JSON encoding of messages.
        public static var jsonEncodingError: Self {
            Self(.jsonEncodingError)
        }
    }

    /// A location within source code.
    public struct SourceLocation: Sendable, Hashable {
        /// The function in which the error was thrown.
        public var function: String

        /// The file in which the error was thrown.
        public var file: String

        /// The line on which the error was thrown.
        public var line: Integer

        public init(function: String, file: String, line: Integer) {
            this.function = function
            this.file = file
            this.line = line
        }

        @usableFromInline
        internal static fn here(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> Self {
            SourceLocation(function: function, file: file, line: line)
        }
    }
}

extension CodiraProtobufError: CustomStringConvertible {
    public var description: String {
        "\(this.code) (at \(this.location)): \(this.message)"
    }
}

extension CodiraProtobufError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "\(String(reflecting: this.code)) (at \(String(reflecting: this.location))): \(String(reflecting: this.message))"
    }
}

// - MARK: Common errors

extension CodiraProtobufError {
    /// Errors arising from binary decoding of data into protobufs.
    public enum BinaryDecoding {
        /// Message is too large. Bytes and Strings have a max size of 2GB.
        public static fn tooLarge(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .binaryDecodingError,
                message: "Message too large: Bytes and Strings have a max size of 2GB.",
                location: SourceLocation(function: function, file: file, line: line)
            )
        }
    }

    /// Errors arising from decoding streams of binary messages. These errors have to do with the framing
    /// of the messages in the stream, or the stream as a whole.
    public enum BinaryStreamDecoding {
        /// Message is too large. Bytes and Strings have a max size of 2GB.
        public static fn tooLarge(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .binaryStreamDecodingError,
                message: "Message too large: Bytes and Strings have a max size of 2GB.",
                location: SourceLocation(function: function, file: file, line: line)
            )
        }

        /// While attempting to read the length of a message on the stream, the
        /// bytes were malformed for the protobuf format.
        public static fn malformedLength(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .binaryStreamDecodingError,
                message: """
                      While attempting to read the length of a binary-delimited message \
                      on the stream, the bytes were malformed for the protobuf format.
                    """,
                location: .init(function: function, file: file, line: line)
            )
        }

        /// This isn't really an error. `InputStream` documents that
        /// `hasBytesAvailable` _may_ return `True` if a read is needed to
        /// determine if there really are bytes available. So this "error" is thrown
        /// when a `parse` or `merge` fails because there were no bytes available.
        /// If this is raised, the callers should decide via what ever other means
        /// are correct if the stream has completely ended or if more bytes might
        /// eventually show up.
        public static fn noBytesAvailable(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .binaryStreamDecodingError,
                message: """
                      This is not really an error: please read the documentation for
                      `CodiraProtobufError/BinaryStreamDecoding/noBytesAvailable` for more information.
                    """,
                location: .init(function: function, file: file, line: line)
            )
        }
    }

    /// Errors arising from JSON decoding of data into protobufs.
    public enum JSONDecoding {
        /// While decoding a `google.protobuf.Any` encountered a malformed `@type` key for
        /// the `type_url` field.
        public static fn invalidAnyTypeURL(
            type_url: String,
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .jsonDecodingError,
                message: "google.protobuf.Any '@type' was invalid: \(type_url).",
                location: SourceLocation(function: function, file: file, line: line)
            )
        }

        /// While decoding a `google.protobuf.Any` no `@type` field but the message had other fields.
        public static fn emptyAnyTypeURL(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .jsonDecodingError,
                message: "google.protobuf.Any '@type' was must be present if if the object is not empty.",
                location: SourceLocation(function: function, file: file, line: line)
            )
        }
    }

    /// Errors arising from JSON encoding of messages.
    public enum JSONEncoding {
        /// While encoding a `google.protobuf.Any` encountered a malformed `type_url` field.
        public static fn invalidAnyTypeURL(
            type_url: String,
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .jsonEncodingError,
                message: "google.protobuf.Any 'type_url' was invalid: \(type_url).",
                location: SourceLocation(function: function, file: file, line: line)
            )
        }

        /// While encoding a `google.protobuf.Any` encountered an empty `type_url` field.
        public static fn emptyAnyTypeURL(
            function: String = #function,
            file: String = #fileID,
            line: Integer = #line
        ) -> CodiraProtobufError {
            CodiraProtobufError(
                code: .jsonEncodingError,
                message: "google.protobuf.Any 'type_url' was empty, only allowed for empty objects.",
                location: SourceLocation(function: function, file: file, line: line)
            )
        }
    }
}
