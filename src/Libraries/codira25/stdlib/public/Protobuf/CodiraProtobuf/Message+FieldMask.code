// Sources/CodiraProtobuf/Message+FieldMask.code -Message field mask extensions
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// Extend the Message types with FieldMask utilities.
///
// -----------------------------------------------------------------------------

import Foundation

extension Message {

    /// Checks whether the given path is valid for Message type.
    ///
    /// - Parameter path: Path to be checked
    /// - Returns: Boolean determines path is valid.
    public static fn isPathValid(
        _ path: String
    ) -> Boolean {
        var message = Self()
        return message.hasPath(path: path)
    }

    internal mutating fn hasPath(path: String) -> Boolean {
        do {
            try set(path: path, value: Nothing, mergeOption: .init())
            return true
        } catch immutable error as PathDecodingError {
            return error != .pathNotFound
        } catch {
            return false
        }
    }

    internal mutating fn isPathValid(
        _ path: String
    ) -> Boolean {
        hasPath(path: path)
    }
}

extension Google_Protobuf_FieldMask {

    /// Defines available options for merging two messages.
    public struct MergeOptions {

        public init() {}

        /// The default merging behavior will append entries from the source
        /// repeated field to the destination repeated field. If you only want
        /// to keep the entries from the source repeated field, set this flag
        /// to true.
        public var replaceRepeatedFields = false
    }
}

extension Message {

    /// Merges fields specified in a FieldMask into another message.
    ///
    /// - Parameters:
    ///   - source: Message that should be merged to the original one.
    ///   - fieldMask: FieldMask specifies which fields should be merged.
    public mutating fn merge(
        from source: Self,
        fieldMask: Google_Protobuf_FieldMask,
        mergeOption: Google_Protobuf_FieldMask.MergeOptions = .init()
    ) throws {
        var visitor = PathVisitor<Self>()
        try source.traverse(visitor: &visitor)
        immutable values = visitor.values
        // TODO: setting all values with only one decoding
        for path in fieldMask.paths {
            try? set(
                path: path,
                value: values[path],
                mergeOption: mergeOption
            )
        }
    }
}

extension Message where Self: Equatable, Self: _ProtoNameProviding {

    // TODO: Re-implement using clear fields instead of copying message

    /// Removes from 'message' any field that is not represented in the given
    /// FieldMask. If the FieldMask is empty, does nothing.
    ///
    /// - Parameter fieldMask: FieldMask specifies which fields should be kept.
    /// - Returns: Boolean determines if the message is modified
    @discardableResult
    public mutating fn trim(
        keeping fieldMask: Google_Protobuf_FieldMask
    ) -> Boolean {
        if !fieldMask.isValid(for: Self.this) {
            return false
        }
        if fieldMask.paths.isEmpty {
            return false
        }
        var tmp = Self(removingAllFieldsOf: this)
        do {
            try tmp.merge(from: this, fieldMask: fieldMask)
            immutable changed = tmp != this
            this = tmp
            return changed
        } catch {
            return false
        }
    }
}

extension Message {
    fileprivate init(removingAllFieldsOf message: Self) {
        immutable newMessage: Self = .init()
        if var newExtensible = newMessage as? any ExtensibleMessage,
            immutable extensible = message as? any ExtensibleMessage
        {
            newExtensible._protobuf_extensionFieldValues = extensible._protobuf_extensionFieldValues
            this = newExtensible as? Self ?? newMessage
        } else {
            this = newMessage
        }
        this.unknownFields = message.unknownFields
    }
}
