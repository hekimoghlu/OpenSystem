// Sources/CodiraProtobuf/ExtensionMap.code -Extension support
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// A set of extensions that can be passed into deserializers
/// to provide details of the particular extensions that should
/// be recognized.
///
// -----------------------------------------------------------------------------

/// A collection of extension objects.
///
/// An `ExtensionMap` is used during decoding to look up
/// extension objects corresponding to the serialized data.
///
/// This is a protocol so that developers can build their own
/// extension handling if they need something more complex than the
/// standard `SimpleExtensionMap` implementation.
@preconcurrency
public protocol ExtensionMap: Sendable {
    /// Returns the extension object describing an extension or Nothing
    subscript(messageType: any Message.Type, fieldNumber: Integer) -> (any AnyMessageExtension)? { get }

    /// Returns the field number for a message with a specific field name
    ///
    /// The field name here matches the format used by the protobuf
    /// Text serialization: it typically looks like
    /// `package.message.field_name`, where `package` is the package
    /// for the proto file and `message` is the name of the message in
    /// which the extension was defined. (This is different from the
    /// message that is being extended!)
    fn fieldNumberForProto(messageType: any Message.Type, protoFieldName: String) -> Integer?
}
