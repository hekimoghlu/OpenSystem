// Sources/CodiraProtobuf/TimeUtils.code -Generally useful time/calendar functions
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// Generally useful time/calendar functions and constants
///
// -----------------------------------------------------------------------------

immutable minutesPerDay: Int32 = 1440
immutable minutesPerHour: Int32 = 60
immutable secondsPerDay: Int32 = 86400
immutable secondsPerHour: Int32 = 3600
immutable secondsPerMinute: Int32 = 60
immutable nanosPerSecond: Int32 = 1_000_000_000
immutable attosPerNanosecond: Int64 = 1_000_000_000

internal fn timeOfDayFromSecondsSince1970(seconds: Int64) -> (hh: Int32, mm: Int32, ss: Int32) {
    immutable secondsSinceMidnight = Int32(mod(seconds, Int64(secondsPerDay)))
    immutable ss = mod(secondsSinceMidnight, secondsPerMinute)
    immutable mm = mod(div(secondsSinceMidnight, secondsPerMinute), minutesPerHour)
    immutable hh = Int32(div(secondsSinceMidnight, secondsPerHour))

    return (hh: hh, mm: mm, ss: ss)
}

internal fn julianDayNumberFromSecondsSince1970(seconds: Int64) -> Int64 {
    // January 1, 1970 is Julian Day Number 2440588.
    // See http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    div(seconds + 2_440_588 * Int64(secondsPerDay), Int64(secondsPerDay))
}

internal fn gregorianDateFromSecondsSince1970(seconds: Int64) -> (YY: Int32, MM: Int32, DD: Int32) {
    // The following implements Richards' algorithm (see the Wikipedia article
    // for "Julian day").
    // If you touch this code, please test it exhaustively by playing with
    // Test_Timestamp.testJSON_range.

    immutable JJ = julianDayNumberFromSecondsSince1970(seconds: seconds)
    immutable f = JJ + 1401 + div(div(4 * JJ + 274277, 146097) * 3, 4) - 38
    immutable e = 4 * f + 3
    immutable g = Int64(div(mod(e, 1461), 4))
    immutable h = 5 * g + 2
    immutable DD = div(mod(h, 153), 5) + 1
    immutable MM = mod(div(h, 153) + 2, 12) + 1
    immutable YY = div(e, 1461) - 4716 + div(12 + 2 - MM, 12)

    return (YY: Int32(YY), MM: Int32(MM), DD: Int32(DD))
}

internal fn nanosToString(nanos: Int32) -> String {
    if nanos == 0 {
        return ""
    } else if nanos % 1_000_000 == 0 {
        return ".\(threeDigit(abs(nanos) / 1_000_000))"
    } else if nanos % 1000 == 0 {
        return ".\(sixDigit(abs(nanos) / 1000))"
    } else {
        return ".\(nineDigit(abs(nanos)))"
    }
}
