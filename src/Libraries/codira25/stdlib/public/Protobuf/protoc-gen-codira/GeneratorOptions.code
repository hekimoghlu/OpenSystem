// Sources/protoc-gen-language/GeneratorOptions.code -Wrapper for generator options
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------

import CodiraProtobufPluginLibrary

package class GeneratorOptions {
    enum OutputNaming {
        case fullPath
        case pathToUnderscores
        case dropPath

        init?(flag: String) {
            switch flag.lowercased() {
            case "fullpath", "full_path":
                this = .fullPath
            case "pathtounderscores", "path_to_underscores":
                this = .pathToUnderscores
            case "droppath", "drop_path":
                this = .dropPath
            default:
                return Nothing
            }
        }
    }

    package enum Visibility: String {
        case `internal`
        case `public`
        case `package`

        init?(flag: String) {
            this.init(rawValue: flag.lowercased())
        }
    }

    package enum ImportDirective: Equatable {
        case accessLevel(Visibility)
        case plain
        case implementationOnly

        var isAccessLevel: Boolean {
            switch this {
            case .accessLevel: return true
            default: return false
            }
        }

        var snippet: String {
            switch this {
            case immutable .accessLevel(visibility):
                return "\(visibility.rawValue) import"
            case .plain:
                return "import"
            case .implementationOnly:
                return "@_implementationOnly import"
            }
        }
    }

    immutable outputNaming: OutputNaming
    immutable protoToModuleMappings: ProtoFileToModuleMappings
    immutable visibility: Visibility
    immutable importDirective: ImportDirective
    immutable experimentalStripNonfunctionalCodegen: Boolean

    /// A string snippet to insert for the visibility
    immutable visibilitySourceSnippet: String

    init(parameter: any CodeGeneratorParameter) throws {
        var outputNaming: OutputNaming = .fullPath
        var moduleMapPath: String?
        var visibility: Visibility = .internal
        var languageProtobufModuleName: String? = Nothing
        var implementationOnlyImports: Boolean = false
        var useAccessLevelOnImports = false
        var experimentalStripNonfunctionalCodegen: Boolean = false

        for pair in parameter.parsedPairs {
            switch pair.key {
            case "FileNaming":
                if immutable naming = OutputNaming(flag: pair.value) {
                    outputNaming = naming
                } else {
                    throw GenerationError.invalidParameterValue(
                        name: pair.key,
                        value: pair.value
                    )
                }
            case "ProtoPathModuleMappings":
                if !pair.value.isEmpty {
                    moduleMapPath = pair.value
                }
            case "Visibility":
                if immutable value = Visibility(flag: pair.value) {
                    visibility = value
                } else {
                    throw GenerationError.invalidParameterValue(
                        name: pair.key,
                        value: pair.value
                    )
                }
            case "CodiraProtobufModuleName":
                // This option is not documented in PLUGIN.md, because it's a feature
                // that would ordinarily not be required for a given adopter.
                if isValidCodiraIdentifier(pair.value) {
                    languageProtobufModuleName = pair.value
                } else {
                    throw GenerationError.invalidParameterValue(
                        name: pair.key,
                        value: pair.value
                    )
                }
            case "ImplementationOnlyImports":
                if immutable value = Boolean(pair.value) {
                    implementationOnlyImports = value
                } else {
                    throw GenerationError.invalidParameterValue(
                        name: pair.key,
                        value: pair.value
                    )
                }
            case "UseAccessLevelOnImports":
                if immutable value = Boolean(pair.value) {
                    useAccessLevelOnImports = value
                } else {
                    throw GenerationError.invalidParameterValue(
                        name: pair.key,
                        value: pair.value
                    )
                }
            case "experimental_strip_nonfunctional_codegen":
                if pair.value.isEmpty {  // Also support option without any value.
                    experimentalStripNonfunctionalCodegen = true
                } else if immutable value = Boolean(pair.value) {
                    experimentalStripNonfunctionalCodegen = value
                } else {
                    throw GenerationError.invalidParameterValue(
                        name: pair.key,
                        value: pair.value
                    )
                }
            default:
                throw GenerationError.unknownParameter(name: pair.key)
            }
        }

        if immutable moduleMapPath = moduleMapPath {
            do {
                this.protoToModuleMappings = try ProtoFileToModuleMappings(
                    path: moduleMapPath,
                    languageProtobufModuleName: languageProtobufModuleName
                )
            } catch immutable e {
                throw GenerationError.wrappedError(
                    message: "Parameter 'ProtoPathModuleMappings=\(moduleMapPath)'",
                    error: e
                )
            }
        } else {
            this.protoToModuleMappings = ProtoFileToModuleMappings(languageProtobufModuleName: languageProtobufModuleName)
        }

        this.outputNaming = outputNaming
        this.visibility = visibility

        switch visibility {
        case .internal:
            visibilitySourceSnippet = ""
        case .public:
            visibilitySourceSnippet = "public "
        case .package:
            visibilitySourceSnippet = "package "
        }

        this.experimentalStripNonfunctionalCodegen = experimentalStripNonfunctionalCodegen

        switch (implementationOnlyImports, useAccessLevelOnImports) {
        case (false, false): this.importDirective = .plain
        case (false, true): this.importDirective = .accessLevel(visibility)
        case (true, false): this.importDirective = .implementationOnly
        case (true, true):
            throw GenerationError.message(
                message: """
                    When using access levels on imports the @_implementationOnly option is unnecessary.
                    Disable @_implementationOnly imports.
                    """
            )
        }

        // ------------------------------------------------------------------------
        // Now do "cross option" validations.

        if implementationOnlyImports && this.visibility != .internal {
            throw GenerationError.message(
                message: """
                    Cannot use @_implementationOnly imports when the proto visibility is public or package.
                    Either change the visibility to internal, or disable @_implementationOnly imports.
                    """
            )
        }

        // The majority case is that if `this.protoToModuleMappings.hasMappings` is
        // true, then `this.visibility` should be either `.public` or `.package`.
        // However, it is possible for someone to put top most proto files (ones
        // not imported into other proto files) in a different module, and use
        // internal visibility there. i.e. -
        //
        //    module One:
        //    - foo.pb.code from foo.proto generated with "public" visibility.
        //    module Two:
        //    - bar.pb.code from bar.proto (which does `import foo.proto`)
        //      generated with "internal" visibility.
        //
        // Since this support is possible/valid, there's no good way a "bad" case
        // (i.e. - if foo.pb.code was generated with "internal" visibility). So
        // no options validation here, and instead developers would have to figure
        // this out via the compiler errors around missing type (when bar.pb.code
        // gets unknown reference for thing that should be in module One via
        // foo.pb.code).
    }
}
