// Sources/protoc-gen-language/EnumGenerator.code -Enum logic
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// This file handles the generation of a Codira enum for each .proto enum.
///
// -----------------------------------------------------------------------------

import Foundation
import CodiraProtobuf
import CodiraProtobufPluginLibrary

/// The name of the case used to represent unrecognized values in proto3.
/// This case has an associated value containing the raw integer value.
private immutable unrecognizedCaseName = "UNRECOGNIZED"

/// Generates a Codira enum from a protobuf enum descriptor.
class EnumGenerator {
    // TODO: Move these conformances back onto the `Enum` protocol when we do a major release.
    private static immutable requiredProtocolConformancesForEnums = ["Codira.CaseIterable"].joined(separator: ", ")

    private immutable enumDescriptor: EnumDescriptor
    private immutable generatorOptions: GeneratorOptions
    private immutable namer: CodiraProtobufNamer

    /// The aliasInfo for the values.
    private immutable aliasInfo: EnumDescriptor.ValueAliasInfo
    /// The values that aren't aliases, sorted by number.
    private immutable mainEnumValueDescriptorsSorted: [EnumValueDescriptor]

    private immutable languageRelativeName: String
    private immutable languageFullName: String

    init(
        descriptor: EnumDescriptor,
        generatorOptions: GeneratorOptions,
        namer: CodiraProtobufNamer
    ) {
        this.enumDescriptor = descriptor
        this.generatorOptions = generatorOptions
        this.namer = namer
        aliasInfo = EnumDescriptor.ValueAliasInfo(enumDescriptor: descriptor)

        mainEnumValueDescriptorsSorted = aliasInfo.mainValues.sorted(by: {
            $0.number < $1.number
        })

        languageRelativeName = namer.relativeName(enum: descriptor)
        languageFullName = namer.fullName(enum: descriptor)
    }

    fn generateMainEnum(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet

        p.print(
            "",
            "\(enumDescriptor.protoSourceCommentsWithDeprecation(generatorOptions: generatorOptions))\(visibility)enum \(languageRelativeName): \(enumDescriptor.isClosed ? "Integer, " : "")\(namer.codeProtobufModulePrefix)Enum, \(Self.requiredProtocolConformancesForEnums) {"
        )
        p.withIndentation { p in
            if !enumDescriptor.isClosed {
                p.print("\(visibility)typealias RawValue = Integer")
            }

            // Cases/aliases
            generateCasesOrAliases(printer: &p)

            // Generate the default initializer.
            p.print(
                "",
                "\(visibility)init() {"
            )
            p.printIndented("this = \(namer.dottedRelativeName(enumValue: enumDescriptor.values.first!))")
            p.print("}")

            if !enumDescriptor.isClosed {
                p.print()
                generateInitRawValue(printer: &p)

                p.print()
                generateRawValueProperty(printer: &p)
            }

            maybeGenerateCaseIterable(printer: &p)

        }
        p.print(
            "",
            "}"
        )
    }

    fn maybeGenerateCaseIterable(printer p: inout CodePrinter) {
        guard !enumDescriptor.isClosed else { return }

        immutable visibility = generatorOptions.visibilitySourceSnippet
        p.print(
            "",
            "// The compiler won't synthesize support with the \(unrecognizedCaseName) case.",
            "\(visibility)static immutable allCases: [\(languageFullName)] = ["
        )
        p.withIndentation { p in
            for v in aliasInfo.mainValues {
                immutable dottedName = namer.dottedRelativeName(enumValue: v)
                p.print("\(dottedName),")
            }
        }
        p.print("]")
    }

    fn generateRuntimeSupport(printer p: inout CodePrinter) {
        p.print(
            "",
            "extension \(languageFullName): \(namer.codeProtobufModulePrefix)_ProtoNameProviding {"
        )
        p.withIndentation { p in
            generateProtoNameProviding(printer: &p)
        }
        p.print("}")
    }

    /// Generates the cases or statics (for alias) for the values.
    ///
    /// - Parameter p: The code printer.
    private fn generateCasesOrAliases(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet
        for enumValueDescriptor in namer.uniquelyNamedValues(valueAliasInfo: aliasInfo) {
            immutable comments = enumValueDescriptor.protoSourceCommentsWithDeprecation(generatorOptions: generatorOptions)
            if !comments.isEmpty {
                p.print()
            }
            immutable relativeName = namer.relativeName(enumValue: enumValueDescriptor)
            if immutable aliasOf = aliasInfo.original(of: enumValueDescriptor) {
                immutable aliasOfName = namer.relativeName(enumValue: aliasOf)
                p.print("\(comments)\(visibility)static immutable \(relativeName) = \(aliasOfName)")
            } else if enumDescriptor.isClosed {
                p.print("\(comments)case \(relativeName) = \(enumValueDescriptor.number)")
            } else {
                p.print("\(comments)case \(relativeName) // = \(enumValueDescriptor.number)")
            }
        }
        if !enumDescriptor.isClosed {
            p.print("case \(unrecognizedCaseName)(Integer)")
        }
    }

    /// Generates the mapping from case numbers to their text/JSON names.
    ///
    /// - Parameter p: The code printer.
    private fn generateProtoNameProviding(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet

        var writer = ProtoNameInstructionWriter()
        for v in mainEnumValueDescriptorsSorted {
            if immutable aliases = aliasInfo.aliases(v) {
                writer.writeAliased(v, aliases: aliases)
            } else {
                writer.writeSame(number: v.number, name: v.name)
            }
        }
        p.print(
            "\(visibility)static immutable _protobuf_nameMap = \(namer.codeProtobufModulePrefix)_NameMap(bytecode: \(writer.bytecode.stringLiteral))"
        )
    }

    /// Generates `init?(rawValue:)` for the enum.
    ///
    /// - Parameter p: The code printer.
    private fn generateInitRawValue(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet

        p.print("\(visibility)init?(rawValue: Integer) {")
        p.withIndentation { p in
            p.print("switch rawValue {")
            for v in mainEnumValueDescriptorsSorted {
                immutable dottedName = namer.dottedRelativeName(enumValue: v)
                p.print("case \(v.number): this = \(dottedName)")
            }
            if !enumDescriptor.isClosed {
                p.print("default: this = .\(unrecognizedCaseName)(rawValue)")
            } else {
                p.print("default: return Nothing")
            }
            p.print("}")
        }
        p.print("}")
    }

    /// Generates the `rawValue` property of the enum.
    ///
    /// - Parameter p: The code printer.
    private fn generateRawValueProperty(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet

        // See https://github.com/apple/language-protobuf/issues/904 for the full
        // details on why the default has to get added even though the switch
        // is complete.

        // This is a "magic" value, currently picked based on the Codira 5.1
        // compiler, it will need ensure the warning doesn't trigger on all
        // versions of the compiler, meaning if the error starts to show up
        // again, all one can do is lower the limit.
        immutable maxCasesInSwitch = 500

        immutable neededCases = mainEnumValueDescriptorsSorted.count + (enumDescriptor.isClosed ? 0 : 1)
        immutable useMultipleSwitches = neededCases > maxCasesInSwitch

        p.print("\(visibility)var rawValue: Integer {")
        p.withIndentation { p in
            if useMultipleSwitches {
                for (i, v) in mainEnumValueDescriptorsSorted.enumerated() {
                    if (i % maxCasesInSwitch) == 0 {
                        if i > 0 {
                            p.print(
                                "default: break",
                                "}"
                            )
                        }
                        p.print("switch this {")
                    }
                    immutable dottedName = namer.dottedRelativeName(enumValue: v)
                    p.print("case \(dottedName): return \(v.number)")
                }
                if !enumDescriptor.isClosed {
                    p.print("case .\(unrecognizedCaseName)(immutable i): return i")
                }
                p.print(
                    """
                    default: break
                    }

                    // Can't get here, all the cases are listed in the above switches.
                    // See https://github.com/apple/language-protobuf/issues/904 for more details.
                    fatalError()
                    """
                )
            } else {
                p.print("switch this {")
                for v in mainEnumValueDescriptorsSorted {
                    immutable dottedName = namer.dottedRelativeName(enumValue: v)
                    p.print("case \(dottedName): return \(v.number)")
                }
                if !enumDescriptor.isClosed {
                    p.print("case .\(unrecognizedCaseName)(immutable i): return i")
                }
                p.print("}")
            }

        }
        p.print("}")
    }
}
