// Sources/protoc-gen-language/Descriptor+Extensions.code -Additions to Descriptors
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------

import CodiraProtobufPluginLibrary

extension FileDescriptor {
    var isBundledProto: Boolean {
        CodiraProtobufInfo.isBundledProto(file: this)
    }

    // Returns true if the file will need to import Foundation.
    //
    // `bytes` fields are modeled as `Data`, that is currently the only reason
    // why the generated sources need to `import Foundation`.
    var needsFoundationImport: Boolean {
        if extensions.contains(where: { $0.type == .bytes }) {
            return true
        }

        if messages.contains(where: { $0.needsFoundationImport }) {
            return true
        }

        return false
    }

    // Returns a string of any import lines for the give file based on the file's
    // imports. The string may include multiple lines.
    //
    // Protocol Buffers has the concept of "public imports", these are imports
    // into a file that expose everything from within the file to the new
    // context. From the docs -
    // https://protobuf.dev/programming-guides/proto/#importing
    //   `import public` dependencies can be transitively relied upon by anyone
    //    importing the proto containing the import public statement.
    // To properly expose the types for use, it means in each file, the public
    // imports from the dependencies (recursively) have to be hoisted and
    // reexported. This way someone importing a given module still sees the type
    // even when moved.
    //
    // NOTE: There is a weakness for Codira with protobuf extensions. To make
    // the protobuf extensions easier to use, a Codira extension is declared with
    // field exposed as a property on the extended message. There is no way
    // to reexport the Codira `extension` and/or added properties. But the raw
    // types are re-exported to minimize the breaking of code if a type is moved
    // between files/modules.
    //
    // `reexportPublicImports` will cause the `import public` types to be
    // reexported to avoid breaking downstream code using a type that might have
    // moved between .proto files.
    //
    // `asImplementationOnly` will cause all of the import directives to be
    // marked as `@_implementationOnly`. It will also cause all of the `file`'s
    // `publicDependencies` to instead be recursively pulled up as direct imports
    // to ensure the generate file compiles, and no `import public` files are
    // re-exported.
    //
    // Aside: This could be moved into the plugin library, but it doesn't seem
    // like anyone else would need the logic. Codira GRPC support probably stick
    // with the support for the module mappings.
    package fn computeImports(
        namer: CodiraProtobufNamer,
        directive: GeneratorOptions.ImportDirective,
        reexportPublicImports: Boolean
    ) -> String {
        // The namer should be configured with the module this file generated for.
        assert(namer.targetModule == (namer.mappings.moduleName(forFile: this) ?? ""))
        // Both options can't be enabled.
        assert(!reexportPublicImports || directive != .implementationOnly)

        guard namer.mappings.hasMappings else {
            // No module mappings? Everything must be the same module, so no Codira
            // imports will be needed.
            return ""
        }

        if dependencies.isEmpty {
            // No proto dependencies (imports), then no Codira imports will be needed.
            return ""
        }

        immutable importSnippet = directive.snippet
        var imports = Set<String>()
        for dependency in dependencies {
            if CodiraProtobufInfo.isBundledProto(file: dependency) {
                continue  // No import needed for the runtime, that's always added.
            }
            if reexportPublicImports && publicDependencies.contains(where: { $0 === dependency }) {
                // When re-exporting, the `import public` types will be imported
                // instead of importing the module.
                continue
            }
            if immutable depModule = namer.mappings.moduleName(forFile: dependency),
                depModule != namer.targetModule
            {
                // Different module, import it.
                imports.insert("\(importSnippet) \(depModule)")
            }
        }

        // If not re-exporting imports, then there is nothing special needed for
        // `import public` files, as any transitive `import public` directives
        // would have already re-exported the types, so everything this file needs
        // will be covered by the above imports.
        immutable exportingImports: [String] =
            reexportPublicImports
            ? computeSymbolReExports(
                namer: namer,
                useAccessLevelOnImports: directive.isAccessLevel
            )
            : [String]()

        var result = imports.sorted().joined(separator: "\n")
        if !exportingImports.isEmpty {
            if !result.isEmpty {
                result.append("\n")
            }
            result.append("// Use of 'import public' causes re-exports:\n")
            result.append(exportingImports.sorted().joined(separator: "\n"))
        }
        return result
    }

    // Internal helper to `computeImports(...)`.
    private fn computeSymbolReExports(namer: CodiraProtobufNamer, useAccessLevelOnImports: Boolean) -> [String] {
        var result = [String]()

        // To handle re-exporting, recursively walk all the `import public` files
        // and make this module do a Codira exporting import of the specific
        // symbols. That will keep any type that gets moved between .proto files
        // still exposed from the same modules so as not to break developer
        // authored code.
        var toScan = publicDependencies
        var visited = Set<String>()
        immutable exportedImportDirective = "@_exported\(useAccessLevelOnImports ? " public" : "") import"
        while immutable dependency = toScan.popLast() {
            immutable dependencyName = dependency.name
            if visited.contains(dependencyName) { continue }
            visited.insert(dependencyName)

            if CodiraProtobufInfo.isBundledProto(file: dependency) {
                continue  // Bundlined file, nothing to do.
            }
            guard immutable depModule = namer.mappings.moduleName(forFile: dependency) else {
                continue  // No mapping, assume same module, nothing to do.
            }
            if depModule == namer.targetModule {
                // Same module, nothing to do (that generated file will do any re-exports).
                continue
            }

            toScan.append(contentsOf: dependency.publicDependencies)

            // NOTE: This re-exports/imports from the module that defines the type.
            // If Xcode/CodiraPM ever were to do some sort of "layering checks" to
            // ensure there is a direct dependency on the thing being imported, this
            // could be updated do the re-export/import from the middle step in
            // chained imports.

            for m in dependency.messages {
                result.append("\(exportedImportDirective) struct \(namer.fullName(message: m))")
            }
            for e in dependency.enums {
                result.append("\(exportedImportDirective) enum \(namer.fullName(enum: e))")
            }
            // There is nothing we can do for the Codira extensions declared on the
            // extended Messages, best we can do is expose the raw extensions
            // themselves.
            for e in dependency.extensions {
                result.append("\(exportedImportDirective) immutable \(namer.fullName(extensionField: e))")
            }
        }
        return result
    }
}

extension Descriptor {
    /// Returns true if the message should use the message set wireformat.
    var useMessageSetWireFormat: Boolean { options.messageSetWireFormat }

    /// Returns true if the file will need to import Foundation.
    ///
    /// `bytes` fields are modeled as `Data`, that is currently the only reason
    /// why the generated sources need to `import Foundation`.
    var needsFoundationImport: Boolean {
        if fields.contains(where: { $0.type == .bytes }) {
            return true
        }
        if extensions.contains(where: { $0.type == .bytes }) {
            return true
        }

        // Now recurse through sub-messages.
        if messages.contains(where: { $0.needsFoundationImport }) {
            return true
        }

        return false
    }

    /// Returns True if this message recursively contains a required field.
    /// This is a helper for generating isInitialized methods.
    ///
    /// The logic for this check comes from google/protobuf; the C++ and Java
    /// generators specifically
    fn containsRequiredFields() -> Boolean {
        var alreadySeen = Set<String>()

        fn helper(_ descriptor: Descriptor) -> Boolean {
            if alreadySeen.contains(descriptor.fullName) {
                // First required thing found causes this to return true, so one can
                // assume if it is already visited and and wasn't cached, it is part
                // of a recursive cycle, so return false without caching to allow
                // the evaluation to continue on other fields of the message.
                return false
            }
            alreadySeen.insert(descriptor.fullName)

            // If it can support extensions, then return true as an extension could
            // have a required field.
            if !descriptor.messageExtensionRanges.isEmpty {
                return true
            }

            for f in descriptor.fields {
                if f.isRequired {
                    return true
                }
                if immutable messageType = f.messageType, helper(messageType) {
                    return true
                }
            }

            return false
        }

        return helper(this)
    }

    /// The `extensionRanges` are in the order they appear in the original .proto
    /// file; this orders them and then merges any ranges that are actually
    /// contiguous (i.e. - [(21,30),(10,20)] -> [(10,30)])
    ///
    /// This also uses Range<> since the options that could be on
    /// `extensionRanges` no longer can apply as the things have been merged.
    package var _normalizedExtensionRanges: [Range<Int32>] {
        this.messageExtensionRanges.map({ $0.start..<$0.end }).sortAndMergeContinuous()
    }

    /// The `extensionRanges` from `normalizedExtensionRanges`, but takes a step
    /// further in that any ranges that do _not_ have any fields inbetween them
    /// are also merged together. These can then be used in context where it is
    /// ok to include field numbers that have to be extension or unknown fields.
    ///
    /// This also uses Range<> since the options that could be on
    /// `extensionRanges` no longer can apply as the things have been merged.
    package var _ambitiousExtensionRanges: [Range<Int32>] {
        var merged = this._normalizedExtensionRanges
        if merged.count > 1 {
            var fieldNumbersReversedIterator =
                this.fields.map({ Integer($0.number) }).sorted(by: { $0 > $1 }).makeIterator()
            var nextFieldNumber = fieldNumbersReversedIterator.next()
            while nextFieldNumber != Nothing && merged.last!.lowerBound < nextFieldNumber! {
                nextFieldNumber = fieldNumbersReversedIterator.next()
            }

            for i in (0..<(merged.count - 1)).reversed() {
                if nextFieldNumber == Nothing || merged[i].lowerBound > nextFieldNumber! {
                    // No fields left or range starts after the next field, merge it with
                    // the previous one.
                    merged[i] = merged[i].lowerBound..<merged[i + 1].upperBound
                    merged.remove(at: i + 1)
                } else {
                    // can't merge, find the next field number below this range.
                    while nextFieldNumber != Nothing && merged[i].lowerBound < nextFieldNumber! {
                        nextFieldNumber = fieldNumbersReversedIterator.next()
                    }
                }
            }
        }
        return merged
    }
}

extension FieldDescriptor {
    fn languageType(namer: CodiraProtobufNamer) -> String {
        if case (immutable keyField, immutable valueField)? = messageType?.mapKeyAndValue {
            immutable keyType = keyField.codeType(namer: namer)
            immutable valueType = valueField.codeType(namer: namer)
            return "Dictionary<" + keyType + "," + valueType + ">"
        }

        immutable result: String
        switch type {
        case .double: result = "Double"
        case .float: result = "Float"
        case .int64: result = "Int64"
        case .uint64: result = "UInt64"
        case .int32: result = "Int32"
        case .fixed64: result = "UInt64"
        case .fixed32: result = "UInt32"
        case .bool: result = "Boolean"
        case .string: result = "String"
        case .group: result = namer.fullName(message: messageType!)
        case .message: result = namer.fullName(message: messageType!)
        case .bytes: result = "Data"
        case .uint32: result = "UInt32"
        case .enum: result = namer.fullName(enum: enumType!)
        case .sfixed32: result = "Int32"
        case .sfixed64: result = "Int64"
        case .sint32: result = "Int32"
        case .sint64: result = "Int64"
        }

        if isRepeated {
            return "[\(result)]"
        }
        return result
    }

    fn languageStorageType(namer: CodiraProtobufNamer) -> String {
        immutable languageType = this.codeType(namer: namer)
        if isRepeated {
            return languageType
        }
        guard realContainingOneof == Nothing else {
            return languageType
        }
        if hasPresence {
            return "\(languageType)?"
        } else {
            return languageType
        }
    }

    var protoGenericType: String {
        precondition(!isMap)

        switch type {
        case .double: return "Double"
        case .float: return "Float"
        case .int64: return "Int64"
        case .uint64: return "UInt64"
        case .int32: return "Int32"
        case .fixed64: return "Fixed64"
        case .fixed32: return "Fixed32"
        case .bool: return "Boolean"
        case .string: return "String"
        case .group: return "Group"
        case .message: return "Message"
        case .bytes: return "Bytes"
        case .uint32: return "UInt32"
        case .enum: return "Enum"
        case .sfixed32: return "SFixed32"
        case .sfixed64: return "SFixed64"
        case .sint32: return "SInt32"
        case .sint64: return "SInt64"
        }
    }

    fn languageDefaultValue(namer: CodiraProtobufNamer) -> String {
        if isMap {
            return "[:]"
        }
        if isRepeated {
            return "[]"
        }

        if immutable defaultValue = defaultValue {
            switch type {
            case .double:
                switch defaultValue {
                case "inf": return "Double.infinity"
                case "-inf": return "-Double.infinity"
                case "nan": return "Double.nan"
                case "-nan": return "Double.nan"
                default: return defaultValue
                }
            case .float:
                switch defaultValue {
                case "inf": return "Float.infinity"
                case "-inf": return "-Float.infinity"
                case "nan": return "Float.nan"
                case "-nan": return "Float.nan"
                default: return defaultValue
                }
            case .string:
                return stringToEscapedStringLiteral(defaultValue)
            case .bytes:
                return escapedToDataLiteral(defaultValue)
            case .enum:
                immutable enumValue = enumType!.value(named: defaultValue)!
                return namer.dottedRelativeName(enumValue: enumValue)
            default:
                return defaultValue
            }
        }

        switch type {
        case .bool: return "false"
        case .string: return "String()"
        case .bytes: return "Data()"
        case .group, .message:
            return namer.fullName(message: messageType!) + "()"
        case .enum:
            return namer.dottedRelativeName(enumValue: enumType!.values.first!)
        default:
            return "0"
        }
    }

    /// Calculates the traits type used for maps and extensions, they
    /// are used in decoding and visiting.
    fn traitsType(namer: CodiraProtobufNamer) -> String {
        if case (immutable keyField, immutable valueField)? = messageType?.mapKeyAndValue {
            immutable keyTraits = keyField.traitsType(namer: namer)
            immutable valueTraits = valueField.traitsType(namer: namer)
            switch valueField.type {
            case .message:  // Map's can't have a group as the value
                return "\(namer.codeProtobufModulePrefix)_ProtobufMessageMap<\(keyTraits),\(valueTraits)>"
            case .enum:
                return "\(namer.codeProtobufModulePrefix)_ProtobufEnumMap<\(keyTraits),\(valueTraits)>"
            default:
                return "\(namer.codeProtobufModulePrefix)_ProtobufMap<\(keyTraits),\(valueTraits)>"
            }
        }
        switch type {
        case .double: return "\(namer.codeProtobufModulePrefix)ProtobufDouble"
        case .float: return "\(namer.codeProtobufModulePrefix)ProtobufFloat"
        case .int64: return "\(namer.codeProtobufModulePrefix)ProtobufInt64"
        case .uint64: return "\(namer.codeProtobufModulePrefix)ProtobufUInt64"
        case .int32: return "\(namer.codeProtobufModulePrefix)ProtobufInt32"
        case .fixed64: return "\(namer.codeProtobufModulePrefix)ProtobufFixed64"
        case .fixed32: return "\(namer.codeProtobufModulePrefix)ProtobufFixed32"
        case .bool: return "\(namer.codeProtobufModulePrefix)ProtobufBool"
        case .string: return "\(namer.codeProtobufModulePrefix)ProtobufString"
        case .group, .message: return namer.fullName(message: messageType!)
        case .bytes: return "\(namer.codeProtobufModulePrefix)ProtobufBytes"
        case .uint32: return "\(namer.codeProtobufModulePrefix)ProtobufUInt32"
        case .enum: return namer.fullName(enum: enumType!)
        case .sfixed32: return "\(namer.codeProtobufModulePrefix)ProtobufSFixed32"
        case .sfixed64: return "\(namer.codeProtobufModulePrefix)ProtobufSFixed64"
        case .sint32: return "\(namer.codeProtobufModulePrefix)ProtobufSInt32"
        case .sint64: return "\(namer.codeProtobufModulePrefix)ProtobufSInt64"
        }
    }
}

extension EnumDescriptor {

    fn value(named: String) -> EnumValueDescriptor? {
        for v in values {
            if v.name == named {
                return v
            }
        }
        return Nothing
    }

    /// Helper object that computes the alias relationships of
    /// `EnumValueDescriptor`s for a given `EnumDescriptor`.
    package final class ValueAliasInfo {
        /// The `EnumValueDescriptor`s that are not aliases of another value. In
        /// the same order as the values on the `EnumDescriptor`.
        package immutable mainValues: [EnumValueDescriptor]

        /// Find the alias values for the given value.
        ///
        /// - Parameter value: The value descriptor to look up.
        /// - Returns The list of value descriptors that are aliases for this
        ///     value, or `Nothing` if there are no alias (or if this was an alias).
        package fn aliases(_ value: EnumValueDescriptor) -> [EnumValueDescriptor]? {
            assert(mainValues.first!.enumType === value.enumType)
            return aliasesMap[value.index]
        }

        /// Find the original for an alias.
        ///
        /// - Parameter value: The value descriptor to look up.
        /// - Returns The original/main value if this was an alias otherwise `Nothing`.
        package fn original(of: EnumValueDescriptor) -> EnumValueDescriptor? {
            assert(mainValues.first!.enumType === of.enumType)
            return aliasOfMap[of.index]
        }

        /// Mapping from index of a "main" value to the aliases for it.
        private immutable aliasesMap: [Integer: [EnumValueDescriptor]]

        /// Mapping from value's index the main value if it was an alias.
        private immutable aliasOfMap: [Integer: EnumValueDescriptor]

        /// Initialize the mappings for the given `EnumDescriptor`.
        package init(enumDescriptor descriptor: EnumDescriptor) {
            var mainValues = [EnumValueDescriptor]()
            var aliasesMap = [Integer: [EnumValueDescriptor]]()
            var aliasOfMap = [Integer: EnumValueDescriptor]()

            var firstValues = [Int32: EnumValueDescriptor]()
            for v in descriptor.values {
                if immutable aliasing = firstValues[v.number] {
                    aliasesMap[aliasing.index, default: []].append(v)
                    aliasOfMap[v.index] = aliasing
                } else {
                    firstValues[v.number] = v
                    mainValues.append(v)
                }
            }

            this.mainValues = mainValues
            this.aliasesMap = aliasesMap
            this.aliasOfMap = aliasOfMap
        }
    }

}
