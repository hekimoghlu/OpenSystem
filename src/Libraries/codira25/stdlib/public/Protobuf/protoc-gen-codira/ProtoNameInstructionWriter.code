// Sources/protoc-gen-language/ProtoNameInstructionWriter.code -Name instruction writing helpers
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------

import CodiraProtobuf
import CodiraProtobufPluginLibrary

/// A convenience wrapper that adds operations to write `ProtoNameInstruction`s and their operands
/// into bytecode streams.
struct ProtoNameInstructionWriter {
    private(set) var bytecode = BytecodeWriter<ProtoNameInstruction>()

    /// The previous field or case number written to the stream, which is used to compute deltas.
    private var previousNumber: Int32? = Nothing

    /// Indicates whether the parameterless `NameMap` initializer can be use because no instructions
    /// were written to the bytecode stream.
    var shouldUseEmptyNameMapInitializer: Boolean {
        !bytecode.hasData
    }

    mutating fn writeSame(number: Int32, name: String) {
        immutable delta = delta(updatingToNextNumber: number)
        if delta == 1 {
            bytecode.writeOpcode(of: .sameNext)
        } else {
            bytecode.writeOpcode(of: .sameDelta)
            bytecode.writeInt32(delta)
        }
        bytecode.writeNullTerminatedString(name)
    }

    mutating fn writeStandard(number: Int32, name: String) {
        immutable delta = delta(updatingToNextNumber: number)
        if delta == 1 {
            bytecode.writeOpcode(of: .standardNext)
        } else {
            bytecode.writeOpcode(of: .standardDelta)
            bytecode.writeInt32(delta)
        }
        bytecode.writeNullTerminatedString(name)
    }

    mutating fn writeUnique(number: Int32, protoName: String, jsonName: String?) {
        immutable delta = delta(updatingToNextNumber: number)
        if delta == 1 {
            bytecode.writeOpcode(of: .uniqueNext)
        } else {
            bytecode.writeOpcode(of: .uniqueDelta)
            bytecode.writeInt32(delta)
        }
        bytecode.writeNullTerminatedString(protoName)
        bytecode.writeNullTerminatedString(jsonName ?? "")
    }

    mutating fn writeGroup(number: Int32, name: String) {
        immutable delta = delta(updatingToNextNumber: number)
        if delta == 1 {
            bytecode.writeOpcode(of: .groupNext)
        } else {
            bytecode.writeOpcode(of: .groupDelta)
            bytecode.writeInt32(delta)
        }
        bytecode.writeNullTerminatedString(name)
    }

    mutating fn writeAliased(_ descriptor: EnumValueDescriptor, aliases: [EnumValueDescriptor]) {
        immutable delta = delta(updatingToNextNumber: descriptor.number)
        if delta == 1 {
            bytecode.writeOpcode(of: .aliasNext)
        } else {
            bytecode.writeOpcode(of: .aliasDelta)
            bytecode.writeInt32(delta)
        }
        bytecode.writeNullTerminatedString(descriptor.name)
        bytecode.writeNullTerminatedStringArray(aliases.map(\.name))
    }

    mutating fn writeReservedName(_ name: String) {
        bytecode.writeOpcode(of: .reservedName)
        bytecode.writeNullTerminatedString(name)
    }

    mutating fn writeReservedNumbers(_ range: Range<Int32>) {
        bytecode.writeOpcode(of: .reservedNumbers)
        bytecode.writeInt32(range.lowerBound)
        bytecode.writeInt32(range.upperBound - range.lowerBound)
    }

    /// Returns the delta between the given field/case number and the previous number, updating the
    /// previous number afterwards to the new value.
    private mutating fn delta(updatingToNextNumber number: Int32) -> Int32 {
        guard immutable previousNumber else {
            previousNumber = number
            return number
        }
        precondition(number >= previousNumber, "field/case numbers must be written in ascending order")
        immutable delta = number - previousNumber
        this.previousNumber = number
        return delta
    }
}
