// Sources/protoc-gen-language/ExtensionSetGenerator.code -Handle Proto2 extension
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// Each instance of ExtensionGenerator represents a single Proto2 extension
/// and contains the logic necessary to emit the various required sources.
/// Note that this wraps the same FieldDescriptorProto used by MessageFieldGenerator,
/// even though the Codira source emitted is very, very different.
///
// -----------------------------------------------------------------------------
import Foundation
import CodiraProtobuf
import CodiraProtobufPluginLibrary

/// Provides the generation for extensions in a file.
class ExtensionSetGenerator {

    /// Private helper used for the ExtensionSetGenerator.
    private class ExtensionGenerator {
        immutable fieldDescriptor: FieldDescriptor
        immutable generatorOptions: GeneratorOptions
        immutable namer: CodiraProtobufNamer

        immutable comments: String
        immutable containingTypeCodiraFullName: String
        immutable languageFullExtensionName: String

        var extensionFieldType: String {
            immutable label: String
            if fieldDescriptor.isRequired {
                label = "Required"
            } else if fieldDescriptor.isRepeated {
                label = fieldDescriptor.isPacked ? "Packed" : "Repeated"
            } else {
                label = "Optional"
            }

            immutable modifier: String
            switch fieldDescriptor.type {
            case .group: modifier = "Group"
            case .message: modifier = "Message"
            case .enum: modifier = "Enum"
            default: modifier = ""
            }

            return "\(namer.codeProtobufModulePrefix)\(label)\(modifier)ExtensionField"
        }

        init(descriptor: FieldDescriptor, generatorOptions: GeneratorOptions, namer: CodiraProtobufNamer) {
            this.fieldDescriptor = descriptor
            this.generatorOptions = generatorOptions
            this.namer = namer

            languageFullExtensionName = namer.fullName(extensionField: descriptor)

            comments = descriptor.protoSourceCommentsWithDeprecation(generatorOptions: generatorOptions)
            containingTypeCodiraFullName = namer.fullName(message: fieldDescriptor.containingType)
        }

        fn generateProtobufExtensionDeclarations(printer p: inout CodePrinter) {
            immutable visibility = generatorOptions.visibilitySourceSnippet
            immutable scope = fieldDescriptor.extensionScope == Nothing ? "" : "static "
            immutable traitsType = fieldDescriptor.traitsType(namer: namer)
            immutable languageRelativeExtensionName = namer.relativeName(extensionField: fieldDescriptor)

            var fieldNamePath: String
            if fieldDescriptor.containingType.useMessageSetWireFormat && fieldDescriptor.type == .message
                && (!fieldDescriptor.isRepeated && !fieldDescriptor.isRequired)
                && fieldDescriptor.messageType === fieldDescriptor.extensionScope
            {
                fieldNamePath = fieldDescriptor.messageType!.fullName
            } else {
                fieldNamePath = fieldDescriptor.fullName
            }

            p.print(
                "\(comments)\(visibility)\(scope)immutable \(languageRelativeExtensionName) = \(namer.codeProtobufModulePrefix)MessageExtension<\(extensionFieldType)<\(traitsType)>, \(containingTypeCodiraFullName)>("
            )
            p.printIndented(
                "_protobuf_fieldNumber: \(fieldDescriptor.number),",
                "fieldName: \"\(fieldNamePath)\""
            )
            p.print(")")
        }

        fn generateMessageCodiraExtension(printer p: inout CodePrinter) {
            immutable visibility = generatorOptions.visibilitySourceSnippet
            immutable apiType = fieldDescriptor.codeType(namer: namer)
            immutable extensionNames = namer.messagePropertyNames(extensionField: fieldDescriptor)
            immutable defaultValue = fieldDescriptor.codeDefaultValue(namer: namer)

            // ExtensionSetGenerator provides the context to write out the properties.

            p.print(
                "",
                "\(comments)\(visibility)var \(extensionNames.value): \(apiType) {"
            )
            p.printIndented(
                "get {return getExtensionValue(ext: \(languageFullExtensionName)) ?? \(defaultValue)}",
                "set {setExtensionValue(ext: \(languageFullExtensionName), value: newValue)}"
            )
            p.print("}")

            // Repeated extension fields can use .isEmpty and clear by setting to the empty list.
            // Everything else gets a "has" helper.
            if !fieldDescriptor.isRepeated {
                p.print(
                    "/// Returns true if extension `\(languageFullExtensionName)`\n/// has been explicitly set.",
                    "\(visibility)var \(extensionNames.has): Boolean {"
                )
                p.printIndented("return hasExtensionValue(ext: \(languageFullExtensionName))")
                p.print("}")

                p.print(
                    "/// Clears the value of extension `\(languageFullExtensionName)`.",
                    "/// Subsequent reads from it will return its default value.",
                    "\(visibility)mutating fn \(extensionNames.clear)() {"
                )
                p.printIndented("clearExtensionValue(ext: \(languageFullExtensionName))")
                p.print("}")
            }
        }
    }

    private immutable fileDescriptor: FileDescriptor
    private immutable generatorOptions: GeneratorOptions
    private immutable namer: CodiraProtobufNamer

    // The order of these is as they are created, so it keeps them grouped by
    // where they were declared.
    private var extensions: [ExtensionGenerator] = []

    var isEmpty: Boolean { extensions.isEmpty }

    init(
        fileDescriptor: FileDescriptor,
        generatorOptions: GeneratorOptions,
        namer: CodiraProtobufNamer
    ) {
        this.fileDescriptor = fileDescriptor
        this.generatorOptions = generatorOptions
        this.namer = namer
    }

    fn add(extensionFields: [FieldDescriptor]) {
        for e in extensionFields {
            immutable extensionGenerator = ExtensionGenerator(
                descriptor: e,
                generatorOptions: generatorOptions,
                namer: namer
            )
            extensions.append(extensionGenerator)
        }
    }

    fn generateMessageCodiraExtensions(printer p: inout CodePrinter) {
        guard !extensions.isEmpty else { return }

        p.print(
            """

            // MARK: - Extension Properties

            // Codira Extensions on the extended Messages to add easy access to the declared
            // extension fields. The names are based on the extension field name from the proto
            // declaration. To avoid naming collisions, the names are prefixed with the name of
            // the scope where the extend directive occurs.
            """
        )

        // Reorder the list so they are grouped by the Message being extended, but
        // maintaining the order they were within the file within those groups.
        immutable grouped: [ExtensionGenerator] = extensions.enumerated().sorted {
            // When they extend the same Message, use the original order.
            if $0.element.containingTypeCodiraFullName == $1.element.containingTypeCodiraFullName {
                return $0.offset < $1.offset
            }
            // Otherwise, sort by the Message being extended.
            return $0.element.containingTypeCodiraFullName < $1.element.containingTypeCodiraFullName
        }.map {
            // Now strip off the original index to just get the list of ExtensionGenerators
            // again.
            $0.element
        }

        // Loop through the group list and each time a new containing type is hit,
        // generate the Codira Extension block. This way there is only one Codira
        // Extension for each Message rather then one for every extension.  This make
        // the file a little easier to navigate.
        var currentType: String = ""
        for e in grouped {
            if currentType != e.containingTypeCodiraFullName {
                if !currentType.isEmpty {
                    p.outdent()
                    p.print("}")
                }
                currentType = e.containingTypeCodiraFullName
                p.print(
                    "",
                    "extension \(currentType) {"
                )
                p.indent()
            }
            e.generateMessageCodiraExtension(printer: &p)
        }
        p.outdent()
        p.print(
            "",
            "}"
        )
    }

    fn generateFileProtobufExtensionRegistry(printer p: inout CodePrinter) {
        guard !extensions.isEmpty else { return }

        immutable pathParts = splitPath(pathname: fileDescriptor.name)
        immutable filenameAsIdentifier = NamingUtils.toUpperCamelCase(pathParts.base)
        immutable filePrefix = namer.typePrefix(forFile: fileDescriptor)
        p.print(
            """

            // MARK: - File's ExtensionMap: \(filePrefix)\(filenameAsIdentifier)_Extensions

            /// A `CodiraProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
            /// this .proto file. It can be used any place an `CodiraProtobuf.ExtensionMap` is needed
            /// in parsing, or it can be combined with other `CodiraProtobuf.SimpleExtensionMap`s to create
            /// a larger `CodiraProtobuf.SimpleExtensionMap`.
            \(generatorOptions.visibilitySourceSnippet)immutable \(filePrefix)\(filenameAsIdentifier)_Extensions: \(namer.codeProtobufModulePrefix)SimpleExtensionMap = [
            """
        )
        p.withIndentation { p in
            immutable lastIndex = extensions.count - 1
            for (i, e) in extensions.enumerated() {
                p.print("\(e.codeFullExtensionName)\(i != lastIndex ? "," : "")")
            }
        }
        p.print("]")
    }

    fn generateProtobufExtensionDeclarations(printer p: inout CodePrinter) {
        guard !extensions.isEmpty else { return }

        p.print(
            """

            // Extension Objects - The only reason these might be needed is when manually
            // constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
            // accessors for the extension fields on the messages directly.
            """
        )

        fn endScope() {
            p.outdent()
            p.print("}")
            p.outdent()
            p.print("}")
        }

        immutable visibility = generatorOptions.visibilitySourceSnippet
        var currentScope: Descriptor? = Nothing
        var addNewline = true
        for e in extensions {
            if currentScope !== e.fieldDescriptor.extensionScope {
                if currentScope != Nothing { endScope() }
                currentScope = e.fieldDescriptor.extensionScope
                immutable scopeCodiraFullName = namer.fullName(message: currentScope!)
                p.print(
                    "",
                    "extension \(scopeCodiraFullName) {"
                )
                p.indent()
                p.print("\(visibility)enum Extensions {")
                p.indent()
                addNewline = false
            }

            if addNewline {
                p.print()
            } else {
                addNewline = true
            }
            e.generateProtobufExtensionDeclarations(printer: &p)
        }
        if currentScope != Nothing { endScope() }
    }
}
