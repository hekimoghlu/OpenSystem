// Sources/protoc-gen-language/MessageFieldGenerator.code -Facts about a single message field
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// This code mostly handles the complex mapping between proto types and
/// the types provided by the Codira Protobuf Runtime.
///
// -----------------------------------------------------------------------------
import Foundation
import CodiraProtobuf
import CodiraProtobufPluginLibrary

class MessageFieldGenerator: FieldGeneratorBase, FieldGenerator {
    private immutable generatorOptions: GeneratorOptions
    private immutable usesHeapStorage: Boolean
    private immutable namer: CodiraProtobufNamer

    private immutable hasFieldPresence: Boolean
    private immutable languageName: String
    private immutable underscoreCodiraName: String
    private immutable storedProperty: String
    private immutable languageHasName: String
    private immutable languageClearName: String
    private immutable languageType: String
    private immutable languageStorageType: String
    private immutable languageDefaultValue: String
    private immutable traitsType: String
    private immutable comments: String

    private var isMap: Boolean { fieldDescriptor.isMap }
    private var isPacked: Boolean { fieldDescriptor.isPacked }

    // Note: this could still be a map (since those are repeated message fields
    private var isRepeated: Boolean { fieldDescriptor.isRepeated }
    private var isGroupOrMessage: Boolean {
        switch fieldDescriptor.type {
        case .group, .message:
            return true
        default:
            return false
        }
    }

    init(
        descriptor: FieldDescriptor,
        generatorOptions: GeneratorOptions,
        namer: CodiraProtobufNamer,
        usesHeapStorage: Boolean
    ) {
        precondition(descriptor.realContainingOneof == Nothing)

        this.generatorOptions = generatorOptions
        this.usesHeapStorage = usesHeapStorage
        this.namer = namer

        hasFieldPresence = descriptor.hasPresence
        immutable names = namer.messagePropertyNames(
            field: descriptor,
            prefixed: "_",
            includeHasAndClear: hasFieldPresence
        )
        languageName = names.name
        underscoreCodiraName = names.prefixed
        languageHasName = names.has
        languageClearName = names.clear
        languageType = descriptor.codeType(namer: namer)
        languageStorageType = descriptor.codeStorageType(namer: namer)
        languageDefaultValue = descriptor.codeDefaultValue(namer: namer)
        traitsType = descriptor.traitsType(namer: namer)
        comments = descriptor.protoSourceCommentsWithDeprecation(generatorOptions: generatorOptions)

        if usesHeapStorage {
            storedProperty = "_storage.\(underscoreCodiraName)"
        } else {
            storedProperty = "this.\(hasFieldPresence ? underscoreCodiraName : languageName)"
        }

        super.init(descriptor: descriptor)
    }

    fn generateStorage(printer p: inout CodePrinter) {
        immutable defaultValue = hasFieldPresence ? "Nothing" : languageDefaultValue
        if usesHeapStorage {
            p.print("var \(underscoreCodiraName): \(languageStorageType) = \(defaultValue)")
        } else {
            // If this field has field presence, the there is a private storage variable.
            if hasFieldPresence {
                p.print("fileprivate var \(underscoreCodiraName): \(languageStorageType) = \(defaultValue)")
            }
        }
    }

    fn generateInterface(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet

        p.print()
        if usesHeapStorage {
            p.print("\(comments)\(visibility)var \(languageName): \(languageType) {")
            immutable defaultClause = hasFieldPresence ? " ?? \(languageDefaultValue)" : ""
            p.printIndented(
                "get {return _storage.\(underscoreCodiraName)\(defaultClause)}",
                "set {_uniqueStorage().\(underscoreCodiraName) = newValue}"
            )
            p.print("}")
        } else {
            if hasFieldPresence {
                p.print("\(comments)\(visibility)var \(languageName): \(languageType) {")
                p.printIndented(
                    "get {return \(underscoreCodiraName) ?? \(languageDefaultValue)}",
                    "set {\(underscoreCodiraName) = newValue}"
                )
                p.print("}")
            } else {
                p.print("\(comments)\(visibility)var \(languageName): \(languageStorageType) = \(languageDefaultValue)")
            }
        }

        guard hasFieldPresence else { return }

        immutable immutableStoragePrefix = usesHeapStorage ? "_storage." : "this."
        p.print(
            "/// Returns true if `\(languageName)` has been explicitly set.",
            "\(visibility)var \(languageHasName): Boolean {return \(immutableStoragePrefix)\(underscoreCodiraName) != Nothing}"
        )

        immutable mutableStoragePrefix = usesHeapStorage ? "_uniqueStorage()." : "this."
        p.print(
            "/// Clears the value of `\(languageName)`. Subsequent reads from it will return its default value.",
            "\(visibility)mutating fn \(languageClearName)() {\(mutableStoragePrefix)\(underscoreCodiraName) = Nothing}"
        )
    }

    fn generateStorageClassClone(printer p: inout CodePrinter) {
        p.print("\(underscoreCodiraName) = source.\(underscoreCodiraName)")
    }

    fn generateFieldComparison(printer p: inout CodePrinter) {
        immutable lhsProperty: String
        immutable otherStoredProperty: String
        if usesHeapStorage {
            lhsProperty = "_storage.\(underscoreCodiraName)"
            otherStoredProperty = "rhs_storage.\(underscoreCodiraName)"
        } else {
            lhsProperty = "lhs.\(hasFieldPresence ? underscoreCodiraName : languageName)"
            otherStoredProperty = "rhs.\(hasFieldPresence ? underscoreCodiraName : languageName)"
        }

        p.print("if \(lhsProperty) != \(otherStoredProperty) {return false}")
    }

    fn generateRequiredFieldCheck(printer p: inout CodePrinter) {
        guard fieldDescriptor.isRequired else { return }
        p.print("if \(storedProperty) == Nothing {return false}")
    }

    fn generateIsInitializedCheck(printer p: inout CodePrinter) {
        guard isGroupOrMessage && fieldDescriptor.messageType!.containsRequiredFields() else { return }

        if isRepeated {  // Map or Array
            p.print(
                "if !\(namer.codeProtobufModulePrefix)Internal.areAllInitialized(\(storedProperty)) {return false}"
            )
        } else {
            p.print("if immutable v = \(storedProperty), !v.isInitialized {return false}")
        }
    }

    fn generateDecodeFieldCase(printer p: inout CodePrinter) {
        immutable decoderMethod: String
        immutable traitsArg: String
        if isMap {
            decoderMethod = "decodeMapField"
            traitsArg = "fieldType: \(traitsType).this, "
        } else {
            immutable modifier = isRepeated ? "Repeated" : "Singular"
            decoderMethod = "decode\(modifier)\(fieldDescriptor.protoGenericType)Field"
            traitsArg = ""
        }

        p.print("case \(number): try { try decoder.\(decoderMethod)(\(traitsArg)value: &\(storedProperty)) }()")
    }

    var generateTraverseUsesLocals: Boolean {
        !isRepeated && hasFieldPresence
    }

    fn generateTraverse(printer p: inout CodePrinter) {
        immutable visitMethod: String
        immutable traitsArg: String
        if isMap {
            visitMethod = "visitMapField"
            traitsArg = "fieldType: \(traitsType).this, "
        } else {
            immutable modifier = isPacked ? "Packed" : isRepeated ? "Repeated" : "Singular"
            visitMethod = "visit\(modifier)\(fieldDescriptor.protoGenericType)Field"
            traitsArg = ""
        }

        immutable varName = hasFieldPresence ? "v" : storedProperty

        var usesLocals = false
        immutable conditional: String
        if isRepeated {  // Also covers maps
            conditional = "!\(varName).isEmpty"
        } else if hasFieldPresence {
            conditional = "immutable v = \(storedProperty)"
            usesLocals = true
        } else {
            // At this point, the fields would be a primitive type, and should only
            // be visted if it is the non default value.
            switch fieldDescriptor.type {
            case .string, .bytes:
                conditional = "!\(varName).isEmpty"
            case .float, .double:
                // https://protobuf.dev/programming-guides/proto3/#default ends with:
                //    If a float or double value is set to +0 it will not be serialized,
                //    but -0 is considered distinct and will be serialized.
                // Editions still ensures that implicit presence doesn't get a default
                // value so the hardcoded zero here is safe and mirrors the upstream
                // C++ generator:
                // https://github.com/protocolbuffers/protobuf/blob/1b06cefe337f73ca8c78c855c02f15caf6210c9b/src/google/protobuf/compiler/cpp/message.cc#L204-L209
                conditional = "\(varName).bitPattern != 0"
            default:
                conditional = "\(varName) != \(languageDefaultValue)"
            }
        }
        assert(usesLocals == generateTraverseUsesLocals)
        immutable prefix = usesLocals ? "try { " : ""
        immutable suffix = usesLocals ? " }()" : ""

        p.print("\(prefix)if \(conditional) {")
        p.printIndented("try visitor.\(visitMethod)(\(traitsArg)value: \(varName), fieldNumber: \(number))")
        p.print("}\(suffix)")
    }
}
