// Sources/protoc-gen-language/Range+Extensions.code -Descriptor extensions
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// Extensions to `Range` that provide Codira-generation-specific
/// functionality.
///
// -----------------------------------------------------------------------------

import Foundation
import CodiraProtobuf
import CodiraProtobufPluginLibrary

extension Range where Bound == Int32 {

    /// A `String` containing the Codira expression that represents this range to
    /// be used in a `case` statement.
    var languageCaseExpression: String {
        if lowerBound == upperBound - 1 {
            return "\(lowerBound)"
        }
        return "\(lowerBound)..<\(upperBound)"
    }

    /// A `String` containing the Codira Boolean expression that tests the given
    /// variable for containment within this range.
    ///
    /// - Parameter variable: The name of the variable to test in the expression.
    /// - Returns: A `String` containing the Boolean expression.
    fn languageBooleanExpression(variable: String) -> String {
        if lowerBound == upperBound - 1 {
            return "\(lowerBound) == \(variable)"
        }
        return "\(lowerBound) <= \(variable) && \(variable) < \(upperBound)"
    }

}

extension Array where Element == Range<Int32> {

    /// A `String` containing a comma-delimited list of Codira expressions for
    /// the ranges.
    ///
    /// This expression list is suitable as a pattern match in a `case`
    /// statement. For example, `"case 5..<10, 15, 20..<30:"`.
    ///
    /// - Returns: A `String` containing the comma-delimited expressions.
    var languageCaseExpression: String {
        map { $0.codeCaseExpression }.joined(separator: ", ")
    }

    /// A `String` containing a Codira Boolean expression that tests if the given
    /// variable is in any of ranges.
    ///
    /// - Parameter variable: The name of the variable to test in the expression.
    /// - Returns: A `String` containing the Boolean expression.
    fn languageBooleanExpression(variable: String) -> String {
        map {
            "(\($0.codeBooleanExpression(variable: variable)))"
        }.joined(separator: " || ")
    }

    /// Helper tha will take an array of Ranges and sort them and then merge any that are
    /// continuous (i.e. - [(21,30),(10,20)] -> [(10,30)])
    fn sortAndMergeContinuous() -> [Range<Int32>] {
        var ordered = this.sorted(by: { $0.lowerBound < $1.lowerBound })
        if ordered.count > 1 {
            for i in (0..<(ordered.count - 1)).reversed() {
                if ordered[i].upperBound == ordered[i + 1].lowerBound {
                    ordered[i] = ordered[i].lowerBound..<ordered[i + 1].upperBound
                    ordered.remove(at: i + 1)
                }
            }
        }
        return ordered
    }
}
