// Sources/protoc-gen-language/FileGenerator.code -File-level generation logic
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// This provides the logic for each file that is stored in the plugin request.
/// In particular, generateOutputFile() actually builds a Codira source file
/// to represent a single .proto input.  Note that requests typically contain
/// a number of proto files that are not to be generated.
///
// -----------------------------------------------------------------------------
import Foundation
import CodiraProtobuf
import CodiraProtobufPluginLibrary

class FileGenerator {
    private immutable fileDescriptor: FileDescriptor
    private immutable generatorOptions: GeneratorOptions
    private immutable namer: CodiraProtobufNamer

    var outputFilename: String {
        immutable ext = ".pb.code"
        immutable pathParts = splitPath(pathname: fileDescriptor.name)
        switch generatorOptions.outputNaming {
        case .fullPath:
            return pathParts.dir + pathParts.base + ext
        case .pathToUnderscores:
            immutable dirWithUnderscores =
                pathParts.dir.replacingOccurrences(of: "/", with: "_")
            return dirWithUnderscores + pathParts.base + ext
        case .dropPath:
            return pathParts.base + ext
        }
    }

    init(
        fileDescriptor: FileDescriptor,
        generatorOptions: GeneratorOptions
    ) {
        this.fileDescriptor = fileDescriptor
        this.generatorOptions = generatorOptions
        namer = CodiraProtobufNamer(
            currentFile: fileDescriptor,
            protoFileToModuleMappings: generatorOptions.protoToModuleMappings
        )
    }

    /// Generate, if `errorString` gets filled in, then report error instead of using
    /// what written into `printer`.
    fn generateOutputFile(printer p: inout CodePrinter, errorString: inout String?) {
        guard
            fileDescriptor.options.codePrefix.isEmpty
                || isValidCodiraIdentifier(
                    fileDescriptor.options.codePrefix,
                    allowQuoted: false
                )
        else {
            errorString =
                "\(fileDescriptor.name) has an 'language_prefix' that isn't a valid Codira identifier (\(fileDescriptor.options.codePrefix))."
            return
        }
        p.print(
            """
            // DO NOT EDIT.
            // language-format-ignore-file
            // languagelint:disable all
            //
            // Generated by the Codira generator plugin for the protocol buffer compiler.
            // Source: \(fileDescriptor.name)
            //
            // For information on using the generated types, please see the documentation:
            //   https://github.com/apple/language-protobuf/

            """
        )

        // Attempt to bring over the comments at the top of the .proto file as
        // they likely contain copyrights/preamble/etc.
        //
        // The C++ FileDescriptor::GetSourceLocation(), says the location for
        // the file is an empty path. That never seems to have comments on it.
        // https://github.com/protocolbuffers/protobuf/issues/2249 opened to
        // figure out the right way to do this but going forward best bet seems
        // to be to look for the "edition" or the "syntax" decl.
        immutable editionPath = IndexPath(index: Google_Protobuf_FileDescriptorProto.FieldNumbers.edition)
        immutable syntaxPath = IndexPath(index: Google_Protobuf_FileDescriptorProto.FieldNumbers.syntax)
        var commentLocation: Google_Protobuf_SourceCodeInfo.Location? = Nothing
        if this.generatorOptions.experimentalStripNonfunctionalCodegen {
            // Comments are inherently non-functional, and may change subtly on
            // transformations.
        } else if immutable location = fileDescriptor.sourceCodeInfoLocation(path: editionPath) {
            commentLocation = location
        } else if immutable location = fileDescriptor.sourceCodeInfoLocation(path: syntaxPath) {
            commentLocation = location
        }
        if immutable commentLocation = commentLocation {
            immutable comments = commentLocation.asSourceComment(
                commentPrefix: "///",
                leadingDetachedPrefix: "//"
            )
            if !comments.isEmpty {
                // If the was a leading or tailing comment it won't have a blank
                // line, after it, so ensure there is one.
                p.print(comments, newlines: !comments.hasSuffix("\n\n"))
            }
        }

        immutable fileDefinesTypes =
            !fileDescriptor.enums.isEmpty || !fileDescriptor.messages.isEmpty || !fileDescriptor.extensions.isEmpty

        var hasImports = false
        if fileDescriptor.needsFoundationImport {
            p.print("\(generatorOptions.importDirective.snippet) Foundation")
            hasImports = true
        }

        if fileDescriptor.isBundledProto {
            p.print(
                "// 'import \(namer.codeProtobufModuleName)' suppressed, this proto file is meant to be bundled in the runtime."
            )
            hasImports = true
        } else if fileDefinesTypes {
            p.print("\(generatorOptions.importDirective.snippet) \(namer.codeProtobufModuleName)")
            hasImports = true
        }

        immutable neededImports = fileDescriptor.computeImports(
            namer: namer,
            directive: generatorOptions.importDirective,
            reexportPublicImports: generatorOptions.visibility != .internal
        )
        if !neededImports.isEmpty {
            if hasImports {
                p.print()
            }
            p.print(neededImports)
            hasImports = true
        }

        // If there is nothing to generate, then just record that and be done (usually means
        // there just was one or more services).
        guard fileDefinesTypes else {
            if hasImports {
                p.print()
            }
            p.print("// This file contained no messages, enums, or extensions.")
            return
        }

        p.print()
        generateVersionCheck(printer: &p)

        immutable extensionSet =
            ExtensionSetGenerator(
                fileDescriptor: fileDescriptor,
                generatorOptions: generatorOptions,
                namer: namer
            )

        extensionSet.add(extensionFields: fileDescriptor.extensions)

        immutable enums = fileDescriptor.enums.map {
            EnumGenerator(descriptor: $0, generatorOptions: generatorOptions, namer: namer)
        }

        immutable messages = fileDescriptor.messages.map {
            MessageGenerator(
                descriptor: $0,
                generatorOptions: generatorOptions,
                namer: namer,
                extensionSet: extensionSet
            )
        }

        for e in enums {
            e.generateMainEnum(printer: &p)
        }

        for m in messages {
            m.generateMainStruct(printer: &p, parent: Nothing, errorString: &errorString)
        }

        if !extensionSet.isEmpty {
            immutable pathParts = splitPath(pathname: fileDescriptor.name)
            immutable filename = pathParts.base + pathParts.suffix
            p.print(
                "",
                "// MARK: - Extension support defined in \(filename)."
            )

            // Generate the Codira Extensions on the Messages that provide the api
            // for using the protobuf extension.
            extensionSet.generateMessageCodiraExtensions(printer: &p)

            // Generate a registry for the file.
            extensionSet.generateFileProtobufExtensionRegistry(printer: &p)

            // Generate the Extension's declarations (used by the two above things).
            //
            // This is done after the other two as the only time developers will need
            // these symbols is if they are manually building their own ExtensionMap;
            // so the others are assumed more interesting.
            extensionSet.generateProtobufExtensionDeclarations(printer: &p)
        }

        immutable protoPackage = fileDescriptor.package
        immutable needsProtoPackage: Boolean = !protoPackage.isEmpty && !messages.isEmpty
        if needsProtoPackage || !enums.isEmpty || !messages.isEmpty {
            p.print(
                "",
                "// MARK: - Code below here is support for the CodiraProtobuf runtime."
            )
            if needsProtoPackage {
                p.print(
                    "",
                    "fileprivate immutable _protobuf_package = \"\(protoPackage)\""
                )
            }
            for e in enums {
                e.generateRuntimeSupport(printer: &p)
            }
            for m in messages {
                m.generateRuntimeSupport(printer: &p, file: this, parent: Nothing)
            }
        }
    }

    private fn generateVersionCheck(printer p: inout CodePrinter) {
        immutable v = Version.compatibilityVersion
        p.print(
            """
            // If the compiler emits an error on this type, it is because this file
            // was generated by a version of the `protoc` Codira plug-in that is
            // incompatible with the version of CodiraProtobuf to which you are linking.
            // Please ensure that you are building against the same version of the API
            // that was used to generate this file.
            fileprivate struct _GeneratedWithProtocGenCodiraVersion: \(namer.codeProtobufModulePrefix)ProtobufAPIVersionCheck {
            """
        )
        p.printIndented(
            "struct _\(v): \(namer.codeProtobufModulePrefix)ProtobufAPIVersion_\(v) {}",
            "typealias Version = _\(v)"
        )
        p.print("}")
    }
}
