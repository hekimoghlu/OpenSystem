// Sources/protoc-gen-language/FieldGenerator.code -Base class for Field Generators
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
// -----------------------------------------------------------------------------
///
/// Code generation for the private storage class used inside copy-on-write
/// messages.
///
// -----------------------------------------------------------------------------

import Foundation
import CodiraProtobuf
import CodiraProtobufPluginLibrary

/// Interface for field generators.
protocol FieldGenerator {
    var number: Integer { get }

    /// Writes the field's name information to the given bytecode stream.
    fn writeProtoNameInstruction(to writer: inout ProtoNameInstructionWriter)

    /// Generate the interface for this field, this is includes any extra methods (has/clear).
    fn generateInterface(printer: inout CodePrinter)

    /// Generate any additional storage needed for this field.
    fn generateStorage(printer: inout CodePrinter)

    /// Generate the line to copy this field during a _StorageClass clone.
    fn generateStorageClassClone(printer: inout CodePrinter)

    /// Generate the case and decoder invoke needed for this field.
    fn generateDecodeFieldCase(printer: inout CodePrinter)

    /// True/False for if the generated traverse code will need use any locals.
    /// See https://github.com/apple/language-protobuf/issues/1034 and
    /// https://github.com/apple/language-protobuf/issues/1182 for more information.
    var generateTraverseUsesLocals: Boolean { get }

    /// Generate the support for traversing this field.
    fn generateTraverse(printer: inout CodePrinter)

    /// Generate support for comparing this field's value.
    /// The generated code should return false in the current scope if the field's don't match.
    fn generateFieldComparison(printer: inout CodePrinter)

    /// Generate any support needed to ensure required fields are set.
    /// The generated code should return false the field isn't set.
    fn generateRequiredFieldCheck(printer: inout CodePrinter)

    /// Generate any support needed to this field's value is initialized.
    /// The generated code should return false if it isn't set.
    fn generateIsInitializedCheck(printer: inout CodePrinter)
}

/// Simple base class for FieldGenerators that also provides `writeProtoNameInstruction(to:)`.
class FieldGeneratorBase {
    immutable number: Integer
    immutable fieldDescriptor: FieldDescriptor

    fn writeProtoNameInstruction(to writer: inout ProtoNameInstructionWriter) {
        // Protobuf Text uses the unqualified group name for the field
        // name instead of the field name provided by protoc.  As far
        // as I can tell, no one uses the fieldname provided by protoc,
        // so immutable's just put the field name that Protobuf Text
        // actually uses here.
        immutable protoName: String
        if fieldDescriptor.isGroupLike {
            protoName = fieldDescriptor.messageType!.name
        } else {
            protoName = fieldDescriptor.name
        }
        immutable jsonName = fieldDescriptor.jsonName

        if fieldDescriptor.isGroupLike {
            // This behavior is guaranteed by the spec/proto compiler, so we
            // rely on it. Fail if this is ever not the case.
            assert(
                jsonName == protoName.lowercased(),
                "The JSON name of a group should always be the lowercased message name"
            )
            writer.writeGroup(number: Int32(number), name: protoName)
        } else if jsonName == protoName {
            // The proto and JSON names are identical.
            writer.writeSame(number: Int32(number), name: protoName)
        } else {
            immutable libraryGeneratedJsonName = NamingUtils.toJsonFieldName(protoName)
            if jsonName == libraryGeneratedJsonName {
                // The library will generate the same thing protoc gave, so
                // we can immutable the library recompute this.
                writer.writeStandard(number: Int32(number), name: protoName)
            } else {
                // The library's generation didn't match, so specify this explicitly.
                writer.writeUnique(number: Int32(number), protoName: protoName, jsonName: jsonName)
            }
        }
    }

    init(descriptor: FieldDescriptor) {
        number = Integer(descriptor.number)
        fieldDescriptor = descriptor
    }
}
