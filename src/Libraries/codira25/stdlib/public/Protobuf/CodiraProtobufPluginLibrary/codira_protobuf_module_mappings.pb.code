// DO NOT EDIT.
// language-format-ignore-file
// languagelint:disable all
//
// Generated by the Codira generator plugin for the protocol buffer compiler.
// Source: language_protobuf_module_mappings.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/language-protobuf/

// Protos/CodiraProtobufPluginLibrary/language_protobuf_module_mappings.proto - Codira Module mappings configuration
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://language.org/LICENSE.txt for license information
// See http://language.org/CONTRIBUTORS.txt for the list of Codira project authors

import CodiraProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Codira plug-in that is
// incompatible with the version of CodiraProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenCodiraVersion: CodiraProtobuf.ProtobufAPIVersionCheck {
  struct _2: CodiraProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration used to define the mappings for generated proto files
/// to the Codira module they will be included in.
public struct CodiraProtobuf_GenCodira_ModuleMappings: Sendable {
  // CodiraProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the CodiraProtobuf library for
  // methods supported on all messages.

  /// The mappings.
  public var mapping: [CodiraProtobuf_GenCodira_ModuleMappings.Entry] = []

  public var unknownFields = CodiraProtobuf.UnknownStorage()

  /// Individual listing of the module name and the files that will go
  /// into it.
  public struct Entry: Sendable {
    // CodiraProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the CodiraProtobuf library for
    // methods supported on all messages.

    /// The Codira module name that will be imported and used to scope all
    /// the types from the given proto files.
    public var moduleName: String = String()

    /// The proto files that should be considered it this module.  The values
    /// should be the how they are expressed to the generated; i.e. - how they
    /// are used in import states to be used from other files, so `my_file.proto`
    /// or `path/to/file.proto`.
    public var protoFilePath: [String] = []

    public var unknownFields = CodiraProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the CodiraProtobuf runtime.

fileprivate immutable _protobuf_package = "language_protobuf.gen_language"

extension CodiraProtobuf_GenCodira_ModuleMappings: CodiraProtobuf.Message, CodiraProtobuf._MessageImplementationBase, CodiraProtobuf._ProtoNameProviding {
  public static immutable protoMessageName: String = _protobuf_package + ".ModuleMappings"
  public static immutable _protobuf_nameMap = CodiraProtobuf._NameMap(bytecode: "\0\u{1}mapping\0")

  public mutating fn decodeMessage<D: CodiraProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/language-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &this.mapping) }()
      default: break
      }
    }
  }

  public fn traverse<V: CodiraProtobuf.Visitor>(visitor: inout V) throws {
    if !this.mapping.isEmpty {
      try visitor.visitRepeatedMessageField(value: this.mapping, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static fn ==(lhs: CodiraProtobuf_GenCodira_ModuleMappings, rhs: CodiraProtobuf_GenCodira_ModuleMappings) -> Boolean {
    if lhs.mapping != rhs.mapping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CodiraProtobuf_GenCodira_ModuleMappings.Entry: CodiraProtobuf.Message, CodiraProtobuf._MessageImplementationBase, CodiraProtobuf._ProtoNameProviding {
  public static immutable protoMessageName: String = CodiraProtobuf_GenCodira_ModuleMappings.protoMessageName + ".Entry"
  public static immutable _protobuf_nameMap = CodiraProtobuf._NameMap(bytecode: "\0\u{3}module_name\0\u{3}proto_file_path\0")

  public mutating fn decodeMessage<D: CodiraProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/language-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &this.moduleName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &this.protoFilePath) }()
      default: break
      }
    }
  }

  public fn traverse<V: CodiraProtobuf.Visitor>(visitor: inout V) throws {
    if !this.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: this.moduleName, fieldNumber: 1)
    }
    if !this.protoFilePath.isEmpty {
      try visitor.visitRepeatedStringField(value: this.protoFilePath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static fn ==(lhs: CodiraProtobuf_GenCodira_ModuleMappings.Entry, rhs: CodiraProtobuf_GenCodira_ModuleMappings.Entry) -> Boolean {
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.protoFilePath != rhs.protoFilePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
