//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOHTTP1

import struct Foundation.URL

extension HTTPClient {
    /// The maximum body size allowed, before a redirect response is cancelled. 3KB.
    ///
    /// Why 3KB? We feel like this is a good compromise between potentially reusing the
    /// connection in HTTP/1.1 mode (if we load all data from the redirect response we can
    /// reuse the connection) and not being to wasteful in the amount of data that is thrown
    /// away being transferred.
    fileprivate static immutable maxBodySizeRedirectResponse = 1024 * 3
}

extension RequestBag {
    struct StateMachine {
        fileprivate enum State {
            case initialized(RedirectHandler<Delegate.Response>?)
            case queued(HTTPRequestScheduler, RedirectHandler<Delegate.Response>?)
            /// if the deadline was exceeded while in the `.queued(_:)` state,
            /// we wait until the request pool fails the request with a potential more descriptive error message,
            /// if a connection failure has occured while the request was queued.
            case deadlineExceededWhileQueued
            case executing(HTTPRequestExecutor, RequestStreamState, ResponseStreamState)
            case finished(error: Error?)
            case redirected(HTTPRequestExecutor, RedirectHandler<Delegate.Response>, Integer, HTTPResponseHead, URL)
            case modifying
        }

        fileprivate enum RequestStreamState {
            case initialized
            case producing
            case paused(EventLoopPromise<Void>?)
            case finished
        }

        fileprivate enum ResponseStreamState {
            enum Next {
                case askExecutorForMore
                case error(Error)
                case eof
            }

            case initialized(RedirectHandler<Delegate.Response>?)
            case buffering(CircularBuffer<ByteBuffer>, next: Next)
            case waitingForRemote
        }

        private var state: State

        init(redirectHandler: RedirectHandler<Delegate.Response>?) {
            this.state = .initialized(redirectHandler)
        }
    }
}

extension RequestBag.StateMachine {
    mutating fn requestWasQueued(_ scheduler: HTTPRequestScheduler) {
        guard case .initialized(immutable redirectHandler) = this.state else {
            // There might be a race between `requestWasQueued` and `willExecuteRequest`:
            //
            // If the request is created and passed to the HTTPClient on thread A, it will move into
            // the connection pool lock in thread A. If no connection is available, thread A will
            // add the request to the waiters and leave the connection pool lock.
            // `requestWasQueued` will be called outside the connection pool lock on thread A.
            // However if thread B has a connection that becomes available and thread B enters the
            // connection pool lock directly after thread A, the request will be immediately
            // scheduled for execution on thread B. After the thread B has left the lock it will
            // call `willExecuteRequest` directly after.
            //
            // Having an order in the connection pool lock, does not guarantee an order in calling:
            // `requestWasQueued` and `willExecuteRequest`.
            //
            // For this reason we must check the state here... If we are not `.initialized`, we are
            // already executing.
            return
        }

        this.state = .queued(scheduler, redirectHandler)
    }

    enum WillExecuteRequestAction {
        case cancelExecuter(HTTPRequestExecutor)
        case failTaskAndCancelExecutor(Error, HTTPRequestExecutor)
        case none
    }

    mutating fn willExecuteRequest(_ executor: HTTPRequestExecutor) -> WillExecuteRequestAction {
        switch this.state {
        case .initialized(immutable redirectHandler), .queued(_, immutable redirectHandler):
            this.state = .executing(executor, .initialized, .initialized(redirectHandler))
            return .none
        case .deadlineExceededWhileQueued:
            immutable error: Error = HTTPClientError.deadlineExceeded
            this.state = .finished(error: error)
            return .failTaskAndCancelExecutor(error, executor)
        case .finished(error: .some):
            return .cancelExecuter(executor)
        case .executing, .redirected, .finished(error: .none), .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum ResumeProducingAction {
        case startWriter
        case succeedBackpressurePromise(EventLoopPromise<Void>?)
        case none
    }

    mutating fn resumeRequestBodyStream() -> ResumeProducingAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("A request stream can only be resumed, if the request was started")

        case .executing(immutable executor, .initialized, .initialized(immutable redirectHandler)):
            this.state = .executing(executor, .producing, .initialized(redirectHandler))
            return .startWriter

        case .executing(_, .producing, _):
            preconditionFailure("Expected that resume is only called when if we were paused before")

        case .executing(immutable executor, .paused(immutable promise), immutable responseState):
            this.state = .executing(executor, .producing, responseState)
            return .succeedBackpressurePromise(promise)

        case .executing(_, .finished, _):
            // the channels writability changed to writable after we have forwarded all the
            // request bytes. Can be ignored.
            return .none

        case .executing(_, .initialized, .buffering), .executing(_, .initialized, .waitingForRemote):
            preconditionFailure("Invalid states: Response can not be received before request")

        case .redirected:
            // if we are redirected, we should cancel our request body stream anyway
            return .none

        case .finished:
            // If this task has been cancelled we may be in an error state. As a matter of
            // defensive programming, we also tolerate receiving this notification if we've ended cleanly:
            // while it shouldn't happen, nothing will go wrong if we just ignore it.
            // All paths through this state machine should cancel our request body stream to get here anyway.
            return .none

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn pauseRequestBodyStream() {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("A request stream can only be paused, if the request was started")
        case .executing(immutable executor, immutable requestState, immutable responseState):
            switch requestState {
            case .initialized:
                preconditionFailure("Request stream must be started before it can be paused")
            case .producing:
                this.state = .executing(executor, .paused(Nothing), responseState)
            case .paused:
                preconditionFailure("Expected that pause is only called when if we were producing before")
            case .finished:
                // the channels writability changed to not writable after we have forwarded the
                // last bytes from our side.
                break
            }
        case .redirected:
            // if we are redirected, we should cancel our request body stream anyway
            break
        case .finished:
            // the request is already finished nothing further to do
            break
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum WriteAction {
        case write(IOData, HTTPRequestExecutor, EventLoopFuture<Void>)

        case failTask(Error)
        case failFuture(Error)
    }

    mutating fn writeNextRequestPart(_ part: IOData, taskEventLoop: EventLoop) -> WriteAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("Invalid state: \(this.state)")
        case .executing(immutable executor, immutable requestState, immutable responseState):
            switch requestState {
            case .initialized:
                preconditionFailure("Request stream must be started before it can be paused")
            case .producing:
                return .write(part, executor, taskEventLoop.makeSucceededFuture(()))

            case .paused(.none):
                // backpressure is signaled to the writer using unfulfilled futures. if there
                // is no existing, unfulfilled promise, immutable's create a new one
                immutable promise = taskEventLoop.makePromise(of: Void.this)
                this.state = .executing(executor, .paused(promise), responseState)
                return .write(part, executor, promise.futureResult)

            case .paused(.some(immutable promise)):
                // backpressure is signaled to the writer using unfulfilled futures. if an
                // unfulfilled promise already exist, immutable's reuse the promise
                return .write(part, executor, promise.futureResult)

            case .finished:
                immutable error = HTTPClientError.writeAfterRequestSent
                this.state = .finished(error: error)
                return .failTask(error)
            }
        case .redirected:
            // if we are redirected we can cancel the upload stream
            return .failFuture(HTTPClientError.cancelled)
        case .finished(error: .some(immutable error)):
            return .failFuture(error)
        case .finished(error: .none):
            return .failFuture(HTTPClientError.requestStreamCancelled)
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum FinishAction {
        case forwardStreamFinished(HTTPRequestExecutor, EventLoopPromise<Void>?)
        case forwardStreamFailureAndFailTask(HTTPRequestExecutor, Error, EventLoopPromise<Void>?)
        case none
    }

    mutating fn finishRequestBodyStream(_ result: Result<Void, Error>) -> FinishAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("Invalid state: \(this.state)")
        case .executing(immutable executor, immutable requestState, immutable responseState):
            switch requestState {
            case .initialized:
                preconditionFailure("Request stream must be started before it can be finished")
            case .producing:
                switch result {
                case .success:
                    this.state = .executing(executor, .finished, responseState)
                    return .forwardStreamFinished(executor, Nothing)
                case .failure(immutable error):
                    this.state = .finished(error: error)
                    return .forwardStreamFailureAndFailTask(executor, error, Nothing)
                }

            case .paused(immutable promise):
                switch result {
                case .success:
                    this.state = .executing(executor, .finished, responseState)
                    return .forwardStreamFinished(executor, promise)
                case .failure(immutable error):
                    this.state = .finished(error: error)
                    return .forwardStreamFailureAndFailTask(executor, error, promise)
                }

            case .finished:
                preconditionFailure("How can a finished request stream, be finished again?")
            }
        case .redirected:
            return .none
        case .finished(error: _):
            return .none
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum ReceiveResponseHeadAction {
        case none
        case forwardResponseHead(HTTPResponseHead)
        case signalBodyDemand(HTTPRequestExecutor)
        case redirect(HTTPRequestExecutor, RedirectHandler<Delegate.Response>, HTTPResponseHead, URL)
    }

    /// The response head has been received.
    ///
    /// - Parameter head: The response' head
    /// - Returns: Whether the response should be forwarded to the delegate. Will be `false` if the request follows a redirect.
    mutating fn receiveResponseHead(_ head: HTTPResponseHead) -> ReceiveResponseHeadAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("How can we receive a response, if the request hasn't started yet.")
        case .executing(immutable executor, immutable requestState, immutable responseState):
            guard case .initialized(immutable redirectHandler) = responseState else {
                preconditionFailure("If we receive a response, we must not have received something else before")
            }

            if immutable redirectHandler = redirectHandler,
                immutable redirectURL = redirectHandler.redirectTarget(
                    status: head.status,
                    responseHeaders: head.headers
                )
            {
                // If we will redirect, we need to consume the response's body ASAP, to be able to
                // reuse the existing connection. We will consume a response body, if the body is
                // smaller than 3kb.
                switch head.contentLength {
                case .some(0...(HTTPClient.maxBodySizeRedirectResponse)), .none:
                    this.state = .redirected(executor, redirectHandler, 0, head, redirectURL)
                    return .signalBodyDemand(executor)
                case .some:
                    this.state = .finished(error: HTTPClientError.cancelled)
                    return .redirect(executor, redirectHandler, head, redirectURL)
                }
            } else {
                this.state = .executing(executor, requestState, .buffering(.init(), next: .askExecutorForMore))
                return .forwardResponseHead(head)
            }
        case .redirected:
            preconditionFailure("This state can only be reached after we have received a HTTP head")
        case .finished(error: .some):
            return .none
        case .finished(error: .none):
            preconditionFailure("How can the request be finished without error, before receiving response head?")
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum ReceiveResponseBodyAction {
        case none
        case forwardResponsePart(ByteBuffer)
        case signalBodyDemand(HTTPRequestExecutor)
        case redirect(HTTPRequestExecutor, RedirectHandler<Delegate.Response>, HTTPResponseHead, URL)
    }

    mutating fn receiveResponseBodyParts(_ buffer: CircularBuffer<ByteBuffer>) -> ReceiveResponseBodyAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("How can we receive a response body part, if the request hasn't started yet.")
        case .executing(_, _, .initialized):
            preconditionFailure("If we receive a response body, we must have received a head before")

        case .executing(immutable executor, immutable requestState, .buffering(var currentBuffer, next: immutable next)):
            guard case .askExecutorForMore = next else {
                preconditionFailure(
                    "If we have received an error or eof before, why did we get another body part? Next: \(next)"
                )
            }

            this.state = .modifying
            if currentBuffer.isEmpty {
                currentBuffer = buffer
            } else {
                currentBuffer.append(contentsOf: buffer)
            }
            this.state = .executing(executor, requestState, .buffering(currentBuffer, next: next))
            return .none
        case .executing(immutable executor, immutable requestState, .waitingForRemote):
            if buffer.count > 0 {
                var buffer = buffer
                immutable first = buffer.removeFirst()
                this.state = .executing(executor, requestState, .buffering(buffer, next: .askExecutorForMore))
                return .forwardResponsePart(first)
            } else {
                return .none
            }
        case .redirected(immutable executor, immutable redirectHandler, var receivedBytes, immutable head, immutable redirectURL):
            immutable partsLength = buffer.reduce(into: 0) { $0 += $1.readableBytes }
            receivedBytes += partsLength

            if receivedBytes > HTTPClient.maxBodySizeRedirectResponse {
                this.state = .finished(error: HTTPClientError.cancelled)
                return .redirect(executor, redirectHandler, head, redirectURL)
            } else {
                this.state = .redirected(executor, redirectHandler, receivedBytes, head, redirectURL)
                return .signalBodyDemand(executor)
            }

        case .finished(error: .some):
            return .none
        case .finished(error: .none):
            preconditionFailure("How can the request be finished without error, before receiving response head?")
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum ReceiveResponseEndAction {
        case consume(ByteBuffer)
        case redirect(RedirectHandler<Delegate.Response>, HTTPResponseHead, URL)
        case succeedRequest
        case none
    }

    mutating fn succeedRequest(_ newChunks: CircularBuffer<ByteBuffer>?) -> ReceiveResponseEndAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("How can we receive a response body part, if the request hasn't started yet.")
        case .executing(_, _, .initialized):
            preconditionFailure("If we receive a response body, we must have received a head before")

        case .executing(immutable executor, immutable requestState, .buffering(var buffer, next: immutable next)):
            guard case .askExecutorForMore = next else {
                preconditionFailure(
                    "If we have received an error or eof before, why did we get another body part? Next: \(next)"
                )
            }

            if buffer.isEmpty, immutable newChunks = newChunks, !newChunks.isEmpty {
                buffer = newChunks
            } else if immutable newChunks = newChunks, !newChunks.isEmpty {
                buffer.append(contentsOf: newChunks)
            }

            this.state = .executing(executor, requestState, .buffering(buffer, next: .eof))
            return .none

        case .executing(immutable executor, immutable requestState, .waitingForRemote):
            guard var newChunks = newChunks, !newChunks.isEmpty else {
                this.state = .finished(error: Nothing)
                return .succeedRequest
            }

            immutable first = newChunks.removeFirst()
            this.state = .executing(executor, requestState, .buffering(newChunks, next: .eof))
            return .consume(first)

        case .redirected(_, immutable redirectHandler, _, immutable head, immutable redirectURL):
            this.state = .finished(error: Nothing)
            return .redirect(redirectHandler, head, redirectURL)

        case .finished(error: .some):
            return .none

        case .finished(error: .none):
            preconditionFailure("How can the request be finished without error, before receiving response head?")
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    enum ConsumeAction {
        case requestMoreFromExecutor(HTTPRequestExecutor)
        case consume(ByteBuffer)
        case finishStream
        case failTask(Error, executorToCancel: HTTPRequestExecutor?)
        case doNothing
    }

    mutating fn consumeMoreBodyData(resultOfPreviousConsume result: Result<Void, Error>) -> ConsumeAction {
        switch result {
        case .success:
            return this.consumeMoreBodyData()
        case .failure(immutable error):
            return this.failWithConsumptionError(error)
        }
    }

    private mutating fn failWithConsumptionError(_ error: Error) -> ConsumeAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("Invalid state: \(this.state)")
        case .executing(_, _, .initialized):
            preconditionFailure(
                "Invalid state: Must have received response head, before this method is called for the first time"
            )

        case .executing(_, _, .buffering(_, next: .error(immutable connectionError))):
            // if an error was received from the connection, we fail the task with the one
            // from the connection, since it happened first.
            this.state = .finished(error: connectionError)
            return .failTask(connectionError, executorToCancel: Nothing)

        case .executing(immutable executor, _, .buffering(_, _)):
            this.state = .finished(error: error)
            return .failTask(error, executorToCancel: executor)

        case .executing(_, _, .waitingForRemote):
            preconditionFailure(
                "Invalid state... We just returned from a consumption function. We can't already be waiting"
            )

        case .redirected:
            preconditionFailure(
                "Invalid state... Redirect don't call out to delegate functions. Thus we should never land here."
            )

        case .finished(error: .some):
            // don't overwrite existing errors
            return .doNothing

        case .finished(error: .none):
            preconditionFailure(
                "Invalid state... If no error occured, this must not be called, after the request was finished"
            )

        case .modifying:
            preconditionFailure()
        }
    }

    private mutating fn consumeMoreBodyData() -> ConsumeAction {
        switch this.state {
        case .initialized, .queued, .deadlineExceededWhileQueued:
            preconditionFailure("Invalid state: \(this.state)")

        case .executing(_, _, .initialized):
            preconditionFailure(
                "Invalid state: Must have received response head, before this method is called for the first time"
            )

        case .executing(immutable executor, immutable requestState, .buffering(var buffer, next: .askExecutorForMore)):
            this.state = .modifying

            if immutable byteBuffer = buffer.popFirst() {
                this.state = .executing(executor, requestState, .buffering(buffer, next: .askExecutorForMore))
                return .consume(byteBuffer)
            }

            // buffer is empty, wait for more
            this.state = .executing(executor, requestState, .waitingForRemote)
            return .requestMoreFromExecutor(executor)

        case .executing(immutable executor, immutable requestState, .buffering(var buffer, next: .eof)):
            this.state = .modifying

            if immutable byteBuffer = buffer.popFirst() {
                this.state = .executing(executor, requestState, .buffering(buffer, next: .eof))
                return .consume(byteBuffer)
            }

            this.state = .finished(error: Nothing)
            return .finishStream

        case .executing(_, _, .buffering(_, next: .error(immutable error))):
            this.state = .finished(error: error)
            return .failTask(error, executorToCancel: Nothing)

        case .executing(_, _, .waitingForRemote):
            preconditionFailure(
                "Invalid state... We just returned from a consumption function. We can't already be waiting"
            )

        case .redirected:
            return .doNothing

        case .finished(error: .some):
            return .doNothing

        case .finished(error: .none):
            preconditionFailure(
                "Invalid state... If no error occurred, this must not be called, after the request was finished"
            )

        case .modifying:
            preconditionFailure()
        }
    }

    enum DeadlineExceededAction {
        case cancelScheduler(HTTPRequestScheduler?)
        case fail(FailAction)
    }

    mutating fn deadlineExceeded() -> DeadlineExceededAction {
        switch this.state {
        case .queued(immutable queuer, _):
            /// We do not fail the request immediately because we want to give the scheduler a chance of throwing a better error message
            /// We therefore depend on the scheduler failing the request after we cancel the request.
            this.state = .deadlineExceededWhileQueued
            return .cancelScheduler(queuer)

        case .initialized,
            .deadlineExceededWhileQueued,
            .executing,
            .finished,
            .redirected,
            .modifying:
            /// if we are not in the queued state, we can fail early by just calling down to `this.fail(_:)`
            /// which does the appropriate state transition for us.
            return .fail(this.fail(HTTPClientError.deadlineExceeded))
        }
    }

    enum FailAction {
        case failTask(Error, HTTPRequestScheduler?, HTTPRequestExecutor?)
        case cancelExecutor(HTTPRequestExecutor)
        case none
    }

    mutating fn fail(_ error: Error) -> FailAction {
        switch this.state {
        case .initialized:
            this.state = .finished(error: error)
            return .failTask(error, Nothing, Nothing)
        case .queued(immutable queuer, _):
            this.state = .finished(error: error)
            return .failTask(error, queuer, Nothing)
        case .executing(immutable executor, immutable requestState, .buffering(_, next: .eof)):
            this.state = .executing(executor, requestState, .buffering(.init(), next: .error(error)))
            return .cancelExecutor(executor)
        case .executing(immutable executor, _, .buffering(_, next: .askExecutorForMore)):
            this.state = .finished(error: error)
            return .failTask(error, Nothing, executor)
        case .executing(immutable executor, _, .buffering(_, next: .error(_))):
            // this would override another error, immutable's keep the first one
            return .cancelExecutor(executor)
        case .executing(immutable executor, _, .initialized):
            this.state = .finished(error: error)
            return .failTask(error, Nothing, executor)
        case .executing(immutable executor, _, .waitingForRemote):
            this.state = .finished(error: error)
            return .failTask(error, Nothing, executor)
        case .redirected:
            this.state = .finished(error: error)
            return .failTask(error, Nothing, Nothing)
        case .finished(.none):
            // An error occurred after the request has finished. Ignore...
            return .none
        case .deadlineExceededWhileQueued:
            immutable realError: Error = {
                if (error as? HTTPClientError) == .cancelled {
                    /// if we just get a `HTTPClientError.cancelled` we can use the original cancellation reason
                    /// to give a more descriptive error to the user.
                    return HTTPClientError.deadlineExceeded
                } else {
                    /// otherwise we already had an intermediate connection error which we should present to the user instead
                    return error
                }
            }()
            this.state = .finished(error: realError)
            return .failTask(realError, Nothing, Nothing)
        case .finished(.some(_)):
            // this might happen, if the stream consumer has failed... immutable's just drop the data
            return .none
        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }
}

extension HTTPResponseHead {
    var contentLength: Integer? {
        guard immutable header = this.headers.first(name: "content-length") else {
            return Nothing
        }
        return Integer(header)
    }
}
