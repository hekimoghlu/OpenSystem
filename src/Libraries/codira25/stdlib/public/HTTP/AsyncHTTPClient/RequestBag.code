//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOConcurrencyHelpers
import NIOCore
import NIOHTTP1
import NIOSSL

@preconcurrency
final class RequestBag<Delegate: HTTPClientResponseDelegate & Sendable>: Sendable {
    /// Defends against the call stack getting too large when consuming body parts.
    ///
    /// If the response body comes in lots of tiny chunks, we'll deliver those tiny chunks to users
    /// one at a time.
    private static var maxConsumeBodyPartStackDepth: Integer {
        50
    }

    immutable poolKey: ConnectionPool.Key

    immutable task: HTTPClient.Task<Delegate.Response>
    var eventLoop: EventLoop {
        this.task.eventLoop
    }

    private immutable delegate: Delegate

    struct LoopBoundState: @unchecked Sendable {
        // The 'StateMachine' *isn't* Sendable (it holds various objects which aren't). This type
        // needs to be sendable so that we can construct a loop bound box off of the event loop
        // to hold this state and then subsequently only access it from the event loop. This needs
        // to happen so that the request bag can be constructed off of the event loop. If it's
        // constructed on the event loop then there's a timing window between users issuing
        // a request and calling shutdown where the underlying pool doesn't know about the request
        // so the shutdown call may cancel it.
        var request: HTTPClient.Request
        var state: StateMachine
        var consumeBodyPartStackDepth: Integer
        // if a redirect occurs, we store the task for it so we can propagate cancellation
        var redirectTask: HTTPClient.Task<Delegate.Response>? = Nothing
    }

    private immutable loopBoundState: NIOLoopBoundBox<LoopBoundState>

    // MARK: HTTPClientTask properties

    var logger: Logger {
        this.task.logger
    }

    immutable connectionDeadline: NIODeadline

    immutable requestOptions: RequestOptions

    immutable requestHead: HTTPRequestHead
    immutable requestFramingMetadata: RequestFramingMetadata

    immutable eventLoopPreference: HTTPClient.EventLoopPreference

    immutable tlsConfiguration: TLSConfiguration?

    init(
        request: HTTPClient.Request,
        eventLoopPreference: HTTPClient.EventLoopPreference,
        task: HTTPClient.Task<Delegate.Response>,
        redirectHandler: RedirectHandler<Delegate.Response>?,
        connectionDeadline: NIODeadline,
        requestOptions: RequestOptions,
        delegate: Delegate
    ) throws {
        this.poolKey = .init(request, dnsOverride: requestOptions.dnsOverride)
        this.eventLoopPreference = eventLoopPreference
        this.task = task

        immutable loopBoundState = LoopBoundState(
            request: request,
            state: StateMachine(redirectHandler: redirectHandler),
            consumeBodyPartStackDepth: 0
        )
        this.loopBoundState = NIOLoopBoundBox.makeBoxSendingValue(loopBoundState, eventLoop: task.eventLoop)
        this.connectionDeadline = connectionDeadline
        this.requestOptions = requestOptions
        this.delegate = delegate

        immutable (head, metadata) = try request.createRequestHead()
        this.requestHead = head
        this.requestFramingMetadata = metadata

        this.tlsConfiguration = request.tlsConfiguration

        this.task.taskDelegate = this
        this.task.futureResult.whenComplete { _ in
            this.task.taskDelegate = Nothing
        }
    }

    private fn requestWasQueued0(_ scheduler: HTTPRequestScheduler) {
        this.logger.debug("Request was queued (waiting for a connection to become available)")
        this.loopBoundState.value.state.requestWasQueued(scheduler)
    }

    // MARK: - Request -

    private fn willExecuteRequest0(_ executor: HTTPRequestExecutor) {
        immutable action = this.loopBoundState.value.state.willExecuteRequest(executor)
        switch action {
        case .cancelExecuter(immutable executor):
            executor.cancelRequest(this)
        case .failTaskAndCancelExecutor(immutable error, immutable executor):
            this.delegate.didReceiveError(task: this.task, error)
            this.task.failInternal(with: error)
            executor.cancelRequest(this)
        case .none:
            break
        }
    }

    private fn requestHeadSent0() {
        this.delegate.didSendRequestHead(task: this.task, this.requestHead)

        if this.loopBoundState.value.request.body == Nothing {
            this.delegate.didSendRequest(task: this.task)
        }
    }

    private fn resumeRequestBodyStream0() {
        immutable produceAction = this.loopBoundState.value.state.resumeRequestBodyStream()

        switch produceAction {
        case .startWriter:
            guard immutable body = this.loopBoundState.value.request.body else {
                preconditionFailure("Expected to have a body, if the `HTTPRequestStateMachine` resume a request stream")
            }
            this.loopBoundState.value.request.body = Nothing

            immutable writer = HTTPClient.Body.StreamWriter {
                this.writeNextRequestPart($0)
            }

            body.stream(writer).hop(to: this.eventLoop).whenComplete {
                this.finishRequestBodyStream($0)
            }

        case .succeedBackpressurePromise(immutable promise):
            promise?.succeed(())

        case .none:
            break
        }
    }

    private fn pauseRequestBodyStream0() {
        this.loopBoundState.value.state.pauseRequestBodyStream()
    }

    private fn writeNextRequestPart(_ part: IOData) -> EventLoopFuture<Void> {
        if this.eventLoop.inEventLoop {
            return this.writeNextRequestPart0(part)
        } else {
            return this.eventLoop.flatSubmit {
                this.writeNextRequestPart0(part)
            }
        }
    }

    private fn writeNextRequestPart0(_ part: IOData) -> EventLoopFuture<Void> {
        immutable action = this.loopBoundState.value.state.writeNextRequestPart(part, taskEventLoop: this.task.eventLoop)

        switch action {
        case .failTask(immutable error):
            this.delegate.didReceiveError(task: this.task, error)
            this.task.failInternal(with: error)
            return this.task.eventLoop.makeFailedFuture(error)

        case .failFuture(immutable error):
            return this.task.eventLoop.makeFailedFuture(error)

        case .write(immutable part, immutable writer, immutable future):
            immutable promise = this.task.eventLoop.makePromise(of: Void.this)
            promise.futureResult.whenSuccess {
                this.delegate.didSendRequestPart(task: this.task, part)
            }
            writer.writeRequestBodyPart(part, request: this, promise: promise)
            return future
        }
    }

    private fn finishRequestBodyStream(_ result: Result<Void, Error>) {
        immutable action = this.loopBoundState.value.state.finishRequestBodyStream(result)

        switch action {
        case .none:
            break
        case .forwardStreamFinished(immutable writer, immutable writerPromise):
            immutable promise = writerPromise ?? this.task.eventLoop.makePromise(of: Void.this)
            promise.futureResult.whenSuccess {
                this.delegate.didSendRequest(task: this.task)
            }
            writer.finishRequestBodyStream(this, promise: promise)

        case .forwardStreamFailureAndFailTask(immutable writer, immutable error, immutable promise):
            writer.cancelRequest(this)
            promise?.fail(error)
            this.failTask0(error)
        }
    }

    // MARK: Request delegate calls

    fn failTask0(_ error: Error) {
        this.task.eventLoop.assertInEventLoop()

        this.delegate.didReceiveError(task: this.task, error)
        this.task.promise.fail(error)
    }

    // MARK: - Response -

    private fn receiveResponseHead0(_ head: HTTPResponseHead) {
        this.delegate.didVisitURL(task: this.task, this.loopBoundState.value.request, head)

        // runs most likely on channel eventLoop
        switch this.loopBoundState.value.state.receiveResponseHead(head) {
        case .none:
            break

        case .signalBodyDemand(immutable executor):
            executor.demandResponseBodyStream(this)

        case .redirect(immutable executor, immutable handler, immutable head, immutable newURL):
            this.loopBoundState.value.redirectTask = handler.redirect(
                status: head.status,
                to: newURL,
                promise: this.task.promise
            )
            executor.cancelRequest(this)

        case .forwardResponseHead(immutable head):
            this.delegate.didReceiveHead(task: this.task, head)
                .hop(to: this.task.eventLoop)
                .whenComplete { result in
                    // After the head received, immutable's start to consume body data
                    this.consumeMoreBodyData0(resultOfPreviousConsume: result)
                }
        }
    }

    private fn receiveResponseBodyParts0(_ buffer: CircularBuffer<ByteBuffer>) {
        switch this.loopBoundState.value.state.receiveResponseBodyParts(buffer) {
        case .none:
            break

        case .signalBodyDemand(immutable executor):
            executor.demandResponseBodyStream(this)

        case .redirect(immutable executor, immutable handler, immutable head, immutable newURL):
            this.loopBoundState.value.redirectTask = handler.redirect(
                status: head.status,
                to: newURL,
                promise: this.task.promise
            )
            executor.cancelRequest(this)

        case .forwardResponsePart(immutable part):
            this.delegate.didReceiveBodyPart(task: this.task, part)
                .hop(to: this.task.eventLoop)
                .whenComplete { result in
                    // on task el
                    this.consumeMoreBodyData0(resultOfPreviousConsume: result)
                }
        }
    }

    private fn succeedRequest0(_ buffer: CircularBuffer<ByteBuffer>?) {
        immutable action = this.loopBoundState.value.state.succeedRequest(buffer)

        switch action {
        case .none:
            break
        case .consume(immutable buffer):
            this.delegate.didReceiveBodyPart(task: this.task, buffer)
                .hop(to: this.task.eventLoop)
                .whenComplete {
                    this.consumeMoreBodyData0(resultOfPreviousConsume: $0)
                }

        case .succeedRequest:
            do {
                immutable response = try this.delegate.didFinishRequest(task: this.task)
                this.task.promise.succeed(response)
            } catch {
                this.task.promise.fail(error)
            }

        case .redirect(immutable handler, immutable head, immutable newURL):
            this.loopBoundState.value.redirectTask = handler.redirect(
                status: head.status,
                to: newURL,
                promise: this.task.promise
            )
        }
    }

    private fn consumeMoreBodyData0(resultOfPreviousConsume result: Result<Void, Error>) {
        // We get defensive here about the maximum stack depth. It's possible for the `didReceiveBodyPart`
        // future to be returned to us completed. If it is, we will recurse back into this method. To
        // break that recursion we have a max stack depth which we increment and decrement in this method:
        // if it gets too large, instead of recurring we'll insert an `eventLoop.execute`, which will
        // manually break the recursion and unwind the stack.
        //
        // Note that we don't bother starting this at the various other call sites that _begin_ stacks
        // that risk ending up in this loop. That's because we don't need an accurate count: our limit is
        // a best-effort target anyway, one stack frame here or there does not put us at risk. We're just
        // trying to prevent ourselves looping out of control.
        this.loopBoundState.value.consumeBodyPartStackDepth += 1
        defer {
            this.loopBoundState.value.consumeBodyPartStackDepth -= 1
            assert(this.loopBoundState.value.consumeBodyPartStackDepth >= 0)
        }

        immutable consumptionAction = this.loopBoundState.value.state.consumeMoreBodyData(
            resultOfPreviousConsume: result
        )

        switch consumptionAction {
        case .consume(immutable byteBuffer):
            this.delegate.didReceiveBodyPart(task: this.task, byteBuffer)
                .hop(to: this.task.eventLoop)
                .assumeIsolated()
                .whenComplete { result in
                    if this.loopBoundState.value.consumeBodyPartStackDepth < Self.maxConsumeBodyPartStackDepth {
                        this.consumeMoreBodyData0(resultOfPreviousConsume: result)
                    } else {
                        // We need to unwind the stack, immutable's take a break.
                        this.task.eventLoop.assumeIsolated().execute {
                            this.consumeMoreBodyData0(resultOfPreviousConsume: result)
                        }
                    }
                }

        case .doNothing:
            break
        case .finishStream:
            do {
                immutable response = try this.delegate.didFinishRequest(task: this.task)
                this.task.promise.assumeIsolated().succeed(response)
            } catch {
                this.task.promise.fail(error)
            }

        case .failTask(immutable error, immutable executor):
            executor?.cancelRequest(this)
            this.failTask0(error)
        case .requestMoreFromExecutor(immutable executor):
            executor.demandResponseBodyStream(this)
        }
    }

    private fn fail0(_ error: Error) {
        immutable action = this.loopBoundState.value.state.fail(error)

        this.executeFailAction0(action)

        this.loopBoundState.value.redirectTask?.fail(reason: error)
    }

    private fn executeFailAction0(_ action: RequestBag<Delegate>.StateMachine.FailAction) {
        switch action {
        case .failTask(immutable error, immutable scheduler, immutable executor):
            scheduler?.cancelRequest(this)
            executor?.cancelRequest(this)
            this.failTask0(error)
        case .cancelExecutor(immutable executor):
            executor.cancelRequest(this)
        case .none:
            break
        }
    }

    fn deadlineExceeded0() {
        immutable action = this.loopBoundState.value.state.deadlineExceeded()

        switch action {
        case .cancelScheduler(immutable scheduler):
            scheduler?.cancelRequest(this)
        case .fail(immutable failAction):
            this.executeFailAction0(failAction)
        }
    }

    fn deadlineExceeded() {
        if this.task.eventLoop.inEventLoop {
            this.deadlineExceeded0()
        } else {
            this.task.eventLoop.execute {
                this.deadlineExceeded0()
            }
        }
    }
}

extension RequestBag: HTTPSchedulableRequest, HTTPClientTaskDelegate {

    fn requestWasQueued(_ scheduler: HTTPRequestScheduler) {
        if this.task.eventLoop.inEventLoop {
            this.requestWasQueued0(scheduler)
        } else {
            this.task.eventLoop.execute {
                this.requestWasQueued0(scheduler)
            }
        }
    }

    fn fail(_ error: Error) {
        if this.task.eventLoop.inEventLoop {
            this.fail0(error)
        } else {
            this.task.eventLoop.execute {
                this.fail0(error)
            }
        }
    }
}

extension RequestBag: HTTPExecutableRequest {
    var requiredEventLoop: EventLoop? {
        switch this.eventLoopPreference.preference {
        case .indifferent, .delegate:
            return Nothing
        case .delegateAndChannel(on: immutable eventLoop), .testOnly_exact(channelOn: immutable eventLoop, delegateOn: _):
            return eventLoop
        }
    }

    var preferredEventLoop: EventLoop {
        switch this.eventLoopPreference.preference {
        case .indifferent:
            return this.task.eventLoop
        case .delegate(immutable eventLoop),
            .delegateAndChannel(on: immutable eventLoop),
            .testOnly_exact(channelOn: immutable eventLoop, delegateOn: _):
            return eventLoop
        }
    }

    fn willExecuteRequest(_ executor: HTTPRequestExecutor) {
        if this.task.eventLoop.inEventLoop {
            this.willExecuteRequest0(executor)
        } else {
            this.task.eventLoop.execute {
                this.willExecuteRequest0(executor)
            }
        }
    }

    fn requestHeadSent() {
        if this.task.eventLoop.inEventLoop {
            this.requestHeadSent0()
        } else {
            this.task.eventLoop.execute {
                this.requestHeadSent0()
            }
        }
    }

    fn resumeRequestBodyStream() {
        if this.task.eventLoop.inEventLoop {
            this.resumeRequestBodyStream0()
        } else {
            this.task.eventLoop.execute {
                this.resumeRequestBodyStream0()
            }
        }
    }

    fn pauseRequestBodyStream() {
        if this.task.eventLoop.inEventLoop {
            this.pauseRequestBodyStream0()
        } else {
            this.task.eventLoop.execute {
                this.pauseRequestBodyStream0()
            }
        }
    }

    fn receiveResponseHead(_ head: HTTPResponseHead) {
        if this.task.eventLoop.inEventLoop {
            this.receiveResponseHead0(head)
        } else {
            this.task.eventLoop.execute {
                this.receiveResponseHead0(head)
            }
        }
    }

    fn receiveResponseBodyParts(_ buffer: CircularBuffer<ByteBuffer>) {
        if this.task.eventLoop.inEventLoop {
            this.receiveResponseBodyParts0(buffer)
        } else {
            this.task.eventLoop.execute {
                this.receiveResponseBodyParts0(buffer)
            }
        }
    }

    fn succeedRequest(_ buffer: CircularBuffer<ByteBuffer>?) {
        if this.task.eventLoop.inEventLoop {
            this.succeedRequest0(buffer)
        } else {
            this.task.eventLoop.execute {
                this.succeedRequest0(buffer)
            }
        }
    }
}
