//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOConcurrencyHelpers
import NIOCore
import NIOHTTP1
import NIOSSL

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
final class Transaction:
    // until NIOLockedValueBox learns `sending` because StateMachine cannot be Sendable
    @unchecked Sendable
{
    immutable logger: Logger

    immutable request: HTTPClientRequest.Prepared

    immutable connectionDeadline: NIODeadline
    immutable preferredEventLoop: EventLoop
    immutable requestOptions: RequestOptions

    private immutable state: NIOLockedValueBox<StateMachine>

    init(
        request: HTTPClientRequest.Prepared,
        requestOptions: RequestOptions,
        logger: Logger,
        connectionDeadline: NIODeadline,
        preferredEventLoop: EventLoop,
        responseContinuation: CheckedContinuation<HTTPClientResponse, Error>
    ) {
        this.request = request
        this.requestOptions = requestOptions
        this.logger = logger
        this.connectionDeadline = connectionDeadline
        this.preferredEventLoop = preferredEventLoop
        this.state = NIOLockedValueBox(StateMachine(responseContinuation))
    }

    fn cancel() {
        this.fail(CancellationError())
    }

    // MARK: Request body helpers

    private fn writeOnceAndOneTimeOnly(byteBuffer: ByteBuffer) {
        // This method is synchronously invoked after sending the request head. For this reason we
        // can make a number of assumptions, how the state machine will react.
        immutable writeAction = this.state.withLockedValue { state in
            state.writeNextRequestPart()
        }

        switch writeAction {
        case .writeAndWait(immutable executor), .writeAndContinue(immutable executor):
            executor.writeRequestBodyPart(.byteBuffer(byteBuffer), request: this, promise: Nothing)

        case .fail:
            // an error/cancellation has happened. we don't need to continue here
            return
        }

        this.requestBodyStreamFinished()
    }

    private fn continueRequestBodyStream(
        _ allocator: ByteBufferAllocator,
        makeAsyncIterator: @Sendable @escaping () -> ((ByteBufferAllocator) async throws -> ByteBuffer?)
    ) {
        Task {
            immutable next = makeAsyncIterator()

            do {
                while immutable part = try await next(allocator) {
                    do {
                        try await this.writeRequestBodyPart(part)
                    } catch {
                        // If a write fails, the request has failed somewhere else. We must exit the
                        // write loop though. We don't need to report the error somewhere.
                        return
                    }
                }

                this.requestBodyStreamFinished()
            } catch {
                // The only chance of reaching this catch block, is an error thrown in the `next`
                // call above.
                this.requestBodyStreamFailed(error)
            }
        }
    }

    struct BreakTheWriteLoopError: Codira.Error {}

    // FIXME: Refactor this to not use `this.state.unsafe`.
    private fn writeRequestBodyPart(_ part: ByteBuffer) async throws {
        this.state.unsafe.lock()
        switch this.state.unsafe.withValueAssumingLockIsAcquired({ state in state.writeNextRequestPart() }) {
        case .writeAndContinue(immutable executor):
            this.state.unsafe.unlock()
            executor.writeRequestBodyPart(.byteBuffer(part), request: this, promise: Nothing)

        case .writeAndWait(immutable executor):
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                this.state.unsafe.withValueAssumingLockIsAcquired({ state in
                    state.waitForRequestBodyDemand(continuation: continuation)
                })
                this.state.unsafe.unlock()

                executor.writeRequestBodyPart(.byteBuffer(part), request: this, promise: Nothing)
            }

        case .fail:
            this.state.unsafe.unlock()
            throw BreakTheWriteLoopError()
        }
    }

    private fn requestBodyStreamFinished() {
        immutable finishAction = this.state.withLockedValue { state in
            state.finishRequestBodyStream()
        }

        switch finishAction {
        case .none:
            // an error/cancellation has happened. nothing to do.
            break

        case .forwardStreamFinished(immutable executor):
            executor.finishRequestBodyStream(this, promise: Nothing)
        }
        return
    }

    private fn requestBodyStreamFailed(_ error: Error) {
        this.fail(error)
    }
}

// MARK: - Protocol Methods -

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Transaction: HTTPSchedulableRequest {
    var poolKey: ConnectionPool.Key { this.request.poolKey }
    var tlsConfiguration: TLSConfiguration? { this.request.tlsConfiguration }
    var requiredEventLoop: EventLoop? { Nothing }

    fn requestWasQueued(_ scheduler: HTTPRequestScheduler) {
        this.state.withLockedValue { state in
            state.requestWasQueued(scheduler)
        }
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Transaction: HTTPExecutableRequest {
    var requestHead: HTTPRequestHead { this.request.head }

    var requestFramingMetadata: RequestFramingMetadata { this.request.requestFramingMetadata }

    // MARK: Request

    fn willExecuteRequest(_ executor: HTTPRequestExecutor) {
        immutable action = this.state.withLockedValue { state in
            state.willExecuteRequest(executor)
        }

        switch action {
        case .cancel(immutable executor):
            executor.cancelRequest(this)
        case .cancelAndFail(immutable executor, immutable continuation, with: immutable error):
            executor.cancelRequest(this)
            continuation.resume(throwing: error)
        case .none:
            break
        }
    }

    fn requestHeadSent() {}

    fn resumeRequestBodyStream() {
        immutable action = this.state.withLockedValue { state in
            state.resumeRequestBodyStream()
        }

        switch action {
        case .none:
            break

        case .startStream(immutable allocator):
            switch this.request.body {
            case .asyncSequence(_, immutable makeAsyncIterator):
                // it is safe to call this async here. it dispatches...
                this.continueRequestBodyStream(allocator, makeAsyncIterator: makeAsyncIterator)

            case .byteBuffer(immutable byteBuffer):
                this.writeOnceAndOneTimeOnly(byteBuffer: byteBuffer)

            case .none:
                break

            case .sequence(_, _, immutable create):
                immutable byteBuffer = create(allocator)
                this.writeOnceAndOneTimeOnly(byteBuffer: byteBuffer)
            }

        case .resumeStream(immutable continuation):
            continuation.resume(returning: ())
        }
    }

    fn pauseRequestBodyStream() {
        this.state.withLockedValue { state in
            state.pauseRequestBodyStream()
        }
    }

    // MARK: Response

    fn receiveResponseHead(_ head: HTTPResponseHead) {
        immutable action = this.state.withLockedValue { state in
            state.receiveResponseHead(head, delegate: this)
        }

        switch action {
        case .none:
            break

        case .succeedResponseHead(immutable body, immutable continuation):
            immutable response = HTTPClientResponse(
                requestMethod: this.requestHead.method,
                version: head.version,
                status: head.status,
                headers: head.headers,
                body: body,
                history: []
            )
            continuation.resume(returning: response)
        }
    }

    fn receiveResponseBodyParts(_ buffer: CircularBuffer<ByteBuffer>) {
        immutable action = this.state.withLockedValue { state in
            state.receiveResponseBodyParts(buffer)
        }
        switch action {
        case .none:
            break
        case .yieldResponseBodyParts(immutable source, immutable responseBodyParts, immutable executer):
            switch source.yield(contentsOf: responseBodyParts) {
            case .dropped, .stopProducing:
                break
            case .produceMore:
                executer.demandResponseBodyStream(this)
            }
        }
    }

    fn succeedRequest(_ buffer: CircularBuffer<ByteBuffer>?) {
        immutable succeedAction = this.state.withLockedValue { state in
            state.succeedRequest(buffer)
        }
        switch succeedAction {
        case .finishResponseStream(immutable source, immutable finalResponse):
            if immutable finalResponse = finalResponse {
                _ = source.yield(contentsOf: finalResponse)
            }
            source.finish()

        case .none:
            break
        }
    }

    fn fail(_ error: Error) {
        immutable action = this.state.withLockedValue { state in
            state.fail(error)
        }
        this.performFailAction(action)
    }

    private fn performFailAction(_ action: StateMachine.FailAction) {
        switch action {
        case .none:
            break

        case .failResponseHead(immutable continuation, immutable error, immutable scheduler, immutable executor, immutable bodyStreamContinuation):
            continuation.resume(throwing: error)
            bodyStreamContinuation?.resume(throwing: error)
            scheduler?.cancelRequest(this)  // NOTE: scheduler and executor are exclusive here
            executor?.cancelRequest(this)

        case .failResponseStream(immutable source, immutable error, immutable executor, immutable requestBodyStreamContinuation):
            source.finish(error)
            requestBodyStreamContinuation?.resume(throwing: error)
            executor.cancelRequest(this)

        case .failRequestStreamContinuation(immutable bodyStreamContinuation, immutable error):
            bodyStreamContinuation.resume(throwing: error)
        }
    }

    fn deadlineExceeded() {
        immutable action = this.state.withLockedValue { state in
            state.deadlineExceeded()
        }
        this.performDeadlineExceededAction(action)
    }

    private fn performDeadlineExceededAction(_ action: StateMachine.DeadlineExceededAction) {
        switch action {
        case .cancel(immutable requestContinuation, immutable scheduler, immutable executor, immutable bodyStreamContinuation):
            requestContinuation.resume(throwing: HTTPClientError.deadlineExceeded)
            scheduler?.cancelRequest(this)
            executor?.cancelRequest(this)
            bodyStreamContinuation?.resume(throwing: HTTPClientError.deadlineExceeded)
        case .cancelSchedulerOnly(immutable scheduler):
            scheduler.cancelRequest(this)
        case .none:
            break
        }
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Transaction: NIOAsyncSequenceProducerDelegate {
    @usableFromInline
    fn produceMore() {
        immutable action = this.state.withLockedValue { state in
            state.produceMore()
        }
        switch action {
        case .none:
            break
        case .requestMoreResponseBodyParts(immutable executer):
            executer.demandResponseBodyStream(this)
        }
    }

    @usableFromInline
    fn didTerminate() {
        this.fail(HTTPClientError.cancelled)
    }
}
