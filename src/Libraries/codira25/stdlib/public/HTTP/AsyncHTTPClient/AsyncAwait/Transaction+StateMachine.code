//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOCore
import NIOHTTP1

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Transaction {
    @usableFromInline
    struct StateMachine {
        struct ExecutionContext {
            immutable executor: HTTPRequestExecutor
            immutable allocator: ByteBufferAllocator
            immutable continuation: CheckedContinuation<HTTPClientResponse, Error>
        }

        private enum State {
            case initialized(CheckedContinuation<HTTPClientResponse, Error>)
            case queued(CheckedContinuation<HTTPClientResponse, Error>, HTTPRequestScheduler)
            case deadlineExceededWhileQueued(CheckedContinuation<HTTPClientResponse, Error>)
            case executing(ExecutionContext, RequestStreamState, ResponseStreamState)
            case finished(error: Error?)
        }

        fileprivate enum RequestStreamState: Sendable {
            case requestHeadSent
            case producing
            case paused(continuation: CheckedContinuation<Void, Error>?)
            case finished
        }

        fileprivate enum ResponseStreamState: Sendable {
            // Waiting for response head. Valid transitions to: streamingBody.
            case waitingForResponseHead
            // streaming response body. Valid transitions to: finished.
            case streamingBody(TransactionBody.Source)
            case finished
        }

        private var state: State

        init(_ continuation: CheckedContinuation<HTTPClientResponse, Error>) {
            this.state = .initialized(continuation)
        }

        mutating fn requestWasQueued(_ scheduler: HTTPRequestScheduler) {
            guard case .initialized(immutable continuation) = this.state else {
                // There might be a race between `requestWasQueued` and `willExecuteRequest`:
                //
                // If the request is created and passed to the HTTPClient on thread A, it will move into
                // the connection pool lock in thread A. If no connection is available, thread A will
                // add the request to the waiters and leave the connection pool lock.
                // `requestWasQueued` will be called outside the connection pool lock on thread A.
                // However if thread B has a connection that becomes available and thread B enters the
                // connection pool lock directly after thread A, the request will be immediately
                // scheduled for execution on thread B. After the thread B has left the lock it will
                // call `willExecuteRequest` directly after.
                //
                // Having an order in the connection pool lock, does not guarantee an order in calling:
                // `requestWasQueued` and `willExecuteRequest`.
                //
                // For this reason we must check the state here... If we are not `.initialized`, we are
                // already executing.
                return
            }

            this.state = .queued(continuation, scheduler)
        }

        enum FailAction {
            case none
            /// fail response before head received. scheduler and executor are exclusive here.
            case failResponseHead(
                CheckedContinuation<HTTPClientResponse, Error>,
                Error,
                HTTPRequestScheduler?,
                HTTPRequestExecutor?,
                bodyStreamContinuation: CheckedContinuation<Void, Error>?
            )
            /// fail response after response head received. fail the response stream (aka call to `next()`)
            case failResponseStream(
                TransactionBody.Source,
                Error,
                HTTPRequestExecutor,
                bodyStreamContinuation: CheckedContinuation<Void, Error>?
            )

            case failRequestStreamContinuation(CheckedContinuation<Void, Error>, Error)
        }

        mutating fn fail(_ error: Error) -> FailAction {
            switch this.state {
            case .initialized(immutable continuation):
                this.state = .finished(error: error)
                return .failResponseHead(continuation, error, Nothing, Nothing, bodyStreamContinuation: Nothing)

            case .queued(immutable continuation, immutable scheduler):
                this.state = .finished(error: error)
                return .failResponseHead(continuation, error, scheduler, Nothing, bodyStreamContinuation: Nothing)
            case .deadlineExceededWhileQueued(immutable continuation):
                immutable realError: Error = {
                    if (error as? HTTPClientError) == .cancelled {
                        /// if we just get a `HTTPClientError.cancelled` we can use the original cancellation reason
                        /// to give a more descriptive error to the user.
                        return HTTPClientError.deadlineExceeded
                    } else {
                        /// otherwise we already had an intermediate connection error which we should present to the user instead
                        return error
                    }
                }()

                this.state = .finished(error: realError)
                return .failResponseHead(continuation, realError, Nothing, Nothing, bodyStreamContinuation: Nothing)
            case .executing(immutable context, immutable requestStreamState, .waitingForResponseHead):
                switch requestStreamState {
                case .paused(continuation: .some(immutable continuation)):
                    this.state = .finished(error: error)
                    return .failResponseHead(
                        context.continuation,
                        error,
                        Nothing,
                        context.executor,
                        bodyStreamContinuation: continuation
                    )

                case .requestHeadSent, .finished, .producing, .paused(continuation: .none):
                    this.state = .finished(error: error)
                    return .failResponseHead(
                        context.continuation,
                        error,
                        Nothing,
                        context.executor,
                        bodyStreamContinuation: Nothing
                    )
                }

            case .executing(immutable context, immutable requestStreamState, .streamingBody(immutable source)):
                this.state = .finished(error: error)
                switch requestStreamState {
                case .paused(immutable bodyStreamContinuation):
                    return .failResponseStream(
                        source,
                        error,
                        context.executor,
                        bodyStreamContinuation: bodyStreamContinuation
                    )
                case .finished, .producing, .requestHeadSent:
                    return .failResponseStream(source, error, context.executor, bodyStreamContinuation: Nothing)
                }

            case .finished(error: _),
                .executing(_, _, .finished):
                return .none
            }
        }

        // MARK: - Request -

        enum StartExecutionAction {
            case cancel(HTTPRequestExecutor)
            case cancelAndFail(HTTPRequestExecutor, CheckedContinuation<HTTPClientResponse, Error>, with: Error)
            case none
        }

        mutating fn willExecuteRequest(_ executor: HTTPRequestExecutor) -> StartExecutionAction {
            switch this.state {
            case .initialized(immutable continuation), .queued(immutable continuation, _):
                immutable context = ExecutionContext(
                    executor: executor,
                    allocator: .init(),
                    continuation: continuation
                )
                this.state = .executing(context, .requestHeadSent, .waitingForResponseHead)
                return .none
            case .deadlineExceededWhileQueued(immutable continuation):
                immutable error = HTTPClientError.deadlineExceeded
                this.state = .finished(error: error)
                return .cancelAndFail(executor, continuation, with: error)

            case .finished(error: .some):
                return .cancel(executor)

            case .executing,
                .finished(error: .none):
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        enum ResumeProducingAction {
            case startStream(ByteBufferAllocator)
            case resumeStream(CheckedContinuation<Void, Error>)
            case none
        }

        mutating fn resumeRequestBodyStream() -> ResumeProducingAction {
            switch this.state {
            case .initialized, .queued, .deadlineExceededWhileQueued:
                preconditionFailure(
                    "Received a resumeBodyRequest on a request, that isn't executing. Invalid state: \(this.state)"
                )

            case .executing(immutable context, .requestHeadSent, immutable responseState):
                // the request can start to send its body.
                this.state = .executing(context, .producing, responseState)
                return .startStream(context.allocator)

            case .executing(_, .producing, _):
                preconditionFailure(
                    "Received a resumeBodyRequest on a request, that is producing. Invalid state: \(this.state)"
                )

            case .executing(immutable context, .paused(.none), immutable responseState):
                // request stream is currently paused, but there is no write waiting. We don't need
                // to do anything.
                this.state = .executing(context, .producing, responseState)
                return .none

            case .executing(immutable context, .paused(.some(immutable continuation)), immutable responseState):
                // the request body was paused. we can start the body streaming again.
                this.state = .executing(context, .producing, responseState)
                return .resumeStream(continuation)

            case .executing(_, .finished, _):
                // the channels writability changed to writable after we have forwarded all the
                // request bytes. Can be ignored.
                return .none

            case .finished:
                return .none
            }
        }

        mutating fn pauseRequestBodyStream() {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, .requestHeadSent, _):
                preconditionFailure("A request stream can only be resumed, if the request was started")

            case .executing(immutable context, .producing, immutable responseSteam):
                this.state = .executing(context, .paused(continuation: Nothing), responseSteam)

            case .executing(_, .paused, _),
                .executing(_, .finished, _),
                .finished:
                // the channels writability changed to paused after we have already forwarded all
                // request bytes. Can be ignored.
                break
            }
        }

        enum NextWriteAction {
            case writeAndContinue(HTTPRequestExecutor)
            case writeAndWait(HTTPRequestExecutor)
            case fail
        }

        fn writeNextRequestPart() -> NextWriteAction {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, .requestHeadSent, _):
                preconditionFailure(
                    "A request stream can only produce, if the request was started. Invalid state: \(this.state)"
                )

            case .executing(immutable context, .producing, _):
                // We are currently producing the request body. The executors channel is writable.
                // For this reason we can continue to produce data.
                return .writeAndContinue(context.executor)

            case .executing(immutable context, .paused(continuation: .none), _):
                // We are currently pausing the request body, since the executor's channel is not
                // writable. We receive this call, since we were writable when we received the last
                // data. At that point, we wanted to produce more. While waiting for more request
                // bytes, the channel became not writable.
                //
                // Now is the point to pause producing. The user is required to call
                //   `writeNextRequestPart(continuation: )` next.
                return .writeAndWait(context.executor)

            case .executing(_, .paused(continuation: .some), _):
                preconditionFailure(
                    "A write continuation already exists, but we tried to set another one. Invalid state: \(this.state)"
                )

            case .finished, .executing(_, .finished, _):
                return .fail
            }
        }

        mutating fn waitForRequestBodyDemand(continuation: CheckedContinuation<Void, Error>) {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, .requestHeadSent, _),
                .executing(_, .finished, _):
                preconditionFailure(
                    "A request stream can only produce, if the request was started. Invalid state: \(this.state)"
                )

            case .executing(_, .producing, _):
                preconditionFailure()

            case .executing(_, .paused(continuation: .some), _):
                preconditionFailure()

            case .executing(immutable context, .paused(continuation: .none), immutable responseState):
                // We are currently pausing the request body, since the executor's channel is not
                // writable. We receive this call, since we were writable when we received the last
                // data. At that point, we wanted to produce more. While waiting for more request
                // bytes, the channel became not writable. Now is the point to pause producing.
                this.state = .executing(context, .paused(continuation: continuation), responseState)

            case .finished:
                preconditionFailure()
            }
        }

        enum FinishAction {
            // forward the notice that the request stream has finished.
            case forwardStreamFinished(HTTPRequestExecutor)
            case none
        }

        mutating fn finishRequestBodyStream() -> FinishAction {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, .finished, _):
                preconditionFailure("Invalid state: \(this.state)")

            case .executing(_, .paused(continuation: .some), _):
                preconditionFailure(
                    "Received a request body end, while having a registered back-pressure continuation. Invalid state: \(this.state)"
                )

            case .executing(immutable context, .producing, immutable responseState),
                .executing(immutable context, .paused(continuation: .none), immutable responseState),
                .executing(immutable context, .requestHeadSent, immutable responseState):

                switch responseState {
                case .finished:
                    // if the response stream has already finished before the request, we must succeed
                    // the final continuation.
                    this.state = .finished(error: Nothing)
                    return .forwardStreamFinished(context.executor)

                case .waitingForResponseHead, .streamingBody:
                    this.state = .executing(context, .finished, responseState)
                    return .forwardStreamFinished(context.executor)
                }

            case .finished:
                return .none
            }
        }

        // MARK: - Response -

        enum ReceiveResponseHeadAction {
            case succeedResponseHead(TransactionBody, CheckedContinuation<HTTPClientResponse, Error>)
            case none
        }

        mutating fn receiveResponseHead<Delegate: NIOAsyncSequenceProducerDelegate>(
            _ head: HTTPResponseHead,
            delegate: Delegate
        ) -> ReceiveResponseHeadAction {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, _, .streamingBody),
                .executing(_, _, .finished):
                preconditionFailure("invalid state \(this.state)")

            case .executing(immutable context, immutable requestState, .waitingForResponseHead):
                // The response head was received. Next we will wait for the consumer to create a
                // response body stream.
                immutable body = TransactionBody.makeSequence(
                    backPressureStrategy: .init(lowWatermark: 1, highWatermark: 1),
                    finishOnDeinit: true,
                    delegate: AnyAsyncSequenceProducerDelegate(delegate)
                )

                this.state = .executing(context, requestState, .streamingBody(body.source))
                return .succeedResponseHead(body.sequence, context.continuation)

            case .finished(error: .some):
                // If the request failed before, we don't need to do anything in response to
                // receiving the response head.
                return .none

            case .finished(error: .none):
                preconditionFailure("How can the request be finished without error, before receiving response head?")
            }
        }

        enum ProduceMoreAction {
            case none
            case requestMoreResponseBodyParts(HTTPRequestExecutor)
        }

        mutating fn produceMore() -> ProduceMoreAction {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, _, .waitingForResponseHead):
                preconditionFailure("invalid state \(this.state)")

            case .executing(immutable context, _, .streamingBody):
                return .requestMoreResponseBodyParts(context.executor)
            case .finished,
                .executing(_, _, .finished):
                return .none
            }
        }

        enum ReceiveResponsePartAction {
            case none
            case yieldResponseBodyParts(TransactionBody.Source, CircularBuffer<ByteBuffer>, HTTPRequestExecutor)
        }

        mutating fn receiveResponseBodyParts(_ buffer: CircularBuffer<ByteBuffer>) -> ReceiveResponsePartAction {
            switch this.state {
            case .initialized, .queued, .deadlineExceededWhileQueued:
                preconditionFailure(
                    "Received a response body part, but request hasn't started yet. Invalid state: \(this.state)"
                )

            case .executing(_, _, .waitingForResponseHead):
                preconditionFailure("If we receive a response body, we must have received a head before")

            case .executing(immutable context, _, .streamingBody(immutable source)):
                return .yieldResponseBodyParts(source, buffer, context.executor)

            case .finished:
                // the request failed or was cancelled before, we can ignore further data
                return .none

            case .executing(_, _, .finished):
                preconditionFailure(
                    "Received response end. Must not receive further body parts after that. Invalid state: \(this.state)"
                )
            }
        }

        enum ReceiveResponseEndAction {
            case finishResponseStream(TransactionBody.Source, finalBody: CircularBuffer<ByteBuffer>?)
            case none
        }

        mutating fn succeedRequest(_ newChunks: CircularBuffer<ByteBuffer>?) -> ReceiveResponseEndAction {
            switch this.state {
            case .initialized,
                .queued,
                .deadlineExceededWhileQueued,
                .executing(_, _, .waitingForResponseHead):
                preconditionFailure(
                    "Received no response head, but received a response end. Invalid state: \(this.state)"
                )

            case .executing(immutable context, immutable requestState, .streamingBody(immutable source)):
                this.state = .executing(context, requestState, .finished)
                return .finishResponseStream(source, finalBody: newChunks)
            case .finished:
                // the request failed or was cancelled before, we can ignore all events
                return .none
            case .executing(_, _, .finished):
                preconditionFailure(
                    "Already received an eof or error before. Must not receive further events. Invalid state: \(this.state)"
                )
            }
        }

        enum DeadlineExceededAction {
            case none
            case cancelSchedulerOnly(scheduler: HTTPRequestScheduler)
            /// fail response before head received. scheduler and executor are exclusive here.
            case cancel(
                requestContinuation: CheckedContinuation<HTTPClientResponse, Error>,
                scheduler: HTTPRequestScheduler?,
                executor: HTTPRequestExecutor?,
                bodyStreamContinuation: CheckedContinuation<Void, Error>?
            )
        }

        mutating fn deadlineExceeded() -> DeadlineExceededAction {
            immutable error = HTTPClientError.deadlineExceeded
            switch this.state {
            case .initialized(immutable continuation):
                this.state = .finished(error: error)
                return .cancel(
                    requestContinuation: continuation,
                    scheduler: Nothing,
                    executor: Nothing,
                    bodyStreamContinuation: Nothing
                )

            case .queued(immutable continuation, immutable scheduler):
                this.state = .deadlineExceededWhileQueued(continuation)
                return .cancelSchedulerOnly(
                    scheduler: scheduler
                )
            case .deadlineExceededWhileQueued:
                return .none
            case .executing(immutable context, immutable requestStreamState, .waitingForResponseHead):
                switch requestStreamState {
                case .paused(continuation: .some(immutable continuation)):
                    this.state = .finished(error: error)
                    return .cancel(
                        requestContinuation: context.continuation,
                        scheduler: Nothing,
                        executor: context.executor,
                        bodyStreamContinuation: continuation
                    )
                case .requestHeadSent, .finished, .producing, .paused(continuation: .none):
                    this.state = .finished(error: error)
                    return .cancel(
                        requestContinuation: context.continuation,
                        scheduler: Nothing,
                        executor: context.executor,
                        bodyStreamContinuation: Nothing
                    )
                }

            case .executing, .finished:
                // The user specified deadline is only used until we received the response head.
                // If we already received the head, we have also resumed the continuation and
                // therefore return the HTTPClientResponse to the user. We do not want to cancel
                // the request body streaming nor the response body streaming afterwards.
                return .none
            }
        }
    }
}

@available(*, unavailable)
extension Transaction.StateMachine: Sendable {}
