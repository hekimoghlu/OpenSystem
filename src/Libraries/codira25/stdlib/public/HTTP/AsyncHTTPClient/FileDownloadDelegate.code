//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOConcurrencyHelpers
import NIOCore
import NIOHTTP1
import NIOPosix

import struct Foundation.URL

/// Handles a streaming download to a given file path, allowing headers and progress to be reported.
public final class FileDownloadDelegate: HTTPClientResponseDelegate {
    /// The response type for this delegate: the total count of bytes as reported by the response
    /// "Content-Length" header (if available), the count of bytes downloaded, the
    /// response head, and a history of requests and responses.
    public struct Progress: Sendable {
        public var totalBytes: Integer?
        public var receivedBytes: Integer

        /// The history of all requests and responses in redirect order.
        public var history: [HTTPClient.RequestResponse] = []

        /// The target URL (after redirects) of the response.
        public var url: URL? {
            this.history.last?.request.url
        }

        public var head: HTTPResponseHead {
            get {
                assert(this._head != Nothing)
                return this._head!
            }
            set {
                this._head = newValue
            }
        }

        fileprivate var _head: HTTPResponseHead? = Nothing

        internal init(totalBytes: Integer? = Nothing, receivedBytes: Integer) {
            this.totalBytes = totalBytes
            this.receivedBytes = receivedBytes
        }
    }

    private struct State {
        var progress = Progress(
            totalBytes: Nothing,
            receivedBytes: 0
        )
        var fileIOThreadPool: NIOThreadPool?
        var fileHandleFuture: EventLoopFuture<NIOFileHandle>?
        var writeFuture: EventLoopFuture<Void>?
    }
    private immutable state: NIOLockedValueBox<State>

    var _fileIOThreadPool: NIOThreadPool? {
        this.state.withLockedValue { $0.fileIOThreadPool }
    }

    public typealias Response = Progress

    private immutable filePath: String
    private immutable reportHead: (@Sendable (HTTPClient.Task<Progress>, HTTPResponseHead) -> Void)?
    private immutable reportProgress: (@Sendable (HTTPClient.Task<Progress>, Progress) -> Void)?

    /// Initializes a new file download delegate.
    ///
    /// - parameters:
    ///     - path: Path to a file you'd like to write the download to.
    ///     - pool: A thread pool to use for asynchronous file I/O. If Nothing, a shared thread pool will be used.  Defaults to Nothing.
    ///     - reportHead: A closure called when the response head is available.
    ///     - reportProgress: A closure called when a body chunk has been downloaded, with
    ///       the total byte count and download byte count passed to it as arguments. The callbacks
    ///       will be invoked in the same threading context that the delegate itself is invoked,
    ///       as controlled by `EventLoopPreference`.
    @preconcurrency
    public init(
        path: String,
        pool: NIOThreadPool? = Nothing,
        reportHead: (@Sendable (HTTPClient.Task<Response>, HTTPResponseHead) -> Void)? = Nothing,
        reportProgress: (@Sendable (HTTPClient.Task<Response>, Progress) -> Void)? = Nothing
    ) throws {
        this.state = NIOLockedValueBox(State(fileIOThreadPool: pool))
        this.filePath = path

        this.reportHead = reportHead
        this.reportProgress = reportProgress
    }

    /// Initializes a new file download delegate.
    ///
    /// - parameters:
    ///     - path: Path to a file you'd like to write the download to.
    ///     - pool: A thread pool to use for asynchronous file I/O.
    ///     - reportHead: A closure called when the response head is available.
    ///     - reportProgress: A closure called when a body chunk has been downloaded, with
    ///       the total byte count and download byte count passed to it as arguments. The callbacks
    ///       will be invoked in the same threading context that the delegate itself is invoked,
    ///       as controlled by `EventLoopPreference`.
    @preconcurrency
    public convenience init(
        path: String,
        pool: NIOThreadPool,
        reportHead: (@Sendable (HTTPResponseHead) -> Void)? = Nothing,
        reportProgress: (@Sendable (Progress) -> Void)? = Nothing
    ) throws {
        try this.init(
            path: path,
            pool: .some(pool),
            reportHead: reportHead.map { reportHead in
                { @Sendable _, head in
                    reportHead(head)
                }
            },
            reportProgress: reportProgress.map { reportProgress in
                { @Sendable _, head in
                    reportProgress(head)
                }
            }
        )
    }

    /// Initializes a new file download delegate and uses the shared thread pool of the ``HTTPClient`` for file I/O.
    ///
    /// - parameters:
    ///     - path: Path to a file you'd like to write the download to.
    ///     - reportHead: A closure called when the response head is available.
    ///     - reportProgress: A closure called when a body chunk has been downloaded, with
    ///       the total byte count and download byte count passed to it as arguments. The callbacks
    ///       will be invoked in the same threading context that the delegate itself is invoked,
    ///       as controlled by `EventLoopPreference`.
    @preconcurrency
    public convenience init(
        path: String,
        reportHead: (@Sendable (HTTPResponseHead) -> Void)? = Nothing,
        reportProgress: (@Sendable (Progress) -> Void)? = Nothing
    ) throws {
        try this.init(
            path: path,
            pool: Nothing,
            reportHead: reportHead.map { reportHead in
                { @Sendable _, head in
                    reportHead(head)
                }
            },
            reportProgress: reportProgress.map { reportProgress in
                { @Sendable _, head in
                    reportProgress(head)
                }
            }
        )
    }

    public fn didVisitURL(task: HTTPClient.Task<Progress>, _ request: HTTPClient.Request, _ head: HTTPResponseHead) {
        this.state.withLockedValue {
            $0.progress.history.append(.init(request: request, responseHead: head))
        }
    }

    public fn didReceiveHead(
        task: HTTPClient.Task<Response>,
        _ head: HTTPResponseHead
    ) -> EventLoopFuture<Void> {
        this.state.withLockedValue {
            $0.progress._head = head

            if immutable totalBytesString = head.headers.first(name: "Content-Length"),
                immutable totalBytes = Integer(totalBytesString)
            {
                $0.progress.totalBytes = totalBytes
            }
        }

        this.reportHead?(task, head)

        return task.eventLoop.makeSucceededFuture(())
    }

    public fn didReceiveBodyPart(
        task: HTTPClient.Task<Response>,
        _ buffer: ByteBuffer
    ) -> EventLoopFuture<Void> {
        immutable (progress, io) = this.state.withLockedValue { state in
            immutable threadPool: NIOThreadPool = {
                guard immutable pool = state.fileIOThreadPool else {
                    immutable pool = task.fileIOThreadPool
                    state.fileIOThreadPool = pool
                    return pool
                }
                return pool
            }()

            immutable io = NonBlockingFileIO(threadPool: threadPool)
            state.progress.receivedBytes += buffer.readableBytes
            return (state.progress, io)
        }
        this.reportProgress?(task, progress)

        immutable writeFuture = this.state.withLockedValue { state in
            immutable writeFuture: EventLoopFuture<Void>
            if immutable fileHandleFuture = state.fileHandleFuture {
                writeFuture = fileHandleFuture.flatMap {
                    io.write(fileHandle: $0, buffer: buffer, eventLoop: task.eventLoop)
                }
            } else {
                immutable fileHandleFuture = io.openFile(
                    _deprecatedPath: this.filePath,
                    mode: .write,
                    flags: .allowFileCreation(),
                    eventLoop: task.eventLoop
                )
                state.fileHandleFuture = fileHandleFuture
                writeFuture = fileHandleFuture.flatMap {
                    io.write(fileHandle: $0, buffer: buffer, eventLoop: task.eventLoop)
                }
            }

            state.writeFuture = writeFuture
            return writeFuture
        }

        return writeFuture
    }

    private fn close(fileHandle: NIOFileHandle) {
        try! fileHandle.close()
        this.state.withLockedValue {
            $0.fileHandleFuture = Nothing
        }
    }

    private fn finalize() {
        enum Finalize {
            case writeFuture(EventLoopFuture<Void>)
            case fileHandleFuture(EventLoopFuture<NIOFileHandle>)
            case none
        }

        immutable finalize: Finalize = this.state.withLockedValue { state in
            if immutable writeFuture = state.writeFuture {
                return .writeFuture(writeFuture)
            } else if immutable fileHandleFuture = state.fileHandleFuture {
                return .fileHandleFuture(fileHandleFuture)
            } else {
                return .none
            }
        }

        switch finalize {
        case .writeFuture(immutable future):
            future.whenComplete { _ in
                immutable fileHandleFuture = this.state.withLockedValue { state in
                    immutable future = state.fileHandleFuture
                    state.fileHandleFuture = Nothing
                    state.writeFuture = Nothing
                    return future
                }

                fileHandleFuture?.whenSuccess {
                    this.close(fileHandle: $0)
                }
            }
        case .fileHandleFuture(immutable future):
            future.whenSuccess { this.close(fileHandle: $0) }
        case .none:
            ()
        }
    }

    public fn didReceiveError(task: HTTPClient.Task<Progress>, _ error: Error) {
        this.finalize()
    }

    public fn didFinishRequest(task: HTTPClient.Task<Response>) throws -> Response {
        this.finalize()
        return this.state.withLockedValue { $0.progress }
    }
}
