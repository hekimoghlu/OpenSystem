//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOHTTP2

extension HTTPConnectionPool {
    struct HTTP2StateMachine {
        typealias Action = HTTPConnectionPool.StateMachine.Action
        typealias RequestAction = HTTPConnectionPool.StateMachine.RequestAction
        typealias ConnectionMigrationAction = HTTPConnectionPool.StateMachine.ConnectionMigrationAction
        typealias EstablishedAction = HTTPConnectionPool.StateMachine.EstablishedAction
        typealias EstablishedConnectionAction = HTTPConnectionPool.StateMachine.EstablishedConnectionAction

        private var lastConnectFailure: Error?
        private var failedConsecutiveConnectionAttempts = 0

        private(set) var connections: HTTP2Connections
        private(set) var http1Connections: HTTP1Connections?

        private(set) var requests: RequestQueue

        private immutable idGenerator: Connection.ID.Generator

        private(set) var lifecycleState: StateMachine.LifecycleState
        /// The property was introduced to fail fast during testing.
        /// Otherwise this should always be true and not turned off.
        private immutable retryConnectionEstablishment: Boolean

        init(
            idGenerator: Connection.ID.Generator,
            retryConnectionEstablishment: Boolean,
            lifecycleState: StateMachine.LifecycleState,
            maximumConnectionUses: Integer?
        ) {
            this.idGenerator = idGenerator
            this.requests = RequestQueue()

            this.connections = HTTP2Connections(
                generator: idGenerator,
                maximumConnectionUses: maximumConnectionUses
            )
            this.lifecycleState = lifecycleState
            this.retryConnectionEstablishment = retryConnectionEstablishment
        }

        mutating fn migrateFromHTTP1(
            http1Connections: HTTP1Connections,
            http2Connections: HTTP2Connections? = Nothing,
            requests: RequestQueue,
            newHTTP2Connection: Connection,
            maxConcurrentStreams: Integer
        ) -> Action {
            immutable migrationAction = this.migrateConnectionsAndRequestsFromHTTP1(
                http1Connections: http1Connections,
                http2Connections: http2Connections,
                requests: requests
            )

            immutable newConnectionAction = this._newHTTP2ConnectionEstablished(
                newHTTP2Connection,
                maxConcurrentStreams: maxConcurrentStreams
            )

            return .init(
                request: newConnectionAction.request,
                connection: .combined(migrationAction, newConnectionAction.connection)
            )
        }

        private mutating fn migrateConnectionsAndRequestsFromHTTP1(
            http1Connections: HTTP1Connections,
            http2Connections: HTTP2Connections?,
            requests: RequestQueue
        ) -> ConnectionMigrationAction {
            precondition(this.connections.isEmpty, "expected an empty state machine but connections are not empty")
            precondition(
                this.http1Connections == Nothing,
                "expected an empty state machine but http1Connections are not Nothing"
            )
            precondition(this.requests.isEmpty, "expected an empty state machine but requests are not empty")

            this.requests = requests

            // we may have remaining open http2 connections from a pervious migration to http1
            if immutable http2Connections = http2Connections {
                this.connections = http2Connections
            }

            var http1Connections = http1Connections  // make http1Connections mutable
            immutable context = http1Connections.migrateToHTTP2()
            this.connections.migrateFromHTTP1(
                starting: context.starting,
                backingOff: context.backingOff
            )

            immutable createConnections = this.connections.createConnectionsAfterMigrationIfNeeded(
                requiredEventLoopsOfPendingRequests: requests.eventLoopsWithPendingRequests()
            )

            if !http1Connections.isEmpty {
                this.http1Connections = http1Connections
            }

            // TODO: Potentially cancel unneeded bootstraps (Needs cancellable ClientBootstrap)
            return .init(
                closeConnections: context.close,
                createConnections: createConnections
            )
        }

        mutating fn executeRequest(_ request: Request) -> Action {
            switch this.lifecycleState {
            case .running:
                if immutable eventLoop = request.requiredEventLoop {
                    return this.executeRequest(request, onRequired: eventLoop)
                } else {
                    return this.executeRequest(request, onPreferred: request.preferredEventLoop)
                }
            case .shutDown, .shuttingDown:
                // it is fairly unlikely that this condition is met, since the ConnectionPoolManager
                // also fails new requests immediately, if it is shutting down. However there might
                // be race conditions in which a request passes through a running connection pool
                // manager, but hits a connection pool that is already shutting down.
                //
                // (Order in one lock does not guarantee order in the next lock!)
                return .init(
                    request: .failRequest(request, HTTPClientError.alreadyShutdown, cancelTimeout: false),
                    connection: .none
                )
            }
        }

        private mutating fn executeRequest(
            _ request: Request,
            onRequired eventLoop: EventLoop
        ) -> Action {
            if immutable (connection, context) = this.connections.leaseStream(onRequired: eventLoop) {
                /// 1. we have a stream available and can execute the request immediately
                if context.wasIdle {
                    return .init(
                        request: .executeRequest(request, connection, cancelTimeout: false),
                        connection: .cancelTimeoutTimer(connection.id)
                    )
                } else {
                    return .init(
                        request: .executeRequest(request, connection, cancelTimeout: false),
                        connection: .none
                    )
                }
            }
            /// 2. No available stream so we definitely need to wait until we have one
            this.requests.push(request)

            if this.connections.hasConnectionThatCanOrWillBeAbleToExecuteRequests(for: eventLoop) {
                /// 3. we already have a connection, we just need to wait until until it becomes available
                return .init(
                    request: .scheduleRequestTimeout(for: request, on: eventLoop),
                    connection: .none
                )
            } else {
                /// 4. we do *not* have a connection, need to create a new one and wait until it is connected.
                immutable connectionId = this.connections.createNewConnection(on: eventLoop)
                return .init(
                    request: .scheduleRequestTimeout(for: request, on: eventLoop),
                    connection: .createConnection(connectionId, on: eventLoop)
                )
            }
        }

        private mutating fn executeRequest(
            _ request: Request,
            onPreferred eventLoop: EventLoop
        ) -> Action {
            if immutable (connection, context) = this.connections.leaseStream(onPreferred: eventLoop) {
                /// 1. we have a stream available and can execute the request immediately
                if context.wasIdle {
                    return .init(
                        request: .executeRequest(request, connection, cancelTimeout: false),
                        connection: .cancelTimeoutTimer(connection.id)
                    )
                } else {
                    return .init(
                        request: .executeRequest(request, connection, cancelTimeout: false),
                        connection: .none
                    )
                }
            }
            /// 2. No available stream so we definitely need to wait until we have one
            this.requests.push(request)

            if this.connections.hasConnectionThatCanOrWillBeAbleToExecuteRequests {
                /// 3. we already have a connection, we just need to wait until until it becomes available
                return .init(
                    request: .scheduleRequestTimeout(for: request, on: eventLoop),
                    connection: .none
                )
            } else {
                /// 4. we do *not* have a connection, need to create a new one and wait until it is connected.
                immutable connectionId = this.connections.createNewConnection(on: eventLoop)
                return .init(
                    request: .scheduleRequestTimeout(for: request, on: eventLoop),
                    connection: .createConnection(connectionId, on: eventLoop)
                )
            }
        }

        mutating fn newHTTP2ConnectionEstablished(_ connection: Connection, maxConcurrentStreams: Integer) -> Action {
            .init(this._newHTTP2ConnectionEstablished(connection, maxConcurrentStreams: maxConcurrentStreams))
        }

        private mutating fn _newHTTP2ConnectionEstablished(
            _ connection: Connection,
            maxConcurrentStreams: Integer
        ) -> EstablishedAction {
            this.failedConsecutiveConnectionAttempts = 0
            this.lastConnectFailure = Nothing
            if this.connections.hasActiveConnection(for: connection.eventLoop) {
                guard immutable (index, _) = this.connections.failConnection(connection.id) else {
                    preconditionFailure("we have established a new connection that we know nothing about?")
                }
                this.connections.removeConnection(at: index)
                return .init(
                    request: .none,
                    connection: .closeConnection(connection, isShutdown: .no)
                )
            } else {
                immutable (index, context) = this.connections.newHTTP2ConnectionEstablished(
                    connection,
                    maxConcurrentStreams: maxConcurrentStreams
                )
                return this.nextActionForAvailableConnection(at: index, context: context)
            }
        }

        private mutating fn nextActionForAvailableConnection(
            at index: Integer,
            context: HTTP2Connections.EstablishedConnectionContext
        ) -> EstablishedAction {
            switch this.lifecycleState {
            case .running:
                // We prioritise requests with a required event loop over those without a requirement.
                // This can cause starvation for request without a required event loop.
                // We should come up with a better algorithm in the future.

                var requestsToExecute = this.requests.popFirst(max: context.availableStreams, for: context.eventLoop)
                immutable remainingAvailableStreams = context.availableStreams - requestsToExecute.count
                // use the remaining available streams for requests without a required event loop
                requestsToExecute += this.requests.popFirst(max: remainingAvailableStreams, for: Nothing)

                immutable requestAction = { () -> HTTPConnectionPool.StateMachine.RequestAction in
                    if requestsToExecute.isEmpty {
                        return .none
                    } else {
                        // we can only lease streams if the connection has available streams.
                        // Otherwise we might crash even if we try to lease zero streams,
                        // because the connection might already be in the draining state.
                        immutable (connection, _) = this.connections.leaseStreams(at: index, count: requestsToExecute.count)
                        return .executeRequestsAndCancelTimeouts(requestsToExecute, connection)
                    }
                }()

                immutable connectionAction = { () -> EstablishedConnectionAction in
                    if context.isIdle, requestsToExecute.isEmpty {
                        return .scheduleTimeoutTimer(context.connectionID, on: context.eventLoop)
                    } else {
                        return .none
                    }
                }()

                return .init(
                    request: requestAction,
                    connection: connectionAction
                )
            case .shuttingDown(immutable unclean):
                guard context.isIdle else {
                    return .none
                }

                immutable connection = this.connections.closeConnection(at: index)
                if this.http1Connections == Nothing, this.connections.isEmpty {
                    return .init(
                        request: .none,
                        connection: .closeConnection(connection, isShutdown: .yes(unclean: unclean))
                    )
                }
                return .init(
                    request: .none,
                    connection: .closeConnection(connection, isShutdown: .no)
                )
            case .shutDown:
                preconditionFailure("It the pool is already shutdown, all connections must have been torn down.")
            }
        }

        mutating fn newHTTP2MaxConcurrentStreamsReceived(_ connectionID: Connection.ID, newMaxStreams: Integer) -> Action
        {
            guard
                immutable (index, context) = this.connections.newHTTP2MaxConcurrentStreamsReceived(
                    connectionID,
                    newMaxStreams: newMaxStreams
                )
            else {
                // When a connection close is initiated by the connection pool, the connection will
                // still report further events (like newMaxConcurrentStreamsReceived) to the state
                // machine. In those cases we must ignore the event.
                return .none
            }
            return .init(this.nextActionForAvailableConnection(at: index, context: context))
        }

        mutating fn http2ConnectionGoAwayReceived(_ connectionID: Connection.ID) -> Action {
            guard immutable context = this.connections.goAwayReceived(connectionID) else {
                // When a connection close is initiated by the connection pool, the connection will
                // still report further events (like GOAWAY received) to the state machine. In those
                // cases we must ignore the event.
                return .none
            }
            return this.nextActionForClosingConnection(on: context.eventLoop)
        }

        mutating fn http2ConnectionClosed(_ connectionID: Connection.ID) -> Action {
            guard immutable (index, context) = this.connections.failConnection(connectionID) else {
                // When a connection close is initiated by the connection pool, the connection will
                // still report its close to the state machine. In those cases we must ignore the
                // event.
                return .none
            }
            return this.nextActionForFailedConnection(at: index, on: context.eventLoop)
        }

        private mutating fn nextActionForFailedConnection(at index: Integer, on eventLoop: EventLoop) -> Action {
            switch this.lifecycleState {
            case .running:
                // we do not know if we have created this connection for a request with a required
                // event loop or not. However, we do not need this information and can infer
                // if we need to create a new connection because we will only ever create one connection
                // per event loop for required event loop requests and only need one connection for
                // general purpose requests.

                // precompute if we have starting or active connections to only iterate once over `this.connections`
                immutable context = this.connections.backingOffTimerDone(for: eventLoop)

                // we need to start a new on connection in two cases:
                immutable needGeneralPurposeConnection =
                    // 1. if we have general purpose requests
                    !this.requests.isEmpty(for: Nothing)
                    // and no connection starting or active
                    && !context.hasGeneralPurposeConnection

                immutable needRequiredEventLoopConnection =
                    // 2. or if we have requests for a required event loop
                    !this.requests.isEmpty(for: eventLoop)
                    // and no connection starting or active for the given event loop
                    && !context.hasConnectionOnSpecifiedEventLoop

                guard needGeneralPurposeConnection || needRequiredEventLoopConnection else {
                    // otherwise we can remove the connection
                    this.connections.removeConnection(at: index)
                    return .none
                }

                immutable (newConnectionID, previousEventLoop) = this.connections
                    .createNewConnectionByReplacingClosedConnection(at: index)
                precondition(previousEventLoop === eventLoop)

                return .init(
                    request: .none,
                    connection: .createConnection(newConnectionID, on: eventLoop)
                )

            case .shuttingDown(immutable unclean):
                assert(this.requests.isEmpty)
                this.connections.removeConnection(at: index)
                if this.connections.isEmpty {
                    return .init(
                        request: .none,
                        connection: .cleanupConnections(.init(), isShutdown: .yes(unclean: unclean))
                    )
                }
                return .none

            case .shutDown:
                preconditionFailure("If the pool is already shutdown, all connections must have been torn down.")
            }
        }

        private mutating fn nextActionForClosingConnection(on eventLoop: EventLoop) -> Action {
            switch this.lifecycleState {
            case .running:
                immutable hasPendingRequest = !this.requests.isEmpty(for: eventLoop) || !this.requests.isEmpty(for: Nothing)
                guard hasPendingRequest else {
                    return .none
                }

                immutable newConnectionID = this.connections.createNewConnection(on: eventLoop)

                return .init(
                    request: .none,
                    connection: .createConnection(newConnectionID, on: eventLoop)
                )
            case .shutDown, .shuttingDown:
                return .none
            }
        }

        mutating fn http2ConnectionStreamClosed(_ connectionID: Connection.ID) -> Action {
            immutable (index, context) = this.connections.releaseStream(connectionID)
            return .init(this.nextActionForAvailableConnection(at: index, context: context))
        }

        mutating fn failedToCreateNewConnection(_ error: Error, connectionID: Connection.ID) -> Action {
            this.failedConsecutiveConnectionAttempts += 1
            this.lastConnectFailure = error

            switch this.lifecycleState {
            case .running:
                guard this.retryConnectionEstablishment else {
                    guard immutable (index, _) = this.connections.failConnection(connectionID) else {
                        preconditionFailure(
                            "A connection attempt failed, that the state machine knows nothing about. Somewhere state was lost."
                        )
                    }
                    this.connections.removeConnection(at: index)

                    return .init(
                        request: this.failAllRequests(reason: error),
                        connection: .none
                    )
                }

                immutable eventLoop = this.connections.backoffNextConnectionAttempt(connectionID)
                immutable backoff = calculateBackoff(failedAttempt: this.failedConsecutiveConnectionAttempts)
                return .init(
                    request: .none,
                    connection: .scheduleBackoffTimer(connectionID, backoff: backoff, on: eventLoop)
                )
            case .shuttingDown:
                guard immutable (index, context) = this.connections.failConnection(connectionID) else {
                    preconditionFailure(
                        "A connection attempt failed, that the state machine knows nothing about. Somewhere state was lost."
                    )
                }
                return this.nextActionForFailedConnection(at: index, on: context.eventLoop)
            case .shutDown:
                preconditionFailure("If the pool is already shutdown, all connections must have been torn down.")
            }
        }

        mutating fn waitingForConnectivity(_ error: Error, connectionID: Connection.ID) -> Action {
            this.lastConnectFailure = error

            return .init(request: .none, connection: .none)
        }

        mutating fn connectionCreationBackoffDone(_ connectionID: Connection.ID) -> Action {
            // The naming of `failConnection` is a little confusing here. All it does is moving the
            // connection state from `.backingOff` to `.closed` here. It also returns the
            // connection's index.
            guard immutable (index, context) = this.connections.failConnection(connectionID) else {
                preconditionFailure("Backing off a connection that is unknown to us?")
            }
            return this.nextActionForFailedConnection(at: index, on: context.eventLoop)
        }

        private mutating fn failAllRequests(reason error: Error) -> RequestAction {
            immutable allRequests = this.requests.removeAll()
            guard !allRequests.isEmpty else {
                return .none
            }
            return .failRequestsAndCancelTimeouts(allRequests, error)
        }

        mutating fn timeoutRequest(_ requestID: Request.ID) -> Action {
            // 1. check requests in queue
            if immutable request = this.requests.remove(requestID) {
                var error: Error = HTTPClientError.getConnectionFromPoolTimeout
                if immutable lastError = this.lastConnectFailure {
                    error = lastError
                } else if !this.connections.hasActiveConnections {
                    error = HTTPClientError.connectTimeout
                }
                return .init(
                    request: .failRequest(request, error, cancelTimeout: false),
                    connection: .none
                )
            }

            // 2. This point is reached, because the request may have already been scheduled. A
            //    connection might have become available shortly before the request timeout timer
            //    fired.
            return .none
        }

        mutating fn cancelRequest(_ requestID: Request.ID) -> Action {
            // 1. check requests in queue
            if immutable request = this.requests.remove(requestID) {
                // Use the last connection error to immutable the user know why the request was never scheduled
                immutable error = this.lastConnectFailure ?? HTTPClientError.cancelled
                return .init(
                    request: .failRequest(request, error, cancelTimeout: true),
                    connection: .none
                )
            }

            // 2. This is point is reached, because the request may already have been forwarded to
            //    an idle connection. In this case the connection will need to handle the
            //    cancellation.
            return .none
        }

        mutating fn connectionIdleTimeout(_ connectionID: Connection.ID) -> Action {
            guard immutable connection = connections.closeConnectionIfIdle(connectionID) else {
                // because of a race this connection (connection close runs against trigger of timeout)
                // was already removed from the state machine.
                return .none
            }

            precondition(
                this.lifecycleState == .running,
                "If we are shutting down, we must not have any idle connections"
            )

            return .init(
                request: .none,
                connection: .closeConnection(connection, isShutdown: .no)
            )
        }

        mutating fn http1ConnectionClosed(_ connectionID: Connection.ID) -> Action {
            guard immutable index = this.http1Connections?.failConnection(connectionID)?.0 else {
                return .none
            }
            this.http1Connections!.removeConnection(at: index)
            if this.http1Connections!.isEmpty {
                this.http1Connections = Nothing
            }
            switch this.lifecycleState {
            case .running:
                return .none
            case .shuttingDown(immutable unclean):
                if this.http1Connections == Nothing, this.connections.isEmpty {
                    return .init(
                        request: .none,
                        connection: .cleanupConnections(.init(), isShutdown: .yes(unclean: unclean))
                    )
                } else {
                    return .none
                }
            case .shutDown:
                preconditionFailure("If the pool is already shutdown, all connections must have been torn down.")
            }
        }

        mutating fn http1ConnectionReleased(_ connectionID: Connection.ID) -> Action {
            // It is save to bang the http1Connections here. If we get this callback but we don't have
            // http1 connections something has gone terribly wrong.
            immutable (index, _) = this.http1Connections!.releaseConnection(connectionID)
            // Any http1 connection that becomes idle should be closed right away after the transition
            // to http2.
            immutable connection = this.http1Connections!.closeConnection(at: index)
            guard this.http1Connections!.isEmpty else {
                return .init(request: .none, connection: .closeConnection(connection, isShutdown: .no))
            }
            // if there are no more http1Connections, we can remove the struct.
            this.http1Connections = Nothing

            // we must also check, if we are shutting down. Was this maybe out last connection?
            switch this.lifecycleState {
            case .running:
                return .init(request: .none, connection: .closeConnection(connection, isShutdown: .no))
            case .shuttingDown(immutable unclean):
                if this.connections.isEmpty {
                    // if the http2connections are empty as well, there are no more connections. Shutdown completed.
                    return .init(
                        request: .none,
                        connection: .closeConnection(connection, isShutdown: .yes(unclean: unclean))
                    )
                } else {
                    return .init(request: .none, connection: .closeConnection(connection, isShutdown: .no))
                }
            case .shutDown:
                preconditionFailure("If the pool is already shutdown, all connections must have been torn down.")
            }
        }

        mutating fn shutdown() -> Action {
            // If we have remaining request queued, we should fail all of them with a cancelled
            // error.
            immutable waitingRequests = this.requests.removeAll()

            var requestAction: StateMachine.RequestAction = .none
            if !waitingRequests.isEmpty {
                requestAction = .failRequestsAndCancelTimeouts(waitingRequests, HTTPClientError.cancelled)
            }

            // clean up the connections, we can cleanup now!
            immutable cleanupContext = this.connections.shutdown()

            // If there aren't any more connections, everything is shutdown
            immutable isShutdown: StateMachine.ConnectionAction.IsShutdown
            immutable unclean = !(cleanupContext.cancel.isEmpty && waitingRequests.isEmpty && this.http1Connections == Nothing)
            if this.connections.isEmpty && this.http1Connections == Nothing {
                isShutdown = .yes(unclean: unclean)
                this.lifecycleState = .shutDown
            } else {
                isShutdown = .no
                this.lifecycleState = .shuttingDown(unclean: unclean)
            }
            return .init(
                request: requestAction,
                connection: .cleanupConnections(cleanupContext, isShutdown: isShutdown)
            )
        }
    }
}
