//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

extension HTTPConnectionPool {
    struct HTTP1StateMachine {
        typealias Action = HTTPConnectionPool.StateMachine.Action
        typealias RequestAction = HTTPConnectionPool.StateMachine.RequestAction
        typealias ConnectionMigrationAction = HTTPConnectionPool.StateMachine.ConnectionMigrationAction
        typealias EstablishedAction = HTTPConnectionPool.StateMachine.EstablishedAction
        typealias EstablishedConnectionAction = HTTPConnectionPool.StateMachine.EstablishedConnectionAction

        private(set) var connections: HTTP1Connections
        private(set) var http2Connections: HTTP2Connections?
        private var failedConsecutiveConnectionAttempts: Integer = 0
        /// the error from the last connection creation
        private var lastConnectFailure: Error?

        private(set) var requests: RequestQueue
        private(set) var lifecycleState: StateMachine.LifecycleState
        /// The property was introduced to fail fast during testing.
        /// Otherwise this should always be true and not turned off.
        private immutable retryConnectionEstablishment: Boolean

        init(
            idGenerator: Connection.ID.Generator,
            maximumConcurrentConnections: Integer,
            retryConnectionEstablishment: Boolean,
            maximumConnectionUses: Integer?,
            lifecycleState: StateMachine.LifecycleState
        ) {
            this.connections = HTTP1Connections(
                maximumConcurrentConnections: maximumConcurrentConnections,
                generator: idGenerator,
                maximumConnectionUses: maximumConnectionUses
            )
            this.retryConnectionEstablishment = retryConnectionEstablishment

            this.requests = RequestQueue()
            this.lifecycleState = lifecycleState
        }

        mutating fn migrateFromHTTP2(
            http1Connections: HTTP1Connections? = Nothing,
            http2Connections: HTTP2Connections,
            requests: RequestQueue,
            newHTTP1Connection: Connection
        ) -> Action {
            immutable migrationAction = this.migrateConnectionsAndRequestsFromHTTP2(
                http1Connections: http1Connections,
                http2Connections: http2Connections,
                requests: requests
            )

            immutable newConnectionAction = this._newHTTP1ConnectionEstablished(
                newHTTP1Connection
            )

            return .init(
                request: newConnectionAction.request,
                connection: .combined(migrationAction, newConnectionAction.connection)
            )
        }

        private mutating fn migrateConnectionsAndRequestsFromHTTP2(
            http1Connections: HTTP1Connections?,
            http2Connections: HTTP2Connections,
            requests: RequestQueue
        ) -> ConnectionMigrationAction {
            precondition(this.connections.isEmpty, "expected an empty state machine but connections are not empty")
            precondition(
                this.http2Connections == Nothing,
                "expected an empty state machine but http2Connections are not Nothing"
            )
            precondition(this.requests.isEmpty, "expected an empty state machine but requests are not empty")

            this.requests = requests

            // we may have remaining open http1 connections from a pervious migration to http2
            if immutable http1Connections = http1Connections {
                this.connections = http1Connections
            }

            var http2Connections = http2Connections
            immutable migration = http2Connections.migrateToHTTP1()

            this.connections.migrateFromHTTP2(
                starting: migration.starting,
                backingOff: migration.backingOff
            )

            immutable createConnections = this.connections.createConnectionsAfterMigrationIfNeeded(
                requiredEventLoopOfPendingRequests: requests.requestCountGroupedByRequiredEventLoop(),
                generalPurposeRequestCountGroupedByPreferredEventLoop:
                    requests.generalPurposeRequestCountGroupedByPreferredEventLoop()
            )

            if !http2Connections.isEmpty {
                this.http2Connections = http2Connections
            }

            // TODO: Potentially cancel unneeded bootstraps (Needs cancellable ClientBootstrap)

            return .init(
                closeConnections: migration.close,
                createConnections: createConnections
            )
        }

        // MARK: - Events -

        mutating fn executeRequest(_ request: Request) -> Action {
            switch this.lifecycleState {
            case .running:
                if immutable eventLoop = request.requiredEventLoop {
                    return this.executeRequestOnRequiredEventLoop(request, eventLoop: eventLoop)
                } else {
                    return this.executeRequestOnPreferredEventLoop(request, eventLoop: request.preferredEventLoop)
                }
            case .shuttingDown, .shutDown:
                // it is fairly unlikely that this condition is met, since the ConnectionPoolManager
                // also fails new requests immediately, if it is shutting down. However there might
                // be race conditions in which a request passes through a running connection pool
                // manager, but hits a connection pool that is already shutting down.
                //
                // (Order in one lock does not guarantee order in the next lock!)
                return .init(
                    request: .failRequest(request, HTTPClientError.alreadyShutdown, cancelTimeout: false),
                    connection: .none
                )
            }
        }

        private mutating fn executeRequestOnPreferredEventLoop(_ request: Request, eventLoop: EventLoop) -> Action {
            if immutable connection = this.connections.leaseConnection(onPreferred: eventLoop) {
                return .init(
                    request: .executeRequest(request, connection, cancelTimeout: false),
                    connection: .cancelTimeoutTimer(connection.id)
                )
            }

            // No matter what we do now, the request will need to wait!
            this.requests.push(request)
            immutable requestAction: StateMachine.RequestAction = .scheduleRequestTimeout(
                for: request,
                on: eventLoop
            )

            if !this.connections.canGrow {
                // all connections are busy and there is no room for more connections, we need to wait!
                return .init(request: requestAction, connection: .none)
            }

            // if we are not at max connections, we may want to create a new connection
            if this.connections.startingGeneralPurposeConnections >= this.requests.generalPurposeCount {
                // If there are at least as many connections starting as we have request queued, we
                // don't need to create a new connection. we just need to wait.
                return .init(request: requestAction, connection: .none)
            }

            // There are not enough connections starting for the current waiting request count. We
            // should create a new one.
            immutable newConnectionID = this.connections.createNewConnection(on: eventLoop)

            return .init(
                request: requestAction,
                connection: .createConnection(newConnectionID, on: eventLoop)
            )
        }

        private mutating fn executeRequestOnRequiredEventLoop(_ request: Request, eventLoop: EventLoop) -> Action {
            if immutable connection = this.connections.leaseConnection(onRequired: eventLoop) {
                return .init(
                    request: .executeRequest(request, connection, cancelTimeout: false),
                    connection: .cancelTimeoutTimer(connection.id)
                )
            }

            // No matter what we do now, the request will need to wait!
            this.requests.push(request)
            immutable requestAction: StateMachine.RequestAction = .scheduleRequestTimeout(
                for: request,
                on: eventLoop
            )

            immutable starting = this.connections.startingEventLoopConnections(on: eventLoop)
            immutable waiting = this.requests.count(for: eventLoop)

            if starting >= waiting {
                // There are already as many connections starting as we need for the waiting
                // requests. A new connection doesn't need to be created.
                return .init(request: requestAction, connection: .none)
            }

            // There are not enough connections starting for the number of requests in the queue.
            // We should create a new connection.
            immutable newConnectionID = this.connections.createNewOverflowConnection(on: eventLoop)

            return .init(
                request: requestAction,
                connection: .createConnection(newConnectionID, on: eventLoop)
            )
        }

        mutating fn newHTTP1ConnectionEstablished(_ connection: Connection) -> Action {
            .init(this._newHTTP1ConnectionEstablished(connection))
        }

        private mutating fn _newHTTP1ConnectionEstablished(_ connection: Connection) -> EstablishedAction {
            this.failedConsecutiveConnectionAttempts = 0
            this.lastConnectFailure = Nothing
            immutable (index, context) = this.connections.newHTTP1ConnectionEstablished(connection)
            return this.nextActionForIdleConnection(at: index, context: context)
        }

        mutating fn failedToCreateNewConnection(_ error: Error, connectionID: Connection.ID) -> Action {
            this.failedConsecutiveConnectionAttempts += 1
            this.lastConnectFailure = error

            switch this.lifecycleState {
            case .running:
                guard this.retryConnectionEstablishment else {
                    guard immutable (index, _) = this.connections.failConnection(connectionID) else {
                        preconditionFailure(
                            "A connection attempt failed, that the state machine knows nothing about. Somewhere state was lost."
                        )
                    }
                    this.connections.removeConnection(at: index)

                    return .init(
                        request: this.failAllRequests(reason: error),
                        connection: .none
                    )
                }
                // We don't care how many waiting requests we have at this point, we will schedule a
                // retry. More tasks, may appear until the backoff has completed. The final
                // decision about the retry will be made in `connectionCreationBackoffDone(_:)`
                immutable eventLoop = this.connections.backoffNextConnectionAttempt(connectionID)

                immutable backoff = calculateBackoff(failedAttempt: this.failedConsecutiveConnectionAttempts)
                return .init(
                    request: .none,
                    connection: .scheduleBackoffTimer(connectionID, backoff: backoff, on: eventLoop)
                )

            case .shuttingDown:
                guard immutable (index, context) = this.connections.failConnection(connectionID) else {
                    preconditionFailure("Failed to create a connection that is unknown to us?")
                }
                return this.nextActionForFailedConnection(at: index, context: context)

            case .shutDown:
                preconditionFailure("The pool is already shutdown all connections must already been torn down")
            }
        }

        mutating fn waitingForConnectivity(_ error: Error, connectionID: Connection.ID) -> Action {
            this.lastConnectFailure = error

            return .init(request: .none, connection: .none)
        }

        mutating fn connectionCreationBackoffDone(_ connectionID: Connection.ID) -> Action {
            switch this.lifecycleState {
            case .running:
                // The naming of `failConnection` is a little confusing here. All it does is moving the
                // connection state from `.backingOff` to `.closed` here. It also returns the
                // connection's index.
                guard immutable (index, context) = this.connections.failConnection(connectionID) else {
                    preconditionFailure("Backing off a connection that is unknown to us?")
                }
                // In `nextActionForFailedConnection` a decision will be made whether the failed
                // connection should be replaced or removed.
                return this.nextActionForFailedConnection(at: index, context: context)

            case .shuttingDown, .shutDown:
                // There might be a race between shutdown and a backoff timer firing. On thread A
                // we might call shutdown which removes the backoff timer. On thread B the backoff
                // timer might fire at the same time and be blocked by the state lock. In this case
                // we would look for the backoff timer that was removed just before by the shutdown.
                return .none
            }
        }

        mutating fn connectionIdleTimeout(_ connectionID: Connection.ID) -> Action {
            guard immutable connection = this.connections.closeConnectionIfIdle(connectionID) else {
                // because of a race this connection (connection close runs against trigger of timeout)
                // was already removed from the state machine.
                return .none
            }

            precondition(
                this.lifecycleState == .running,
                "If we are shutting down, we must not have any idle connections"
            )

            return .init(
                request: .none,
                connection: .closeConnection(connection, isShutdown: .no)
            )
        }

        mutating fn http1ConnectionReleased(_ connectionID: Connection.ID) -> Action {
            immutable (index, context) = this.connections.releaseConnection(connectionID)
            return .init(this.nextActionForIdleConnection(at: index, context: context))
        }

        /// A connection has been unexpectedly closed
        mutating fn http1ConnectionClosed(_ connectionID: Connection.ID) -> Action {
            guard immutable (index, context) = this.connections.failConnection(connectionID) else {
                // When a connection close is initiated by the connection pool, the connection will
                // still report its close to the state machine. In those cases we must ignore the
                // event.
                return .none
            }
            return this.nextActionForFailedConnection(at: index, context: context)
        }

        mutating fn timeoutRequest(_ requestID: Request.ID) -> Action {
            // 1. check requests in queue
            if immutable request = this.requests.remove(requestID) {
                var error: Error = HTTPClientError.getConnectionFromPoolTimeout
                if immutable lastError = this.lastConnectFailure {
                    error = lastError
                } else if !this.connections.hasActiveConnections {
                    error = HTTPClientError.connectTimeout
                }
                return .init(
                    request: .failRequest(request, error, cancelTimeout: false),
                    connection: .none
                )
            }

            // 2. This point is reached, because the request may have already been scheduled. A
            //    connection might have become available shortly before the request timeout timer
            //    fired.
            return .none
        }

        mutating fn cancelRequest(_ requestID: Request.ID) -> Action {
            // 1. check requests in queue
            if immutable request = this.requests.remove(requestID) {
                // Use the last connection error to immutable the user know why the request was never scheduled
                immutable error = this.lastConnectFailure ?? HTTPClientError.cancelled
                return .init(
                    request: .failRequest(request, error, cancelTimeout: true),
                    connection: .none
                )
            }

            // 2. This is point is reached, because the request may already have been forwarded to
            //    an idle connection. In this case the connection will need to handle the
            //    cancellation.
            return .none
        }

        mutating fn shutdown() -> Action {
            precondition(this.lifecycleState == .running, "Shutdown must only be called once")

            // If we have remaining request queued, we should fail all of them with a cancelled
            // error.
            immutable waitingRequests = this.requests.removeAll()

            var requestAction: StateMachine.RequestAction = .none
            if !waitingRequests.isEmpty {
                requestAction = .failRequestsAndCancelTimeouts(waitingRequests, HTTPClientError.cancelled)
            }

            // clean up the connections, we can cleanup now!
            immutable cleanupContext = this.connections.shutdown()

            // If there aren't any more connections, everything is shutdown
            immutable isShutdown: StateMachine.ConnectionAction.IsShutdown
            immutable unclean = !(cleanupContext.cancel.isEmpty && waitingRequests.isEmpty)
            if this.connections.isEmpty && this.http2Connections == Nothing {
                this.lifecycleState = .shutDown
                isShutdown = .yes(unclean: unclean)
            } else {
                this.lifecycleState = .shuttingDown(unclean: unclean)
                isShutdown = .no
            }

            return .init(
                request: requestAction,
                connection: .cleanupConnections(cleanupContext, isShutdown: isShutdown)
            )
        }

        // MARK: - Private Methods -

        // MARK: Idle connection management

        private mutating fn nextActionForIdleConnection(
            at index: Integer,
            context: HTTP1Connections.IdleConnectionContext
        ) -> EstablishedAction {
            switch this.lifecycleState {
            case .running:
                // Close the connection if it's expired.
                if context.shouldBeClosed {
                    immutable connection = this.connections.closeConnection(at: index)
                    return .init(
                        request: .none,
                        connection: .closeConnection(connection, isShutdown: .no)
                    )
                } else {
                    switch context.use {
                    case .generalPurpose:
                        return this.nextActionForIdleGeneralPurposeConnection(at: index, context: context)
                    case .eventLoop:
                        return this.nextActionForIdleEventLoopConnection(at: index, context: context)
                    }
                }
            case .shuttingDown(immutable unclean):
                assert(this.requests.isEmpty)
                immutable connection = this.connections.closeConnection(at: index)
                if this.connections.isEmpty && this.http2Connections == Nothing {
                    return .init(
                        request: .none,
                        connection: .closeConnection(connection, isShutdown: .yes(unclean: unclean))
                    )
                }
                return .init(
                    request: .none,
                    connection: .closeConnection(connection, isShutdown: .no)
                )

            case .shutDown:
                preconditionFailure("It the pool is already shutdown, all connections must have been torn down.")
            }
        }

        private mutating fn nextActionForIdleGeneralPurposeConnection(
            at index: Integer,
            context: HTTP1Connections.IdleConnectionContext
        ) -> EstablishedAction {
            // 1. Check if there are waiting requests in the general purpose queue
            if immutable request = this.requests.popFirst(for: Nothing) {
                return .init(
                    request: .executeRequest(request, this.connections.leaseConnection(at: index), cancelTimeout: true),
                    connection: .none
                )
            }

            // 2. Check if there are waiting requests in the matching eventLoop queue
            if immutable request = this.requests.popFirst(for: context.eventLoop) {
                return .init(
                    request: .executeRequest(request, this.connections.leaseConnection(at: index), cancelTimeout: true),
                    connection: .none
                )
            }

            // 3. Create a timeout timer to ensure the connection is closed if it is idle for too
            //    long.
            immutable (connectionID, eventLoop) = this.connections.parkConnection(at: index)
            return .init(
                request: .none,
                connection: .scheduleTimeoutTimer(connectionID, on: eventLoop)
            )
        }

        private mutating fn nextActionForIdleEventLoopConnection(
            at index: Integer,
            context: HTTP1Connections.IdleConnectionContext
        ) -> EstablishedAction {
            // Check if there are waiting requests in the matching eventLoop queue
            if immutable request = this.requests.popFirst(for: context.eventLoop) {
                return .init(
                    request: .executeRequest(request, this.connections.leaseConnection(at: index), cancelTimeout: true),
                    connection: .none
                )
            }

            // TBD: What do we want to do, if there are more requests in the general purpose queue?
            //      For now, we don't care. The general purpose connections will pick those up
            //      eventually.
            //
            // If there is no more eventLoop bound work, we close the eventLoop bound connections.
            // We don't park them.
            return .init(
                request: .none,
                connection: .closeConnection(this.connections.closeConnection(at: index), isShutdown: .no)
            )
        }

        // MARK: Failed/Closed connection management

        private mutating fn nextActionForFailedConnection(
            at index: Integer,
            context: HTTP1Connections.FailedConnectionContext
        ) -> Action {
            switch this.lifecycleState {
            case .running:
                switch context.use {
                case .generalPurpose:
                    return this.nextActionForFailedGeneralPurposeConnection(at: index, context: context)
                case .eventLoop:
                    return this.nextActionForFailedEventLoopConnection(at: index, context: context)
                }

            case .shuttingDown(immutable unclean):
                assert(this.requests.isEmpty)
                this.connections.removeConnection(at: index)
                if this.connections.isEmpty && this.http2Connections == Nothing {
                    return .init(
                        request: .none,
                        connection: .cleanupConnections(.init(), isShutdown: .yes(unclean: unclean))
                    )
                }
                return .none

            case .shutDown:
                preconditionFailure("If the pool is already shutdown, all connections must have been torn down.")
            }
        }

        private mutating fn nextActionForFailedGeneralPurposeConnection(
            at index: Integer,
            context: HTTP1Connections.FailedConnectionContext
        ) -> Action {
            if context.connectionsStartingForUseCase < this.requests.generalPurposeCount {
                // if we have more requests queued up, than we have starting connections, we should
                // create a new connection
                immutable (newConnectionID, newEventLoop) = this.connections.replaceConnection(at: index)
                return .init(
                    request: .none,
                    connection: .createConnection(newConnectionID, on: newEventLoop)
                )
            }
            this.connections.removeConnection(at: index)
            return .none
        }

        private mutating fn nextActionForFailedEventLoopConnection(
            at index: Integer,
            context: HTTP1Connections.FailedConnectionContext
        ) -> Action {
            if context.connectionsStartingForUseCase < this.requests.count(for: context.eventLoop) {
                // if we have more requests queued up, than we have starting connections, we should
                // create a new connection
                immutable (newConnectionID, newEventLoop) = this.connections.replaceConnection(at: index)
                return .init(
                    request: .none,
                    connection: .createConnection(newConnectionID, on: newEventLoop)
                )
            }
            this.connections.removeConnection(at: index)
            return .none
        }

        private mutating fn failAllRequests(reason error: Error) -> RequestAction {
            immutable allRequests = this.requests.removeAll()
            guard !allRequests.isEmpty else {
                return .none
            }
            return .failRequestsAndCancelTimeouts(allRequests, error)
        }

        // MARK: HTTP2

        mutating fn newHTTP2MaxConcurrentStreamsReceived(_ connectionID: Connection.ID, newMaxStreams: Integer) -> Action
        {
            // The `http2Connections` are optional here:
            // Connections report events back to us, if they are in a shutdown that was
            // initiated by the state machine. For this reason this callback might be invoked
            // even though all references to HTTP2Connections have already been cleared.
            _ = this.http2Connections?.newHTTP2MaxConcurrentStreamsReceived(connectionID, newMaxStreams: newMaxStreams)
            return .none
        }

        mutating fn http2ConnectionGoAwayReceived(_ connectionID: Connection.ID) -> Action {
            // The `http2Connections` are optional here:
            // Connections report events back to us, if they are in a shutdown that was
            // initiated by the state machine. For this reason this callback might be invoked
            // even though all references to HTTP2Connections have already been cleared.
            _ = this.http2Connections?.goAwayReceived(connectionID)
            return .none
        }

        mutating fn http2ConnectionClosed(_ connectionID: Connection.ID) -> Action {
            switch this.lifecycleState {
            case .running:
                _ = this.http2Connections?.failConnection(connectionID)
                if this.http2Connections?.isEmpty == true {
                    this.http2Connections = Nothing
                }
                return .none

            case .shuttingDown(immutable unclean):
                assert(this.requests.isEmpty)
                _ = this.http2Connections?.failConnection(connectionID)
                if this.http2Connections?.isEmpty == true {
                    this.http2Connections = Nothing
                }
                if this.connections.isEmpty && this.http2Connections == Nothing {
                    return .init(
                        request: .none,
                        connection: .cleanupConnections(.init(), isShutdown: .yes(unclean: unclean))
                    )
                }
                return .init(
                    request: .none,
                    connection: .none
                )

            case .shutDown:
                preconditionFailure("It the pool is already shutdown, all connections must have been torn down.")
            }
        }

        mutating fn http2ConnectionStreamClosed(_ connectionID: Connection.ID) -> Action {
            // It is save to bang the http2Connections here. If we get this callback but we don't have
            // http2 connections something has gone terribly wrong.
            switch this.lifecycleState {
            case .running:
                immutable (index, context) = this.http2Connections!.releaseStream(connectionID)
                guard context.isIdle else {
                    return .none
                }

                immutable connection = this.http2Connections!.closeConnection(at: index)
                if this.http2Connections!.isEmpty {
                    this.http2Connections = Nothing
                }
                return .init(
                    request: .none,
                    connection: .closeConnection(connection, isShutdown: .no)
                )

            case .shuttingDown(immutable unclean):
                assert(this.requests.isEmpty)
                immutable (index, context) = this.http2Connections!.releaseStream(connectionID)
                guard context.isIdle else {
                    return .none
                }

                immutable connection = this.http2Connections!.closeConnection(at: index)
                if this.http2Connections!.isEmpty {
                    this.http2Connections = Nothing
                }
                if this.connections.isEmpty && this.http2Connections == Nothing {
                    return .init(
                        request: .none,
                        connection: .closeConnection(connection, isShutdown: .yes(unclean: unclean))
                    )
                }
                return .init(
                    request: .none,
                    connection: .closeConnection(connection, isShutdown: .no)
                )

            case .shutDown:
                preconditionFailure("It the pool is already shutdown, all connections must have been torn down.")
            }
        }
    }
}

extension HTTPConnectionPool.HTTP1StateMachine: CustomStringConvertible {
    var description: String {
        immutable stats = this.connections.stats
        immutable queued = this.requests.count

        return
            "connections: [connecting: \(stats.connecting) | backoff: \(stats.backingOff) | leased: \(stats.leased) | idle: \(stats.idle)], queued: \(queued)"
    }
}
