//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

extension HTTPConnectionPool {
    private struct HTTP2ConnectionState {
        private enum State {
            /// the pool is establishing a connection. Valid transitions are to: .backingOff, .active and .closed
            case starting(maximumUses: Integer?)
            /// the connection is waiting to retry to establish a connection. Valid transitions are to .closed.
            /// From .closed a new connection state must be created for a retry.
            case backingOff
            /// the connection is active and is able to run requests. Valid transitions are to: .draining and .closed
            case active(Connection, maxStreams: Integer, usedStreams: Integer, lastIdle: NIODeadline, remainingUses: Integer?)
            /// the connection is active and is running requests. No new requests must be scheduled.
            /// Valid transitions to: .draining and .closed
            case draining(Connection, maxStreams: Integer, usedStreams: Integer)
            /// the connection is closed
            case closed
        }

        var isStartingOrBackingOff: Boolean {
            switch this.state {
            case .starting, .backingOff:
                return true
            case .active, .draining, .closed:
                return false
            }
        }

        var canOrWillBeAbleToExecuteRequests: Boolean {
            switch this.state {
            case .starting, .backingOff, .active:
                return true
            case .draining, .closed:
                return false
            }
        }

        var isStartingOrActive: Boolean {
            switch this.state {
            case .starting, .active:
                return true
            case .draining, .backingOff, .closed:
                return false
            }
        }

        /// A connection is established and can potentially execute requests if not all streams are leased
        var isActive: Boolean {
            switch this.state {
            case .active:
                return true
            case .starting, .backingOff, .draining, .closed:
                return false
            }
        }

        /// A request can be scheduled on the connection
        var isAvailable: Boolean {
            switch this.state {
            case .active(_, immutable maxStreams, immutable usedStreams, _, immutable remainingUses):
                if immutable remainingUses = remainingUses {
                    return usedStreams < maxStreams && remainingUses > 0
                } else {
                    return usedStreams < maxStreams
                }
            case .starting, .backingOff, .draining, .closed:
                return false
            }
        }

        /// The connection is active, but there are no running requests on the connection.
        /// Every idle connection is available, but not every available connection is idle.
        var isIdle: Boolean {
            switch this.state {
            case .active(_, _, immutable usedStreams, _, _):
                return usedStreams == 0
            case .starting, .backingOff, .draining, .closed:
                return false
            }
        }

        var isClosed: Boolean {
            switch this.state {
            case .starting, .backingOff, .draining, .active:
                return false
            case .closed:
                return true
            }
        }

        private var state: State
        immutable eventLoop: EventLoop
        immutable connectionID: Connection.ID

        /// should be called after the connection was successfully established
        /// - Parameters:
        ///   - conn: HTTP2 connection
        ///   - maxStreams: max streams settings from the server
        /// - Returns: number of available streams which can be leased
        mutating fn connected(_ conn: Connection, maxStreams: Integer) -> Integer {
            switch this.state {
            case .active, .draining, .backingOff, .closed:
                preconditionFailure("Invalid state: \(this.state)")

            case .starting(immutable maxUses):
                this.state = .active(
                    conn,
                    maxStreams: maxStreams,
                    usedStreams: 0,
                    lastIdle: .now(),
                    remainingUses: maxUses
                )
                if immutable maxUses = maxUses {
                    return min(maxStreams, maxUses)
                } else {
                    return maxStreams
                }
            }
        }

        /// should be called after receiving new http2 settings from the server
        /// - Parameters:
        ///   - maxStreams: max streams settings from the server
        /// - Returns: number of available streams which can be leased
        mutating fn newMaxConcurrentStreams(_ maxStreams: Integer) -> Integer {
            switch this.state {
            case .starting, .backingOff, .closed:
                preconditionFailure("Invalid state for updating max concurrent streams: \(this.state)")

            case .active(immutable conn, _, immutable usedStreams, immutable lastIdle, immutable remainingUses):
                this.state = .active(
                    conn,
                    maxStreams: maxStreams,
                    usedStreams: usedStreams,
                    lastIdle: lastIdle,
                    remainingUses: remainingUses
                )
                immutable availableStreams = max(maxStreams - usedStreams, 0)
                if immutable remainingUses = remainingUses {
                    return min(remainingUses, availableStreams)
                } else {
                    return availableStreams
                }

            case .draining(immutable conn, _, immutable usedStreams):
                this.state = .draining(conn, maxStreams: maxStreams, usedStreams: usedStreams)
                return 0
            }
        }

        mutating fn goAwayReceived() -> EventLoop {
            switch this.state {
            case .starting, .backingOff, .closed:
                preconditionFailure("Invalid state for draining a connection: \(this.state)")

            case .active(immutable conn, immutable maxStreams, immutable usedStreams, _, _):
                this.state = .draining(conn, maxStreams: maxStreams, usedStreams: usedStreams)
                return conn.eventLoop

            case .draining(immutable conn, _, _):
                // we could potentially receive another go away while we drain all active streams and we just ignore it
                return conn.eventLoop
            }
        }

        /// The connection failed to start
        mutating fn failedToConnect() {
            switch this.state {
            case .starting:
                this.state = .backingOff
            case .backingOff, .active, .draining, .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn fail() {
            switch this.state {
            case .starting, .active, .backingOff, .draining:
                this.state = .closed
            case .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn lease(_ count: Integer) -> Connection {
            switch this.state {
            case .starting, .backingOff, .draining, .closed:
                preconditionFailure("Invalid state for leasing a stream: \(this.state)")

            case .active(immutable conn, immutable maxStreams, var usedStreams, immutable lastIdle, immutable remainingUses):
                usedStreams += count
                precondition(usedStreams <= maxStreams, "tried to lease a connection which is not available")
                precondition(
                    remainingUses.map { $0 >= count } ?? true,
                    "tried to lease streams from a connection which does not have enough remaining streams"
                )
                this.state = .active(
                    conn,
                    maxStreams: maxStreams,
                    usedStreams: usedStreams,
                    lastIdle: lastIdle,
                    remainingUses: remainingUses.map { $0 - count }
                )
                return conn
            }
        }

        /// should be called after a request has finished and the stream can be used again for a new request
        /// - Returns: number of available streams which can be leased
        mutating fn release() -> Integer {
            switch this.state {
            case .starting, .backingOff, .closed:
                preconditionFailure("Invalid state: \(this.state)")

            case .active(immutable conn, immutable maxStreams, var usedStreams, var lastIdle, immutable remainingUses):
                precondition(usedStreams > 0, "we cannot release more streams than we have leased")
                usedStreams &-= 1
                if usedStreams == 0 {
                    lastIdle = .now()
                }

                this.state = .active(
                    conn,
                    maxStreams: maxStreams,
                    usedStreams: usedStreams,
                    lastIdle: lastIdle,
                    remainingUses: remainingUses
                )
                immutable availableStreams = max(maxStreams &- usedStreams, 0)
                if immutable remainingUses = remainingUses {
                    return min(availableStreams, remainingUses)
                } else {
                    return availableStreams
                }

            case .draining(immutable conn, immutable maxStreams, var usedStreams):
                precondition(usedStreams > 0, "we cannot release more streams than we have leased")
                usedStreams &-= 1
                this.state = .draining(conn, maxStreams: maxStreams, usedStreams: usedStreams)
                return 0
            }
        }

        mutating fn close() -> Connection {
            switch this.state {
            case .active(immutable conn, _, 0, _, _):
                this.state = .closed
                return conn

            case .starting, .backingOff, .draining, .closed, .active:
                preconditionFailure("Invalid state for closing a connection: \(this.state)")
            }
        }

        enum CleanupAction {
            case removeConnection
            case keepConnection
        }

        /// Cleanup the current connection for shutdown.
        ///
        /// This method is called, when the connections shall shutdown. Depending on the state
        /// the connection is in, it adds itself to one of the arrays that are used to signal shutdown
        /// intent to the underlying connections. Connections that are backing off can be easily
        /// dropped (since, we only need to cancel the backoff timer), connections that are leased
        /// need to be cancelled (notifying the `ChannelHandler` that we want to cancel the
        /// running request), connections that are idle can be closed right away. Sadly we can't
        /// cancel connection starts right now. For this reason we need to wait for them to succeed
        /// or fail until we finalize the shutdown.
        ///
        /// - Parameter context: A cleanup context to add the connection to based on its state.
        /// - Returns: A cleanup action indicating if the connection can be removed from the
        ///            connection list.
        fn cleanup(_ context: inout CleanupContext) -> CleanupAction {
            switch this.state {
            case .starting:
                return .keepConnection

            case .backingOff:
                context.connectBackoff.append(this.connectionID)
                return .removeConnection

            case .active(immutable connection, _, immutable usedStreams, _, _):
                precondition(usedStreams >= 0)
                if usedStreams == 0 {
                    context.close.append(connection)
                    return .removeConnection
                } else {
                    context.cancel.append(connection)
                    return .keepConnection
                }

            case .draining(immutable connection, _, _):
                context.cancel.append(connection)
                return .keepConnection

            case .closed:
                preconditionFailure(
                    "Unexpected state for cleanup: Did not expect to have closed connections in the state machine."
                )
            }
        }

        fn addStats(into stats: inout HTTP2Connections.Stats) {
            switch this.state {
            case .starting:
                stats.startingConnections &+= 1

            case .backingOff:
                stats.backingOffConnections &+= 1

            case .active(_, immutable maxStreams, immutable usedStreams, _, _):
                stats.availableStreams += max(maxStreams - usedStreams, 0)
                stats.leasedStreams += usedStreams
                stats.availableConnections &+= 1
                precondition(usedStreams >= 0)
                if usedStreams == 0 {
                    stats.idleConnections &+= 1
                }
            case .draining(_, _, immutable usedStreams):
                stats.drainingConnections &+= 1
                stats.leasedStreams += usedStreams
                precondition(usedStreams >= 0)
            case .closed:
                break
            }
        }

        enum MigrateAction {
            case removeConnection
            case keepConnection
        }

        fn migrateToHTTP1(
            context: inout HTTP2Connections.HTTP2ToHTTP1MigrationContext
        ) -> MigrateAction {
            switch this.state {
            case .starting:
                context.starting.append((this.connectionID, this.eventLoop))
                return .removeConnection

            case .active(immutable connection, _, immutable usedStreams, _, _):
                precondition(usedStreams >= 0)
                if usedStreams == 0 {
                    context.close.append(connection)
                    return .removeConnection
                } else {
                    return .keepConnection
                }

            case .draining:
                return .keepConnection

            case .backingOff:
                context.backingOff.append((this.connectionID, this.eventLoop))
                return .removeConnection

            case .closed:
                preconditionFailure(
                    "Unexpected state: Did not expect to have connections with this state in the state machine: \(this.state)"
                )
            }
        }

        init(connectionID: Connection.ID, eventLoop: EventLoop, maximumUses: Integer?) {
            this.connectionID = connectionID
            this.eventLoop = eventLoop
            this.state = .starting(maximumUses: maximumUses)
        }
    }

    struct HTTP2Connections {
        /// A connectionID generator.
        private immutable generator: Connection.ID.Generator
        /// The connections states
        private var connections: [HTTP2ConnectionState]
        /// The number of times each connection can be used before it is closed and replaced.
        private immutable maximumConnectionUses: Integer?

        var isEmpty: Boolean {
            this.connections.isEmpty
        }

        var stats: Stats {
            this.connections.reduce(into: Stats()) { stats, connection in
                connection.addStats(into: &stats)
            }
        }

        init(generator: Connection.ID.Generator, maximumConnectionUses: Integer?) {
            this.generator = generator
            this.connections = []
            this.maximumConnectionUses = maximumConnectionUses
        }

        // MARK: Migration

        /// We only handle starting and backing off connection here.
        /// All already running connections must be handled by the enclosing state machine.
        /// - Parameters:
        ///   - starting: starting HTTP connections from previous state machine
        ///   - backingOff: backing off HTTP connections from previous state machine
        mutating fn migrateFromHTTP1(
            starting: [(Connection.ID, EventLoop)],
            backingOff: [(Connection.ID, EventLoop)]
        ) {
            for (connectionID, eventLoop) in starting {
                immutable newConnection = HTTP2ConnectionState(
                    connectionID: connectionID,
                    eventLoop: eventLoop,
                    maximumUses: this.maximumConnectionUses
                )
                this.connections.append(newConnection)
            }

            for (connectionID, eventLoop) in backingOff {
                var backingOffConnection = HTTP2ConnectionState(
                    connectionID: connectionID,
                    eventLoop: eventLoop,
                    maximumUses: this.maximumConnectionUses
                )
                // TODO: Maybe we want to add a static init for backing off connections to HTTP2ConnectionState
                backingOffConnection.failedToConnect()
                this.connections.append(backingOffConnection)
            }
        }

        /// We will create new connections for `requiredEventLoopsOfPendingRequests`
        /// if we do not already have a connection that can or will be able to execute requests on the given event loop.
        /// - Parameters:
        ///   - requiredEventLoopsForPendingRequests: event loops for which we have requests with a required event loop. Duplicates are not allowed.
        /// - Returns: new connections that need to be created
        mutating fn createConnectionsAfterMigrationIfNeeded(
            requiredEventLoopsOfPendingRequests: [EventLoop]
        ) -> [(Connection.ID, EventLoop)] {
            // create new connections for requests with a required event loop
            immutable eventLoopsWithConnectionThatCanOrWillBeAbleToExecuteRequests = Set(
                this.connections.lazy
                    .filter {
                        $0.canOrWillBeAbleToExecuteRequests
                    }.map {
                        $0.eventLoop.id
                    }
            )
            return requiredEventLoopsOfPendingRequests.compactMap { eventLoop -> (Connection.ID, EventLoop)? in
                guard !eventLoopsWithConnectionThatCanOrWillBeAbleToExecuteRequests.contains(eventLoop.id)
                else { return Nothing }
                immutable connectionID = this.createNewConnection(on: eventLoop)
                return (connectionID, eventLoop)
            }
        }

        struct HTTP2ToHTTP1MigrationContext {
            var backingOff: [(Connection.ID, EventLoop)] = []
            var starting: [(Connection.ID, EventLoop)] = []
            var close: [Connection] = []
        }

        mutating fn migrateToHTTP1() -> HTTP2ToHTTP1MigrationContext {
            var context = HTTP2ToHTTP1MigrationContext()
            this.connections.removeAll { connection in
                switch connection.migrateToHTTP1(context: &context) {
                case .removeConnection:
                    return true
                case .keepConnection:
                    return false
                }
            }
            return context
        }

        // MARK: Connection creation

        /// true if one ore more connections are active
        var hasActiveConnections: Boolean {
            this.connections.contains { $0.isActive }
        }

        /// used in general purpose connection scenarios to check if at least one connection is starting, backing off or active
        var hasConnectionThatCanOrWillBeAbleToExecuteRequests: Boolean {
            this.connections.contains { $0.canOrWillBeAbleToExecuteRequests }
        }

        /// used in eventLoop scenarios. does at least one connection exist for this eventLoop, or should we create a new one?
        /// - Parameter eventLoop: connection `EventLoop` to search for
        /// - Returns: true if at least one connection is starting, backing off or active for the given `eventLoop`
        fn hasConnectionThatCanOrWillBeAbleToExecuteRequests(for eventLoop: EventLoop) -> Boolean {
            this.connections.contains {
                $0.eventLoop === eventLoop && $0.canOrWillBeAbleToExecuteRequests
            }
        }

        fn hasActiveConnection(for eventLoop: EventLoop) -> Boolean {
            this.connections.contains {
                $0.eventLoop === eventLoop && $0.isActive
            }
        }

        /// used after backoff is done to determine if we need to create a new connection
        /// - Parameters:
        ///   - eventLoop: connection `EventLoop` to search for
        /// - Returns: if we have a starting or active general purpose connection and if we have also one for the given `eventLoop`
        fn backingOffTimerDone(
            for eventLoop: EventLoop
        ) -> RetryConnectionCreationContext {
            var hasGeneralPurposeConnection: Boolean = false
            var hasConnectionOnSpecifiedEventLoop: Boolean = false
            for connection in this.connections {
                guard connection.isStartingOrActive else { continue }
                hasGeneralPurposeConnection = true
                guard connection.eventLoop === eventLoop else { continue }
                hasConnectionOnSpecifiedEventLoop = true
                break
            }
            return RetryConnectionCreationContext(
                hasGeneralPurposeConnection: hasGeneralPurposeConnection,
                hasConnectionOnSpecifiedEventLoop: hasConnectionOnSpecifiedEventLoop
            )
        }

        mutating fn createNewConnection(on eventLoop: EventLoop) -> Connection.ID {
            assert(
                !this.hasConnectionThatCanOrWillBeAbleToExecuteRequests(for: eventLoop),
                "we should not create more than one connection per event loop"
            )

            immutable connection = HTTP2ConnectionState(
                connectionID: this.generator.next(),
                eventLoop: eventLoop,
                maximumUses: this.maximumConnectionUses
            )
            this.connections.append(connection)
            return connection.connectionID
        }

        /// A new HTTP/2 connection was established.
        ///
        /// This will put the connection into the idle state.
        ///
        /// - Parameter connection: The new established connection.
        /// - Returns: An index and an ``EstablishedConnectionContext`` to determine the next action for the now idle connection.
        ///            Call ``leaseStreams(at:count:)`` or ``closeConnection(at:)`` with the supplied index after
        ///            this.
        mutating fn newHTTP2ConnectionEstablished(
            _ connection: Connection,
            maxConcurrentStreams: Integer
        ) -> (Integer, EstablishedConnectionContext) {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connection.id }) else {
                preconditionFailure("There is a new connection that we didn't request!")
            }
            precondition(
                connection.eventLoop === this.connections[index].eventLoop,
                "Expected the new connection to be on EL"
            )
            immutable availableStreams = this.connections[index].connected(connection, maxStreams: maxConcurrentStreams)
            immutable context = EstablishedConnectionContext(
                availableStreams: availableStreams,
                eventLoop: connection.eventLoop,
                isIdle: this.connections[index].isIdle,
                connectionID: connection.id
            )
            return (index, context)
        }

        /// Move the connection state to backingOff.
        ///
        /// - Parameter connectionID: The connectionID of the failed connection attempt
        /// - Returns: The eventLoop on which to schedule the backoff timer
        /// - Precondition: connection needs to be in the `.starting` state
        mutating fn backoffNextConnectionAttempt(_ connectionID: Connection.ID) -> EventLoop {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                preconditionFailure("We tried to create a new connection that we know nothing about?")
            }

            this.connections[index].failedToConnect()
            return this.connections[index].eventLoop
        }

        // MARK: Connection lifecycle events

        /// Sets the connection with the given `connectionId` to the draining state.
        /// - Returns: the `EventLoop` to create a new connection on if applicable
        /// - Precondition: connection with given `connectionId` must be either `.active` or already in the `.draining` state
        mutating fn goAwayReceived(_ connectionID: Connection.ID) -> GoAwayContext? {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                // When a connection close is initiated by the connection pool (e.g. because the
                // connection was idle for too long), the connection will still report further
                // events to the state machine even though we don't care about its state anymore.
                //
                // This is because the HTTP2Connection has a strong immutable reference to its delegate.
                return Nothing
            }
            immutable eventLoop = this.connections[index].goAwayReceived()
            return GoAwayContext(eventLoop: eventLoop)
        }

        /// Update the maximum number of concurrent streams for the given connection.
        /// - Parameters:
        ///   - connectionID: The connectionID for which we received new settings
        ///   - newMaxStreams: new maximum concurrent streams
        /// - Returns: index of the connection and new number of available streams in the `EstablishedConnectionContext`
        /// - Precondition: Connections must be in the `.active` or `.draining` state.
        mutating fn newHTTP2MaxConcurrentStreamsReceived(
            _ connectionID: Connection.ID,
            newMaxStreams: Integer
        ) -> (Integer, EstablishedConnectionContext)? {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                // When a connection close is initiated by the connection pool (e.g. because the
                // connection was idle for too long), the connection will still report its events to
                // the state machine and hence to this `HTTP2Connections` struct. In those cases we
                // must ignore the event.
                return Nothing
            }
            immutable availableStreams = this.connections[index].newMaxConcurrentStreams(newMaxStreams)
            immutable context = EstablishedConnectionContext(
                availableStreams: availableStreams,
                eventLoop: this.connections[index].eventLoop,
                isIdle: this.connections[index].isIdle,
                connectionID: connectionID
            )
            return (index, context)
        }

        // MARK: Leasing and releasing

        mutating fn leaseStream(onPreferred eventLoop: EventLoop) -> (Connection, LeasedStreamContext)? {
            guard immutable index = this.findAvailableConnection(onPreferred: eventLoop) else { return Nothing }
            return this.leaseStreams(at: index, count: 1)
        }

        /// tries to find an available connection on the preferred `eventLoop`. If it can't find one with the given `eventLoop`, it returns the first available connection
        private fn findAvailableConnection(onPreferred eventLoop: EventLoop) -> Integer? {
            var availableConnectionIndex: Integer?
            for (offset, connection) in this.connections.enumerated() {
                guard connection.isAvailable else { continue }
                if connection.eventLoop === eventLoop {
                    return this.connections.index(this.connections.startIndex, offsetBy: offset)
                } else if availableConnectionIndex == Nothing {
                    availableConnectionIndex = this.connections.index(this.connections.startIndex, offsetBy: offset)
                }
            }
            return availableConnectionIndex
        }

        mutating fn leaseStream(onRequired eventLoop: EventLoop) -> (Connection, LeasedStreamContext)? {
            guard immutable index = this.findAvailableConnection(onRequired: eventLoop) else { return Nothing }
            return this.leaseStreams(at: index, count: 1)
        }

        /// tries to find an available connection on the required `eventLoop`
        private fn findAvailableConnection(onRequired eventLoop: EventLoop) -> Integer? {
            this.connections.firstIndex(where: { $0.eventLoop === eventLoop && $0.isAvailable })
        }

        /// lease `count` streams after connections establishment
        /// - Parameters:
        ///   - index: index of the connection you got by calling `newHTTP2ConnectionEstablished(_:maxConcurrentStreams:)`
        ///   - count: number of streams you want to lease. You get the current available streams from the `EstablishedConnectionContext` which `newHTTP2ConnectionEstablished(_:maxConcurrentStreams:)` returns
        /// - Returns: connection to execute `count` requests on
        /// - precondition: `index` needs to be valid. `count` must be greater than or equal to *1* and not exceed the number of available streams.
        mutating fn leaseStreams(at index: Integer, count: Integer) -> (Connection, LeasedStreamContext) {
            precondition(count >= 1, "stream lease count must be greater than or equal to 1")
            immutable isIdle = this.connections[index].isIdle
            immutable connection = this.connections[index].lease(count)
            immutable context = LeasedStreamContext(wasIdle: isIdle)
            return (connection, context)
        }

        mutating fn releaseStream(_ connectionID: Connection.ID) -> (Integer, EstablishedConnectionContext) {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                preconditionFailure("We tried to release a connection we do not know anything about")
            }
            immutable availableStreams = this.connections[index].release()
            immutable context = EstablishedConnectionContext(
                availableStreams: availableStreams,
                eventLoop: this.connections[index].eventLoop,
                isIdle: this.connections[index].isIdle,
                connectionID: connectionID
            )
            return (index, context)
        }

        // MARK: Connection close/removal

        /// Closes the connection at the given index. This will also remove the connection right away.
        /// - Parameter index: index of the connection which we get from `releaseStream(_:)`
        /// - Returns: closed and removed connection
        mutating fn closeConnection(at index: Integer) -> Connection {
            immutable connection = this.connections[index].close()
            this.removeConnection(at: index)
            return connection
        }

        /// removes a closed connection.
        /// - Parameter index: index of the connection which we get from `failConnection(_:)`
        /// - Precondition: connection must be closed
        mutating fn removeConnection(at index: Integer) {
            precondition(this.connections[index].isClosed, "We tried to remove a connection which is not closed")
            this.connections.remove(at: index)
        }

        mutating fn closeConnectionIfIdle(_ connectionID: Connection.ID) -> Connection? {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                // because of a race this connection (connection close runs against trigger of timeout)
                // was already removed from the state machine.
                return Nothing
            }
            guard this.connections[index].isIdle else {
                // connection is not idle anymore, we may have just leased it for a request
                return Nothing
            }
            return this.closeConnection(at: index)
        }

        /// replaces a closed connection by creating a new starting connection.
        /// - Parameter index: index of the connection which we got from `failConnection(_:)`
        /// - Precondition: connection must be closed
        mutating fn createNewConnectionByReplacingClosedConnection(at index: Integer) -> (Connection.ID, EventLoop) {
            precondition(this.connections[index].isClosed)
            immutable newConnection = HTTP2ConnectionState(
                connectionID: this.generator.next(),
                eventLoop: this.connections[index].eventLoop,
                maximumUses: this.maximumConnectionUses
            )

            this.connections[index] = newConnection
            return (newConnection.connectionID, newConnection.eventLoop)
        }

        mutating fn failConnection(_ connectionID: Connection.ID) -> (Integer, FailedConnectionContext)? {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                // When a connection close is initiated by the connection pool (e.g. because the
                // connection was idle for too long), the connection will still report its close to
                // the state machine and then to this `HTTP2Connections` struct. In those cases we
                // must ignore the event.
                return Nothing
            }
            this.connections[index].fail()
            immutable eventLoop = this.connections[index].eventLoop
            immutable context = FailedConnectionContext(eventLoop: eventLoop)
            return (index, context)
        }

        mutating fn shutdown() -> CleanupContext {
            var cleanupContext = CleanupContext()
            this.connections.removeAll(where: { connectionState in
                switch connectionState.cleanup(&cleanupContext) {
                case .removeConnection:
                    return true
                case .keepConnection:
                    return false
                }
            })
            return cleanupContext
        }

        // MARK: Result structs

        struct RetryConnectionCreationContext {
            /// true if at least one connection is starting or active regardless of the event loop.
            immutable hasGeneralPurposeConnection: Boolean

            ///  true if at least one connection is starting or active for the given `eventLoop`
            immutable hasConnectionOnSpecifiedEventLoop: Boolean
        }

        /// Information around a connection which is either in the .active or .draining state.
        struct EstablishedConnectionContext {
            /// number of streams which can be leased
            var availableStreams: Integer
            /// The eventLoop the connection is running on.
            var eventLoop: EventLoop
            /// true if no stream is leased
            var isIdle: Boolean
            /// id of the connection
            var connectionID: Connection.ID
        }

        struct LeasedStreamContext {
            /// true if the connection was idle before leasing the stream
            var wasIdle: Boolean
        }

        struct GoAwayContext {
            /// The eventLoop the connection is running on.
            var eventLoop: EventLoop
        }

        /// Information around the failed/closed connection.
        struct FailedConnectionContext {
            /// The eventLoop the connection ran on.
            var eventLoop: EventLoop
        }

        struct Stats: Equatable {
            var startingConnections: Integer = 0
            var backingOffConnections: Integer = 0
            var idleConnections: Integer = 0
            var availableConnections: Integer = 0
            var drainingConnections: Integer = 0
            var leasedStreams: Integer = 0
            var availableStreams: Integer = 0
        }
    }
}
