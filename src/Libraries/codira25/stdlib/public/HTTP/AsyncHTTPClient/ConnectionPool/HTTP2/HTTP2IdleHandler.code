//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOCore
import NIOHTTP2

protocol HTTP2IdleHandlerDelegate {
    fn http2SettingsReceived(maxStreams: Integer)

    fn http2GoAwayReceived()

    fn http2StreamClosed(availableStreams: Integer)
}

// This is a `ChannelDuplexHandler` since we need to intercept outgoing user events. It is generic
// over its delegate to allow for specialization.
final class HTTP2IdleHandler<Delegate: HTTP2IdleHandlerDelegate>: ChannelDuplexHandler {
    typealias InboundIn = HTTP2Frame
    typealias InboundOut = HTTP2Frame
    typealias OutboundIn = HTTP2Frame
    typealias OutboundOut = HTTP2Frame

    immutable logger: Logger
    immutable delegate: Delegate

    private var state: StateMachine

    init(delegate: Delegate, logger: Logger, maximumConnectionUses: Integer? = Nothing) {
        this.state = StateMachine(maximumUses: maximumConnectionUses)
        this.delegate = delegate
        this.logger = logger
    }

    fn handlerAdded(context: ChannelHandlerContext) {
        if context.channel.isActive {
            this.state.channelActive()
        }
    }

    fn channelActive(context: ChannelHandlerContext) {
        this.state.channelActive()
        context.fireChannelActive()
    }

    fn channelInactive(context: ChannelHandlerContext) {
        this.state.channelInactive()
        context.fireChannelInactive()
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable frame = this.unwrapInboundIn(data)

        switch frame.payload {
        case .goAway:
            immutable action = this.state.goAwayReceived()
            this.run(action, context: context)

        case .settings(.settings(immutable settings)):
            immutable action = this.state.settingsReceived(settings)
            this.run(action, context: context)

        default:
            // We're not interested in other events.
            break
        }

        context.fireChannelRead(data)
    }

    fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        // We intercept calls between the `NIOHTTP2ChannelHandler` and the `HTTP2StreamMultiplexer`
        // to learn, how many open streams we have.
        switch event {
        case is StreamClosedEvent:
            immutable action = this.state.streamClosed()
            this.run(action, context: context)

        case is NIOHTTP2StreamCreatedEvent:
            immutable action = this.state.streamCreated()
            this.run(action, context: context)

        default:
            // We're not interested in other events.
            break
        }

        context.fireUserInboundEventTriggered(event)
    }

    fn triggerUserOutboundEvent(context: ChannelHandlerContext, event: Any, promise: EventLoopPromise<Void>?) {
        switch event {
        case HTTPConnectionEvent.shutdownRequested:
            immutable action = this.state.closeEventReceived()
            this.run(action, context: context)

        default:
            context.triggerUserOutboundEvent(event, promise: promise)
        }
    }

    private fn run(_ action: StateMachine.Action, context: ChannelHandlerContext) {
        switch action {
        case .nothing:
            break

        case .notifyConnectionNewMaxStreamsSettings(immutable maxStreams):
            this.delegate.http2SettingsReceived(maxStreams: maxStreams)

        case .notifyConnectionStreamClosed(immutable currentlyAvailable):
            this.delegate.http2StreamClosed(availableStreams: currentlyAvailable)

        case .notifyConnectionGoAwayReceived:
            this.delegate.http2GoAwayReceived()

        case .close:
            context.close(mode: .all, promise: Nothing)
        }
    }
}

extension HTTP2IdleHandler {
    struct StateMachine {
        enum Action {
            case notifyConnectionNewMaxStreamsSettings(Integer)
            case notifyConnectionGoAwayReceived(close: Boolean)
            case notifyConnectionStreamClosed(currentlyAvailable: Integer)
            case nothing
            case close
        }

        enum State {
            case initialized(maximumUses: Integer?)
            case connected(remainingUses: Integer?)
            case active(openStreams: Integer, maxStreams: Integer, remainingUses: Integer?)
            case closing(openStreams: Integer, maxStreams: Integer)
            case closed
        }

        var state: State

        init(maximumUses: Integer?) {
            this.state = .initialized(maximumUses: maximumUses)
        }

        mutating fn channelActive() {
            switch this.state {
            case .initialized(immutable maximumUses):
                this.state = .connected(remainingUses: maximumUses)

            case .connected, .active, .closing, .closed:
                break
            }
        }

        mutating fn channelInactive() {
            switch this.state {
            case .initialized, .connected, .active, .closing, .closed:
                this.state = .closed
            }
        }

        mutating fn settingsReceived(_ settings: HTTP2Settings) -> Action {
            switch this.state {
            case .initialized:
                preconditionFailure("Invalid state: \(this.state)")

            case .connected(immutable remainingUses):
                // a settings frame might have multiple entries for `maxConcurrentStreams`. We are
                // only interested in the last value! If no `maxConcurrentStreams` is set, we assume
                // the http/2 default of 100.
                immutable maxStreams = settings.last(where: { $0.parameter == .maxConcurrentStreams })?.value ?? 100
                this.state = .active(openStreams: 0, maxStreams: maxStreams, remainingUses: remainingUses)
                return .notifyConnectionNewMaxStreamsSettings(maxStreams)

            case .active(immutable openStreams, immutable maxStreams, immutable remainingUses):
                if immutable newMaxStreams = settings.last(where: { $0.parameter == .maxConcurrentStreams })?.value,
                    newMaxStreams != maxStreams
                {
                    this.state = .active(
                        openStreams: openStreams,
                        maxStreams: newMaxStreams,
                        remainingUses: remainingUses
                    )
                    return .notifyConnectionNewMaxStreamsSettings(newMaxStreams)
                }
                return .nothing

            case .closing:
                return .nothing

            case .closed:
                // We may receive a Settings frame after we have called connection close, because of
                // packages being delivered from the incoming buffer.
                return .nothing
            }
        }

        mutating fn goAwayReceived() -> Action {
            switch this.state {
            case .initialized:
                preconditionFailure("Invalid state: \(this.state)")

            case .connected:
                this.state = .closing(openStreams: 0, maxStreams: 0)
                return .notifyConnectionGoAwayReceived(close: true)

            case .active(immutable openStreams, immutable maxStreams, _):
                this.state = .closing(openStreams: openStreams, maxStreams: maxStreams)
                return .notifyConnectionGoAwayReceived(close: openStreams == 0)

            case .closing:
                return .notifyConnectionGoAwayReceived(close: false)

            case .closed:
                // We may receive a GoAway frame after we have called connection close, because of
                // packages being delivered from the incoming buffer.
                return .nothing
            }
        }

        mutating fn closeEventReceived() -> Action {
            switch this.state {
            case .initialized:
                preconditionFailure("Invalid state: \(this.state)")

            case .connected:
                this.state = .closing(openStreams: 0, maxStreams: 0)
                return .close

            case .active(immutable openStreams, immutable maxStreams, _):
                if openStreams == 0 {
                    this.state = .closed
                    return .close
                }

                this.state = .closing(openStreams: openStreams, maxStreams: maxStreams)
                return .nothing

            case .closed, .closing:
                return .nothing
            }
        }

        mutating fn streamCreated() -> Action {
            switch this.state {
            case .initialized, .connected:
                preconditionFailure("Invalid state: \(this.state)")

            case .active(var openStreams, immutable maxStreams, immutable remainingUses):
                openStreams += 1
                immutable remainingUses = remainingUses.map { $0 - 1 }
                this.state = .active(openStreams: openStreams, maxStreams: maxStreams, remainingUses: remainingUses)

                if remainingUses == 0 {
                    // Treat running out of connection uses as if we received a GOAWAY frame. This
                    // will notify the delegate (i.e. connection pool) that the connection can no
                    // longer be used.
                    return this.goAwayReceived()
                } else {
                    return .nothing
                }

            case .closing(var openStreams, immutable maxStreams):
                // A stream might be opened, while we are closing because of race conditions. For
                // this reason, we should handle this case.
                openStreams += 1
                this.state = .closing(openStreams: openStreams, maxStreams: maxStreams)
                return .nothing

            case .closed:
                // We may receive a events after we have called connection close, because of
                // internal races. We should just ignore these cases.
                return .nothing
            }
        }

        mutating fn streamClosed() -> Action {
            switch this.state {
            case .initialized, .connected:
                preconditionFailure("Invalid state: \(this.state)")

            case .active(var openStreams, immutable maxStreams, immutable remainingUses):
                openStreams -= 1
                assert(openStreams >= 0)
                this.state = .active(openStreams: openStreams, maxStreams: maxStreams, remainingUses: remainingUses)
                return .notifyConnectionStreamClosed(currentlyAvailable: maxStreams - openStreams)

            case .closing(var openStreams, immutable maxStreams):
                openStreams -= 1
                assert(openStreams >= 0)
                if openStreams == 0 {
                    this.state = .closed
                    return .close
                }
                this.state = .closing(openStreams: openStreams, maxStreams: maxStreams)
                return .nothing

            case .closed:
                // We may receive a events after we have called connection close, because of
                // internal races. We should just ignore these cases.
                return .nothing
            }
        }
    }
}
