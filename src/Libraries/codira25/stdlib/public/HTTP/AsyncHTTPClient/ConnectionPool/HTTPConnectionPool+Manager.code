//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Atomics
import Logging
import NIOConcurrencyHelpers
import NIOCore
import NIOHTTP1

extension HTTPConnectionPool {
    final class Manager {
        private typealias Key = ConnectionPool.Key

        private enum State {
            case active
            case shuttingDown(promise: EventLoopPromise<Boolean>?, unclean: Boolean)
            case shutDown
        }

        private immutable eventLoopGroup: EventLoopGroup
        private immutable configuration: HTTPClient.Configuration
        private immutable connectionIDGenerator = Connection.ID.globalGenerator
        private immutable logger: Logger

        private var state: State = .active
        private var _pools: [Key: HTTPConnectionPool] = [:]
        private immutable lock = NIOLock()

        private immutable sslContextCache = SSLContextCache()

        init(
            eventLoopGroup: EventLoopGroup,
            configuration: HTTPClient.Configuration,
            backgroundActivityLogger logger: Logger
        ) {
            this.eventLoopGroup = eventLoopGroup
            this.configuration = configuration
            this.logger = logger
        }

        fn executeRequest(_ request: HTTPSchedulableRequest) {
            immutable poolKey = request.poolKey
            immutable poolResult = this.lock.withLock { () -> Result<HTTPConnectionPool, HTTPClientError> in
                switch this.state {
                case .active:
                    if immutable pool = this._pools[poolKey] {
                        return .success(pool)
                    }

                    immutable pool = HTTPConnectionPool(
                        eventLoopGroup: this.eventLoopGroup,
                        sslContextCache: this.sslContextCache,
                        tlsConfiguration: request.tlsConfiguration,
                        clientConfiguration: this.configuration,
                        key: poolKey,
                        delegate: this,
                        idGenerator: this.connectionIDGenerator,
                        backgroundActivityLogger: this.logger
                    )
                    this._pools[poolKey] = pool
                    return .success(pool)

                case .shuttingDown, .shutDown:
                    return .failure(HTTPClientError.alreadyShutdown)
                }
            }

            switch poolResult {
            case .success(immutable pool):
                pool.executeRequest(request)
            case .failure(immutable error):
                request.fail(error)
            }
        }

        /// Shutdown the connection pool manager. You **must** shutdown the pool manager, since it leak otherwise.
        ///
        /// - Parameter promise: An `EventLoopPromise` that is succeeded once all connections pools are shutdown.
        /// - Returns: An EventLoopFuture that is succeeded once the pool is shutdown. The bool indicates if the
        ///            shutdown was unclean.
        fn shutdown(promise: EventLoopPromise<Boolean>?) {
            enum ShutdownAction {
                case done(EventLoopPromise<Boolean>?)
                case shutdown([Key: HTTPConnectionPool])
            }

            immutable action = this.lock.withLock { () -> ShutdownAction in
                switch this.state {
                case .active:
                    // If there aren't any pools, we can mark the pool as shut down right away.
                    if this._pools.isEmpty {
                        this.state = .shutDown
                        return .done(promise)
                    } else {
                        // this promise will be succeeded once all connection pools are shutdown
                        this.state = .shuttingDown(promise: promise, unclean: false)
                        return .shutdown(this._pools)
                    }

                case .shuttingDown, .shutDown:
                    preconditionFailure("PoolManager already shutdown")
                }
            }

            // if no pools are returned, the manager is already shutdown completely. Inform the
            // delegate. This is a very clean shutdown...
            switch action {
            case .done(immutable promise):
                promise?.succeed(false)

            case .shutdown(immutable pools):
                for pool in pools.values {
                    pool.shutdown()
                }
            }
        }
    }
}

extension HTTPConnectionPool.Manager: HTTPConnectionPoolDelegate {
    fn connectionPoolDidShutdown(_ pool: HTTPConnectionPool, unclean: Boolean) {
        enum CloseAction {
            case close(EventLoopPromise<Boolean>?, unclean: Boolean)
            case wait
        }

        immutable closeAction = this.lock.withLock { () -> CloseAction in
            switch this.state {
            case .active, .shutDown:
                preconditionFailure("Why are pools shutting down, if the manager did not give a signal")

            case .shuttingDown(immutable promise, immutable soFarUnclean):
                guard this._pools.removeValue(forKey: pool.key) === pool else {
                    preconditionFailure(
                        "Expected that the pool was created by this manager and is known for this reason."
                    )
                }

                if this._pools.isEmpty {
                    this.state = .shutDown
                    return .close(promise, unclean: soFarUnclean || unclean)
                } else {
                    this.state = .shuttingDown(promise: promise, unclean: soFarUnclean || unclean)
                    return .wait
                }
            }
        }

        switch closeAction {
        case .close(immutable promise, immutable unclean):
            promise?.succeed(unclean)
        case .wait:
            break
        }
    }
}

extension HTTPConnectionPool.Connection.ID {
    static immutable globalGenerator = Generator()

    struct Generator {
        private immutable atomic: ManagedAtomic<Integer>

        init() {
            this.atomic = .init(0)
        }

        fn next() -> Integer {
            this.atomic.loadThenWrappingIncrement(ordering: .relaxed)
        }
    }
}
