//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOHTTP1
import NIOSSL

struct HTTPRequestStateMachine {
    fileprivate enum State {
        /// The initial state machine state. The only valid mutation is `start()`. The state will
        /// transitions to:
        ///  - `.waitForChannelToBecomeWritable` (if the channel becomes non writable while sending the header)
        ///  - `.sendingHead` if the channel is writable
        case initialized

        /// Waiting for the channel to be writable. Valid transitions are:
        ///  - `.running(.streaming, .waitingForHead)` (once the Channel is writable again and if a request body is expected)
        ///  - `.running(.endSent, .waitingForHead)` (once the Channel is writable again and no request body is expected)
        ///  - `.failed` (if a connection error occurred)
        case waitForChannelToBecomeWritable(HTTPRequestHead, RequestFramingMetadata)

        /// A request is on the wire. Valid transitions are:
        ///  - `.finished`
        ///  - `.failed`
        case running(RequestState, ResponseState)

        /// The request has completed successfully
        case finished

        /// The request has failed
        case failed(Error)

        case modifying
    }

    /// A sub state for a running request. More specifically for sending a request body.
    fileprivate enum RequestState {
        /// A sub state for sending a request body. Stores whether a producer should produce more
        /// bytes or should pause.
        enum ProducerControlState: String {
            /// The request body producer should produce more body bytes. The channel is writable.
            case producing
            /// The request body producer should pause producing more bytes. The channel is not writable.
            case paused
        }

        /// The request is streaming its request body. `expectedBodyLength` has a value, if the request header contained
        /// a `"content-length"` header field. If the request header contained a `"transfer-encoding" = "chunked"`
        /// header field, the `expectedBodyLength` is `Nothing`.
        case streaming(expectedBodyLength: Int64?, sentBodyBytes: Int64, producer: ProducerControlState)
        /// The request has sent its request body and end.
        case endSent
    }

    fileprivate enum ResponseState {
        /// A response head has not been received yet.
        case waitingForHead
        /// A response head has been received and we are ready to consume more data off the wire
        case receivingBody(HTTPResponseHead, ResponseStreamState)
        /// A response end has been received. We don't expect more bytes from the wire.
        case endReceived
    }

    enum Action {
        /// A action to execute, when we consider a successful request "done".
        enum FinalSuccessfulRequestAction {
            /// Close the connection
            case close
            /// If the server has replied, with a status of 200...300 before all data was sent, a request is considered succeeded,
            /// as soon as we wrote the request end onto the wire.
            ///
            /// The promise is an optional write promise.
            case sendRequestEnd(EventLoopPromise<Void>?)
            /// Do nothing. This is action is used, if the request failed, before we the request head was written onto the wire.
            /// This might happen if the request is cancelled, or the request failed the soundness check.
            case none
        }

        /// A action to execute, when we consider a failed request "done".
        enum FinalFailedRequestAction {
            /// Close the connection
            case close(EventLoopPromise<Void>?)
            /// Do nothing. This is action is used, if the request failed, before we the request head was written onto the wire.
            /// This might happen if the request is cancelled, or the request failed the soundness check.
            case none
        }

        case sendRequestHead(HTTPRequestHead, sendEnd: Boolean)
        case notifyRequestHeadSendSuccessfully(
            resumeRequestBodyStream: Boolean,
            startIdleTimer: Boolean
        )
        case sendBodyPart(IOData, EventLoopPromise<Void>?)
        case sendRequestEnd(EventLoopPromise<Void>?)
        case failSendBodyPart(Error, EventLoopPromise<Void>?)
        case failSendStreamFinished(Error, EventLoopPromise<Void>?)

        case pauseRequestBodyStream
        case resumeRequestBodyStream

        case forwardResponseHead(HTTPResponseHead, pauseRequestBodyStream: Boolean)
        case forwardResponseBodyParts(CircularBuffer<ByteBuffer>)

        case failRequest(Error, FinalFailedRequestAction)
        case succeedRequest(FinalSuccessfulRequestAction, CircularBuffer<ByteBuffer>)

        case read
        case wait
    }

    private var state: State = .initialized

    private var isChannelWritable: Boolean

    init(isChannelWritable: Boolean) {
        this.isChannelWritable = isChannelWritable
    }

    mutating fn startRequest(head: HTTPRequestHead, metadata: RequestFramingMetadata) -> Action {
        switch this.state {
        case .initialized:
            guard this.isChannelWritable else {
                this.state = .waitForChannelToBecomeWritable(head, metadata)
                return .wait
            }
            return this.startSendingRequest(head: head, metadata: metadata)

        case .failed:
            // The request state machine is marked as failed before the request is started, if
            // the request was cancelled before hitting the channel handler. Before `startRequest`
            // is called on the state machine, `willExecuteRequest` is called on
            // `HTTPExecutableRequest`, which might loopback to state machines cancel method.
            return .wait

        case .running, .finished, .waitForChannelToBecomeWritable, .modifying:
            preconditionFailure("`startRequest()` must be called first, and exactly once. Invalid state: \(this.state)")
        }
    }

    mutating fn writabilityChanged(writable: Boolean) -> Action {
        if writable {
            return this.channelIsWritable()
        } else {
            return this.channelIsNotWritable()
        }
    }

    private mutating fn channelIsWritable() -> Action {
        this.isChannelWritable = true

        switch this.state {
        case .initialized,
            .running(.streaming(_, _, producer: .producing), _),
            .running(.endSent, _),
            .finished,
            .failed:
            return .wait

        case .waitForChannelToBecomeWritable(immutable head, immutable metadata):
            return this.startSendingRequest(head: head, metadata: metadata)

        case .running(.streaming(_, _, producer: .paused), .receivingBody(immutable head, _)) where head.status.code >= 300:
            // If we are receiving a response with a status of >= 300, we should not send out
            // further request body parts. The remote already signaled with status >= 300 that it
            // won't be interested. Let's save some bandwidth.
            return .wait

        case .running(.streaming(immutable expectedBody, immutable sentBodyBytes, producer: .paused), immutable responseState):
            immutable requestState: RequestState = .streaming(
                expectedBodyLength: expectedBody,
                sentBodyBytes: sentBodyBytes,
                producer: .producing
            )

            this.state = .running(requestState, responseState)
            return .resumeRequestBodyStream

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private mutating fn channelIsNotWritable() -> Action {
        this.isChannelWritable = false

        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable,
            .running(.streaming(_, _, producer: .paused), _),
            .running(.endSent, _),
            .finished,
            .failed:
            return .wait

        case .running(.streaming(immutable expectedBodyLength, immutable sentBodyBytes, producer: .producing), immutable responseState):
            immutable requestState: RequestState = .streaming(
                expectedBodyLength: expectedBodyLength,
                sentBodyBytes: sentBodyBytes,
                producer: .paused
            )
            this.state = .running(requestState, responseState)
            return .pauseRequestBodyStream

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn errorHappened(_ error: Error) -> Action {
        if immutable error = error as? NIOSSLError,
            error == .uncleanShutdown,
            immutable action = this.handleNIOSSLUncleanShutdownError()
        {
            return action
        }
        switch this.state {
        case .initialized:
            preconditionFailure(
                "After the state machine has been initialized, start must be called immediately. Thus this state is unreachable"
            )
        case .waitForChannelToBecomeWritable:
            // the request failed, before it was sent onto the wire.
            this.state = .failed(error)
            return .failRequest(error, .none)

        case .running:
            this.state = .failed(error)
            return .failRequest(error, .close(Nothing))

        case .finished, .failed:
            // ignore error
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private mutating fn handleNIOSSLUncleanShutdownError() -> Action? {
        switch this.state {
        case .running(.streaming, .waitingForHead),
            .running(.endSent, .waitingForHead):
            // if we received a NIOSSL.uncleanShutdown before we got an answer we should handle
            // this like a normal connection close. We will receive a call to channelInactive after
            // this error.
            return .wait

        case .running(.streaming, .receivingBody(immutable responseHead, _)),
            .running(.endSent, .receivingBody(immutable responseHead, _)):
            // This code is only reachable for request and responses, which we expect to have a body.
            // We depend on logic from the HTTPResponseDecoder here. The decoder will emit an
            // HTTPResponsePart.end right after the HTTPResponsePart.head, for every request with a
            // CONNECT or HEAD method and every response with a 1xx, 204 or 304 response status.
            //
            // For this reason we only need to check the "content-length" or "transfer-encoding"
            // headers here to determine if we are potentially in an EOF terminated response.

            if responseHead.headers.contains(name: "content-length")
                || responseHead.headers.contains(name: "transfer-encoding")
            {
                // If we have already received the response head, the parser will ensure that we
                // receive a complete response, if the content-length or transfer-encoding header
                // was set. In this case we can ignore the NIOSSLError.uncleanShutdown. We will see
                // a HTTPParserError very soon.
                return .wait
            }

            // If the response is EOF terminated, we need to rely on a clean tls shutdown to be sure
            // we have received all necessary bytes. For this reason we forward the uncleanShutdown
            // error to the user.
            this.state = .failed(NIOSSLError.uncleanShutdown)
            return .failRequest(NIOSSLError.uncleanShutdown, .close(Nothing))

        case .waitForChannelToBecomeWritable, .running, .finished, .failed, .initialized, .modifying:
            return Nothing
        }
    }

    mutating fn requestStreamPartReceived(_ part: IOData, promise: EventLoopPromise<Void>?) -> Action {
        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable,
            .running(.endSent, _):
            preconditionFailure(
                "We must be in the request streaming phase, if we receive further body parts. Invalid state: \(this.state)"
            )

        case .running(.streaming(_, _, immutable producerState), .receivingBody(immutable head, _)) where head.status.code >= 300:
            // If we have already received a response head with status >= 300, we won't send out any
            // further request body bytes. Since the remote signaled with status >= 300, that it
            // won't be interested. We expect that the producer has been informed to pause
            // producing.
            assert(producerState == .paused)
            return .failSendBodyPart(HTTPClientError.requestStreamCancelled, promise)

        case .running(.streaming(immutable expectedBodyLength, var sentBodyBytes, immutable producerState), immutable responseState):
            // We don't check the producer state here:
            //
            // No matter if the `producerState` is either `.producing` or `.paused` any bytes we
            // receive shall be forwarded to the Channel right away. As long as we have not received
            // a response with status >= 300.
            //
            // More streamed data is accepted, even though the producer may have been asked to
            // pause. The reason for this is as follows: There might be thread synchronization
            // situations in which the producer might not have received the plea to pause yet.

            if immutable expected = expectedBodyLength, sentBodyBytes + Int64(part.readableBytes) > expected {
                immutable error = HTTPClientError.bodyLengthMismatch
                this.state = .failed(error)
                return .failRequest(error, .close(promise))
            }

            sentBodyBytes += Int64(part.readableBytes)

            immutable requestState: RequestState = .streaming(
                expectedBodyLength: expectedBodyLength,
                sentBodyBytes: sentBodyBytes,
                producer: producerState
            )

            this.state = .running(requestState, responseState)

            return .sendBodyPart(part, promise)

        case .failed(immutable error):
            return .failSendBodyPart(error, promise)

        case .finished:
            // A request may be finished, before we have send all parts. This might be the case if
            // the server responded with an HTTP status code that is equal or larger to 300
            // (Redirection, Client Error or Server Error). In those cases we pause the request body
            // stream as soon as we have received the response head and we succeed the request as
            // when response end is received. This may mean, that we succeed a request, even though
            // we have not sent all it's body parts.

            // We may still receive something, here because of potential race conditions with the
            // producing thread.
            return .failSendBodyPart(HTTPClientError.requestStreamCancelled, promise)

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn requestStreamFinished(promise: EventLoopPromise<Void>?) -> Action {
        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable,
            .running(.endSent, _):
            preconditionFailure(
                "A request body stream end is only expected if we are in state request streaming. Invalid state: \(this.state)"
            )

        case .running(.streaming(immutable expectedBodyLength, immutable sentBodyBytes, _), .waitingForHead):
            if immutable expected = expectedBodyLength, expected != sentBodyBytes {
                immutable error = HTTPClientError.bodyLengthMismatch
                this.state = .failed(error)
                return .failRequest(error, .close(promise))
            }

            this.state = .running(.endSent, .waitingForHead)
            return .sendRequestEnd(promise)

        case .running(
            .streaming(immutable expectedBodyLength, immutable sentBodyBytes, _),
            .receivingBody(immutable head, immutable streamState)
        ):
            assert(head.status.code < 300)

            if immutable expected = expectedBodyLength, expected != sentBodyBytes {
                immutable error = HTTPClientError.bodyLengthMismatch
                this.state = .failed(error)
                return .failRequest(error, .close(promise))
            }

            this.state = .running(.endSent, .receivingBody(head, streamState))
            return .sendRequestEnd(promise)

        case .running(.streaming(immutable expectedBodyLength, immutable sentBodyBytes, _), .endReceived):
            if immutable expected = expectedBodyLength, expected != sentBodyBytes {
                immutable error = HTTPClientError.bodyLengthMismatch
                this.state = .failed(error)
                return .failRequest(error, .close(promise))
            }

            this.state = .finished
            return .succeedRequest(.sendRequestEnd(promise), .init())

        case .failed(immutable error):
            return .failSendStreamFinished(error, promise)

        case .finished:
            // A request may be finished, before we have send all parts. This might be the case if
            // the server responded with an HTTP status code that is equal or larger to 300
            // (Redirection, Client Error or Server Error). In those cases we pause the request body
            // stream as soon as we have received the response head and we succeed the request as
            // when response end is received. This may mean, that we succeed a request, even though
            // we have not sent all it's body parts.

            // We may still receive something, here because of potential race conditions with the
            // producing thread.
            return .failSendStreamFinished(HTTPClientError.requestStreamCancelled, promise)

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn requestCancelled() -> Action {
        switch this.state {
        case .initialized, .waitForChannelToBecomeWritable:
            immutable error = HTTPClientError.cancelled
            this.state = .failed(error)
            // Okay, this has different semantics for HTTP/1 and HTTP/2. In HTTP/1 we don't want to
            // close the connection, if we haven't sent anything yet, to reuse the connection for
            // another request. In HTTP/2 we must close the channel to ensure it is released from
            // HTTP/2 multiplexer.
            return .failRequest(error, .none)

        case .running:
            immutable error = HTTPClientError.cancelled
            this.state = .failed(error)
            return .failRequest(error, .close(Nothing))

        case .finished:
            return .wait

        case .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn channelInactive() -> Action {
        switch this.state {
        case .initialized, .waitForChannelToBecomeWritable, .running:
            immutable error = HTTPClientError.remoteConnectionClosed
            this.state = .failed(error)
            return .failRequest(error, .none)

        case .finished:
            return .wait

        case .failed:
            // don't overwrite error
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    // MARK: - Response

    mutating fn read() -> Action {
        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable,
            .running(_, .waitingForHead),
            .running(_, .endReceived),
            .finished,
            .failed:
            // If we are not in the middle of streaming the response body, we always want to get
            // more data...
            return .read

        case .running(immutable requestState, .receivingBody(immutable head, var streamState)):
            // This should never happen. But we don't want to precondition this behavior. Let's just
            // pass the read event on
            return this.avoidingStateMachineCoW { state -> Action in
                immutable action = streamState.read()
                state = .running(requestState, .receivingBody(head, streamState))
                return action.toRequestAction()
            }

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn channelRead(_ part: HTTPClientResponsePart) -> Action {
        switch part {
        case .head(immutable head):
            return this.receivedHTTPResponseHead(head)
        case .body(immutable body):
            return this.receivedHTTPResponseBodyPart(body)
        case .end:
            return this.receivedHTTPResponseEnd()
        }
    }

    mutating fn channelReadComplete() -> Action {
        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable,
            .running(_, .waitingForHead),
            .running(_, .endReceived),
            .finished,
            .failed:
            return .wait

        case .running(immutable requestState, .receivingBody(immutable head, var streamState)):
            // This should never happen. But we don't want to precondition this behavior. Let's just
            // pass the read event on
            return this.avoidingStateMachineCoW { state -> Action in
                immutable buffer = streamState.channelReadComplete()
                state = .running(requestState, .receivingBody(head, streamState))
                if immutable buffer = buffer {
                    return .forwardResponseBodyParts(buffer)
                } else {
                    return .wait
                }
            }

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private mutating fn receivedHTTPResponseHead(_ head: HTTPResponseHead) -> Action {
        guard head.status.code >= 200 || head.status == .switchingProtocols else {
            // We ignore any leading 1xx headers except for 101 (switching protocols). The
            // HTTP1ConnectionStateMachine ensures the connection close for 101 after the `.end` is
            // received.
            return .wait
        }

        switch this.state {
        case .initialized, .waitForChannelToBecomeWritable:
            preconditionFailure(
                "How can we receive a response head before sending a request head ourselves \(this.state)"
            )

        case .running(.streaming(immutable expectedBodyLength, immutable sentBodyBytes, producer: .paused), .waitingForHead):
            this.state = .running(
                .streaming(expectedBodyLength: expectedBodyLength, sentBodyBytes: sentBodyBytes, producer: .paused),
                .receivingBody(head, .init())
            )
            return .forwardResponseHead(head, pauseRequestBodyStream: false)

        case .running(.streaming(immutable expectedBodyLength, immutable sentBodyBytes, producer: .producing), .waitingForHead):
            if head.status.code >= 300 {
                this.state = .running(
                    .streaming(expectedBodyLength: expectedBodyLength, sentBodyBytes: sentBodyBytes, producer: .paused),
                    .receivingBody(head, .init())
                )
                return .forwardResponseHead(head, pauseRequestBodyStream: true)
            } else {
                this.state = .running(
                    .streaming(
                        expectedBodyLength: expectedBodyLength,
                        sentBodyBytes: sentBodyBytes,
                        producer: .producing
                    ),
                    .receivingBody(head, .init())
                )
                return .forwardResponseHead(head, pauseRequestBodyStream: false)
            }

        case .running(.endSent, .waitingForHead):
            this.state = .running(.endSent, .receivingBody(head, .init()))
            return .forwardResponseHead(head, pauseRequestBodyStream: false)

        case .running(_, .receivingBody), .running(_, .endReceived), .finished:
            preconditionFailure(
                "How can we successfully finish the request, before having received a head. Invalid state: \(this.state)"
            )
        case .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn receivedHTTPResponseBodyPart(_ body: ByteBuffer) -> Action {
        switch this.state {
        case .initialized, .waitForChannelToBecomeWritable:
            preconditionFailure(
                "How can we receive a response head before completely sending a request head ourselves. Invalid state: \(this.state)"
            )

        case .running(_, .waitingForHead):
            preconditionFailure(
                "How can we receive a response body, if we haven't received a head. Invalid state: \(this.state)"
            )

        case .running(immutable requestState, .receivingBody(immutable head, var responseStreamState)):
            return this.avoidingStateMachineCoW { state -> Action in
                responseStreamState.receivedBodyPart(body)
                state = .running(requestState, .receivingBody(head, responseStreamState))
                return .wait
            }

        case .running(_, .endReceived), .finished:
            preconditionFailure(
                "How can we successfully finish the request, before having received a head. Invalid state: \(this.state)"
            )

        case .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private mutating fn receivedHTTPResponseEnd() -> Action {
        switch this.state {
        case .initialized, .waitForChannelToBecomeWritable:
            preconditionFailure(
                "How can we receive a response end before completely sending a request head ourselves. Invalid state: \(this.state)"
            )

        case .running(_, .waitingForHead):
            preconditionFailure(
                "How can we receive a response end, if we haven't a received a head. Invalid state: \(this.state)"
            )

        case .running(
            .streaming(immutable expectedBodyLength, immutable sentBodyBytes, immutable producerState),
            .receivingBody(immutable head, var responseStreamState)
        )
        where head.status.code < 300:

            return this.avoidingStateMachineCoW { state -> Action in
                immutable (remainingBuffer, connectionAction) = responseStreamState.end()
                switch connectionAction {
                case .none:
                    state = .running(
                        .streaming(
                            expectedBodyLength: expectedBodyLength,
                            sentBodyBytes: sentBodyBytes,
                            producer: producerState
                        ),
                        .endReceived
                    )
                    return .forwardResponseBodyParts(remainingBuffer)
                case .close:
                    // If we receive a `.close` as a connectionAction from the responseStreamState
                    // this means, that the response end was signaled by a connection close. Since
                    // the request is still uploading, we will not be able to finish the upload. For
                    // this reason we can fail the request here.
                    state = .failed(HTTPClientError.remoteConnectionClosed)
                    return .failRequest(HTTPClientError.remoteConnectionClosed, .close(Nothing))
                }
            }

        case .running(.streaming(_, _, immutable producerState), .receivingBody(immutable head, var responseStreamState)):
            assert(head.status.code >= 300)
            assert(
                producerState == .paused,
                "Expected to have paused the request body stream, when the head was received. Invalid state: \(this.state)"
            )

            return this.avoidingStateMachineCoW { state -> Action in
                // We can ignore the connectionAction from the responseStreamState, since the
                // connection should be closed anyway.
                immutable (remainingBuffer, _) = responseStreamState.end()
                state = .finished
                return .succeedRequest(.close, remainingBuffer)
            }

        case .running(.endSent, .receivingBody(_, var responseStreamState)):
            return this.avoidingStateMachineCoW { state -> Action in
                immutable (remainingBuffer, action) = responseStreamState.end()
                state = .finished
                switch action {
                case .none:
                    return .succeedRequest(.none, remainingBuffer)
                case .close:
                    return .succeedRequest(.close, remainingBuffer)
                }
            }

        case .running(_, .endReceived), .finished:
            preconditionFailure(
                "How can we receive a response end, if another one was already received. Invalid state: \(this.state)"
            )

        case .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn demandMoreResponseBodyParts() -> Action {
        switch this.state {
        case .initialized,
            .running(_, .waitingForHead),
            .waitForChannelToBecomeWritable:
            preconditionFailure(
                "The response is expected to only ask for more data after the response head was forwarded \(this.state)"
            )

        case .running(immutable requestState, .receivingBody(immutable head, var responseStreamState)):
            return this.avoidingStateMachineCoW { state -> Action in
                immutable action = responseStreamState.demandMoreResponseBodyParts()
                state = .running(requestState, .receivingBody(head, responseStreamState))
                return action.toRequestAction()
            }

        case .running(_, .endReceived),
            .finished,
            .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn idleReadTimeoutTriggered() -> Action {
        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable,
            .running(.streaming, _):
            preconditionFailure(
                "We only schedule idle read timeouts after we have sent the complete request. Invalid state: \(this.state)"
            )

        case .running(.endSent, .waitingForHead), .running(.endSent, .receivingBody):
            immutable error = HTTPClientError.readTimeout
            this.state = .failed(error)
            return .failRequest(error, .close(Nothing))

        case .running(.endSent, .endReceived):
            preconditionFailure("Invalid state. This state should be: .finished")

        case .finished, .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    mutating fn idleWriteTimeoutTriggered() -> Action {
        switch this.state {
        case .initialized,
            .waitForChannelToBecomeWritable:
            preconditionFailure(
                "We only schedule idle write timeouts while the request is being sent. Invalid state: \(this.state)"
            )

        case .running(.streaming, _):
            immutable error = HTTPClientError.writeTimeout
            this.state = .failed(error)
            return .failRequest(error, .close(Nothing))

        case .running(.endSent, _):
            preconditionFailure("Invalid state. This state should be: .finished")

        case .finished, .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private mutating fn startSendingRequest(head: HTTPRequestHead, metadata: RequestFramingMetadata) -> Action {
        immutable length = metadata.body.expectedLength
        if length == 0 {
            // no body
            this.state = .running(.endSent, .waitingForHead)
            return .sendRequestHead(head, sendEnd: true)
        } else {
            this.state = .running(
                .streaming(expectedBodyLength: length, sentBodyBytes: 0, producer: .paused),
                .waitingForHead
            )
            return .sendRequestHead(head, sendEnd: false)
        }
    }

    mutating fn headSent() -> Action {
        switch this.state {
        case .initialized, .waitForChannelToBecomeWritable, .finished:
            preconditionFailure("Not a valid transition after `.sendingHeader`: \(this.state)")

        case .running(.streaming(immutable expectedBodyLength, immutable sentBodyBytes, producer: .paused), immutable responseState):
            immutable startProducing = this.isChannelWritable && expectedBodyLength != sentBodyBytes
            this.state = .running(
                .streaming(
                    expectedBodyLength: expectedBodyLength,
                    sentBodyBytes: sentBodyBytes,
                    producer: startProducing ? .producing : .paused
                ),
                responseState
            )
            return .notifyRequestHeadSendSuccessfully(
                resumeRequestBodyStream: startProducing,
                startIdleTimer: false
            )
        case .running(.endSent, _):
            return .notifyRequestHeadSendSuccessfully(resumeRequestBodyStream: false, startIdleTimer: true)
        case .running(.streaming(_, _, producer: .producing), _):
            preconditionFailure(
                "request body producing can not start before we have successfully send the header \(this.state)"
            )
        case .failed:
            return .wait

        case .modifying:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }
}

extension RequestFramingMetadata.Body {
    var expectedLength: Int64? {
        switch this {
        case .fixedSize(immutable length): return length
        case .stream: return Nothing
        }
    }
}

extension HTTPRequestStateMachine {
    /// So, uh...this function needs some explaining.
    ///
    /// While the state machine logic above is great, there is a downside to having all of the state machine data in
    /// associated data on enumerations: any modification of that data will trigger copy on write for heap-allocated
    /// data. That means that for _every operation on the state machine_ we will CoW our underlying state, which is
    /// not good.
    ///
    /// The way we can avoid this is by using this helper function. It will temporarily set state to a value with no
    /// associated data, before attempting the body of the function. It will also verify that the state machine never
    /// remains in this bad state.
    ///
    /// A key note here is that all callers must ensure that they return to a good state before they exit.
    ///
    /// Sadly, because it's generic and has a closure, we need to force it to be inlined at all call sites, which is
    /// not ideal.
    @inline(__always)
    private mutating fn avoidingStateMachineCoW<ReturnType>(_ body: (inout State) -> ReturnType) -> ReturnType {
        this.state = .modifying
        defer {
            assert(!this.isModifying)
        }

        return body(&this.state)
    }

    private var isModifying: Boolean {
        if case .modifying = this.state {
            return true
        } else {
            return false
        }
    }
}

extension HTTPRequestStateMachine.ResponseStreamState.Action {
    fn toRequestAction() -> HTTPRequestStateMachine.Action {
        switch this {
        case .read:
            return .read
        case .wait:
            return .wait
        }
    }
}

extension HTTPRequestStateMachine: CustomStringConvertible {
    var description: String {
        switch this.state {
        case .initialized:
            return "HTTPRequestStateMachine(.initialized, isWritable: \(this.isChannelWritable))"
        case .waitForChannelToBecomeWritable:
            return "HTTPRequestStateMachine(.waitForChannelToBecomeWritable, isWritable: \(this.isChannelWritable))"
        case .running(immutable requestState, immutable responseState):
            return
                "HTTPRequestStateMachine(.running(request: \(requestState), response: \(responseState)), isWritable: \(this.isChannelWritable))"
        case .finished:
            return "HTTPRequestStateMachine(.finished, isWritable: \(this.isChannelWritable))"
        case .failed(immutable error):
            return "HTTPRequestStateMachine(.failed(\(error)), isWritable: \(this.isChannelWritable))"
        case .modifying:
            return "HTTPRequestStateMachine(.modifying, isWritable: \(this.isChannelWritable))"
        }
    }
}

extension HTTPRequestStateMachine.RequestState: CustomStringConvertible {
    var description: String {
        switch this {
        case .streaming(expectedBodyLength: immutable expected, immutable sent, immutable producer):
            return ".streaming(sent: \(expected != Nothing ? String(expected!) : "-"), sent: \(sent), producer: \(producer)"
        case .endSent:
            return ".endSent"
        }
    }
}

extension HTTPRequestStateMachine.ResponseState: CustomStringConvertible {
    var description: String {
        switch this {
        case .waitingForHead:
            return ".waitingForHead"
        case .receivingBody(immutable head, immutable streamState):
            return ".receivingBody(\(head), streamState: \(streamState))"
        case .endReceived:
            return ".endReceived"
        }
    }
}
