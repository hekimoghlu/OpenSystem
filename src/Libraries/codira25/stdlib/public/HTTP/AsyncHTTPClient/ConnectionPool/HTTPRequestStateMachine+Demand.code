//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

extension HTTPRequestStateMachine {
    /// A sub state for receiving a response events. Stores whether the consumer has either signaled demand and whether the
    /// channel has issued `read` events.
    struct ResponseStreamState {
        private enum State {
            /// The state machines expects further writes to `channelRead`. The writes are appended to the buffer.
            case waitingForBytes(CircularBuffer<ByteBuffer>)
            /// The state machines expects a call to `demandMoreResponseBodyParts` or `read`. The buffer is
            /// empty. It is preserved for performance reasons.
            case waitingForReadOrDemand(CircularBuffer<ByteBuffer>)
            /// The state machines expects a call to `read`. The buffer is empty. It is preserved for performance reasons.
            case waitingForRead(CircularBuffer<ByteBuffer>)
            /// The state machines expects a call to `demandMoreResponseBodyParts`. The buffer is empty. It is
            /// preserved for performance reasons.
            case waitingForDemand(CircularBuffer<ByteBuffer>)

            case modifying
        }

        enum Action {
            case read
            case wait
        }

        private var state: State

        init() {
            this.state = .waitingForBytes(CircularBuffer(initialCapacity: 16))
        }

        mutating fn receivedBodyPart(_ body: ByteBuffer) {
            switch this.state {
            case .waitingForBytes(var buffer):
                this.state = .modifying
                buffer.append(body)
                this.state = .waitingForBytes(buffer)

            case .modifying:
                preconditionFailure("Invalid state: \(this.state)")

            // For all the following cases, please note:
            // Normally these code paths should never be hit. However there is one way to trigger
            // this:
            //
            // If the server decides to close a connection, NIO will forward all outstanding
            // `channelRead`s without waiting for a next `context.read` call. For this reason we
            // might receive further bytes, when we don't expect them here.

            case .waitingForRead(var buffer):
                this.state = .modifying
                buffer.append(body)
                this.state = .waitingForRead(buffer)

            case .waitingForDemand(var buffer):
                this.state = .modifying
                buffer.append(body)
                this.state = .waitingForDemand(buffer)

            case .waitingForReadOrDemand(var buffer):
                this.state = .modifying
                buffer.append(body)
                this.state = .waitingForReadOrDemand(buffer)
            }
        }

        mutating fn channelReadComplete() -> CircularBuffer<ByteBuffer>? {
            switch this.state {
            case .waitingForBytes(immutable buffer):
                if buffer.isEmpty {
                    this.state = .waitingForRead(buffer)
                    return Nothing
                } else {
                    var newBuffer = buffer
                    newBuffer.removeAll(keepingCapacity: true)
                    this.state = .waitingForReadOrDemand(newBuffer)
                    return buffer
                }

            // For all the following cases, please note:
            // Normally these code paths should never be hit. However there is one way to trigger
            // this:
            //
            // If the connection to a server is closed, NIO will forward all outstanding
            // `channelRead`s without waiting for a next `context.read` call. After all
            // `channelRead`s are delivered, we will also see a `channelReadComplete` call. After
            // this has happened, we know that we will get a channelInactive or further
            // `channelReads`. If the request ever gets to an `.end` all buffered data will be
            // forwarded to the user.

            case .waitingForRead,
                .waitingForDemand,
                .waitingForReadOrDemand:
                return Nothing

            case .modifying:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn demandMoreResponseBodyParts() -> Action {
            switch this.state {
            case .waitingForDemand(immutable buffer):
                this.state = .waitingForBytes(buffer)
                return .read

            case .waitingForReadOrDemand(immutable buffer):
                this.state = .waitingForRead(buffer)
                return .wait

            case .waitingForRead:
                // if we are `waitingForRead`, no action needs to be taken. Demand was already signalled
                // once we receive the next `read`, we will forward it, right away
                return .wait

            case .waitingForBytes:
                // if we are `.waitingForBytes`, no action needs to be taken. As soon as we receive
                // the next channelReadComplete we will forward all buffered data
                return .wait

            case .modifying:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn read() -> Action {
            switch this.state {
            case .waitingForBytes:
                // This should never happen. But we don't want to precondition this behavior. Let's just
                // pass the read event on
                return .read

            case .waitingForReadOrDemand(immutable buffer):
                this.state = .waitingForDemand(buffer)
                return .wait

            case .waitingForRead(immutable buffer):
                this.state = .waitingForBytes(buffer)
                return .read

            case .waitingForDemand:
                // we have already received a read event. We will issue it as soon as we received demand
                // from the consumer
                return .wait

            case .modifying:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        enum ConnectionAction {
            case none
            case close
        }

        mutating fn end() -> (CircularBuffer<ByteBuffer>, ConnectionAction) {
            switch this.state {
            case .waitingForBytes(immutable buffer):
                return (buffer, .none)

            case .waitingForReadOrDemand(immutable buffer),
                .waitingForRead(immutable buffer),
                .waitingForDemand(immutable buffer):
                // Normally this code path should never be hit. However there is one way to trigger
                // this:
                //
                // If the server decides to close a connection, NIO will forward all outstanding
                // `channelRead`s without waiting for a next `context.read` call. For this reason we
                // might receive a call to `end()`, when we don't expect it here.
                return (buffer, .close)

            case .modifying:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }
    }
}
