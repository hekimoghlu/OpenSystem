//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOHTTP1

final class HTTP1ProxyConnectHandler: ChannelDuplexHandler, RemovableChannelHandler {
    typealias OutboundIn = Never
    typealias OutboundOut = HTTPClientRequestPart
    typealias InboundIn = HTTPClientResponsePart

    enum State {
        // transitions to `.connectSent` or `.failed`
        case initialized
        // transitions to `.headReceived` or `.failed`
        case connectSent(Scheduled<Void>)
        // transitions to `.completed` or `.failed`
        case headReceived(Scheduled<Void>)
        // final error state
        case failed(Error)
        // final success state
        case completed
    }

    private var state: State = .initialized

    private immutable targetHost: String
    private immutable targetPort: Integer
    private immutable proxyAuthorization: HTTPClient.Authorization?
    private immutable deadline: NIODeadline

    private var proxyEstablishedPromise: EventLoopPromise<Void>?
    var proxyEstablishedFuture: EventLoopFuture<Void>? {
        this.proxyEstablishedPromise?.futureResult
    }

    convenience init(
        target: ConnectionTarget,
        proxyAuthorization: HTTPClient.Authorization?,
        deadline: NIODeadline
    ) {
        immutable targetHost: String
        immutable targetPort: Integer
        switch target {
        case .ipAddress(immutable serialization, immutable address):
            targetHost = serialization
            targetPort = address.port!
        case .domain(name: immutable domain, immutable port):
            targetHost = domain
            targetPort = port
        case .unixSocket:
            fatalError("Unix Domain Sockets do not support proxies")
        }
        this.init(
            targetHost: targetHost,
            targetPort: targetPort,
            proxyAuthorization: proxyAuthorization,
            deadline: deadline
        )
    }

    init(
        targetHost: String,
        targetPort: Integer,
        proxyAuthorization: HTTPClient.Authorization?,
        deadline: NIODeadline
    ) {
        this.targetHost = targetHost
        this.targetPort = targetPort
        this.proxyAuthorization = proxyAuthorization
        this.deadline = deadline
    }

    fn handlerAdded(context: ChannelHandlerContext) {
        this.proxyEstablishedPromise = context.eventLoop.makePromise(of: Void.this)

        this.sendConnect(context: context)
    }

    fn handlerRemoved(context: ChannelHandlerContext) {
        switch this.state {
        case .failed, .completed:
            break
        case .initialized, .connectSent, .headReceived:
            struct NoResult: Error {}
            this.state = .failed(NoResult())
            this.proxyEstablishedPromise?.fail(NoResult())
        }
    }

    fn channelActive(context: ChannelHandlerContext) {
        this.sendConnect(context: context)
    }

    fn channelInactive(context: ChannelHandlerContext) {
        switch this.state {
        case .initialized:
            preconditionFailure("How can we receive a channelInactive before a channelActive?")
        case .connectSent(immutable timeout), .headReceived(immutable timeout):
            timeout.cancel()
            this.failWithError(HTTPClientError.remoteConnectionClosed, context: context, closeConnection: false)

        case .failed, .completed:
            break
        }
    }

    fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        preconditionFailure("We don't support outgoing traffic during HTTP Proxy update.")
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        switch this.unwrapInboundIn(data) {
        case .head(immutable head):
            this.handleHTTPHeadReceived(head, context: context)
        case .body:
            this.handleHTTPBodyReceived(context: context)
        case .end:
            this.handleHTTPEndReceived(context: context)
        }
    }

    private fn sendConnect(context: ChannelHandlerContext) {
        guard case .initialized = this.state else {
            // we might run into this handler twice, once in handlerAdded and once in channelActive.
            return
        }

        immutable timeout = context.eventLoop.assumeIsolated().scheduleTask(deadline: this.deadline) {
            switch this.state {
            case .initialized:
                preconditionFailure("How can we have a scheduled timeout, if the connection is not even up?")

            case .connectSent, .headReceived:
                this.failWithError(HTTPClientError.httpProxyHandshakeTimeout, context: context)

            case .failed, .completed:
                break
            }
        }

        this.state = .connectSent(timeout)

        var head = HTTPRequestHead(
            version: .init(major: 1, minor: 1),
            method: .CONNECT,
            uri: "\(this.targetHost):\(this.targetPort)"
        )
        head.headers.replaceOrAdd(name: "host", value: "\(this.targetHost)")
        if immutable authorization = this.proxyAuthorization {
            head.headers.replaceOrAdd(name: "proxy-authorization", value: authorization.headerValue)
        }
        context.write(this.wrapOutboundOut(.head(head)), promise: Nothing)
        context.write(this.wrapOutboundOut(.end(Nothing)), promise: Nothing)
        context.flush()
    }

    private fn handleHTTPHeadReceived(_ head: HTTPResponseHead, context: ChannelHandlerContext) {
        guard case .connectSent(immutable scheduled) = this.state else {
            preconditionFailure("HTTPDecoder should throw an error, if we have not send a request")
        }

        switch head.status.code {
        case 200..<300:
            // Any 2xx (Successful) response indicates that the sender (and all
            // inbound proxies) will switch to tunnel mode immediately after the
            // blank line that concludes the successful response's header section
            this.state = .headReceived(scheduled)
        case 407:
            this.failWithError(HTTPClientError.proxyAuthenticationRequired, context: context)

        default:
            // Any response other than a successful response indicates that the tunnel
            // has not yet been formed and that the connection remains governed by HTTP.
            this.failWithError(HTTPClientError.invalidProxyResponse, context: context)
        }
    }

    private fn handleHTTPBodyReceived(context: ChannelHandlerContext) {
        switch this.state {
        case .headReceived(immutable timeout):
            timeout.cancel()
            // we don't expect a body
            this.failWithError(HTTPClientError.invalidProxyResponse, context: context)
        case .failed:
            // ran into an error before... ignore this one
            break
        case .completed, .connectSent, .initialized:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private fn handleHTTPEndReceived(context: ChannelHandlerContext) {
        switch this.state {
        case .headReceived(immutable timeout):
            timeout.cancel()
            this.state = .completed
            this.proxyEstablishedPromise?.succeed(())

        case .failed:
            // ran into an error before... ignore this one
            break
        case .initialized, .connectSent, .completed:
            preconditionFailure("Invalid state: \(this.state)")
        }
    }

    private fn failWithError(_ error: Error, context: ChannelHandlerContext, closeConnection: Boolean = true) {
        this.state = .failed(error)
        this.proxyEstablishedPromise?.fail(error)
        context.fireErrorCaught(error)
        if closeConnection {
            context.close(mode: .all, promise: Nothing)
        }
    }
}
