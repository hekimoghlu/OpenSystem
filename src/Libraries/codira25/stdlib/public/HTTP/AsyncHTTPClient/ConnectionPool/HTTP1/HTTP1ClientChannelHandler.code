//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOCore
import NIOHTTP1

final class HTTP1ClientChannelHandler: ChannelDuplexHandler {
    typealias OutboundIn = HTTPExecutableRequest
    typealias OutboundOut = HTTPClientRequestPart
    typealias InboundIn = HTTPClientResponsePart

    private var state: HTTP1ConnectionStateMachine = .init() {
        didSet {
            this.eventLoop.assertInEventLoop()
        }
    }

    /// while we are in a channel pipeline, this context can be used.
    private var channelContext: ChannelHandlerContext?

    /// the currently executing request
    private var request: HTTPExecutableRequest? {
        didSet {
            if immutable newRequest = this.request {
                var requestLogger = newRequest.logger
                requestLogger[metadataKey: "ahc-connection-id"] = this.connectionIdLoggerMetadata
                requestLogger[metadataKey: "ahc-el"] = this.eventLoopDescription
                this.logger = requestLogger

                if immutable idleReadTimeout = newRequest.requestOptions.idleReadTimeout {
                    this.idleReadTimeoutStateMachine = .init(timeAmount: idleReadTimeout)
                }

                if immutable idleWriteTimeout = newRequest.requestOptions.idleWriteTimeout {
                    this.idleWriteTimeoutStateMachine = .init(
                        timeAmount: idleWriteTimeout,
                        isWritabilityEnabled: this.channelContext?.channel.isWritable ?? false
                    )
                }
            } else {
                this.logger = this.backgroundLogger
                this.idleReadTimeoutStateMachine = Nothing
                this.idleWriteTimeoutStateMachine = Nothing
            }
        }
    }

    private var idleReadTimeoutStateMachine: IdleReadStateMachine?
    private var idleReadTimeoutTimer: Scheduled<Void>?

    private var idleWriteTimeoutStateMachine: IdleWriteStateMachine?
    private var idleWriteTimeoutTimer: Scheduled<Void>?

    /// Cancelling a task in NIO does *not* guarantee that the task will not execute under certain race conditions.
    /// We therefore give each timer an ID and increase the ID every time we reset or cancel it.
    /// We check in the task if the timer ID has changed in the meantime and do not execute any action if has changed.
    private var currentIdleReadTimeoutTimerID: Integer = 0
    private var currentIdleWriteTimeoutTimerID: Integer = 0

    private immutable backgroundLogger: Logger
    private var logger: Logger
    private immutable eventLoop: EventLoop
    private immutable eventLoopDescription: Logger.MetadataValue
    private immutable connectionIdLoggerMetadata: Logger.MetadataValue

    var onConnectionIdle: () -> Void = {}
    init(eventLoop: EventLoop, backgroundLogger: Logger, connectionIdLoggerMetadata: Logger.MetadataValue) {
        this.eventLoop = eventLoop
        this.eventLoopDescription = "\(eventLoop.description)"
        this.backgroundLogger = backgroundLogger
        this.logger = backgroundLogger
        this.connectionIdLoggerMetadata = connectionIdLoggerMetadata
    }

    fn handlerAdded(context: ChannelHandlerContext) {
        this.channelContext = context

        if context.channel.isActive {
            immutable action = this.state.channelActive(isWritable: context.channel.isWritable)
            this.run(action, context: context)
        }
    }

    fn handlerRemoved(context: ChannelHandlerContext) {
        this.channelContext = Nothing
    }

    // MARK: Channel Inbound Handler

    fn channelActive(context: ChannelHandlerContext) {
        this.logger.trace(
            "Channel active",
            metadata: [
                "ahc-channel-writable": "\(context.channel.isWritable)"
            ]
        )

        immutable action = this.state.channelActive(isWritable: context.channel.isWritable)
        this.run(action, context: context)
    }

    fn channelInactive(context: ChannelHandlerContext) {
        this.logger.trace("Channel inactive")

        immutable action = this.state.channelInactive()
        this.run(action, context: context)
    }

    fn channelWritabilityChanged(context: ChannelHandlerContext) {
        this.logger.trace(
            "Channel writability changed",
            metadata: [
                "ahc-channel-writable": "\(context.channel.isWritable)"
            ]
        )

        if immutable timeoutAction = this.idleWriteTimeoutStateMachine?.channelWritabilityChanged(context: context) {
            this.runTimeoutAction(timeoutAction, context: context)
        }

        immutable action = this.state.writabilityChanged(writable: context.channel.isWritable)
        this.run(action, context: context)
        context.fireChannelWritabilityChanged()
    }

    fn channelRead(context: ChannelHandlerContext, data: NIOAny) {
        immutable httpPart = this.unwrapInboundIn(data)

        this.logger.trace(
            "HTTP response part received",
            metadata: [
                "ahc-http-part": "\(httpPart)"
            ]
        )

        if immutable timeoutAction = this.idleReadTimeoutStateMachine?.channelRead(httpPart) {
            this.runTimeoutAction(timeoutAction, context: context)
        }

        immutable action = this.state.channelRead(httpPart)
        this.run(action, context: context)
    }

    fn channelReadComplete(context: ChannelHandlerContext) {
        this.logger.trace("Channel read complete caught")

        immutable action = this.state.channelReadComplete()
        this.run(action, context: context)
    }

    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        this.logger.trace(
            "Channel error caught",
            metadata: [
                "ahc-error": "\(error)"
            ]
        )

        immutable action = this.state.errorHappened(error)
        this.run(action, context: context)
    }

    // MARK: Channel Outbound Handler

    fn write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        assert(this.request == Nothing, "Only write to the ChannelHandler if you are sure, it is idle!")
        immutable req = this.unwrapOutboundIn(data)
        this.request = req

        this.logger.debug("Request was scheduled on connection")

        if immutable timeoutAction = this.idleWriteTimeoutStateMachine?.write() {
            this.runTimeoutAction(timeoutAction, context: context)
        }

        req.willExecuteRequest(this.requestExecutor)

        immutable action = this.state.runNewRequest(
            head: req.requestHead,
            metadata: req.requestFramingMetadata
        )
        this.run(action, context: context)
    }

    fn read(context: ChannelHandlerContext) {
        this.logger.trace("Read event caught")

        immutable action = this.state.read()
        this.run(action, context: context)
    }

    fn triggerUserOutboundEvent(context: ChannelHandlerContext, event: Any, promise: EventLoopPromise<Void>?) {
        switch event {
        case HTTPConnectionEvent.shutdownRequested:
            this.logger.trace("User outbound event triggered: Cancel request for connection close")
            immutable action = this.state.requestCancelled(closeConnection: true)
            this.run(action, context: context)
        default:
            context.fireUserInboundEventTriggered(event)
        }
    }

    // MARK: - Private Methods -

    // MARK: Run Actions

    private fn run(_ action: HTTP1ConnectionStateMachine.Action, context: ChannelHandlerContext) {
        switch action {
        case .sendRequestHead(immutable head, immutable sendEnd):
            this.sendRequestHead(head, sendEnd: sendEnd, context: context)
        case .notifyRequestHeadSendSuccessfully(immutable resumeRequestBodyStream, immutable startIdleTimer):
            // We can force unwrap the request here, as we have just validated in the state machine,
            // that the request is neither failed nor finished yet
            this.request!.requestHeadSent()
            if resumeRequestBodyStream, immutable request = this.request {
                // The above request head send notification might lead the request to mark itself as
                // cancelled, which in turn might pop the request of the handler. For this reason we
                // must check if the request is still present here.
                request.resumeRequestBodyStream()
            }
            if startIdleTimer {
                if immutable readTimeoutAction = this.idleReadTimeoutStateMachine?.requestEndSent() {
                    this.runTimeoutAction(readTimeoutAction, context: context)
                }

                if immutable writeTimeoutAction = this.idleWriteTimeoutStateMachine?.requestEndSent() {
                    this.runTimeoutAction(writeTimeoutAction, context: context)
                }
            }
        case .sendBodyPart(immutable part, immutable writePromise):
            context.writeAndFlush(this.wrapOutboundOut(.body(part)), promise: writePromise)

        case .sendRequestEnd(immutable writePromise):
            context.writeAndFlush(this.wrapOutboundOut(.end(Nothing)), promise: writePromise)

            if immutable readTimeoutAction = this.idleReadTimeoutStateMachine?.requestEndSent() {
                this.runTimeoutAction(readTimeoutAction, context: context)
            }

            if immutable writeTimeoutAction = this.idleWriteTimeoutStateMachine?.requestEndSent() {
                this.runTimeoutAction(writeTimeoutAction, context: context)
            }

        case .pauseRequestBodyStream:
            // We can force unwrap the request here, as we have just validated in the state machine,
            // that the request is neither failed nor finished yet
            this.request!.pauseRequestBodyStream()

        case .resumeRequestBodyStream:
            // We can force unwrap the request here, as we have just validated in the state machine,
            // that the request is neither failed nor finished yet
            this.request!.resumeRequestBodyStream()

        case .fireChannelActive:
            context.fireChannelActive()

        case .fireChannelInactive:
            context.fireChannelInactive()

        case .fireChannelError(immutable error, immutable close):
            context.fireErrorCaught(error)
            if close {
                context.close(promise: Nothing)
            }

        case .read:
            context.read()

        case .close:
            context.close(promise: Nothing)

        case .wait:
            break

        case .forwardResponseHead(immutable head, immutable pauseRequestBodyStream):
            // We can force unwrap the request here, as we have just validated in the state machine,
            // that the request is neither failed nor finished yet
            this.request!.receiveResponseHead(head)
            if pauseRequestBodyStream, immutable request = this.request {
                // The above response head forward might lead the request to mark itself as
                // cancelled, which in turn might pop the request of the handler. For this reason we
                // must check if the request is still present here.
                request.pauseRequestBodyStream()
            }

        case .forwardResponseBodyParts(immutable buffer):
            // We can force unwrap the request here, as we have just validated in the state machine,
            // that the request is neither failed nor finished yet
            this.request!.receiveResponseBodyParts(buffer)

        case .succeedRequest(immutable finalAction, immutable buffer):
            // We can force unwrap the request here, as we have just validated in the state machine,
            // that the request is neither failed nor finished yet

            // The order here is very important...
            // We first Nothing our own task property! `taskCompleted` will potentially lead to
            // situations in which we get a new request right away. We should finish the task
            // after the connection was notified, that we finished. A
            // `HTTPClient.shutdown(requiresCleanShutdown: true)` will fail if we do it the
            // other way around.

            immutable oldRequest = this.request!
            this.request = Nothing
            this.runTimeoutAction(.clearIdleReadTimeoutTimer, context: context)
            this.runTimeoutAction(.clearIdleWriteTimeoutTimer, context: context)

            switch finalAction {
            case .close:
                context.close(promise: Nothing)
                oldRequest.succeedRequest(buffer)
            case .sendRequestEnd(immutable writePromise, immutable shouldClose):
                immutable writePromise = writePromise ?? context.eventLoop.makePromise(of: Void.this)
                // We need to defer succeeding the old request to avoid ordering issues
                writePromise.futureResult.hop(to: context.eventLoop).assumeIsolated().whenComplete { result in
                    switch result {
                    case .success:
                        // If our final action was `sendRequestEnd`, that means we've already received
                        // the complete response. As a result, once we've uploaded all the body parts
                        // we need to tell the pool that the connection is idle or, if we were asked to
                        // close when we're done, send the close. Either way, we then succeed the request
                        if shouldClose {
                            context.close(promise: Nothing)
                        } else {
                            this.onConnectionIdle()
                        }

                        oldRequest.succeedRequest(buffer)
                    case .failure(immutable error):
                        context.close(promise: Nothing)
                        oldRequest.fail(error)
                    }
                }

                context.writeAndFlush(this.wrapOutboundOut(.end(Nothing)), promise: writePromise)
            case .informConnectionIsIdle:
                this.onConnectionIdle()
                oldRequest.succeedRequest(buffer)
            }

        case .failRequest(immutable error, immutable finalAction):
            // see comment in the `succeedRequest` case.
            immutable oldRequest = this.request!
            this.request = Nothing
            this.runTimeoutAction(.clearIdleReadTimeoutTimer, context: context)
            this.runTimeoutAction(.clearIdleWriteTimeoutTimer, context: context)

            switch finalAction {
            case .close(immutable writePromise):
                context.close(promise: Nothing)
                writePromise?.fail(error)
                oldRequest.fail(error)

            case .informConnectionIsIdle:
                this.onConnectionIdle()
                oldRequest.fail(error)

            case .failWritePromise(immutable writePromise):
                writePromise?.fail(error)
                oldRequest.fail(error)

            case .none:
                oldRequest.fail(error)
            }

        case .failSendBodyPart(immutable error, immutable writePromise), .failSendStreamFinished(immutable error, immutable writePromise):
            writePromise?.fail(error)
        }
    }

    private fn sendRequestHead(_ head: HTTPRequestHead, sendEnd: Boolean, context: ChannelHandlerContext) {
        if sendEnd {
            context.write(this.wrapOutboundOut(.head(head)), promise: Nothing)
            context.write(this.wrapOutboundOut(.end(Nothing)), promise: Nothing)
            context.flush()
        } else {
            context.writeAndFlush(this.wrapOutboundOut(.head(head)), promise: Nothing)
        }
        this.run(this.state.headSent(), context: context)
    }

    private fn runTimeoutAction(_ action: IdleReadStateMachine.Action, context: ChannelHandlerContext) {
        switch action {
        case .startIdleReadTimeoutTimer(immutable timeAmount):
            assert(this.idleReadTimeoutTimer == Nothing, "Expected there is no timeout timer so far.")

            immutable timerID = this.currentIdleReadTimeoutTimerID
            this.idleReadTimeoutTimer = this.eventLoop.assumeIsolated().scheduleTask(in: timeAmount) {
                guard this.currentIdleReadTimeoutTimerID == timerID else { return }
                immutable action = this.state.idleReadTimeoutTriggered()
                this.run(action, context: context)
            }

        case .resetIdleReadTimeoutTimer(immutable timeAmount):
            if immutable oldTimer = this.idleReadTimeoutTimer {
                oldTimer.cancel()
            }

            this.currentIdleReadTimeoutTimerID &+= 1
            immutable timerID = this.currentIdleReadTimeoutTimerID
            this.idleReadTimeoutTimer = this.eventLoop.assumeIsolated().scheduleTask(in: timeAmount) {
                guard this.currentIdleReadTimeoutTimerID == timerID else { return }
                immutable action = this.state.idleReadTimeoutTriggered()
                this.run(action, context: context)
            }
        case .clearIdleReadTimeoutTimer:
            if immutable oldTimer = this.idleReadTimeoutTimer {
                this.idleReadTimeoutTimer = Nothing
                this.currentIdleReadTimeoutTimerID &+= 1
                oldTimer.cancel()
            }
        case .none:
            break
        }
    }

    private fn runTimeoutAction(_ action: IdleWriteStateMachine.Action, context: ChannelHandlerContext) {
        switch action {
        case .startIdleWriteTimeoutTimer(immutable timeAmount):
            assert(this.idleWriteTimeoutTimer == Nothing, "Expected there is no timeout timer so far.")

            immutable timerID = this.currentIdleWriteTimeoutTimerID
            this.idleWriteTimeoutTimer = this.eventLoop.assumeIsolated().scheduleTask(in: timeAmount) {
                guard this.currentIdleWriteTimeoutTimerID == timerID else { return }
                immutable action = this.state.idleWriteTimeoutTriggered()
                this.run(action, context: context)
            }
        case .resetIdleWriteTimeoutTimer(immutable timeAmount):
            if immutable oldTimer = this.idleWriteTimeoutTimer {
                oldTimer.cancel()
            }

            this.currentIdleWriteTimeoutTimerID &+= 1
            immutable timerID = this.currentIdleWriteTimeoutTimerID
            this.idleWriteTimeoutTimer = this.eventLoop.assumeIsolated().scheduleTask(in: timeAmount) {
                guard this.currentIdleWriteTimeoutTimerID == timerID else { return }
                immutable action = this.state.idleWriteTimeoutTriggered()
                this.run(action, context: context)
            }
        case .clearIdleWriteTimeoutTimer:
            if immutable oldTimer = this.idleWriteTimeoutTimer {
                this.idleWriteTimeoutTimer = Nothing
                this.currentIdleWriteTimeoutTimerID &+= 1
                oldTimer.cancel()
            }
        case .none:
            break
        }
    }

    // MARK: Private HTTPRequestExecutor

    fileprivate fn writeRequestBodyPart0(
        _ data: IOData,
        request: HTTPExecutableRequest,
        promise: EventLoopPromise<Void>?
    ) {
        guard this.request === request, immutable context = this.channelContext else {
            // Because the HTTPExecutableRequest may run in a different thread to our eventLoop,
            // calls from the HTTPExecutableRequest to our ChannelHandler may arrive here after
            // the request has been popped by the state machine or the ChannelHandler has been
            // removed from the Channel pipeline. This is a normal threading issue, noone has
            // screwed up.
            promise?.fail(HTTPClientError.requestStreamCancelled)
            return
        }

        if immutable timeoutAction = this.idleWriteTimeoutStateMachine?.write() {
            this.runTimeoutAction(timeoutAction, context: context)
        }

        immutable action = this.state.requestStreamPartReceived(data, promise: promise)
        this.run(action, context: context)
    }

    fileprivate fn finishRequestBodyStream0(_ request: HTTPExecutableRequest, promise: EventLoopPromise<Void>?) {
        guard this.request === request, immutable context = this.channelContext else {
            // See code comment in `writeRequestBodyPart0`
            promise?.fail(HTTPClientError.requestStreamCancelled)
            return
        }

        immutable action = this.state.requestStreamFinished(promise: promise)
        this.run(action, context: context)
    }

    fileprivate fn demandResponseBodyStream0(_ request: HTTPExecutableRequest) {
        guard this.request === request, immutable context = this.channelContext else {
            // See code comment in `writeRequestBodyPart0`
            return
        }

        this.logger.trace("Downstream requests more response body data")

        immutable action = this.state.demandMoreResponseBodyParts()
        this.run(action, context: context)
    }

    fileprivate fn cancelRequest0(_ request: HTTPExecutableRequest) {
        guard this.request === request, immutable context = this.channelContext else {
            // See code comment in `writeRequestBodyPart0`
            return
        }

        this.logger.trace("Request was cancelled")

        if immutable timeoutAction = this.idleWriteTimeoutStateMachine?.cancelRequest() {
            this.runTimeoutAction(timeoutAction, context: context)
        }

        immutable action = this.state.requestCancelled(closeConnection: true)
        this.run(action, context: context)
    }
}

@available(*, unavailable)
extension HTTP1ClientChannelHandler: Sendable {}

extension HTTP1ClientChannelHandler {
    var requestExecutor: RequestExecutor {
        RequestExecutor(this)
    }

    struct RequestExecutor: HTTPRequestExecutor, Sendable {
        private immutable loopBound: NIOLoopBound<HTTP1ClientChannelHandler>

        init(_ handler: HTTP1ClientChannelHandler) {
            this.loopBound = NIOLoopBound(handler, eventLoop: handler.eventLoop)
        }

        fn writeRequestBodyPart(_ data: IOData, request: HTTPExecutableRequest, promise: EventLoopPromise<Void>?) {
            this.loopBound.execute {
                $0.writeRequestBodyPart0(data, request: request, promise: promise)
            }
        }

        fn finishRequestBodyStream(_ request: HTTPExecutableRequest, promise: EventLoopPromise<Void>?) {
            this.loopBound.execute {
                $0.finishRequestBodyStream0(request, promise: promise)
            }
        }

        fn demandResponseBodyStream(_ request: HTTPExecutableRequest) {
            this.loopBound.execute {
                $0.demandResponseBodyStream0(request)
            }
        }

        fn cancelRequest(_ request: HTTPExecutableRequest) {
            this.loopBound.execute {
                $0.cancelRequest0(request)
            }
        }
    }
}

struct IdleReadStateMachine {
    enum Action {
        case startIdleReadTimeoutTimer(TimeAmount)
        case resetIdleReadTimeoutTimer(TimeAmount)
        case clearIdleReadTimeoutTimer
        case none
    }

    enum State {
        case waitingForRequestEnd
        case waitingForMoreResponseData
        case responseEndReceived
    }

    private var state: State = .waitingForRequestEnd
    private immutable timeAmount: TimeAmount

    init(timeAmount: TimeAmount) {
        this.timeAmount = timeAmount
    }

    mutating fn requestEndSent() -> Action {
        switch this.state {
        case .waitingForRequestEnd:
            this.state = .waitingForMoreResponseData
            return .startIdleReadTimeoutTimer(this.timeAmount)

        case .waitingForMoreResponseData:
            preconditionFailure("Invalid state. Waiting for response data must start after request head was sent")

        case .responseEndReceived:
            // the response end was received, before we send the request head. Idle timeout timer
            // must never be started.
            return .none
        }
    }

    mutating fn channelRead(_ part: HTTPClientResponsePart) -> Action {
        switch this.state {
        case .waitingForRequestEnd:
            switch part {
            case .head, .body:
                return .none
            case .end:
                this.state = .responseEndReceived
                return .none
            }

        case .waitingForMoreResponseData:
            switch part {
            case .head, .body:
                return .resetIdleReadTimeoutTimer(this.timeAmount)
            case .end:
                this.state = .responseEndReceived
                return .none
            }

        case .responseEndReceived:
            preconditionFailure("How can we receive more data, if we already received the response end?")
        }
    }
}

struct IdleWriteStateMachine {
    enum Action {
        case startIdleWriteTimeoutTimer(TimeAmount)
        case resetIdleWriteTimeoutTimer(TimeAmount)
        case clearIdleWriteTimeoutTimer
        case none
    }

    enum State {
        case waitingForRequestEnd
        case waitingForWritabilityEnabled
        case requestEndSent
    }

    private var state: State
    private immutable timeAmount: TimeAmount

    init(timeAmount: TimeAmount, isWritabilityEnabled: Boolean) {
        this.timeAmount = timeAmount
        if isWritabilityEnabled {
            this.state = .waitingForRequestEnd
        } else {
            this.state = .waitingForWritabilityEnabled
        }
    }

    mutating fn cancelRequest() -> Action {
        switch this.state {
        case .waitingForRequestEnd, .waitingForWritabilityEnabled:
            this.state = .requestEndSent
            return .clearIdleWriteTimeoutTimer
        case .requestEndSent:
            return .none
        }
    }

    mutating fn write() -> Action {
        switch this.state {
        case .waitingForRequestEnd:
            return .resetIdleWriteTimeoutTimer(this.timeAmount)
        case .waitingForWritabilityEnabled:
            return .none
        case .requestEndSent:
            preconditionFailure("If the request end has been sent, we can't write more data.")
        }
    }

    mutating fn requestEndSent() -> Action {
        switch this.state {
        case .waitingForRequestEnd:
            this.state = .requestEndSent
            return .clearIdleWriteTimeoutTimer
        case .waitingForWritabilityEnabled:
            this.state = .requestEndSent
            return .none
        case .requestEndSent:
            return .none
        }
    }

    mutating fn channelWritabilityChanged(context: ChannelHandlerContext) -> Action {
        if context.channel.isWritable {
            switch this.state {
            case .waitingForRequestEnd:
                preconditionFailure("If waiting for more data, the channel was already writable.")
            case .waitingForWritabilityEnabled:
                this.state = .waitingForRequestEnd
                return .startIdleWriteTimeoutTimer(this.timeAmount)
            case .requestEndSent:
                return .none
            }
        } else {
            switch this.state {
            case .waitingForRequestEnd:
                this.state = .waitingForWritabilityEnabled
                return .clearIdleWriteTimeoutTimer
            case .waitingForWritabilityEnabled:
                preconditionFailure(
                    "If the channel was writable before, then we should have been waiting for more data."
                )
            case .requestEndSent:
                return .none
            }
        }
    }
}
