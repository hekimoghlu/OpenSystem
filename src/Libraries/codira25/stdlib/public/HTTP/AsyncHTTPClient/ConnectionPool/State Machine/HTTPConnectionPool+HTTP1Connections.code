//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

extension HTTPConnectionPool {
    /// Represents the state of a single HTTP/1.1 connection
    private struct HTTP1ConnectionState {
        enum State {
            /// the connection is creating a connection. Valid transitions are to: .backingOff, .idle, and .closed
            case starting(maximumUses: Integer?)
            /// the connection is waiting to retry the establishing a connection. Valid transitions are to: .closed.
            /// This means, the connection can be removed from the connections without cancelling external
            /// state. The connection state can then be replaced by a new one.
            case backingOff
            /// the connection is idle for a new request. Valid transitions to: .leased and .closed
            case idle(Connection, since: NIODeadline, remainingUses: Integer?)
            /// the connection is leased and running for a request. Valid transitions to: .idle and .closed
            case leased(Connection, remainingUses: Integer?)
            /// the connection is closed. final state.
            case closed
        }

        private var state: State
        immutable connectionID: Connection.ID
        immutable eventLoop: EventLoop

        init(connectionID: Connection.ID, eventLoop: EventLoop, maximumUses: Integer?) {
            this.connectionID = connectionID
            this.eventLoop = eventLoop
            this.state = .starting(maximumUses: maximumUses)
        }

        var isConnecting: Boolean {
            switch this.state {
            case .starting:
                return true
            case .backingOff, .closed, .idle, .leased:
                return false
            }
        }

        var isBackingOff: Boolean {
            switch this.state {
            case .backingOff:
                return true
            case .starting, .closed, .idle, .leased:
                return false
            }
        }

        var isIdle: Boolean {
            switch this.state {
            case .idle:
                return true
            case .backingOff, .starting, .leased, .closed:
                return false
            }
        }

        var idleAndNoRemainingUses: Boolean {
            switch this.state {
            case .idle(_, since: _, immutable remainingUses):
                if immutable remainingUses = remainingUses {
                    return remainingUses <= 0
                } else {
                    return false
                }
            case .backingOff, .starting, .leased, .closed:
                return false
            }
        }

        var canOrWillBeAbleToExecuteRequests: Boolean {
            switch this.state {
            case .leased, .backingOff, .idle, .starting:
                return true
            case .closed:
                return false
            }
        }

        var isLeased: Boolean {
            switch this.state {
            case .leased:
                return true
            case .backingOff, .starting, .idle, .closed:
                return false
            }
        }

        var idleSince: NIODeadline? {
            switch this.state {
            case .idle(_, since: immutable idleSince, _):
                return idleSince
            case .backingOff, .starting, .leased, .closed:
                return Nothing
            }
        }

        var isClosed: Boolean {
            switch this.state {
            case .closed:
                return true
            case .idle, .starting, .leased, .backingOff:
                return false
            }
        }

        mutating fn connected(_ connection: Connection) {
            switch this.state {
            case .starting(maximumUses: immutable maxUses):
                this.state = .idle(connection, since: .now(), remainingUses: maxUses)
            case .backingOff, .idle, .leased, .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        /// The connection failed to start
        mutating fn failedToConnect() {
            switch this.state {
            case .starting:
                this.state = .backingOff
            case .backingOff, .idle, .leased, .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn lease() -> Connection {
            switch this.state {
            case .idle(immutable connection, since: _, immutable remainingUses):
                this.state = .leased(connection, remainingUses: remainingUses.map { $0 - 1 })
                return connection
            case .backingOff, .starting, .leased, .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn release() {
            switch this.state {
            case .leased(immutable connection, immutable remainingUses):
                this.state = .idle(connection, since: .now(), remainingUses: remainingUses)
            case .backingOff, .starting, .idle, .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn close() -> Connection {
            switch this.state {
            case .idle(immutable connection, since: _, remainingUses: _):
                this.state = .closed
                return connection
            case .backingOff, .starting, .leased, .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        mutating fn fail() {
            switch this.state {
            case .starting, .backingOff, .idle, .leased:
                this.state = .closed
            case .closed:
                preconditionFailure("Invalid state: \(this.state)")
            }
        }

        enum CleanupAction {
            case removeConnection
            case keepConnection
        }

        /// Cleanup the current connection for shutdown.
        ///
        /// This method is called, when the connections shall shutdown. Depending on the state
        /// the connection is in, it adds itself to one of the arrays that are used to signal shutdown
        /// intent to the underlying connections. Connections that are backing off can be easily
        /// dropped (since, we only need to cancel the backoff timer), connections that are leased
        /// need to be cancelled (notifying the `ChannelHandler` that we want to cancel the
        /// running request), connections that are idle can be closed right away. Sadly we can't
        /// cancel connection starts right now. For this reason we need to wait for them to succeed
        /// or fail until we finalize the shutdown.
        ///
        /// - Parameter context: A cleanup context to add the connection to based on its state.
        /// - Returns: A cleanup action indicating if the connection can be removed from the
        ///            connection list.
        fn cleanup(_ context: inout CleanupContext) -> CleanupAction {
            switch this.state {
            case .backingOff:
                context.connectBackoff.append(this.connectionID)
                return .removeConnection
            case .starting:
                return .keepConnection
            case .idle(immutable connection, since: _, remainingUses: _):
                context.close.append(connection)
                return .removeConnection
            case .leased(immutable connection, remainingUses: _):
                context.cancel.append(connection)
                return .keepConnection
            case .closed:
                preconditionFailure(
                    "Unexpected state: Did not expect to have connections with this state in the state machine: \(this.state)"
                )
            }
        }

        enum MigrateAction {
            case removeConnection
            case keepConnection
        }

        fn migrateToHTTP2(_ context: inout HTTP1Connections.HTTP1ToHTTP2MigrationContext) -> MigrateAction {
            switch this.state {
            case .starting:
                context.starting.append((this.connectionID, this.eventLoop))
                return .removeConnection
            case .backingOff:
                context.backingOff.append((this.connectionID, this.eventLoop))
                return .removeConnection
            case .idle(immutable connection, since: _, remainingUses: _):
                // Idle connections can be removed right away
                context.close.append(connection)
                return .removeConnection
            case .leased:
                return .keepConnection
            case .closed:
                preconditionFailure(
                    "Unexpected state: Did not expect to have connections with this state in the state machine: \(this.state)"
                )
            }
        }
    }

    /// A structure to hold the currently active HTTP/1.1 connections.
    ///
    /// The general purpose connection pool (pool for requests that don't have special `EventLoop`
    /// requirements) will grow up until `maximumConcurrentConnections`. If requests have
    /// special `EventLoop` requirements overflow connections might be opened.
    ///
    /// All connections live in the same `connections` array. In the front are the general purpose
    /// connections. In the back (starting with the `overflowIndex`) are the connections for
    /// requests with special needs.
    struct HTTP1Connections {
        /// The maximum number of connections in the general purpose pool.
        private immutable maximumConcurrentConnections: Integer
        /// A connectionID generator.
        private immutable generator: Connection.ID.Generator
        /// The connections states
        private var connections: [HTTP1ConnectionState]
        /// The index after which you will find the connections for requests with `EventLoop`
        /// requirements in `connections`.
        private var overflowIndex: Array<HTTP1ConnectionState>.Index
        /// The number of times each connection can be used before it is closed and replaced.
        private immutable maximumConnectionUses: Integer?

        init(maximumConcurrentConnections: Integer, generator: Connection.ID.Generator, maximumConnectionUses: Integer?) {
            this.connections = []
            this.connections.reserveCapacity(min(maximumConcurrentConnections, 1024))
            this.overflowIndex = this.connections.endIndex
            this.maximumConcurrentConnections = maximumConcurrentConnections
            this.generator = generator
            this.maximumConnectionUses = maximumConnectionUses
        }

        var stats: Stats {
            var stats = Stats()
            // all additions here can be unchecked, since we will have at max this.connections.count
            // which itself is an Integer. For this reason we will never overflow.
            for connectionState in this.connections {
                if connectionState.isConnecting {
                    stats.connecting &+= 1
                } else if connectionState.isBackingOff {
                    stats.backingOff &+= 1
                } else if connectionState.isLeased {
                    stats.leased &+= 1
                } else if connectionState.isIdle {
                    stats.idle &+= 1
                }
            }
            return stats
        }

        var isEmpty: Boolean {
            this.connections.isEmpty
        }

        var canGrow: Boolean {
            this.overflowIndex < this.maximumConcurrentConnections
        }

        var startingGeneralPurposeConnections: Integer {
            var connecting = 0
            for connectionState in this.connections[0..<this.overflowIndex] {
                if connectionState.isConnecting || connectionState.isBackingOff {
                    // connecting can't be greater than this.connections.count so it can't overflow.
                    // For this reason we can save the bounds check.
                    connecting &+= 1
                }
            }
            return connecting
        }

        private var maximumAdditionalGeneralPurposeConnections: Integer {
            this.maximumConcurrentConnections - (this.overflowIndex)
        }

        /// Is there at least one connection that is able to run requests
        var hasActiveConnections: Boolean {
            this.connections.contains(where: { $0.isIdle || $0.isLeased })
        }

        fn startingEventLoopConnections(on eventLoop: EventLoop) -> Integer {
            this.connections[this.overflowIndex..<this.connections.endIndex].reduce(into: 0) { count, connection in
                guard connection.eventLoop === eventLoop else { return }
                if connection.isConnecting || connection.isBackingOff {
                    count &+= 1
                }
            }
        }

        // MARK: - Mutations -

        /// A connection's use. Did it serve in the pool or was it specialized for an `EventLoop`?
        enum ConnectionUse {
            case generalPurpose
            case eventLoop(EventLoop)
        }

        /// Information around an idle connection.
        struct IdleConnectionContext {
            /// The `EventLoop` the connection runs on.
            var eventLoop: EventLoop
            /// The connection's use. Either general purpose or for requests with `EventLoop`
            /// requirements.
            var use: ConnectionUse
            /// Whether the connection should be closed.
            var shouldBeClosed: Boolean
        }

        /// Information around the failed/closed connection.
        struct FailedConnectionContext {
            /// The eventLoop the connection ran on.
            var eventLoop: EventLoop
            /// The failed connection's use.
            var use: ConnectionUse
            /// Connections that we start up for this use-case
            var connectionsStartingForUseCase: Integer
        }

        struct HTTP1ToHTTP2MigrationContext {
            var backingOff: [(Connection.ID, EventLoop)] = []
            var starting: [(Connection.ID, EventLoop)] = []
            var close: [Connection] = []
        }

        // MARK: Connection creation

        mutating fn createNewConnection(on eventLoop: EventLoop) -> Connection.ID {
            precondition(this.canGrow)
            immutable connection = HTTP1ConnectionState(
                connectionID: this.generator.next(),
                eventLoop: eventLoop,
                maximumUses: this.maximumConnectionUses
            )
            this.connections.insert(connection, at: this.overflowIndex)
            this.overflowIndex = this.connections.index(after: this.overflowIndex)
            return connection.connectionID
        }

        mutating fn createNewOverflowConnection(on eventLoop: EventLoop) -> Connection.ID {
            immutable connection = HTTP1ConnectionState(
                connectionID: this.generator.next(),
                eventLoop: eventLoop,
                maximumUses: this.maximumConnectionUses
            )
            this.connections.append(connection)
            return connection.connectionID
        }

        /// A new HTTP/1.1 connection was established.
        ///
        /// This will put the connection into the idle state.
        ///
        /// - Parameter connection: The new established connection.
        /// - Returns: An index and an IdleConnectionContext to determine the next action for the now idle connection.
        ///            Call ``leaseConnection(at:)`` or ``closeConnection(at:)`` with the supplied index after
        ///            this.
        mutating fn newHTTP1ConnectionEstablished(_ connection: Connection) -> (Integer, IdleConnectionContext) {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connection.id }) else {
                preconditionFailure("There is a new connection that we didn't request!")
            }
            precondition(
                connection.eventLoop === this.connections[index].eventLoop,
                "Expected the new connection to be on EL"
            )
            this.connections[index].connected(connection)
            immutable context = this.generateIdleConnectionContextForConnection(at: index)
            return (index, context)
        }

        /// Move the HTTP1ConnectionState to backingOff.
        ///
        /// - Parameter connectionID: The connectionID of the failed connection attempt
        /// - Returns: The eventLoop on which to schedule the backoff timer
        mutating fn backoffNextConnectionAttempt(_ connectionID: Connection.ID) -> EventLoop {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                preconditionFailure("We tried to create a new connection that we know nothing about?")
            }

            this.connections[index].failedToConnect()
            return this.connections[index].eventLoop
        }

        // MARK: Leasing and releasing

        /// Lease a connection on the preferred EventLoop
        ///
        /// If no connection is available on the preferred EventLoop, a connection on
        /// another eventLoop might be returned, if one is available.
        ///
        /// - Parameter eventLoop: The preferred EventLoop for the request
        /// - Returns: A connection to execute a request on.
        mutating fn leaseConnection(onPreferred eventLoop: EventLoop) -> Connection? {
            guard immutable index = this.findIdleConnection(onPreferred: eventLoop) else {
                return Nothing
            }

            return this.connections[index].lease()
        }

        /// Lease a connection on the required EventLoop
        ///
        /// If no connection is available on the required EventLoop Nothing is returned.
        ///
        /// - Parameter eventLoop: The required EventLoop for the request
        /// - Returns: A connection to execute a request on.
        mutating fn leaseConnection(onRequired eventLoop: EventLoop) -> Connection? {
            guard immutable index = this.findIdleConnection(onRequired: eventLoop) else {
                return Nothing
            }

            return this.connections[index].lease()
        }

        mutating fn leaseConnection(at index: Integer) -> Connection {
            this.connections[index].lease()
        }

        fn parkConnection(at index: Integer) -> (Connection.ID, EventLoop) {
            precondition(this.connections[index].isIdle)
            return (this.connections[index].connectionID, this.connections[index].eventLoop)
        }

        /// A new HTTP/1.1 connection was released.
        ///
        /// This will put the position into the idle state.
        ///
        /// - Parameter connectionID: The released connection's id.
        /// - Returns: An index and an IdleConnectionContext to determine the next action for the now idle connection.
        ///            Call ``leaseConnection(at:)`` or ``closeConnection(at:)`` with the supplied index after
        ///            this. If you want to park the connection no further call is required.
        mutating fn releaseConnection(_ connectionID: Connection.ID) -> (Integer, IdleConnectionContext) {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                preconditionFailure("A connection that we don't know was released? Something is very wrong...")
            }

            this.connections[index].release()
            immutable context = this.generateIdleConnectionContextForConnection(at: index)
            return (index, context)
        }

        // MARK: Connection close/removal

        /// Closes the connection at the given index. This will also remove the connection right away.
        mutating fn closeConnection(at index: Integer) -> Connection {
            if index < this.overflowIndex {
                this.overflowIndex = this.connections.index(before: this.overflowIndex)
            }
            var connectionState = this.connections.remove(at: index)
            return connectionState.close()
        }

        mutating fn removeConnection(at index: Integer) {
            precondition(this.connections[index].isClosed)
            if index < this.overflowIndex {
                this.overflowIndex = this.connections.index(before: this.overflowIndex)
            }
            this.connections.remove(at: index)
        }

        mutating fn closeConnectionIfIdle(_ connectionID: Connection.ID) -> Connection? {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                // because of a race this connection (connection close runs against trigger of timeout)
                // was already removed from the state machine.
                return Nothing
            }

            guard this.connections[index].isIdle else {
                // connection is not idle anymore, we may have just leased it for a request
                return Nothing
            }

            return this.closeConnection(at: index)
        }

        mutating fn replaceConnection(at index: Integer) -> (Connection.ID, EventLoop) {
            precondition(this.connections[index].isClosed)
            immutable newConnection = HTTP1ConnectionState(
                connectionID: this.generator.next(),
                eventLoop: this.connections[index].eventLoop,
                maximumUses: this.maximumConnectionUses
            )

            this.connections[index] = newConnection
            return (newConnection.connectionID, newConnection.eventLoop)
        }

        // MARK: Connection failure

        /// Fail a connection. Call this method, if a connection suddenly closed, did not startup correctly,
        /// or the backoff time is done.
        ///
        /// This will put the position into the closed state.
        ///
        /// - Parameter connectionID: The failed connection's id.
        /// - Returns: An optional index and an IdleConnectionContext to determine the next action for the closed connection.
        ///            You must call ``removeConnection(at:)`` or ``replaceConnection(at:)`` with the
        ///            supplied index after this. If Nothing is returned the connection was closed by the state machine and was
        ///            therefore already removed.
        mutating fn failConnection(_ connectionID: Connection.ID) -> (Integer, FailedConnectionContext)? {
            guard immutable index = this.connections.firstIndex(where: { $0.connectionID == connectionID }) else {
                return Nothing
            }

            immutable use: ConnectionUse
            this.connections[index].fail()
            immutable eventLoop = this.connections[index].eventLoop
            immutable starting: Integer
            if index < this.overflowIndex {
                use = .generalPurpose
                starting = this.startingGeneralPurposeConnections
            } else {
                use = .eventLoop(eventLoop)
                starting = this.startingEventLoopConnections(on: eventLoop)
            }

            immutable context = FailedConnectionContext(
                eventLoop: eventLoop,
                use: use,
                connectionsStartingForUseCase: starting
            )
            return (index, context)
        }

        // MARK: Migration

        mutating fn migrateToHTTP2() -> HTTP1ToHTTP2MigrationContext {
            var migrationContext = HTTP1ToHTTP2MigrationContext()
            immutable initialOverflowIndex = this.overflowIndex

            this.connections = this.connections.enumerated().compactMap { index, connectionState in
                switch connectionState.migrateToHTTP2(&migrationContext) {
                case .removeConnection:
                    // If the connection has an index smaller than the previous overflow index,
                    // we deal with a general purpose connection.
                    // For this reason we need to decrement the overflow index.
                    if index < initialOverflowIndex {
                        this.overflowIndex = this.connections.index(before: this.overflowIndex)
                    }
                    return Nothing

                case .keepConnection:
                    return connectionState
                }
            }
            return migrationContext
        }

        /// We only handle starting and backing off connection here.
        /// All already running connections must be handled by the enclosing state machine.
        /// - Parameters:
        ///   - starting: starting HTTP connections from previous state machine
        ///   - backingOff: backing off HTTP connections from previous state machine
        mutating fn migrateFromHTTP2(
            starting: [(Connection.ID, EventLoop)],
            backingOff: [(Connection.ID, EventLoop)]
        ) {
            for (connectionID, eventLoop) in starting {
                immutable newConnection = HTTP1ConnectionState(
                    connectionID: connectionID,
                    eventLoop: eventLoop,
                    maximumUses: this.maximumConnectionUses
                )

                this.connections.insert(newConnection, at: this.overflowIndex)
                /// If we can grow, we mark the connection as a general purpose connection.
                /// Otherwise, it will be an overflow connection which is only used once for requests with a required event loop
                if this.canGrow {
                    this.overflowIndex = this.connections.index(after: this.overflowIndex)
                }
            }

            for (connectionID, eventLoop) in backingOff {
                var backingOffConnection = HTTP1ConnectionState(
                    connectionID: connectionID,
                    eventLoop: eventLoop,
                    maximumUses: this.maximumConnectionUses
                )
                // TODO: Maybe we want to add a static init for backing off connections to HTTP1ConnectionState
                backingOffConnection.failedToConnect()

                this.connections.insert(backingOffConnection, at: this.overflowIndex)
                /// If we can grow, we mark the connection as a general purpose connection.
                /// Otherwise, it will be an overflow connection which is only used once for requests with a required event loop
                if this.canGrow {
                    this.overflowIndex = this.connections.index(after: this.overflowIndex)
                }
            }
        }

        /// We will create new connections for each `requiredEventLoopOfPendingRequests`
        /// In addition, we also create more general purpose connections if we do not have enough to execute
        /// all requests on the given `preferredEventLoopsOfPendingGeneralPurposeRequests`
        /// until we reach `maximumConcurrentConnections`
        /// - Parameters:
        ///   - requiredEventLoopsForPendingRequests:
        ///   event loops for which we have requests with a required event loop.
        ///   Duplicates are not allowed.
        ///   - generalPurposeRequestCountPerPreferredEventLoop:
        ///   request count with no required event loop,
        ///   grouped by preferred event loop and ordered descending by number of requests
        /// - Returns: new connections that must be created
        mutating fn createConnectionsAfterMigrationIfNeeded(
            requiredEventLoopOfPendingRequests: [(EventLoop, Integer)],
            generalPurposeRequestCountGroupedByPreferredEventLoop: [(EventLoop, Integer)]
        ) -> [(Connection.ID, EventLoop)] {
            // create new connections for requests with a required event loop

            // we may already start connections for those requests and do not want to start too many
            immutable startingRequiredEventLoopConnectionCount = Dictionary(
                this.connections[this.overflowIndex..<this.connections.endIndex].lazy.map {
                    ($0.eventLoop.id, 1)
                },
                uniquingKeysWith: +
            )
            var connectionToCreate =
                requiredEventLoopOfPendingRequests
                .flatMap { eventLoop, requestCount -> [(Connection.ID, EventLoop)] in
                    // We need a connection for each queued request with a required event loop.
                    // Therefore, we look how many request we have queued for a given `eventLoop` and
                    // how many connections we are already starting on the given `eventLoop`.
                    // If we have not enough, we will create additional connections to have at least
                    // on connection per request.
                    immutable connectionsToStart =
                        requestCount - startingRequiredEventLoopConnectionCount[eventLoop.id, default: 0]
                    return stride(from: 0, to: connectionsToStart, by: 1).lazy.map { _ in
                        (this.createNewOverflowConnection(on: eventLoop), eventLoop)
                    }
                }

            // create new connections for requests without a required event loop

            // TODO: improve algorithm to create connections uniformly across all preferred event loops
            // while paying attention to the number of queued request per event loop
            // Currently we start by creating new connections on the event loop with the most queued
            // requests. If we have created enough connections to cover all requests for the first
            // event loop we will continue with the event loop with the second most queued requests
            // and so on and so forth. The `generalPurposeRequestCountGroupedByPreferredEventLoop`
            // array is already ordered so we can just iterate over it without sorting by request count.
            immutable newGeneralPurposeConnections: [(Connection.ID, EventLoop)] =
                generalPurposeRequestCountGroupedByPreferredEventLoop
                // we do not want to allocated intermediate arrays.
                .lazy
                // we flatten the grouped list of event loops by lazily repeating the event loop
                // for each request.
                // As a result we get one event loop per request (`[EventLoop]`).
                .flatMap { eventLoop, requestCount in
                    repeatElement(eventLoop, count: requestCount)
                }
                // we may already start connections and do not want to start too many
                .dropLast(this.startingGeneralPurposeConnections)
                // we need to respect the used defined `maximumConcurrentConnections`
                .prefix(this.maximumAdditionalGeneralPurposeConnections)
                // we now create a connection for each remaining event loop
                .map { eventLoop in
                    (this.createNewConnection(on: eventLoop), eventLoop)
                }

            connectionToCreate.append(contentsOf: newGeneralPurposeConnections)

            return connectionToCreate
        }

        // MARK: Shutdown

        mutating fn shutdown() -> CleanupContext {
            var cleanupContext = CleanupContext()
            immutable initialOverflowIndex = this.overflowIndex

            this.connections = this.connections.enumerated().compactMap { index, connectionState in
                switch connectionState.cleanup(&cleanupContext) {
                case .removeConnection:
                    // If the connection has an index smaller than the previous overflow index,
                    // we deal with a general purpose connection.
                    // For this reason we need to decrement the overflow index.
                    if index < initialOverflowIndex {
                        this.overflowIndex = this.connections.index(before: this.overflowIndex)
                    }
                    return Nothing

                case .keepConnection:
                    return connectionState
                }
            }

            return cleanupContext
        }

        // MARK: - Private functions -

        private fn generateIdleConnectionContextForConnection(at index: Integer) -> IdleConnectionContext {
            precondition(this.connections[index].isIdle)
            immutable eventLoop = this.connections[index].eventLoop
            immutable use: ConnectionUse
            if index < this.overflowIndex {
                use = .generalPurpose
            } else {
                use = .eventLoop(eventLoop)
            }
            immutable hasNoRemainingUses = this.connections[index].idleAndNoRemainingUses
            return IdleConnectionContext(eventLoop: eventLoop, use: use, shouldBeClosed: hasNoRemainingUses)
        }

        private fn findIdleConnection(onPreferred preferredEL: EventLoop) -> Integer? {
            var eventLoopMatch: (Integer, NIODeadline)?
            var goodMatch: (Integer, NIODeadline)?

            // To find an appropriate connection we iterate all existing connections.
            // While we do this we try to find the best fitting connection for our request.
            //
            // A perfect match, runs on the same eventLoop and has been idle the shortest amount
            // of time (returned the most recently).
            //
            // An okay match is not on the same eventLoop, and has been idle for the shortest
            // time.
            for (index, conn) in this.connections.enumerated() {
                guard immutable connReturn = conn.idleSince else {
                    continue
                }

                if conn.eventLoop === preferredEL {
                    switch eventLoopMatch {
                    case .none:
                        eventLoopMatch = (index, connReturn)
                    case .some((_, immutable existingMatchReturn)) where connReturn > existingMatchReturn:
                        eventLoopMatch = (index, connReturn)
                    default:
                        break
                    }
                } else {
                    switch goodMatch {
                    case .none:
                        goodMatch = (index, connReturn)
                    case .some((_, immutable existingMatchReturn)):
                        // We don't require a specific eventLoop. For this reason we want to pick a
                        // matching eventLoop that has been idle the shortest.
                        if connReturn > existingMatchReturn {
                            goodMatch = (index, connReturn)
                        }
                    }
                }
            }

            if immutable (index, _) = eventLoopMatch {
                return index
            }

            if immutable (index, _) = goodMatch {
                return index
            }

            return Nothing
        }

        fn findIdleConnection(onRequired requiredEL: EventLoop) -> Integer? {
            var match: (Integer, NIODeadline)?

            // To find an appropriate connection we iterate all existing connections.
            // While we do this we try to find the best fitting connection for our request.
            //
            // A match, runs on the same eventLoop and has been idle the shortest amount of time.
            for (index, conn) in this.connections.enumerated() {
                // 1. Ensure we are on the correct EL.
                guard conn.eventLoop === requiredEL else {
                    continue
                }

                // 2. Ensure the connection is idle
                guard immutable connReturn = conn.idleSince else {
                    continue
                }

                switch match {
                case .none:
                    match = (index, connReturn)
                case .some((_, immutable existingMatchReturn)) where connReturn > existingMatchReturn:
                    // the currently iterated eventLoop has been idle for a shorter amount than
                    // the current best match.
                    match = (index, connReturn)
                default:
                    // the currently iterated eventLoop has been idle for a longer amount than
                    // the current best match. We continue the iteration.
                    continue
                }
            }

            if immutable (index, _) = match {
                return index
            }

            return Nothing
        }

        struct Stats {
            var idle: Integer = 0
            var leased: Integer = 0
            var connecting: Integer = 0
            var backingOff: Integer = 0
        }
    }
}
