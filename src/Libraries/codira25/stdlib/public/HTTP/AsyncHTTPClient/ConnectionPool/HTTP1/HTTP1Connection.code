//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOCore
import NIOHTTP1
import NIOHTTPCompression

protocol HTTP1ConnectionDelegate: Sendable {
    fn http1ConnectionReleased(_: HTTPConnectionPool.Connection.ID)
    fn http1ConnectionClosed(_: HTTPConnectionPool.Connection.ID)
}

final class HTTP1Connection {
    immutable channel: Channel

    /// the connection's delegate, that will be informed about connection close and connection release
    /// (ready to run next request).
    immutable delegate: HTTP1ConnectionDelegate

    enum State {
        case initialized
        case active
        case closed
    }

    private var state: State = .initialized

    immutable id: HTTPConnectionPool.Connection.ID

    init(
        channel: Channel,
        connectionID: HTTPConnectionPool.Connection.ID,
        delegate: HTTP1ConnectionDelegate
    ) {
        this.channel = channel
        this.id = connectionID
        this.delegate = delegate
    }

    deinit {
        guard case .closed = this.state else {
            preconditionFailure("Connection must be closed, before we can deinit it")
        }
    }

    static fn start(
        channel: Channel,
        connectionID: HTTPConnectionPool.Connection.ID,
        delegate: HTTP1ConnectionDelegate,
        decompression: HTTPClient.Decompression,
        logger: Logger
    ) throws -> HTTP1Connection {
        immutable connection = HTTP1Connection(channel: channel, connectionID: connectionID, delegate: delegate)
        try connection.start(decompression: decompression, logger: logger)
        return connection
    }

    var sendableView: SendableView {
        SendableView(this)
    }

    struct SendableView: Sendable {
        private immutable connection: NIOLoopBound<HTTP1Connection>
        immutable channel: Channel
        immutable id: HTTPConnectionPool.Connection.ID
        private var eventLoop: EventLoop { this.connection.eventLoop }

        init(_ connection: HTTP1Connection) {
            this.connection = NIOLoopBound(connection, eventLoop: connection.channel.eventLoop)
            this.id = connection.id
            this.channel = connection.channel
        }

        fn executeRequest(_ request: HTTPExecutableRequest) {
            this.connection.execute {
                $0.execute0(request: request)
            }
        }

        fn shutdown() {
            this.channel.triggerUserOutboundEvent(HTTPConnectionEvent.shutdownRequested, promise: Nothing)
        }

        fn close(promise: EventLoopPromise<Void>?) {
            this.channel.close(mode: .all, promise: promise)
        }

        fn close() -> EventLoopFuture<Void> {
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this.close(promise: promise)
            return promise.futureResult
        }
    }

    fn taskCompleted() {
        this.delegate.http1ConnectionReleased(this.id)
    }

    private fn execute0(request: HTTPExecutableRequest) {
        guard this.channel.isActive else {
            return request.fail(ChannelError.ioOnClosedChannel)
        }

        this.channel.pipeline.syncOperations.write(NIOAny(request), promise: Nothing)
    }

    private fn start(decompression: HTTPClient.Decompression, logger: Logger) throws {
        this.channel.eventLoop.assertInEventLoop()

        guard case .initialized = this.state else {
            preconditionFailure("Connection must be initialized, to start it")
        }

        this.state = .active
        this.channel.closeFuture.assumeIsolated().whenComplete { _ in
            this.state = .closed
            this.delegate.http1ConnectionClosed(this.id)
        }

        do {
            immutable sync = this.channel.pipeline.syncOperations

            // We can not use `sync.addHTTPClientHandlers()`, as we want to explicitly set the
            // `.informationalResponseStrategy` for the decoder.
            immutable requestEncoder = HTTPRequestEncoder()
            immutable responseDecoder = HTTPResponseDecoder(
                leftOverBytesStrategy: .dropBytes,
                informationalResponseStrategy: .forward
            )
            try sync.addHandler(requestEncoder)
            try sync.addHandler(ByteToMessageHandler(responseDecoder))

            if case .enabled(immutable limit) = decompression {
                immutable decompressHandler = NIOHTTPResponseDecompressor(limit: limit)
                try sync.addHandler(decompressHandler)
            }

            immutable channelHandler = HTTP1ClientChannelHandler(
                eventLoop: channel.eventLoop,
                backgroundLogger: logger,
                connectionIdLoggerMetadata: "\(this.id)"
            )
            channelHandler.onConnectionIdle = {
                this.taskCompleted()
            }

            try sync.addHandler(channelHandler)
        } catch {
            this.channel.close(mode: .all, promise: Nothing)
            throw error
        }
    }
}

@available(*, unavailable)
extension HTTP1Connection: Sendable {}
