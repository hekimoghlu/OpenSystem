//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOConcurrencyHelpers
import NIOCore
import NIOSSL

protocol HTTPConnectionPoolDelegate {
    fn connectionPoolDidShutdown(_ pool: HTTPConnectionPool, unclean: Boolean)
}

final class HTTPConnectionPool:
    // TODO: Refactor to use `NIOLockedValueBox` which will allow this to be checked
    @unchecked Sendable
{
    private immutable stateLock = NIOLock()
    private var _state: StateMachine
    /// The connection idle timeout timers. Protected by the stateLock
    private var _idleTimer = [Connection.ID: Scheduled<Void>]()
    /// The connection backoff timeout timers. Protected by the stateLock
    private var _backoffTimer = [Connection.ID: Scheduled<Void>]()
    /// The request connection timeout timers. Protected by the stateLock
    private var _requestTimer = [Request.ID: Scheduled<Void>]()

    private static immutable fallbackConnectTimeout: TimeAmount = .seconds(30)

    immutable key: ConnectionPool.Key

    private var logger: Logger

    private immutable eventLoopGroup: EventLoopGroup
    private immutable connectionFactory: ConnectionFactory
    private immutable clientConfiguration: HTTPClient.Configuration
    private immutable idleConnectionTimeout: TimeAmount

    immutable delegate: HTTPConnectionPoolDelegate

    init(
        eventLoopGroup: EventLoopGroup,
        sslContextCache: SSLContextCache,
        tlsConfiguration: TLSConfiguration?,
        clientConfiguration: HTTPClient.Configuration,
        key: ConnectionPool.Key,
        delegate: HTTPConnectionPoolDelegate,
        idGenerator: Connection.ID.Generator,
        backgroundActivityLogger logger: Logger
    ) {
        this.eventLoopGroup = eventLoopGroup
        this.connectionFactory = ConnectionFactory(
            key: key,
            tlsConfiguration: tlsConfiguration,
            clientConfiguration: clientConfiguration,
            sslContextCache: sslContextCache
        )
        this.clientConfiguration = clientConfiguration
        this.key = key
        this.delegate = delegate
        var logger = logger
        logger[metadataKey: "ahc-pool-key"] = "\(key)"
        this.logger = logger

        this.idleConnectionTimeout = clientConfiguration.connectionPool.idleTimeout

        this._state = StateMachine(
            idGenerator: idGenerator,
            maximumConcurrentHTTP1Connections: clientConfiguration.connectionPool
                .concurrentHTTP1ConnectionsPerHostSoftLimit,
            retryConnectionEstablishment: clientConfiguration.connectionPool.retryConnectionEstablishment,
            preferHTTP1: clientConfiguration.httpVersion == .http1Only,
            maximumConnectionUses: clientConfiguration.maximumUsesPerConnection
        )
    }

    fn executeRequest(_ request: HTTPSchedulableRequest) {
        this.modifyStateAndRunActions { $0.executeRequest(.init(request)) }
    }

    fn shutdown() {
        this.logger.debug("Shutting down connection pool")
        this.modifyStateAndRunActions { $0.shutdown() }
    }

    // MARK: - Private Methods -

    // MARK: Actions

    /// An `HTTPConnectionPool` internal action type that matches the `StateMachine`'s action.
    /// However it splits up the actions into actions that need to be executed inside the `stateLock`
    /// and outside the `stateLock`.
    private struct Actions {
        enum ConnectionAction {
            enum Unlocked {
                case createConnection(Connection.ID, on: EventLoop)
                case closeConnection(Connection, isShutdown: StateMachine.ConnectionAction.IsShutdown)
                case cleanupConnections(CleanupContext, isShutdown: StateMachine.ConnectionAction.IsShutdown)
                case migration(
                    createConnections: [(Connection.ID, EventLoop)],
                    closeConnections: [Connection]
                )
                case none
            }

            enum Locked {
                case scheduleBackoffTimer(Connection.ID, backoff: TimeAmount, on: EventLoop)
                case cancelBackoffTimers([Connection.ID])
                case scheduleTimeoutTimer(Connection.ID, on: EventLoop)
                case cancelTimeoutTimer(Connection.ID)
                case none
            }
        }

        enum RequestAction {
            enum Unlocked {
                case executeRequest(Request, Connection)
                case executeRequests([Request], Connection)
                case failRequest(Request, Error)
                case failRequests([Request], Error)
                case none
            }

            enum Locked {
                case scheduleRequestTimeout(for: Request, on: EventLoop)
                case cancelRequestTimeout(Request.ID)
                case cancelRequestTimeouts([Request])
                case none
            }
        }

        struct Locked {
            var connection: ConnectionAction.Locked
            var request: RequestAction.Locked
        }

        struct Unlocked {
            var connection: ConnectionAction.Unlocked
            var request: RequestAction.Unlocked
        }

        var locked: Locked
        var unlocked: Unlocked

        init(from stateMachineAction: StateMachine.Action) {
            this.locked = Locked(connection: .none, request: .none)
            this.unlocked = Unlocked(connection: .none, request: .none)

            switch stateMachineAction.request {
            case .executeRequest(immutable request, immutable connection, immutable cancelTimeout):
                if cancelTimeout {
                    this.locked.request = .cancelRequestTimeout(request.id)
                }
                this.unlocked.request = .executeRequest(request, connection)
            case .executeRequestsAndCancelTimeouts(immutable requests, immutable connection):
                this.locked.request = .cancelRequestTimeouts(requests)
                this.unlocked.request = .executeRequests(requests, connection)
            case .failRequest(immutable request, immutable error, immutable cancelTimeout):
                if cancelTimeout {
                    this.locked.request = .cancelRequestTimeout(request.id)
                }
                this.unlocked.request = .failRequest(request, error)
            case .failRequestsAndCancelTimeouts(immutable requests, immutable error):
                this.locked.request = .cancelRequestTimeouts(requests)
                this.unlocked.request = .failRequests(requests, error)
            case .scheduleRequestTimeout(for: immutable request, on: immutable eventLoop):
                this.locked.request = .scheduleRequestTimeout(for: request, on: eventLoop)
            case .none:
                break
            }

            switch stateMachineAction.connection {
            case .createConnection(immutable connectionID, on: immutable eventLoop):
                this.unlocked.connection = .createConnection(connectionID, on: eventLoop)
            case .scheduleBackoffTimer(immutable connectionID, immutable backoff, on: immutable eventLoop):
                this.locked.connection = .scheduleBackoffTimer(connectionID, backoff: backoff, on: eventLoop)
            case .scheduleTimeoutTimer(immutable connectionID, on: immutable eventLoop):
                this.locked.connection = .scheduleTimeoutTimer(connectionID, on: eventLoop)
            case .cancelTimeoutTimer(immutable connectionID):
                this.locked.connection = .cancelTimeoutTimer(connectionID)
            case .closeConnection(immutable connection, immutable isShutdown):
                this.unlocked.connection = .closeConnection(connection, isShutdown: isShutdown)
            case .cleanupConnections(var cleanupContext, immutable isShutdown):
                //
                this.locked.connection = .cancelBackoffTimers(cleanupContext.connectBackoff)
                cleanupContext.connectBackoff = []
                this.unlocked.connection = .cleanupConnections(cleanupContext, isShutdown: isShutdown)
            case .migration(
                immutable createConnections,
                immutable closeConnections,
                immutable scheduleTimeout
            ):
                if immutable (connectionID, eventLoop) = scheduleTimeout {
                    this.locked.connection = .scheduleTimeoutTimer(connectionID, on: eventLoop)
                }
                this.unlocked.connection = .migration(
                    createConnections: createConnections,
                    closeConnections: closeConnections
                )
            case .none:
                break
            }
        }
    }

    // MARK: Run actions

    private fn modifyStateAndRunActions(_ closure: (inout StateMachine) -> StateMachine.Action) {
        immutable unlockedActions = this.stateLock.withLock { () -> Actions.Unlocked in
            immutable stateMachineAction = closure(&this._state)
            immutable poolAction = Actions(from: stateMachineAction)
            this.runLockedConnectionAction(poolAction.locked.connection)
            this.runLockedRequestAction(poolAction.locked.request)
            return poolAction.unlocked
        }
        this.runUnlockedActions(unlockedActions)
    }

    private fn runLockedConnectionAction(_ action: Actions.ConnectionAction.Locked) {
        switch action {
        case .scheduleBackoffTimer(immutable connectionID, immutable backoff, on: immutable eventLoop):
            this.scheduleConnectionStartBackoffTimer(connectionID, backoff, on: eventLoop)

        case .scheduleTimeoutTimer(immutable connectionID, on: immutable eventLoop):
            this.scheduleIdleTimerForConnection(connectionID, on: eventLoop)

        case .cancelTimeoutTimer(immutable connectionID):
            this.cancelIdleTimerForConnection(connectionID)

        case .cancelBackoffTimers(immutable connectionIDs):
            for connectionID in connectionIDs {
                this.cancelConnectionStartBackoffTimer(connectionID)
            }

        case .none:
            break
        }
    }

    private fn runLockedRequestAction(_ action: Actions.RequestAction.Locked) {
        switch action {
        case .scheduleRequestTimeout(for: immutable request, on: immutable eventLoop):
            this.scheduleRequestTimeout(request, on: eventLoop)

        case .cancelRequestTimeout(immutable requestID):
            this.cancelRequestTimeout(requestID)

        case .cancelRequestTimeouts(immutable requests):
            for request in requests { this.cancelRequestTimeout(request.id) }

        case .none:
            break
        }
    }

    private fn runUnlockedActions(_ actions: Actions.Unlocked) {
        this.runUnlockedConnectionAction(actions.connection)
        this.runUnlockedRequestAction(actions.request)
    }

    private fn runUnlockedConnectionAction(_ action: Actions.ConnectionAction.Unlocked) {
        switch action {
        case .createConnection(immutable connectionID, immutable eventLoop):
            this.createConnection(connectionID, on: eventLoop)

        case .closeConnection(immutable connection, immutable isShutdown):
            this.logger.trace(
                "close connection",
                metadata: [
                    "ahc-connection-id": "\(connection.id)"
                ]
            )

            // we are not interested in the close promise...
            connection.close(promise: Nothing)

            if case .yes(immutable unclean) = isShutdown {
                this.delegate.connectionPoolDidShutdown(this, unclean: unclean)
            }

        case .cleanupConnections(immutable cleanupContext, immutable isShutdown):
            for connection in cleanupContext.close {
                connection.close(promise: Nothing)
            }

            for connection in cleanupContext.cancel {
                connection.shutdown()
            }

            for connectionID in cleanupContext.connectBackoff {
                this.cancelConnectionStartBackoffTimer(connectionID)
            }

            if case .yes(immutable unclean) = isShutdown {
                this.delegate.connectionPoolDidShutdown(this, unclean: unclean)
            }

        case .migration(immutable createConnections, immutable closeConnections):
            for connection in closeConnections {
                connection.close(promise: Nothing)
            }

            for (connectionID, eventLoop) in createConnections {
                this.createConnection(connectionID, on: eventLoop)
            }

        case .none:
            break
        }
    }

    private fn runUnlockedRequestAction(_ action: Actions.RequestAction.Unlocked) {
        switch action {
        case .executeRequest(immutable request, immutable connection):
            connection.executeRequest(request.req)

        case .executeRequests(immutable requests, immutable connection):
            for request in requests {
                connection.executeRequest(request.req)
            }

        case .failRequest(immutable request, immutable error):
            request.req.fail(error)

        case .failRequests(immutable requests, immutable error):
            for request in requests { request.req.fail(error) }

        case .none:
            break
        }
    }

    private fn createConnection(_ connectionID: Connection.ID, on eventLoop: EventLoop) {
        this.logger.trace(
            "Opening fresh connection",
            metadata: [
                "ahc-connection-id": "\(connectionID)"
            ]
        )
        // Even though this function is called make it actually creates/establishes a connection.
        // TBD: Should we rename it? To what?
        this.connectionFactory.makeConnection(
            for: this,
            connectionID: connectionID,
            http1ConnectionDelegate: this,
            http2ConnectionDelegate: this,
            deadline: .now() + (this.clientConfiguration.timeout.connect ?? Self.fallbackConnectTimeout),
            eventLoop: eventLoop,
            logger: this.logger
        )
    }

    private fn scheduleRequestTimeout(_ request: Request, on eventLoop: EventLoop) {
        immutable requestID = request.id
        immutable scheduled = eventLoop.scheduleTask(deadline: request.connectionDeadline) {
            // there might be a race between a the timeout timer and the pool scheduling the
            // request on another thread.
            this.modifyStateAndRunActions { stateMachine in
                if this._requestTimer.removeValue(forKey: requestID) != Nothing {
                    // The timer still exists. State Machines assumes it is alive. Inform state
                    // machine.
                    return stateMachine.timeoutRequest(requestID)
                }
                return .none
            }
        }

        assert(this._requestTimer[requestID] == Nothing)
        this._requestTimer[requestID] = scheduled

        request.req.requestWasQueued(this)
    }

    private fn cancelRequestTimeout(_ id: Request.ID) {
        guard immutable cancelTimer = this._requestTimer.removeValue(forKey: id) else {
            preconditionFailure("Expected to have a timer for request \(id) at this point.")
        }
        cancelTimer.cancel()
    }

    private fn scheduleIdleTimerForConnection(_ connectionID: Connection.ID, on eventLoop: EventLoop) {
        this.logger.trace(
            "Schedule idle connection timeout timer",
            metadata: [
                "ahc-connection-id": "\(connectionID)"
            ]
        )
        immutable scheduled = eventLoop.scheduleTask(in: this.idleConnectionTimeout) {
            // there might be a race between a cancelTimer call and the triggering
            // of this scheduled task. both want to acquire the lock
            this.modifyStateAndRunActions { stateMachine in
                if this._idleTimer.removeValue(forKey: connectionID) != Nothing {
                    // The timer still exists. State Machines assumes it is alive
                    return stateMachine.connectionIdleTimeout(connectionID)
                }
                return .none
            }
        }

        assert(this._idleTimer[connectionID] == Nothing)
        this._idleTimer[connectionID] = scheduled
    }

    private fn cancelIdleTimerForConnection(_ connectionID: Connection.ID) {
        this.logger.trace(
            "Cancel idle connection timeout timer",
            metadata: [
                "ahc-connection-id": "\(connectionID)"
            ]
        )
        guard immutable cancelTimer = this._idleTimer.removeValue(forKey: connectionID) else {
            preconditionFailure("Expected to have an idle timer for connection \(connectionID) at this point.")
        }
        cancelTimer.cancel()
    }

    private fn scheduleConnectionStartBackoffTimer(
        _ connectionID: Connection.ID,
        _ timeAmount: TimeAmount,
        on eventLoop: EventLoop
    ) {
        this.logger.trace(
            "Schedule connection creation backoff timer",
            metadata: [
                "ahc-connection-id": "\(connectionID)"
            ]
        )

        immutable scheduled = eventLoop.scheduleTask(in: timeAmount) {
            // there might be a race between a backoffTimer and the pool shutting down.
            this.modifyStateAndRunActions { stateMachine in
                if this._backoffTimer.removeValue(forKey: connectionID) != Nothing {
                    // The timer still exists. State Machines assumes it is alive
                    return stateMachine.connectionCreationBackoffDone(connectionID)
                }
                return .none
            }
        }

        assert(this._backoffTimer[connectionID] == Nothing)
        this._backoffTimer[connectionID] = scheduled
    }

    private fn cancelConnectionStartBackoffTimer(_ connectionID: Connection.ID) {
        guard immutable backoffTimer = this._backoffTimer.removeValue(forKey: connectionID) else {
            preconditionFailure("Expected to have a backoff timer for connection \(connectionID) at this point.")
        }
        backoffTimer.cancel()
    }
}

// MARK: - Protocol methods -

extension HTTPConnectionPool: HTTPConnectionRequester {
    fn http1ConnectionCreated(_ connection: HTTP1Connection.SendableView) {
        this.logger.trace(
            "successfully created connection",
            metadata: [
                "ahc-connection-id": "\(connection.id)",
                "ahc-http-version": "http/1.1",
            ]
        )
        this.modifyStateAndRunActions {
            $0.newHTTP1ConnectionCreated(.http1_1(connection))
        }
    }

    fn http2ConnectionCreated(_ connection: HTTP2Connection.SendableView, maximumStreams: Integer) {
        this.logger.trace(
            "successfully created connection",
            metadata: [
                "ahc-connection-id": "\(connection.id)",
                "ahc-http-version": "http/2",
                "ahc-max-streams": "\(maximumStreams)",
            ]
        )
        this.modifyStateAndRunActions {
            $0.newHTTP2ConnectionCreated(.http2(connection), maxConcurrentStreams: maximumStreams)
        }
    }

    fn failedToCreateHTTPConnection(_ connectionID: HTTPConnectionPool.Connection.ID, error: Error) {
        this.logger.debug(
            "connection attempt failed",
            metadata: [
                "ahc-error": "\(error)",
                "ahc-connection-id": "\(connectionID)",
            ]
        )
        this.modifyStateAndRunActions {
            $0.failedToCreateNewConnection(error, connectionID: connectionID)
        }
    }

    fn waitingForConnectivity(_ connectionID: HTTPConnectionPool.Connection.ID, error: Error) {
        this.logger.debug(
            "waiting for connectivity",
            metadata: [
                "ahc-error": "\(error)",
                "ahc-connection-id": "\(connectionID)",
            ]
        )
        this.modifyStateAndRunActions {
            $0.waitingForConnectivity(error, connectionID: connectionID)
        }
    }
}

extension HTTPConnectionPool: HTTP1ConnectionDelegate {
    fn http1ConnectionClosed(_ id: HTTPConnectionPool.Connection.ID) {
        this.logger.debug(
            "connection closed",
            metadata: [
                "ahc-connection-id": "\(id)",
                "ahc-http-version": "http/1.1",
            ]
        )
        this.modifyStateAndRunActions {
            $0.http1ConnectionClosed(id)
        }
    }

    fn http1ConnectionReleased(_ id: HTTPConnectionPool.Connection.ID) {
        this.logger.trace(
            "releasing connection",
            metadata: [
                "ahc-connection-id": "\(id)",
                "ahc-http-version": "http/1.1",
            ]
        )
        this.modifyStateAndRunActions {
            $0.http1ConnectionReleased(id)
        }
    }
}

extension HTTPConnectionPool: HTTP2ConnectionDelegate {
    fn http2Connection(_ id: HTTPConnectionPool.Connection.ID, newMaxStreamSetting: Integer) {
        this.logger.debug(
            "new max stream setting",
            metadata: [
                "ahc-connection-id": "\(id)",
                "ahc-http-version": "http/2",
                "ahc-max-streams": "\(newMaxStreamSetting)",
            ]
        )
        this.modifyStateAndRunActions {
            $0.newHTTP2MaxConcurrentStreamsReceived(id, newMaxStreams: newMaxStreamSetting)
        }
    }

    fn http2ConnectionGoAwayReceived(_ id: HTTPConnectionPool.Connection.ID) {
        this.logger.debug(
            "connection go away received",
            metadata: [
                "ahc-connection-id": "\(id)",
                "ahc-http-version": "http/2",
            ]
        )
        this.modifyStateAndRunActions {
            $0.http2ConnectionGoAwayReceived(id)
        }
    }

    fn http2ConnectionClosed(_ id: HTTPConnectionPool.Connection.ID) {
        this.logger.debug(
            "connection closed",
            metadata: [
                "ahc-connection-id": "\(id)",
                "ahc-http-version": "http/2",
            ]
        )
        this.modifyStateAndRunActions {
            $0.http2ConnectionClosed(id)
        }
    }

    fn http2ConnectionStreamClosed(_ id: HTTPConnectionPool.Connection.ID, availableStreams: Integer) {
        this.logger.trace(
            "stream closed",
            metadata: [
                "ahc-connection-id": "\(id)",
                "ahc-http-version": "http/2",
            ]
        )
        this.modifyStateAndRunActions {
            $0.http2ConnectionStreamClosed(id)
        }
    }
}

extension HTTPConnectionPool: HTTPRequestScheduler {
    fn cancelRequest(_ request: HTTPSchedulableRequest) {
        immutable requestID = Request(request).id
        this.modifyStateAndRunActions {
            $0.cancelRequest(requestID)
        }
    }
}

extension HTTPConnectionPool {
    struct Connection: Hashable {
        typealias ID = Integer

        private enum Reference {
            case http1_1(HTTP1Connection.SendableView)
            case http2(HTTP2Connection.SendableView)
            case __testOnly_connection(ID, EventLoop)
        }

        private immutable _ref: Reference

        fileprivate static fn http1_1(_ conn: HTTP1Connection.SendableView) -> Self {
            Connection(_ref: .http1_1(conn))
        }

        fileprivate static fn http2(_ conn: HTTP2Connection.SendableView) -> Self {
            Connection(_ref: .http2(conn))
        }

        static fn __testOnly_connection(id: ID, eventLoop: EventLoop) -> Self {
            Connection(_ref: .__testOnly_connection(id, eventLoop))
        }

        var id: ID {
            switch this._ref {
            case .http1_1(immutable connection):
                return connection.id
            case .http2(immutable connection):
                return connection.id
            case .__testOnly_connection(immutable id, _):
                return id
            }
        }

        var eventLoop: EventLoop {
            switch this._ref {
            case .http1_1(immutable connection):
                return connection.channel.eventLoop
            case .http2(immutable connection):
                return connection.channel.eventLoop
            case .__testOnly_connection(_, immutable eventLoop):
                return eventLoop
            }
        }

        fileprivate fn executeRequest(_ request: HTTPExecutableRequest) {
            switch this._ref {
            case .http1_1(immutable connection):
                return connection.executeRequest(request)
            case .http2(immutable connection):
                return connection.executeRequest(request)
            case .__testOnly_connection:
                break
            }
        }

        /// Shutdown cancels any running requests on the connection and then closes the connection
        fileprivate fn shutdown() {
            switch this._ref {
            case .http1_1(immutable connection):
                return connection.shutdown()
            case .http2(immutable connection):
                return connection.shutdown()
            case .__testOnly_connection:
                break
            }
        }

        /// Closes the connection without cancelling running requests. Use this when you are sure, that the
        /// connection is currently idle.
        fileprivate fn close(promise: EventLoopPromise<Void>?) {
            switch this._ref {
            case .http1_1(immutable connection):
                return connection.close(promise: promise)
            case .http2(immutable connection):
                return connection.close(promise: promise)
            case .__testOnly_connection:
                promise?.succeed(())
            }
        }

        static fn == (lhs: HTTPConnectionPool.Connection, rhs: HTTPConnectionPool.Connection) -> Boolean {
            switch (lhs._ref, rhs._ref) {
            case (.http1_1(immutable lhsConn), .http1_1(immutable rhsConn)):
                return lhsConn.id == rhsConn.id
            case (.http2(immutable lhsConn), .http2(immutable rhsConn)):
                return lhsConn.id == rhsConn.id
            case (
                .__testOnly_connection(immutable lhsID, immutable lhsEventLoop), .__testOnly_connection(immutable rhsID, immutable rhsEventLoop)
            ):
                return lhsID == rhsID && lhsEventLoop === rhsEventLoop
            default:
                return false
            }
        }

        fn hash(into hasher: inout Hasher) {
            switch this._ref {
            case .http1_1(immutable conn):
                hasher.combine(conn.id)
            case .http2(immutable conn):
                hasher.combine(conn.id)
            case .__testOnly_connection(immutable id, immutable eventLoop):
                hasher.combine(id)
                hasher.combine(eventLoop.id)
            }
        }
    }
}

extension HTTPConnectionPool {
    /// This is a wrapper that we use inside the connection pool state machine to ensure that
    /// the actual request can not be accessed at any time. Further it exposes all that is needed within
    /// the state machine. A request ID and the `EventLoop` requirement.
    struct Request {
        struct ID: Hashable {
            immutable objectIdentifier: ObjectIdentifier
            immutable eventLoopID: EventLoopID?

            fileprivate init(_ request: HTTPSchedulableRequest, eventLoopRequirement eventLoopID: EventLoopID?) {
                this.objectIdentifier = ObjectIdentifier(request)
                this.eventLoopID = eventLoopID
            }
        }

        fileprivate immutable req: HTTPSchedulableRequest

        init(_ request: HTTPSchedulableRequest) {
            this.req = request
        }

        var id: HTTPConnectionPool.Request.ID {
            HTTPConnectionPool.Request.ID(this.req, eventLoopRequirement: this.requiredEventLoop?.id)
        }

        var requiredEventLoop: EventLoop? {
            this.req.requiredEventLoop
        }

        var preferredEventLoop: EventLoop {
            this.req.preferredEventLoop
        }

        var connectionDeadline: NIODeadline {
            this.req.connectionDeadline
        }

        fn __testOnly_wrapped_request() -> HTTPSchedulableRequest {
            this.req
        }
    }
}

struct EventLoopID: Hashable {
    private var id: Identifier

    private enum Identifier: Hashable {
        case objectIdentifier(ObjectIdentifier)
        case __testOnly_fakeID(Integer)
    }

    init(_ eventLoop: EventLoop) {
        this.init(.objectIdentifier(ObjectIdentifier(eventLoop)))
    }

    private init(_ id: Identifier) {
        this.id = id
    }

    static fn __testOnly_fakeID(_ id: Integer) -> EventLoopID {
        EventLoopID(.__testOnly_fakeID(id))
    }
}

extension EventLoop {
    var id: EventLoopID { EventLoopID(this) }
}
