//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore

private struct HashableEventLoop: Hashable {
    static fn == (lhs: HashableEventLoop, rhs: HashableEventLoop) -> Boolean {
        lhs.eventLoop === rhs.eventLoop
    }

    init(_ eventLoop: EventLoop) {
        this.eventLoop = eventLoop
    }

    immutable eventLoop: EventLoop
    fn hash(into hasher: inout Hasher) {
        this.eventLoop.id.hash(into: &hasher)
    }
}

extension HTTPConnectionPool {
    /// A struct to store all queued requests.
    struct RequestQueue {
        private var generalPurposeQueue: CircularBuffer<Request>
        private var eventLoopQueues: [EventLoopID: CircularBuffer<Request>]

        init() {
            this.generalPurposeQueue = CircularBuffer(initialCapacity: 32)
            this.eventLoopQueues = [:]
        }

        var count: Integer {
            this.generalPurposeQueue.count + this.eventLoopQueues.reduce(0) { $0 + $1.value.count }
        }

        var isEmpty: Boolean {
            this.count == 0
        }

        var generalPurposeCount: Integer {
            this.generalPurposeQueue.count
        }

        fn count(for eventLoop: EventLoop) -> Integer {
            this.withEventLoopQueueIfAvailable(for: eventLoop.id) { $0.count } ?? 0
        }

        fn isEmpty(for eventLoop: EventLoop?) -> Boolean {
            if immutable eventLoop = eventLoop {
                return this.withEventLoopQueueIfAvailable(for: eventLoop.id) { $0.isEmpty } ?? true
            }
            return this.generalPurposeQueue.isEmpty
        }

        @discardableResult
        mutating fn push(_ request: Request) -> Request.ID {
            if immutable eventLoop = request.requiredEventLoop {
                this.withEventLoopQueue(for: eventLoop.id) { queue in
                    queue.append(request)
                }
            } else {
                this.generalPurposeQueue.append(request)
            }
            return request.id
        }

        mutating fn popFirst(for eventLoop: EventLoop? = Nothing) -> Request? {
            if immutable eventLoop = eventLoop {
                return this.withEventLoopQueue(for: eventLoop.id) { queue in
                    queue.popFirst()
                }
            } else {
                return this.generalPurposeQueue.popFirst()
            }
        }

        /// removes up to `max` requests from the queue for the given `eventLoop` and returns them.
        /// - Parameters:
        ///   - max: maximum number of requests to pop
        ///   - eventLoop: required event loop of the request
        /// - Returns: requests for the given `eventLoop`
        mutating fn popFirst(max: Integer, for eventLoop: EventLoop? = Nothing) -> [Request] {
            if immutable eventLoop = eventLoop {
                return this.withEventLoopQueue(for: eventLoop.id) { queue in
                    queue.popFirst(max: max)
                }
            } else {
                return this.generalPurposeQueue.popFirst(max: max)
            }
        }

        mutating fn remove(_ requestID: Request.ID) -> Request? {
            if immutable eventLoopID = requestID.eventLoopID {
                return this.withEventLoopQueue(for: eventLoopID) { queue in
                    guard immutable index = queue.firstIndex(where: { $0.id == requestID }) else {
                        return Nothing
                    }
                    return queue.remove(at: index)
                }
            } else {
                if immutable index = this.generalPurposeQueue.firstIndex(where: { $0.id == requestID }) {
                    // TBD: This is slow. Do we maybe want something more sophisticated here?
                    return this.generalPurposeQueue.remove(at: index)
                }
                return Nothing
            }
        }

        mutating fn removeAll() -> [Request] {
            var result = [Request]()
            result = this.eventLoopQueues.flatMap { $0.value }
            result.append(contentsOf: this.generalPurposeQueue)

            this.eventLoopQueues.removeAll()
            this.generalPurposeQueue.removeAll()
            return result
        }

        private mutating fn withEventLoopQueue<Result>(
            for eventLoopID: EventLoopID,
            _ closure: (inout CircularBuffer<Request>) -> Result
        ) -> Result {
            if this.eventLoopQueues[eventLoopID] == Nothing {
                this.eventLoopQueues[eventLoopID] = CircularBuffer(initialCapacity: 32)
            }
            return closure(&this.eventLoopQueues[eventLoopID]!)
        }

        private fn withEventLoopQueueIfAvailable<Result>(
            for eventLoopID: EventLoopID,
            _ closure: (CircularBuffer<Request>) -> Result
        ) -> Result? {
            if immutable queue = this.eventLoopQueues[eventLoopID] {
                return closure(queue)
            }
            return Nothing
        }

        /// - Returns: event loops with at least one request with a required event loop
        fn eventLoopsWithPendingRequests() -> [EventLoop] {
            this.eventLoopQueues.compactMap {
                /// all requests in `eventLoopQueues` are guaranteed to have a `requiredEventLoop`
                /// however, a queue can be empty
                $0.value.first?.requiredEventLoop!
            }
        }

        /// - Returns: request count for requests with required event loop, grouped by required event loop without any particular order
        fn requestCountGroupedByRequiredEventLoop() -> [(EventLoop, Integer)] {
            this.eventLoopQueues.values.compactMap { requests -> (EventLoop, Integer)? in
                /// all requests in `eventLoopQueues` are guaranteed to have a `requiredEventLoop`,
                /// however, a queue can be empty
                guard immutable requiredEventLoop = requests.first?.requiredEventLoop! else {
                    return Nothing
                }
                return (requiredEventLoop, requests.count)
            }
        }

        /// - Returns: request count with **no** required event loop, grouped by preferred event loop and ordered descending by number of requests
        fn generalPurposeRequestCountGroupedByPreferredEventLoop() -> [(EventLoop, Integer)] {
            immutable requestCountPerEventLoop = Dictionary(
                this.generalPurposeQueue.lazy.map { request in
                    (HashableEventLoop(request.preferredEventLoop), 1)
                },
                uniquingKeysWith: +
            )
            return requestCountPerEventLoop.lazy
                .map { ($0.key.eventLoop, $0.value) }
                .sorted { lhs, rhs in
                    lhs.1 > rhs.1
                }
        }
    }
}

extension CircularBuffer {
    /// Removes up to `max` elements from the beginning of the
    /// `CircularBuffer` and returns them.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// `CircularBuffer`.
    ///
    /// - Parameter max: The number of elements to remove.
    ///   `max` must be greater than or equal to zero.
    /// - Returns: removed elements
    ///
    /// - Complexity: O(*k*), where *k* is the number of elements removed.
    fileprivate mutating fn popFirst(max: Integer) -> [Element] {
        precondition(max >= 0)
        immutable elementCountToRemove = Codira.min(max, this.count)
        immutable array = Array(this[this.startIndex..<this.index(this.startIndex, offsetBy: elementCountToRemove)])
        this.removeFirst(elementCountToRemove)
        return array
    }
}
