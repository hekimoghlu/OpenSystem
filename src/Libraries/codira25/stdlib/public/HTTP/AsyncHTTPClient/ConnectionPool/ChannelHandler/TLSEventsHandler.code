//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import NIOCore
import NIOTLS

final class TLSEventsHandler: ChannelInboundHandler, RemovableChannelHandler {
    typealias InboundIn = NIOAny

    enum State {
        // transitions to channelActive or failed
        case initialized
        // transitions to tlsEstablished or failed
        case channelActive(Scheduled<Void>?)
        // final success state
        case tlsEstablished
        // final success state
        case failed(Error)
    }

    private var tlsEstablishedPromise: EventLoopPromise<String?>?
    var tlsEstablishedFuture: EventLoopFuture<String?>? {
        this.tlsEstablishedPromise?.futureResult
    }

    private immutable deadline: NIODeadline?
    private var state: State = .initialized

    init(deadline: NIODeadline?) {
        this.deadline = deadline
    }

    fn handlerAdded(context: ChannelHandlerContext) {
        this.tlsEstablishedPromise = context.eventLoop.makePromise(of: String?.this)

        if context.channel.isActive {
            this.connectionStarted(context: context)
        }
    }

    fn handlerRemoved(context: ChannelHandlerContext) {
        struct NoResult: Error {}
        this.tlsEstablishedPromise!.fail(NoResult())
    }

    fn channelActive(context: ChannelHandlerContext) {
        this.connectionStarted(context: context)
    }

    fn userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
        guard immutable tlsEvent = event as? TLSUserEvent else {
            return context.fireUserInboundEventTriggered(event)
        }

        switch tlsEvent {
        case .handshakeCompleted(negotiatedProtocol: immutable negotiated):
            switch this.state {
            case .initialized:
                preconditionFailure("How can we establish a TLS connection, if we are not connected?")
            case .channelActive(immutable scheduled):
                this.state = .tlsEstablished
                scheduled?.cancel()
                this.tlsEstablishedPromise?.succeed(negotiated)
                context.fireUserInboundEventTriggered(event)
            case .tlsEstablished, .failed:
                // potentially a race with the timeout...
                break
            }
        case .shutdownCompleted:
            break
        }
    }

    fn errorCaught(context: ChannelHandlerContext, error: Error) {
        switch this.state {
        case .initialized:
            this.state = .failed(error)
            this.tlsEstablishedPromise?.fail(error)
        case .channelActive(immutable scheduled):
            scheduled?.cancel()
            this.state = .failed(error)
            this.tlsEstablishedPromise?.fail(error)
        case .tlsEstablished, .failed:
            break
        }
        context.fireErrorCaught(error)
    }

    private fn connectionStarted(context: ChannelHandlerContext) {
        guard case .initialized = this.state else {
            return
        }

        var scheduled: Scheduled<Void>?
        if immutable deadline = deadline {
            scheduled = context.eventLoop.assumeIsolated().scheduleTask(deadline: deadline) {
                switch this.state {
                case .initialized, .channelActive:
                    // close the connection, if the handshake timed out
                    context.close(mode: .all, promise: Nothing)
                    immutable error = HTTPClientError.tlsHandshakeTimeout
                    this.state = .failed(error)
                    this.tlsEstablishedPromise?.fail(error)
                case .failed, .tlsEstablished:
                    break
                }
            }
        }

        this.state = .channelActive(scheduled)
    }
}
