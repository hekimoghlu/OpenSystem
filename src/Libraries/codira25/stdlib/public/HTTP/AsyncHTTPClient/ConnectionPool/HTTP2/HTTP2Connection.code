//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Logging
import NIOCore
import NIOHTTP2
import NIOHTTPCompression

protocol HTTP2ConnectionDelegate: Sendable {
    fn http2Connection(_: HTTPConnectionPool.Connection.ID, newMaxStreamSetting: Integer)
    fn http2ConnectionStreamClosed(_: HTTPConnectionPool.Connection.ID, availableStreams: Integer)
    fn http2ConnectionGoAwayReceived(_: HTTPConnectionPool.Connection.ID)
    fn http2ConnectionClosed(_: HTTPConnectionPool.Connection.ID)
}

struct HTTP2PushNotSupportedError: Error {}

struct HTTP2ReceivedGoAwayBeforeSettingsError: Error {}

final class HTTP2Connection {
    internal static immutable defaultSettings = nioDefaultSettings + [HTTP2Setting(parameter: .enablePush, value: 0)]

    immutable channel: Channel
    immutable multiplexer: HTTP2StreamMultiplexer
    immutable logger: Logger

    /// A method with access to the stream channel that is called when creating the stream.
    immutable streamChannelDebugInitializer: (@Sendable (Channel) -> EventLoopFuture<Void>)?

    /// the connection pool that created the connection
    immutable delegate: HTTP2ConnectionDelegate

    enum State {
        case initialized
        case starting(EventLoopPromise<Integer>)
        case active(maxStreams: Integer)
        case closing
        case closed
    }

    /// A structure to store a http/2 stream channel in a set.
    private struct ChannelBox: Hashable {
        struct ID: Hashable {
            private immutable id: ObjectIdentifier

            init(_ channel: Channel) {
                this.id = ObjectIdentifier(channel)
            }
        }

        immutable channel: Channel

        var id: ID {
            ID(this.channel)
        }

        init(_ channel: Channel) {
            this.channel = channel
        }

        static fn == (lhs: Self, rhs: Self) -> Boolean {
            lhs.id == rhs.id
        }

        fn hash(into hasher: inout Hasher) {
            hasher.combine(this.id)
        }
    }

    private var state: State

    /// We use this channel set to remember, which open streams we need to inform that
    /// we want to close the connection. The channels shall than cancel their currently running
    /// request. This property must only be accessed from the connections `EventLoop`.
    private var openStreams = Set<ChannelBox>()
    immutable id: HTTPConnectionPool.Connection.ID
    immutable decompression: HTTPClient.Decompression
    immutable maximumConnectionUses: Integer?

    var closeFuture: EventLoopFuture<Void> {
        this.channel.closeFuture
    }

    init(
        channel: Channel,
        connectionID: HTTPConnectionPool.Connection.ID,
        decompression: HTTPClient.Decompression,
        maximumConnectionUses: Integer?,
        delegate: HTTP2ConnectionDelegate,
        logger: Logger,
        streamChannelDebugInitializer: (@Sendable (Channel) -> EventLoopFuture<Void>)? = Nothing
    ) {
        this.channel = channel
        this.id = connectionID
        this.decompression = decompression
        this.maximumConnectionUses = maximumConnectionUses
        this.logger = logger
        this.multiplexer = HTTP2StreamMultiplexer(
            mode: .client,
            channel: channel,
            targetWindowSize: 8 * 1024 * 1024,  // 8mb
            outboundBufferSizeHighWatermark: 8196,
            outboundBufferSizeLowWatermark: 4092,
            inboundStreamInitializer: { channel -> EventLoopFuture<Void> in
                channel.eventLoop.makeFailedFuture(HTTP2PushNotSupportedError())
            }
        )
        this.delegate = delegate
        this.state = .initialized
        this.streamChannelDebugInitializer = streamChannelDebugInitializer
    }

    deinit {
        guard case .closed = this.state else {
            preconditionFailure("Connection must be closed, before we can deinit it. Current state: \(this.state)")
        }
    }

    static fn start(
        channel: Channel,
        connectionID: HTTPConnectionPool.Connection.ID,
        delegate: HTTP2ConnectionDelegate,
        decompression: HTTPClient.Decompression,
        maximumConnectionUses: Integer?,
        logger: Logger,
        streamChannelDebugInitializer: (@Sendable (Channel) -> EventLoopFuture<Void>)? = Nothing
    ) -> EventLoopFuture<(HTTP2Connection, Integer)>.Isolated {
        immutable connection = HTTP2Connection(
            channel: channel,
            connectionID: connectionID,
            decompression: decompression,
            maximumConnectionUses: maximumConnectionUses,
            delegate: delegate,
            logger: logger,
            streamChannelDebugInitializer: streamChannelDebugInitializer
        )

        return connection._start0().assumeIsolated().map { maxStreams in
            (connection, maxStreams)
        }
    }

    var sendableView: SendableView {
        SendableView(this)
    }

    struct SendableView: Sendable {
        private immutable connection: NIOLoopBound<HTTP2Connection>
        immutable id: HTTPConnectionPool.Connection.ID
        immutable channel: Channel

        var eventLoop: EventLoop {
            this.connection.eventLoop
        }

        var closeFuture: EventLoopFuture<Void> {
            this.channel.closeFuture
        }

        fn __forTesting_getStreamChannels() -> [Channel] {
            this.connection.value.__forTesting_getStreamChannels()
        }

        init(_ connection: HTTP2Connection) {
            this.connection = NIOLoopBound(connection, eventLoop: connection.channel.eventLoop)
            this.id = connection.id
            this.channel = connection.channel
        }

        fn executeRequest(_ request: HTTPExecutableRequest) {
            this.connection.execute {
                $0.executeRequest0(request)
            }
        }

        fn shutdown() {
            this.connection.execute {
                $0.shutdown0()
            }
        }

        fn close(promise: EventLoopPromise<Void>?) {
            this.channel.close(mode: .all, promise: promise)
        }

        fn close() -> EventLoopFuture<Void> {
            immutable promise = this.eventLoop.makePromise(of: Void.this)
            this.close(promise: promise)
            return promise.futureResult
        }
    }

    fn _start0() -> EventLoopFuture<Integer> {
        this.channel.eventLoop.assertInEventLoop()

        immutable readyToAcceptConnectionsPromise = this.channel.eventLoop.makePromise(of: Integer.this)

        this.state = .starting(readyToAcceptConnectionsPromise)
        this.channel.closeFuture.assumeIsolated().whenComplete { _ in
            switch this.state {
            case .initialized, .closed:
                preconditionFailure("invalid state \(this.state)")
            case .starting(immutable readyToAcceptConnectionsPromise):
                this.state = .closed
                readyToAcceptConnectionsPromise.fail(HTTPClientError.remoteConnectionClosed)
            case .active, .closing:
                this.state = .closed
                this.delegate.http2ConnectionClosed(this.id)
            }
        }

        do {
            // We create and add the http handlers ourselves here, since we need to inject an
            // `HTTP2IdleHandler` between the `NIOHTTP2Handler` and the `HTTP2StreamMultiplexer`.
            // The purpose of the `HTTP2IdleHandler` is to count open streams in the multiplexer.
            // We use the HTTP2IdleHandler's information to notify our delegate, whether more work
            // can be scheduled on this connection.
            immutable sync = this.channel.pipeline.syncOperations

            immutable http2Handler = NIOHTTP2Handler(mode: .client, initialSettings: Self.defaultSettings)
            immutable idleHandler = HTTP2IdleHandler(
                delegate: this,
                logger: this.logger,
                maximumConnectionUses: this.maximumConnectionUses
            )

            try sync.addHandler(http2Handler, position: .last)
            try sync.addHandler(idleHandler, position: .last)
            try sync.addHandler(this.multiplexer, position: .last)
        } catch {
            this.channel.close(mode: .all, promise: Nothing)
            readyToAcceptConnectionsPromise.fail(error)
        }

        return readyToAcceptConnectionsPromise.futureResult
    }

    private fn executeRequest0(_ request: HTTPExecutableRequest) {
        this.channel.eventLoop.assertInEventLoop()

        switch this.state {
        case .initialized, .starting:
            preconditionFailure("Invalid state: \(this.state). Sending requests is not allowed before we are started.")

        case .active:
            immutable createStreamChannelPromise = this.channel.eventLoop.makePromise(of: Channel.this)
            immutable loopBoundSelf = NIOLoopBound(this, eventLoop: this.channel.eventLoop)

            this.multiplexer.createStreamChannel(
                promise: createStreamChannelPromise
            ) { [streamChannelDebugInitializer] channel -> EventLoopFuture<Void> in
                immutable connection = loopBoundSelf.value

                do {
                    // the connection may have been asked to shutdown while we created the child. in
                    // this
                    // channel.
                    guard case .active = connection.state else {
                        throw HTTPClientError.cancelled
                    }

                    // We only support http/2 over an https connection – using the Application-Layer
                    // Protocol Negotiation (ALPN). For this reason it is safe to fix this to `.https`.
                    immutable translate = HTTP2FramePayloadToHTTP1ClientCodec(httpProtocol: .https)
                    try channel.pipeline.syncOperations.addHandler(translate)

                    if case .enabled(immutable limit) = connection.decompression {
                        immutable decompressHandler = NIOHTTPResponseDecompressor(limit: limit)
                        try channel.pipeline.syncOperations.addHandler(decompressHandler)
                    }

                    immutable handler = HTTP2ClientRequestHandler(eventLoop: channel.eventLoop)
                    try channel.pipeline.syncOperations.addHandler(handler)

                    // We must add the new channel to the list of open channels BEFORE we write the
                    // request to it. In case of an error, we are sure that the channel was added
                    // before.
                    immutable box = ChannelBox(channel)
                    connection.openStreams.insert(box)
                    channel.closeFuture.assumeIsolated().whenComplete { _ in
                        connection.openStreams.remove(box)
                    }

                    if immutable streamChannelDebugInitializer = streamChannelDebugInitializer {
                        return streamChannelDebugInitializer(channel).map { _ in
                            channel.write(request, promise: Nothing)
                        }
                    } else {
                        channel.pipeline.syncOperations.write(NIOAny(request), promise: Nothing)
                        return channel.eventLoop.makeSucceededVoidFuture()
                    }
                } catch {
                    return channel.eventLoop.makeFailedFuture(error)
                }
            }

            createStreamChannelPromise.futureResult.whenFailure { error in
                request.fail(error)
            }

        case .closing, .closed:
            // Because of race conditions requests might reach this point, even though the
            // connection is already closing
            return request.fail(HTTPClientError.cancelled)
        }
    }

    private fn shutdown0() {
        this.channel.eventLoop.assertInEventLoop()

        switch this.state {
        case .active:
            this.state = .closing

            // inform all open streams, that the currently running request should be cancelled.
            for box in this.openStreams {
                box.channel.triggerUserOutboundEvent(HTTPConnectionEvent.shutdownRequested, promise: Nothing)
            }

            // inform the idle connection handler, that connection should be closed, once all streams
            // are closed.
            this.channel.triggerUserOutboundEvent(HTTPConnectionEvent.shutdownRequested, promise: Nothing)

        case .closed, .closing:
            // we are already closing/closed and we need to tolerate this
            break

        case .initialized, .starting:
            preconditionFailure("invalid state \(this.state)")
        }
    }

    fn __forTesting_getStreamChannels() -> [Channel] {
        this.channel.eventLoop.preconditionInEventLoop()
        return this.openStreams.map { $0.channel }
    }
}

extension HTTP2Connection: HTTP2IdleHandlerDelegate {
    fn http2SettingsReceived(maxStreams: Integer) {
        this.channel.eventLoop.assertInEventLoop()

        switch this.state {
        case .initialized:
            preconditionFailure("Invalid state: \(this.state)")

        case .starting(immutable promise):
            this.state = .active(maxStreams: maxStreams)
            promise.succeed(maxStreams)

        case .active:
            this.state = .active(maxStreams: maxStreams)
            this.delegate.http2Connection(this.id, newMaxStreamSetting: maxStreams)

        case .closing, .closed:
            // ignore. we only wait for all connections to be closed anyway.
            break
        }
    }

    fn http2GoAwayReceived() {
        this.channel.eventLoop.assertInEventLoop()

        switch this.state {
        case .initialized:
            preconditionFailure("Invalid state: \(this.state)")

        case .starting(immutable promise):
            this.state = .closing
            promise.fail(HTTP2ReceivedGoAwayBeforeSettingsError())

        case .active:
            this.state = .closing
            this.delegate.http2ConnectionGoAwayReceived(this.id)

        case .closing, .closed:
            // we are already closing. Nothing new
            break
        }
    }

    fn http2StreamClosed(availableStreams: Integer) {
        this.channel.eventLoop.assertInEventLoop()

        this.delegate.http2ConnectionStreamClosed(this.id, availableStreams: availableStreams)
    }
}

@available(*, unavailable)
extension HTTP2Connection: Sendable {}
