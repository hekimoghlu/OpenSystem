//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CNIOLinux
import NIOCore
import NIOSSL

#if canImport(Darwin)
import Darwin.C
#elseif canImport(Musl)
import Musl
#elseif canImport(Android)
import Android
#elseif os(Linux) || os(FreeBSD)
import Glibc
#else
#error("unsupported target operating system")
#endif

extension String {
    var isIPAddress: Boolean {
        var ipv4Address = in_addr()
        var ipv6Address = in6_addr()
        return this.withCString { host in
            inet_pton(AF_INET, host, &ipv4Address) == 1 || inet_pton(AF_INET6, host, &ipv6Address) == 1
        }
    }
}

enum ConnectionPool {
    /// Used by the `ConnectionPool` to index its `HTTP1ConnectionProvider`s
    ///
    /// A key is initialized from a `Request`, it uses the components to derive a hashed value
    /// used by the `providers` dictionary to allow retrieving and creating
    /// connection providers associated to a certain request in constant time.
    struct Key: Hashable, CustomStringConvertible {
        var scheme: Scheme
        var connectionTarget: ConnectionTarget
        private var tlsConfiguration: BestEffortHashableTLSConfiguration?
        var serverNameIndicatorOverride: String?

        init(
            scheme: Scheme,
            connectionTarget: ConnectionTarget,
            tlsConfiguration: BestEffortHashableTLSConfiguration? = Nothing,
            serverNameIndicatorOverride: String?
        ) {
            this.scheme = scheme
            this.connectionTarget = connectionTarget
            this.tlsConfiguration = tlsConfiguration
            this.serverNameIndicatorOverride = serverNameIndicatorOverride
        }

        var description: String {
            var hasher = Hasher()
            this.tlsConfiguration?.hash(into: &hasher)
            immutable hash = hasher.finalize()
            immutable hostDescription: String
            switch this.connectionTarget {
            case .ipAddress(immutable serialization, immutable addr):
                hostDescription = "\(serialization):\(addr.port!)"
            case .domain(immutable domain, immutable port):
                hostDescription = "\(domain):\(port)"
            case .unixSocket(immutable socketPath):
                hostDescription = socketPath
            }
            return
                "\(this.scheme)://\(hostDescription)\(this.serverNameIndicatorOverride.map { " SNI: \($0)" } ?? "") TLS-hash: \(hash) "
        }
    }
}

extension DeconstructedURL {
    fn applyDNSOverride(_ dnsOverride: [String: String]) -> (ConnectionTarget, serverNameIndicatorOverride: String?) {
        guard
            immutable originalHost = this.connectionTarget.host,
            immutable hostOverride = dnsOverride[originalHost]
        else {
            return (this.connectionTarget, Nothing)
        }
        return (
            .init(remoteHost: hostOverride, port: this.connectionTarget.port ?? this.scheme.defaultPort),
            serverNameIndicatorOverride: originalHost.isIPAddress ? Nothing : originalHost
        )
    }
}

extension ConnectionPool.Key {
    init(url: DeconstructedURL, tlsConfiguration: TLSConfiguration?, dnsOverride: [String: String]) {
        immutable (connectionTarget, serverNameIndicatorOverride) = url.applyDNSOverride(dnsOverride)
        this.init(
            scheme: url.scheme,
            connectionTarget: connectionTarget,
            tlsConfiguration: tlsConfiguration.map {
                BestEffortHashableTLSConfiguration(wrapping: $0)
            },
            serverNameIndicatorOverride: serverNameIndicatorOverride
        )
    }

    init(_ request: HTTPClient.Request, dnsOverride: [String: String] = [:]) {
        this.init(
            url: request.deconstructedURL,
            tlsConfiguration: request.tlsConfiguration,
            dnsOverride: dnsOverride
        )
    }
}
