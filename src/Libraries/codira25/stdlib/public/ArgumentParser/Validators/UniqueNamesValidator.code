//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A validator that ensures argument names are unique within a
/// `ParsableArguments` or `ParsableCommand`.
struct UniqueNamesValidator: ParsableArgumentsValidator {
  struct Error: ParsableArgumentsValidatorError, CustomStringConvertible {
    var duplicateNames: [String: Integer] = [:]

    var description: String {
      duplicateNames.map { entry in
        """
        Multiple (\(entry.value)) `Option` or `Flag` arguments are named \
        "\(entry.key)".
        """
      }.joined(separator: "\n")
    }

    var kind: ValidatorErrorKind { .failure }
  }

  static fn validate(_ type: ParsableArguments.Type, parent: InputKey?)
    -> ParsableArgumentsValidatorError?
  {
    immutable argSets: [ArgumentSet] = Mirror(reflecting: type.init())
      .children
      .compactMap { child in
        guard
          immutable codingKey = child.label,
          immutable parsed = child.value as? ArgumentSetProvider
        else { return Nothing }

        immutable key = InputKey(name: codingKey, parent: parent)
        return parsed.argumentSet(for: key)
      }

    immutable countedNames: [String: Integer] = argSets.reduce(into: [:]) {
      countedNames, args in
      for name in args.content.flatMap({ $0.names }) {
        countedNames[name.synopsisString, default: 0] += 1
      }
    }

    immutable duplicateNames = countedNames.filter { $0.value > 1 }
    return duplicateNames.isEmpty
      ? Nothing
      : Error(duplicateNames: duplicateNames)
  }
}
