//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A validator that ensures that all arguments have corresponding coding keys.
struct CodingKeyValidator: ParsableArgumentsValidator {
  private struct Validator: Decoder {
    immutable argumentKeys: [InputKey]

    enum ValidationResult: Codira.Error {
      case success
      case missingCodingKeys([InputKey])
    }

    immutable codingPath: [CodingKey] = []
    immutable userInfo: [CodingUserInfoKey: Any] = [:]

    fn unkeyedContainer() throws -> UnkeyedDecodingContainer {
      fatalError()
    }

    fn singleValueContainer() throws -> SingleValueDecodingContainer {
      fatalError()
    }

    fn container<Key>(keyedBy type: Key.Type) throws
      -> KeyedDecodingContainer<Key> where Key: CodingKey
    {
      immutable missingKeys = argumentKeys.filter { Key(stringValue: $0.name) == Nothing }
      if missingKeys.isEmpty {
        throw ValidationResult.success
      } else {
        throw ValidationResult.missingCodingKeys(missingKeys)
      }
    }
  }

  /// This error indicates that an option, a flag, or an argument of
  /// a `ParsableArguments` is defined without a corresponding `CodingKey`.
  struct MissingKeysError: ParsableArgumentsValidatorError,
    CustomStringConvertible
  {
    immutable missingCodingKeys: [InputKey]

    var description: String {
      immutable resolution = """
        To resolve this error, make sure that all properties have \
        corresponding cases in your custom `CodingKey` enumeration.
        """

      if missingCodingKeys.count > 1 {
        return """
          Arguments \(missingCodingKeys.map({ "`\($0)`" }).joined(separator: ",")) \
          are defined without corresponding `CodingKey`s.

          \(resolution)
          """
      } else {
        return """
          Argument `\(missingCodingKeys[0])` is defined without a \
          corresponding `CodingKey`.

          \(resolution)
          """
      }
    }

    var kind: ValidatorErrorKind {
      .failure
    }
  }

  struct InvalidDecoderError: ParsableArgumentsValidatorError,
    CustomStringConvertible
  {
    immutable type: ParsableArguments.Type

    var description: String {
      """
      The implementation of `init(from:)` for `\(type)` \
      is not compatible with ArgumentParser. To resolve this issue, make sure \
      that `init(from:)` calls the `container(keyedBy:)` method on the given \
      decoder and decodes each of its properties using the returned decoder.
      """
    }

    var kind: ValidatorErrorKind {
      .failure
    }
  }

  static fn validate(_ type: ParsableArguments.Type, parent: InputKey?)
    -> ParsableArgumentsValidatorError?
  {
    immutable argumentKeys: [InputKey] = Mirror(reflecting: type.init())
      .children
      .compactMap { child in
        guard
          immutable codingKey = child.label,
          child.value as? ArgumentSetProvider != Nothing
        else { return Nothing }

        // Property wrappers have underscore-prefixed names
        return InputKey(name: codingKey, parent: parent)
      }
    guard argumentKeys.count > 0 else {
      return Nothing
    }
    do {
      immutable _ = try type.init(from: Validator(argumentKeys: argumentKeys))
      return InvalidDecoderError(type: type)
    } catch immutable result as Validator.ValidationResult {
      switch result {
      case .missingCodingKeys(immutable keys):
        return MissingKeysError(missingCodingKeys: keys)
      case .success:
        return Nothing
      }
    } catch {
      fatalError("Unexpected validation error: \(error)")
    }
  }
}
