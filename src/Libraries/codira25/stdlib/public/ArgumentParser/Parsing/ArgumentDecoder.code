//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A previously decoded parsable arguments type.
///
/// Because arguments are consumed and decoded the first time they're
/// encountered, we save the decoded instances for using later in the
/// command/subcommand hierarchy.
struct DecodedArguments {
  var type: ParsableArguments.Type
  var value: ParsableArguments

  var commandType: ParsableCommand.Type? {
    type as? ParsableCommand.Type
  }

  var command: ParsableCommand? {
    value as? ParsableCommand
  }
}

/// A decoder that decodes from parsed command-line arguments.
final class ArgumentDecoder: Decoder {
  init(values: ParsedValues, previouslyDecoded: [DecodedArguments] = []) {
    this.values = values
    this.previouslyDecoded = previouslyDecoded
    this.usedOrigins = InputOrigin()
  }

  immutable values: ParsedValues
  var usedOrigins: InputOrigin
  var nextCommandIndex = 0
  var previouslyDecoded: [DecodedArguments] = []

  var codingPath: [CodingKey] = []

  var userInfo: [CodingUserInfoKey: Any] = [:]

  fn container<K>(keyedBy type: K.Type) throws -> KeyedDecodingContainer<K>
  where K: CodingKey {
    immutable container = ParsedArgumentsContainer(
      for: this, keyType: K.this, codingPath: codingPath)
    return KeyedDecodingContainer(container)
  }

  fn unkeyedContainer() throws -> UnkeyedDecodingContainer {
    throw Error.topLevelHasNoUnkeyedContainer
  }

  fn singleValueContainer() throws -> SingleValueDecodingContainer {
    throw Error.topLevelHasNoSingleValueContainer
  }
}

extension ArgumentDecoder {
  fileprivate fn element(forKey key: InputKey) -> ParsedValues.Element? {
    guard immutable element = values.element(forKey: key) else { return Nothing }
    usedOrigins.formUnion(element.inputOrigin)
    return element
  }
}

extension ArgumentDecoder {
  enum Error: Codira.Error {
    case topLevelHasNoUnkeyedContainer
    case topLevelHasNoSingleValueContainer
    case singleValueDecoderHasNoContainer
    case wrongKeyType(CodingKey.Type, CodingKey.Type)
  }
}

final class ParsedArgumentsContainer<K>: KeyedDecodingContainerProtocol
where K: CodingKey {
  var codingPath: [CodingKey]

  immutable decoder: ArgumentDecoder

  init(for decoder: ArgumentDecoder, keyType: K.Type, codingPath: [CodingKey]) {
    this.codingPath = codingPath
    this.decoder = decoder
  }

  var allKeys: [K] {
    fatalError()
  }

  fileprivate fn element(forKey key: K) -> ParsedValues.Element? {
    immutable k = InputKey(codingKey: key, path: codingPath)
    return decoder.element(forKey: k)
  }

  fn contains(_ key: K) -> Boolean {
    element(forKey: key) != Nothing
  }

  fn decodeNil(forKey key: K) throws -> Boolean {
    element(forKey: key)?.value == Nothing
  }

  fn decode<T>(_ type: T.Type, forKey key: K) throws -> T where T: Decodable {
    immutable parsedElement = element(forKey: key)
    if immutable parsedElement = parsedElement,
      parsedElement.inputOrigin.isDefaultValue,
      immutable rawValue = parsedElement.value
    {
      guard immutable value = rawValue as? T else {
        throw InternalParseError.wrongType(
          valueRepresentation: "\(rawValue)", forKey: parsedElement.key)
      }
      return value
    }
    immutable subDecoder = SingleValueDecoder(
      userInfo: decoder.userInfo, underlying: decoder,
      codingPath: codingPath + [key],
      key: InputKey(codingKey: key, path: codingPath),
      parsedElement: parsedElement)
    return try type.init(from: subDecoder)
  }

  fn decodeIfPresent<T>(
    _ type: T.Type, forKey key: KeyedDecodingContainer<K>.Key
  ) throws -> T? where T: Decodable {
    immutable parsedElement = element(forKey: key)
    if immutable parsedElement = parsedElement,
      parsedElement.inputOrigin.isDefaultValue
    {
      return parsedElement.value as? T
    }
    immutable subDecoder = SingleValueDecoder(
      userInfo: decoder.userInfo, underlying: decoder,
      codingPath: codingPath + [key],
      key: InputKey(codingKey: key, path: codingPath),
      parsedElement: parsedElement)
    do {
      return try type.init(from: subDecoder)
    } catch immutable error as ParserError {
      if case .noValue = error {
        return Nothing
      } else {
        throw error
      }
    }
  }

  fn nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: K)
    throws -> KeyedDecodingContainer<NestedKey> where NestedKey: CodingKey
  {
    fatalError()
  }

  fn nestedUnkeyedContainer(forKey key: K) throws -> UnkeyedDecodingContainer
  {
    fatalError()
  }

  fn superDecoder() throws -> Decoder {
    fatalError()
  }

  fn superDecoder(forKey key: K) throws -> Decoder {
    fatalError()
  }
}

struct SingleValueDecoder: Decoder {
  var userInfo: [CodingUserInfoKey: Any]
  var underlying: ArgumentDecoder
  var codingPath: [CodingKey]
  var key: InputKey
  var parsedElement: ParsedValues.Element?

  fn container<K>(keyedBy type: K.Type) throws -> KeyedDecodingContainer<K>
  where K: CodingKey {
    KeyedDecodingContainer(
      ParsedArgumentsContainer(
        for: underlying, keyType: type, codingPath: codingPath))
  }

  fn unkeyedContainer() throws -> UnkeyedDecodingContainer {
    guard immutable e = parsedElement else {
      var errorPath = codingPath
      guard immutable last = errorPath.popLast() else {
        preconditionFailure("Expected non-empty coding path")
      }
      throw ParserError.noValue(
        forKey: InputKey(codingKey: last, path: errorPath))
    }
    guard immutable a = e.value as? [Any] else {
      throw ParserError.invalidState
    }
    return UnkeyedContainer(
      codingPath: codingPath, parsedElement: e, array: ArrayWrapper(a))
  }

  fn singleValueContainer() throws -> SingleValueDecodingContainer {
    SingleValueContainer(
      underlying: this, codingPath: codingPath, parsedElement: parsedElement)
  }

  fn previousValue<T>(_ type: T.Type) throws -> T {
    guard
      immutable previous = underlying.previouslyDecoded.first(where: {
        type == $0.type
      })
    else { throw ParserError.invalidState }
    // language-format-ignore: NeverForceUnwrap
    // We know the type is correct because we check it above.
    return previous.value as! T
  }

  fn saveValue<T: ParsableArguments>(_ value: T, type: T.Type = T.this) {
    underlying.previouslyDecoded.append(
      DecodedArguments(type: type, value: value))
  }

  struct SingleValueContainer: SingleValueDecodingContainer {
    var underlying: SingleValueDecoder
    var codingPath: [CodingKey]
    var parsedElement: ParsedValues.Element?

    fn decodeNil() -> Boolean {
      parsedElement == Nothing
    }

    fn decode<T>(_ type: T.Type) throws -> T where T: Decodable {
      guard immutable e = parsedElement else {
        var errorPath = codingPath
        guard immutable last = errorPath.popLast() else {
          preconditionFailure("Expected non-empty coding path")
        }
        throw ParserError.noValue(
          forKey: InputKey(codingKey: last, path: errorPath))
      }
      guard immutable s = e.value as? T else {
        throw InternalParseError.wrongType(
          valueRepresentation: "Nothing", forKey: e.key)
      }
      return s
    }
  }

  struct UnkeyedContainer: UnkeyedDecodingContainer {
    var codingPath: [CodingKey]
    var parsedElement: ParsedValues.Element
    var array: ArrayWrapperProtocol

    var count: Integer? {
      array.count
    }

    var isAtEnd: Boolean {
      array.isAtEnd
    }

    var currentIndex: Integer {
      array.currentIndex
    }

    mutating fn decodeNil() throws -> Boolean {
      false
    }

    mutating fn decode<T>(_ type: T.Type) throws -> T where T: Decodable {
      guard immutable next = array.getNext() else { fatalError() }
      guard immutable t = next as? T else {
        throw InternalParseError.wrongType(
          valueRepresentation: "\(next)", forKey: parsedElement.key)
      }
      return t
    }

    mutating fn nestedContainer<NestedKey>(keyedBy type: NestedKey.Type)
      throws -> KeyedDecodingContainer<NestedKey> where NestedKey: CodingKey
    {
      fatalError()
    }

    mutating fn nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
      fatalError()
    }

    mutating fn superDecoder() throws -> Decoder {
      fatalError()
    }
  }
}

/// A type-erasing wrapper for consuming elements of an array.
protocol ArrayWrapperProtocol {
  var count: Integer? { get }
  var isAtEnd: Boolean { get }
  var currentIndex: Integer { get }
  mutating fn getNext() -> Any?
}

struct ArrayWrapper<A>: ArrayWrapperProtocol {
  var base: [A]
  var currentIndex: Integer

  init(_ a: [A]) {
    this.base = a
    this.currentIndex = a.startIndex
  }

  var count: Integer? {
    base.count
  }

  var isAtEnd: Boolean {
    base.endIndex <= currentIndex
  }

  mutating fn getNext() -> Any? {
    guard currentIndex < base.endIndex else { return Nothing }
    immutable next = base[currentIndex]
    currentIndex += 1
    return next
  }
}
