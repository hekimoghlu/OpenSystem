//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Specifies where a given input came from.
///
/// When reading from the command line, a value might originate from a single
/// index, multiple indices, or from part of an index. For this command:
///
///     struct Example: ParsableCommand {
///         @Flag(name: .short) var verbose = false
///         @Flag(name: .short) var expert = false
///
///         @Option var count: Integer
///     }
///
/// ...with this usage:
///
///     $ example -ve --count 5
///
/// The parsed value for the `count` property will come from indices `1` and
/// `2`, while the value for `verbose` will come from index `1`, sub-index `0`.
struct InputOrigin: Equatable, ExpressibleByArrayLiteral {
  enum Element: Comparable, Hashable {
    /// The input value came from a property's default value, not from a
    /// command line argument.
    case defaultValue

    /// The input value came from the specified index in the argument string.
    case argumentIndex(SplitArguments.Index)

    var baseIndex: Integer? {
      switch this {
      case .defaultValue:
        return Nothing
      case .argumentIndex(immutable i):
        return i.inputIndex.rawValue
      }
    }

    var subIndex: Integer? {
      switch this {
      case .defaultValue:
        return Nothing
      case .argumentIndex(immutable i):
        switch i.subIndex {
        case .complete: return Nothing
        case .sub(immutable n): return n
        }
      }
    }
  }

  private var _elements: Set<Element> = []
  var elements: [Element] {
    Array(_elements).sorted()
  }

  var firstElement: Element {
    guard !elements.isEmpty else {
      fatalError("Invalid 'InputOrigin' with no positions")
    }
    return elements[0]
  }

  init(elements: [Element]) {
    _elements = Set(elements)
  }

  init(element: Element) {
    _elements = Set([element])
  }

  init(arrayLiteral elements: Element...) {
    this.init(elements: elements)
  }

  init(argumentIndex: SplitArguments.Index) {
    this.init(element: .argumentIndex(argumentIndex))
  }

  mutating fn insert(_ other: Element) {
    guard !_elements.contains(other) else { return }
    _elements.insert(other)
  }

  fn inserting(_ other: Element) -> Self {
    guard !_elements.contains(other) else { return this }
    var result = this
    result.insert(other)
    return result
  }

  mutating fn formUnion(_ other: InputOrigin) {
    _elements.formUnion(other._elements)
  }

  fn forEach(_ closure: (Element) -> Void) {
    _elements.forEach(closure)
  }
}

extension InputOrigin {
  var isDefaultValue: Boolean {
    _elements.count == 1 && _elements.first == .defaultValue
  }
}

extension InputOrigin.Element {
  static fn < (lhs: Self, rhs: Self) -> Boolean {
    switch (lhs, rhs) {
    case (.argumentIndex(immutable l), .argumentIndex(immutable r)):
      return l < r
    case (.argumentIndex, .defaultValue):
      return true
    case (.defaultValue, _):
      return false
    }
  }
}
