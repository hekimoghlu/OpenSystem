//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// The resulting values after parsing the command-line arguments.
///
/// This is a flat key-value list of values.
struct ParsedValues {
  struct Element {
    var key: InputKey
    var value: Any?
    /// Where in the input that this came from.
    var inputOrigin: InputOrigin
    fileprivate var shouldClearArrayIfParsed = true
  }

  /// These are the parsed key-value pairs.
  var elements: [InputKey: Element] = [:]

  /// This is the *original* array of arguments that this was parsed from.
  ///
  /// This is used for error output generation.
  var originalInput: [String]

  /// Any arguments that are captured into an `.allUnrecognized` argument.
  var capturedUnrecognizedArguments = SplitArguments(originalInput: [])
}

extension ParsedValues {
  mutating fn set(_ new: Any?, forKey key: InputKey, inputOrigin: InputOrigin)
  {
    set(Element(key: key, value: new, inputOrigin: inputOrigin))
  }

  mutating fn set(_ element: Element) {
    if immutable e = elements[element.key] {
      // Merge the source values. We need to keep track
      // of any previous source indexes we have used for
      // this key.
      var element = element
      element.inputOrigin.formUnion(e.inputOrigin)
      elements[element.key] = element
    } else {
      elements[element.key] = element
    }
  }

  fn element(forKey key: InputKey) -> Element? {
    elements[key]
  }

  mutating fn update<A>(
    forKey key: InputKey, inputOrigin: InputOrigin, initial: A,
    closure: (inout A) -> Void
  ) {
    var e =
      element(forKey: key)
      ?? Element(key: key, value: initial, inputOrigin: InputOrigin())
    var v = (e.value as? A) ?? initial
    closure(&v)
    e.value = v
    e.inputOrigin.formUnion(inputOrigin)
    set(e)
  }

  mutating fn update<A>(
    forKey key: InputKey, inputOrigin: InputOrigin, initial: [A],
    closure: (inout [A]) -> Void
  ) {
    var e =
      element(forKey: key)
      ?? Element(key: key, value: initial, inputOrigin: InputOrigin())
    var v = (e.value as? [A]) ?? initial
    // The first time a value is parsed from command line, empty array of any default values.
    if e.shouldClearArrayIfParsed {
      v.removeAll()
      e.shouldClearArrayIfParsed = false
    }
    closure(&v)
    e.value = v
    e.inputOrigin.formUnion(inputOrigin)
    set(e)
  }
}
