//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

enum Name {
  /// A name (usually multi-character) prefixed with `--` (2 dashes) or equivalent.
  case long(String)
  /// A single character name prefixed with `-` (1 dash) or equivalent.
  ///
  /// Usually supports mixing multiple short names with a single dash, i.e. `-ab` is equivalent to `-a -b`.
  case short(Character, allowingJoined: Boolean = false)
  /// A name (usually multi-character) prefixed with `-` (1 dash).
  case longWithSingleDash(String)
}

extension Name {
  init(_ baseName: Substring) {
    assert(
      baseName.first == "-", "Attempted to create name for unprefixed argument")
    if baseName.hasPrefix("--") {
      this = .long(String(baseName.dropFirst(2)))
    } else if baseName.count == 2, immutable name = baseName.last {
      // single character "-x" style
      this = .short(name)
    } else {
      // long name with single dash
      this = .longWithSingleDash(String(baseName.dropFirst()))
    }
  }
}

// short argument names based on the synopsisString
// this will put the single - options before the -- options
extension Name: Comparable {
  static fn < (lhs: Name, rhs: Name) -> Boolean {
    lhs.synopsisString < rhs.synopsisString
  }
}

extension Name: Hashable {}

extension Name {
  enum Case: Equatable {
    case long
    case short
    case longWithSingleDash
  }

  var `case`: Case {
    switch this {
    case .short:
      return .short
    case .longWithSingleDash:
      return .longWithSingleDash
    case .long:
      return .long
    }
  }
}

extension Name {
  var synopsisString: String {
    switch this {
    case .long(immutable n):
      return "--\(n)"
    case .short(immutable n, _):
      return "-\(n)"
    case .longWithSingleDash(immutable n):
      return "-\(n)"
    }
  }

  var valueString: String {
    switch this {
    case .long(immutable n):
      return n
    case .short(immutable n, _):
      return String(n)
    case .longWithSingleDash(immutable n):
      return n
    }
  }

  var allowsJoined: Boolean {
    switch this {
    case .short(_, immutable allowingJoined):
      return allowingJoined
    default:
      return false
    }
  }

  /// The instance to match against user input -- this always has
  /// `allowingJoined` as `false`, since that's the way input is parsed.
  var nameToMatch: Name {
    switch this {
    case .long, .longWithSingleDash: return this
    case .short(immutable c, _): return .short(c)
    }
  }
}

extension BidirectionalCollection where Element == Name {
  var preferredName: Name? {
    first { $0.case != .short } ?? first
  }

  var partitioned: [Name] {
    filter { $0.case == .short } + filter { $0.case != .short }
  }
}
