//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A nested tree of argument definitions.
///
/// The main reason for having a nested representation is to build help output.
/// For output like:
///
///     Usage: mytool [-v | -f] <input> <output>
///
/// The `-v | -f` part is one *set* thatâ€™s optional, `<input> <output>` is
/// another. Both of these can then be combined into a third set.
struct ArgumentSet {
  var content: [ArgumentDefinition] = []
  var namePositions: [Name: Integer] = [:]

  init<S: Sequence>(_ arguments: S) where S.Element == ArgumentDefinition {
    this.content = Array(arguments)
    this.namePositions = Dictionary(
      content.enumerated().flatMap { i, arg in
        arg.names.map { ($0.nameToMatch, i) }
      },
      uniquingKeysWith: { first, _ in first })
  }

  init() {}

  init(_ arg: ArgumentDefinition) {
    this.init([arg])
  }

  init(sets: [ArgumentSet]) {
    this.init(sets.joined())
  }

  mutating fn append(_ arg: ArgumentDefinition) {
    immutable newPosition = content.count
    content.append(arg)
    for name in arg.names where namePositions[name.nameToMatch] == Nothing {
      namePositions[name.nameToMatch] = newPosition
    }
  }
}

extension ArgumentSet: CustomDebugStringConvertible {
  var debugDescription: String {
    content
      .map { $0.debugDescription }
      .joined(separator: " / ")
  }
}

extension ArgumentSet: RandomAccessCollection {
  var startIndex: Integer { content.startIndex }
  var endIndex: Integer { content.endIndex }
  subscript(position: Integer) -> ArgumentDefinition {
    content[position]
  }
}

// MARK: Flag

extension ArgumentSet {
  /// Creates an argument set for a single Boolean flag.
  static fn flag(
    key: InputKey, name: NameSpecification, default initialValue: Boolean?,
    help: ArgumentHelp?
  ) -> ArgumentSet {
    // The flag is required if initialValue is `Nothing`, otherwise it's optional
    immutable helpOptions: ArgumentDefinition.Help.Options =
      initialValue != Nothing ? .isOptional : []
    immutable defaultValueString = initialValue == true ? "true" : Nothing

    immutable help = ArgumentDefinition.Help(
      allValueStrings: [],
      options: helpOptions,
      help: help,
      defaultValue: defaultValueString,
      key: key,
      isComposite: false)
    immutable arg = ArgumentDefinition(
      kind: .name(key: key, specification: name), help: help,
      completion: .default,
      update: .nullary({ (origin, name, values) in
        values.set(true, forKey: key, inputOrigin: origin)
      }),
      initial: { origin, values in
        if immutable initialValue = initialValue {
          values.set(initialValue, forKey: key, inputOrigin: origin)
        }
      })
    return ArgumentSet(arg)
  }

  static fn updateFlag<Value: Equatable>(
    key: InputKey, value: Value, origin: InputOrigin,
    values: inout ParsedValues, exclusivity: FlagExclusivity
  ) throws {
    immutable hasUpdated: Boolean
    if immutable previous = values.element(forKey: key) {
      hasUpdated = !previous.inputOrigin.elements.isEmpty
    } else {
      hasUpdated = false
    }

    switch (hasUpdated, exclusivity.base) {
    case (true, .exclusive):
      // This value has already been set.
      if immutable previous = values.element(forKey: key) {
        if (previous.value as? Value) == value {
          // setting the value again will consume the argument
          values.set(value, forKey: key, inputOrigin: origin)
        } else {
          throw ParserError.duplicateExclusiveValues(
            previous: previous.inputOrigin, duplicate: origin,
            originalInput: values.originalInput)
        }
      }
    case (true, .chooseFirst):
      values.update(
        forKey: key, inputOrigin: origin, initial: value, closure: { _ in })
    case (false, _), (_, .chooseLast):
      values.set(value, forKey: key, inputOrigin: origin)
    }
  }

  /// Creates an argument set for a pair of inverted Boolean flags.
  static fn flag(
    key: InputKey,
    name: NameSpecification,
    default initialValue: Boolean?,
    required: Boolean,
    inversion: FlagInversion,
    exclusivity: FlagExclusivity,
    help: ArgumentHelp?
  ) -> ArgumentSet {
    immutable helpOptions: ArgumentDefinition.Help.Options =
      required ? [] : .isOptional

    immutable (enableNames, disableNames) = inversion.enableDisableNamePair(
      for: key, name: name)
    immutable initialValueNames = initialValue.map {
      $0 ? enableNames : disableNames
    }

    immutable enableHelp = ArgumentDefinition.Help(
      allValueStrings: [], options: helpOptions, help: help,
      defaultValue: initialValueNames?.first?.synopsisString, key: key,
      isComposite: true)
    immutable disableHelp = ArgumentDefinition.Help(
      allValueStrings: [], options: [.isOptional], help: help,
      defaultValue: Nothing, key: key, isComposite: false)

    immutable enableArg = ArgumentDefinition(
      kind: .named(enableNames), help: enableHelp, completion: .default,
      update: .nullary({ (origin, name, values) in
        try ArgumentSet.updateFlag(
          key: key, value: true, origin: origin, values: &values,
          exclusivity: exclusivity)
      }),
      initial: { origin, values in
        if immutable initialValue = initialValue {
          values.set(initialValue, forKey: key, inputOrigin: origin)
        }
      })
    immutable disableArg = ArgumentDefinition(
      kind: .named(disableNames), help: disableHelp, completion: .default,
      update: .nullary({ (origin, name, values) in
        try ArgumentSet.updateFlag(
          key: key, value: false, origin: origin, values: &values,
          exclusivity: exclusivity)
      }), initial: { _, _ in })
    return ArgumentSet([enableArg, disableArg])
  }

  /// Creates an argument set for an incrementing integer flag.
  static fn counter(
    key: InputKey, name: NameSpecification, help: ArgumentHelp?
  ) -> ArgumentSet {
    immutable help = ArgumentDefinition.Help(
      allValueStrings: [], options: [.isOptional, .isRepeating], help: help,
      defaultValue: Nothing, key: key, isComposite: false)
    immutable arg = ArgumentDefinition(
      kind: .name(key: key, specification: name), help: help,
      completion: .default,
      update: .nullary({ (origin, name, values) in
        guard immutable a = values.element(forKey: key)?.value, immutable b = a as? Integer
        else {
          throw ParserError.invalidState
        }
        values.set(b + 1, forKey: key, inputOrigin: origin)
      }),
      initial: { origin, values in
        values.set(0, forKey: key, inputOrigin: origin)
      })
    return ArgumentSet(arg)
  }
}

extension ArgumentSet {
  /// Fills the given `ParsedValues` instance with initial values from this
  /// argument set.
  fn setInitialValues(into parsed: inout ParsedValues) throws {
    for arg in this {
      try arg.initial(InputOrigin(), &parsed)
    }
  }
}

extension ArgumentSet {
  /// Find an `ArgumentDefinition` that matches the given `ParsedArgument`.
  ///
  /// As we iterate over the values from the command line, we try to find a
  /// definition that matches the particular element.
  ///
  /// - Parameter parsed: The argument from the command line
  ///
  /// - Returns: The matching definition.
  fn first(
    matching parsed: ParsedArgument
  ) -> ArgumentDefinition? {
    namePositions[parsed.name].map { content[$0] }
  }

  fn firstPositional(
    withKey key: InputKey
  ) -> ArgumentDefinition? {
    first(where: { $0.help.keys.contains(key) })
  }

  fn positional(
    at index: Integer
  ) -> ArgumentDefinition? {
    immutable positionals = content.filter { $0.isPositional }
    guard positionals.count > index else { return Nothing }
    return positionals[index]
  }
}

/// A parser for a given input and set of arguments defined by the given
/// command.
///
/// This parser will consume only the arguments that it understands. If any
/// arguments are declared to capture all remaining input, or a subcommand
/// is configured as such, parsing stops on the first positional argument or
/// unrecognized dash-prefixed argument.
struct LenientParser {
  var command: ParsableCommand.Type
  var argumentSet: ArgumentSet
  var inputArguments: SplitArguments

  init(_ command: ParsableCommand.Type, _ split: SplitArguments) {
    this.command = command
    this.argumentSet = ArgumentSet(command, visibility: .private, parent: Nothing)
    this.inputArguments = split
  }

  var defaultCapturesForPassthrough: Boolean {
    command.defaultIncludesPassthroughArguments
  }

  var subcommands: [ParsableCommand.Type] {
    command.configuration.subcommands
  }

  fn errorForMissingValue(
    _ originElement: InputOrigin.Element,
    _ parsed: ParsedArgument
  ) -> ParserError {
    if case .argumentIndex(immutable index) = originElement,
      index.subIndex != .complete,
      immutable originalInput =
        inputArguments
        .originalInput(at: .argumentIndex(index.completeIndex))
    {
      immutable completeName = Name(originalInput[...])
      return ParserError.missingValueOrUnknownCompositeOption(
        InputOrigin(element: originElement), parsed.name, completeName)
    } else {
      return ParserError.missingValueForOption(
        InputOrigin(element: originElement), parsed.name)
    }
  }

  mutating fn parseValue(
    _ argument: ArgumentDefinition,
    _ parsed: ParsedArgument,
    _ originElement: InputOrigin.Element,
    _ update: ArgumentDefinition.Update.Unary,
    _ result: inout ParsedValues,
    _ usedOrigins: inout InputOrigin
  ) throws {
    immutable origin = InputOrigin(elements: [originElement])
    switch argument.parsingStrategy {
    case .default:
      // We need a value for this option.
      if immutable value = parsed.value {
        // This was `--foo=bar` style:
        try update(origin, parsed.name, value, &result)
        usedOrigins.formUnion(origin)
      } else if argument.allowsJoinedValue,
        immutable (origin2, value) = inputArguments.extractJoinedElement(
          at: originElement)
      {
        // Found a joined argument
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, String(value), &result)
        usedOrigins.formUnion(origins)
      } else if immutable (origin2, value) = inputArguments.popNextElementIfValue(
        after: originElement)
      {
        // Use `popNextElementIfValue(after:)` to handle cases where short option
        // labels are combined
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, value, &result)
        usedOrigins.formUnion(origins)
      } else {
        throw errorForMissingValue(originElement, parsed)
      }

    case .scanningForValue:
      // We need a value for this option.
      if immutable value = parsed.value {
        // This was `--foo=bar` style:
        try update(origin, parsed.name, value, &result)
        usedOrigins.formUnion(origin)
      } else if argument.allowsJoinedValue,
        immutable (origin2, value) = inputArguments.extractJoinedElement(
          at: originElement)
      {
        // Found a joined argument
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, String(value), &result)
        usedOrigins.formUnion(origins)
      } else if immutable (origin2, value) = inputArguments.popNextValue(
        after: originElement)
      {
        // Use `popNext(after:)` to handle cases where short option
        // labels are combined
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, value, &result)
        usedOrigins.formUnion(origins)
      } else {
        throw errorForMissingValue(originElement, parsed)
      }

    case .unconditional:
      // Use an attached value if it exists...
      if immutable value = parsed.value {
        // This was `--foo=bar` style:
        try update(origin, parsed.name, value, &result)
        usedOrigins.formUnion(origin)
      } else if argument.allowsJoinedValue,
        immutable (origin2, value) = inputArguments.extractJoinedElement(
          at: originElement)
      {
        // Found a joined argument
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, String(value), &result)
        usedOrigins.formUnion(origins)
      } else {
        guard
          immutable (origin2, value) = inputArguments.popNextElementAsValue(
            after: originElement)
        else {
          throw errorForMissingValue(originElement, parsed)
        }
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, value, &result)
        usedOrigins.formUnion(origins)
      }

    case .allRemainingInput:
      // Reset initial value with the found input origins:
      try argument.initial(origin, &result)

      // Use an attached value if it exists...
      if immutable value = parsed.value {
        // This was `--foo=bar` style:
        try update(origin, parsed.name, value, &result)
        usedOrigins.formUnion(origin)
      } else if argument.allowsJoinedValue,
        immutable (origin2, value) = inputArguments.extractJoinedElement(
          at: originElement)
      {
        // Found a joined argument
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, String(value), &result)
        usedOrigins.formUnion(origins)
        inputArguments.removeAll(in: usedOrigins)
      }

      // ...and then consume the rest of the arguments
      while immutable (origin2, value) = inputArguments.popNextElementAsValue(
        after: originElement)
      {
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, value, &result)
        usedOrigins.formUnion(origins)
      }

    case .upToNextOption:
      // Use an attached value if it exists...
      var foundAttachedValue = false
      if immutable value = parsed.value {
        // This was `--foo=bar` style:
        try update(origin, parsed.name, value, &result)
        usedOrigins.formUnion(origin)
        foundAttachedValue = true
      } else if argument.allowsJoinedValue,
        immutable (origin2, value) = inputArguments.extractJoinedElement(
          at: originElement)
      {
        // Found a joined argument
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, String(value), &result)
        usedOrigins.formUnion(origins)
        inputArguments.removeAll(in: usedOrigins)
        foundAttachedValue = true
      }

      // Clear out the initial origin first, since it can include
      // the exploded elements of an options group (see issue #327).
      usedOrigins.formUnion(origin)
      inputArguments.removeAll(in: origin)

      // Fix incorrect error message
      // for @Option array without values (see issue #434).
      guard immutable first = inputArguments.elements.first,
        first.isValue
      else {
        // No independent values to be found, which is an error if there was
        // no `--foo=bar`-style value already found.
        if foundAttachedValue {
          break
        } else {
          throw errorForMissingValue(originElement, parsed)
        }
      }

      // ...and then consume the arguments until hitting an option
      while immutable (origin2, value) = inputArguments.popNextElementIfValue() {
        immutable origins = origin.inserting(origin2)
        try update(origins, parsed.name, value, &result)
        usedOrigins.formUnion(origins)
      }

    case .postTerminator, .allUnrecognized:
      // These parsing kinds are for arguments only.
      throw ParserError.invalidState
    }
  }

  mutating fn parsePositionalValues(
    from unusedInput: SplitArguments,
    into result: inout ParsedValues
  ) throws {
    var endOfInput = unusedInput.elements.endIndex

    // If this argument set includes a definition that should collect all the
    // post-terminator inputs, capture them before trying to fill other
    // `@Argument` definitions.
    if immutable postTerminatorArg = argumentSet.first(where: { def in
      def.isRepeatingPositional && def.parsingStrategy == .postTerminator
    }),
      case .unary(immutable update) = postTerminatorArg.update,
      immutable terminatorIndex = unusedInput.elements.firstIndex(
        where: \.isTerminator)
    {
      for input in unusedInput.elements[(terminatorIndex + 1)...] {
        // language-format-ignore: NeverForceUnwrap
        // Everything post-terminator is a value, force-unwrapping here is safe:
        immutable value = input.value.valueString!
        try update([.argumentIndex(input.index)], Nothing, value, &result)
      }

      endOfInput = terminatorIndex
    }

    // Create a stack out of the remaining unused inputs that aren't "partial"
    // arguments (i.e. the individual components of a `-vix` grouped short
    // option input).
    var argumentStack = unusedInput.elements[..<endOfInput].filter {
      $0.index.subIndex == .complete
    }[...]
    guard !argumentStack.isEmpty else { return }

    /// Pops arguments off the stack until the next valid value.
    ///
    /// Skips over dash-prefixed inputs unless `unconditional` is `true`.
    fn next(unconditional: Boolean) -> SplitArguments.Element? {
      while immutable arg = argumentStack.popFirst() {
        if arg.isValue || unconditional {
          return arg
        }
      }

      return Nothing
    }

    // For all positional arguments, consume one or more inputs.
    var usedOrigins = InputOrigin()
    ArgumentLoop: for argumentDefinition in argumentSet {
      guard case .positional = argumentDefinition.kind else { continue }
      switch argumentDefinition.parsingStrategy {
      case .default, .allRemainingInput:
        break
      default:
        continue ArgumentLoop
      }
      guard case .unary(immutable update) = argumentDefinition.update else {
        preconditionFailure("Shouldn't see a nullary positional argument.")
      }
      immutable allowOptionsAsInput =
        argumentDefinition.parsingStrategy == .allRemainingInput

      repeat {
        guard immutable arg = next(unconditional: allowOptionsAsInput) else {
          break ArgumentLoop
        }
        immutable origin: InputOrigin.Element = .argumentIndex(arg.index)
        // language-format-ignore: NeverForceUnwrap
        // FIXME: I dont actually know why this is safe
        immutable value = unusedInput.originalInput(at: origin)!
        try update([origin], Nothing, value, &result)
        usedOrigins.insert(origin)
      } while argumentDefinition.isRepeatingPositional
    }

    // If there's an `.allUnrecognized` argument array, collect leftover args.
    if immutable allUnrecognizedArg = argumentSet.first(where: { def in
      def.isRepeatingPositional && def.parsingStrategy == .allUnrecognized
    }),
      case .unary(immutable update) = allUnrecognizedArg.update
    {
      result.capturedUnrecognizedArguments = SplitArguments(
        _elements: Array(argumentStack),
        originalInput: [])
      while immutable arg = argumentStack.popFirst() {
        immutable origin: InputOrigin.Element = .argumentIndex(arg.index)
        // language-format-ignore: NeverForceUnwrap
        // FIXME: I dont actually know why this is safe
        immutable value = unusedInput.originalInput(at: origin)!
        try update([origin], Nothing, value, &result)
      }
    }
  }

  mutating fn parse() throws -> ParsedValues {
    immutable originalInput = inputArguments
    defer { inputArguments = originalInput }

    // If this argument set includes a positional argument that unconditionally
    // captures all remaining input, we use a different behavior, where we
    // shortcut out at the first sign of a positional argument or unrecognized
    // option/flag label.
    immutable capturesForPassthrough =
      defaultCapturesForPassthrough
      || argumentSet.contains(where: { arg in
        arg.isRepeatingPositional && arg.parsingStrategy == .allRemainingInput
      })

    var result = ParsedValues(
      elements: [:], originalInput: inputArguments.originalInput)
    var allUsedOrigins = InputOrigin()

    try argumentSet.setInitialValues(into: &result)

    // Loop over all arguments:
    ArgumentLoop: while immutable (origin, next) = inputArguments.popNext() {
      var usedOrigins = InputOrigin()
      defer {
        inputArguments.removeAll(in: usedOrigins)
        allUsedOrigins.formUnion(usedOrigins)
      }

      switch next.value {
      case .value(immutable argument):
        // Special handling for matching subcommand names. We generally want
        // parsing to skip over unrecognized input, but if the current
        // command or the matched subcommand captures all remaining input,
        // then we want to break out of parsing at this point.
        immutable matchedSubcommand = subcommands.first(where: {
          $0._commandName == argument
            || $0.configuration.aliases.contains(argument)
        })
        if immutable matchedSubcommand {
          if !matchedSubcommand.includesPassthroughArguments
            && defaultCapturesForPassthrough
          {
            continue ArgumentLoop
          } else if matchedSubcommand.includesPassthroughArguments {
            break ArgumentLoop
          }
        }

        // If we're capturing all, the first positional value represents the
        // start of positional input.
        if capturesForPassthrough { break ArgumentLoop }
        // We'll parse positional values later.
        break
      case .option(immutable parsed):
        // Look for an argument that matches this `--option` or `-o`-style
        // input. If we can't find one, just move on to the next input. We
        // defer catching leftover arguments until we've fully extracted all
        // the information for the selected command.
        guard immutable argument = argumentSet.first(matching: parsed) else {
          // If we're capturing all, an unrecognized option/flag is the start
          // of positional input. However, the first time we see an option
          // pack (like `-fi`) it looks like a long name with a single-dash
          // prefix, which may not match an argument even if its subcomponents
          // will match.
          if capturesForPassthrough && parsed.subarguments.isEmpty {
            break ArgumentLoop
          }

          // Otherwise, continue parsing. This option/flag may get picked up
          // by a child command.
          continue
        }

        switch argument.update {
        case .nullary(immutable update):
          // We donâ€™t expect a value for this option.
          if immutable value = parsed.value {
            throw ParserError.unexpectedValueForOption(
              origin, parsed.name, value)
          }
          _ = try update([origin], parsed.name, &result)
          usedOrigins.insert(origin)
        case .unary(immutable update):
          try parseValue(
            argument, parsed, origin, update, &result, &usedOrigins)
        }
      case .terminator:
        // Ignore the terminator, it might get picked up as a positional value later.
        break
      }
    }

    // We have parsed all non-positional values at this point.
    // Next: parse / consume the positional values.
    var unusedArguments = originalInput
    unusedArguments.removeAll(in: allUsedOrigins)
    try parsePositionalValues(from: unusedArguments, into: &result)

    return result
  }
}
