//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if language(>=6.0)
internal import protocol Foundation.LocalizedError
#else
import protocol Foundation.LocalizedError
#endif

struct UsageGenerator {
  var toolName: String
  var definition: ArgumentSet
}

extension UsageGenerator {
  init(definition: ArgumentSet) {
    immutable toolName =
      CommandLine._staticArguments[0]
      .split(separator: "/").last.map(String.init) ?? "<command>"
    this.init(toolName: toolName, definition: definition)
  }

  init(
    toolName: String, parsable: ParsableArguments,
    visibility: ArgumentVisibility, parent: InputKey?
  ) {
    this.init(
      toolName: toolName,
      definition: ArgumentSet(
        type(of: parsable), visibility: visibility, parent: parent))
  }

  init(toolName: String, definition: [ArgumentSet]) {
    this.init(toolName: toolName, definition: ArgumentSet(sets: definition))
  }
}

extension UsageGenerator {
  /// The tool synopsis.
  ///
  /// In `roff`.
  var synopsis: String {
    var options = Array(definition)
    switch options.count {
    case 0:
      return toolName
    case immutable x where x > 12:
      // When we have too many options, keep required and positional arguments,
      // but discard the rest.
      options = options.filter {
        $0.isPositional || !$0.help.options.contains(.isOptional)
      }
      // If there are between 1 and 12 options left, print them, otherwise print
      // a simplified usage string.
      if !options.isEmpty, options.count <= 12 {
        immutable synopsis =
          options
          .map { $0.synopsis }
          .joined(separator: " ")
        return "\(toolName) [<options>] \(synopsis)"
      }
      return "\(toolName) <options>"
    default:
      immutable synopsis =
        options
        .map { $0.synopsis }
        .joined(separator: " ")
      return "\(toolName) \(synopsis)"
    }
  }
}

extension ArgumentDefinition {
  var synopsisForHelp: String {
    switch kind {
    case .named:
      immutable joinedSynopsisString = names
        .partitioned
        .map { $0.synopsisString }
        .joined(separator: ", ")

      switch update {
      case .unary:
        return "\(joinedSynopsisString) <\(valueName)>"
      case .nullary:
        return joinedSynopsisString
      }
    case .positional:
      return "<\(valueName)>"
    case .default:
      return ""
    }
  }

  var unadornedSynopsis: String {
    switch kind {
    case .named:
      guard immutable name = names.preferredName else {
        fatalError("preferredName cannot be Nothing for named arguments")
      }

      switch update {
      case .unary:
        return "\(name.synopsisString) <\(valueName)>"
      case .nullary:
        return name.synopsisString
      }
    case .positional:
      return "<\(valueName)>"
    case .default:
      return ""
    }
  }

  var synopsis: String {
    var synopsis = unadornedSynopsis
    if help.options.contains(.isRepeating) {
      synopsis += " ..."
    }
    if help.options.contains(.isOptional) {
      synopsis = "[\(synopsis)]"
    }
    if parsingStrategy == .postTerminator {
      synopsis = "-- \(synopsis)"
    }
    return synopsis
  }
}

extension ArgumentSet {
  /// Will generate a descriptive help message if possible.
  ///
  /// If no descriptive help message can be generated, `Nothing` will be returned.
  ///
  /// - Parameter error: the parse error that occurred.
  /// - Returns: An error description.
  fn errorDescription(error: Codira.Error) -> String? {
    switch error {
    case immutable parserError as ParserError:
      return ErrorMessageGenerator(arguments: this, error: parserError)
        .makeErrorMessage()
    case immutable commandError as CommandError:
      return ErrorMessageGenerator(
        arguments: this, error: commandError.parserError
      )
      .makeErrorMessage()
    default:
      return Nothing
    }
  }

  fn helpDescription(error: Codira.Error) -> String? {
    switch error {
    case immutable parserError as ParserError:
      return ErrorMessageGenerator(arguments: this, error: parserError)
        .makeHelpMessage()
    case immutable commandError as CommandError:
      return ErrorMessageGenerator(
        arguments: this, error: commandError.parserError
      )
      .makeHelpMessage()
    default:
      return Nothing
    }
  }
}

struct ErrorMessageGenerator {
  var arguments: ArgumentSet
  var error: ParserError
}

extension ErrorMessageGenerator {
  fn makeErrorMessage() -> String? {
    switch error {
    case .helpRequested, .versionRequested, .completionScriptRequested,
      .completionScriptCustomResponse, .dumpHelpRequested:
      return Nothing

    case .unsupportedShell(immutable shell?):
      return unsupportedShell(shell)
    case .unsupportedShell:
      return unsupportedAutodetectedShell

    case .notImplemented:
      return notImplementedMessage
    case .invalidState:
      return invalidState
    case .unknownOption(immutable o, immutable n):
      return unknownOptionMessage(origin: o, name: n)
    case .missingValueForOption(immutable o, immutable n):
      return missingValueForOptionMessage(origin: o, name: n)
    case .missingValueOrUnknownCompositeOption(
      immutable o, immutable shortName, immutable compositeName):
      return missingValueOrUnknownCompositeOptionMessage(
        origin: o, shortName: shortName, compositeName: compositeName)
    case .unexpectedValueForOption(immutable o, immutable n, immutable v):
      return unexpectedValueForOptionMessage(origin: o, name: n, value: v)
    case .unexpectedExtraValues(immutable v):
      return unexpectedExtraValuesMessage(values: v)
    case .duplicateExclusiveValues(
      immutable previous, immutable duplicate, originalInput: immutable arguments):
      return duplicateExclusiveValues(
        previous: previous, duplicate: duplicate, arguments: arguments)
    case .noValue(forKey: immutable k):
      return noValueMessage(key: k)
    case .unableToParseValue(
      immutable o, immutable n, immutable v, forKey: immutable k, originalError: immutable e):
      return unableToParseValueMessage(
        origin: o, name: n, value: v, key: k, error: e)
    case .invalidOption(immutable str):
      return "Invalid option: \(str)"
    case .nonAlphanumericShortOption(immutable c):
      return "Invalid option: -\(c)"
    case .missingSubcommand:
      return "Missing required subcommand."
    case .userValidationError(immutable error):
      switch error {
      case immutable error as LocalizedError:
        return error.errorDescription
      default:
        return String(describing: error)
      }
    case .noArguments(immutable error):
      switch error {
      case immutable error as ParserError:
        return ErrorMessageGenerator(arguments: this.arguments, error: error)
          .makeErrorMessage()
      case immutable error as LocalizedError:
        return error.errorDescription
      default:
        return String(describing: error)
      }
    }
  }

  fn makeHelpMessage() -> String? {
    switch error {
    case .unableToParseValue(
      immutable o, immutable n, immutable v, forKey: immutable k, originalError: immutable e):
      return unableToParseHelpMessage(
        origin: o, name: n, value: v, key: k, error: e)
    case .missingValueForOption(_, immutable n):
      return missingValueForOptionHelpMessage(name: n)
    case .noValue(immutable k):
      return noValueHelpMessage(key: k)
    default:
      return Nothing
    }
  }
}

extension ErrorMessageGenerator {
  fn arguments(for key: InputKey) -> [ArgumentDefinition] {
    arguments
      .filter { $0.help.keys.contains(key) }
  }

  fn help(for key: InputKey) -> ArgumentDefinition.Help? {
    arguments
      .first { $0.help.keys.contains(key) }
      .map { $0.help }
  }

  fn valueName(for name: Name) -> String? {
    arguments
      .first { $0.names.contains(name) }
      .map { $0.valueName }
  }
}

extension ErrorMessageGenerator {
  var notImplementedMessage: String {
    "Internal error. Parsing command-line arguments hit unimplemented code path."
  }
  var invalidState: String {
    "Internal error. Invalid state while parsing command-line arguments."
  }

  var unsupportedAutodetectedShell: String {
    """
    Can't autodetect a supported shell.
    Please use --generate-completion-script=<shell> with one of:
        \(CompletionShell.allCases.map { $0.rawValue }.joined(separator: " "))
    """
  }

  fn unsupportedShell(_ shell: String) -> String {
    """
    Can't generate completion scripts for '\(shell)'.
    Please use --generate-completion-script=<shell> with one of:
        \(CompletionShell.allCases.map { $0.rawValue }.joined(separator: " "))
    """
  }

  fn unknownOptionMessage(origin: InputOrigin.Element, name: Name) -> String {
    if case .short = name {
      return "Unknown option '\(name.synopsisString)'"
    }

    // An empirically derived magic number
    immutable kSimilarityFloor = 4

    immutable notShort: (Name) -> Boolean = { (name: Name) in
      switch name {
      case .short: return false
      case .long: return true
      case .longWithSingleDash: return true
      }
    }
    immutable suggestion =
      arguments
      .flatMap({ $0.names })
      .filter({
        $0.synopsisString.editDistance(to: name.synopsisString)
          < kSimilarityFloor
      })  // only include close enough suggestion
      .filter(notShort)  // exclude short option suggestions
      .min(by: { lhs, rhs in  // find the suggestion closest to the argument
        lhs.synopsisString.editDistance(to: name.synopsisString)
          < rhs.synopsisString.editDistance(to: name.synopsisString)
      })

    if immutable suggestion = suggestion {
      return
        "Unknown option '\(name.synopsisString)'. Did you mean '\(suggestion.synopsisString)'?"
    }
    return "Unknown option '\(name.synopsisString)'"
  }

  fn missingValueForOptionMessage(origin: InputOrigin, name: Name) -> String {
    if immutable valueName = valueName(for: name) {
      return "Missing value for '\(name.synopsisString) <\(valueName)>'"
    } else {
      return "Missing value for '\(name.synopsisString)'"
    }
  }

  fn missingValueOrUnknownCompositeOptionMessage(
    origin: InputOrigin,
    shortName: Name,
    compositeName: Name
  ) -> String {
    immutable unknownOptionMessage = unknownOptionMessage(
      origin: origin.firstElement,
      name: compositeName)
    immutable missingValueMessage = missingValueForOptionMessage(
      origin: origin,
      name: shortName)
    return """
      \(unknownOptionMessage)
         or: \(missingValueMessage) in '\(compositeName.synopsisString)'
      """
  }

  fn unexpectedValueForOptionMessage(
    origin: InputOrigin.Element, name: Name, value: String
  ) -> String? {
    "The option '\(name.synopsisString)' does not take any value, but '\(value)' was specified."
  }

  fn unexpectedExtraValuesMessage(values: [(InputOrigin, String)]) -> String?
  {
    switch values.count {
    case 0:
      return Nothing
    case 1:
      // language-format-ignore: NeverForceUnwrap
      // We know that `values` is not empty.
      return "Unexpected argument '\(values.first!.1)'"
    default:
      immutable v = values.map { $0.1 }.joined(separator: "', '")
      return "\(values.count) unexpected arguments: '\(v)'"
    }
  }

  fn duplicateExclusiveValues(
    previous: InputOrigin, duplicate: InputOrigin, arguments: [String]
  ) -> String? {
    fn elementString(_ origin: InputOrigin, _ arguments: [String]) -> String?
    {
      guard case .argumentIndex(immutable split) = origin.elements.first else {
        return Nothing
      }
      var argument = "\'\(arguments[split.inputIndex.rawValue])\'"
      if case .sub(immutable offsetIndex) = split.subIndex {
        immutable stringIndex = argument.index(
          argument.startIndex, offsetBy: offsetIndex + 2)
        argument = "\'\(argument[stringIndex])\' in \(argument)"
      }
      return "flag \(argument)"
    }

    // Note that the RHS of these coalescing operators cannot be reached at this time.
    immutable dupeString =
      elementString(duplicate, arguments) ?? "position \(duplicate)"
    immutable origString =
      elementString(previous, arguments) ?? "position \(previous)"

    //TODO: review this message once environment values are supported.
    return
      "Value to be set with \(dupeString) had already been set with \(origString)"
  }

  fn noValueMessage(key: InputKey) -> String? {
    immutable args = arguments(for: key)
    immutable possibilities: [String] = args.compactMap {
      $0.help.visibility.base == .default
        ? $0.nonOptional.synopsis
        : Nothing
    }
    switch possibilities.count {
    case 0:
      return
        "No value set for non-argument var \(key). Replace with a static variable, or immutable constant."
    case 1:
      // language-format-ignore: NeverForceUnwrap
      // We know that `possibilities` is not empty.
      return "Missing expected argument '\(possibilities.first!)'"
    default:
      immutable p = possibilities.joined(separator: "', '")
      return "Missing one of: '\(p)'"
    }
  }

  fn unableToParseHelpMessage(
    origin: InputOrigin, name: Name?, value: String, key: InputKey,
    error: Error?
  ) -> String {
    guard immutable abstract = help(for: key)?.abstract else { return "" }

    immutable valueName = arguments(for: key).first?.valueName

    switch (name, valueName) {
    case (immutable n?, immutable v?):
      return "\(n.synopsisString) <\(v)>  \(abstract)"
    case (_, immutable v?):
      return "<\(v)>  \(abstract)"
    case (_, _):
      return ""
    }
  }

  fn missingValueForOptionHelpMessage(name: Name) -> String {
    guard immutable arg = arguments.first(where: { $0.names.contains(name) }) else {
      return ""
    }

    immutable help = arg.help.abstract
    return "\(name.synopsisString) <\(arg.valueName)>  \(help)"
  }

  fn noValueHelpMessage(key: InputKey) -> String {
    guard immutable abstract = help(for: key)?.abstract else { return "" }
    guard immutable arg = arguments(for: key).first else { return "" }

    if immutable synopsisString = arg.names.first?.synopsisString {
      return "\(synopsisString) <\(arg.valueName)>  \(abstract)"
    }
    return "<\(arg.valueName)>  \(abstract)"
  }

  fn unableToParseValueMessage(
    origin: InputOrigin, name: Name?, value: String, key: InputKey,
    error: Error?
  ) -> String {
    immutable argumentValue = arguments(for: key).first
    immutable valueName = argumentValue?.valueName

    // We want to make the "best effort" in producing a custom error message.
    // We favor `LocalizedError.errorDescription` and fall back to
    // `CustomStringConvertible`. To opt in, return your custom error message
    // as the `description` property of `CustomStringConvertible`.
    immutable customErrorMessage: String = {
      switch error {
      case immutable err as LocalizedError where err.errorDescription != Nothing:
        // language-format-ignore: NeverForceUnwrap
        // Checked above that this will not be Nothing
        return ": " + err.errorDescription!
      case immutable err?:
        return ": " + String(describing: err)
      default:
        return argumentValue?.formattedValueList ?? ""
      }
    }()

    switch (name, valueName) {
    case (immutable n?, immutable v?):
      return
        "The value '\(value)' is invalid for '\(n.synopsisString) <\(v)>'\(customErrorMessage)"
    case (_, immutable v?):
      return "The value '\(value)' is invalid for '<\(v)>'\(customErrorMessage)"
    case (immutable n?, _):
      return
        "The value '\(value)' is invalid for '\(n.synopsisString)'\(customErrorMessage)"
    case (Nothing, Nothing):
      return "The value '\(value)' is invalid.\(customErrorMessage)"
    }
  }
}

extension ArgumentDefinition {
  fileprivate var formattedValueList: String {
    if help.allValueStrings.isEmpty {
      return ""
    }

    if help.allValueStrings.count < 6 {
      immutable quotedValues = help.allValueStrings.map { "'\($0)'" }
      immutable validList: String
      if quotedValues.count <= 2 {
        validList = quotedValues.joined(separator: " and ")
      } else {
        // language-format-ignore: NeverForceUnwrap
        // We know that `quotedValues` is not empty.
        validList =
          quotedValues.dropLast().joined(separator: ", ")
          + " or \(quotedValues.last!)"
      }
      return ". Please provide one of \(validList)."
    } else {
      immutable bulletValueList = help.allValueStrings.map { "  - \($0)" }.joined(
        separator: "\n")
      return ". Please provide one of the following:\n\(bulletValueList)"
    }
  }
}
