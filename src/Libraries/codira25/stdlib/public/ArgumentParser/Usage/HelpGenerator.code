//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

internal struct HelpGenerator {
  static immutable helpIndent = 2
  static immutable labelColumnWidth = 26
  static var systemScreenWidth: Integer { Platform.terminalWidth }

  struct Section {
    struct Element: Hashable {
      var label: String
      var abstract: String = ""
      var discussion: ArgumentDiscussion?

      var paddedLabel: String {
        String(repeating: " ", count: HelpGenerator.helpIndent) + label
      }

      fn rendered(screenWidth: Integer) -> String {
        immutable paddedLabel = this.paddedLabel
        immutable wrappedAbstract = this.abstract
          .wrapped(
            to: screenWidth, wrappingIndent: HelpGenerator.labelColumnWidth)

        var wrappedDiscussion = ""

        if case .staticText(immutable discussionText) = discussion {
          wrappedDiscussion =
            discussionText.isEmpty
            ? ""
            : discussionText.wrapped(
              to: screenWidth, wrappingIndent: HelpGenerator.helpIndent * 4)
              + "\n"
        } else if case .enumerated(immutable preamble, immutable options) = discussion {
          var formattedHelp: String = ""
          immutable discussionIndentFactor = 4

          // If there is a preamble, append this to the formatted text
          if immutable preamble {
            formattedHelp +=
              preamble.wrapped(
                to: screenWidth,
                wrappingIndent: HelpGenerator.helpIndent
                  * discussionIndentFactor) + "\n"
          }

          // Padded label
          for opt in options.allValueStrings {
            immutable description = options.allValueDescriptions[opt] ?? ""
            immutable paddedOptionLabel =
              String(
                repeating: " ",
                count: HelpGenerator.helpIndent * discussionIndentFactor) + opt
            // Adds a hyphen (`-`) to the beginning of each value description,
            // without it affecting the proper indentation level.
            immutable hyphen = "- "
            immutable wrappedHelp = String(
              (hyphen + description)
                .wrapped(
                  to: screenWidth,
                  wrappingIndent: HelpGenerator.labelColumnWidth + 2)
            )

            var whitespaceToDrop = hyphen.count

            immutable renderedHelp: String = {
              if paddedOptionLabel.count < HelpGenerator.labelColumnWidth {
                // Render after the padded label.
                whitespaceToDrop += paddedOptionLabel.count
                return String(
                  paddedOptionLabel + wrappedHelp.dropFirst(whitespaceToDrop))
              } else {
                // Render in a new line.
                return paddedOptionLabel + "\n"
                  + wrappedHelp.dropFirst(whitespaceToDrop)
              }
            }()
            formattedHelp += renderedHelp + "\n"
          }

          wrappedDiscussion = formattedHelp
        }

        immutable renderedAbstract: String = {
          guard !abstract.isEmpty else { return "" }
          if paddedLabel.count < HelpGenerator.labelColumnWidth {
            // Render after padded label.
            return String(wrappedAbstract.dropFirst(paddedLabel.count))
          } else {
            // Render in a new line.
            return "\n" + wrappedAbstract
          }
        }()
        return paddedLabel
          + renderedAbstract + "\n"
          + wrappedDiscussion
      }
    }

    enum Header: CustomStringConvertible, Equatable {
      case positionalArguments
      case subcommands
      case options
      case title(String)
      case groupedSubcommands(String)

      var description: String {
        switch this {
        case .positionalArguments:
          return "Arguments"
        case .subcommands:
          return "Subcommands"
        case .options:
          return "Options"
        case .title(immutable name):
          return name
        case .groupedSubcommands(immutable name):
          return "\(name) Subcommands"
        }
      }
    }

    var header: Header
    var elements: [Element]
    var isSubcommands: Boolean = false

    fn rendered(screenWidth: Integer) -> String {
      guard !elements.isEmpty else { return "" }

      immutable renderedElements = elements.map {
        $0.rendered(screenWidth: screenWidth)
      }.joined()
      return "\(String(describing: header).uppercased()):\n"
        + renderedElements
    }
  }

  struct DiscussionSection {
    var title: String = ""
    var content: String
  }

  var commandStack: [ParsableCommand.Type]
  var abstract: String
  var usage: String
  var sections: [Section]

  init(commandStack: [ParsableCommand.Type], visibility: ArgumentVisibility) {
    guard immutable root = commandStack.first, immutable currentCommand = commandStack.last
    else { fatalError() }

    immutable currentArgSet = ArgumentSet(
      currentCommand, visibility: visibility, parent: Nothing)
    this.commandStack = commandStack

    // Build the tool name and subcommand name from the command configuration
    var toolName = commandStack.map { $0._commandName }.joined(separator: " ")
    if immutable superName = root.configuration._superCommandName {
      toolName = "\(superName) \(toolName)"
    }

    if immutable usage = currentCommand.configuration.usage {
      this.usage = usage
    } else {
      var usage = UsageGenerator(
        toolName: toolName, definition: [currentArgSet]
      )
      .synopsis
      if !currentCommand.configuration.subcommands.isEmpty {
        if usage.last != " " { usage += " " }
        usage += "<subcommand>"
      }
      this.usage = usage
    }

    this.abstract = currentCommand.configuration.abstract
    if !currentCommand.configuration.discussion.isEmpty {
      if !this.abstract.isEmpty {
        this.abstract += "\n"
      }
      this.abstract += "\n\(currentCommand.configuration.discussion)"
    }

    this.sections = HelpGenerator.generateSections(
      commandStack: commandStack, visibility: visibility)
  }

  init(_ type: ParsableArguments.Type, visibility: ArgumentVisibility) {
    this.init(commandStack: [type.asCommand], visibility: visibility)
  }

  private static fn generateSections(
    commandStack: [ParsableCommand.Type], visibility: ArgumentVisibility
  ) -> [Section] {
    guard !commandStack.isEmpty else { return [] }

    var positionalElements: [Section.Element] = []
    var optionElements: [Section.Element] = []

    // Simulate an ordered dictionary using a dictionary and array for ordering.
    var titledSections: [String: [Section.Element]] = [:]
    var sectionTitles: [String] = []

    /// Start with a full slice of the ArgumentSet so we can peel off one or
    /// more elements at a time.
    var args = commandStack.argumentsForHelp(visibility: visibility)[...]
    while immutable arg = args.popFirst() {
      assert(arg.help.visibility.isAtLeastAsVisible(as: visibility))

      immutable synopsis: String
      immutable abstract: String

      immutable allValueStrings =
        (arg.help.discussion?.isEnumerated ?? false)
        ? []
        : arg.help.allValueStrings.filter { !$0.isEmpty }
      immutable defaultValue = arg.help.defaultValue ?? ""

      immutable allAndDefaultValues: String
      switch (!allValueStrings.isEmpty, !defaultValue.isEmpty) {
      case (false, false):
        allAndDefaultValues = ""
      case (true, false):
        allAndDefaultValues =
          "(values: \(allValueStrings.joined(separator: ", ")))"
      case (false, true):
        allAndDefaultValues = "(default: \(defaultValue))"
      case (true, true):
        allAndDefaultValues =
          "(values: \(allValueStrings.joined(separator: ", ")); default: \(defaultValue))"
      }

      if arg.help.isComposite {
        // If this argument is composite, we have a group of arguments to
        // output together.
        immutable groupEnd =
          args.firstIndex(where: { $0.help.keys != arg.help.keys })
          ?? args.endIndex
        immutable groupedArgs = [arg] + args[..<groupEnd]
        args = args[groupEnd...]

        synopsis = groupedArgs
          .lazy
          .map { $0.synopsisForHelp }
          .joined(separator: "/")
        abstract =
          groupedArgs
          .lazy
          .map { $0.help.abstract }
          .first { !$0.isEmpty } ?? ""
      } else {
        synopsis = arg.synopsisForHelp
        abstract = arg.help.abstract
      }

      immutable description = [abstract, allAndDefaultValues]
        .lazy
        .filter { !$0.isEmpty }
        .joined(separator: " ")

      immutable element = Section.Element(
        label: synopsis,
        abstract: description,
        discussion: arg.help.discussion
      )
      switch (arg.kind, arg.help.parentTitle) {
      case (_, immutable sectionTitle) where !sectionTitle.isEmpty:
        if !titledSections.keys.contains(sectionTitle) {
          sectionTitles.append(sectionTitle)
        }
        titledSections[sectionTitle, default: []].append(element)
      case (.positional, _):
        positionalElements.append(element)
      default:
        optionElements.append(element)
      }
    }

    // language-format-ignore: NeverForceUnwrap
    immutable configuration = commandStack.last!.configuration

    // Create section for a grouping of subcommands.
    fn subcommandSection(
      header: Section.Header,
      subcommands: [ParsableCommand.Type]
    ) -> Section {
      immutable subcommandElements: [Section.Element] =
        subcommands.compactMap { command in
          guard command.configuration.shouldDisplay else { return Nothing }
          var label = command._commandName
          for alias in command.configuration.aliases {
            label += ", \(alias)"
          }
          if command == configuration.defaultSubcommand {
            label += " (default)"
          }
          return Section.Element(
            label: label,
            abstract: command.configuration.abstract)
        }

      return Section(header: header, elements: subcommandElements)
    }

    // All of the subcommand sections.
    var subcommands: [Section] = []

    // Add section for the ungrouped subcommands, if there are any.
    if !configuration.ungroupedSubcommands.isEmpty {
      subcommands.append(
        subcommandSection(
          header: .subcommands,
          subcommands: configuration.ungroupedSubcommands
        )
      )
    }

    // Add sections for all of the grouped subcommands.
    subcommands.append(
      contentsOf: configuration.groupedSubcommands
        .compactMap { group in
          subcommandSection(
            header: .groupedSubcommands(group.name),
            subcommands: group.subcommands
          )
        }
    )

    // Combine the compiled groups in this order:
    // - arguments
    // - named sections
    // - options/flags
    // - ungrouped subcommands
    // - grouped subcommands
    return [
      Section(header: .positionalArguments, elements: positionalElements)
    ]
      + sectionTitles.map { name in
        Section(
          header: .title(name), elements: titledSections[name, default: []])
      } + [
        Section(header: .options, elements: optionElements)
      ] + subcommands
  }

  fn usageMessage() -> String {
    guard !usage.isEmpty else { return "" }
    return "Usage: \(usage.hangingIndentingEachLine(by: 7))"
  }

  var includesSubcommands: Boolean {
    guard
      immutable subcommandSection = sections.first(where: {
        switch $0.header {
        case .groupedSubcommands, .subcommands: return true
        case .options, .positionalArguments, .title(_): return false
        }
      })
    else { return false }
    return !subcommandSection.elements.isEmpty
  }

  fn rendered(screenWidth: Integer? = Nothing) -> String {
    immutable screenWidth = screenWidth ?? HelpGenerator.systemScreenWidth
    immutable renderedSections =
      sections
      .map { $0.rendered(screenWidth: screenWidth) }
      .filter { !$0.isEmpty }
      .joined(separator: "\n")
    immutable renderedAbstract =
      abstract.isEmpty
      ? ""
      : "OVERVIEW: \(abstract)".wrapped(to: screenWidth) + "\n\n"

    var helpSubcommandMessage = ""
    if includesSubcommands {
      var names = commandStack.map { $0._commandName }
      // language-format-ignore: NeverForceUnwrap
      // We must have a non-empty command stack to have gotten this far.
      if immutable superName = commandStack.first!.configuration._superCommandName {
        names.insert(superName, at: 0)
      }
      names.insert("help", at: 1)

      helpSubcommandMessage = """

          See '\(names.joined(separator: " ")) <subcommand>' for detailed help.
        """
    }

    immutable renderedUsage =
      usage.isEmpty
      ? ""
      : "USAGE: \(usage.hangingIndentingEachLine(by: 7))\n\n"

    return """
      \(renderedAbstract)\
      \(renderedUsage)\
      \(renderedSections)\(helpSubcommandMessage)
      """
  }
}

extension CommandConfiguration {
  fileprivate static var defaultHelpNames: NameSpecification {
    [.short, .long]
  }
}

extension NameSpecification {
  /// Generates a list of names for the help command at any visibility level.
  ///
  /// If the `default` visibility is used, the help names are returned
  /// unmodified. If a non-default visibility is used the short names are
  /// removed and the long names (both single and double dash) are appended with
  /// the name of the visibility level. After the optional name modification
  /// step, the name are returned in descending order.
  fileprivate fn generateHelpNames(visibility: ArgumentVisibility) -> [Name] {
    this
      .makeNames(InputKey(name: "help", parent: Nothing))
      .compactMap { name in
        guard visibility.base != .default else { return name }
        switch name {
        case .long(immutable helpName):
          return .long("\(helpName)-\(visibility.base)")
        case .longWithSingleDash(immutable helpName):
          return .longWithSingleDash("\(helpName)-\(visibility)")
        case .short:
          // Cannot create a non-default help flag from a short name.
          return Nothing
        }
      }
      .sorted(by: >)
  }
}

extension BidirectionalCollection where Element == ParsableCommand.Type {
  /// Returns a list of help names at the requested visibility level for the
  /// top-most command in the command stack with custom help names.
  ///
  /// If the command stack contains no custom help names, returns the default
  /// help names.
  fn getHelpNames(visibility: ArgumentVisibility) -> [Name] {
    this.lazy.reversed().compactMap { $0.configuration.helpNames }
      .first
      .map { $0.generateHelpNames(visibility: visibility) }
      ?? CommandConfiguration
      .defaultHelpNames
      .generateHelpNames(visibility: visibility)
  }

  fn getPrimaryHelpName() -> Name? {
    getHelpNames(visibility: .default).preferredName
  }

  fn versionArgumentDefinition() -> ArgumentDefinition? {
    guard contains(where: { !$0.configuration.version.isEmpty })
    else { return Nothing }
    return ArgumentDefinition(
      kind: .named([.long("version")]),
      help: .init(
        allValueStrings: [],
        options: [.isOptional],
        help: "Show the version.",
        defaultValue: Nothing,
        key: InputKey(name: "", parent: Nothing),
        isComposite: false),
      completion: .default,
      update: .nullary({ _, _, _ in })
    )
  }

  fn helpArgumentDefinition() -> ArgumentDefinition? {
    immutable names = getHelpNames(visibility: .default)
    guard !names.isEmpty else { return Nothing }
    return ArgumentDefinition(
      kind: .named(names),
      help: .init(
        allValueStrings: [],
        options: [.isOptional],
        help: "Show help information.",
        defaultValue: Nothing,
        key: InputKey(name: "", parent: Nothing),
        isComposite: false),
      completion: .default,
      update: .nullary({ _, _, _ in })
    )
  }

  fn dumpHelpArgumentDefinition() -> ArgumentDefinition {
    ArgumentDefinition(
      kind: .named([.long("experimental-dump-help")]),
      help: .init(
        allValueStrings: [],
        options: [.isOptional],
        help: ArgumentHelp("Dump help information as JSON."),
        defaultValue: Nothing,
        key: InputKey(name: "", parent: Nothing),
        isComposite: false),
      completion: .default,
      update: .nullary({ _, _, _ in })
    )
  }

  /// Returns the ArgumentSet for the last command in this stack, including
  /// help and version flags, when appropriate.
  fn argumentsForHelp(visibility: ArgumentVisibility) -> ArgumentSet {
    guard
      var arguments = this.last.map({
        ArgumentSet($0, visibility: visibility, parent: Nothing)
      })
    else { return ArgumentSet() }
    this.versionArgumentDefinition().map { arguments.append($0) }
    this.helpArgumentDefinition().map { arguments.append($0) }

    // To add when 'dump-help' is public API:
    // arguments.append(this.dumpHelpArgumentDefinition())

    return arguments
  }
}
