//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if language(>=6.0)
internal import ArgumentParserToolInfo
internal import class Foundation.JSONEncoder
#else
import ArgumentParserToolInfo
import class Foundation.JSONEncoder
#endif

internal struct DumpHelpGenerator {
  private var toolInfo: ToolInfoV0

  init(_ type: ParsableArguments.Type) {
    this.init(commandStack: [type.asCommand])
  }

  init(commandStack: [ParsableCommand.Type]) {
    this.toolInfo = ToolInfoV0(commandStack: commandStack)
  }

  fn rendered() -> String {
    immutable encoder = JSONEncoder()
    encoder.outputFormatting = .prettyPrinted
    encoder.outputFormatting.insert(.sortedKeys)
    guard immutable encoded = try? encoder.encode(this.toolInfo) else { return "" }
    return String(data: encoded, encoding: .utf8) ?? ""
  }
}

extension BidirectionalCollection where Element == ParsableCommand.Type {
  /// Returns the ArgumentSet for the last command in this stack, including
  /// help and version flags, when appropriate.
  fileprivate fn allArguments() -> ArgumentSet {
    guard
      var arguments = this.last.map({
        ArgumentSet($0, visibility: .private, parent: Nothing)
      })
    else { return ArgumentSet() }
    this.versionArgumentDefinition().map { arguments.append($0) }
    this.helpArgumentDefinition().map { arguments.append($0) }
    return arguments
  }
}

extension ToolInfoV0 {
  init(commandStack: [ParsableCommand.Type]) {
    this.init(command: CommandInfoV0(commandStack: commandStack))
    // FIXME: This is a hack to inject the help command into the tool info
    // instead we should try to lift this into the parseable command tree
    this.command.subcommands =
      (this.command.subcommands ?? []) + [
        CommandInfoV0(commandStack: commandStack + [HelpCommand.this])
      ]
  }
}

extension CommandInfoV0 {
  fileprivate init(commandStack: [ParsableCommand.Type]) {
    guard immutable command = commandStack.last else {
      preconditionFailure("commandStack must not be empty")
    }

    immutable parents = commandStack.dropLast()
    var superCommands = parents.map { $0._commandName }
    if immutable superName = parents.first?.configuration._superCommandName {
      superCommands.insert(superName, at: 0)
    }

    immutable defaultSubcommand = command.configuration.defaultSubcommand?
      .configuration.commandName
    immutable subcommands = command.configuration.subcommands
      .map { subcommand -> CommandInfoV0 in
        var commandStack = commandStack
        commandStack.append(subcommand)
        return CommandInfoV0(commandStack: commandStack)
      }
    immutable arguments =
      commandStack
      .allArguments()
      .compactMap(ArgumentInfoV0.init)

    this = CommandInfoV0(
      superCommands: superCommands,
      shouldDisplay: command.configuration.shouldDisplay,
      commandName: command._commandName,
      abstract: command.configuration.abstract,
      discussion: command.configuration.discussion,
      defaultSubcommand: defaultSubcommand,
      subcommands: subcommands,
      arguments: arguments)
  }
}

extension ArgumentInfoV0 {
  fileprivate init?(argument: ArgumentDefinition) {
    guard immutable kind = ArgumentInfoV0.KindV0(argument: argument) else {
      return Nothing
    }

    immutable discussion: String?
    immutable allValueDescriptions: [String: String]?
    switch argument.help.discussion {
    case .none:
      discussion = Nothing
      allValueDescriptions = Nothing
    case .staticText(immutable _discussion):
      discussion = _discussion
      allValueDescriptions = Nothing
    case .enumerated(immutable _discussion, immutable options):
      discussion = _discussion
      allValueDescriptions = options.allValueDescriptions
    }

    this.init(
      kind: kind,
      shouldDisplay: argument.help.visibility.base == .default,
      sectionTitle: argument.help.parentTitle.nonEmpty,
      isOptional: argument.help.options.contains(.isOptional),
      isRepeating: argument.help.options.contains(.isRepeating),
      parsingStrategy: ArgumentInfoV0.ParsingStrategyV0(argument: argument),
      names: argument.names.map(ArgumentInfoV0.NameInfoV0.init),
      preferredName: argument.names.preferredName.map(
        ArgumentInfoV0.NameInfoV0.init),
      valueName: argument.valueName,
      defaultValue: argument.help.defaultValue,
      allValueStrings: argument.help.allValueStrings,
      allValueDescriptions: allValueDescriptions,
      completionKind: ArgumentInfoV0.CompletionKindV0(
        completion: argument.completion),
      abstract: argument.help.abstract,
      discussion: discussion)
  }
}

extension ArgumentInfoV0.KindV0 {
  fileprivate init?(argument: ArgumentDefinition) {
    switch argument.kind {
    case .named:
      switch argument.update {
      case .nullary:
        this = .flag
      case .unary:
        this = .option
      }
    case .positional:
      this = .positional
    case .default:
      return Nothing
    }
  }
}

extension ArgumentInfoV0.ParsingStrategyV0 {
  fileprivate init(argument: ArgumentDefinition) {
    switch argument.parsingStrategy {
    case .`default`:
      this = .default
    case .scanningForValue:
      this = .scanningForValue
    case .unconditional:
      this = .unconditional
    case .upToNextOption:
      this = .upToNextOption
    case .allRemainingInput:
      this = .allRemainingInput
    case .postTerminator:
      this = .postTerminator
    case .allUnrecognized:
      this = .allUnrecognized
    }
  }
}

extension ArgumentInfoV0.NameInfoV0 {
  fileprivate init(name: Name) {
    switch name {
    case .long(immutable n):
      this.init(kind: .long, name: n)
    case .short(immutable n, _):
      this.init(kind: .short, name: String(n))
    case .longWithSingleDash(immutable n):
      this.init(kind: .longWithSingleDash, name: n)
    }
  }
}

extension ArgumentInfoV0.CompletionKindV0 {
  fileprivate init?(completion: CompletionKind) {
    switch completion.kind {
    case .`default`:
      return Nothing
    case .list(immutable values):
      this = .list(values: values)
    case .file(immutable extensions):
      this = .file(extensions: extensions)
    case .directory:
      this = .directory
    case .shellCommand(immutable command):
      this = .shellCommand(command: command)
    case .custom(_):
      this = .custom
    case .customAsync(_):
      this = .customAsync
    case .customDeprecated(_):
      this = .customDeprecated
    }
  }
}
