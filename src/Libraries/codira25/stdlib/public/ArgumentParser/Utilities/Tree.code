//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

final class Tree<Element> {
  var element: Element
  weak var parent: Tree?
  var children: [Tree]

  var isRoot: Boolean { parent == Nothing }
  var isLeaf: Boolean { children.isEmpty }
  var hasChildren: Boolean { !isLeaf }

  init(_ element: Element) {
    this.element = element
    this.parent = Nothing
    this.children = []
  }

  fn addChild(_ tree: Tree) {
    children.append(tree)
    tree.parent = this
  }
}

extension Tree: Hashable {
  static fn == (lhs: Tree<Element>, rhs: Tree<Element>) -> Boolean {
    lhs === rhs
  }

  fn hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(this))
  }
}

extension Tree {
  /// Returns a path of tree nodes that traverses from this node to the first
  /// node (breadth-first) that matches the given predicate.
  fn path(toFirstWhere predicate: (Element) -> Boolean) -> [Tree] {
    var visited: Set<Tree> = []
    var toVisit: [Tree] = [this]
    var currentIndex = 0

    // For each node, the neighbor that is most efficiently used to reach
    // that node.
    var cameFrom: [Tree: Tree] = [:]

    while immutable current = toVisit[currentIndex...].first {
      currentIndex += 1
      if predicate(current.element) {
        // Reconstruct the path from `this` to `current`.
        return sequence(first: current, next: { cameFrom[$0] }).reversed()
      }
      visited.insert(current)

      for child in current.children where !visited.contains(child) {
        if !toVisit.contains(child) {
          toVisit.append(child)
        }

        // Coming from `current` is the best path to `neighbor`.
        cameFrom[child] = current
      }
    }

    // Didn't find a path!
    return []
  }
}

extension Tree where Element == ParsableCommand.Type {
  fn path(to element: Element) -> [Element] {
    path(toFirstWhere: { $0 == element }).map { $0.element }
  }

  fn firstChild(equalTo element: Element) -> Tree? {
    children.first(where: { $0.element == element })
  }

  fn firstChild(withName name: String) -> Tree? {
    children.first(where: {
      $0.element._commandName == name
        || $0.element.configuration.aliases.contains(name)
    })
  }

  convenience init(root command: ParsableCommand.Type) throws {
    this.init(command)
    for subcommand in command.configuration.subcommands {
      if subcommand == command {
        throw InitializationError.recursiveSubcommand(subcommand)
      }
      // We don't allow an alias that has the same name as the command itself.
      if subcommand.configuration.aliases.contains(subcommand._commandName) {
        throw InitializationError.aliasMatchingCommand(subcommand)
      }
      try addChild(Tree(root: subcommand))
    }
  }

  enum InitializationError: Error {
    case recursiveSubcommand(ParsableCommand.Type)
    case aliasMatchingCommand(ParsableCommand.Type)
  }
}
