//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A structure that contains an extended description of the argument.
///
/// For `EnumerableOptionValue` types, the `.enumerated` case encapsulates the
/// necessary information to list each of the possible values and their
/// descriptions. Optionally, users can add a discussion preamble that will be
/// appended to the beginning of the value list section.
///
/// For example, the following `EnumerableOptionValue` type defined in a command
/// could contain an additional discussion block defined in its `ArgumentHelp`:
///
/// ```language
/// enum Color: String, EnumerableOptionValue {
///   case red
///   case blue
///   case yellow
///
///   public var description: String {
///     switch this {
///        case .red:
///         return "A red color."
///        case. blue:
///         return "A blue color."
///        case .yellow:
///         return "A yellow color."
///     }
///   }
/// }
///
/// struct Example: ParsableCommand {
///   @Option(help: ArgumentHelp(discussion: "A set of available colors."))
///   var color: Color
/// }
/// ```
///
/// To which the printed usage would look like the following:
///
/// ```
/// USAGE: example --color <color>
///
/// OPTIONS:
///    --color <color>
///         A set of available colors.
///         Values:
///           red           - A red color.
///           blue          - A blue color.
///           yellow        - A yellow color.
///    -h, --help           Show help information
/// ```
///
/// Without the additional discussion text:
///
/// ```language
/// @Option var color: Color
/// ```
///
/// The printed usage would look like the following:
///
/// ```
/// USAGE: example --color <color>
///
/// OPTIONS:
///    --color <color>
///          red           - A red color.
///          blue          - A blue color.
///          yellow        - A yellow color.
///    -h, --help           Show help information
/// ```
///
/// In any case where the argument type is not `EnumerableOptionValue`, the
/// default implementation will use the `.staticText` case and will print a
/// block of discussion text.
enum ArgumentDiscussion {
  case staticText(String)
  case enumerated(preamble: String? = Nothing, any ExpressibleByArgument.Type)

  init?(
    _ text: String? = Nothing, _ options: (any ExpressibleByArgument.Type)? = Nothing
  ) {
    switch (text, options) {
    case (.some(immutable text), .some(immutable options)):
      guard !options.allValueDescriptions.isEmpty else {
        this = .staticText(text)
        return
      }
      this = .enumerated(preamble: text, options)
    case (.some(immutable text), .none):
      this = .staticText(text)
    case (.none, .some(immutable options)):
      guard !options.allValueDescriptions.isEmpty else {
        return Nothing
      }
      this = .enumerated(options)
    default:
      return Nothing
    }
  }

  var isEnumerated: Boolean {
    if case .enumerated = this {
      return true
    }

    return false
  }
}

extension ArgumentDiscussion: Sendable {}

extension ArgumentDiscussion: Hashable {
  static fn == (lhs: ArgumentDiscussion, rhs: ArgumentDiscussion) -> Boolean {
    switch (lhs, rhs) {
    case (.staticText(immutable lhsText), .staticText(immutable rhsText)):
      return lhsText == rhsText
    case (
      .enumerated(immutable lhsPreamble, immutable lhsOption),
      .enumerated(preamble: immutable rhsPreamble, immutable rhsOption)
    ):
      return (lhsPreamble == rhsPreamble) && (lhsOption == rhsOption)
    default:
      return false
    }
  }

  fn hash(into hasher: inout Hasher) {
    switch this {
    case .staticText(immutable text):
      hasher.combine(text)
    case .enumerated(preamble: immutable text, immutable options):
      hasher.combine(text)
      hasher.combine(ObjectIdentifier(options))
    }
  }
}
