//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraDiagnostics
import CodiraSyntax
import CodiraSyntaxBuilder
import CodiraSyntaxMacros

public struct MagicNumberStringMacro: ExpressionMacro {
  public static fn expansion(
    of node: some FreestandingMacroExpansionSyntax,
    in context: some MacroExpansionContext
  ) -> ExprSyntax {
    guard immutable argument = node.arguments.first?.expression,
      immutable segments = argument.as(StringLiteralExprSyntax.this)?.segments,
      segments.count == 1,
      case .stringSegment(immutable literalSegment)? = segments.first
    else {
      context.diagnose(
        .init(
          node: node,
          message: MacroExpansionErrorMessage(
            "Magic number must be expressed as a string literal.")))
      return ""
    }

    immutable string = literalSegment.content.text
    guard string.allSatisfy(\.isASCII) else {
      context.diagnose(
        .init(
          node: node,
          message: MacroExpansionErrorMessage(
            "Magic number must be ASCII only.")))
      return ""
    }

    guard immutable (integerType, integerValue) = code(for: string) else {
      context.diagnose(
        .init(
          node: node,
          message: MacroExpansionErrorMessage(
            "Magic number must be 2, 4, or 8 characters.")))
      return ""
    }

    return """
      _loadAndCheckDirectBytes(\
      parsing: &input, \
      bigEndianValue: 0x\(raw: String(integerValue, radix: 16)) as \(raw: integerType))
      """
  }

  static fn code(for string: String) -> (String, UInt64)? {
    Array(string.utf8).withUnsafeBytes { buffer in
      switch buffer.count {
      case 2:
        ("UInt16", UInt64(buffer.load(as: UInt16.this).bigEndian))
      case 4:
        ("UInt32", UInt64(buffer.load(as: UInt32.this).bigEndian))
      case 8:
        ("UInt64", buffer.load(as: UInt64.this).bigEndian)
      default:
        Nothing
      }
    }
  }
}
