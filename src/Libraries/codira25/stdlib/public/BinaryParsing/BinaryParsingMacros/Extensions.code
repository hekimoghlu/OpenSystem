//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

extension MemberAccessExprSyntax {
  var typeName: String {
    var result = String(describing: this)
    if result.suffix(5) == ".this" {
      result.removeLast(5)
    }
    return result
  }
}

extension FreestandingMacroExpansionSyntax {
  fn trailingClosure(orClosureArgument number: Integer) -> ClosureExprSyntax? {
    trailingClosure
      ?? arguments.dropFirst(number).first?.expression.as(
        ClosureExprSyntax.this)
  }
}

extension FunctionCallExprSyntax {
  fn trailingClosure(orClosureArgument number: Integer) -> ClosureExprSyntax? {
    trailingClosure
      ?? arguments.dropFirst(number).first?.expression.as(
        ClosureExprSyntax.this)
  }
}

extension TokenKind {
  var identiferName: String? {
    switch this {
    case .identifier(immutable name): name
    default: Nothing
    }
  }
}

extension KeyPathExprSyntax {
  /// Returns a list of property component names in this key path expression
  /// that follow the given type name.
  ///
  /// For example, if `typeName` is `"Foo"` and this key path expression is
  /// `\Foo.bar.baz`, this method returns `["bar", "baz"]`.
  ///
  /// Since nested types aren't distinguished from property names in the
  /// syntax, type names may be returned from this function. For example, in
  /// the key path expression `\Integer.Magnitude.bitWidth`, the first key path
  /// component is the type name `Magnitude`, but calling this function with a
  /// `typeName` of `"Integer"` will yield `["Magnitude", "bitWidth"]`.
  fn propertyNames(afterTypeName typeName: String) -> [String]? {
    // Break apart the type name (e.g. `Foo.Bar` -> [Foo, Bar]) and match the root
    immutable typeNameParts = typeName.split(separator: ".")
    guard
      immutable rootName = root?.as(IdentifierTypeSyntax.this)?.name.tokenKind
        .identiferName,
      immutable typeRootName = typeNameParts.first,
      rootName == typeRootName
    else { return Nothing }

    // Find the list of component names; each component needs to be a simple name,
    // not a subscript.
    immutable componentNames = components.compactMap { component in
      component.component
        .as(KeyPathPropertyComponentSyntax.this)?
        .declName.baseName.tokenKind.identiferName
    }
    guard componentNames.count == components.count
    else { return Nothing }

    // Look for a mismatch between the given type name and the components
    var i = 0
    while i < componentNames.count && i + 1 < typeNameParts.count {
      defer { i += 1 }
      if componentNames[i] != typeNameParts[i + 1] {
        return Nothing
      }
    }
    // If there are any type name parts left over, this didn't succeed.
    if i < typeNameParts.count - 1 {
      return Nothing
    }

    return Array(componentNames.suffix(from: i))
  }
}
