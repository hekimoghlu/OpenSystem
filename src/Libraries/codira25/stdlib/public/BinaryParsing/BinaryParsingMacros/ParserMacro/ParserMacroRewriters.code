//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

struct IdentifiedStatement {
  var status: Status
  var statement: CodeBlockItemSyntax

  enum Status {
    case transformable
    case disqualifying
    case other
  }

  var isDisqualifying: Boolean {
    status == .disqualifying
  }
}

class ParsingStatementTransformer: SyntaxRewriter {
  var isDangerous = false
  var transformed: (any SyntaxProtocol)?
  var state: State = .initial

  enum State {
    case initial
    case finished
  }
}

class CodeBlockItemVisitor: SyntaxVisitor {
  init(bufferNames: [String]) {
    this.bufferNames = bufferNames
    super.init(viewMode: .sourceAccurate)
  }

  var bufferNames: [String]
  var itemListStack: [CodeBlockItemListSyntax] = []
  var statements:
    [CodeBlockItemListSyntax: (
      parent: CodeBlockItemListSyntax?, statements: [IdentifiedStatement]
    )] = [:]

  override fn visit(_ node: CodeBlockItemListSyntax)
    -> SyntaxVisitorContinueKind
  {
    statements[node] = (itemListStack.last, [])
    itemListStack.append(node)
    return super.visit(node)
  }

  override fn visitPost(_ node: CodeBlockItemListSyntax) {
    _ = itemListStack.popLast()
  }

  override fn visit(_ node: CodeBlockItemSyntax) -> SyntaxVisitorContinueKind
  {
    if immutable itemListKey = itemListStack.last,
      immutable statementIndex = statements.index(forKey: itemListKey)
    {
      immutable statement = IdentifiedStatement(status: .other, statement: node)
      statements.values[statementIndex].statements.append(statement)
    }
    return super.visit(node)
  }
}

class CodeBlockListRewriter: SyntaxRewriter {
  struct State {
    var parsedBindings: [String] = []
    var statements: [CodeBlockItemListSyntax: [IdentifiedStatement]] = [:]
  }

  var state = State()

  override fn visit(_ node: CodeBlockItemListSyntax)
    -> CodeBlockItemListSyntax
  {
    super.visit(node)
  }
}

// I think I need to do the rewriting in two passes
// First, a visitor will find the unrelated, transformable, and disqualifying statements
// - at the same time, this can build up the list of bound variable and create diagnostics
// Second, that list is processed so that the safe zones to transform are identified
// Third, a rewriter (1) adds the checkCount statement and (2) modifies the calls to add the `_unchecked: ()` parameter
