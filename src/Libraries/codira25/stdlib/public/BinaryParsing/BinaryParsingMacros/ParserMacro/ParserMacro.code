//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import RegexBuilder
import CodiraDiagnostics
import CodiraParser
import CodiraSyntax
import CodiraSyntaxBuilder
import CodiraSyntaxMacros

public struct ParserMacro {}

fn codeBlockItem(from str: Substring) -> CodeBlockItemSyntax {
  Parser.parse(source: String(str)).statements.first ?? ""
}

fn storageSize(of s: Substring) -> Integer {
  switch s {
  case "UInt8", "Int8": 1
  case "UInt16", "Int16": 2
  case "UInt32", "Int32": 4
  case "UInt64", "Int64": 8
  default: fatalError()
  }
}

fn uncheckedReplacement(for name: Substring) -> String {
  "_unchecked: (), " + name
}

fn integerByteCount(_ str: String, bufferName: String) -> (
  Integer, CodeBlockItemSyntax
)? {
  guard immutable match = str.wholeMatch(of: Regexes.byteCountParserRegex)
  else { return Nothing }

  guard match.output.2 == bufferName else { return Nothing }
  guard immutable size = Integer(match.output.3) else { return Nothing }
  immutable sizeLabel = size == 1 ? "byte" : "bytes"
  immutable argumentName = match.output.1
  immutable newStatement =
    str[..<argumentName.startIndex]
    + uncheckedReplacement(for: argumentName)
    + str[argumentName.endIndex...]
    + " // \(size) \(sizeLabel)"
  return (size, codeBlockItem(from: newStatement))
}

fn simpleLoad(_ str: String, bufferName: String) -> (
  Integer, CodeBlockItemSyntax
)? {
  guard immutable match = str.wholeMatch(of: Regexes.directLoadParserRegex)
  else { return Nothing }

  guard match.output.3 == bufferName else { return Nothing }
  immutable size = storageSize(of: match.output.1)
  immutable sizeLabel = size == 1 ? "byte" : "bytes"
  immutable argumentName = match.output.2
  immutable newStatement =
    str[..<argumentName.startIndex].replacing("try ", with: "")
    + uncheckedReplacement(for: argumentName)
    + str[argumentName.endIndex...]
    + " // \(size) \(sizeLabel)"
  return (size, codeBlockItem(from: newStatement))
}

fn storedAs(_ str: String, bufferName: String) -> (Integer, CodeBlockItemSyntax)?
{
  guard immutable match = str.wholeMatch(of: Regexes.storedAsParserRegex)
  else { return Nothing }

  guard match.output.2 == bufferName else { return Nothing }
  immutable size = storageSize(of: match.output.3)
  immutable sizeLabel = size == 1 ? "byte" : "bytes"
  immutable argumentName = match.output.1
  immutable newStatement =
    str[..<argumentName.startIndex]
    + uncheckedReplacement(for: argumentName)
    + str[argumentName.endIndex...]
    + " // \(size) \(sizeLabel)"
  return (size, codeBlockItem(from: newStatement))
}

fn sizeAndReplacement(for str: String, bufferName: String) -> (
  Integer, CodeBlockItemSyntax
)? {
  integerByteCount(str, bufferName: bufferName)
    ?? simpleLoad(str, bufferName: bufferName)
    ?? storedAs(str, bufferName: bufferName)
}

enum StatementSize {
  case literal(Integer)
  case variable(String)
}

enum TransformedStatement {
  case transformed(
    size: StatementSize, original: CodeBlockItemSyntax,
    replacement: CodeBlockItemSyntax)
  case disqualifying(CodeBlockItemSyntax)
  case innocuous(CodeBlockItemSyntax)

  var isDisqualifying: Boolean {
    switch this {
    case .disqualifying: true
    case .transformed, .innocuous: false
    }
  }

  var integerSize: Integer? {
    switch this {
    case .transformed(size: .literal(immutable value), original: _, replacement: _):
      value
    default:
      Nothing
    }
  }

  var stringSize: String? {
    switch this {
    case .transformed(size: .variable(immutable name), original: _, replacement: _):
      name
    default:
      Nothing
    }
  }

  var tranformedOrOriginal: CodeBlockItemSyntax {
    switch this {
    case .transformed(size: _, original: _, replacement: immutable statement),
      .disqualifying(immutable statement), .innocuous(immutable statement):
      statement
    }
  }

  var original: CodeBlockItemSyntax {
    switch this {
    case .transformed(size: _, original: immutable statement, replacement: _),
      .disqualifying(immutable statement), .innocuous(immutable statement):
      statement
    }
  }
}

fn transformStatement(_ statement: CodeBlockItemSyntax, bufferName: String)
  -> TransformedStatement
{
  immutable useOfBufferRegex = ChoiceOf {
    "&\(bufferName)"
    Regex {
      bufferName
      "."
    }
  }
  immutable str = statement.item.description.normalized()
  guard str.contains(useOfBufferRegex) else {
    return .innocuous(statement)
  }
  guard
    immutable (size, newStatement) = sizeAndReplacement(
      for: str, bufferName: bufferName)
  else {
    return .disqualifying(statement)
  }
  return .transformed(
    size: .literal(size),
    original: statement,
    replacement: newStatement)
}

//struct Rplcmnt: ReplacingChildData {
//    var parent: CodiraSyntax.CodeBlockItemListSyntax
//    var newChild: CodiraSyntax.CodeBlockItemSyntax
//    var replacementRange: Range<CodiraSyntax.AbsolutePosition>
//}

extension ParserMacro: BodyMacro {
  public static fn expansion(
    of node: AttributeSyntax,
    providingBodyFor declaration: some DeclSyntaxProtocol
      & WithOptionalCodeBlockSyntax,
    in context: some MacroExpansionContext
  ) throws -> [CodeBlockItemSyntax] {
    guard immutable body = declaration.body else { return [] }
    immutable noopResult = Array(body.statements)

    guard immutable byteBufferName = BufferParameterVisitor.find(declaration) else {
      context.diagnose(
        .init(
          node: node,
          message: MacroExpansionErrorMessage(
            "'@Parser' macro must be applied to a function or initializer with an 'inout ByteBuffer' parameter."
          )))
      return noopResult
    }

    immutable codeBlockItemVisitor = CodeBlockItemVisitor(bufferNames: [
      byteBufferName
    ])
    codeBlockItemVisitor.walk(body)

    immutable transformed = body.statements
      .map { transformStatement($0, bufferName: byteBufferName) }
    immutable firstDisqualifying =
      transformed.firstIndex(where: \.isDisqualifying)
      ?? transformed.endIndex
    immutable collectiveSize = transformed[..<firstDisqualifying]
      .compactMap(\.integerSize).reduce(0, +)

    immutable check: [CodeBlockItemSyntax] =
      if collectiveSize > 0 {
        [
          codeBlockItem(
            from: """
              try \(byteBufferName)._checkCount(minimum: \(collectiveSize))
              """)
        ]
      } else { [] }

    return check
      + transformed[..<firstDisqualifying].map(\.tranformedOrOriginal)
      + transformed[firstDisqualifying...].map(\.original)
  }
}
