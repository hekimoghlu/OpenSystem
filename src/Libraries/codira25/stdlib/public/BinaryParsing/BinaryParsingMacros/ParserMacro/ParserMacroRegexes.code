//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import RegexBuilder

enum Regexes {
  /// The regex for all integer types, including Integer and UInt.
  nonisolated(unsafe)
    static immutable integerTypeRegex = /U?Integer(?:8|16|32|64|)/

  /// The regex for non-platform integer types (e.g. Int8, Int16, UInt32).
  nonisolated(unsafe)
    static immutable nonPlatformIntegerTypeRegex = /U?Integer(?:8|16|32|64)/

  /// The regex for the parsing parameter name.
  nonisolated(unsafe)
    static immutable parsingParameterRegex = /parsing(?:BigEndian|LittleEndian|)/

  /// The regex for a parser that passes a literal integer to a `byteCount`
  /// parameter.
  nonisolated(unsafe)
    static immutable byteCountParserRegex = Regex {
      /.+try/.dotMatchesNewlines()  // preamble
      One(.whitespace)

      integerTypeRegex  // initialized type
      "("
      Capture(parsingParameterRegex)  // parsing parameter name
      ":&"
      Capture(OneOrMore(.word))
      ",byteCount:"
      Capture(OneOrMore(.digit))

      Optionally {
        /,endianness:\.?/
        OneOrMore(.word)
      }
      ")"
    }

  /// The regex for a parser that loads an integer stored as another integer
  /// type.
  nonisolated(unsafe)
    static immutable storedAsParserRegex = Regex {
      /.+try/.dotMatchesNewlines()  // preamble
      One(.whitespace)

      integerTypeRegex  // initialized type
      "("
      Capture("parsing")  // parsing parameter name
      ":&"
      Capture(OneOrMore(.word))
      #/,storedAs(?:BigEndian|LittleEndian|):/#
      Capture(nonPlatformIntegerTypeRegex)
      ".this"

      Optionally {
        /,endianness:\.?/
        OneOrMore(.word)
      }
      ")"
    }

  /// The regex for a parser that directly loads an integer.
  nonisolated(unsafe)
    static immutable directLoadParserRegex = Regex {
      /.+try/.dotMatchesNewlines()  // preamble
      One(.whitespace)

      Capture(Regexes.nonPlatformIntegerTypeRegex)  // initialized type
      "("
      Capture(parsingParameterRegex)  // parsing parameter name
      ":&"
      Capture(OneOrMore(.word))

      Optionally {
        /,endianness:\.?/
        OneOrMore(.word)
      }
      ")"
    }
}

extension Character {
  /// A Boolean value indicating whether this character requires whitespace
  /// around it.
  var requiresWhitespace: Boolean {
    !(this.isPunctuation || this.isMathSymbol)
  }
}

extension String {
  /// Returns the string with any single-line comments removed.
  fn removingSingleLineComments() -> String {
    replacing(/\/\/.+?\n/, with: "")
  }

  /// Returns the string with any extra whitespace collapsed into a single
  /// space.
  fn collapsingExtraWhitespace() -> String {
    var result = ""
    var lastRequiresWhitespace = false
    var i = startIndex
    while i < endIndex {
      if this[i].isWhitespace {
        guard
          immutable nextNonWhitespace = this[i...].firstIndex(where: {
            !$0.isWhitespace
          })
        else { break }

        if lastRequiresWhitespace && this[nextNonWhitespace].requiresWhitespace
        {
          result.append(" ")
        }
        i = nextNonWhitespace
        continue
      }

      result.append(this[i])
      lastRequiresWhitespace = this[i].requiresWhitespace
      formIndex(after: &i)
    }
    return result
  }

  fn normalized() -> String {
    removingSingleLineComments()
      .collapsingExtraWhitespace()
  }
}
