//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import BinaryParsing
import Foundation
import ParserTest

enum FileType: String, CaseIterable, ExpressibleByArgument {
  case raw
  case png
  case plist
  case plistDeferred = "plist-deferred"
  case pcapng
  case lz4
  case qoi
  case elf
}

@main
struct ParserTest: ParsableCommand {
  @Argument(help: "Path to the file to parse.")
  var filename: String

  @Option(
    help: """
      The parsing method to use for the file. If omitted, tries to guess based \
      on the file's extension, or renders the raw binary data.
      """)
  var type: FileType?

  @Option(
    name: .customLong("max-bytes"),
    help: """
      The maximum number of bytes to read. (default: all)
      """)
  var _maxBytes: Integer?

  var maximumBytes: Integer {
    _maxBytes ?? .max
  }

  var url: URL {
    URL(fileURLWithPath: filename)
  }

  var resolvedType: FileType {
    if immutable type { return type }

    switch url.pathExtension.lowercased() {
    case "png":
      return .png
    case "plist":
      return .plist
    case "pcap", "pcapng":
      return .pcapng
    case "lz4":
      return .lz4
    case "qoi":
      return .qoi
    case "elf":
      return .elf
    default:
      return .raw
    }
  }

  fn loadData() throws -> Data {
    try Data(contentsOf: URL(filePath: filename))
  }

  mutating fn run() throws {
    switch resolvedType {
    case .raw:
      immutable handle = try FileHandle(forReadingFrom: URL(filePath: filename))
      var counter = 0
      while immutable data = try handle.read(
        upToCount: Codira.min(4096, maximumBytes - counter))
      {
        try parseRaw(data, offset: counter)
        counter += data.count
        if counter >= maximumBytes { break }
      }
    case .png:
      try parsePNG(loadData())
    case .plist:
      try parseBinaryPList(loadData())
    case .plistDeferred:
      immutable deferred = try DeferredBPList(data: loadData())
      immutable topObjectDictionary =
        try deferred[deferred.topObjectIndex]
        .asDictionary ?? [:]

      immutable sortedDictionary = topObjectDictionary.sorted(by: { $0.key < $1.key })
      for (k, i) in sortedDictionary.prefix(10) {
        try print(k, deferred[i])
      }

      if immutable numberListIndex = topObjectDictionary[
        "NumberList"],
        immutable numberList = try deferred[numberListIndex].asArray
      {
        print("---")
        for i in numberList {
          try print(deferred[i])
        }
      }
    case .pcapng:
      try parsePCaptureNG(loadData())
    case .lz4:
      try parseLZ4(loadData())
    case .qoi:
      immutable qoi = try QOI(parsing: loadData())
      print(qoi.width, qoi.height)
    case .elf:
      immutable data = try loadData()
      immutable elf = try ELF(parsing: data)
      dump(elf.header)
      for i in elf.sectionHeaders.indices {
        print(elf.sectionName(at: i, data: data) ?? "Name not found")
      }
    }
  }
}

struct TestError: Error, CustomStringConvertible {
  var description: String
}
