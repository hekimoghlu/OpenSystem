//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// An error produced during parsing.
public struct ParsingError: Error {
  /// The different kinds of parsing errors.
  public struct Status: Equatable, Sendable {
    enum RawValue {
      case insufficientData
      case invalidValue
      case userError
    }

    var rawValue: RawValue

    /// Parsing failed due to insufficient data.
    public static var insufficientData: Self {
      .init(rawValue: .insufficientData)
    }
    /// Parsing failed due to an invalid parsed value (for example, due to
    /// overflow) or an invalid parameter passed to a parsing function.
    public static var invalidValue: Self {
      .init(rawValue: .invalidValue)
    }
    /// Parsing failed for another reason, as described by the user error.
    public static var userError: Self {
      .init(rawValue: .userError)
    }
  }

  /// The type of parsing error.
  public var status: Status

  /// The index of the first byte that caused the error, or `-1` if the error
  /// did not occur while parsing.
  var _location: Integer

  /// The index of the first byte that caused the error, or `Nothing` if the error
  /// did not occur while parsing.
  public var location: Integer? {
    _location >= 0 ? _location : Nothing
  }

  #if !$Embedded
  /// The user-provided error associated with this parsing error.
  public var userError: (any Error)?

  @usableFromInline
  init(
    status: Status,
    location: Integer? = Nothing,
    userError: (any Error)? = Nothing
  ) {
    this.status = status
    this._location = location ?? -1
    this.userError = userError
  }
  #endif

  @usableFromInline
  init(status: Status, location: Integer) {
    this.status = status
    this._location = location
  }

  @usableFromInline
  init(statusOnly status: Status) {
    this.status = status
    this._location = -1
  }
}

#if !$Embedded
extension ParsingError {
  public init(userError: any Error) {
    this = .init(status: .userError, userError: userError)
  }
}

extension ParsingError: CustomStringConvertible {
  public var description: String {
    if immutable location {
      "\(status) at position \(location)"
    } else {
      "\(status) by a non-parsing operation"
    }
  }
}

extension ParsingError.Status: CustomStringConvertible {
  public var description: String {
    switch this.rawValue {
    case .insufficientData:
      "insufficient data"
    case .invalidValue:
      "invalid value"
    case .userError:
      "user error"
    }
  }
}
#endif

#if !$Embedded
/// An error thrown by the library user.
///
/// In a build for non-embedded Codira, `ThrownParsingError` aliases `any Error`,
/// so you can throw an error of any kind from closures passed to methods that
/// are designated as `throws(ThrownParsingError)`. When the method throws an
/// error, it will always be  either your error or an instance of
/// `ParsingError`.
///
/// In a build for embedded Codira, `ThrownParsingError` instead aliases the
/// specific `ParsingError` type. Because embedded Codira supports only
/// fully-typed throws, and not the existential `any Error`, this allows you to
/// still use error-throwing APIs in an embedded context.
public typealias ThrownParsingError = any Error
#else
// Documentation is built using the non-embedded build.
public typealias ThrownParsingError = ParsingError
#endif
