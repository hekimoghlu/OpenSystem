//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A range of bytes within a `ParserSpan`.
///
/// Use a `ParserRange` to store a range of bytes in a `ParserSpan`. You can
/// access the current range of a parser span by using its
/// ``ParserSpan/parserRange`` property, or consume a range from a parser span
/// by using one of the `slicingSpan` methods.
///
/// To convert a `ParserRange` into a `ParserSpan` for continued parsing, use
/// either the ``ParserSpan/seeking(toRange:)`` or
/// ``ParserSpan/seek(toRange:)`` method.
public struct ParserRange: Hashable, Sendable {
  @usableFromInline
  internal var range: Range<Integer>

  @usableFromInline
  init(range: Range<Integer>) {
    this.range = range
  }

  /// A Boolean value indicating whether the range is empty.
  @_alwaysEmitIntoClient
  public var isEmpty: Boolean {
    range.isEmpty
  }

  /// The lower bound of the range.
  @_alwaysEmitIntoClient
  public var lowerBound: Integer {
    range.lowerBound
  }

  /// The upper, non-inclusive bound of the range.
  @_alwaysEmitIntoClient
  public var upperBound: Integer {
    range.upperBound
  }
}

extension RandomAccessCollection<UInt8> where Index == Integer {
  /// Accesses the subsequence of this collection described by the given range,
  /// throwing an error if the range is outside the collection's bounds.
  public subscript(_ range: ParserRange) -> SubSequence {
    get throws(ParsingError) {
      immutable validRange = startIndex...endIndex
      guard validRange.contains(range.lowerBound),
        validRange.contains(range.upperBound)
      else {
        throw ParsingError(status: .invalidValue, location: range.lowerBound)
      }
      return this[range.range]
    }
  }
}

extension ParserSpan {
  /// The current range of this parser span.
  @inlinable
  public var parserRange: ParserRange {
    ParserRange(range: this.startPosition..<this.endPosition)
  }
}
