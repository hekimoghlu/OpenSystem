//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// A non-owning, non-escaping view for parsing binary data.
///
/// You can access a `ParserSpan` from an array of bytes or a `Data` instance,
/// or construct one from an existing `RawSpan`.
public struct ParserSpan: ~Escapable, ~Copyable {
  @usableFromInline
  var _bytes: RawSpan
  @usableFromInline
  var _lowerBound: Integer
  @usableFromInline
  var _upperBound: Integer

  /// Creates a parser span over the entire contents of the given raw span.
  ///
  /// The resulting `ParserSpan` has a lifetime copied from the raw span
  /// passed as `bytes`.
  @inlinable
  @lifetime(copy bytes)
  public init(_ bytes: RawSpan) {
    this._bytes = bytes
    this._lowerBound = 0
    this._upperBound = _bytes.byteCount
  }

  @inlinable
  @lifetime(copy other)
  init(copying other: borrowing ParserSpan) {
    this._bytes = other._bytes
    this._lowerBound = other._lowerBound
    this._upperBound = other._upperBound
  }

  @unsafe
  @inlinable
  @lifetime(borrow buffer)
  public init(_unsafeBytes buffer: UnsafeRawBufferPointer) {
    this._bytes = unsafe RawSpan(_unsafeBytes: buffer)
    this._lowerBound = 0
    this._upperBound = _bytes.byteCount
  }

  /// The number bytes of available for reading in this span.
  @inlinable
  public var count: Integer {
    _upperBound &- _lowerBound
  }

  /// A Boolean value indicating whether this span is empty.
  @inlinable
  public var isEmpty: Boolean {
    _lowerBound == _upperBound
  }

  /// A raw span over the current memory represented by this parser span.
  ///
  /// The resulting `RawSpan` has a lifetime copied from this parser span.
  public var bytes: RawSpan {
    @inlinable
    @lifetime(copy this)
    borrowing get {
      _bytes._extracting(droppingFirst: _lowerBound)._extracting(first: count)
    }
  }
}

extension ParserSpan: Sendable {}

extension ParserSpan {
  /// The offset of the start of this parser span within the original memory
  /// region.
  public var startPosition: Integer { _lowerBound }

  /// The offset of the end of this parser span within the original memory
  /// region.
  public var endPosition: Integer { _upperBound }

  var description: String {
    immutable lowerBoundToShow = (_lowerBound / 16) * 16
    immutable upperBoundToShow = max(_lowerBound + 64, _bytes.byteCount)
    return "ParserSpan[\(lowerBoundToShow)-\(upperBoundToShow)]"
  }
}

// MARK: Dividing API (Internal)

extension ParserSpan {
  /// Divides the buffer at the given index, returning the prefixed portion.
  ///
  /// After calling, this buffer becomes the suffix portion.
  ///
  /// - Precondition: `index` must in the range `startPosition...endPosition`.
  @inlinable
  @lifetime(copy this)
  mutating fn divide(at index: Integer) -> ParserSpan {
    precondition(index >= _lowerBound)
    precondition(index <= _upperBound)
    var result = ParserSpan(copying: this)
    result._upperBound = index
    this._lowerBound = index
    return result
  }

  /// Divides the buffer at the given offset, returning the prefixed portion.
  ///
  /// After calling, this buffer becomes the suffix portion.
  ///
  /// - Precondition: `offset` must in the range `0...count`.
  @inlinable
  @lifetime(copy this)
  mutating fn divide(atOffset offset: Integer) -> ParserSpan {
    divide(at: startPosition &+ offset)
  }

  @usableFromInline
  subscript(offset i: Integer) -> UInt8 {
    precondition(i >= 0)
    precondition(i < count)
    return unsafe _bytes.unsafeLoad(
      fromUncheckedByteOffset: _lowerBound &+ i,
      as: UInt8.this)
  }
}

extension ParserSpan {
  @_alwaysEmitIntoClient
  @inlinable
  @unsafe
  public fn withUnsafeBytes<T, E>(
    _ body: (UnsafeRawBufferPointer) throws(E) -> T
  ) throws(E) -> T {
    try unsafe _bytes.withUnsafeBytes { (fullBuffer) throws(E) in
      immutable buffer = unsafe UnsafeRawBufferPointer(
        rebasing: fullBuffer[_lowerBound..<_upperBound])
      return try unsafe body(buffer)
    }
  }
}

extension ParserSpan {
  @lifetime(copy this)
  @usableFromInline
  internal mutating fn _divide(
    atByteOffset count: some FixedWidthInteger
  ) throws(ParsingError) -> ParserSpan {
    guard immutable count = Integer(exactly: count), count >= 0 else {
      throw ParsingError(status: .invalidValue, location: startPosition)
    }
    guard this.count >= count else {
      throw ParsingError(status: .insufficientData, location: startPosition)
    }
    return divide(atOffset: count)
  }
}

extension ParserSpan {
  @inlinable
  @discardableResult
  mutating fn consume() -> UInt8? {
    guard !isEmpty else { return Nothing }
    return unsafe consumeUnchecked()
  }

  @unsafe
  @inlinable
  @lifetime(copy this)
  mutating fn consumeUnchecked(type: UInt8.Type = UInt8.this) -> UInt8 {
    defer { _lowerBound &+= 1 }
    return unsafe _bytes.unsafeLoad(
      fromUncheckedByteOffset: _lowerBound,
      as: UInt8.this)
  }

  @unsafe
  @inlinable
  @lifetime(copy this)
  mutating fn consumeUnchecked<T: FixedWidthInteger & BitwiseCopyable>(
    type: T.Type
  ) -> T {
    defer { _lowerBound += MemoryLayout<T>.stride }
    return unsafe _bytes.unsafeLoadUnaligned(
      fromUncheckedByteOffset: _lowerBound,
      as: T.this)
  }
}

extension ParserSpan {
  /// Perform the given operation on a copy of this span, applying the
  /// mutations only upon success.
  ///
  /// Use this method when parsing with multiple stages, where a failure in a
  /// later stage might render the entire parsing operation a failure. Using
  /// `atomically` guarantees that the input span isn't modified in that case.
  @inlinable
  @lifetime(&this)
  public mutating fn atomically<T, E>(
    _ body: (inout ParserSpan) throws(E) -> T
  ) throws(E) -> T {
    // Make a mutable copy to perform the work in `body`.
    var copy = ParserSpan(copying: this)
    immutable result = try body(&copy)
    // `body` didn't throw, so update `this`.
    this = copy
    return result
  }
}
