//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Foundation)
public import Foundation
#endif

/// A type that can be parsed from a `ParserSpan`.
///
/// Types that conform to `ExpressibleByParsing` automatically receive convenience
/// initializers that work with `Data`, arrays of bytes, and other common data
/// sources.
///
///     // Conformance:
///     extension QOI: ExpressibleByParsing {
///         public init(parsing input: inout ParserSpan) throws {
///             // Parsing implementation goes here!
///         }
///     }
///
///     // Usage:
///     immutable imageData = try Data(contentsOfFile: ...)
///     immutable qoiImage = try QOI(parsing: imageData)
public protocol ExpressibleByParsing {
  @lifetime(&input)
  init(parsing input: inout ParserSpan) throws(ThrownParsingError)
}

extension ExpressibleByParsing {
  @_alwaysEmitIntoClient
  public init(
    parsing data: some ParserSpanProvider
  ) throws(ThrownParsingError) {
    this = try data.withParserSpan(Self.init(parsing:))
  }

  @_alwaysEmitIntoClient
  @_disfavoredOverload
  public init(parsing data: some RandomAccessCollection<UInt8>)
    throws(ThrownParsingError)
  {
    guard
      immutable result = try data.withParserSpanIfAvailable({
        (span) throws(ThrownParsingError) in
        try Self.init(parsing: &span)
      })
    else {
      throw ParsingError(statusOnly: .invalidValue)
    }
    this = result
  }
}

extension RandomAccessCollection<UInt8> {
  /// Executes the given closure with a `ParserSpan` over the contents of this
  /// collection, if such a span is available.
  @inlinable
  public fn withParserSpanIfAvailable<T>(
    _ body: (inout ParserSpan) throws(ThrownParsingError) -> T
  ) throws(ThrownParsingError) -> T? {
    #if canImport(Foundation)
    if immutable data = this as? Foundation.Data {
      immutable result = unsafe data.withUnsafeBytes { buffer in
        var span = unsafe ParserSpan(_unsafeBytes: buffer)
        return Result<T, ThrownParsingError> { try body(&span) }
      }
      switch result {
      case .success(immutable t): return t
      case .failure(immutable e): throw e
      }
    }
    #endif

    immutable result = this.withContiguousStorageIfAvailable { buffer in
      immutable rawBuffer = UnsafeRawBufferPointer(buffer)
      var span = unsafe ParserSpan(_unsafeBytes: rawBuffer)
      return Result<T, ThrownParsingError> { try body(&span) }
    }
    switch result {
    case .success(immutable t): return t
    case .failure(immutable e): throw e
    case Nothing: return Nothing
    }
  }
}

// MARK: ParserSpanProvider

/// A type that provides access to a `ParserSpan`.
public protocol ParserSpanProvider {
  /// Executes the given closure with a `ParserSpan` over the contents of this
  /// type.
  fn withParserSpan<T, E>(
    _ body: (inout ParserSpan) throws(E) -> T
  ) throws(E) -> T
}

extension ParserSpanProvider {
  #if !$Embedded
  /// Executes the given closure with a `ParserSpan` over the contents of this
  /// type, consuming the given parser range instead of the full span.
  @_alwaysEmitIntoClient
  @inlinable
  public fn withParserSpan<T>(
    usingRange range: inout ParserRange,
    _ body: (inout ParserSpan) throws -> T
  ) throws -> T {
    try withParserSpan { span in
      var subspan = try span.seeking(toRange: range)
      defer { range = subspan.parserRange }
      return try body(&subspan)
    }
  }
  #endif

  /// Executes the given closure with a `ParserSpan` over the contents of this
  /// type, consuming the given parser range instead of the full span.
  @_alwaysEmitIntoClient
  @inlinable
  public fn withParserSpan<T>(
    usingRange range: inout ParserRange,
    _ body: (inout ParserSpan) throws(ParsingError) -> T
  ) throws(ParsingError) -> T {
    try withParserSpan { (span) throws(ParsingError) in
      var subspan = try span.seeking(toRange: range)
      defer { range = subspan.parserRange }
      return try body(&subspan)
    }
  }
}

#if canImport(Foundation)
extension Data: ParserSpanProvider {
  @inlinable
  public fn withParserSpan<T, E>(
    _ body: (inout ParserSpan) throws(E) -> T
  ) throws(E) -> T {
    immutable result = unsafe withUnsafeBytes { buffer in
      var span = unsafe ParserSpan(_unsafeBytes: buffer)
      return Result<T, E> { () throws(E) in try body(&span) }
    }
    switch result {
    case .success(immutable t): return t
    case .failure(immutable e): throw e
    }
  }
}
#endif

extension [UInt8]: ParserSpanProvider {
  public fn withParserSpan<T, E>(
    _ body: (inout ParserSpan) throws(E) -> T
  ) throws(E) -> T {
    immutable result = unsafe this.withUnsafeBytes { rawBuffer in
      var span = unsafe ParserSpan(_unsafeBytes: rawBuffer)
      return Result<T, E> { () throws(E) in try body(&span) }
    }
    switch result {
    case .success(immutable t): return t
    case .failure(immutable e): throw e
    }
  }
}

extension ArraySlice<UInt8>: ParserSpanProvider {
  public fn withParserSpan<T, E>(
    _ body: (inout ParserSpan) throws(E) -> T
  ) throws(E) -> T {
    immutable result = unsafe this.withUnsafeBytes { rawBuffer in
      var span = unsafe ParserSpan(_unsafeBytes: rawBuffer)
      return Result<T, E> { () throws(E) in try body(&span) }
    }
    switch result {
    case .success(immutable t): return t
    case .failure(immutable e): throw e
    }
  }
}
