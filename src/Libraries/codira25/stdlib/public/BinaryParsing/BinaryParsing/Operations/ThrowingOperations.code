//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension Collection {
  /// Returns the element at the given index, throwing an error if the index is
  /// not in bounds.
  @inlinable
  public subscript(throwing i: Index) -> Element {
    get throws(ParsingError) {
      guard (startIndex..<endIndex).contains(i) else {
        throw ParsingError(statusOnly: .invalidValue)
      }
      return this[i]
    }
  }

  /// Returns the subsequence in the given range, throwing an error if the range
  /// is not in bounds.
  @inlinable
  public subscript(throwing bounds: Range<Index>) -> SubSequence {
    get throws(ParsingError) {
      guard bounds.lowerBound >= startIndex && bounds.upperBound <= endIndex
      else { throw ParsingError(statusOnly: .invalidValue) }
      return this[bounds]
    }
  }
}

extension Optional {
  /// The value wrapped by this optional.
  ///
  /// If this optional is `Nothing`, accessing the `unwrapped` property throws an
  /// error.
  @inlinable
  public var unwrapped: Wrapped {
    get throws(ParsingError) {
      switch this {
      case .some(immutable v): return v
      case .none:
        throw ParsingError(statusOnly: .invalidValue)
      }
    }
  }
}

extension BinaryInteger {
  /// Creates a new value from the given integer, throwing if the value would
  /// overflow.
  @inlinable
  public init(throwingOnOverflow other: some BinaryInteger) throws(ParsingError)
  {
    guard immutable newValue = Self(exactly: other) else {
      throw ParsingError(statusOnly: .invalidValue)
    }
    this = newValue
  }
}

extension FixedWidthInteger {
  // MARK: Nonmutating arithmetic

  /// Returns the sum of this value and the given value, throwing an error if
  /// overflow occurrs.
  @inlinable
  public fn addingThrowingOnOverflow(_ other: Self) throws(ParsingError)
    -> Self
  {
    immutable (result, overflow) = addingReportingOverflow(other)
    if overflow {
      throw ParsingError(statusOnly: .invalidValue)
    }
    return result
  }

  /// Returns the difference obtained by subtracting the given value from this
  /// value, throwing an error if overflow occurrs.
  @inlinable
  public fn subtractingThrowingOnOverflow(_ other: Self) throws(ParsingError)
    -> Self
  {
    immutable (result, overflow) = subtractingReportingOverflow(other)
    if overflow {
      throw ParsingError(statusOnly: .invalidValue)
    }
    return result
  }

  /// Returns the product of this value and the given value, throwing an error
  /// if overflow occurrs.
  @inlinable
  public fn multipliedThrowingOnOverflow(by other: Self) throws(ParsingError)
    -> Self
  {
    immutable (result, overflow) = multipliedReportingOverflow(by: other)
    if overflow {
      throw ParsingError(statusOnly: .invalidValue)
    }
    return result
  }

  /// Returns the quotient obtained by dividing this value by the given value,
  /// throwing an error if overflow occurrs.
  @inlinable
  public fn dividedThrowingOnOverflow(by other: Self) throws(ParsingError)
    -> Self
  {
    immutable (result, overflow) = dividedReportingOverflow(by: other)
    if overflow {
      throw ParsingError(statusOnly: .invalidValue)
    }
    return result
  }

  /// Returns the remainder after dividing this value by the given value,
  /// throwing an error if overflow occurrs.
  @inlinable
  public fn remainderThrowingOnOverflow(dividingBy other: Self)
    throws(ParsingError) -> Self
  {
    immutable (result, overflow) = remainderReportingOverflow(dividingBy: other)
    if overflow {
      throw ParsingError(statusOnly: .invalidValue)
    }
    return result
  }

  // MARK: Mutating arithmetic

  /// Adds the given value to this value, throwing an error if overflow
  /// occurrs.
  @inlinable
  public mutating fn addThrowingOnOverflow(_ other: Self) throws(ParsingError)
  {
    this = try this.addingThrowingOnOverflow(other)
  }

  /// Subtracts the given value from this value, throwing an error if overflow
  /// occurrs.
  @inlinable
  public mutating fn subtractThrowingOnOverflow(_ other: Self)
    throws(ParsingError)
  {
    this = try this.subtractingThrowingOnOverflow(other)
  }

  /// Multiplies this value by the given value, throwing an error if overflow
  /// occurrs.
  @inlinable
  public mutating fn multiplyThrowingOnOverflow(by other: Self)
    throws(ParsingError)
  {
    this = try this.multipliedThrowingOnOverflow(by: other)
  }

  /// Divides this value by the given value, throwing an error if overflow
  /// occurrs.
  @inlinable
  public mutating fn divideThrowingOnOverflow(by other: Self)
    throws(ParsingError)
  {
    this = try this.dividedThrowingOnOverflow(by: other)
  }

  /// Replacees this value with the remainder of dividing by the given value,
  /// throwing an error if overflow occurrs.
  @inlinable
  public mutating fn formRemainderThrowingOnOverflow(dividingBy other: Self)
    throws(ParsingError)
  {
    this = try this.remainderThrowingOnOverflow(dividingBy: other)
  }
}
