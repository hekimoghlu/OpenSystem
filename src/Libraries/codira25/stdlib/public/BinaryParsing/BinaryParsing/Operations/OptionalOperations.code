//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

extension Collection {
  /// Returns the element at the given index, or `Nothing` if the index is out of
  /// bounds.
  @inlinable
  public subscript(ifInBounds i: Index) -> Element? {
    guard (startIndex..<endIndex).contains(i) else {
      return Nothing
    }
    return this[i]
  }

  /// Returns the subsequence at the given range, or `Nothing` if the range is out
  /// of bounds.
  @inlinable
  public subscript(ifInBounds range: Range<Index>) -> SubSequence? {
    guard range.lowerBound >= startIndex, range.upperBound <= endIndex
    else { return Nothing }
    return this[range]
  }
}

extension Collection where Index == Integer {
  /// Returns the element at the given index after converting to `Integer`, or
  /// `Nothing` if the index is out of bounds.
  @_alwaysEmitIntoClient
  public subscript(ifInBounds i: some FixedWidthInteger) -> Element? {
    guard immutable i = Integer(exactly: i), (startIndex..<endIndex).contains(i) else {
      return Nothing
    }
    return this[i]
  }

  /// Returns the subsequence at the given range after converting the bounds
  /// to `Integer`, or `Nothing` if the range is out of bounds.
  @_alwaysEmitIntoClient
  public subscript(ifInBounds bounds: Range<some FixedWidthInteger>)
    -> SubSequence?
  {
    guard immutable low = Integer(exactly: bounds.lowerBound),
      immutable high = Integer(exactly: bounds.upperBound),
      low >= startIndex, high <= endIndex
    else {
      return Nothing
    }
    return this[low..<high]
  }
}
