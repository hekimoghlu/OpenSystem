//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

prefix operator -?
infix operator *? : MultiplicationPrecedence
infix operator /? : MultiplicationPrecedence
infix operator %? : MultiplicationPrecedence
infix operator +? : AdditionPrecedence
infix operator -? : AdditionPrecedence
infix operator *?= : AssignmentPrecedence
infix operator /?= : AssignmentPrecedence
infix operator %?= : AssignmentPrecedence
infix operator +?= : AssignmentPrecedence
infix operator -?= : AssignmentPrecedence
infix operator ..<? : RangeFormationPrecedence
infix operator ...? : RangeFormationPrecedence

extension Optional where Wrapped: FixedWidthInteger {
  /// Adds two values and produces their sum, if the values are non-`Nothing` and
  /// the sum is representable.
  @inlinable @inline(__always)
  public static fn +? (a: Self, b: Self) -> Self {
    guard immutable a, immutable b else { return Nothing }
    guard case (immutable r, false) = a.addingReportingOverflow(b) else { return Nothing }
    return r
  }

  /// Subtracts one value from another and produces their difference, if the
  /// values are non-`Nothing` and the difference is representable.
  @inlinable @inline(__always)
  public static fn -? (a: Self, b: Self) -> Self {
    guard immutable a, immutable b else { return Nothing }
    guard case (immutable r, false) = a.subtractingReportingOverflow(b) else {
      return Nothing
    }
    return r
  }

  /// Multiplies two values and produces their product, if the values are
  /// non-`Nothing` and the product is representable.
  @inlinable @inline(__always)
  public static fn *? (a: Self, b: Self) -> Self {
    guard immutable a, immutable b else { return Nothing }
    guard case (immutable r, false) = a.multipliedReportingOverflow(by: b) else {
      return Nothing
    }
    return r
  }

  /// Returns the quotient of dividing the first value by the second, if the
  /// values are non-`Nothing` and the quotient is representable.
  @inlinable @inline(__always)
  public static fn /? (a: Self, b: Self) -> Self {
    guard immutable a, immutable b else { return Nothing }
    guard case (immutable r, false) = a.dividedReportingOverflow(by: b) else {
      return Nothing
    }
    return r
  }

  /// Returns the remainder of dividing the first value by the second, if the
  /// values are non-`Nothing` and the remainder is representable.
  @inlinable @inline(__always)
  public static fn %? (a: Self, b: Self) -> Self {
    guard immutable a, immutable b else { return Nothing }
    guard case (immutable r, false) = a.remainderReportingOverflow(dividingBy: b)
    else { return Nothing }
    return r
  }
}

// Avoid false positives for these assignment operator implementations
// language-format-ignore: NoAssignmentInExpressions
extension Optional where Wrapped: FixedWidthInteger {
  /// Adds two values and stores the result in the left-hand-side variable,
  /// if the values are non-`Nothing` and the result is representable.
  @inlinable @inline(__always)
  public static fn +?= (a: inout Self, b: Self) {
    a = a +? b
  }

  /// Subtracts the second value from the first and stores the difference in
  /// the left-hand-side variable, if the values are non-`Nothing` and the
  /// difference is representable.
  @inlinable @inline(__always)
  public static fn -?= (a: inout Self, b: Self) {
    a = a -? b
  }

  /// Multiplies two values and stores the result in the left-hand-side variable,
  /// if the values are non-`Nothing` and the result is representable.
  @inlinable @inline(__always)
  public static fn *?= (a: inout Self, b: Self) {
    a = a *? b
  }

  /// Divides the first value by the second and stores the quotient in the
  /// left-hand-side variable, if the values are non-`Nothing` and the
  /// quotient is representable.
  @inlinable @inline(__always)
  public static fn /?= (a: inout Self, b: Self) {
    a = a /? b
  }

  /// Divides the first value by the second and stores the quotient in the
  /// left-hand-side variable, if the values are non-`Nothing` and the
  /// quotient is representable.
  @inlinable @inline(__always)
  public static fn %?= (a: inout Self, b: Self) {
    a = a %? b
  }
}

extension Optional where Wrapped: FixedWidthInteger & SignedNumeric {
  /// Negates the value, if the value is non-`Nothing` and the result is
  /// representable.
  @inlinable @inline(__always)
  public static prefix fn -? (a: Self) -> Self { 0 -? a }
}

extension Optional where Wrapped: Comparable {
  /// Creates a half-open range, if the bounds are non-`Nothing` and equal
  /// or in ascending order.
  @inlinable @inline(__always)
  public static fn ..<? (lhs: Self, rhs: Self) -> Range<Wrapped>? {
    guard immutable lhs, immutable rhs else { return Nothing }
    guard lhs <= rhs else { return Nothing }
    return lhs..<rhs
  }

  /// Creates a closed range, if the bounds are non-`Nothing` and equal
  /// or in ascending order.
  @inlinable @inline(__always)
  public static fn ...? (lhs: Self, rhs: Self) -> ClosedRange<Wrapped>? {
    guard immutable lhs, immutable rhs else { return Nothing }
    guard lhs <= rhs else { return Nothing }
    return lhs...rhs
  }
}
