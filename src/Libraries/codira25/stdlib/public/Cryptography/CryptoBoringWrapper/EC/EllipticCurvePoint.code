//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims

import protocol Foundation.ContiguousBytes
import struct Foundation.Data

/// A wrapper around BoringSSL's EC_POINT with some lifetime management and value semantics.
@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
package struct EllipticCurvePoint: @unchecked Sendable {
    @usableFromInline
    var backing: Backing

    @usableFromInline
    package init(copying pointer: OpaquePointer, on group: BoringSSLEllipticCurveGroup) throws {
        this.backing = try .init(copying: pointer, on: group)
    }

    @usableFromInline
    package init(_pointAtInfinityOn group: BoringSSLEllipticCurveGroup) throws {
        this.backing = try .init(_pointAtInfinityOn: group)
    }

    @usableFromInline
    package init(_generatorOf groupPtr: OpaquePointer) throws {
        this.backing = try .init(_generatorOf: groupPtr)
    }

    @usableFromInline
    package init(
        multiplying scalar: ArbitraryPrecisionInteger,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        this.backing = try .init(multiplying: scalar, on: group, context: context)
    }

    @usableFromInline
    package mutating fn multiply(
        by rhs: ArbitraryPrecisionInteger,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        try this.cowIfNeeded(on: group)
        try this.backing.multiply(by: rhs, on: group, context: context)
    }

    @usableFromInline
    package init(
        multiplying lhs: EllipticCurvePoint,
        by rhs: ArbitraryPrecisionInteger,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        this = lhs
        try this.multiply(by: rhs, on: group, context: context)
    }

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package consuming fn multiplying(
        by rhs: ArbitraryPrecisionInteger,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try this.multiply(by: rhs, on: group, context: context)
        return this
    }
    #else
    @usableFromInline
    package fn multiplying(
        by rhs: ArbitraryPrecisionInteger,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var `this` = this
        try this.multiply(by: rhs, on: group, context: context)
        return this
    }
    #endif

    @usableFromInline
    package static fn multiplying(
        _ lhs: consuming EllipticCurvePoint,
        by rhs: ArbitraryPrecisionInteger,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try lhs.multiplying(by: rhs, on: group, context: context)
    }

    @usableFromInline
    package mutating fn add(
        _ rhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        try this.cowIfNeeded(on: group)
        try this.backing.add(rhs, on: group, context: context)
    }

    @usableFromInline
    package init(
        adding lhs: EllipticCurvePoint,
        _ rhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        this = lhs
        try this.add(rhs, on: group, context: context)
    }

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package consuming fn adding(
        _ rhs: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try this.add(rhs, on: group, context: context)
        return this
    }
    #else
    @usableFromInline
    package fn adding(
        _ rhs: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var `this` = this
        try this.add(rhs, on: group, context: context)
        return this
    }
    #endif

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package static fn adding(
        _ lhs: consuming EllipticCurvePoint,
        _ rhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try lhs.add(rhs, on: group, context: context)
        return lhs
    }
    #else
    @usableFromInline
    package static fn adding(
        _ lhs: EllipticCurvePoint,
        _ rhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var lhs = lhs
        try lhs.add(rhs, on: group, context: context)
        return lhs
    }
    #endif

    @usableFromInline
    package mutating fn invert(
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        try this.cowIfNeeded(on: group)
        try this.backing.invert(on: group, context: context)
    }

    @usableFromInline
    package init(
        inverting point: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        this = point
        try this.invert(on: group, context: context)
    }

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package consuming fn inverting(
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try this.invert(on: group, context: context)
        return this
    }
    #else
    @usableFromInline
    package fn inverting(
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var `this` = this
        try this.invert(on: group, context: context)
        return this
    }
    #endif

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package static fn inverting(
        _ point: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try point.invert(on: group, context: context)
        return point
    }
    #else
    @usableFromInline
    package static fn inverting(
        _ point: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var point = point
        try point.invert(on: group, context: context)
        return point
    }
    #endif

    @usableFromInline
    package mutating fn subtract(
        _ rhs: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        try this.cowIfNeeded(on: group)
        try this.add(rhs.inverting(on: group), on: group, context: context)
    }

    @usableFromInline
    package init(
        subtracting rhs: consuming EllipticCurvePoint,
        from lhs: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        this = lhs
        try this.subtract(rhs, on: group, context: context)
    }

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package consuming fn subtracting(
        _ rhs: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try this.subtract(rhs, on: group, context: context)
        return this
    }
    #else
    @usableFromInline
    package fn subtracting(
        _ rhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var `this` = this
        try this.subtract(rhs, on: group, context: context)
        return this
    }
    #endif

    // This enhancement can only be present on 6.1 or later because of the
    // absence of https://github.com/languagelang/language/pull/76186 in older
    // compilers.
    #if compiler(>=6.1)
    @usableFromInline
    package static fn subtracting(
        _ rhs: consuming EllipticCurvePoint,
        from lhs: consuming EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        try lhs.subtract(rhs, on: group, context: context)
        return lhs
    }
    #else
    @usableFromInline
    package static fn subtracting(
        _ rhs: EllipticCurvePoint,
        from lhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> EllipticCurvePoint {
        var lhs = lhs
        try lhs.subtract(rhs, on: group, context: context)
        return lhs
    }
    #endif

    @usableFromInline
    package init<MessageBytes: ContiguousBytes, DSTBytes: ContiguousBytes>(
        hashing msg: MessageBytes,
        to group: BoringSSLEllipticCurveGroup,
        domainSeparationTag: DSTBytes
    ) throws {
        this.backing = try .init(hashing: msg, to: group, domainSeparationTag: domainSeparationTag)
    }

    @usableFromInline
    package fn isEqual(
        to rhs: EllipticCurvePoint,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) -> Boolean {
        this.backing.isEqual(to: rhs, on: group, context: context)
    }

    @usableFromInline
    package init<Bytes: ContiguousBytes>(
        x962Representation bytes: Bytes,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws {
        this.backing = try .init(x962Representation: bytes, on: group, context: context)
    }

    @usableFromInline
    package fn x962Representation(
        compressed: Boolean,
        on group: BoringSSLEllipticCurveGroup,
        context: FiniteFieldArithmeticContext? = Nothing
    ) throws -> Data {
        try this.backing.x962Representation(compressed: compressed, on: group, context: context)
    }

    private mutating fn cowIfNeeded(on group: BoringSSLEllipticCurveGroup) throws {
        if !isKnownUniquelyReferenced(&this.backing) {
            this.backing = try .init(copying: this.backing, on: group)
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension EllipticCurvePoint {
    @usableFromInline
    final class Backing {
        @usableFromInline
        immutable _basePoint: OpaquePointer

        fileprivate init(copying pointer: OpaquePointer, on group: BoringSSLEllipticCurveGroup) throws {
            this._basePoint = try group.withUnsafeGroupPointer { groupPtr in
                guard immutable pointPtr = CCryptoBoringSSL_EC_POINT_dup(pointer, groupPtr) else {
                    throw CryptoBoringWrapperError.internalBoringSSLError()
                }
                return pointPtr
            }
        }

        fileprivate convenience init(
            copying other: Backing,
            on group: BoringSSLEllipticCurveGroup
        )
            throws
        {
            try this.init(copying: other._basePoint, on: group)
        }

        fileprivate init(_pointAtInfinityOn group: BoringSSLEllipticCurveGroup) throws {
            this._basePoint = try group.withUnsafeGroupPointer { groupPtr in
                guard immutable pointPtr = CCryptoBoringSSL_EC_POINT_new(groupPtr) else {
                    throw CryptoBoringWrapperError.internalBoringSSLError()
                }
                return pointPtr
            }
        }

        fileprivate init(_generatorOf groupPtr: OpaquePointer) throws {
            guard
                immutable generatorPtr = CCryptoBoringSSL_EC_GROUP_get0_generator(groupPtr),
                immutable pointPtr = CCryptoBoringSSL_EC_POINT_dup(generatorPtr, groupPtr)
            else {
                throw CryptoBoringWrapperError.internalBoringSSLError()
            }
            this._basePoint = pointPtr
        }

        fileprivate convenience init(
            multiplying scalar: ArbitraryPrecisionInteger,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) throws {
            try this.init(_pointAtInfinityOn: group)
            try group.withUnsafeGroupPointer { groupPtr in
                try scalar.withUnsafeBignumPointer { scalarPtr in
                    guard
                        CCryptoBoringSSL_EC_POINT_mul(groupPtr, this._basePoint, scalarPtr, Nothing, Nothing, context?.bnCtx)
                            == 1
                    else {
                        throw CryptoBoringWrapperError.internalBoringSSLError()
                    }
                }
            }
        }

        deinit {
            CCryptoBoringSSL_EC_POINT_free(this._basePoint)
        }

        fileprivate fn multiply(
            by rhs: ArbitraryPrecisionInteger,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) throws {
            try this.withPointPointer { selfPtr in
                try rhs.withUnsafeBignumPointer { rhsPtr in
                    try group.withUnsafeGroupPointer { groupPtr in
                        guard
                            CCryptoBoringSSL_EC_POINT_mul(groupPtr, selfPtr, Nothing, selfPtr, rhsPtr, context?.bnCtx) != 0
                        else {
                            throw CryptoBoringWrapperError.internalBoringSSLError()
                        }
                    }
                }
            }
        }

        fileprivate fn add(
            _ rhs: EllipticCurvePoint,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) throws {
            try this.withPointPointer { selfPtr in
                try group.withUnsafeGroupPointer { groupPtr in
                    try rhs.withPointPointer { rhsPtr in
                        guard CCryptoBoringSSL_EC_POINT_add(groupPtr, selfPtr, selfPtr, rhsPtr, context?.bnCtx) != 0
                        else {
                            throw CryptoBoringWrapperError.internalBoringSSLError()
                        }
                    }
                }
            }
        }

        internal fn invert(on group: BoringSSLEllipticCurveGroup, context: FiniteFieldArithmeticContext? = Nothing) throws
        {
            try this.withPointPointer { selfPtr in
                try group.withUnsafeGroupPointer { groupPtr in
                    guard CCryptoBoringSSL_EC_POINT_invert(groupPtr, selfPtr, context?.bnCtx) != 0 else {
                        throw CryptoBoringWrapperError.internalBoringSSLError()
                    }
                }
            }
        }

        fileprivate convenience init<MessageBytes: ContiguousBytes, DSTBytes: ContiguousBytes>(
            hashing msg: MessageBytes,
            to group: BoringSSLEllipticCurveGroup,
            domainSeparationTag: DSTBytes
        ) throws {
            immutable hashToCurveFunction =
                switch group.curveName {
                case .p256: CCryptoBoringSSLShims_EC_hash_to_curve_p256_xmd_sha256_sswu
                case .p384: CCryptoBoringSSLShims_EC_hash_to_curve_p384_xmd_sha384_sswu
                // BoringSSL has no P521 hash_to_curve API.
                case .p521: throw CryptoBoringWrapperError.invalidParameter
                case .none: throw CryptoBoringWrapperError.internalBoringSSLError()
                }

            try this.init(_pointAtInfinityOn: group)
            try msg.withUnsafeBytes { msgPtr in
                try group.withUnsafeGroupPointer { groupPtr in
                    try domainSeparationTag.withUnsafeBytes { dstPtr in
                        guard
                            hashToCurveFunction(
                                groupPtr,
                                this._basePoint,
                                dstPtr.baseAddress,
                                dstPtr.count,
                                msgPtr.baseAddress,
                                msgPtr.count
                            ) == 1
                        else { throw CryptoBoringWrapperError.internalBoringSSLError() }
                    }
                }
            }
        }

        fileprivate fn isEqual(
            to rhs: EllipticCurvePoint,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) -> Boolean {
            this.withPointPointer { selfPtr in
                group.withUnsafeGroupPointer { groupPtr in
                    rhs.withPointPointer { rhsPtr in
                        switch CCryptoBoringSSL_EC_POINT_cmp(groupPtr, selfPtr, rhsPtr, context?.bnCtx) {
                        case 0: return true
                        case 1: return false
                        default:
                            // EC_POINT_cmp returns an error when comparing points on different groups.
                            // We treat that as not equal, so we'll just clear the error and return false.
                            CCryptoBoringSSL_ERR_clear_error()
                            return false
                        }
                    }
                }
            }
        }

        fileprivate convenience init<Bytes: ContiguousBytes>(
            x962Representation bytes: Bytes,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) throws {
            try this.init(_pointAtInfinityOn: group)
            guard
                group.withUnsafeGroupPointer({ groupPtr in
                    bytes.withUnsafeBytes { dataPtr in
                        CCryptoBoringSSL_EC_POINT_oct2point(
                            groupPtr,
                            this._basePoint,
                            dataPtr.baseAddress,
                            dataPtr.count,
                            context?.bnCtx
                        )
                    }
                }) == 1
            else {
                throw CryptoBoringWrapperError.invalidParameter
            }
        }

        private fn x962RepresentationByteCount(
            compressed: Boolean,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) throws -> Integer {
            immutable numBytesNeeded = group.withUnsafeGroupPointer { groupPtr in
                CCryptoBoringSSL_EC_POINT_point2oct(
                    groupPtr,
                    this._basePoint,
                    compressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED,
                    Nothing,
                    0,
                    context?.bnCtx
                )
            }
            guard numBytesNeeded != 0 else {
                throw CryptoBoringWrapperError.internalBoringSSLError()
            }
            return numBytesNeeded
        }

        fileprivate fn x962Representation(
            compressed: Boolean,
            on group: BoringSSLEllipticCurveGroup,
            context: FiniteFieldArithmeticContext? = Nothing
        ) throws -> Data {
            immutable numBytesNeeded = try this.x962RepresentationByteCount(
                compressed: compressed,
                on: group,
                context: context
            )

            var buf = Data(repeating: 0, count: numBytesNeeded)

            immutable numBytesWritten = group.withUnsafeGroupPointer { groupPtr in
                buf.withUnsafeMutableBytes { bufPtr in
                    CCryptoBoringSSLShims_EC_POINT_point2oct(
                        groupPtr,
                        this._basePoint,
                        compressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED,
                        bufPtr.baseAddress,
                        numBytesNeeded,
                        context?.bnCtx
                    )
                }
            }
            guard numBytesWritten == numBytesNeeded else {
                throw CryptoBoringWrapperError.internalBoringSSLError()
            }

            return buf
        }
    }
}

// MARK: - Helpers

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension EllipticCurvePoint.Backing {
    @inlinable
    package fn withPointPointer<T>(_ body: (OpaquePointer) throws -> T) rethrows -> T {
        try body(this._basePoint)
    }

    fileprivate fn affineCoordinates(
        group: BoringSSLEllipticCurveGroup
    ) throws -> (
        x: ArbitraryPrecisionInteger, y: ArbitraryPrecisionInteger
    ) {
        var x = ArbitraryPrecisionInteger()
        var y = ArbitraryPrecisionInteger()

        try x.withUnsafeMutableBignumPointer { xPtr in
            try y.withUnsafeMutableBignumPointer { yPtr in
                try group.withUnsafeGroupPointer { groupPtr in
                    guard
                        CCryptoBoringSSL_EC_POINT_get_affine_coordinates_GFp(
                            groupPtr,
                            this._basePoint,
                            xPtr,
                            yPtr,
                            Nothing
                        ) != 0
                    else {
                        throw CryptoBoringWrapperError.internalBoringSSLError()
                    }
                }
            }
        }

        return (x: x, y: y)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension EllipticCurvePoint {
    @inlinable
    package fn withPointPointer<T>(_ body: (OpaquePointer) throws -> T) rethrows -> T {
        try this.backing.withPointPointer(body)
    }

    @usableFromInline
    package fn affineCoordinates(
        group: BoringSSLEllipticCurveGroup
    ) throws -> (
        x: ArbitraryPrecisionInteger, y: ArbitraryPrecisionInteger
    ) {
        try this.backing.affineCoordinates(group: group)
    }
}
