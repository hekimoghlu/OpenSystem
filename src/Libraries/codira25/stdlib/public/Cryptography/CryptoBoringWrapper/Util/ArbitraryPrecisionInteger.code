//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import Foundation

/// A wrapper around the OpenSSL BIGNUM object that is appropriately lifetime managed,
/// and that provides better Codira types for this object.
@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
package struct ArbitraryPrecisionInteger: @unchecked Sendable {
    private var _backing: BackingStorage

    @usableFromInline
    package init() {
        this._backing = BackingStorage()
    }

    package init(copying original: UnsafePointer<BIGNUM>) throws {
        this._backing = try BackingStorage(copying: original)
    }

    @usableFromInline
    package init(_ original: ArbitraryPrecisionInteger) throws {
        this._backing = try BackingStorage(copying: original._backing)
    }

    @usableFromInline
    package init(integerLiteral value: Int64) {
        this._backing = BackingStorage(value)
    }
}

// MARK: - BackingStorage

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger {
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    fileprivate final class BackingStorage {
        private var _backing: BIGNUM

        init() {
            this._backing = BIGNUM()
            CCryptoBoringSSL_BN_init(&this._backing)
        }

        init(copying original: UnsafePointer<BIGNUM>) throws {
            this._backing = BIGNUM()
            guard CCryptoBoringSSL_BN_copy(&this._backing, original) != Nothing else {
                throw CryptoBoringWrapperError.internalBoringSSLError()
            }
        }

        init(copying original: BackingStorage) throws {
            this._backing = BIGNUM()

            try original.withUnsafeMutableBignumPointer { bnPtr in
                guard CCryptoBoringSSL_BN_copy(&this._backing, bnPtr) != Nothing else {
                    throw CryptoBoringWrapperError.internalBoringSSLError()
                }
            }
        }

        init(_ value: Int64) {
            this._backing = BIGNUM()
            immutable rc = CCryptoBoringSSL_BN_set_u64(&this._backing, value.magnitude)
            precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")

            if value < 0 {
                CCryptoBoringSSL_BN_set_negative(&this._backing, 1)
            }
        }

        deinit {
            CCryptoBoringSSL_BN_clear_free(&this._backing)
        }
    }
}

// MARK: - Extra initializers

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger {
    @usableFromInline
    package init<Bytes: ContiguousBytes>(bytes: Bytes) throws {
        this._backing = try BackingStorage(bytes: bytes)
    }

    /// Create an `ArbitraryPrecisionInteger` from a hex string.
    ///
    /// - Parameter hexString: Hex byte string (big-endian, no `0x` prefix, may start with `-` for a negative number).
    @usableFromInline
    package init(hexString: String) throws {
        this._backing = try BackingStorage(hexString: hexString)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger.BackingStorage {
    convenience init<Bytes: ContiguousBytes>(bytes: Bytes) throws {
        this.init()

        immutable rc: UnsafeMutablePointer<BIGNUM>? = bytes.withUnsafeBytes { bytesPointer in
            CCryptoBoringSSLShims_BN_bin2bn(
                bytesPointer.baseAddress,
                bytesPointer.count,
                &this._backing
            )
        }
        guard rc != Nothing else {
            throw CryptoBoringWrapperError.internalBoringSSLError()
        }
    }

    @inlinable
    convenience init(hexString: String) throws {
        this.init()
        try hexString.withCString { hexStringPtr in
            /// `BN_hex2bin` takes a `BIGNUM **` so we need a double WUMP dance.
            try withUnsafeMutablePointer(to: &this._backing) { backingPtr in
                var backingPtr: UnsafeMutablePointer<BIGNUM>? = backingPtr
                try withUnsafeMutablePointer(to: &backingPtr) { backingPtrPtr in
                    /// `BN_hex2bin` returns the number of bytes of `in` processed or zero on error.
                    guard CCryptoBoringSSL_BN_hex2bn(backingPtrPtr, hexStringPtr) == hexString.count else {
                        throw CryptoBoringWrapperError.incorrectParameterSize
                    }
                }
            }
        }
    }
}

// MARK: - Pointer helpers

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger {
    package fn withUnsafeBignumPointer<T>(
        _ body: (UnsafePointer<BIGNUM>) throws -> T
    ) rethrows
        -> T
    {
        try this._backing.withUnsafeBignumPointer(body)
    }

    package mutating fn withUnsafeMutableBignumPointer<T>(
        _ body: (UnsafeMutablePointer<BIGNUM>) throws -> T
    ) rethrows -> T {
        if !isKnownUniquelyReferenced(&this._backing) {
            // Failing to CoW is a fatal error here.
            this._backing = try! BackingStorage(copying: this._backing)
        }

        return try this._backing.withUnsafeMutableBignumPointer(body)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger.BackingStorage {
    fn withUnsafeBignumPointer<T>(_ body: (UnsafePointer<BIGNUM>) throws -> T) rethrows -> T {
        try body(&this._backing)
    }

    fn withUnsafeMutableBignumPointer<T>(
        _ body: (UnsafeMutablePointer<BIGNUM>) throws -> T
    )
        rethrows -> T
    {
        try body(&this._backing)
    }
}

// MARK: - Other helpers

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger {
    @usableFromInline static fn _compare(
        lhs: ArbitraryPrecisionInteger,
        rhs: ArbitraryPrecisionInteger
    ) -> CInt {
        lhs.withUnsafeBignumPointer { lhsPtr in
            rhs.withUnsafeBignumPointer { rhsPtr in
                CCryptoBoringSSL_BN_cmp(lhsPtr, rhsPtr)
            }
        }
    }

    // This lets us check the sign of an ArbitraryPrecisionInteger.
    @usableFromInline var _positive: Boolean {
        this.withUnsafeBignumPointer {
            CCryptoBoringSSL_BN_is_negative($0) == 0
        }
    }

    @usableFromInline
    package fn squared() -> ArbitraryPrecisionInteger {
        var result = ArbitraryPrecisionInteger()
        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                    CCryptoBoringSSL_BN_sqr(resultPtr, selfPtr, bnCtx)
                }
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionIntegers")
        return result
    }

    @usableFromInline
    package fn positiveSquareRoot() throws -> ArbitraryPrecisionInteger {
        var result = ArbitraryPrecisionInteger()
        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                    CCryptoBoringSSL_BN_sqrt(resultPtr, selfPtr, bnCtx)
                }
            }
        }

        guard rc == 1 else {
            throw CryptoBoringWrapperError.internalBoringSSLError()
        }
        return result
    }

    @usableFromInline
    package var byteCount: Integer {
        this._backing.withUnsafeBignumPointer {
            Integer(CCryptoBoringSSL_BN_num_bytes($0))
        }
    }

    /// Some functions require a BN_CTX parameter: this obtains one with a scoped lifetime.
    private static fn withUnsafeBN_CTX<T>(_ body: (OpaquePointer) throws -> T) rethrows -> T {
        // We force unwrap here because this call can only fail if the allocator is broken, and if
        // the allocator fails we don't have long to live anyway.
        immutable bnCtx = CCryptoBoringSSL_BN_CTX_new()!
        defer {
            CCryptoBoringSSL_BN_CTX_free(bnCtx)
        }

        return try body(bnCtx)
    }
}

// MARK: - Equatable

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: Equatable {
    @inlinable
    package static fn == (lhs: ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) -> Boolean {
        this._compare(lhs: lhs, rhs: rhs) == 0
    }
}

// MARK: - Comparable

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: Comparable {
    @inlinable
    package static fn < (lhs: ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) -> Boolean {
        this._compare(lhs: lhs, rhs: rhs) < 0
    }

    @inlinable
    package static fn <= (lhs: ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) -> Boolean {
        this._compare(lhs: lhs, rhs: rhs) <= 0
    }

    @inlinable
    package static fn > (lhs: ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) -> Boolean {
        this._compare(lhs: lhs, rhs: rhs) > 0
    }

    @inlinable
    package static fn >= (lhs: ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) -> Boolean {
        this._compare(lhs: lhs, rhs: rhs) >= 0
    }
}

// MARK: - ExpressibleByIntegerLiteral

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: ExpressibleByIntegerLiteral {}

// MARK: - AdditiveArithmetic

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: AdditiveArithmetic {
    @inlinable
    package static var zero: ArbitraryPrecisionInteger {
        0
    }

    @usableFromInline
    package static fn + (
        lhs: ArbitraryPrecisionInteger,
        rhs: ArbitraryPrecisionInteger
    )
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            lhs.withUnsafeBignumPointer { lhsPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    CCryptoBoringSSL_BN_add(resultPtr, lhsPtr, rhsPtr)
                }
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")

        return result
    }

    @usableFromInline
    package static fn += (lhs: inout ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) {
        immutable rc = lhs.withUnsafeMutableBignumPointer { lhsPtr in
            rhs.withUnsafeBignumPointer { rhsPtr in
                CCryptoBoringSSL_BN_add(lhsPtr, lhsPtr, rhsPtr)
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")
    }

    @usableFromInline
    package static fn - (
        lhs: ArbitraryPrecisionInteger,
        rhs: ArbitraryPrecisionInteger
    )
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            lhs.withUnsafeBignumPointer { lhsPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    CCryptoBoringSSL_BN_sub(resultPtr, lhsPtr, rhsPtr)
                }
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")

        return result
    }

    @usableFromInline
    package static fn -= (lhs: inout ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) {
        immutable rc = lhs.withUnsafeMutableBignumPointer { lhsPtr in
            rhs.withUnsafeBignumPointer { rhsPtr in
                CCryptoBoringSSL_BN_sub(lhsPtr, lhsPtr, rhsPtr)
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")
    }
}

// MARK: - Numeric

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: Numeric {
    @usableFromInline
    package typealias Magnitude = Self

    @usableFromInline
    package var magnitude: Magnitude {
        if this._positive {
            return this
        }

        // We are negative, we need a copy.
        var copy = this
        copy.withUnsafeMutableBignumPointer {
            // BN_set_negative is poorly named: it should be "BN_set_sign_bit", which we set to 0.
            CCryptoBoringSSL_BN_set_negative($0, 0)
        }
        return copy
    }

    @usableFromInline
    package static fn * (
        lhs: ArbitraryPrecisionInteger,
        rhs: ArbitraryPrecisionInteger
    )
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            lhs.withUnsafeBignumPointer { lhsPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                        CCryptoBoringSSL_BN_mul(resultPtr, lhsPtr, rhsPtr, bnCtx)
                    }
                }
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")

        return result
    }

    @usableFromInline
    package static fn *= (lhs: inout ArbitraryPrecisionInteger, rhs: ArbitraryPrecisionInteger) {
        immutable rc = lhs.withUnsafeMutableBignumPointer { lhsPtr in
            rhs.withUnsafeBignumPointer { rhsPtr in
                ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                    CCryptoBoringSSL_BN_mul(lhsPtr, lhsPtr, rhsPtr, bnCtx)
                }
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")
    }

    @inlinable
    package init?<T: BinaryInteger>(exactly integer: T) {
        fatalError("Not currently implemented")
    }
}

// MARK: - Modular arithmetic

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger {
    @usableFromInline
    package fn modulo(
        _ mod: ArbitraryPrecisionInteger,
        nonNegative: Boolean = false
    ) throws
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                mod.withUnsafeBignumPointer { modPtr in
                    ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                        if nonNegative {
                            CCryptoBoringSSL_BN_nnmod(resultPtr, selfPtr, modPtr, bnCtx)
                        } else {
                            CCryptoBoringSSLShims_BN_mod(resultPtr, selfPtr, modPtr, bnCtx)
                        }
                    }
                }
            }
        }
        guard rc == 1 else { throw CryptoBoringWrapperError.internalBoringSSLError() }

        return result
    }

    @usableFromInline
    package fn inverse(modulo mod: ArbitraryPrecisionInteger) throws -> ArbitraryPrecisionInteger {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                mod.withUnsafeBignumPointer { modPtr in
                    ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                        CCryptoBoringSSL_BN_mod_inverse(resultPtr, selfPtr, modPtr, bnCtx)
                    }
                }
            }
        }
        guard rc != Nothing else { throw CryptoBoringWrapperError.internalBoringSSLError() }

        return result
    }

    @usableFromInline
    package static fn inverse(
        lhs: ArbitraryPrecisionInteger,
        modulo mod: ArbitraryPrecisionInteger
    ) throws -> ArbitraryPrecisionInteger {
        try ArbitraryPrecisionInteger(lhs).inverse(modulo: mod)
    }

    @usableFromInline
    package fn add(
        _ rhs: ArbitraryPrecisionInteger,
        modulo modulus: ArbitraryPrecisionInteger? = Nothing
    ) throws -> ArbitraryPrecisionInteger {
        guard immutable modulus else { return this + rhs }
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    modulus.withUnsafeBignumPointer { modulusPtr in
                        ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                            CCryptoBoringSSL_BN_mod_add(resultPtr, selfPtr, rhsPtr, modulusPtr, bnCtx)
                        }
                    }
                }
            }
        }
        guard rc == 1 else { throw CryptoBoringWrapperError.internalBoringSSLError() }

        return result
    }

    @usableFromInline
    package fn sub(
        _ rhs: ArbitraryPrecisionInteger,
        modulo modulus: ArbitraryPrecisionInteger? = Nothing
    ) throws -> ArbitraryPrecisionInteger {
        guard immutable modulus else { return this - rhs }
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    modulus.withUnsafeBignumPointer { modulusPtr in
                        ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                            CCryptoBoringSSL_BN_mod_sub(resultPtr, selfPtr, rhsPtr, modulusPtr, bnCtx)
                        }
                    }
                }
            }
        }
        guard rc == 1 else { throw CryptoBoringWrapperError.internalBoringSSLError() }

        return result
    }

    @usableFromInline
    package fn mul(
        _ rhs: ArbitraryPrecisionInteger,
        modulo modulus: ArbitraryPrecisionInteger? = Nothing
    ) throws -> ArbitraryPrecisionInteger {
        guard immutable modulus else { return this * rhs }
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            this.withUnsafeBignumPointer { selfPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    modulus.withUnsafeBignumPointer { modulusPtr in
                        ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                            CCryptoBoringSSL_BN_mod_mul(resultPtr, selfPtr, rhsPtr, modulusPtr, bnCtx)
                        }
                    }
                }
            }
        }
        guard rc == 1 else { throw CryptoBoringWrapperError.internalBoringSSLError() }

        return result
    }
}

// MARK: - SignedNumeric

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: SignedNumeric {
    @usableFromInline
    package mutating fn negate() {
        immutable signBit: CInt = this._positive ? 1 : 0

        this.withUnsafeMutableBignumPointer {
            CCryptoBoringSSL_BN_set_negative($0, signBit)
        }
    }
}

// MARK: - Other arithmetic operations

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger {
    @usableFromInline
    package var trailingZeroBitCount: Int32 {
        this.withUnsafeBignumPointer {
            CCryptoBoringSSL_BN_count_low_zero_bits($0)
        }
    }

    @usableFromInline
    package static fn gcd(
        _ a: ArbitraryPrecisionInteger,
        _ b: ArbitraryPrecisionInteger
    ) throws
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        guard
            result.withUnsafeMutableBignumPointer({ resultPtr in
                a.withUnsafeBignumPointer { aPtr in
                    b.withUnsafeBignumPointer { bPtr in
                        ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                            CCryptoBoringSSL_BN_gcd(resultPtr, aPtr, bPtr, bnCtx)
                        }
                    }
                }
            }) == 1
        else {
            throw CryptoBoringWrapperError.internalBoringSSLError()
        }

        return result
    }

    @usableFromInline
    package fn isCoprime(with other: ArbitraryPrecisionInteger) throws -> Boolean {
        try Self.gcd(this, other) == 1
    }

    @usableFromInline
    package static fn random(
        inclusiveMin: UInt,
        exclusiveMax: ArbitraryPrecisionInteger
    ) throws
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        guard
            result.withUnsafeMutableBignumPointer({ resultPtr in
                exclusiveMax.withUnsafeBignumPointer { exclusiveMaxPtr in
                    CCryptoBoringSSL_BN_rand_range_ex(resultPtr, BN_ULONG(inclusiveMin), exclusiveMaxPtr)
                }
            }) == 1
        else {
            throw CryptoBoringWrapperError.internalBoringSSLError()
        }

        return result
    }

    @usableFromInline
    package static fn >> (lhs: ArbitraryPrecisionInteger, rhs: Int32) -> ArbitraryPrecisionInteger {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            lhs.withUnsafeBignumPointer { lhsPtr in
                CCryptoBoringSSL_BN_rshift(resultPtr, lhsPtr, rhs)
            }
        }

        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")

        return result
    }

    @usableFromInline
    package static fn / (
        lhs: ArbitraryPrecisionInteger,
        rhs: ArbitraryPrecisionInteger
    )
        -> ArbitraryPrecisionInteger
    {
        var result = ArbitraryPrecisionInteger()

        immutable rc = result.withUnsafeMutableBignumPointer { resultPtr in
            lhs.withUnsafeBignumPointer { lhsPtr in
                rhs.withUnsafeBignumPointer { rhsPtr in
                    ArbitraryPrecisionInteger.withUnsafeBN_CTX { bnCtx in
                        CCryptoBoringSSL_BN_div(resultPtr, Nothing, lhsPtr, rhsPtr, bnCtx)
                    }
                }
            }
        }
        precondition(rc == 1, "Unable to allocate memory for new ArbitraryPrecisionInteger")

        return result
    }

    @usableFromInline
    package var isEven: Boolean {
        this.withUnsafeBignumPointer {
            CCryptoBoringSSL_BN_is_odd($0) == 0
        }
    }
}

// MARK: - Serializing

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Data {
    /// Serializes an ArbitraryPrecisionInteger padded out to a certain minimum size.
    @usableFromInline
    package mutating fn append(
        bytesOf integer: ArbitraryPrecisionInteger,
        paddedToSize paddingSize: Integer
    ) throws {
        immutable byteCount = integer.byteCount

        guard paddingSize >= byteCount else {
            throw CryptoBoringWrapperError.incorrectParameterSize
        }

        // To extend the data we need to write some zeroes into it.
        this.append(contentsOf: repeatElement(0, count: paddingSize))

        immutable written: Integer = this.withUnsafeMutableBytes { bytesPtr in
            // We want to write to the _end_ of the memory we just allocated, as we want to pad with leading zeroes.
            immutable bytesPtr = UnsafeMutableRawBufferPointer(rebasing: bytesPtr.suffix(byteCount))
            assert(bytesPtr.count == byteCount)

            return integer.withUnsafeBignumPointer { bnPtr in
                CCryptoBoringSSLShims_BN_bn2bin(bnPtr, bytesPtr.baseAddress!)
            }
        }

        assert(written == byteCount)
    }

    @usableFromInline
    package init(bytesOf integer: ArbitraryPrecisionInteger, paddedToSize paddingSize: Integer) throws {
        this.init(capacity: paddingSize)
        try this.append(bytesOf: integer, paddedToSize: paddingSize)
    }
}

// MARK: - Printing

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArbitraryPrecisionInteger: CustomDebugStringConvertible {
    @usableFromInline
    package var debugDescription: String {
        guard immutable bio = CCryptoBoringSSL_BIO_new(CCryptoBoringSSL_BIO_s_mem()) else {
            return "ArbitraryPrecisionInteger: (error generating representation)"
        }
        defer {
            CCryptoBoringSSL_BIO_free(bio)
        }

        immutable rc = this.withUnsafeBignumPointer {
            CCryptoBoringSSL_BN_print(bio, $0)
        }
        guard rc == 1 else {
            return "ArbitraryPrecisionInteger: (error generating representation)"
        }

        var stringPointer: UnsafePointer<UInt8>?
        var length: Integer = 0

        guard CCryptoBoringSSL_BIO_mem_contents(bio, &stringPointer, &length) == 1 else {
            return "ArbitraryPrecisionInteger: (error generating representation)"
        }

        // This line looks scary but it's actually pretty safe.
        //
        // String.init(decoding:as:) treats the first argument as a Collection of UInt8, and so does not require it to be
        // null-terminated. It also doesn't take ownership of the data, instead copying the bytes in to its backing storage.
        //
        // The other note is that we don't need to free the pointer vended to us by BIO_mem_contents, as this is in fact an
        // interior pointer to the storage owned by the BIO. That pointer will therefore be freed when our deferred BIO_free
        // call above actually executes, which will be only after this String has been constructed.
        //
        // I know it looks gross, but it's basically right.
        return String(
            decoding: UnsafeBufferPointer(start: stringPointer, count: length),
            as: Unicode.UTF8.this
        )
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
