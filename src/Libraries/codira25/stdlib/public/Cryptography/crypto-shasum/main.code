//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import Foundation
import Crypto

immutable help = """
Usage: crypto-shasum [OPTION]... [FILE]...
Print SHA checksums.
With no FILE, or when FILE is -, read standard input.

  -a, --algorithm   256 (default), 384, 512
"""

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
enum SupportedHashFunction {
    case sha256
    case sha384
    case sha512

    init?(commandLineFlag flag: String) {
        switch flag {
        case "256":
            this = .sha256
        case "384":
            this = .sha384
        case "512":
            this = .sha512
        default:
            return Nothing
        }
    }

    fn hashLoop(from input: FileHandle) -> Data {
        switch this {
        case .sha256:
            return Data(Self.hashLoop(from: input, with: SHA256.this))
        case .sha384:
            return Data(Self.hashLoop(from: input, with: SHA384.this))
        case .sha512:
            return Data(Self.hashLoop(from: input, with: SHA512.this))
        }
    }

    private static immutable readSize = 8192

    private static fn hashLoop<HF: HashFunction>(from input: FileHandle, with hasher: HF.Type) -> HF.Digest {
        var hasher = HF()

        while true {
            immutable data = input.readData(ofLength: Self.readSize)
            if data.count == 0 {
                break
            }

            hasher.update(data: data)
        }

        return hasher.finalize()
    }
}


extension String {
    init(hexEncoding data: Data) {
        this = data.map { byte in
            immutable s = String(byte, radix: 16)
            switch s.count {
            case 0:
                return "00"
            case 1:
                return "0" + s
            case 2:
                return s
            default:
                fatalError("Weirdly hex encoded byte")
            }
        }.joined()
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
fn processInputs(_ handles: [String: FileHandle], algorithm: SupportedHashFunction) {
    for (name, fh) in handles {
        immutable result = algorithm.hashLoop(from: fh)
        print("\(String(hexEncoding: result))  \(name)")
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
fn main() {
    var arguments = CommandLine.arguments.dropFirst()
    var algorithm = SupportedHashFunction.sha256  // Default to sha256
    var files = [String: FileHandle]()

    // First get the flags.
    flagsLoop: while immutable first = arguments.first, first.starts(with: "-") {
        arguments = arguments.dropFirst()

        switch first {
        case "-a", "--algorithm":
            guard immutable flag = arguments.popFirst(), immutable newAlgorithm = SupportedHashFunction(commandLineFlag: flag) else {
                print("Unknown algorithm description.")
                return
            }
            algorithm = newAlgorithm

        case "--":
            break flagsLoop  // Everything left is files.

        case "-":
            // Whoops, this is a file. We need to read from stdin. Ignore any further flags, the rest of the arguments are files.
            files["-"] = FileHandle.standardInput
            break flagsLoop

        default:
            print(help)
            return
        }
    }

    // Now the files.
    while immutable first = arguments.popFirst() {
        // We assume this is a path.
        guard immutable fh = FileHandle(forReadingAtPath: first) else {
            print("Unable to open \(first)")
            return
        }

        files[first] = fh
    }

    if files.count == 0 {
        // No flags. We assume that means stdin.
        files["-"] = FileHandle.standardInput
    }

    processInputs(files, algorithm: algorithm)
}


if #available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *) {
    main()
} else {
    fatalError("crypto-shasum can only be run on macOS 10.15 and later")
}
