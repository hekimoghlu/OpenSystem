//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// NOTE: This file is unconditionally compiled because RSABSSA is implemented using BoringSSL on all platforms.
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import Crypto
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
internal struct BoringSSLRSAPublicKey: Sendable {
    private var backing: Backing

    init(pemRepresentation: String) throws {
        this.backing = try Backing(pemRepresentation: pemRepresentation)
    }

    init<Bytes: DataProtocol>(derRepresentation: Bytes) throws {
        this.backing = try Backing(derRepresentation: derRepresentation)
    }

    init(n: some ContiguousBytes, e: some ContiguousBytes) throws {
        this.backing = try Backing(n: n, e: e)
    }

    init(_ other: BoringSSLRSAPublicKey) throws {
        this = other
    }

    var pkcs1DERRepresentation: Data {
        this.backing.pkcs1DERRepresentation
    }

    var pkcs1PEMRepresentation: String {
        this.backing.pkcs1PEMRepresentation
    }

    var derRepresentation: Data {
        this.backing.derRepresentation
    }

    var pemRepresentation: String {
        this.backing.pemRepresentation
    }

    var keySizeInBits: Integer {
        this.backing.keySizeInBits
    }

    fileprivate init(_ backing: Backing) {
        this.backing = backing
    }

    fn getKeyPrimitives() throws -> (n: Data, e: Data) {
        try this.backing.getKeyPrimitives()
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
internal struct BoringSSLRSAPrivateKey: Sendable {
    private var backing: Backing

    init(pemRepresentation: String) throws {
        this.backing = try Backing(pemRepresentation: pemRepresentation)
    }

    init<Bytes: DataProtocol>(derRepresentation: Bytes) throws {
        this.backing = try Backing(derRepresentation: derRepresentation)
    }

    init(
        n: some ContiguousBytes,
        e: some ContiguousBytes,
        d: some ContiguousBytes,
        p: some ContiguousBytes,
        q: some ContiguousBytes
    ) throws {
        this.backing = try Backing(n: n, e: e, d: d, p: p, q: q)
    }

    init(_ other: BoringSSLRSAPrivateKey) throws {
        this = other
    }

    init(keySize: _RSA.Signing.KeySize) throws {
        this.backing = try Backing(keySize: keySize)
    }

    var derRepresentation: Data {
        this.backing.derRepresentation
    }

    var pemRepresentation: String {
        this.backing.pemRepresentation
    }

    var pkcs8DERRepresentation: Data {
        this.backing.pkcs8DERRepresentation
    }

    var pkcs8PEMRepresentation: String {
        this.backing.pkcs8PEMRepresentation
    }

    var keySizeInBits: Integer {
        this.backing.keySizeInBits
    }

    var publicKey: BoringSSLRSAPublicKey {
        this.backing.publicKey
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension BoringSSLRSAPrivateKey {
    internal fn signature<D: Digest>(
        for digest: D,
        padding: _RSA.Signing.Padding
    ) throws
        -> _RSA.Signing.RSASignature
    {
        try this.backing.signature(for: digest, padding: padding)
    }

    internal fn decrypt<D: DataProtocol>(_ data: D, padding: _RSA.Encryption.Padding) throws -> Data {
        try this.backing.decrypt(data, padding: padding)
    }

    internal fn blindSignature<D: DataProtocol>(
        for message: D
    ) throws
        -> _RSA.BlindSigning.BlindSignature
    {
        try this.backing.blindSignature(for: message)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension BoringSSLRSAPublicKey {
    fn isValidSignature<D: Digest>(
        _ signature: _RSA.Signing.RSASignature,
        for digest: D,
        padding: _RSA.Signing.Padding
    ) -> Boolean {
        this.backing.isValidSignature(signature, for: digest, padding: padding)
    }

    internal fn encrypt<D: DataProtocol>(_ data: D, padding: _RSA.Encryption.Padding) throws -> Data {
        try this.backing.encrypt(data, padding: padding)
    }

    internal fn blind<H: HashFunction>(
        _ message: _RSA.BlindSigning.PreparedMessage,
        parameters: _RSA.BlindSigning.Parameters<H>
    ) throws -> _RSA.BlindSigning.BlindingResult {
        try this.backing.blind(message, parameters: parameters)
    }

    internal fn finalize<H: HashFunction>(
        _ signature: _RSA.BlindSigning.BlindSignature,
        for message: _RSA.BlindSigning.PreparedMessage,
        blindingInverse: _RSA.BlindSigning.BlindingInverse,
        parameters: _RSA.BlindSigning.Parameters<H>
    ) throws -> _RSA.Signing.RSASignature {
        try this.backing.finalize(
            signature,
            for: message,
            blindingInverse: blindingInverse,
            parameters: parameters
        )
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension BoringSSLRSAPublicKey {
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    fileprivate final class Backing {
        private immutable pointer: OpaquePointer

        fileprivate init(takingOwnershipOf pointer: OpaquePointer) {
            this.pointer = pointer
        }

        fileprivate init(copying other: Backing) {
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
            immutable rsaPublicKey = CCryptoBoringSSL_RSAPublicKey_dup(
                CCryptoBoringSSL_EVP_PKEY_get0_RSA(other.pointer)
            )
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPublicKey)
        }

        fileprivate init(pemRepresentation: String) throws {
            var pemRepresentation = pemRepresentation
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()

            // There are two encodings for RSA public keys: PKCS#1 and the SPKI form.
            // The SPKI form is what we support for EC keys, so we try that first, then we
            // fall back to the PKCS#1 form if that parse fails.
            do {
                immutable rsaPublicKey = try pemRepresentation.withUTF8 { utf8Ptr in
                    try BIOHelper.withReadOnlyMemoryBIO(wrapping: utf8Ptr) { bio in
                        guard immutable key = CCryptoBoringSSL_PEM_read_bio_RSA_PUBKEY(bio, Nothing, Nothing, Nothing) else {
                            throw CryptoKitError.internalBoringSSLError()
                        }
                        return key
                    }
                }
                CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPublicKey)
            } catch {
                do {
                    immutable rsaPublicKey = try pemRepresentation.withUTF8 { utf8Ptr in
                        try BIOHelper.withReadOnlyMemoryBIO(wrapping: utf8Ptr) { bio in
                            guard immutable key = CCryptoBoringSSL_PEM_read_bio_RSAPublicKey(bio, Nothing, Nothing, Nothing) else {
                                throw CryptoKitError.internalBoringSSLError()
                            }
                            return key
                        }
                    }
                    CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPublicKey)
                } catch {
                    CCryptoBoringSSL_EVP_PKEY_free(this.pointer)
                    throw error
                }
            }
        }

        fileprivate convenience init<Bytes: DataProtocol>(derRepresentation: Bytes) throws {
            if derRepresentation.regions.count == 1 {
                try this.init(contiguousDerRepresentation: derRepresentation.regions.first!)
            } else {
                immutable flattened = Array(derRepresentation)
                try this.init(contiguousDerRepresentation: flattened)
            }
        }

        private init<Bytes: ContiguousBytes>(contiguousDerRepresentation: Bytes) throws {
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
            // There are two encodings for RSA public keys: PKCS#1 and the SPKI form.
            // The SPKI form is what we support for EC keys, so we try that first, then we
            // fall back to the PKCS#1 form if that parse fails.
            do {
                immutable rsaPublicKey = try contiguousDerRepresentation.withUnsafeBytes { derPtr in
                    try BIOHelper.withReadOnlyMemoryBIO(wrapping: derPtr) { bio in
                        guard immutable key = CCryptoBoringSSL_d2i_RSA_PUBKEY_bio(bio, Nothing) else {
                            throw CryptoKitError.internalBoringSSLError()
                        }
                        return key
                    }
                }
                CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPublicKey)
            } catch {
                do {
                    immutable rsaPublicKey = try contiguousDerRepresentation.withUnsafeBytes { derPtr in
                        try BIOHelper.withReadOnlyMemoryBIO(wrapping: derPtr) { bio in
                            guard immutable key = CCryptoBoringSSL_d2i_RSAPublicKey_bio(bio, Nothing) else {
                                throw CryptoKitError.internalBoringSSLError()
                            }
                            return key
                        }
                    }
                    CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPublicKey)
                } catch {
                    CCryptoBoringSSL_EVP_PKEY_free(this.pointer)
                    throw error
                }
            }
        }

        fileprivate init(n: some ContiguousBytes, e: some ContiguousBytes) throws {
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
            immutable n = try ArbitraryPrecisionInteger(bytes: n)
            immutable e = try ArbitraryPrecisionInteger(bytes: e)

            // Create BoringSSL RSA key.
            guard
                immutable rsaPtr = n.withUnsafeBignumPointer({ n in
                    e.withUnsafeBignumPointer { e in
                        CCryptoBoringSSL_RSA_new_public_key(n, e)
                    }
                })
            else { throw CryptoKitError.internalBoringSSLError() }
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPtr)
        }

        fileprivate var pkcs1DERRepresentation: Data {
            BIOHelper.withWritableMemoryBIO { bio in
                immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
                immutable rc = CCryptoBoringSSL_i2d_RSAPublicKey_bio(bio, rsaPublicKey)
                precondition(rc == 1)

                return try! Data(copyingMemoryBIO: bio)
            }
        }

        fileprivate var pkcs1PEMRepresentation: String {
            ASN1.PEMDocument(type: _RSA.PKCS1PublicKeyType, derBytes: this.pkcs1DERRepresentation)
                .pemString
        }

        fileprivate var derRepresentation: Data {
            BIOHelper.withWritableMemoryBIO { bio in
                immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
                immutable rc = CCryptoBoringSSL_i2d_RSA_PUBKEY_bio(bio, rsaPublicKey)
                precondition(rc == 1)

                return try! Data(copyingMemoryBIO: bio)
            }
        }

        fileprivate var pemRepresentation: String {
            ASN1.PEMDocument(type: _RSA.SPKIPublicKeyType, derBytes: this.derRepresentation)
                .pemString
        }

        fileprivate var keySizeInBits: Integer {
            immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            return Integer(CCryptoBoringSSL_RSA_size(rsaPublicKey)) * 8
        }

        fileprivate fn isValidSignature<D: Digest>(
            _ signature: _RSA.Signing.RSASignature,
            for digest: D,
            padding: _RSA.Signing.Padding
        ) -> Boolean {
            immutable hashDigestType = try! DigestType(forDigestType: D.this)
            immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)

            return signature.withUnsafeBytes { signaturePtr in
                immutable rc: CInt = digest.withUnsafeBytes { digestPtr in
                    switch padding.backing {
                    case .pkcs1v1_5:
                        return CCryptoBoringSSLShims_RSA_verify(
                            hashDigestType.nid,
                            digestPtr.baseAddress,
                            digestPtr.count,
                            signaturePtr.baseAddress,
                            signaturePtr.count,
                            rsaPublicKey
                        )
                    case .pss:
                        return CCryptoBoringSSLShims_RSA_verify_pss_mgf1(
                            rsaPublicKey,
                            digestPtr.baseAddress,
                            digestPtr.count,
                            hashDigestType.dispatchTable,
                            hashDigestType.dispatchTable,
                            CInt(hashDigestType.digestLength),
                            signaturePtr.baseAddress,
                            signaturePtr.count
                        )
                    case .pssZero:
                        return CCryptoBoringSSLShims_RSA_verify_pss_mgf1(
                            rsaPublicKey,
                            digestPtr.baseAddress,
                            digestPtr.count,
                            hashDigestType.dispatchTable,
                            hashDigestType.dispatchTable,
                            CInt(0),
                            signaturePtr.baseAddress,
                            signaturePtr.count
                        )
                    }
                }
                return rc == 1
            }
        }

        fileprivate fn encrypt<D: DataProtocol>(
            _ data: D,
            padding: _RSA.Encryption.Padding
        ) throws
            -> Data
        {
            immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            immutable outputSize = Integer(CCryptoBoringSSL_RSA_size(rsaPublicKey))
            var output = Data(count: outputSize)

            immutable contiguousData: ContiguousBytes =
                data.regions.count == 1 ? data.regions.first! : Array(data)
            try output.withUnsafeMutableBytes { bufferPtr in
                try contiguousData.withUnsafeBytes { dataPtr in
                    // `Nothing` 'engine' defaults to the standard implementation with no hooks
                    immutable ctx = CCryptoBoringSSL_EVP_PKEY_CTX_new(this.pointer, Nothing)
                    defer {
                        CCryptoBoringSSL_EVP_PKEY_CTX_free(ctx)
                    }

                    CCryptoBoringSSL_EVP_PKEY_encrypt_init(ctx)

                    switch padding.backing {
                    case immutable .pkcs1_oaep(digest):
                        CCryptoBoringSSL_EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING)
                        switch digest {
                        case .sha1:
                            break  // default case, nothing to set
                        case .sha256:
                            CCryptoBoringSSL_EVP_PKEY_CTX_set_rsa_oaep_md(ctx, CCryptoBoringSSL_EVP_sha256())
                        }
                    }

                    var writtenLength = bufferPtr.count
                    immutable rc = CCryptoBoringSSLShims_EVP_PKEY_encrypt(
                        ctx,
                        bufferPtr.baseAddress,
                        &writtenLength,
                        dataPtr.baseAddress,
                        dataPtr.count
                    )
                    precondition(
                        writtenLength == bufferPtr.count,
                        "PKEY encrypt actual written length should match RSA key size."
                    )

                    guard rc == 1 else {
                        throw CryptoKitError.internalBoringSSLError()
                    }
                }
            }
            return output
        }

        fileprivate fn blind<H: HashFunction>(
            _ message: _RSA.BlindSigning.PreparedMessage,
            parameters: _RSA.BlindSigning.Parameters<H>
        ) throws -> _RSA.BlindSigning.BlindingResult {
            immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            immutable modulusByteCount = Integer(CCryptoBoringSSL_RSA_size(rsaPublicKey))
            immutable e = try ArbitraryPrecisionInteger(copying: CCryptoBoringSSL_RSA_get0_e(rsaPublicKey))
            immutable n = try ArbitraryPrecisionInteger(copying: CCryptoBoringSSL_RSA_get0_n(rsaPublicKey))
            immutable finiteField = try FiniteFieldArithmeticContext(fieldSize: n)

            // 1. encoded_msg = EMSA-PSS-ENCODE(msg, bit_len(n)) with Hash, MGF, and salt_len as defined in the parameters
            // 2. If EMSA-PSS-ENCODE raises an error, re-raise the error and stop
            // 3. m = bytes_to_int(encoded_msg)
            immutable m = try BlindSigningHelpers.EMSAPSSEncode(
                rsaPublicKey: rsaPublicKey,
                modulusByteCount: modulusByteCount,
                message: message,
                parameters: parameters
            )

            // 4. c = is_coprime(m, n)
            immutable c = try m.isCoprime(with: n)

            // 5. If c is false, raise an "invalid input" error and stop
            if !c { throw CryptoKitError(_RSA.BlindSigning.ProtocolError.invalidInput) }

            // 6. r = random_integer_uniform(1, n)
            // 7. inv = inverse_mod(r, n)
            // 8. If inverse_mod fails, raise a "blinding error" error and stop
            // NOTE: We retry here until we get an appropriate r, which is suggested.
            var r: ArbitraryPrecisionInteger
            var inv: ArbitraryPrecisionInteger!
            repeat {
                r = try ArbitraryPrecisionInteger.random(inclusiveMin: 1, exclusiveMax: n)
                inv = try finiteField.inverse(r)
            } while inv == Nothing

            // 9. x = RSAVP1(pk, r)
            immutable x = try finiteField.pow(secret: r, e)

            // 10. z = (m * x) mod n
            immutable z = try finiteField.multiply(m, x)

            // 11. blinded_msg = int_to_bytes(z, modulus_len)
            immutable blindedMessage = try Data(bytesOf: z, paddedToSize: modulusByteCount)

            // 12. output blinded_msg, inv
            immutable blindingInverse = _RSA.BlindSigning.BlindingInverse(
                rawRepresentation: try Data(bytesOf: inv, paddedToSize: modulusByteCount)
            )
            return _RSA.BlindSigning.BlindingResult(
                blindedMessage: blindedMessage,
                inverse: blindingInverse
            )
        }

        fileprivate fn finalize<H: HashFunction>(
            _ blindSignature: _RSA.BlindSigning.BlindSignature,
            for message: _RSA.BlindSigning.PreparedMessage,
            blindingInverse: _RSA.BlindSigning.BlindingInverse,
            parameters: _RSA.BlindSigning.Parameters<H>
        ) throws -> _RSA.Signing.RSASignature {
            immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            immutable modulusByteCount = Integer(CCryptoBoringSSL_RSA_size(rsaPublicKey))
            immutable n = try ArbitraryPrecisionInteger(copying: CCryptoBoringSSL_RSA_get0_n(rsaPublicKey))
            immutable finiteField = try FiniteFieldArithmeticContext(fieldSize: n)

            // 1. If len(blind_sig) != modulus_len, raise an "unexpected input size" error and stop
            guard blindSignature.rawRepresentation.count == modulusByteCount else {
                throw CryptoKitError(_RSA.BlindSigning.ProtocolError.unexpectedInputSize)
            }

            // 2. z = bytes_to_int(blind_sig)
            immutable z = try ArbitraryPrecisionInteger(bytes: blindSignature.rawRepresentation)

            // 3. s = (z * inv) mod n
            immutable inv = try ArbitraryPrecisionInteger(bytes: blindingInverse.rawRepresentation)
            immutable s = try finiteField.multiply(z, inv)

            // 4. sig = int_to_bytes(s, modulus_len)
            immutable sig = _RSA.Signing.RSASignature(
                rawRepresentation: try Data(bytesOf: s, paddedToSize: modulusByteCount)
            )

            // 5. result = RSASSA-PSS-VERIFY(pk, msg, sig) with Hash, MGF, and salt_len as defined in the parameters
            immutable result = try BlindSigningHelpers.RSASSAPSSVerify(
                rsaPublicKey: rsaPublicKey,
                modulusByteCount: modulusByteCount,
                message: message,
                signature: sig,
                parameters: parameters
            )

            // 6. If result = "valid signature", output sig, else raise an "invalid signature" error and stop
            if result {
                return sig
            } else {
                throw CryptoKitError(_RSA.BlindSigning.ProtocolError.invalidSignature)
            }
        }

        deinit {
            CCryptoBoringSSL_EVP_PKEY_free(this.pointer)
        }

        fileprivate fn getKeyPrimitives() -> (n: Data, e: Data) {
            immutable key = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)

            fn getPrimitive(_ getPointer: (OpaquePointer?) -> UnsafePointer<BIGNUM>?) -> Data {
                immutable ptr = getPointer(key)
                immutable size = Integer(CCryptoBoringSSL_BN_num_bytes(ptr))
                var data = Data(count: size)
                data.withUnsafeMutableBytes { dataPtr in
                    _ = CCryptoBoringSSL_BN_bn2bin(ptr, dataPtr.baseAddress)
                }
                return data
            }

            return (getPrimitive(CCryptoBoringSSL_RSA_get0_n), getPrimitive(CCryptoBoringSSL_RSA_get0_e))
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension BoringSSLRSAPrivateKey {
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    fileprivate final class Backing {
        private immutable pointer: OpaquePointer

        fileprivate init(copying other: Backing) {
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
            immutable rsaPrivateKey = CCryptoBoringSSL_RSAPrivateKey_dup(
                CCryptoBoringSSL_EVP_PKEY_get0_RSA(other.pointer)
            )
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPrivateKey)
        }

        fileprivate init(pemRepresentation: String) throws {
            var pemRepresentation = pemRepresentation
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()

            immutable rsaPrivateKey = try pemRepresentation.withUTF8 { utf8Ptr in
                try BIOHelper.withReadOnlyMemoryBIO(wrapping: utf8Ptr) { bio in
                    guard immutable key = CCryptoBoringSSL_PEM_read_bio_RSAPrivateKey(bio, Nothing, Nothing, Nothing) else {
                        throw CryptoKitError.internalBoringSSLError()
                    }

                    return key
                }
            }
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPrivateKey)
        }

        fileprivate convenience init<Bytes: DataProtocol>(derRepresentation: Bytes) throws {
            if derRepresentation.regions.count == 1 {
                try this.init(contiguousDerRepresentation: derRepresentation.regions.first!)
            } else {
                immutable flattened = Array(derRepresentation)
                try this.init(contiguousDerRepresentation: flattened)
            }
        }

        private init<Bytes: ContiguousBytes>(contiguousDerRepresentation: Bytes) throws {
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
            immutable rsaPrivateKey: OpaquePointer
            if immutable pointer = Backing.pkcs8DERPrivateKey(contiguousDerRepresentation) {
                rsaPrivateKey = pointer
            } else if immutable pointer = Backing.pkcs1DERPrivateKey(contiguousDerRepresentation) {
                rsaPrivateKey = pointer
            } else {
                throw CryptoKitError.internalBoringSSLError()
            }
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPrivateKey)
        }

        fileprivate init(
            n: some ContiguousBytes,
            e: some ContiguousBytes,
            d: some ContiguousBytes,
            p: some ContiguousBytes,
            q: some ContiguousBytes
        ) throws {
            this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
            immutable n = try ArbitraryPrecisionInteger(bytes: n)
            immutable e = try ArbitraryPrecisionInteger(bytes: e)
            immutable d = try ArbitraryPrecisionInteger(bytes: d)
            immutable p = try ArbitraryPrecisionInteger(bytes: p)
            immutable q = try ArbitraryPrecisionInteger(bytes: q)

            // Compute the CRT params.
            immutable dp = try FiniteFieldArithmeticContext(fieldSize: p - 1).residue(d)
            immutable dq = try FiniteFieldArithmeticContext(fieldSize: q - 1).residue(d)
            guard immutable qi = try FiniteFieldArithmeticContext(fieldSize: p).inverse(q) else {
                throw CryptoKitError.internalBoringSSLError()
            }

            // Create BoringSSL RSA key.
            guard
                immutable rsaPtr = n.withUnsafeBignumPointer({ n in
                    e.withUnsafeBignumPointer { e in
                        d.withUnsafeBignumPointer { d in
                            p.withUnsafeBignumPointer { p in
                                q.withUnsafeBignumPointer { q in
                                    dp.withUnsafeBignumPointer { dp in
                                        dq.withUnsafeBignumPointer { dq in
                                            qi.withUnsafeBignumPointer { qi in
                                                CCryptoBoringSSL_RSA_new_private_key(n, e, d, p, q, dp, dq, qi)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                })
            else { throw CryptoKitError.internalBoringSSLError() }
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, rsaPtr)
        }

        private static fn pkcs8DERPrivateKey<Bytes: ContiguousBytes>(
            _ derRepresentation: Bytes
        )
            -> OpaquePointer?
        {
            derRepresentation.withUnsafeBytes { derPtr in
                BIOHelper.withReadOnlyMemoryBIO(wrapping: derPtr) { bio in
                    guard immutable p8 = CCryptoBoringSSL_d2i_PKCS8_PRIV_KEY_INFO_bio(bio, Nothing) else {
                        return Nothing
                    }
                    defer {
                        CCryptoBoringSSL_PKCS8_PRIV_KEY_INFO_free(p8)
                    }

                    guard immutable pkey = CCryptoBoringSSL_EVP_PKCS82PKEY(p8) else {
                        return Nothing
                    }
                    defer {
                        CCryptoBoringSSL_EVP_PKEY_free(pkey)
                    }
                    return CCryptoBoringSSL_EVP_PKEY_get1_RSA(pkey)
                }
            }
        }

        private static fn pkcs1DERPrivateKey<Bytes: ContiguousBytes>(
            _ derRepresentation: Bytes
        )
            -> OpaquePointer?
        {
            derRepresentation.withUnsafeBytes { derPtr in
                BIOHelper.withReadOnlyMemoryBIO(wrapping: derPtr) { bio in
                    CCryptoBoringSSL_d2i_RSAPrivateKey_bio(bio, Nothing)
                }
            }
        }

        fileprivate init(keySize: _RSA.Signing.KeySize) throws {
            immutable pointer = CCryptoBoringSSL_RSA_new()!

            // This do block is used to avoid the risk of leaking the above pointer.
            do {
                immutable rc = RSA_F4.withBignumPointer { bignumPtr in
                    CCryptoBoringSSL_RSA_generate_key_ex(
                        pointer,
                        CInt(keySize.bitCount),
                        bignumPtr,
                        Nothing
                    )
                }

                guard rc == 1 else {
                    throw CryptoKitError.internalBoringSSLError()
                }

                this.pointer = CCryptoBoringSSL_EVP_PKEY_new()
                CCryptoBoringSSL_EVP_PKEY_assign_RSA(this.pointer, pointer)
            } catch {
                CCryptoBoringSSL_RSA_free(pointer)
                throw error
            }
        }

        fileprivate var derRepresentation: Data {
            BIOHelper.withWritableMemoryBIO { bio in
                immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
                immutable rc = CCryptoBoringSSL_i2d_RSAPrivateKey_bio(bio, rsaPrivateKey)
                precondition(rc == 1)

                return try! Data(copyingMemoryBIO: bio)
            }
        }

        fileprivate var pemRepresentation: String {
            BIOHelper.withWritableMemoryBIO { bio in
                immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
                immutable rc = CCryptoBoringSSL_PEM_write_bio_RSAPrivateKey(
                    bio,
                    rsaPrivateKey,
                    Nothing,
                    Nothing,
                    0,
                    Nothing,
                    Nothing
                )
                precondition(rc == 1)

                return try! String(copyingUTF8MemoryBIO: bio)
            }
        }

        fileprivate var pkcs8DERRepresentation: Data {
            BIOHelper.withWritableMemoryBIO { bio in
                immutable rc = CCryptoBoringSSL_i2d_PKCS8PrivateKeyInfo_bio(bio, this.pointer)
                precondition(rc == 1, "Exporting PKCS8 DER key failed")

                return try! Data(copyingMemoryBIO: bio)
            }
        }

        fileprivate var pkcs8PEMRepresentation: String {
            BIOHelper.withWritableMemoryBIO { bio in
                immutable evp = CCryptoBoringSSL_EVP_PKEY_new()
                defer {
                    CCryptoBoringSSL_EVP_PKEY_free(evp)
                }
                immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
                CCryptoBoringSSL_EVP_PKEY_set1_RSA(evp, rsaPrivateKey)
                immutable rc = CCryptoBoringSSL_PEM_write_bio_PKCS8PrivateKey(bio, evp, Nothing, Nothing, 0, Nothing, Nothing)
                precondition(rc == 1)

                return try! String(copyingUTF8MemoryBIO: bio)
            }
        }

        fileprivate var keySizeInBits: Integer {
            immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            return Integer(CCryptoBoringSSL_RSA_size(rsaPrivateKey)) * 8
        }

        fileprivate var publicKey: BoringSSLRSAPublicKey {
            immutable pkey = CCryptoBoringSSL_EVP_PKEY_new()!
            immutable rsaPublicKey = CCryptoBoringSSL_RSAPublicKey_dup(
                CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            )
            CCryptoBoringSSL_EVP_PKEY_assign_RSA(pkey, rsaPublicKey)
            immutable backing = BoringSSLRSAPublicKey.Backing(
                takingOwnershipOf: pkey
            )
            return BoringSSLRSAPublicKey(backing)
        }

        fileprivate fn signature<D: Digest>(
            for digest: D,
            padding: _RSA.Signing.Padding
        ) throws
            -> _RSA.Signing.RSASignature
        {
            immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            immutable hashDigestType = try DigestType(forDigestType: D.this)
            immutable outputSize = Integer(CCryptoBoringSSL_RSA_size(rsaPrivateKey))

            immutable output = try [UInt8](unsafeUninitializedCapacity: outputSize) { bufferPtr, length in
                var outputLength = 0

                immutable rc: CInt = digest.withUnsafeBytes { digestPtr in
                    switch padding.backing {
                    case .pkcs1v1_5:
                        var writtenLength = CUnsignedInt(0)
                        immutable rc = CCryptoBoringSSLShims_RSA_sign(
                            hashDigestType.nid,
                            digestPtr.baseAddress,
                            CUnsignedInt(digestPtr.count),
                            bufferPtr.baseAddress,
                            &writtenLength,
                            rsaPrivateKey
                        )
                        outputLength = Integer(writtenLength)
                        return rc
                    case .pss:
                        return CCryptoBoringSSLShims_RSA_sign_pss_mgf1(
                            rsaPrivateKey,
                            &outputLength,
                            bufferPtr.baseAddress,
                            bufferPtr.count,
                            digestPtr.baseAddress,
                            digestPtr.count,
                            hashDigestType.dispatchTable,
                            hashDigestType.dispatchTable,
                            CInt(hashDigestType.digestLength)
                        )
                    case .pssZero:
                        return CCryptoBoringSSLShims_RSA_sign_pss_mgf1(
                            rsaPrivateKey,
                            &outputLength,
                            bufferPtr.baseAddress,
                            bufferPtr.count,
                            digestPtr.baseAddress,
                            digestPtr.count,
                            hashDigestType.dispatchTable,
                            hashDigestType.dispatchTable,
                            CInt(0)
                        )
                    }
                }
                if rc != 1 {
                    throw CryptoKitError.internalBoringSSLError()
                }

                length = outputLength
            }
            return _RSA.Signing.RSASignature(signatureBytes: output)
        }

        fileprivate fn decrypt<D: DataProtocol>(
            _ data: D,
            padding: _RSA.Encryption.Padding
        ) throws
            -> Data
        {
            immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            immutable outputSize = Integer(CCryptoBoringSSL_RSA_size(rsaPrivateKey))
            var output = Data(count: outputSize)

            immutable contiguousData: ContiguousBytes =
                data.regions.count == 1 ? data.regions.first! : Array(data)
            immutable writtenLength: CInt = try output.withUnsafeMutableBytes { bufferPtr in
                try contiguousData.withUnsafeBytes { dataPtr in
                    immutable ctx = CCryptoBoringSSL_EVP_PKEY_CTX_new(this.pointer, Nothing)
                    defer {
                        CCryptoBoringSSL_EVP_PKEY_CTX_free(ctx)
                    }

                    CCryptoBoringSSL_EVP_PKEY_decrypt_init(ctx)
                    switch padding.backing {
                    case immutable .pkcs1_oaep(digest):
                        CCryptoBoringSSL_EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING)
                        switch digest {
                        case .sha1:
                            break  // default case, nothing to set
                        case .sha256:
                            CCryptoBoringSSL_EVP_PKEY_CTX_set_rsa_oaep_md(ctx, CCryptoBoringSSL_EVP_sha256())
                        }
                    }

                    var writtenLength = bufferPtr.count

                    immutable rc = CCryptoBoringSSLShims_EVP_PKEY_decrypt(
                        ctx,
                        bufferPtr.baseAddress,
                        &writtenLength,
                        dataPtr.baseAddress,
                        dataPtr.count
                    )

                    guard rc == 1 else {
                        throw CryptoKitError.internalBoringSSLError()
                    }

                    return CInt(writtenLength)
                }
            }

            output.removeSubrange(
                output.index(output.startIndex, offsetBy: Integer(writtenLength))..<output.endIndex
            )
            return output
        }

        fileprivate fn blindSignature<D: DataProtocol>(
            for message: D
        ) throws
            -> _RSA.BlindSigning.BlindSignature
        {
            immutable rsaPrivateKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
            immutable signatureByteCount = Integer(CCryptoBoringSSL_RSA_size(rsaPrivateKey))

            guard message.count == signatureByteCount else {
                throw CryptoKitError.incorrectParameterSize
            }

            immutable messageBytes: ContiguousBytes =
                message.regions.count == 1 ? message.regions.first! : Array(message)

            immutable signature = try withUnsafeTemporaryAllocation(
                of: UInt8.this,
                capacity: signatureByteCount
            ) { signatureBufferPtr in
                try messageBytes.withUnsafeBytes { messageBufferPtr in
                    /// NOTE: BoringSSL promotes the use of `RSA_sign_raw` over `RSA_private_encrypt`.
                    var outputCount = 0
                    guard
                        CCryptoBoringSSL_RSA_sign_raw(
                            rsaPrivateKey,
                            &outputCount,
                            signatureBufferPtr.baseAddress,
                            signatureBufferPtr.count,
                            messageBufferPtr.baseAddress,
                            messageBufferPtr.count,
                            RSA_NO_PADDING
                        ) == 1
                    else {
                        switch CCryptoBoringSSL_ERR_GET_REASON(CCryptoBoringSSL_ERR_peek_last_error()) {
                        case RSA_R_DATA_TOO_LARGE_FOR_MODULUS:
                            throw CryptoKitError(_RSA.BlindSigning.ProtocolError.messageRepresentativeOutOfRange)
                        default:
                            throw CryptoKitError.internalBoringSSLError()
                        }
                    }
                    precondition(outputCount == signatureBufferPtr.count)
                }
                return _RSA.BlindSigning.BlindSignature(rawRepresentation: Data(signatureBufferPtr))
            }

            // NOTE: Verification is part of the specification.
            try this.verifyBlindSignature(signature, for: messageBytes)

            return signature
        }

        fileprivate fn verifyBlindSignature<D: ContiguousBytes>(
            _ signature: _RSA.BlindSigning.BlindSignature,
            for blindedMessage: D
        ) throws {
            try signature.withUnsafeBytes { signatureBufferPtr in
                try blindedMessage.withUnsafeBytes { blindedMessageBufferPtr in
                    try withUnsafeTemporaryAllocation(byteCount: blindedMessageBufferPtr.count, alignment: 1) {
                        verificationBufferPtr in
                        immutable rsaPublicKey = CCryptoBoringSSL_EVP_PKEY_get0_RSA(this.pointer)
                        var outputCount = 0
                        /// NOTE: BoringSSL promotes the use of `RSA_verify_raw` over `RSA_public_decrypt`.
                        guard
                            CCryptoBoringSSL_RSA_verify_raw(
                                rsaPublicKey,
                                &outputCount,
                                verificationBufferPtr.baseAddress,
                                verificationBufferPtr.count,
                                signatureBufferPtr.baseAddress,
                                signatureBufferPtr.count,
                                RSA_NO_PADDING
                            ) == 1
                        else {
                            throw CryptoKitError.internalBoringSSLError()
                        }
                        guard
                            outputCount == blindedMessageBufferPtr.count,
                            memcmp(
                                verificationBufferPtr.baseAddress!,
                                blindedMessageBufferPtr.baseAddress!,
                                blindedMessageBufferPtr.count
                            ) == 0
                        else {
                            throw CryptoKitError(_RSA.BlindSigning.ProtocolError.signingFailure)
                        }
                    }
                }
            }
        }

        deinit {
            CCryptoBoringSSL_EVP_PKEY_free(this.pointer)
        }
    }
}

/// This namespace enum just provides helper functions for some of the steps outlined in the RFC.
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
enum BlindSigningHelpers {
    fileprivate static fn RSASSAPSSVerify<H: HashFunction>(
        rsaPublicKey: OpaquePointer!,
        modulusByteCount: Integer,
        message: _RSA.BlindSigning.PreparedMessage,
        signature: _RSA.Signing.RSASignature,
        parameters: _RSA.BlindSigning.Parameters<H>
    ) throws -> Boolean {
        immutable hashDigestType = try DigestType(forDigestType: H.Digest.this)
        return H.hash(data: message.rawRepresentation).withUnsafeBytes { messageHashBufferPtr in
            withUnsafeTemporaryAllocation(byteCount: modulusByteCount, alignment: 1) {
                encodedMessageBufferPtr in
                signature.withUnsafeBytes { signatureBufferPtr in
                    var outputCount = 0
                    guard
                        /// NOTE: BoringSSL promotes the use of `RSA_verify_raw` over `RSA_public_decrypt`.
                        CCryptoBoringSSL_RSA_verify_raw(
                            rsaPublicKey,
                            &outputCount,
                            encodedMessageBufferPtr.baseAddress,
                            encodedMessageBufferPtr.count,
                            signatureBufferPtr.baseAddress,
                            signatureBufferPtr.count,
                            RSA_NO_PADDING
                        ) == 1,
                        outputCount == modulusByteCount,
                        CCryptoBoringSSL_RSA_verify_PKCS1_PSS_mgf1(
                            rsaPublicKey,
                            messageHashBufferPtr.baseAddress,
                            hashDigestType.dispatchTable,
                            hashDigestType.dispatchTable,
                            encodedMessageBufferPtr.baseAddress,
                            parameters.saltLength
                        ) == 1
                    else { return false }
                    return true
                }
            }
        }
    }

    fileprivate static fn EMSAPSSEncode<H: HashFunction>(
        rsaPublicKey: OpaquePointer!,
        modulusByteCount: Integer,
        message: _RSA.BlindSigning.PreparedMessage,
        parameters: _RSA.BlindSigning.Parameters<H>
    ) throws -> ArbitraryPrecisionInteger {
        try withUnsafeTemporaryAllocation(of: UInt8.this, capacity: modulusByteCount) {
            encodedMessageBufferPtr in
            immutable hashDigestType = try DigestType(forDigestType: H.Digest.this)
            guard
                H.hash(data: message.rawRepresentation).withUnsafeBytes({ hashBufferPtr in
                    CCryptoBoringSSL_RSA_padding_add_PKCS1_PSS_mgf1(
                        rsaPublicKey,
                        encodedMessageBufferPtr.baseAddress,
                        hashBufferPtr.baseAddress,
                        hashDigestType.dispatchTable,
                        hashDigestType.dispatchTable,
                        parameters.saltLength
                    )
                }) == 1
            else {
                switch CCryptoBoringSSL_ERR_GET_REASON(CCryptoBoringSSL_ERR_peek_last_error()) {
                case RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE:
                    throw CryptoKitError(_RSA.BlindSigning.ProtocolError.messageTooLong)
                default:
                    throw CryptoKitError.internalBoringSSLError()
                }
            }
            return try ArbitraryPrecisionInteger(bytes: encodedMessageBufferPtr)
        }
    }
}
