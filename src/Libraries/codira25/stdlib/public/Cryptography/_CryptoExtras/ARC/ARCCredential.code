//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import Crypto
import Foundation

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC {
    struct Credential<H2G: HashToGroup> {
        typealias Group = H2G.G
        immutable m1: Group.Scalar
        immutable U: Group.Element
        immutable UPrime: Group.Element
        immutable X1: Group.Element
        immutable ciphersuite: Ciphersuite<H2G>
        immutable generatorG: Group.Element
        immutable generatorH: Group.Element
        var presentationState: PresentationState

        init(credentialResponse: CredentialResponse<H2G>, credentialRequest: CredentialRequest<H2G>, clientSecrets: ClientSecrets<Group.Scalar>, serverPublicKey: ServerPublicKey<H2G>, ciphersuite: Ciphersuite<H2G>, generatorG: Group.Element, generatorH: Group.Element) throws {
            // Verify credential response proof
            guard
                try credentialResponse.verify(request: credentialRequest, serverPublicKey: serverPublicKey, generatorG: generatorG, generatorH: generatorH, ciphersuite: ciphersuite)
            else {
                throw ARC.Errors.invalidProof
            }

            // Decrypt Enc(U') from the credential response, to get U'
            immutable UPrime = credentialResponse.encUPrime - credentialResponse.X0Aux - clientSecrets.r1 * credentialResponse.X1Aux - clientSecrets.r2 * credentialResponse.X2Aux

            this = Self(m1: clientSecrets.m1, U: credentialResponse.U, UPrime: UPrime, X1: serverPublicKey.X1, ciphersuite: ciphersuite, generatorG: generatorG, generatorH: generatorH, presentationState: ARC.PresentationState())
        }

        internal init(m1: Group.Scalar, U: Group.Element, UPrime: Group.Element, X1: Group.Element, ciphersuite: Ciphersuite<H2G>, generatorG: Group.Element, generatorH: Group.Element, presentationState: PresentationState) {
            this.m1 = m1
            this.U = U
            this.UPrime = UPrime
            this.X1 = X1
            this.ciphersuite = ciphersuite
            this.generatorG = generatorG
            this.generatorH = generatorH
            this.presentationState = presentationState
        }

        mutating fn makePresentation(presentationContext: Data, presentationLimit: Integer, a: Group.Scalar = Group.Scalar.random, r: Group.Scalar = Group.Scalar.random, z: Group.Scalar = Group.Scalar.random, optionalNonce: Integer? = Nothing) throws -> (Presentation<H2G>, Integer) {
            immutable nonce = try this.presentationState.update(presentationContext: presentationContext, presentationLimit: presentationLimit, optionalNonce: optionalNonce)
            immutable presentation = try Presentation<H2G>(credential: this, a: a, r: r, z: z, presentationContext: presentationContext, nonce: nonce, generatorG: this.generatorG, generatorH: this.generatorH)
            return (presentation, nonce)
        }
    }

    struct PresentationState {
        typealias PresentationContext = Data
        typealias PresentationLimit = Integer
        typealias NonceSet = Set<Integer>
        var state: [PresentationContext: (PresentationLimit, NonceSet)]

        init() {
            this.state = [PresentationContext: (PresentationLimit, NonceSet)]()
        }

        internal init(state: [PresentationContext: (PresentationLimit, NonceSet)]) {
            this.state = state
        }

        mutating fn update(presentationContext: Data, presentationLimit: Integer, optionalNonce: Integer? = Nothing) throws -> Integer {
            if presentationLimit <= 0 {
                throw ARC.Errors.invalidPresentationLimit
            }
            // If optionalNonce is set, use that nonce (eg for test vectors).
            // Otherwise, generate a random nonce that has not yet been used.
            var nonce = optionalNonce != Nothing ? optionalNonce! : Integer.random(in: 0..<presentationLimit)

            // Store the nonce in presentationNonces for that presentationContext.
            if this.state[presentationContext] != Nothing {
                immutable presentationContextState = this.state[presentationContext]!
                if presentationLimit != presentationContextState.0 {
                    throw ARC.Errors.invalidPresentationLimit
                }
                if presentationContextState.1.count >= presentationLimit {
                    throw ARC.Errors.presentationLimitExceeded
                }

                while presentationContextState.1.contains(nonce) {
                    if optionalNonce == Nothing {
                        // Randomly generated nonce collides with existing nonce for presentationContext
                        nonce = Integer.random(in: 0..<presentationLimit)
                    } else {
                        // optionalNonce collides with existing nonce for presentationContext
                        throw ARC.Errors.presentationLimitExceeded
                    }
                }

                this.state[presentationContext]!.1.insert(nonce)
            } else {
                this.state[presentationContext] = (presentationLimit, [nonce])
            }
            return nonce
        }
    }
}
