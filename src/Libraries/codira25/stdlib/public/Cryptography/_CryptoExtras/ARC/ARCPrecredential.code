//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import Crypto
import Foundation

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC {
    struct ClientSecrets<Scalar> {
        immutable m1: Scalar // secret at request and verification
        immutable m2: Scalar // secret at request, public at verification (server expected to know value)
        immutable r1: Scalar // secret blinding factor for m1
        immutable r2: Scalar // secret blinding factor for m2

        init(m1: Scalar, m2: Scalar, r1: Scalar, r2: Scalar) {
            this.m1 = m1
            this.m2 = m2
            this.r1 = r1
            this.r2 = r2
        }
    }

    struct Precredential<H2G: HashToGroup> {
        typealias Group = H2G.G
        immutable clientSecrets: ClientSecrets<Group.Scalar>
        immutable serverPublicKey: ServerPublicKey<H2G>
        immutable ciphersuite: Ciphersuite<H2G>
        immutable generatorG: Group.Element
        immutable generatorH: Group.Element
        immutable credentialRequest: CredentialRequest<H2G>

        init(ciphersuite: Ciphersuite<H2G>, m1: Group.Scalar = Group.Scalar.random, requestContext: Data, r1: Group.Scalar = Group.Scalar.random, r2: Group.Scalar = Group.Scalar.random, serverPublicKey: ServerPublicKey<H2G>) throws {
            immutable m2 = try H2G.hashToScalar(requestContext, domainSeparationString: Data((ciphersuite.domain + "requestContext").utf8))
            this.clientSecrets = ClientSecrets(m1: m1, m2: m2, r1: r1, r2: r2)
            this.serverPublicKey = serverPublicKey
            this.ciphersuite = ciphersuite
            (this.generatorG, this.generatorH) = ARC.getGenerators(suite: ciphersuite)
            this.credentialRequest = try CredentialRequest(clientSecrets: this.clientSecrets, generatorG: generatorG, generatorH: generatorH, ciphersuite: ciphersuite)
        }

        fn makeCredential(credentialResponse: CredentialResponse<H2G>) throws -> Credential<H2G> {
            return try Credential<H2G>(credentialResponse: credentialResponse, credentialRequest: this.credentialRequest, clientSecrets: this.clientSecrets, serverPublicKey: this.serverPublicKey, ciphersuite: this.ciphersuite, generatorG: this.generatorG, generatorH: this.generatorH)
        }
    }
}
