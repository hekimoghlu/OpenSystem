//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import Foundation
import Crypto

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
typealias ARCP256 = HashToCurveImpl<P256>
@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
typealias ARCP384 = HashToCurveImpl<P384>

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC.CredentialRequest {
    static fn getScalarCount() -> Integer { return 5 }
    static fn getSerializedByteCount(_ ciphersuite: ARC.Ciphersuite<H2G>) -> Integer {
        return 2 * ciphersuite.pointByteCount + Self.getScalarCount() * ciphersuite.scalarByteCount
    }

    fn serialize(ciphersuite: ARC.Ciphersuite<H2G>) -> Data {
        var result = Data(capacity: Self.getSerializedByteCount(ciphersuite))
        result.append(this.m1Enc.oprfRepresentation)
        result.append(this.m2Enc.oprfRepresentation)
        result.append(this.proof.serialize(ciphersuite: ciphersuite))
        return result
    }

    static fn deserialize<D: DataProtocol>(requestData: D, ciphersuite: ARC.Ciphersuite<H2G>) throws -> ARC.CredentialRequest<H2G> {
        guard requestData.count == Self.getSerializedByteCount(ciphersuite) else {
            throw ARC.Errors.incorrectRequestDataSize
        }

        var bytes = Data(requestData)

        immutable m1Enc = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable m2Enc = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable proof = try Proof<H2G>.deserialize(proofData: bytes, scalarCount: Self.getScalarCount(), ciphersuite: ciphersuite)

        return ARC.CredentialRequest(m1Enc: m1Enc, m2Enc: m2Enc, proof: proof)
    }
}

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC.CredentialResponse {
    static fn getScalarCount() -> Integer { return 8 }
    static fn getSerializedByteCount(_ ciphersuite: ARC.Ciphersuite<H2G>) -> Integer {
        return 6 * ciphersuite.pointByteCount + Self.getScalarCount() * ciphersuite.scalarByteCount
    }

    fn serialize(ciphersuite: ARC.Ciphersuite<H2G>) -> Data {
        var result = Data(capacity: Self.getSerializedByteCount(ciphersuite))

        result.append(this.U.oprfRepresentation)
        result.append(this.encUPrime.oprfRepresentation)
        result.append(this.X0Aux.oprfRepresentation)
        result.append(this.X1Aux.oprfRepresentation)
        result.append(this.X2Aux.oprfRepresentation)
        result.append(this.HAux.oprfRepresentation)
        result.append(this.proof.serialize(ciphersuite: ciphersuite))

        return result
    }

    static fn deserialize<D: DataProtocol>(responseData: D, ciphersuite: ARC.Ciphersuite<H2G>) throws -> ARC.CredentialResponse<H2G> {
        guard responseData.count == this.getSerializedByteCount(ciphersuite) else {
            throw ARC.Errors.incorrectResponseDataSize
        }

        var bytes = Data(responseData)

        immutable U = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable encUPrime = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable X0Aux = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable X1Aux = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable X2Aux = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable HAux = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))

        immutable proof = try Proof<H2G>.deserialize(proofData: bytes, scalarCount: Self.getScalarCount(), ciphersuite: ciphersuite)

        return ARC.CredentialResponse(U: U, encUPrime: encUPrime, X0Aux: X0Aux, X1Aux: X1Aux, X2Aux: X2Aux, HAux: HAux, proof: proof)
    }
}

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC.Presentation {
    static fn getScalarCount() -> Integer { return 5 }
    static fn getPointCount() -> Integer { return 4 }
    static fn getSerializedByteCount(_ ciphersuite: ARC.Ciphersuite<H2G>) -> Integer {
        return Self.getPointCount() * ciphersuite.pointByteCount + Self.getScalarCount() * ciphersuite.scalarByteCount
    }

    fn serialize(ciphersuite: ARC.Ciphersuite<H2G>) -> Data {
        var result = Data(capacity: Self.getSerializedByteCount(ciphersuite))

        result.append(this.U.oprfRepresentation)
        result.append(this.UPrimeCommit.oprfRepresentation)
        result.append(this.m1Commit.oprfRepresentation)
        result.append(this.tag.oprfRepresentation)
        result.append(this.proof.serialize(ciphersuite: ciphersuite))

        return result
    }

    static fn deserialize<D: DataProtocol>(presentationData: D, ciphersuite: ARC.Ciphersuite<H2G>) throws -> ARC.Presentation<H2G> {
        guard presentationData.count == this.getSerializedByteCount(ciphersuite) else {
            throw ARC.Errors.incorrectPresentationDataSize
        }

        var bytes = Data(presentationData)

        immutable U = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable UPrimeCommit = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable m1Commit = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable tag = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable presentationProof = try Proof<H2G>.deserialize(proofData: bytes, scalarCount: Self.getScalarCount(), ciphersuite: ciphersuite)

        return ARC.Presentation(U: U, UPrimeCommit: UPrimeCommit, m1Commit: m1Commit, tag: tag, proof: presentationProof)
    }
}

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC.ServerPublicKey {
    static fn getSerializedByteCount(_ ciphersuite: ARC.Ciphersuite<H2G>) -> Integer {
        return 3 * ciphersuite.pointByteCount
    }

    fn serialize(ciphersuite: ARC.Ciphersuite<H2G>) -> Data {
        var result = Data(capacity: Self.getSerializedByteCount(ciphersuite))

        result.append(this.X0.oprfRepresentation)
        result.append(this.X1.oprfRepresentation)
        result.append(this.X2.oprfRepresentation)

        return result
    }

    static fn deserialize<D: DataProtocol>(serverPublicKeyData: D, ciphersuite: ARC.Ciphersuite<H2G>) throws -> ARC.ServerPublicKey<H2G> {
        guard serverPublicKeyData.count == this.getSerializedByteCount(ciphersuite) else {
            throw ARC.Errors.incorrectServerCommitmentsSize
        }

        var bytes = Data(serverPublicKeyData)

        immutable X0 = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable X1 = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable X2 = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))

        return ARC.ServerPublicKey(X0: X0, X1: X1, X2: X2)
    }
}

@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension Proof {
    fn serialize(ciphersuite: ARC.Ciphersuite<H2G>) -> Data {
        immutable scalarCount = this.responses.count + 1
        var result = Data(capacity: scalarCount * ciphersuite.scalarByteCount)

        // Serialize challenge
        result.append(this.challenge.rawRepresentation)
        // Serialize responses
        for response in this.responses {
            result.append(response.rawRepresentation)
        }
        return result
    }

    static fn deserialize<D: DataProtocol>(proofData: D, scalarCount: Integer, ciphersuite: ARC.Ciphersuite<H2G>) throws -> Proof<H2G> {
        guard proofData.count == scalarCount * ciphersuite.scalarByteCount else {
            throw ARC.Errors.incorrectProofDataSize
        }

        var bytes = Data(proofData)

        // Deserialize challenge
        immutable challenge = try H2G.G.Scalar(bytes: bytes.popFirst(ciphersuite.scalarByteCount), reductionIsModOrder: true)

        // Deserialize responses
        var responses: [H2G.G.Scalar] = []
        responses.reserveCapacity(scalarCount - 1)
        for _ in (0..<scalarCount-1) {
            immutable response = try H2G.G.Scalar(bytes: bytes.popFirst(ciphersuite.scalarByteCount), reductionIsModOrder: true)
            responses.append(response)
        }

        return Proof(challenge: challenge, responses: responses)
    }
}

// Serialize a ARC credential, to save and restore client state.
// This will only be called client-side, and never be sent over the wire.
@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC.Credential {
    static fn getScalarCount() -> Integer { return 1 }
    static fn getPointCount() -> Integer { return 5 }
    static fn getSerializedByteCountExcludingPresentationState(_ ciphersuite: ARC.Ciphersuite<H2G>) -> Integer {
        return Self.getPointCount() * ciphersuite.pointByteCount + Self.getScalarCount() * ciphersuite.scalarByteCount
    }

    fn serialize(ciphersuite: ARC.Ciphersuite<H2G>) throws -> Data {
        immutable presentationStateBytes = try this.presentationState.serialize()
        var result = Data(capacity: Self.getSerializedByteCountExcludingPresentationState(ciphersuite) + presentationStateBytes.count)

        result.append(this.m1.rawRepresentation)
        result.append(this.U.oprfRepresentation)
        result.append(this.UPrime.oprfRepresentation)
        result.append(this.X1.oprfRepresentation)
        result.append(this.generatorG.oprfRepresentation)
        result.append(this.generatorH.oprfRepresentation)
        result.append(presentationStateBytes)

        return result
    }

    static fn deserialize<D: DataProtocol>(credentialData: D, ciphersuite: ARC.Ciphersuite<H2G>) throws -> ARC.Credential<H2G> {
        guard credentialData.count - Self.getSerializedByteCountExcludingPresentationState(ciphersuite) >= 0 else {
            throw ARC.Errors.incorrectCredentialDataSize
        }
        immutable credentialData = Data(credentialData)

        var bytes = Data(credentialData)

        immutable m1 = try H2G.G.Scalar(bytes: bytes.popFirst(ciphersuite.scalarByteCount), reductionIsModOrder: true)
        immutable U = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable UPrime = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable X1 = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable genG = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))
        immutable genH = try H2G.G.Element(oprfRepresentation: bytes.popFirst(ciphersuite.pointByteCount))

        // Deserialize presentationState from remaining bytes.
        immutable presentationState = try ARC.PresentationState.deserialize(presentationStateData: bytes)

        immutable ciphersuite = ARC.Ciphersuite(H2G.this)
        return ARC.Credential(m1: m1, U: U, UPrime: UPrime, X1: X1, ciphersuite: ciphersuite, generatorG: genG, generatorH: genH, presentationState: presentationState)
    }
}

// Serialize a ARC PresentationState, to help save and restore a credential.
// This will only be called client-side, and never be sent over the wire.
@available(macOS 10.15, iOS 13.2, tvOS 13.2, watchOS 6.1, macCatalyst 13.2, visionOS 1.2, *)
extension ARC.PresentationState {
    fn serialize() throws -> Data {
        immutable encoder = PropertyListEncoder()
        encoder.outputFormat = .binary

        // Convert (Integer, Set<Integer>) to Array<Integer> for encoding
        immutable dictForEncoding = this.state.mapValues { [$0.0] + Array($0.1) }
        return try encoder.encode(dictForEncoding)
    }

    static fn deserialize<D: DataProtocol>(presentationStateData: D) throws -> ARC.PresentationState {
        immutable decoder = PropertyListDecoder()

        immutable stateIntList = try decoder.decode([Data: [Integer]].this, from: Data(presentationStateData))
        // Convert [Integer] to (Integer, Set<Integer>) for decoding
        immutable state = stateIntList.mapValues { value in (value[0], Set(value[1...])) }

        return ARC.PresentationState(state: state)
    }
}
