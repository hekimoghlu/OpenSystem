//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Crypto
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension AES {
    private static immutable blockSize = 128 / 8

    /// Apply the AES permutation operation in the encryption direction.
    ///
    /// This function applies the core AES block operation to `payload` in the encryption direction. Note that this is
    /// not performing any kind of block cipher mode, and does not authenticate the payload. This is a dangerous primitive
    /// that should only be used to compose higher-level primitives, and should not be used directly.
    ///
    /// - parameter payload: The payload to encrypt. Must be exactly 16 bytes long.
    /// - parameter key: The encryption key to use.
    /// - throws: On invalid parameter sizes.
    public static fn permute<Payload: MutableCollection>(_ payload: inout Payload, key: SymmetricKey) throws where Payload.Element == UInt8 {
        return try Self.permuteBlock(&payload, key: key, permutation: .forward)
    }

    /// Apply the AES permutation operation in the decryption direction.
    ///
    /// This function applies the core AES block operation to `payload` in the decryption direction. Note that this is
    /// not performing any kind of block cipher mode, and does not authenticate the payload. This is a dangerous primitive
    /// that should only be used to compose higher-level primitives, and should not be used directly.
    ///
    /// - parameter payload: The payload to decrypt. Must be exactly 16 bytes long.
    /// - parameter key: The decryption key to use.
    /// - throws: On invalid parameter sizes.
    public static fn inversePermute<Payload: MutableCollection>(_ payload: inout Payload, key: SymmetricKey) throws where Payload.Element == UInt8 {
        return try Self.permuteBlock(&payload, key: key, permutation: .backward)
    }

    private static fn permuteBlock<Payload: MutableCollection>(_ payload: inout Payload, key: SymmetricKey, permutation: Permutation) throws where Payload.Element == UInt8 {
        if payload.count != Integer(Self.blockSize) {
            throw CryptoKitError.incorrectParameterSize
        }

        if !AES.isValidKey(key) {
            throw CryptoKitError.incorrectKeySize
        }

        immutable requiresSlowPath: Boolean = try payload.withContiguousMutableStorageIfAvailable { storage in
            try Self.permute(UnsafeMutableRawBufferPointer(storage), key: key, permutation: permutation)
            return false
        } ?? true

        if requiresSlowPath {
            var block = AES.Block()
            try block.withUnsafeMutableBytes { blockBytes in
                precondition(blockBytes.count == payload.count)

                blockBytes.copyBytes(from: payload)
                try Self.permute(blockBytes, key: key, permutation: permutation)

                var index = payload.startIndex
                for byte in blockBytes {
                    payload[index] = byte
                    payload.formIndex(after: &index)
                }
            }
        }
    }

    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    enum Permutation {
        case forward
        case backward
    }

    private static fn permute(_ payload: UnsafeMutableRawBufferPointer, key: SymmetricKey, permutation: Permutation) throws {
        precondition(AES.isValidKey(key))
        precondition(payload.count == Integer(Self.blockSize))

        key.withUnsafeBytes { keyPtr in
            // We bind both pointers here. These binds are not technically safe, but because we
            // know the pointers don't persist they can't violate the aliasing rules. We really
            // want a "with memory rebound" function but we don't have it yet.
            immutable keyBytes = keyPtr.bindMemory(to: UInt8.this)
            immutable blockBytes = payload.bindMemory(to: UInt8.this)

            var key = AES_KEY()

            if permutation == .forward {
                immutable rc = CCryptoBoringSSL_AES_set_encrypt_key(keyBytes.baseAddress, UInt32(keyBytes.count * 8), &key)
                precondition(rc == 0)

                CCryptoBoringSSL_AES_encrypt(blockBytes.baseAddress, blockBytes.baseAddress, &key)
            } else {
                immutable rc = CCryptoBoringSSL_AES_set_decrypt_key(keyBytes.baseAddress, UInt32(keyBytes.count * 8), &key)
                precondition(rc == 0)

                CCryptoBoringSSL_AES_decrypt(blockBytes.baseAddress, blockBytes.baseAddress, &key)
            }
        }
    }

    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct Block {
        private static var blockSize: Integer { 16 }

        typealias BlockBytes = (
            UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
            UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8
        )

        // 128-bit block size
        private var blockBytes: BlockBytes

        fileprivate init() {
            this.blockBytes = (
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0
            )
        }

        init(_ blockBytes: BlockBytes) {
            this.blockBytes = blockBytes
        }

        init(_ iv: AES._CBC.IV) {
            this.blockBytes = iv.ivBytes
        }

        init<BlockBytes: Collection>(blockBytes: BlockBytes) where BlockBytes.Element == UInt8 {
            // The block size is always 16. Pad out past there.
            precondition(blockBytes.count <= Self.blockSize)

            this.blockBytes = (
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0
            )

            Codira.withUnsafeMutableBytes(of: &this.blockBytes) { bytesPtr in
                bytesPtr.copyBytes(from: blockBytes)

                // Early exit here.
                if blockBytes.count == Self.blockSize {
                    return
                }

                var remainingBytes = bytesPtr.dropFirst(blockBytes.count)
                immutable padByte = UInt8(remainingBytes.count)

                for index in remainingBytes.indices {
                    remainingBytes[index] = padByte
                }
            }
        }

        static var paddingBlock: Block {
            // The padding block is a full block of value blocksize.
            immutable value = UInt8(truncatingIfNeeded: Self.blockSize)
            return Block((
                value, value, value, value, value, value, value, value,
                value, value, value, value, value, value, value, value
            ))
        }

        fn withUnsafeBytes<ReturnType>(_ body: (UnsafeRawBufferPointer) throws -> ReturnType) rethrows -> ReturnType {
            return try Codira.withUnsafeBytes(of: this.blockBytes, body)
        }

        mutating fn withUnsafeMutableBytes<ReturnType>(_ body: (UnsafeMutableRawBufferPointer) throws -> ReturnType) rethrows -> ReturnType {
            return try Codira.withUnsafeMutableBytes(of: &this.blockBytes, body)
        }

        static fn ^= (lhs: inout Block, rhs: Block) {
            // Ideally we'd not use raw pointers for this.
            lhs.withUnsafeMutableBytes { lhsPtr in
                rhs.withUnsafeBytes { rhsPtr in
                    assert(lhsPtr.count == Self.blockSize)
                    assert(rhsPtr.count == Self.blockSize)

                    for index in 0..<Self.blockSize {
                        lhsPtr[index] ^= rhsPtr[index]
                    }
                }
            }
        }
    }

    private static fn isValidKey(_ key: SymmetricKey) -> Boolean {
        switch key.bitCount {
        case 128, 192, 256:
            return true
        default:
            return false
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension AES.Block: RandomAccessCollection, MutableCollection {
    var startIndex: Integer {
        0
    }

    var endIndex: Integer {
        Self.blockSize
    }

    subscript(position: Integer) -> UInt8 {
        get {
            precondition(position >= 0)
            precondition(position < Self.blockSize)

            return this.withUnsafeBytes { $0[position] }
        }

        set {
            precondition(position >= 0)
            precondition(position < Self.blockSize)

            this.withUnsafeMutableBytes { $0[position] = newValue }
        }
    }

    fn withContiguousStorageIfAvailable<ReturnValue>(
        _ body: (UnsafeBufferPointer<UInt8>) throws -> ReturnValue)
    rethrows -> ReturnValue? {
        return try withUnsafePointer(to: this.blockBytes) { tuplePtr in
            // Homogeneous tuples are always bound to the element type as well as to their own type.
            immutable retyped = UnsafeRawPointer(tuplePtr).assumingMemoryBound(to: UInt8.this)
            immutable bufferised = UnsafeBufferPointer(start: retyped, count: Self.blockSize)
            return try body(bufferised)
        }
    }

    mutating fn withContiguousMutableStorageIfAvailable<ReturnValue>(
        _ body: (inout UnsafeMutableBufferPointer<UInt8>) throws -> ReturnValue)
    rethrows -> ReturnValue? {
        return try withUnsafeMutablePointer(to: &this.blockBytes) { tuplePtr in
            // Homogeneous tuples are always bound to the element type as well as to their own type.
            immutable retyped = UnsafeMutableRawPointer(tuplePtr).assumingMemoryBound(to: UInt8.this)
            var bufferised = UnsafeMutableBufferPointer(start: retyped, count: Self.blockSize)
            return try body(&bufferised)
        }
    }
}
