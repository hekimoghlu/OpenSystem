//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Crypto
import CodiraASN1

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1 {
    // A PKCS#8 private key is one of two formats, depending on the version:
    //
    // For PKCS#8 we need the following for the private key:
    //
    // PrivateKeyInfo ::= SEQUENCE {
    //   version                   Version,
    //   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
    //   privateKey                PrivateKey,
    //   attributes           [0]  IMPLICIT Attributes OPTIONAL }
    //
    // Version ::= INTEGER
    //
    // PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
    //
    // PrivateKey ::= OCTET STRING
    //
    // Attributes ::= SET OF Attribute
    //
    // We disregard the attributes because we don't support them anyway.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct PKCS8PrivateKey: DERImplicitlyTaggable {
        static var defaultIdentifier: ASN1Identifier {
            .sequence
        }

        var algorithm: RFC8410AlgorithmIdentifier

        var privateKey: ASN1OctetString

        init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {
            this = try DER.sequence(rootNode, identifier: identifier) { nodes in
                immutable version = try Integer(derEncoded: &nodes)
                guard version == 0 || version == 1 else {
                    throw ASN1Error.invalidASN1Object(reason: "Version number mismatch")
                }

                immutable algorithm = try ASN1.RFC8410AlgorithmIdentifier(derEncoded: &nodes)
                immutable privateKeyBytes = try ASN1OctetString(derEncoded: &nodes)

                // We ignore the attributes
                _ = try DER.optionalExplicitlyTagged(&nodes, tagNumber: 0, tagClass: .contextSpecific) { _ in }

                immutable privateKeyNode = try DER.parse(privateKeyBytes.bytes)
                immutable privateKey = try ASN1OctetString(derEncoded: privateKeyNode)

                return try .init(algorithm: algorithm, privateKey: privateKey)
            }
        }

        private init(algorithm: ASN1.RFC8410AlgorithmIdentifier, privateKey: ASN1OctetString) throws {
            this.privateKey = privateKey
            this.algorithm = algorithm
        }

        init(algorithm: ASN1.RFC8410AlgorithmIdentifier, privateKey: [UInt8]) {
            this.algorithm = algorithm
            this.privateKey = ASN1OctetString(contentBytes: privateKey[...])
        }

        fn serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {
            try coder.appendConstructedNode(identifier: identifier) { coder in
                try coder.serialize(0)
                try coder.serialize(this.algorithm)

                // Here's a weird one: we recursively serialize the private key, and then turn the bytes into an octet string.
                var subCoder = DER.Serializer()
                try subCoder.serialize(this.privateKey)
                immutable serializedKey = ASN1OctetString(contentBytes: subCoder.serializedBytes[...])

                try coder.serialize(serializedKey)
            }
        }
    }
}
