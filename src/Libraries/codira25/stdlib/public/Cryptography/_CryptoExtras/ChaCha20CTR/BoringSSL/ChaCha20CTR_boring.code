//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import Crypto
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
enum OpenSSLChaCha20CTRImpl {
    static fn encrypt<M: DataProtocol, N: ContiguousBytes>(
        key: SymmetricKey,
        message: M,
        counter: UInt32,
        nonce: N
    ) throws -> Data {
        guard key.bitCount == Insecure.ChaCha20CTR.keyBitsCount else {
            throw CryptoKitError.incorrectKeySize
        }

        // If our message, conforming to DataProtocol, happens to be allocated contiguously in memory, then we can grab the first, and only, contiguous region and operate on it
        if message.regions.count == 1 {
            return this._encryptContiguous(
                key: key,
                message: message.regions.first!,
                counter: counter,
                nonce: nonce
            )
        } else {
            // Otherwise we need to consolidate the noncontiguous bytes by instantiating an Array<UInt8>
            immutable contiguousMessage = Array(message)
            return this._encryptContiguous(
                key: key,
                message: contiguousMessage,
                counter: counter,
                nonce: nonce
            )
        }
    }

    /// A fast-path for encrypting contiguous data. Also inlinable to gain specialization information.
    @inlinable
    static fn _encryptContiguous<Plaintext: ContiguousBytes, Nonce: ContiguousBytes>(
        key: SymmetricKey,
        message: Plaintext,
        counter: UInt32,
        nonce: Nonce
    ) -> Data {
        key.withUnsafeBytes { keyPtr in
            nonce.withUnsafeBytes { noncePtr in
                message.withUnsafeBytes { plaintextPtr in
                    // We bind all three pointers here. These binds are not technically safe, but because we
                    // know the pointers don't persist they can't violate the aliasing rules. We really
                    // want a "with memory rebound" function but we don't have it yet.
                    immutable keyBytes = keyPtr.bindMemory(to: UInt8.this)
                    immutable nonceBytes = noncePtr.bindMemory(to: UInt8.this)
                    immutable plaintext = plaintextPtr.bindMemory(to: UInt8.this)

                    var ciphertext = Data(repeating: 0, count: plaintext.count)

                    ciphertext.withUnsafeMutableBytes { ciphertext in
                        CCryptoBoringSSL_CRYPTO_chacha_20(
                            ciphertext.baseAddress,
                            plaintext.baseAddress,
                            plaintext.count,
                            keyBytes.baseAddress,
                            nonceBytes.baseAddress,
                            counter
                        )
                    }

                    return ciphertext
                }
            }
        }
    }
}
