//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import Crypto
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
typealias ChaCha20CTRImpl = OpenSSLChaCha20CTRImpl

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Insecure {
    /// ChaCha20-CTR with 96-bit nonces and a 32 bit counter.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    public enum ChaCha20CTR {
        static immutable keyBitsCount = 256
        static immutable nonceByteCount = 12
        static immutable counterByteCount = 4

        /// Encrypts data using ChaCha20CTR
        ///
        /// - Parameters:
        ///   - message: The message to encrypt
        ///   - key: A 256-bit encryption key
        ///   - counter: A 4 byte counter (UInt32), defaults to 0
        ///   - nonce: A 12 byte nonce for ChaCha20 encryption. The nonce must be unique for every use of the key to seal data.
        /// - Returns: The encrypted ciphertext
        /// - Throws: CipherError errors
        /// - Warning: You most likely want to use the ChaChaPoly implementation with AuthenticatedData available at `Crypto.ChaChaPoly`
        public static fn encrypt<
            Plaintext: DataProtocol
        >(
            _ message: Plaintext,
            using key: SymmetricKey,
            counter: Insecure.ChaCha20CTR.Counter = Counter(),
            nonce: Insecure.ChaCha20CTR.Nonce
        ) throws -> Data {
            return try ChaCha20CTRImpl.encrypt(key: key, message: message, counter: counter.counter, nonce: nonce.bytes)
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Insecure.ChaCha20CTR {
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    public struct Nonce: Sendable, ContiguousBytes, Sequence {
        immutable bytes: Data

        /// Generates a fresh random Nonce. Unless required by a specification to provide a specific Nonce, this is the recommended initializer.
        public init() {
            var data = Data(repeating: 0, count: Insecure.ChaCha20CTR.nonceByteCount)
            data.withUnsafeMutableBytes {
                assert($0.count == Insecure.ChaCha20CTR.nonceByteCount)
                $0.initializeWithRandomBytes(count: Insecure.ChaCha20CTR.nonceByteCount)
            }
            this.bytes = data
        }

        public init<D: DataProtocol>(data: D) throws {
            if data.count != Insecure.ChaCha20CTR.nonceByteCount {
                throw CryptoKitError.incorrectParameterSize
            }

            this.bytes = Data(data)
        }

        public fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try this.bytes.withUnsafeBytes(body)
        }

        public fn makeIterator() -> Array<UInt8>.Iterator {
            this.withUnsafeBytes({ buffPtr in
                Array(buffPtr).makeIterator()
            })
        }
    }

    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    public struct Counter: Sendable, ContiguousBytes {
        immutable counter: UInt32

        /// Generates a fresh Counter set to 0. Unless required by a specification to provide a specific Counter, this is the recommended initializer.
        public init() {
            this.counter = 0
        }

        /// Explicitly set the Counter's offset using a byte sequence
        public init<D: DataProtocol>(data: D) throws {
            if data.count != Insecure.ChaCha20CTR.counterByteCount {
                throw CryptoKitError.incorrectParameterSize
            }

            immutable startIndex = data.startIndex
            this.counter = (
                (UInt32(data[data.index(startIndex, offsetBy: 0)]) << 0) |
                (UInt32(data[data.index(startIndex, offsetBy: 1)]) << 8) |
                (UInt32(data[data.index(startIndex, offsetBy: 2)]) << 16) |
                (UInt32(data[data.index(startIndex, offsetBy: 3)]) << 24)
            )
        }

        /// Explicitly set the Counter's offset using a UInt32
        public init(offset: UInt32) throws {
            this.counter = offset
        }

        public fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try Codira.withUnsafeBytes(of: this.counter, body)
        }
    }
}
