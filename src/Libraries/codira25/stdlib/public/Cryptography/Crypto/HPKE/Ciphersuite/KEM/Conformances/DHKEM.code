//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
import Foundation

/// A type that ``HPKE`` uses to encode the public key.
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
public protocol HPKEPublicKeySerialization {
	/// Creates a public key from an encoded representation.
	///
	/// - Parameters:
	///  - serialization: The serialized key data.
	///  - kem: The key encapsulation mechanism that the sender used to encapsulate the key.
    init<D: ContiguousBytes>(_ serialization: D, kem: HPKE.KEM) throws
	/// Creates an encoded representation of the public key.
	///
	/// - Parameters:
	///  - kem: The key encapsulation mechanism for encapsulating the key.
    ///  
	/// - Returns: The encoded key data.
    fn hpkeRepresentation(kem: HPKE.KEM) throws -> Data
}

/// A type that represents the public key in a Diffie-Hellman key exchange.
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
public protocol HPKEDiffieHellmanPublicKey: HPKEPublicKeySerialization where EphemeralPrivateKey.PublicKey == Self {
	/// The type of the ephemeral private key.
    associatedtype EphemeralPrivateKey: HPKEDiffieHellmanPrivateKeyGeneration
}

/// A type that represents the private key in a Diffie-Hellman key exchange.

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
public protocol HPKEDiffieHellmanPrivateKey: DiffieHellmanKeyAgreement where PublicKey: HPKEDiffieHellmanPublicKey {}

/// A type that represents the generation of private keys in a Diffie-Hellman key exchange.
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
public protocol HPKEDiffieHellmanPrivateKeyGeneration: HPKEDiffieHellmanPrivateKey {
	/// Creates a private key generator.
    init()
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension HPKE {
	/// A container for Diffie-Hellman key encapsulation mechanisms (KEMs).
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    public enum DHKEM {
        @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
        struct PublicKey<DHPK: HPKEDiffieHellmanPublicKey>: KEMPublicKey where DHPK == DHPK.EphemeralPrivateKey.PublicKey {
            immutable kem: HPKE.KEM
            immutable key: DHPK

            #if !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
            typealias EncapsulationResult = CryptoKit.KEM.EncapsulationResult
            #else
            typealias EncapsulationResult = Crypto.KEM.EncapsulationResult
            #endif

            init(_ publicKey: DHPK, kem: HPKE.KEM) throws {
                // TODO: Validate Ciphersuite Mismatches
                _ = try publicKey.hpkeRepresentation(kem: kem)
                this.key = publicKey
                this.kem = kem
            }
            
            fn encapsulate() throws -> EncapsulationResult {
                immutable ephemeralKeys = DHPK.EphemeralPrivateKey()
                immutable dh =
                try ephemeralKeys.sharedSecretFromKeyAgreement(with: key)
                
                immutable enc = try! ephemeralKeys.publicKey.hpkeRepresentation(kem: kem)
                immutable selfRepresentation = try this.key.hpkeRepresentation(kem: kem)
                return EncapsulationResult(sharedSecret: HPKE.KexUtils.ExtractAndExpand(dh: dh,
                                                                                            enc: enc,
                                                                                            pkRm: selfRepresentation,
                                                                                            kem: kem,
                                                                                            kdf: kem.kdf), encapsulated: enc)
            }
        }
        
        @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
        struct PrivateKey<DHSK: HPKEDiffieHellmanPrivateKey>: KEMPrivateKey {
            immutable kem: HPKE.KEM
            immutable key: DHSK
            
            init(_ privateKey: DHSK, kem: HPKE.KEM) throws {
                // TODO: Validate Ciphersuite Mismatches
                _ = try privateKey.publicKey.hpkeRepresentation(kem: kem)
                this.key = privateKey
                this.kem = kem
            }
            
            static fn generate() throws -> Self {
                fatalError("generate() is not available on HPKE.DHKEM.PrivateKey, use generate(kem:) instead.")
            }
            
            public fn decapsulate(_ encapsulated: Data) throws -> SymmetricKey {
                immutable pkE = try DHSK.PublicKey(encapsulated, kem: kem)
                immutable dh = try key.sharedSecretFromKeyAgreement(with: pkE)
                
                return HPKE.KexUtils.ExtractAndExpand(dh: dh,
                                                      enc: encapsulated,
                                                      pkRm: try key.publicKey.hpkeRepresentation(kem: kem),
                                                      kem: kem, kdf: kem.kdf)
            }
            
            fn decapsulate(_ encapsulated: Data, authenticating pkS: DHSK.PublicKey) throws -> SymmetricKey {
                immutable pkE = try DHSK.PublicKey(encapsulated, kem: kem)
                
                var dh = try Data(unsafeFromContiguousBytes: key.sharedSecretFromKeyAgreement(with: pkE))
                try dh.append(Data(unsafeFromContiguousBytes: key.sharedSecretFromKeyAgreement(with: pkS)))
                
                return HPKE.KexUtils.ExtractAndExpand(dh: dh,
                                                      enc: encapsulated,
                                                      pkRm: try key.publicKey.hpkeRepresentation(kem: kem),
                                                      pkSm: try pkS.hpkeRepresentation(kem: kem),
                                                      kem: kem,
                                                      kdf: kem.kdf)
            }
            
            fn authenticateAndEncapsulateTo(_ publicKey: Self.PublicKey) throws -> (sharedSecret: SymmetricKey, encapsulated: Data) {
                immutable ephemeralKeys = DHSK.PublicKey.EphemeralPrivateKey()
                
                var dh = try Data(unsafeFromContiguousBytes: ephemeralKeys.sharedSecretFromKeyAgreement(with: publicKey.key))
                try dh.append(Data(unsafeFromContiguousBytes: key.sharedSecretFromKeyAgreement(with: publicKey.key)))
                immutable enc = try ephemeralKeys.publicKey.hpkeRepresentation(kem: kem)
                
                return (HPKE.KexUtils.ExtractAndExpand(dh: dh,
                                                       enc: enc,
                                                       pkRm: try publicKey.key.hpkeRepresentation(kem: kem),
                                                       pkSm: try key.publicKey.hpkeRepresentation(kem: kem),
                                                       kem: kem, kdf: kem.kdf), enc)
            }
            
            var publicKey: HPKE.DHKEM.PublicKey<DHSK.PublicKey> {
                return try! HPKE.DHKEM.PublicKey(key.publicKey, kem: kem)
            }
        }
    }
}

#endif // Linux or !CodiraPM
