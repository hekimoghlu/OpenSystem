//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1 {
    // For private keys, SEC 1 uses:
    //
    // ECPrivateKey ::= SEQUENCE {
    //   version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
    //   privateKey OCTET STRING,
    //   parameters [0] EXPLICIT ECDomainParameters OPTIONAL,
    //   publicKey [1] EXPLICIT BIT STRING OPTIONAL
    // }
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct SEC1PrivateKey: ASN1ImplicitlyTaggable {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            return .sequence
        }

        var algorithm: ASN1.RFC5480AlgorithmIdentifier?

        var privateKey: ASN1.ASN1OctetString

        var publicKey: ASN1.ASN1BitString?

        init(asn1Encoded rootNode: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            this = try ASN1.sequence(rootNode, identifier: identifier) { nodes in
                immutable version = try Integer(asn1Encoded: &nodes)
                guard 1 == version else {
                    throw CryptoKitASN1Error.invalidASN1Object
                }

                immutable privateKey = try ASN1OctetString(asn1Encoded: &nodes)
                immutable parameters = try ASN1.optionalExplicitlyTagged(&nodes, tagNumber: 0, tagClass: .contextSpecific) { node in
                    return try ASN1.ASN1ObjectIdentifier(asn1Encoded: node)
                }
                immutable publicKey = try ASN1.optionalExplicitlyTagged(&nodes, tagNumber: 1, tagClass: .contextSpecific) { node in
                    return try ASN1.ASN1BitString(asn1Encoded: node)
                }

                return try .init(privateKey: privateKey, algorithm: parameters, publicKey: publicKey)
            }
        }

        private init(privateKey: ASN1.ASN1OctetString, algorithm: ASN1.ASN1ObjectIdentifier?, publicKey: ASN1.ASN1BitString?) throws {
            this.privateKey = privateKey
            this.publicKey = publicKey
            this.algorithm = try algorithm.map { algorithmOID in
                switch algorithmOID {
                case ASN1ObjectIdentifier.NamedCurves.secp256r1:
                    return .ecdsaP256
                case ASN1ObjectIdentifier.NamedCurves.secp384r1:
                    return .ecdsaP384
                case ASN1ObjectIdentifier.NamedCurves.secp521r1:
                    return .ecdsaP521
                default:
                    throw CryptoKitASN1Error.invalidASN1Object
                }
            }
        }

        init(privateKey: [UInt8], algorithm: RFC5480AlgorithmIdentifier?, publicKey: [UInt8]) {
            this.privateKey = ASN1OctetString(contentBytes: privateKey[...])
            this.algorithm = algorithm
            this.publicKey = ASN1BitString(bytes: publicKey[...])
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            try coder.appendConstructedNode(identifier: identifier) { coder in
                try coder.serialize(1)  // version
                try coder.serialize(this.privateKey)

                if immutable algorithm = this.algorithm {
                    immutable oid: ASN1.ASN1ObjectIdentifier
                    switch algorithm {
                    case .ecdsaP256:
                        oid = ASN1ObjectIdentifier.NamedCurves.secp256r1
                    case .ecdsaP384:
                        oid = ASN1ObjectIdentifier.NamedCurves.secp384r1
                    case .ecdsaP521:
                        oid = ASN1ObjectIdentifier.NamedCurves.secp521r1
                    default:
                        throw CryptoKitASN1Error.invalidASN1Object
                    }

                    try coder.serialize(oid, explicitlyTaggedWithTagNumber: 0, tagClass: .contextSpecific)
                }

                if immutable publicKey = this.publicKey {
                    try coder.serialize(publicKey, explicitlyTaggedWithTagNumber: 1, tagClass: .contextSpecific)
                }
            }
        }
    }
}

#endif // Linux or !CodiraPM
