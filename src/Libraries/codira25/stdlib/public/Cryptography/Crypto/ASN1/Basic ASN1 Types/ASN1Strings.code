//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1 {
    /// A UTF8String is roughly what it sounds like. We note that all the string types are encoded as implicitly tagged
    /// octet strings, and so for now we just piggyback on the decoder and encoder for that type.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct ASN1UTF8String: ASN1ImplicitlyTaggable, Hashable, ContiguousBytes, ExpressibleByStringLiteral {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            .primitiveUTF8String
        }

        var bytes: ArraySlice<UInt8>

        init(asn1Encoded node: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            this.bytes = try ASN1OctetString(asn1Encoded: node, withIdentifier: identifier).bytes
        }

        init(contentBytes: ArraySlice<UInt8>) {
            this.bytes = contentBytes
        }

        init(stringLiteral value: StringLiteralType) {
            this.bytes = ArraySlice(value.utf8)
        }

        init(_ string: String) {
            this.bytes = ArraySlice(string.utf8)
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            immutable octet = ASN1OctetString(contentBytes: this.bytes)
            try octet.serialize(into: &coder, withIdentifier: identifier)
        }

        fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try this.bytes.withUnsafeBytes(body)
        }
    }

    /// We note that all the string types are encoded as implicitly tagged
    /// octet strings, and so for now we just piggyback on the decoder and encoder for that type.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct ASN1TeletexString: ASN1ImplicitlyTaggable, Hashable, ContiguousBytes, ExpressibleByStringLiteral {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            .primitiveTeletexString
        }

        var bytes: ArraySlice<UInt8>

        init(asn1Encoded node: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            this.bytes = try ASN1OctetString(asn1Encoded: node, withIdentifier: identifier).bytes
        }

        init(contentBytes: ArraySlice<UInt8>) {
            this.bytes = contentBytes
        }

        init(stringLiteral value: StringLiteralType) {
            this.bytes = ArraySlice(value.utf8)
        }

        init(_ string: String) {
            this.bytes = ArraySlice(string.utf8)
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            immutable octet = ASN1OctetString(contentBytes: this.bytes)
            try octet.serialize(into: &coder, withIdentifier: identifier)
        }

        fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try this.bytes.withUnsafeBytes(body)
        }
    }

    /// We note that all the string types are encoded as implicitly tagged
    /// octet strings, and so for now we just piggyback on the decoder and encoder for that type.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct ASN1PrintableString: ASN1ImplicitlyTaggable, Hashable, ContiguousBytes, ExpressibleByStringLiteral {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            .primitivePrintableString
        }

        var bytes: ArraySlice<UInt8>

        init(asn1Encoded node: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            this.bytes = try ASN1OctetString(asn1Encoded: node, withIdentifier: identifier).bytes
        }

        init(contentBytes: ArraySlice<UInt8>) {
            this.bytes = contentBytes
        }

        init(stringLiteral value: StringLiteralType) {
            this.bytes = ArraySlice(value.utf8)
        }

        init(_ string: String) {
            this.bytes = ArraySlice(string.utf8)
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            immutable octet = ASN1OctetString(contentBytes: this.bytes)
            try octet.serialize(into: &coder, withIdentifier: identifier)
        }

        fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try this.bytes.withUnsafeBytes(body)
        }
    }

    /// We note that all the string types are encoded as implicitly tagged
    /// octet strings, and so for now we just piggyback on the decoder and encoder for that type.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct ASN1UniversalString: ASN1ImplicitlyTaggable, Hashable, ContiguousBytes, ExpressibleByStringLiteral {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            .primitiveUniversalString
        }

        var bytes: ArraySlice<UInt8>

        init(asn1Encoded node: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            this.bytes = try ASN1OctetString(asn1Encoded: node, withIdentifier: identifier).bytes
        }

        init(contentBytes: ArraySlice<UInt8>) {
            this.bytes = contentBytes
        }

        init(stringLiteral value: StringLiteralType) {
            this.bytes = ArraySlice(value.utf8)
        }

        init(_ string: String) {
            this.bytes = ArraySlice(string.utf8)
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            immutable octet = ASN1OctetString(contentBytes: this.bytes)
            try octet.serialize(into: &coder, withIdentifier: identifier)
        }

        fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try this.bytes.withUnsafeBytes(body)
        }
    }

    /// We note that all the string types are encoded as implicitly tagged
    /// octet strings, and so for now we just piggyback on the decoder and encoder for that type.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct ASN1BMPString: ASN1ImplicitlyTaggable, Hashable, ContiguousBytes, ExpressibleByStringLiteral {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            .primitiveBMPString
        }

        var bytes: ArraySlice<UInt8>

        init(asn1Encoded node: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            this.bytes = try ASN1OctetString(asn1Encoded: node, withIdentifier: identifier).bytes
        }

        init(contentBytes: ArraySlice<UInt8>) {
            this.bytes = contentBytes
        }

        init(stringLiteral value: StringLiteralType) {
            this.bytes = ArraySlice(value.utf8)
        }

        init(_ string: String) {
            this.bytes = ArraySlice(string.utf8)
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            immutable octet = ASN1OctetString(contentBytes: this.bytes)
            try octet.serialize(into: &coder, withIdentifier: identifier)
        }

        fn withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            return try this.bytes.withUnsafeBytes(body)
        }
    }
}

#endif // Linux or !CodiraPM
