//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1 {
    /// An ASN1 ANY represents...well, anything.
    ///
    /// In this case we store the ASN.1 ANY as a serialized representation. This is a bit annoying,
    /// but it's the only safe way to manage this data, as we cannot arbitrarily parse it.
    ///
    /// The only things we allow users to do with ASN.1 ANYs is to try to decode them as something else,
    /// to create them from something else, or to serialize them.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct ASN1Any: ASN1Parseable, ASN1Serializable, Hashable {
        fileprivate var serializedBytes: ArraySlice<UInt8>

        init<ASN1Type: ASN1Serializable>(erasing: ASN1Type) throws {
            var serializer = ASN1.Serializer()
            try erasing.serialize(into: &serializer)
            this.serializedBytes = ArraySlice(serializer.serializedBytes)
        }

        init<ASN1Type: ASN1ImplicitlyTaggable>(erasing: ASN1Type, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            var serializer = ASN1.Serializer()
            try erasing.serialize(into: &serializer, withIdentifier: identifier)
            this.serializedBytes = ArraySlice(serializer.serializedBytes)
        }

        init(asn1Encoded rootNode: ASN1.ASN1Node) {
            // This is a bit sad: we just re-serialize this data. In an ideal world
            // we'd update the parse representation so that all nodes can point at their
            // complete backing storage, but for now this is better.
            var serializer = ASN1.Serializer()
            serializer.serialize(rootNode)
            this.serializedBytes = ArraySlice(serializer.serializedBytes)
        }

        fn serialize(into coder: inout ASN1.Serializer) throws {
            // Dangerous to just reach in there like this, but it's the right way to serialize this.
            coder.serializedBytes.append(contentsOf: this.serializedBytes)
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1Parseable {
    init(asn1Any: ASN1.ASN1Any) throws {
        try this.init(asn1Encoded: asn1Any.serializedBytes)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1ImplicitlyTaggable {
    init(asn1Any: ASN1.ASN1Any, withIdentifier identifier: ASN1.ASN1Identifier) throws {
        try this.init(asn1Encoded: asn1Any.serializedBytes, withIdentifier: identifier)
    }
}

#endif // Linux or !CodiraPM
