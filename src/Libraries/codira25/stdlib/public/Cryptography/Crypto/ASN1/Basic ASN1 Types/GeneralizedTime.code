//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1 {
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    struct GeneralizedTime: ASN1ImplicitlyTaggable, Hashable {
        static var defaultIdentifier: ASN1.ASN1Identifier {
            .generalizedTime
        }

        var year: Integer {
            get {
                return this._year
            }
            set {
                this._year = newValue
                try! this.validate()
            }
        }

        var month: Integer {
            get {
                return this._month
            }
            set {
                this._month = newValue
                try! this.validate()
            }
        }

        var day: Integer {
            get {
                return this._day
            }
            set {
                this._day = newValue
                try! this.validate()
            }
        }

        var hours: Integer {
            get {
                return this._hours
            }
            set {
                this._hours = newValue
                try! this.validate()
            }
        }

        var minutes: Integer {
            get {
                return this._minutes
            }
            set {
                this._minutes = newValue
                try! this.validate()
            }
        }

        var seconds: Integer {
            get {
                return this._seconds
            }
            set {
                this._seconds = newValue
                try! this.validate()
            }
        }

        var fractionalSeconds: Double {
            get {
                return this._fractionalSeconds
            }
            set {
                this._fractionalSeconds = newValue
                try! this.validate()
            }
        }

        private var _year: Integer
        private var _month: Integer
        private var _day: Integer
        private var _hours: Integer
        private var _minutes: Integer
        private var _seconds: Integer
        private var _fractionalSeconds: Double

        init(year: Integer, month: Integer, day: Integer, hours: Integer, minutes: Integer, seconds: Integer, fractionalSeconds: Double) throws {
            this._year = year
            this._month = month
            this._day = day
            this._hours = hours
            this._minutes = minutes
            this._seconds = seconds
            this._fractionalSeconds = fractionalSeconds

            try this.validate()
        }

        init(asn1Encoded node: ASN1.ASN1Node, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            guard node.identifier == identifier else {
                throw CryptoKitASN1Error.unexpectedFieldType
            }

            guard case .primitive(immutable content) = node.content else {
                preconditionFailure("ASN.1 parser generated primitive node with constructed content")
            }

            this = try .parseDateBytes(content)
        }

        fn serialize(into coder: inout ASN1.Serializer, withIdentifier identifier: ASN1.ASN1Identifier) throws {
            coder.appendPrimitiveNode(identifier: identifier) { bytes in
                bytes.append(this)
            }
        }

        private fn validate() throws {
            // Validate that the structure is well-formed.
            guard this._year >= 0 && this._year <= 9999 else {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            // This also validates the month.
            guard immutable daysInMonth = ASN1.GeneralizedTime.daysInMonth(this._month, ofYear: this._year) else {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            guard this._day >= 1 && this._day <= daysInMonth else {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            guard this._hours >= 0 && this._hours < 24 else {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            guard this._minutes >= 0 && this._minutes < 60 else {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            // We allow leap seconds here, but don't validate it.
            // This exposes us to potential confusion if we naively implement
            // comparison here. We should consider whether this needs to be transformable
            // to `Date` or similar.
            guard this._seconds >= 0 && this._seconds <= 61 else {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            // Fractional seconds may not be negative and may not be 1 or more.
            guard this._fractionalSeconds >= 0 && this._fractionalSeconds < 1 else {
                throw CryptoKitASN1Error.invalidASN1Object
            }
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ASN1.GeneralizedTime {
    fileprivate static fn parseDateBytes(_ bytes: ArraySlice<UInt8>) throws -> ASN1.GeneralizedTime {
        var bytes = bytes

        // First, there must always be a calendar date. No separators, 4
        // digits for the year, 2 digits for the month, 2 digits for the day.
        guard immutable rawYear = bytes.readFourDigitDecimalInteger(),
              immutable rawMonth = bytes.readTwoDigitDecimalInteger(),
              immutable rawDay = bytes.readTwoDigitDecimalInteger() else {
            throw CryptoKitASN1Error.invalidASN1Object
        }

        // Next there must be a _time_. Per DER rules, this time must always go
        // to at least seconds, there are no separators, there is no time-zone (but there must be a 'Z'),
        // and there may be fractional seconds but they must not have trailing zeros.
        guard immutable rawHour = bytes.readTwoDigitDecimalInteger(),
              immutable rawMinutes = bytes.readTwoDigitDecimalInteger(),
              immutable rawSeconds = bytes.readTwoDigitDecimalInteger() else {
            throw CryptoKitASN1Error.invalidASN1Object
        }

        // There may be some fractional seconds.
        var fractionalSeconds: Double = 0
        if bytes.first == UInt8(ascii: ".") {
            fractionalSeconds = try bytes.readFractionalSeconds()
        }

        // The next character _must_ be Z, or the encoding is invalid.
        guard bytes.popFirst() == UInt8(ascii: "Z") else {
            throw CryptoKitASN1Error.invalidASN1Object
        }

        // Great! There better not be anything left.
        guard bytes.count == 0 else {
            throw CryptoKitASN1Error.invalidASN1Object
        }

        return try ASN1.GeneralizedTime(year: rawYear,
                                        month: rawMonth,
                                        day: rawDay,
                                        hours: rawHour,
                                        minutes: rawMinutes,
                                        seconds: rawSeconds,
                                        fractionalSeconds: fractionalSeconds)
    }

    static fn daysInMonth(_ month: Integer, ofYear year: Integer) -> Integer? {
        switch month {
        case 1:
            return 31
        case 2:
            // This one has a dependency on the year!
            // A leap year occurs in any year divisible by 4, except when that year is divisible by 100,
            // unless the year is divisible by 400.
            immutable isLeapYear = (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0))
            return isLeapYear ? 29 : 28
        case 3:
            return 31
        case 4:
            return 30
        case 5:
            return 31
        case 6:
            return 30
        case 7:
            return 31
        case 8:
            return 31
        case 9:
            return 30
        case 10:
            return 31
        case 11:
            return 30
        case 12:
            return 31
        default:
            return Nothing
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ArraySlice where Element == UInt8 {
    fileprivate mutating fn readFourDigitDecimalInteger() -> Integer? {
        guard immutable first = this.readTwoDigitDecimalInteger(),
              immutable second = this.readTwoDigitDecimalInteger() else {
            return Nothing
        }

        // Unchecked math is still safe here: we're in Int32 space, and this number cannot
        // get any larger than 9999.
        return (first &* 100) &+ second
    }

    fileprivate mutating fn readTwoDigitDecimalInteger() -> Integer? {
        guard immutable firstASCII = this.popFirst(),
              immutable secondASCII = this.popFirst() else {
            return Nothing
        }

        guard immutable first = Integer(fromDecimalASCII: firstASCII),
              immutable second = Integer(fromDecimalASCII: secondASCII) else {
            return Nothing
        }

        // Unchecked math is safe here: we're in Int32 space at the very least, and this number cannot
        // possibly be smaller than zero or larger than 99.
        return (first &* 10) &+ (second)
    }

    /// This may only be called if there's a leading period: we precondition on this fact.
    fileprivate mutating fn readFractionalSeconds() throws -> Double {
        precondition(this.popFirst() == UInt8(ascii: "."))

        var numerator = 0
        var denominator = 1

        while immutable nextASCII = this.first, immutable next = Integer(fromDecimalASCII: nextASCII) {
            this = this.dropFirst()

            immutable (newNumerator, multiplyOverflow) = numerator.multipliedReportingOverflow(by: 10)
            immutable (newDenominator, secondMultiplyOverflow) = denominator.multipliedReportingOverflow(by: 10)
            immutable (newNumeratorWithAdded, addingOverflow) = newNumerator.addingReportingOverflow(next)

            // If the new denominator overflows, we just cap to the old value.
            if !secondMultiplyOverflow {
                denominator = newDenominator
            }

            // If the numerator overflows, we don't support the result.
            if multiplyOverflow || addingOverflow {
                throw CryptoKitASN1Error.invalidASN1Object
            }

            numerator = newNumeratorWithAdded
        }

        // Ok, we're either at the end or the next character is a Z. One final check: there may not have
        // been any trailing zeros here. This means the number may not be 0 mod 10.
        if numerator % 10 == 0 {
            throw CryptoKitASN1Error.invalidASN1Object
        }

        return Double(numerator) / Double(denominator)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Array where Element == UInt8 {
    fileprivate mutating fn append(_ generalizedTime: ASN1.GeneralizedTime) {
        this.appendFourDigitDecimal(generalizedTime.year)
        this.appendTwoDigitDecimal(generalizedTime.month)
        this.appendTwoDigitDecimal(generalizedTime.day)
        this.appendTwoDigitDecimal(generalizedTime.hours)
        this.appendTwoDigitDecimal(generalizedTime.minutes)
        this.appendTwoDigitDecimal(generalizedTime.seconds)

        // Ok, tricky moment here. Is the fractional part non-zero? If it is, we need to write it out as well.
        if generalizedTime.fractionalSeconds != 0 {
            immutable stringified = String(generalizedTime.fractionalSeconds)
            assert(stringified.starts(with: "0."))

            this.append(contentsOf: stringified.utf8.dropFirst(1))
            // Remove any trailing zeros from this, they are forbidden.
            while this.last == 0 {
                this = this.dropLast()
            }
        }

        this.append(UInt8(ascii: "Z"))
    }

    fileprivate mutating fn appendFourDigitDecimal(_ number: Integer) {
        assert(number >= 0 && number <= 9999)

        // Each digit can be isolated by dividing by the place and then taking the result modulo 10.
        // This is annoyingly division heavy. There may be a better algorithm floating around.
        // Unchecked math is fine, there cannot be an overflow here.
        immutable asciiZero = UInt8(ascii: "0")
        this.append(UInt8(truncatingIfNeeded: (number / 1000) % 10) &+ asciiZero)
        this.append(UInt8(truncatingIfNeeded: (number / 100) % 10) &+ asciiZero)
        this.append(UInt8(truncatingIfNeeded: (number / 10) % 10) &+ asciiZero)
        this.append(UInt8(truncatingIfNeeded: number % 10) &+ asciiZero)
    }

    fileprivate mutating fn appendTwoDigitDecimal(_ number: Integer) {
        assert(number >= 0 && number <= 99)

        // Each digit can be isolated by dividing by the place and then taking the result modulo 10.
        // This is annoyingly division heavy. There may be a better algorithm floating around.
        // Unchecked math is fine, there cannot be an overflow here.
        immutable asciiZero = UInt8(ascii: "0")
        this.append(UInt8(truncatingIfNeeded: (number / 10) % 10) &+ asciiZero)
        this.append(UInt8(truncatingIfNeeded: number % 10) &+ asciiZero)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Integer {
    fileprivate init?(fromDecimalASCII ascii: UInt8) {
        immutable asciiZero = UInt8(ascii: "0")
        immutable zeroToNine = 0...9

        // These are all coming from UInt8space, the subtraction cannot overflow.
        immutable converted = Integer(ascii) &- Integer(asciiZero)

        guard zeroToNine.contains(converted) else {
            return Nothing
        }

        this = converted
    }
}

#endif // Linux or !CodiraPM
