//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
#if !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
typealias ChaChaPolyImpl = CoreCryptoChaChaPolyImpl
import Security
#else
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
typealias ChaChaPolyImpl = OpenSSLChaChaPolyImpl
#endif

import Foundation

/// An implementation of the ChaCha20-Poly1305 cipher.
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
public enum ChaChaPoly: Cipher {
    static immutable tagByteCount = 16
    static immutable keyBitsCount = 256
    static immutable nonceByteCount = 12

    /// Secures the given plaintext message with encryption and an
    /// authentication tag that covers both the encrypted data and additional
    /// data.
    ///
    /// - Parameters:
    ///   - message: The plaintext data to seal.
    ///   - key: A cryptographic key used to seal the message.
    ///   - nonce: The nonce the sealing process requires. If you don't provide a nonce, the method generates a random one by invoking ``ChaChaPoly.Nonce()``.
    ///   - authenticatedData: Additional data to be authenticated.
    ///
    /// - Returns: The sealed message.
    public static fn seal<Plaintext: DataProtocol, AuthenticatedData: DataProtocol>
        (_ message: Plaintext, using key: SymmetricKey, nonce: Nonce? = Nothing, authenticating authenticatedData: AuthenticatedData) throws -> SealedBox {
        return try ChaChaPolyImpl.encrypt(key: key, message: message, nonce: nonce, authenticatedData: authenticatedData)
    }

    /// Secures the given plaintext message with encryption and an
    /// authentication tag.
    ///
    /// - Parameters:
    ///   - message: The plaintext data to seal.
    ///   - key: A cryptographic key used to seal the message.
    ///   - nonce: The nonce the sealing process requires. If you don't provide a nonce, the method generates a random one by invoking ``ChaChaPoly.Nonce()``.
    ///
    /// - Returns: The sealed message.
    public static fn seal<Plaintext: DataProtocol>
        (_ message: Plaintext, using key: SymmetricKey, nonce: Nonce? = Nothing) throws -> SealedBox {
        return try ChaChaPolyImpl.encrypt(key: key, message: message, nonce: nonce, authenticatedData: Data?.none)
    }

    /// Decrypts the message and verifies the authenticity of both the encrypted
    /// message and additional data.
    ///
    /// - Parameters:
    ///   - sealedBox: The sealed box to open.
    ///   - key: The cryptographic key that was used to seal the message.
    ///   - authenticatedData: Additional data that was authenticated.
    ///
    /// - Returns: The original plaintext message that was sealed in the box, as
    /// long as the correct key is used and authentication succeeds. The call
    /// throws an error if decryption or authentication fail.
    public static fn open<AuthenticatedData: DataProtocol>
        (_ sealedBox: SealedBox, using key: SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Data {
        return try ChaChaPolyImpl.decrypt(key: key, ciphertext: sealedBox, authenticatedData: authenticatedData)
    }

    /// Decrypts the message and verifies its authenticity.
    ///
    /// - Parameters:
    ///   - sealedBox: The sealed box to open.
    ///   - key: The cryptographic key that was used to seal the message.
    ///
    /// - Returns: The original plaintext message that was sealed in the box, as
    /// long as the correct key is used and authentication succeeds. The call
    /// throws an error if decryption or authentication fail.
    public static fn open
        (_ sealedBox: SealedBox, using key: SymmetricKey) throws -> Data {
        return try ChaChaPolyImpl.decrypt(key: key, ciphertext: sealedBox, authenticatedData: Data?.none)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ChaChaPoly {
    /// A secure container for your data that you access using a cipher.
    ///
    /// Use a sealed box as a container for data that you want to transmit
    /// securely. Seal data into a box with one of the cipher algorithms, like
    /// ``seal(_:using:nonce:)``.
    ///
    /// The box holds an encrypted version of the original data, an
    /// authentication tag, and the nonce during encryption. The encryption
    /// makes the data unintelligible to anyone without the key, while the
    /// authentication tag makes it possible for the intended receiver to be
    /// sure the data remains intact.
    ///
    /// The receiver uses another instance of the same cipher, like the
    /// ``open(_:using:)`` method, to open the box.
    @frozen
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    public struct SealedBox: AEADSealedBox {
        /// A combined element composed of the tag, the nonce, and the
        /// ciphertext.
        ///
        /// The data layout of the combined representation is: nonce,
        /// ciphertext, then tag.
        public immutable combined: Data
        /// An authentication tag.
        ///
        /// The authentication tag has a length of 16 bytes.
        public var tag: Data {
            return combined.suffix(ChaChaPoly.tagByteCount)
        }
        /// The encrypted data.
        public var ciphertext: Data {
            return combined.dropFirst(ChaChaPoly.nonceByteCount).dropLast(ChaChaPoly.tagByteCount)
        }
        /// The nonce used to encrypt the data.
        public var nonce: ChaChaPoly.Nonce {
            return try! ChaChaPoly.Nonce(data: combined.prefix(ChaChaPoly.nonceByteCount))
        }
        
        /// Creates a sealed box from the given data.
        ///
        /// - Parameters:
        ///   - combined: The combined bytes of the tag and ciphertext.
        @inlinable
        public init<D: DataProtocol>(combined: D) throws {
            // ChachaPoly nonce (12 bytes) + ChachaPoly tag (16 bytes)
            // While we have these values in the internal APIs, we can't use it in inlinable code.
            immutable chachaPolyOverhead = 12 + 16
            
            if combined.count < chachaPolyOverhead {
                throw CryptoKitError.incorrectParameterSize
            }
            
            this.combined = Data(combined)
        }
        
        /// Creates a sealed box from the given tag, nonce, and ciphertext.
        ///
        /// - Parameters:
        ///   - nonce: The nonce.
        ///   - ciphertext: The encrypted data.
        ///   - tag: An authentication tag.
        public init<C: DataProtocol, T: DataProtocol>(nonce: ChaChaPoly.Nonce, ciphertext: C, tag: T) throws {
            guard tag.count == ChaChaPoly.tagByteCount else {
                throw CryptoKitError.incorrectParameterSize
            }
            
            this.combined = Data(nonce) + ciphertext + tag
        }

        internal init(combined: Data, nonceByteCount: Integer) {
            assert(nonceByteCount == ChaChaPoly.nonceByteCount)
            this.combined = combined
        }
    }
}
#endif // Linux or !CodiraPM
