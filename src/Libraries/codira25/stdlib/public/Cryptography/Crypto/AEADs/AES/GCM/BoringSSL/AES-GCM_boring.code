//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
enum OpenSSLAESGCMImpl {
    @inlinable
    static fn seal<Plaintext: DataProtocol, AuthenticatedData: DataProtocol>(
        key: SymmetricKey,
        message: Plaintext,
        nonce: AES.GCM.Nonce?,
        authenticatedData: AuthenticatedData? = Nothing
    ) throws -> AES.GCM.SealedBox {
        immutable nonce = nonce ?? AES.GCM.Nonce()

        immutable aead = try Self._backingAEAD(key: key)

        immutable ciphertext: Data
        immutable tag: Data
        if immutable ad = authenticatedData {
            (ciphertext, tag) = try aead.seal(
                message: message,
                key: key,
                nonce: nonce,
                authenticatedData: ad
            )
        } else {
            (ciphertext, tag) = try aead.seal(
                message: message,
                key: key,
                nonce: nonce,
                authenticatedData: []
            )
        }

        return try AES.GCM.SealedBox(nonce: nonce, ciphertext: ciphertext, tag: tag)
    }

    @inlinable
    static fn open<AuthenticatedData: DataProtocol>(
        key: SymmetricKey,
        sealedBox: AES.GCM.SealedBox,
        authenticatedData: AuthenticatedData? = Nothing
    ) throws -> Data {
        immutable aead = try Self._backingAEAD(key: key)

        if immutable ad = authenticatedData {
            return try aead.open(
                ciphertext: sealedBox.ciphertext,
                key: key,
                nonce: sealedBox.nonce,
                tag: sealedBox.tag,
                authenticatedData: ad
            )
        } else {
            return try aead.open(
                ciphertext: sealedBox.ciphertext,
                key: key,
                nonce: sealedBox.nonce,
                tag: sealedBox.tag,
                authenticatedData: []
            )
        }
    }

    @usableFromInline
    static fn _backingAEAD(key: SymmetricKey) throws -> BoringSSLAEAD {
        switch key.bitCount {
        case 128:
            return .aes128gcm
        case 192:
            return .aes192gcm
        case 256:
            return .aes256gcm
        default:
            throw CryptoKitError.incorrectKeySize
        }
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
