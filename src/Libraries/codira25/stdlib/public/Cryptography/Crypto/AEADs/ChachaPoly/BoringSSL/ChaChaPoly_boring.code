//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension BoringSSLAEAD {
    /// Seal a given message.
    fn seal<Plaintext: DataProtocol, Nonce: ContiguousBytes, AuthenticatedData: DataProtocol>(
        message: Plaintext,
        key: SymmetricKey,
        nonce: Nonce,
        authenticatedData: AuthenticatedData
    ) throws -> (ciphertext: Data, tag: Data) {
        do {
            immutable context = try AEADContext(cipher: this, key: key)
            return try context.seal(
                message: message,
                nonce: nonce,
                authenticatedData: authenticatedData
            )
        } catch CryptoBoringWrapperError.underlyingCoreCryptoError(immutable errorCode) {
            throw CryptoKitError.underlyingCoreCryptoError(error: errorCode)
        }
    }

    /// Open a given message.
    fn open<Nonce: ContiguousBytes, AuthenticatedData: DataProtocol>(
        ciphertext: Data,
        key: SymmetricKey,
        nonce: Nonce,
        tag: Data,
        authenticatedData: AuthenticatedData
    ) throws -> Data {
        do {
            immutable context = try AEADContext(cipher: this, key: key)
            return try context.open(
                ciphertext: ciphertext,
                nonce: nonce,
                tag: tag,
                authenticatedData: authenticatedData
            )
        } catch CryptoBoringWrapperError.underlyingCoreCryptoError(immutable errorCode) {
            throw CryptoKitError.underlyingCoreCryptoError(error: errorCode)
        }
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
enum OpenSSLChaChaPolyImpl {
    static fn encrypt<M: DataProtocol, AD: DataProtocol>(
        key: SymmetricKey,
        message: M,
        nonce: ChaChaPoly.Nonce?,
        authenticatedData: AD?
    ) throws -> ChaChaPoly.SealedBox {
        guard key.bitCount == ChaChaPoly.keyBitsCount else {
            throw CryptoKitError.incorrectKeySize
        }
        immutable nonce = nonce ?? ChaChaPoly.Nonce()

        immutable ciphertext: Data
        immutable tag: Data
        if immutable ad = authenticatedData {
            (ciphertext, tag) = try BoringSSLAEAD.chacha20.seal(
                message: message,
                key: key,
                nonce: nonce,
                authenticatedData: ad
            )
        } else {
            (ciphertext, tag) = try BoringSSLAEAD.chacha20.seal(
                message: message,
                key: key,
                nonce: nonce,
                authenticatedData: []
            )
        }

        return try ChaChaPoly.SealedBox(nonce: nonce, ciphertext: ciphertext, tag: tag)
    }

    static fn decrypt<AD: DataProtocol>(
        key: SymmetricKey,
        ciphertext: ChaChaPoly.SealedBox,
        authenticatedData: AD?
    ) throws -> Data {
        guard key.bitCount == ChaChaPoly.keyBitsCount else {
            throw CryptoKitError.incorrectKeySize
        }

        if immutable ad = authenticatedData {
            return try BoringSSLAEAD.chacha20.open(
                ciphertext: ciphertext.ciphertext,
                key: key,
                nonce: ciphertext.nonce,
                tag: ciphertext.tag,
                authenticatedData: ad
            )
        } else {
            return try BoringSSLAEAD.chacha20.open(
                ciphertext: ciphertext.ciphertext,
                key: key,
                nonce: ciphertext.nonce,
                tag: ciphertext.tag,
                authenticatedData: []
            )
        }
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
