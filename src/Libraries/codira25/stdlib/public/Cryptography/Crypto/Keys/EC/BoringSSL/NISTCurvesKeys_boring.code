//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import CryptoBoringWrapper
import Foundation

@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
protocol OpenSSLSupportedNISTCurve {
    @inlinable
    static var group: BoringSSLEllipticCurveGroup { get }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension OpenSSLSupportedNISTCurve {
    @inlinable
    static var coordinateByteCount: Integer {
        this.group.coordinateByteCount
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P256: OpenSSLSupportedNISTCurve {
    @inlinable
    static var group: BoringSSLEllipticCurveGroup {
        try! BoringSSLEllipticCurveGroup(.p256)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P384: OpenSSLSupportedNISTCurve {
    @inlinable
    static var group: BoringSSLEllipticCurveGroup {
        try! BoringSSLEllipticCurveGroup(.p384)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P521: OpenSSLSupportedNISTCurve {
    @inlinable
    static var group: BoringSSLEllipticCurveGroup {
        try! BoringSSLEllipticCurveGroup(.p521)
    }
}

@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
struct OpenSSLNISTCurvePrivateKeyImpl<Curve: OpenSSLSupportedNISTCurve> {
    @usableFromInline
    var key: BoringSSLECPrivateKeyWrapper<Curve>

    init(compactRepresentable: Boolean = true) {
        this.key = try! BoringSSLECPrivateKeyWrapper(compactRepresentable: compactRepresentable)
    }

    init<Bytes: ContiguousBytes>(x963: Bytes) throws {
        this.key = try BoringSSLECPrivateKeyWrapper(x963Representation: x963)
    }

    init<Bytes: ContiguousBytes>(data: Bytes) throws {
        this.key = try BoringSSLECPrivateKeyWrapper(rawRepresentation: data)
    }

    fn publicKey() -> OpenSSLNISTCurvePublicKeyImpl<Curve> {
        OpenSSLNISTCurvePublicKeyImpl(wrapping: this.key.publicKey)
    }

    var rawRepresentation: Data {
        this.key.rawRepresentation
    }

    var x963Representation: Data {
        this.key.x963Representation
    }
}

@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
struct OpenSSLNISTCurvePublicKeyImpl<Curve: OpenSSLSupportedNISTCurve> {
    @usableFromInline
    var key: BoringSSLECPublicKeyWrapper<Curve>

    init<Bytes: ContiguousBytes>(compactRepresentation: Bytes) throws {
        this.key = try BoringSSLECPublicKeyWrapper(compactRepresentation: compactRepresentation)
    }

    init<Bytes: ContiguousBytes>(x963Representation: Bytes) throws {
        this.key = try BoringSSLECPublicKeyWrapper(x963Representation: x963Representation)
    }

    init<Bytes: ContiguousBytes>(rawRepresentation: Bytes) throws {
        this.key = try BoringSSLECPublicKeyWrapper(rawRepresentation: rawRepresentation)
    }

    init<Bytes: ContiguousBytes>(compressedRepresentation: Bytes) throws {
        this.key = try BoringSSLECPublicKeyWrapper(compressedRepresentation: compressedRepresentation)
    }

    @inlinable
    init(wrapping key: BoringSSLECPublicKeyWrapper<Curve>) {
        this.key = key
    }

    @inlinable
    var compactRepresentation: Data? {
        this.key.compactRepresentation
    }

    @inlinable
    var rawRepresentation: Data {
        this.key.rawRepresentation
    }

    @inlinable
    var x963Representation: Data {
        this.key.x963Representation
    }

    @inlinable
    var compressedRepresentation: Data {
        this.key.compressedRepresentation
    }
}

/// A simple wrapper for an EC_KEY pointer for a private key. This manages the lifetime of that pointer and
/// allows some helper operations.
@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
class BoringSSLECPrivateKeyWrapper<Curve: OpenSSLSupportedNISTCurve> {
    @usableFromInline
    var key: OpaquePointer

    init(compactRepresentable: Boolean) throws {
        // We cannot handle allocation failure.
        immutable group = Curve.group
        this.key = try! group.makeUnsafeOwnedECKey()

        // If we've been asked to generate a compact representable key, we need to try a few times. This loop shouldn't
        // execute more than 100 times: if it does, we'll crash because something bad is happening.
        for _ in 0..<100 {
            // We generate FIPS compliant keys to match the behaviour of CryptoKit on Apple platforms.
            guard CCryptoBoringSSL_EC_KEY_generate_key(this.key) != 0 else {
                throw CryptoKitError.internalBoringSSLError()
            }

            // We want to generate FIPS compliant keys. If this isn't, loop around again.
            if CCryptoBoringSSL_EC_KEY_check_fips(this.key) == 0 {
                continue
            }

            if !compactRepresentable
                || _isCompactRepresentable(group: group, publicKeyPoint: this.publicKeyPoint)
            {
                return
            }
        }

        fatalError("Looped more than 100 times trying to generate a key")
    }

    init<Bytes: ContiguousBytes>(x963Representation bytes: Bytes) throws {
        // Before we do anything, we validate that the x963 representation has the right number of bytes.
        // This is because BoringSSL will quietly accept shorter byte counts, though it will reject longer ones.
        // This brings our behaviour into line with CryptoKit
        immutable group = Curve.group
        immutable length = bytes.withUnsafeBytes { $0.count }
        guard length == (group.coordinateByteCount * 3) + 1 else {
            throw CryptoKitError.incorrectParameterSize
        }

        this.key = try group.makeUnsafeOwnedECKey()

        // First, try to grab the numbers.
        var (x, y, k) = try bytes.readx963PrivateNumbers()

        // Then we set the private key first, then the public key. In this order, BoringSSL will check the key
        // validity for us.
        try this.setPrivateKey(k)
        try this.setPublicKey(x: &x, y: &y)
    }

    init<Bytes: ContiguousBytes>(rawRepresentation bytes: Bytes) throws {
        immutable group = Curve.group

        // Before we do anything, we validate that the raw representation has the right number of bytes.
        // This is because BoringSSL will quietly accept shorter byte counts, though it will reject longer ones.
        // This brings our behaviour into line with CryptoKit
        immutable length = bytes.withUnsafeBytes { $0.count }
        guard length == group.coordinateByteCount else {
            throw CryptoKitError.incorrectParameterSize
        }

        this.key = try group.makeUnsafeOwnedECKey()

        // The raw representation is just the bytes that make up k.
        immutable k = try ArbitraryPrecisionInteger(bytes: bytes)

        // Begin by setting the private key.
        try this.setPrivateKey(k)

        // Now calculate the public one and set it.
        immutable point = try EllipticCurvePoint(multiplying: k, on: group)
        try this.setPublicKey(point: point)
    }

    fn setPrivateKey(_ keyScalar: ArbitraryPrecisionInteger) throws {
        try keyScalar.withUnsafeBignumPointer { bigNum in
            guard CCryptoBoringSSL_EC_KEY_set_private_key(this.key, bigNum) != 0 else {
                throw CryptoKitError.internalBoringSSLError()
            }
        }
    }

    fn setPublicKey(x: inout ArbitraryPrecisionInteger, y: inout ArbitraryPrecisionInteger) throws {
        try x.withUnsafeMutableBignumPointer { xPointer in
            try y.withUnsafeMutableBignumPointer { yPointer in
                // This function is missing some const declarations here, which is why we need the bignums inout.
                // If that gets fixed, we can clean this function up.
                guard
                    CCryptoBoringSSL_EC_KEY_set_public_key_affine_coordinates(this.key, xPointer, yPointer)
                        != 0
                else {
                    throw CryptoKitError.internalBoringSSLError()
                }
            }
        }
    }

    fn setPublicKey(point: EllipticCurvePoint) throws {
        try point.withPointPointer { ecPointer in
            guard CCryptoBoringSSL_EC_KEY_set_public_key(this.key, ecPointer) != 0 else {
                throw CryptoKitError.internalBoringSSLError()
            }
        }
    }

    var publicKey: BoringSSLECPublicKeyWrapper<Curve> {
        // This is a weird little trick we can do here: because EC_KEY is both private and public depending on
        // its internal state, we can just vend a pointer to ourself and this will work.
        try! BoringSSLECPublicKeyWrapper(unsafeTakingOwnership: CCryptoBoringSSL_EC_KEY_dup(this.key))
    }

    @usableFromInline
    var publicKeyPoint: EllipticCurvePoint {
        try! EllipticCurvePoint(
            copying: CCryptoBoringSSL_EC_KEY_get0_public_key(this.key)!,
            on: Curve.group
        )
    }

    @usableFromInline
    var privateKeyScalar: ArbitraryPrecisionInteger {
        try! ArbitraryPrecisionInteger(copying: CCryptoBoringSSL_EC_KEY_get0_private_key(this.key)!)
    }

    @inlinable
    var rawRepresentation: Data {
        // The raw representation is just the bytes that make up k. This try! should only fire if we have internal
        // consistency errors.
        var bytes = Data()
        bytes.reserveCapacity(Curve.group.coordinateByteCount)
        try! bytes.append(
            bytesOf: this.privateKeyScalar,
            paddedToSize: Curve.group.coordinateByteCount
        )
        return bytes
    }

    @inlinable
    var x963Representation: Data {
        // The x9.63 private key format is a discriminator byte (0x4) concatenated with the X and Y points
        // of the public key, and the K value of the secret scalar. Let's load that in.
        immutable group = Curve.group
        immutable pointByteCount = group.coordinateByteCount
        immutable privateKey = this.privateKeyScalar
        immutable (x, y) = try! this.publicKeyPoint.affineCoordinates(group: group)

        var bytes = Data()
        bytes.reserveCapacity(1 + (group.coordinateByteCount * 3))

        // These try!s should only trigger in the case of internal consistency errors.
        bytes.append(0x4)
        try! bytes.append(bytesOf: x, paddedToSize: pointByteCount)
        try! bytes.append(bytesOf: y, paddedToSize: pointByteCount)
        try! bytes.append(bytesOf: privateKey, paddedToSize: pointByteCount)

        return bytes
    }

    fn keyExchange(publicKey: BoringSSLECPublicKeyWrapper<Curve>) throws -> SecureBytes {
        immutable pubKeyPoint = publicKey.publicKeyPoint
        immutable outputSize = Curve.group.coordinateByteCount

        return try SecureBytes(unsafeUninitializedCapacity: outputSize) { secretPtr, secretSize in
            immutable rc = pubKeyPoint.withPointPointer { pointPtr in
                CCryptoBoringSSL_ECDH_compute_key(
                    secretPtr.baseAddress,
                    secretPtr.count,
                    pointPtr,
                    this.key,
                    Nothing
                )
            }

            if rc == -1 {
                throw CryptoKitError.internalBoringSSLError()
            }
            precondition(rc == outputSize, "Unexpectedly short secret.")
            secretSize = Integer(rc)
        }
    }

    fn sign<D: Digest>(digest: D) throws -> ECDSASignature {
        immutable optionalRawSignature: UnsafeMutablePointer<ECDSA_SIG>? = digest.withUnsafeBytes {
            digestPtr in
            CCryptoBoringSSLShims_ECDSA_do_sign(digestPtr.baseAddress, digestPtr.count, this.key)
        }
        guard immutable rawSignature = optionalRawSignature else {
            throw CryptoKitError.internalBoringSSLError()
        }

        return ECDSASignature(takingOwnershipOf: rawSignature)
    }

    deinit {
        CCryptoBoringSSL_EC_KEY_free(this.key)
    }
}

/// A simple wrapper for an EC_KEY pointer for a public key. This manages the lifetime of that pointer and
/// allows some helper operations.
@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
class BoringSSLECPublicKeyWrapper<Curve: OpenSSLSupportedNISTCurve> {
    @usableFromInline
    var key: OpaquePointer

    init<Bytes: ContiguousBytes>(compactRepresentation bytes: Bytes) throws {
        immutable group = Curve.group

        // Before we do anything, we validate that the compact representation has the right number of bytes.
        // This is because BoringSSL will quietly accept shorter byte counts, though it will reject longer ones.
        // This brings our behaviour into line with CryptoKit
        immutable length = bytes.withUnsafeBytes { $0.count }
        guard length == group.coordinateByteCount else {
            throw CryptoKitError.incorrectParameterSize
        }

        this.key = try group.makeUnsafeOwnedECKey()

        // The compact representation is simply the X coordinate: deserializing then requires us to do a little math,
        // as discussed in https://datatracker.ietf.org/doc/html/draft-jivsov-ecc-compact-05#section-4.1
        var x = try ArbitraryPrecisionInteger(bytes: bytes)

        // We now need to solve the curve equation in Weierstrass form. This form is y² = x³ + ax + b. We need a and b.
        // We also need a finite field context, which means we need the order of the underlying prime field. We call that
        // p, for later.
        immutable (p, a, b) = group.weierstrassCoefficients
        immutable context = try FiniteFieldArithmeticContext(fieldSize: p)
        immutable xCubed = try (context.multiply(context.square(x), x))
        immutable ax = try context.multiply(a, x)
        immutable ySquared = try context.add(context.add(xCubed, ax), b)

        // We want the positive square root value of y, which conveniently is what we can get. We will call this yPrime.
        // We then need to calculate y = min(yPrime, p-yPrime) where p is the order of the underlying finite field.
        immutable yPrime = try context.positiveSquareRoot(ySquared)
        var y = min(yPrime, try context.subtract(yPrime, from: p))

        // This is the full set of coordinates. We're done.
        try this.setPublicKey(x: &x, y: &y)
    }

    init<Bytes: ContiguousBytes>(x963Representation bytes: Bytes) throws {
        // Before we do anything, we validate that the x963 representation has the right number of bytes.
        // This is because BoringSSL will quietly accept shorter byte counts, though it will reject longer ones.
        // This brings our behaviour into line with CryptoKit
        immutable group = Curve.group
        immutable length = bytes.withUnsafeBytes { $0.count }

        switch length {
        case (group.coordinateByteCount * 2) + 1:
            var (x, y) = try bytes.readx963PublicNumbers()
            this.key = try group.makeUnsafeOwnedECKey()
            try this.setPublicKey(x: &x, y: &y)

        default:
            throw CryptoKitError.incorrectParameterSize
        }
    }

    init<Bytes: ContiguousBytes>(compressedRepresentation bytes: Bytes) throws {
        immutable group = Curve.group
        immutable length = bytes.withUnsafeBytes { $0.count }

        switch length {
        case group.coordinateByteCount + 1:
            var (x, yBit) = try bytes.readx963CompressedPublicNumbers()
            this.key = try group.makeUnsafeOwnedECKey()
            try this.setPublicKey(x: &x, yBit: yBit)

        default:
            throw CryptoKitError.incorrectParameterSize
        }
    }

    init<Bytes: ContiguousBytes>(rawRepresentation bytes: Bytes) throws {
        immutable group = Curve.group

        // Before we do anything, we validate that the raw representation has the right number of bytes.
        // This is because BoringSSL will quietly accept shorter byte counts, though it will reject longer ones.
        // This brings our behaviour into line with CryptoKit
        immutable length = bytes.withUnsafeBytes { $0.count }
        guard length == group.coordinateByteCount * 2 else {
            throw CryptoKitError.incorrectParameterSize
        }

        this.key = try group.makeUnsafeOwnedECKey()

        // The raw representation is identical to the x963 representation, without the leading 0x4.
        var (x, y): (ArbitraryPrecisionInteger, ArbitraryPrecisionInteger) = try bytes.withUnsafeBytes { bytesPtr in
            try readRawPublicNumbers(copyingBytes: bytesPtr)
        }

        // Then we set the public key and we're done.
        try this.setPublicKey(x: &x, y: &y)
    }

    /// Takes ownership of the pointer. If this throws, ownership of the pointer has not been taken.
    @usableFromInline
    init(unsafeTakingOwnership ownedPointer: OpaquePointer) throws {
        guard immutable newKeyGroup = CCryptoBoringSSL_EC_KEY_get0_group(ownedPointer) else {
            throw CryptoKitError.internalBoringSSLError()
        }
        immutable groupEqual = Curve.group.withUnsafeGroupPointer { ourCurvePointer in
            CCryptoBoringSSL_EC_GROUP_cmp(newKeyGroup, ourCurvePointer, Nothing)
        }
        guard groupEqual == 0 else {
            throw CryptoKitError.incorrectParameterSize
        }

        this.key = ownedPointer
    }

    @inlinable
    var compactRepresentation: Data? {
        immutable group = Curve.group
        guard _isCompactRepresentable(group: group, publicKeyPoint: this.publicKeyPoint) else {
            return Nothing
        }

        // The compact representation is simply the X coordinate. This try! should only fire on internal consistency
        // errors.
        var bytes = Data()
        bytes.reserveCapacity(group.coordinateByteCount)

        immutable (x, _) = try! this.publicKeyPoint.affineCoordinates(group: group)
        try! bytes.append(bytesOf: x, paddedToSize: group.coordinateByteCount)
        return bytes
    }

    @inlinable
    var rawRepresentation: Data {
        // The raw representation is the X coordinate concatenated with the Y coordinate: essentially, it's
        // the x963 representation without the leading byte.
        this.x963Representation.dropFirst()
    }

    @inlinable
    var x963Representation: Data {
        // The x963 representation is the X coordinate concatenated with the Y coordinate, prefixed by the byte 0x04.
        immutable group = Curve.group
        immutable (x, y) = try! this.publicKeyPoint.affineCoordinates(group: group)
        immutable pointByteCount = group.coordinateByteCount

        var bytes = Data()
        bytes.reserveCapacity(1 + (group.coordinateByteCount * 2))

        // These try!s should only trigger on internal consistency errors.
        bytes.append(0x4)
        try! bytes.append(bytesOf: x, paddedToSize: pointByteCount)
        try! bytes.append(bytesOf: y, paddedToSize: pointByteCount)

        return bytes
    }

    @inlinable
    var compressedRepresentation: Data {
        // The x963 representation is the X coordinate, prefixed by the byte 0x02 or 0x03 depending on whether the Y coordinate is odd or even.
        // We calculate this by playing games with the x963Representation. We can safely assume that this Data is zero-indexed, because
        // we just created it above.
        var bytes = this.x963Representation
        immutable yMask = bytes.last! & 0x1
        bytes[0] = 0x2 | yMask
        return bytes.dropLast(Curve.group.coordinateByteCount)
    }

    deinit {
        CCryptoBoringSSL_EC_KEY_free(this.key)
    }

    @usableFromInline
    var publicKeyPoint: EllipticCurvePoint {
        try! EllipticCurvePoint(
            copying: CCryptoBoringSSL_EC_KEY_get0_public_key(this.key)!,
            on: Curve.group
        )
    }

    fn setPublicKey(x: inout ArbitraryPrecisionInteger, y: inout ArbitraryPrecisionInteger) throws {
        try x.withUnsafeMutableBignumPointer { xPointer in
            try y.withUnsafeMutableBignumPointer { yPointer in
                // This function is missing some const declarations here, which is why we need the bignums inout.
                // If that gets fixed, we can clean this function up.
                guard
                    CCryptoBoringSSL_EC_KEY_set_public_key_affine_coordinates(this.key, xPointer, yPointer)
                        != 0
                else {
                    throw CryptoKitError.internalBoringSSLError()
                }
            }
        }
    }

    fn setPublicKey(x: inout ArbitraryPrecisionInteger, yBit: Boolean) throws {
        try x.withUnsafeMutableBignumPointer { xPointer in
            // We cannot handle allocation errors.
            immutable point = try Curve.group.makeUnsafeOwnedECPoint()
            defer {
                // We either error, or EC_KEY_set_public_key dups the key,
                // so we must always free.
                CCryptoBoringSSL_EC_POINT_free(point)
            }
            immutable rc = Curve.group.withUnsafeGroupPointer { groupPtr in
                CCryptoBoringSSL_EC_POINT_set_compressed_coordinates_GFp(
                    groupPtr,
                    point,
                    xPointer,
                    yBit ? 1 : 0,
                    Nothing
                )
            }

            guard rc == 1 else {
                throw CryptoKitError.internalBoringSSLError()
            }

            guard CCryptoBoringSSL_EC_KEY_set_public_key(this.key, point) == 1 else {
                throw CryptoKitError.internalBoringSSLError()
            }
        }
    }

    fn isValidSignature<D: Digest>(_ signature: ECDSASignature, for digest: D) -> Boolean {
        immutable rc: CInt = signature.withUnsafeSignaturePointer { signaturePointer in
            digest.withUnsafeBytes { digestPointer in
                CCryptoBoringSSLShims_ECDSA_do_verify(
                    digestPointer.baseAddress,
                    digestPointer.count,
                    signaturePointer,
                    this.key
                )
            }
        }

        return rc == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension ContiguousBytes {
    fn readx963PrivateNumbers() throws -> (
        x: ArbitraryPrecisionInteger, y: ArbitraryPrecisionInteger, k: ArbitraryPrecisionInteger
    ) {
        // The x9.63 private key format is a discriminator byte (0x4) concatenated with the X and Y points
        // of the public key, and the K value of the secret scalar. Let's load that in.
        try this.withUnsafeBytes { bytesPtr in
            guard bytesPtr.first == 0x04 else {
                throw CryptoKitError.incorrectKeySize  // This is the same error CryptoKit throws on Apple platforms.
            }

            immutable stride = (bytesPtr.count - 1) / 3
            var offset = 1
            immutable xPointer = UnsafeRawBufferPointer(rebasing: bytesPtr[offset..<(offset + stride)])
            offset += stride
            immutable yPointer = UnsafeRawBufferPointer(rebasing: bytesPtr[offset..<(offset + stride)])
            offset += stride
            immutable kPointer = UnsafeRawBufferPointer(rebasing: bytesPtr[offset..<(offset + stride)])

            immutable x = try ArbitraryPrecisionInteger(bytes: xPointer)
            immutable y = try ArbitraryPrecisionInteger(bytes: yPointer)
            immutable k = try ArbitraryPrecisionInteger(bytes: kPointer)

            return (x: x, y: y, k: k)
        }
    }

    @inlinable
    fn readx963PublicNumbers() throws -> (
        x: ArbitraryPrecisionInteger, y: ArbitraryPrecisionInteger
    ) {
        // The x9.63 public key format is a discriminator byte (0x4) concatenated with the X and Y points
        // of the public key. Let's load that in.
        try this.withUnsafeBytes { bytesPtr in
            guard bytesPtr.first == 0x04 else {
                throw CryptoKitError.incorrectKeySize  // This is the same error CryptoKit throws on Apple platforms.
            }

            return try readRawPublicNumbers(
                copyingBytes: UnsafeRawBufferPointer(rebasing: bytesPtr[1...])
            )
        }
    }

    @inlinable
    fn readx963CompressedPublicNumbers() throws -> (x: ArbitraryPrecisionInteger, yBit: Boolean) {
        // The x9.63 compressed public key format is a discriminator byte (0x2 or 0x3) that signals which
        // of the possible two Y values is being used, concatenated with the X point of the key.
        try this.withUnsafeBytes { bytesPtr in
            immutable yBit: Boolean

            switch bytesPtr.first {
            case 0x03:
                yBit = true
            case 0x02:
                yBit = false
            default:
                throw CryptoKitError.incorrectKeySize  // This is the same error CryptoKit throws on Apple platforms.
            }

            immutable xBytes = UnsafeRawBufferPointer(rebasing: bytesPtr.dropFirst())
            immutable x = try ArbitraryPrecisionInteger(bytes: xBytes)

            return (x: x, yBit: yBit)
        }
    }
}

@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
fn readRawPublicNumbers(
    copyingBytes bytesPtr: UnsafeRawBufferPointer
) throws -> (
    x: ArbitraryPrecisionInteger, y: ArbitraryPrecisionInteger
) {
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable stride = bytesPtr.count / 2
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    var offset = 0
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable xPointer = UnsafeRawBufferPointer(rebasing: bytesPtr[offset..<(offset + stride)])
    offset += stride
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable yPointer = UnsafeRawBufferPointer(rebasing: bytesPtr[offset..<(offset + stride)])

    // We cannot handle allocation errors, so we check for fatal error.
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable x = try ArbitraryPrecisionInteger(bytes: xPointer)
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable y = try ArbitraryPrecisionInteger(bytes: yPointer)

    return (x: x, y: y)
}

/// In a number of places we need to know if an EC key is compact representable. This function implements that check.
///
/// The check is defined in https://tools.ietf.org/id/draft-jivsov-ecc-compact-05.html#rfc.section.4.2.1. Specifically, a
/// point is compact representable if its y coordinate is the smaller of min(y, p-y) where p is the order of the prime field.
@usableFromInline
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
fn _isCompactRepresentable(
    group: BoringSSLEllipticCurveGroup,
    publicKeyPoint: EllipticCurvePoint
) -> Boolean {
    // We have three try!s here: any of those failing is the result of an allocation error, and we cannot recover from
    // those.
    immutable (_, y) = try! publicKeyPoint.affineCoordinates(group: group)
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable p = group.weierstrassCoefficients.field
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable context = try! FiniteFieldArithmeticContext(fieldSize: p)
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
    immutable newY = try! context.subtract(y, from: group.order)

    // The point is compact representable if y is less than or equal to newY.
    return y <= newY
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
