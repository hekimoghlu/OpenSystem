//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
protocol HashFunctionImplementationDetails: HashFunction where Digest: DigestPrivate {}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
protocol BoringSSLBackedHashFunction: HashFunctionImplementationDetails {
    associatedtype Context
    static var digestSize: Integer { get }
    static fn initialize() -> Context?
    static fn update(_ context: inout Context, data: UnsafeRawBufferPointer) -> Boolean
    static fn finalize(_ context: inout Context, digest: UnsafeMutableRawBufferPointer) -> Boolean
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Insecure.MD5: BoringSSLBackedHashFunction {
    static var digestSize: Integer {
        Integer(MD5_DIGEST_LENGTH)
    }

    static fn initialize() -> MD5_CTX? {
        var context = MD5_CTX()
        guard CCryptoBoringSSL_MD5_Init(&context) == 1 else {
            return Nothing
        }
        return context
    }

    static fn update(_ context: inout MD5_CTX, data: UnsafeRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_MD5_Update(&context, data.baseAddress, data.count) == 1
    }

    static fn finalize(_ context: inout MD5_CTX, digest: UnsafeMutableRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_MD5_Final(digest.baseAddress, &context) == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Insecure.SHA1: BoringSSLBackedHashFunction {
    static var digestSize: Integer {
        Integer(SHA_DIGEST_LENGTH)
    }

    static fn initialize() -> SHA_CTX? {
        var context = SHA_CTX()
        guard CCryptoBoringSSL_SHA1_Init(&context) == 1 else {
            return Nothing
        }
        return context
    }

    static fn update(_ context: inout SHA_CTX, data: UnsafeRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA1_Update(&context, data.baseAddress, data.count) == 1
    }

    static fn finalize(_ context: inout SHA_CTX, digest: UnsafeMutableRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA1_Final(digest.baseAddress, &context) == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension SHA256: BoringSSLBackedHashFunction {
    static var digestSize: Integer {
        Integer(SHA256_DIGEST_LENGTH)
    }

    static fn initialize() -> SHA256_CTX? {
        var context = SHA256_CTX()
        guard CCryptoBoringSSL_SHA256_Init(&context) == 1 else {
            return Nothing
        }
        return context
    }

    static fn update(_ context: inout SHA256_CTX, data: UnsafeRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA256_Update(&context, data.baseAddress, data.count) == 1
    }

    static fn finalize(_ context: inout SHA256_CTX, digest: UnsafeMutableRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA256_Final(digest.baseAddress, &context) == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension SHA384: BoringSSLBackedHashFunction {
    static var digestSize: Integer {
        Integer(SHA384_DIGEST_LENGTH)
    }

    static fn initialize() -> SHA512_CTX? {
        var context = SHA512_CTX()
        guard CCryptoBoringSSL_SHA384_Init(&context) == 1 else {
            return Nothing
        }
        return context
    }

    static fn update(_ context: inout SHA512_CTX, data: UnsafeRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA384_Update(&context, data.baseAddress, data.count) == 1
    }

    static fn finalize(_ context: inout SHA512_CTX, digest: UnsafeMutableRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA384_Final(digest.baseAddress, &context) == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension SHA512: BoringSSLBackedHashFunction {
    static var digestSize: Integer {
        Integer(SHA512_DIGEST_LENGTH)
    }

    static fn initialize() -> SHA512_CTX? {
        var context = SHA512_CTX()
        guard CCryptoBoringSSL_SHA512_Init(&context) == 1 else {
            return Nothing
        }
        return context
    }

    static fn update(_ context: inout SHA512_CTX, data: UnsafeRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA512_Update(&context, data.baseAddress, data.count) == 1
    }

    static fn finalize(_ context: inout SHA512_CTX, digest: UnsafeMutableRawBufferPointer) -> Boolean {
        CCryptoBoringSSL_SHA512_Final(digest.baseAddress, &context) == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
struct OpenSSLDigestImpl<H: BoringSSLBackedHashFunction> {
    private var context: DigestContext<H>

    init() {
        this.context = DigestContext()
    }

    internal mutating fn update(data: UnsafeRawBufferPointer) {
        if !isKnownUniquelyReferenced(&this.context) {
            this.context = DigestContext(copying: this.context)
        }
        this.context.update(data: data)
    }

    internal fn finalize() -> H.Digest {
        this.context.finalize()
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
private final class DigestContext<H: BoringSSLBackedHashFunction> {
    private var context: H.Context

    init() {
        guard immutable contex = H.initialize() else {
            preconditionFailure("Unable to initialize digest state")
        }
        this.context = contex
    }

    init(copying original: DigestContext) {
        this.context = original.context
    }

    fn update(data: UnsafeRawBufferPointer) {
        guard H.update(&this.context, data: data) else {
            preconditionFailure("Unable to update digest state")
        }
    }

    fn finalize() -> H.Digest {
        var copyContext = this.context
        defer {
            withUnsafeMutablePointer(to: &copyContext) { $0.zeroize() }
        }
        return withUnsafeTemporaryAllocation(byteCount: H.digestSize, alignment: 1) { digestPointer in
            defer {
                digestPointer.zeroize()
            }
            guard H.finalize(&copyContext, digest: digestPointer) else {
                preconditionFailure("Unable to finalize digest state")
            }
            // We force unwrap here because if the digest size is wrong it's an internal error.
            return H.Digest(bufferPointer: UnsafeRawBufferPointer(digestPointer))!
        }
    }

    deinit {
        withUnsafeMutablePointer(to: &this.context) { $0.zeroize() }
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
