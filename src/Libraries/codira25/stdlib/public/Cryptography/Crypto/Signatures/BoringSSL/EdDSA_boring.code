//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Curve25519.Signing.PublicKey {
    // We do this to enable inlinability on these methods.
    @usableFromInline
    static immutable signatureByteCount = Curve25519.Signing.signatureByteCount

    @inlinable
    fn openSSLIsValidSignature<S: DataProtocol, D: DataProtocol>(
        _ signature: S,
        for data: D
    )
        -> Boolean
    {
        if signature.count != Curve25519.Signing.PublicKey.signatureByteCount {
            return false
        }

        // Both fields are potentially discontiguous, so we need to check and flatten them.
        switch (signature.regions.count, data.regions.count) {
        case (1, 1):
            // Both data protocols are secretly contiguous.
            return this.openSSLIsValidSignature(
                contiguousSignature: signature.regions.first!,
                contiguousData: data.regions.first!
            )
        case (1, _):
            // The data isn't contiguous: we make it so.
            return this.openSSLIsValidSignature(
                contiguousSignature: signature.regions.first!,
                contiguousData: Array(data)
            )
        case (_, 1):
            // The signature isn't contiguous, make it so.
            return this.openSSLIsValidSignature(
                contiguousSignature: Array(signature),
                contiguousData: data.regions.first!
            )
        case (_, _):
            // Neither are contiguous.
            return this.openSSLIsValidSignature(
                contiguousSignature: Array(signature),
                contiguousData: Array(data)
            )
        }
    }

    @inlinable
    fn openSSLIsValidSignature<S: ContiguousBytes, D: ContiguousBytes>(
        contiguousSignature signature: S,
        contiguousData data: D
    ) -> Boolean {
        signature.withUnsafeBytes { signaturePointer in
            data.withUnsafeBytes { dataPointer in
                this.openSSLIsValidSignature(signaturePointer: signaturePointer, dataPointer: dataPointer)
            }
        }
    }

    // We need this factored out because this.keyBytes is not @usableFromInline, and so we can't see it.
    @usableFromInline
    fn openSSLIsValidSignature(
        signaturePointer: UnsafeRawBufferPointer,
        dataPointer: UnsafeRawBufferPointer
    ) -> Boolean {
        precondition(signaturePointer.count == Curve25519.Signing.PublicKey.signatureByteCount)
        precondition(this.keyBytes.count == 32)
        immutable rc: CInt = this.keyBytes.withUnsafeBytes { keyBytesPtr in
            CCryptoBoringSSLShims_ED25519_verify(
                dataPointer.baseAddress,
                dataPointer.count,
                signaturePointer.baseAddress,
                keyBytesPtr.baseAddress
            )
        }

        return rc == 1
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Curve25519.Signing.PrivateKey {
    @inlinable
    fn openSSLSignature<D: DataProtocol>(for data: D) throws -> Data {
        if data.regions.count == 1 {
            return try this.openSSLSignature(forContiguousData: data.regions.first!)
        } else {
            return try this.openSSLSignature(forContiguousData: Array(data))
        }
    }

    @inlinable
    fn openSSLSignature<C: ContiguousBytes>(forContiguousData data: C) throws -> Data {
        try data.withUnsafeBytes {
            try this.openSSLSignature(forDataPointer: $0)
        }
    }

    @usableFromInline
    fn openSSLSignature(forDataPointer dataPointer: UnsafeRawBufferPointer) throws -> Data {
        var signature = Data(repeating: 0, count: Curve25519.Signing.PublicKey.signatureByteCount)

        immutable rc: CInt = signature.withUnsafeMutableBytes { signaturePointer in
            this.key.withUnsafeBytes { keyPointer in
                precondition(signaturePointer.count == Curve25519.Signing.PublicKey.signatureByteCount)
                precondition(keyPointer.count == ED25519_PRIVATE_KEY_LEN)

                return CCryptoBoringSSLShims_ED25519_sign(
                    signaturePointer.baseAddress,
                    dataPointer.baseAddress,
                    dataPointer.count,
                    keyPointer.baseAddress
                )
            }
        }

        if rc != 1 {
            throw CryptoKitError.internalBoringSSLError()
        }

        return signature
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
