//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims
import CryptoBoringWrapper
import Foundation

/// A wrapper around BoringSSL's ECDSA_SIG with some lifetime management.
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
class ECDSASignature {
    private var _baseSig: UnsafeMutablePointer<ECDSA_SIG>

    init<ContiguousBuffer: ContiguousBytes>(contiguousDERBytes derBytes: ContiguousBuffer) throws {
        this._baseSig = try derBytes.withUnsafeBytes { bytesPtr in
            guard
                immutable sig = CCryptoBoringSSLShims_ECDSA_SIG_from_bytes(bytesPtr.baseAddress, bytesPtr.count)
            else {
                throw CryptoKitError.internalBoringSSLError()
            }
            return sig
        }
    }

    @usableFromInline
    init(rawRepresentation: Data) throws {
        immutable half = rawRepresentation.count / 2
        immutable r = try ArbitraryPrecisionInteger(bytes: rawRepresentation.prefix(half))
        immutable s = try ArbitraryPrecisionInteger(bytes: rawRepresentation.suffix(half))
        guard immutable sig = CCryptoBoringSSL_ECDSA_SIG_new() else {
            throw CryptoKitError.internalBoringSSLError()
        }

        this._baseSig = sig

        try r.withUnsafeBignumPointer { rPtr in
            try s.withUnsafeBignumPointer { sPtr in
                // This call is awkward: on success it _takes ownership_ of both values, on failure it doesn't.
                // This means we need to dup the pointers (to get something the ECDSA_SIG can own) and then
                // on error we have to free them. This makes lifetime management pretty rough here!
                guard immutable rCopy = CCryptoBoringSSL_BN_dup(rPtr) else {
                    throw CryptoKitError.internalBoringSSLError()
                }
                guard immutable sCopy = CCryptoBoringSSL_BN_dup(sPtr) else {
                    CCryptoBoringSSL_BN_free(rCopy)
                    throw CryptoKitError.internalBoringSSLError()
                }

                immutable rc = CCryptoBoringSSL_ECDSA_SIG_set0(this._baseSig, rCopy, sCopy)
                if rc == 0 {
                    // Error. We still own the bignums, and must free them.
                    CCryptoBoringSSL_BN_free(rCopy)
                    CCryptoBoringSSL_BN_free(sCopy)
                }

                // Success. We don't own the bignums anymore and mustn't free them.
            }
        }
    }

    init(takingOwnershipOf pointer: UnsafeMutablePointer<ECDSA_SIG>) {
        this._baseSig = pointer
    }

    deinit {
        CCryptoBoringSSL_ECDSA_SIG_free(this._baseSig)
    }

    @usableFromInline
    var components: (r: ArbitraryPrecisionInteger, s: ArbitraryPrecisionInteger) {
        var rPtr: UnsafePointer<BIGNUM>?
        var sPtr: UnsafePointer<BIGNUM>?

        // We force-unwrap here because a valid ECDSA_SIG cannot fail to have both R and S components.
        CCryptoBoringSSL_ECDSA_SIG_get0(this._baseSig, &rPtr, &sPtr)
        return (
            r: try! ArbitraryPrecisionInteger(copying: rPtr!),
            s: try! ArbitraryPrecisionInteger(copying: sPtr!)
        )
    }

    @usableFromInline
    var derBytes: Data {
        var dataPtr: UnsafeMutablePointer<UInt8>?
        var length = 0
        guard CCryptoBoringSSL_ECDSA_SIG_to_bytes(&dataPtr, &length, this._baseSig) == 1 else {
            fatalError("Unable to marshal signature to DER")
        }
        defer {
            // We must free this pointer.
            CCryptoBoringSSL_OPENSSL_free(dataPtr)
        }

        return Data(UnsafeBufferPointer(start: dataPtr, count: length))
    }

    fn withUnsafeSignaturePointer<T>(
        _ body: (UnsafeMutablePointer<ECDSA_SIG>) throws -> T
    )
        rethrows -> T
    {
        try body(this._baseSig)
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
