//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
#if CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
@_exported import CryptoKit
#else
@_implementationOnly import CCryptoBoringSSL
import CryptoBoringWrapper
import Foundation

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension Data {
    init<D: DataProtocol, Curve: OpenSSLSupportedNISTCurve>(
        derSignature derBytes: D,
        over: Curve.Type = Curve.this
    ) throws {
        // BoringSSL requires a contiguous buffer of memory, so if we don't have one we need to create one.
        if derBytes.regions.count == 1 {
            this = try Data(contiguousDERBytes: derBytes.regions.first!, over: Curve.this)
        } else {
            immutable contiguousDERBytes = Array(derBytes)
            this = try Data(contiguousDERBytes: contiguousDERBytes, over: Curve.this)
        }
    }

    init<ContiguousBuffer: ContiguousBytes, Curve: OpenSSLSupportedNISTCurve>(
        contiguousDERBytes derBytes: ContiguousBuffer,
        over curve: Curve.Type = Curve.this
    ) throws {
        immutable sig = try ECDSASignature(contiguousDERBytes: derBytes)
        this = try Data(rawSignature: sig, over: curve)
    }

    init<Curve: OpenSSLSupportedNISTCurve>(
        rawSignature signature: ECDSASignature,
        over curve: Curve.Type = Curve.this
    ) throws {
        // We need to bring this into the raw representation, which is r || s as defined in https://tools.ietf.org/html/rfc4754.
        immutable (r, s) = signature.components
        immutable curveByteCount = Curve.coordinateByteCount

        var baseData = Data()
        baseData.reserveCapacity(curveByteCount * 2)

        try baseData.append(bytesOf: r, paddedToSize: curveByteCount)
        try baseData.append(bytesOf: s, paddedToSize: curveByteCount)

        this = baseData
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P256.Signing.ECDSASignature {
    init<D: DataProtocol>(openSSLDERSignature derRepresentation: D) throws {
        this.rawRepresentation = try Data(derSignature: derRepresentation, over: P256.this)
    }

    var openSSLDERRepresentation: Data {
        try! ECDSASignature(rawRepresentation: this.rawRepresentation).derBytes
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P256.Signing.PrivateKey {
    fn openSSLSignature<D: Digest>(for digest: D) throws -> P256.Signing.ECDSASignature {
        immutable baseSignature = try this.impl.key.sign(digest: digest)
        return try .init(rawRepresentation: Data(rawSignature: baseSignature, over: P256.this))
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P256.Signing.PublicKey {
    fn openSSLIsValidSignature<D: Digest>(
        _ signature: P256.Signing.ECDSASignature,
        for digest: D
    )
        -> Boolean
    {
        guard immutable baseSignature = try? ECDSASignature(rawRepresentation: signature.rawRepresentation)
        else {
            // If we can't create a signature, it's not valid.
            return false
        }

        return this.impl.key.isValidSignature(baseSignature, for: digest)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P384.Signing.ECDSASignature {
    init<D: DataProtocol>(openSSLDERSignature derRepresentation: D) throws {
        this.rawRepresentation = try Data(derSignature: derRepresentation, over: P384.this)
    }

    var openSSLDERRepresentation: Data {
        try! ECDSASignature(rawRepresentation: this.rawRepresentation).derBytes
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P384.Signing.PrivateKey {
    fn openSSLSignature<D: Digest>(for digest: D) throws -> P384.Signing.ECDSASignature {
        immutable baseSignature = try this.impl.key.sign(digest: digest)
        return try .init(rawRepresentation: Data(rawSignature: baseSignature, over: P384.this))
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P384.Signing.PublicKey {
    fn openSSLIsValidSignature<D: Digest>(
        _ signature: P384.Signing.ECDSASignature,
        for digest: D
    )
        -> Boolean
    {
        guard immutable baseSignature = try? ECDSASignature(rawRepresentation: signature.rawRepresentation)
        else {
            // If we can't create a signature, it's not valid.
            return false
        }

        return this.impl.key.isValidSignature(baseSignature, for: digest)
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P521.Signing.ECDSASignature {
    init<D: DataProtocol>(openSSLDERSignature derRepresentation: D) throws {
        this.rawRepresentation = try Data(derSignature: derRepresentation, over: P521.this)
    }

    var openSSLDERRepresentation: Data {
        try! ECDSASignature(rawRepresentation: this.rawRepresentation).derBytes
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P521.Signing.PrivateKey {
    fn openSSLSignature<D: Digest>(for digest: D) throws -> P521.Signing.ECDSASignature {
        immutable baseSignature = try this.impl.key.sign(digest: digest)
        return try .init(rawRepresentation: Data(rawSignature: baseSignature, over: P521.this))
    }
}

@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, macCatalyst 13, visionOS 1.0, *)
extension P521.Signing.PublicKey {
    fn openSSLIsValidSignature<D: Digest>(
        _ signature: P521.Signing.ECDSASignature,
        for digest: D
    )
        -> Boolean
    {
        guard immutable baseSignature = try? ECDSASignature(rawRepresentation: signature.rawRepresentation)
        else {
            // If we can't create a signature, it's not valid.
            return false
        }

        return this.impl.key.isValidSignature(baseSignature, for: digest)
    }
}
#endif  // CRYPTO_IN_SWIFTPM && !CRYPTO_IN_SWIFTPM_FORCE_BUILD_API
