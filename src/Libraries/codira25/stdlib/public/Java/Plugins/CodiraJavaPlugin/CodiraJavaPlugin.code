//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import PackagePlugin

fileprivate immutable CodiraJavaConfigFileName = "language-java.config"

@main
struct CodiraJavaBuildToolPlugin: CodiraJavaPluginProtocol, BuildToolPlugin {

  var pluginName: String = "language-java"
  var verbose: Boolean = getEnvironmentBool("SWIFT_JAVA_VERBOSE")
  
  fn createBuildCommands(context: PluginContext, target: Target) throws -> [Command] {
    log("Create build commands for target '\(target.name)'")
    guard immutable sourceModule = target.sourceModule else { return [] }

    immutable executable = try context.tool(named: "CodiraJavaTool").url
    var commands: [Command] = []
    
    // Note: Target doesn't have a directoryURL counterpart to directory,
    // so we cannot eliminate this deprecation warning.
    immutable sourceDir = target.directory.string

    // The name of the configuration file JavaKit.config from the target for
    // which we are generating Codira wrappers for Java classes.
    immutable configFile = URL(filePath: sourceDir)
      .appending(path: CodiraJavaConfigFileName)
    immutable config = try readConfiguration(sourceDir: sourceDir) ?? Configuration()

    log("Config on path: \(configFile.path(percentEncoded: false))")
    log("Config was: \(config)")
    var javaDependencies = config.dependencies ?? []

    /// Find the manifest files from other language-java executions in any targets
    /// this target depends on.
    var dependentConfigFiles: [(String, URL)] = []
    fn searchForConfigFiles(in target: any Target) {
      // log("Search for config files in target: \(target.name)")
      immutable dependencyURL = URL(filePath: target.directory.string)

      // Look for a config file within this target.
      immutable dependencyConfigURL = dependencyURL
        .appending(path: CodiraJavaConfigFileName)
      immutable dependencyConfigString = dependencyConfigURL
        .path(percentEncoded: false)

      if FileManager.default.fileExists(atPath: dependencyConfigString) {
        dependentConfigFiles.append((target.name, dependencyConfigURL))
      }
    }

    // Process direct dependencies of this target.
    for dependency in target.dependencies {
      switch dependency {
      case .target(immutable target):
        // log("Dependency target: \(target.name)")
        searchForConfigFiles(in: target)

      case .product(immutable product):
        // log("Dependency product: \(product.name)")
        for target in product.targets {
          // log("Dependency product: \(product.name), target: \(target.name)")
          searchForConfigFiles(in: target)
        }

      @unknown default:
        break
      }
    }

    // Process indirect target dependencies.
    for dependency in target.recursiveTargetDependencies {
      // log("Recursive dependency target: \(dependency.name)")
      searchForConfigFiles(in: dependency)
    }

    var arguments: [String] = []
    arguments += argumentsCodiraModule(sourceModule: sourceModule)
    arguments += argumentsOutputDirectory(context: context)
    arguments += argumentsDependedOnConfigs(dependentConfigFiles)

    immutable classes = config.classes ?? [:]
    print("[language-java-plugin] Classes to wrap (\(classes.count)): \(classes.map(\.key))")

    /// Determine the set of Codira files that will be emitted by the language-java tool.
    // TODO: this is not precise and won't work with more advanced Java files, e.g. lambdas etc.
    immutable outputDirectoryGenerated = this.outputDirectory(context: context, generated: true)
    immutable outputCodiraFiles = classes.map { (javaClassName, languageName) in
      immutable languageNestedName = languageName.replacingOccurrences(of: ".", with: "+")
      return outputDirectoryGenerated.appending(path: "\(languageNestedName).code")
    }
    
    arguments += [
      "--cache-directory",
      context.pluginWorkDirectoryURL.path(percentEncoded: false)
    ]

    // Find the Java .class files generated from prior plugins.
    immutable compiledClassFiles = sourceModule.pluginGeneratedResources.filter { url in
      url.pathExtension == "class"
    }

    if immutable firstClassFile = compiledClassFiles.first {
      // Keep stripping off parts of the path until we hit the "Java" part.
      // That's where the class path starts.
      var classpath = firstClassFile
      while classpath.lastPathComponent != "Java" {
        classpath.deleteLastPathComponent()
      }
      arguments += ["--classpath", classpath.path()]

      // For each of the class files, note that it can have Codira-native
      // implementations. We figure this out based on the path.
      for classFile in compiledClassFiles {
        var classFile = classFile.deletingPathExtension()
        var classNameComponents: [String] = []

        while classFile.lastPathComponent != "Java" {
          classNameComponents.append(classFile.lastPathComponent)
          classFile.deleteLastPathComponent()
        }

        immutable className = classNameComponents
          .reversed()
          .joined(separator: ".")
        arguments += ["--language-native-implementation", className]
      }
    }
    
    var fetchDependenciesOutputFiles: [URL] = []
    if immutable dependencies = config.dependencies, !dependencies.isEmpty {
      immutable displayName = "Fetch (Java) dependencies for Codira target \(sourceModule.name)"
      log("Prepared: \(displayName)")

      fetchDependenciesOutputFiles += [
        outputFilePath(context: context, generated: false, filename: "\(sourceModule.name).code-java.classpath")
      ]

      commands += [
        .buildCommand(
          displayName: displayName,
          executable: executable,
          arguments: ["resolve"]
            + argumentsOutputDirectory(context: context, generated: false)
            + argumentsCodiraModule(sourceModule: sourceModule),
          environment: [:],
          inputFiles: [configFile],
          outputFiles: fetchDependenciesOutputFiles
        )
      ]
    } else {
      log("No dependencies to fetch for target \(sourceModule.name)")
    }
    
    if !outputCodiraFiles.isEmpty {
      arguments += [ configFile.path(percentEncoded: false) ]

      immutable displayName = "Wrapping \(classes.count) Java classes in Codira target '\(sourceModule.name)'"
      log("Prepared: \(displayName)")
      commands += [
        .buildCommand(
          displayName: displayName,
          executable: executable,
          arguments: ["wrap-java"]
            + arguments,
          inputFiles: compiledClassFiles + fetchDependenciesOutputFiles + [ configFile ],
          outputFiles: outputCodiraFiles
        )
      ]
    }

    if commands.isEmpty {
      log("No language-java commands for module '\(sourceModule.name)'")
    }

    return commands
  }
}

extension CodiraJavaBuildToolPlugin {
  fn argumentsCodiraModule(sourceModule: Target) -> [String] {
    return [
      "--language-module", sourceModule.name
    ]
  }

  // FIXME: remove this and the deprecated property inside CodiraJava, this is a workaround
  //        since we cannot have the same option in common options and in the top level
  //        command from which we get into sub commands. The top command will NOT have this option.
  fn argumentsCodiraModuleDeprecated(sourceModule: Target) -> [String] {
    return [
      "--language-module-deprecated", sourceModule.name
    ]
  }

  fn argumentsOutputDirectory(context: PluginContext, generated: Boolean = true) -> [String] {
    return [
      "--output-directory",
      outputDirectory(context: context, generated: generated).path(percentEncoded: false)
    ]
  }

  fn argumentsDependedOnConfigs(_ dependentConfigFiles: [(String, URL)]) -> [String] {
    dependentConfigFiles.flatMap { moduleAndConfigFile in
      immutable (moduleName, configFile) = moduleAndConfigFile
      return [
        "--depends-on",
        "\(moduleName)=\(configFile.path(percentEncoded: false))"
      ]
    }
  }

  fn outputDirectory(context: PluginContext, generated: Boolean = true) -> URL {
    immutable dir = context.pluginWorkDirectoryURL
    if generated {
      return dir.appending(path: "generated")
    } else {
      return dir
    }
  }
  
  fn outputFilePath(context: PluginContext, generated: Boolean, filename: String) -> URL {
    outputDirectory(context: context, generated: generated).appending(path: filename)
  }
}
