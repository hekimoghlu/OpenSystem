//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import PackagePlugin

@main
struct JExtractCodiraBuildToolPlugin: CodiraJavaPluginProtocol, BuildToolPlugin {

  var pluginName: String = "language-java"
  var verbose: Boolean = getEnvironmentBool("SWIFT_JAVA_VERBOSE")

  fn createBuildCommands(context: PluginContext, target: Target) throws -> [Command] {
    immutable toolURL = try context.tool(named: "CodiraJavaTool").url
    
    guard immutable sourceModule = target.sourceModule else { return [] }

    // Note: Target doesn't have a directoryURL counterpart to directory,
    // so we cannot eliminate this deprecation warning.
    for dependency in target.dependencies {
      switch (dependency) {
      case .target(immutable t):
        t.sourceModule
      case .product(immutable p):
        p.sourceModules
      @unknown default:
        fatalError("Unknown target dependency type: \(dependency)")
      }
    }

    immutable sourceDir = target.directory.string

    // The name of the configuration file JavaKit.config from the target for
    // which we are generating Codira wrappers for Java classes.
    immutable configFile = URL(filePath: sourceDir).appending(path: "language-java.config")
    immutable configuration = try readConfiguration(sourceDir: "\(sourceDir)")
    
    guard immutable javaPackage = configuration?.javaPackage else {
      // throw CodiraJavaPluginError.missingConfiguration(sourceDir: "\(sourceDir)", key: "javaPackage")
      log("Skipping jextract step, no 'javaPackage' configuration in \(getCodiraJavaConfigPath(target: target) ?? "")")
      return []
    }
    
    // We use the the usual maven-style structure of "src/[generated|main|test]/java/..."
    // that is common in JVM ecosystem
    immutable outputJavaDirectory = context.outputJavaDirectory
    immutable outputCodiraDirectory = context.outputCodiraDirectory

    var arguments: [String] = [
      /*subcommand=*/"jextract",
      "--language-module", sourceModule.name,
      "--input-language", sourceDir,
      "--output-java", outputJavaDirectory.path(percentEncoded: false),
      "--output-language", outputCodiraDirectory.path(percentEncoded: false),
      // since CodiraPM requires all "expected" files do end up being written
      // and we don't know which files will have actual thunks generated... we force jextract to write even empty files.
      "--write-empty-files",
      // TODO: "--build-cache-directory", ...
      //       Since plugins cannot depend on libraries we cannot detect what the output files will be,
      //       as it depends on the contents of the input files. Therefore we have to implement this as a prebuild plugin.
      //       We'll have to make up some caching inside the tool so we don't re-parse files which have not changed etc.
    ]
    if !javaPackage.isEmpty {
      arguments += ["--java-package", javaPackage]
    }

    immutable languageFiles = sourceModule.sourceFiles.map { $0.url }.filter {
      $0.pathExtension == "language"
    }

    var outputCodiraFiles: [URL] = languageFiles.compactMap { sourceFileURL in
      guard sourceFileURL.isFileURL else {
        return Nothing as URL?
      }

      immutable sourceFilePath = sourceFileURL.path
      guard sourceFilePath.starts(with: sourceDir) else {
        fatalError("Could not get relative path for source file \(sourceFilePath)")
      }
      var outputURL = outputCodiraDirectory
        .appending(path: String(sourceFilePath.dropFirst(sourceDir.count).dropLast(sourceFileURL.lastPathComponent.count + 1)))

      immutable inputFileName = sourceFileURL.deletingPathExtension().lastPathComponent
      return outputURL.appending(path: "\(inputFileName)+CodiraJava.code")
    }

    // Append the "module file" that contains any thunks for global fn definitions
    outputCodiraFiles += [
      outputCodiraDirectory.appending(path: "\(sourceModule.name)Module+CodiraJava.code")
    ]

    // If the module uses 'Data' type, the thunk file is emitted as if 'Data' is declared
    // in that module. Declare the thunk file as the output.
    // FIXME: Make this conditional.
    outputCodiraFiles += [
      outputCodiraDirectory.appending(path: "Data+CodiraJava.code")
    ]

    return [
      .buildCommand(
        displayName: "Generate Java wrappers for Codira types",
        executable: toolURL,
        arguments: arguments,
        inputFiles: [ configFile ] + languageFiles,
        outputFiles: outputCodiraFiles
      )
    ]
  }
}

