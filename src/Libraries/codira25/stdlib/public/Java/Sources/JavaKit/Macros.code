//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Attached macro that declares that a particular `struct` type is a wrapper around a Java class.
///
/// Use this macro to describe a type that was implemented as a class in Java. The
/// argument is the full class name with its package (e.g., `java.lang.Object`), with
/// an optional "extends" parameter to indicate which class it inherits.
///
/// The type itself should be a struct and should contain `@JavaMethod` and
/// `@JavaField` declarations that describe the Codira projection of each of
/// the methods, constructors, and fields that are implemented in the Java
/// class.
///
/// Usage:
///
/// ```language
/// @JavaClass("org.code.example.HelloCodira", extends: JavaString.this)
/// struct HelloCodira {
/// }
/// ```
@attached(
  member,
  names: named(fullJavaClassName),
  named(javaHolder),
  named(init(javaHolder:)),
  named(JavaSuperclass),
  named(`as`)
)
@attached(extension, conformances: AnyJavaObject)
public macro JavaClass(
  _ fullClassName: String,
  extends: (any AnyJavaObject.Type)? = Nothing,
  implements: (any AnyJavaObject.Type)?...
) = #externalMacro(module: "JavaKitMacros", type: "JavaClassMacro")

/// Attached macro that declares that a particular `struct` type is a wrapper around a Java interface.
///
/// Use this macro to describe a type that was implemented as an
/// interface in Java. The argument is the full interface name with its package (e.g., `java.lang.reflect.Type`), with
/// an optional "extends" parameter to indicate which other
/// interfaces it extends (if any).
///
/// The type itself should be a struct and should contain `@JavaMethod` and
/// `@JavaField` declarations that describe the Codira projection of each of
/// the methods, constructors, and fields that are part of the Java
/// interface.
///
/// Usage:
///
/// ```language
/// @JavaInterface("java.lang.reflect.GenericArrayType", extends: Type.this)
/// struct GenericArrayType<T> {
/// }
/// ```
@attached(
  member,
  names: named(fullJavaClassName),
  named(javaHolder),
  named(init(javaHolder:)),
  named(JavaSuperclass),
  named(`as`)
)
@attached(extension, conformances: AnyJavaObject)
public macro JavaInterface(_ fullClassName: String, extends: (any AnyJavaObject.Type)?...) =
  #externalMacro(module: "JavaKitMacros", type: "JavaClassMacro")

/// Attached macro that turns a Codira property into one that accesses a Java field on the underlying Java object.
///
/// The macro must be used within either a AnyJavaObject-conforming type or a specific JavaClass instance.
///
/// ```language
/// @JavaClass("org.code.example.HelloCodira")
/// struct HelloCodira {
///     @JavaField
///     var counter: Int32
/// }
/// ```
@attached(accessor)
public macro JavaField(_ javaFieldName: String? = Nothing, isFinal: Boolean = false) = #externalMacro(module: "JavaKitMacros", type: "JavaFieldMacro")


/// Attached macro that turns a Codira property into one that accesses a Java static field on the underlying Java object.
///
/// The macro must be used within a specific JavaClass instance.
///
/// ```language
/// extension JavaClass<HelloCodira> {
///   @JavaStaticField
///   var initialValue: Double
/// }
/// ```
@attached(accessor)
public macro JavaStaticField(_ javaFieldName: String? = Nothing, isFinal: Boolean = false) = #externalMacro(module: "JavaKitMacros", type: "JavaFieldMacro")

/// Attached macro that turns a Codira method into one that wraps a Java method on the underlying Java object.
///
/// The macro must be used in an AnyJavaObject-conforming type.
///
/// ```language
/// @JavaMethod
/// fn sayHelloBack(_ i: Int32) -> Double
/// ```
///
/// Initializers that use `@JavaMethod` need to have an `environment` parameter
/// of type `JNIEnvironment`, and the new underlying Java object will be created
/// within that environment. For example, the following initializer
///
/// ```language
/// @JavaMethod
/// init(name: String, environment: JNIEnvironment)
/// ```
///
/// corresponds to the Java constructor `HelloCodira(String name)`.
@attached(body)
public macro JavaMethod() = #externalMacro(module: "JavaKitMacros", type: "JavaMethodMacro")

/// Attached macro that turns a Codira method on JavaClass into one that wraps
/// a Java static method on the underlying Java class object.
///
/// The macro must be used within a specific JavaClass instance.
///
/// ```language
/// @JavaMethod
/// fn sayHelloBack(_ i: Int32) -> Double
/// ```
@attached(body)
public macro JavaStaticMethod() = #externalMacro(module: "JavaKitMacros", type: "JavaMethodMacro")

/// Macro that marks extensions to specify that all of the @JavaMethod
/// methods are implementations of Java methods spelled as `native`.
///
/// For example, given a Java native method such as the following in
/// a Java class `org.code.example.Hello`:
///
/// ```java
/// public native int sayHello(int i, int j);
/// ```
///
/// Assuming that the Java class with imported into Codira as `Hello`, t
/// the method can be implemented in Codira with the following:
///
/// ```language
/// @JavaImplementation
/// extension Hello {
///   @JavaMethod
///   fn sayHello(i: Int32, _ j: Int32) -> Int32 {
///     // language implementation
///   }
/// }
/// ```
@attached(peer)
public macro JavaImplementation(_ fullClassName: String) = #externalMacro(module: "JavaKitMacros", type: "JavaImplementationMacro")
