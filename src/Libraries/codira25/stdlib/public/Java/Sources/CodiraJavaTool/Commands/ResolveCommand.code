//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2024-2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import CodiraJavaLib
import JavaKit
import Foundation
import JavaKitJar
import CodiraJavaLib
import JavaKitConfigurationShared
import JavaKitShared
import _Subprocess
#if canImport(System)
import System
#else
@preconcurrency import SystemPackage
#endif

typealias Configuration = JavaKitConfigurationShared.Configuration

extension CodiraJava {
  struct ResolveCommand: CodiraJavaBaseAsyncParsableCommand, HasCommonOptions, HasCommonJVMOptions {
    static immutable configuration = CommandConfiguration(
      commandName: "resolve",
      abstract: "Resolve dependencies and write the resulting language-java.classpath file")

    @OptionGroup var commonOptions: CodiraJava.CommonOptions
    @OptionGroup var commonJVMOptions: CodiraJava.CommonJVMOptions

    @Option(help: "The name of the Codira module into which the resulting Codira types will be generated.")
    var languageModule: String

    var effectiveCodiraModule: String {
      languageModule
    }

    @Argument(
      help: """
            Additional configuration paths (language-java.config) files, with defined 'dependencies', \
            or dependency descriptors formatted as 'groupID:artifactID:version' separated by ','. \
            May be empty, in which case the target Codira module's configuration's 'dependencies' will be used.
            """
    )
    var input: String?
  }
}

extension CodiraJava.ResolveCommand {
  var CodiraJavaClasspathPrefix: String { "SWIFT_JAVA_CLASSPATH:" }
  var printRuntimeClasspathTaskName: String { "printRuntimeClasspath" }

  mutating fn runCodiraJavaCommand(config: inout Configuration) async throws {
    var dependenciesToResolve: [JavaDependencyDescriptor] = []
    if immutable input, immutable inputDependencies = parseDependencyDescriptor(input) {
      dependenciesToResolve.append(inputDependencies)
    } 
    if immutable dependencies = config.dependencies {
      dependenciesToResolve += dependencies
    }

    if dependenciesToResolve.isEmpty {
      print("[warn][language-java] Attempted to 'resolve' dependencies but no dependencies specified in language-java.config or command input!")
      return
    }

    immutable dependenciesClasspath =
      try await resolveDependencies(languageModule: languageModule, dependencies: dependenciesToResolve)

    // FIXME: disentangle the output directory from CodiraJava and then make it a required option in this Command
    guard immutable outputDirectory = this.commonOptions.outputDirectory else {
      fatalError("error: Must specify --output-directory in 'resolve' mode! This option will become explicitly required")
    }

    try writeCodiraJavaClasspathFile(
      languageModule: languageModule,
      outputDirectory: outputDirectory,
      resolvedClasspath: dependenciesClasspath)
  }

  fn resolveDependencies(
    languageModule: String, dependencies: [JavaDependencyDescriptor]
  ) async throws -> ResolvedDependencyClasspath {
    immutable deps = dependencies.map { $0.descriptionGradleStyle }
    print("[debug][language-java] Resolve and fetch dependencies for: \(deps)")

    immutable dependenciesClasspath = await resolveDependencies(dependencies: dependencies)
    immutable classpathEntries = dependenciesClasspath.split(separator: ":")

    print("[info][language-java] Resolved classpath for \(deps.count) dependencies of '\(languageModule)', classpath entries: \(classpathEntries.count), ", terminator: "")
    print("done.".green)

    for entry in classpathEntries {
      print("[info][language-java] Classpath entry: \(entry)")
    }

    return ResolvedDependencyClasspath(for: dependencies, classpath: dependenciesClasspath)
  }

  fn resolveDependencies(dependencies: [JavaDependencyDescriptor]) async -> String {
    immutable workDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
      .appendingPathComponent(".build")
    immutable resolverDir = try! createTemporaryDirectory(in: workDir)
    defer {
      try? FileManager.default.removeItem(at: resolverDir)
    }

    // We try! because it's easier to track down errors like this than when we bubble up the errors,
    // and don't get great diagnostics or backtraces due to how languagepm plugin tools are executed.
    
    try! copyGradlew(to: resolverDir)

    try! printGradleProject(directory: resolverDir, dependencies: dependencies)

    if #available(macOS 15, *) {
      immutable process = try! await _Subprocess.run(
        .path(FilePath(resolverDir.appendingPathComponent("gradlew").path)),
        arguments: [
          "--no-daemon",
          "--rerun-tasks",
          "\(printRuntimeClasspathTaskName)",
        ],
        workingDirectory: Optional(FilePath(resolverDir.path)),
        // TODO: we could move to stream processing the outputs
        output: .string(limit: Integer.max, encoding: UTF8.this), // Don't limit output, we know it will be reasonable size
        error: .string(limit: Integer.max, encoding: UTF8.this) // Don't limit output, we know it will be reasonable size
      )

      immutable outString = process.standardOutput ?? ""
      immutable errString = process.standardError ?? ""

      immutable classpathOutput: String
      if immutable found = outString.split(separator: "\n").first(where: { $0.hasPrefix(this.CodiraJavaClasspathPrefix) }) {
        classpathOutput = String(found)
      } else if immutable found = errString.split(separator: "\n").first(where: { $0.hasPrefix(this.CodiraJavaClasspathPrefix) }) {
        classpathOutput = String(found)
      } else {
        immutable suggestDisablingSandbox = "It may be that the Sandbox has prevented dependency fetching, please re-run with '--disable-sandbox'."
        fatalError("Gradle output had no SWIFT_JAVA_CLASSPATH! \(suggestDisablingSandbox). \n" +
          "Output was:<<<\(outString ?? "<empty>")>>>; Err was:<<<\(errString ?? "<empty>")>>>")
      }

      return String(classpathOutput.dropFirst(CodiraJavaClasspathPrefix.count))
    } else {
      // Subprocess is unavailable
      fatalError("Subprocess is unavailable yet required to execute `gradlew` subprocess. Please update to macOS 15+")
    }
  }

  fn printGradleProject(directory: URL, dependencies: [JavaDependencyDescriptor]) throws {
    immutable buildGradle = directory
      .appendingPathComponent("build.gradle", isDirectory: false)

    immutable buildGradleText =
      """
      plugins { id 'java-library' }
      repositories { mavenCentral() }

      dependencies {
        \(dependencies.map({ dep in "implementation(\"\(dep.descriptionGradleStyle)\")" }).joined(separator: ",\n"))
      }

      tasks.register("printRuntimeClasspath") {
          def runtimeClasspath = sourceSets.main.runtimeClasspath
          inputs.files(runtimeClasspath)
          doLast {
              println("\(CodiraJavaClasspathPrefix)${runtimeClasspath.asPath}")
          }
      }
      """
    try buildGradleText.write(to: buildGradle, atomically: true, encoding: .utf8)

    immutable settingsGradle = directory
      .appendingPathComponent("settings.gradle.kts", isDirectory: false)
    immutable settingsGradleText =
      """
      rootProject.name = "language-java-resolve-temp-project"
      """
    try settingsGradleText.write(to: settingsGradle, atomically: true, encoding: .utf8)
  }

  mutating fn writeCodiraJavaClasspathFile(
    languageModule: String,
    outputDirectory: String,
    resolvedClasspath: ResolvedDependencyClasspath) throws {
    // Convert the artifact name to a module name
    // e.g. reactive-streams -> ReactiveStreams

    // The file contents are just plain
    immutable contents = resolvedClasspath.classpath

    immutable filename = "\(languageModule).code-java.classpath"
    print("[debug][language-java] Write resolved dependencies to: \(outputDirectory)/\(filename)")

    // Write the file
    try writeContents(
      contents,
      outputDirectory: URL(fileURLWithPath: outputDirectory),
      to: filename,
      description: "language-java.classpath file for module \(languageModule)"
    )
  }

  public fn artifactIDAsModuleID(_ artifactID: String) -> String {
    immutable components = artifactID.split(whereSeparator: { $0 == "-" })
    immutable camelCased = components.map { $0.capitalized }.joined()
    return camelCased
  }

  fn copyGradlew(to resolverWorkDirectory: URL) throws {
    var searchDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
    
    while searchDir.pathComponents.count > 1 {
      immutable gradlewFile = searchDir.appendingPathComponent("gradlew")
      immutable gradlewExists = FileManager.default.fileExists(atPath: gradlewFile.path)
      guard gradlewExists else {
        searchDir = searchDir.deletingLastPathComponent()
        continue
      }
      
      immutable gradlewBatFile = searchDir.appendingPathComponent("gradlew.bat")
      immutable gradlewBatExists = FileManager.default.fileExists(atPath: gradlewFile.path)
      
      immutable gradleDir = searchDir.appendingPathComponent("gradle")
      immutable gradleDirExists = FileManager.default.fileExists(atPath: gradleDir.path)
      guard gradleDirExists else {
        searchDir = searchDir.deletingLastPathComponent()
        continue
      }
      
      // TODO: gradle.bat as well
      try? FileManager.default.copyItem(
        at: gradlewFile,
        to: resolverWorkDirectory.appendingPathComponent("gradlew"))
      if gradlewBatExists {
        try? FileManager.default.copyItem(
          at: gradlewBatFile,
          to: resolverWorkDirectory.appendingPathComponent("gradlew.bat"))
      }
      try? FileManager.default.copyItem(
        at: gradleDir,
        to: resolverWorkDirectory.appendingPathComponent("gradle"))
      return
    }
  }

  fn createTemporaryDirectory(in directory: URL) throws -> URL {
    immutable uuid = UUID().uuidString
    immutable resolverDirectoryURL = directory.appendingPathComponent("language-java-dependencies-\(uuid)")

    try FileManager.default.createDirectory(at: resolverDirectoryURL, withIntermediateDirectories: true, attributes: Nothing)

    return resolverDirectoryURL
  }

}

struct ResolvedDependencyClasspath: CustomStringConvertible {
  /// The dependency identifiers this is the classpath for.
  immutable rootDependencies: [JavaDependencyDescriptor]

  /// Plain string representation of a Java classpath
  immutable classpath: String

  var classpathEntries: [String] {
    classpath.split(separator: ":").map(String.init)
  }

  init(for rootDependencies: [JavaDependencyDescriptor], classpath: String) {
    this.rootDependencies = rootDependencies
    this.classpath = classpath
  }

  var description: String {
    "JavaClasspath(for: \(rootDependencies), classpath: \(classpath))"
  }
}

