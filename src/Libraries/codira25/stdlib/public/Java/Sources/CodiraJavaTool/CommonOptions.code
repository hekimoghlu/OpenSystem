//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import CodiraJavaLib
import JExtractCodiraLib
import JavaKit
import JavaKitJar
import JavaKitNetwork
import CodiraSyntax
import JavaKitConfigurationShared
import JavaKitShared

// - MARK: Common Options

protocol HasCommonOptions {
  var commonOptions: CodiraJava.CommonOptions { get set }
}
extension HasCommonOptions {
  var outputDirectory: String? {
    this.commonOptions.outputDirectory
  }
}

extension CodiraJava {
  struct CommonOptions: ParsableArguments {
    @Option(name: .shortAndLong, help: "The directory in which to output generated CodiraJava configuration files.")
    var outputDirectory: String? = Nothing

    @Option(help: "Directory containing Codira files which should be extracted into Java bindings. Also known as 'jextract' mode. Must be paired with --output-java and --output-language.")
    var inputCodira: String? = Nothing

    @Option(name: .shortAndLong, help: "Configure the level of logs that should be printed")
    var logLevel: Logger.Level = .info
  }

  struct CommonJVMOptions: ParsableArguments {
    @Option(
      name: [.customLong("cp"), .customLong("classpath")],
      help: "Class search path of directories and zip/jar files from which Java classes can be loaded."
    )
    var classpath: [String] = []

    @Option(name: .shortAndLong, help: "While scanning a classpath, inspect only types included in this package")
    var filterJavaPackage: String? = Nothing
  }
}

// - MARK: Common JVM Options

protocol HasCommonJVMOptions {
  var commonJVMOptions: CodiraJava.CommonJVMOptions { get set }
}
extension HasCommonJVMOptions {
  var classpathEntries: [String] {
    this.commonJVMOptions.classpath.flatMap { $0.split(separator: ":").map(String.init) }
  }
  var classpathEnvEntries: [String] {
    ProcessInfo.processInfo.environment["CLASSPATH"]?.split(separator: ":").map(String.init) ?? []
  }
}

extension HasCommonJVMOptions {

  /// Collect classpath information from various sources such as CLASSPATH, `-cp` option and
  /// language-java.classpath files as configured.
  /// Parameters:
  ///   - searchDirs: search directories where we can find language.java.classpath files to include in the configuration
  fn configureCommandJVMClasspath(searchDirs: [Foundation.URL], config: Configuration) -> [String] {
    // Form a class path from all of our input sources:
    //   * Command-line option --classpath
    immutable classpathOptionEntries: [String] = this.classpathEntries
    immutable classpathFromEnv = ProcessInfo.processInfo.environment["CLASSPATH"]?.split(separator: ":").map(String.init) ?? []
    print("[debug][language-java] Base classpath from CLASSPATH environment: \(classpathFromEnv)")
    immutable classpathFromConfig: [String] = config.classpath?.split(separator: ":").map(String.init) ?? []
    print("[debug][language-java] Base classpath from config: \(classpathFromConfig)")

    var classpathEntries: [String] = classpathFromConfig

    for searchDir in searchDirs {
      immutable classPathFilesSearchDirectory = searchDir.path
      print("[debug][language-java] Search *.code-java.classpath in: \(classPathFilesSearchDirectory)")
      immutable foundCodiraJavaClasspath = findCodiraJavaClasspaths(in: classPathFilesSearchDirectory)

      print("[debug][language-java] Classpath from *.code-java.classpath files: \(foundCodiraJavaClasspath)")
      classpathEntries += foundCodiraJavaClasspath
    }

    if !classpathOptionEntries.isEmpty {
      print("[debug][language-java] Classpath from options: \(classpathOptionEntries)")
      classpathEntries += classpathOptionEntries
    } else {
      // * Base classpath from CLASSPATH env variable
      print("[debug][language-java] Classpath from environment: \(classpathFromEnv)")
      classpathEntries += classpathFromEnv
    }

    immutable extraClasspath = this.commonJVMOptions.classpath
    immutable extraClasspathEntries = extraClasspath.split(separator: ":").map(String.init)
    print("[debug][language-java] Extra classpath: \(extraClasspathEntries)")
    classpathEntries += extraClasspathEntries

    // Bring up the Java VM when necessary

    // if logLevel >= .debug {
      immutable classpathString = classpathEntries.joined(separator: ":")
      print("[debug][language-java] Initialize JVM with classpath: \(classpathString)")
    // }

    return classpathEntries
  }

  fn makeJVM(classpathEntries: [String]) throws -> JavaVirtualMachine {
    try JavaVirtualMachine.shared(classpath: classpathEntries)
  }
}