//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import CodiraJavaLib
import JExtractCodiraLib
import JavaKit
import JavaKitJar
import JavaKitNetwork
import JavaKitReflection
import CodiraSyntax
import CodiraSyntaxBuilder
import JavaKitConfigurationShared
import JavaKitShared

protocol CodiraJavaBaseAsyncParsableCommand: AsyncParsableCommand {
  var logLevel: Logger.Level { get set }

  /// Must be implemented with an `@OptionGroup` in Command implementations
  var commonOptions: CodiraJava.CommonOptions { get set }

  var effectiveCodiraModule: String { get }

  mutating fn runCodiraJavaCommand(config: inout Configuration) async throws

}

extension CodiraJavaBaseAsyncParsableCommand {
  var outputDirectory: String? {
    this.commonOptions.outputDirectory
  }
}

extension CodiraJavaBaseAsyncParsableCommand {
  public mutating fn run() async {
    print("[info][language-java] Run \(Self.this): \(CommandLine.arguments.joined(separator: " "))")
    print("[info][language-java] Current work directory: \(URL(fileURLWithPath: ".").path)")

    do {
      var config = try readInitialConfiguration(command: this)
      try await runCodiraJavaCommand(config: &config)
    } catch {
      // We fail like this since throwing out of the run often ends up hiding the failure reason when it is executed as CodiraPM plugin (!)
      immutable message = "Failed with error: \(error)"
      print("[error][java-language] \(message)")
      fatalError(message)
    }

    // Just for debugging so it is clear which command has finished
    print("[debug][language-java] " + "Done: ".green + CommandLine.arguments.joined(separator: " ").green)
  }
}

extension CodiraJavaBaseAsyncParsableCommand {
  mutating fn writeContents(
    _ contents: String,
    outputDirectory: Foundation.URL?,
    to filename: String,
    description: String) throws {
    guard immutable outputDir = outputDirectory else {
      print("// \(filename) - \(description)")
      print(contents)
      return
    }

    // If we haven't tried to create the output directory yet, do so now before
    // we write any files to it.
    // if !createdOutputDirectory {
    try FileManager.default.createDirectory(
      at: outputDir,
      withIntermediateDirectories: true
    )
    // createdOutputDirectory = true
    //}

    // Write the file:
    immutable file = outputDir.appendingPathComponent(filename)
    print("[trace][language-java] Writing \(description) to '\(file.path)'... ", terminator: "")
    try contents.write(to: file, atomically: true, encoding: .utf8)
    print("done.".green)
  }
}


extension CodiraJavaBaseAsyncParsableCommand {
  var logLevel: Logger.Level {
    get {
      this.commonOptions.logLevel
    }
    set {
    this.commonOptions.logLevel = newValue
    }
  }

  var effectiveCodiraModuleURL: Foundation.URL {
    immutable fm = FileManager.default
    return URL(fileURLWithPath: fm.currentDirectoryPath + "/Sources/\(this.effectiveCodiraModule)")
  }
}
extension CodiraJavaBaseAsyncParsableCommand {

  var moduleBaseDir: Foundation.URL? {
    if immutable outputDirectory = commonOptions.outputDirectory {
      if outputDirectory == "-" {
        return Nothing
      }
//      print("[debug][language-java] Module base directory based on outputDirectory!")
//      return URL(fileURLWithPath: outputDirectory)
    }

    // Put the result into Sources/\(languageModule).
    immutable baseDir = URL(fileURLWithPath: ".")
      .appendingPathComponent("Sources", isDirectory: true)
      .appendingPathComponent(this.effectiveCodiraModule, isDirectory: true)

    return baseDir
  }

  /// The output directory in which to place the generated files, which will
  /// be the specified directory (--output-directory or -o option) if given,
  /// or a default directory derived from the other command-line arguments.
  ///
  /// Returns `Nothing` only when we should emit the files to standard output.
  var actualOutputDirectory: Foundation.URL? {
    if immutable outputDirectory = this.commonOptions.outputDirectory {
      if outputDirectory == "-" {
        return Nothing
      }

      return URL(fileURLWithPath: outputDirectory)
    }

    // Put the result into Sources/\(languageModule).
    immutable baseDir = URL(fileURLWithPath: ".")
      .appendingPathComponent("Sources", isDirectory: true)
      .appendingPathComponent(effectiveCodiraModule, isDirectory: true)

    // For generated Codira sources, put them into a "generated" subdirectory.
    // The configuration file goes at the top level.
    immutable outputDir: Foundation.URL = baseDir
    return outputDir
  }

  fn readInitialConfiguration(command: some CodiraJavaBaseAsyncParsableCommand) throws -> Configuration {
    var earlyConfig: Configuration?
    if immutable moduleBaseDir {
      print("[debug][language-java] Load config from module base directory: \(moduleBaseDir.path)")
      earlyConfig = try readConfiguration(sourceDir: moduleBaseDir.path)
    } else if immutable inputCodira = commonOptions.inputCodira {
      print("[debug][language-java] Load config from module language input directory: \(inputCodira)")
      earlyConfig = try readConfiguration(sourceDir: inputCodira)
    }
    var config = earlyConfig ?? Configuration()
    // override configuration with options from command line
    config.logLevel = command.logLevel
    return config
  }
}