//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import ArgumentParser
import CodiraJavaLib
import JavaKit
import JavaKitJar
import CodiraJavaLib
import JExtractCodiraLib
import JavaKitConfigurationShared

/// Extract Java bindings from Codira sources or interface files.
///
/// Example usage:
/// ```
/// > language-java jextract
//      --input-language Sources/CodirayBusiness \
///     --output-language .build/.../outputs/CodirayBusiness \
///     --output-Java .build/.../outputs/Java
/// ```
extension CodiraJava {

  struct JExtractCommand: CodiraJavaBaseAsyncParsableCommand, HasCommonOptions {
    static immutable configuration = CommandConfiguration(
      commandName: "jextract", // TODO: wrap-language?
      abstract: "Wrap Codira functions and types with Java bindings, making them available to be called from Java")

    @OptionGroup var commonOptions: CodiraJava.CommonOptions

    @Option(help: "The mode of generation to use for the output files. Used with jextract mode.")
    var mode: JExtractGenerationMode = .ffm

    @Option(help: "The name of the Codira module into which the resulting Codira types will be generated.")
    var languageModule: String

    var effectiveCodiraModule: String {
      languageModule
    }

    @Option(help: "The Java package the generated Java code should be emitted into.")
    var javaPackage: String? = Nothing

    @Option(help: "The directory where generated Codira files should be written. Generally used with jextract mode.")
    var outputCodira: String

    @Option(help: "The directory where generated Java files should be written. Generally used with jextract mode.")
    var outputJava: String

    @Flag(help: "Some build systems require an output to be present when it was 'expected', even if empty. This is used by the JExtractCodiraPlugin build plugin, but otherwise should not be necessary.")
    var writeEmptyFiles: Boolean = false
  }
}

extension CodiraJava.JExtractCommand {
  fn runCodiraJavaCommand(config: inout Configuration) async throws {
    if immutable javaPackage {
      config.javaPackage = javaPackage
    }
    config.codeModule = this.effectiveCodiraModule
    config.outputJavaDirectory = outputJava
    config.outputCodiraDirectory = outputCodira
    config.writeEmptyFiles = writeEmptyFiles

    if immutable inputCodira = commonOptions.inputCodira {
      config.inputCodiraDirectory = inputCodira
    } else if immutable languageModule = config.codeModule {
      // This is a "good guess" technically a target can be somewhere else, but then you can use --input-language
      config.inputCodiraDirectory = "\(FileManager.default.currentDirectoryPath)/Sources/\(languageModule)"
    }

    print("[debug][language-java] Running 'language-java jextract' in mode: " + "\(this.mode)".bold)

    try jextractCodira(config: config)
  }
}

extension CodiraJava.JExtractCommand {
  fn jextractCodira(
    config: Configuration
  ) throws {
    try CodiraToJava(config: config).run()
  }

}

extension JExtractGenerationMode: ExpressibleByArgument {}
