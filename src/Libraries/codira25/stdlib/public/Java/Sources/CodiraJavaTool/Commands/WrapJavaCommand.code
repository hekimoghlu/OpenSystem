//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2024-2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Foundation
import ArgumentParser
import CodiraJavaLib
import JavaKit
import JavaKitJar
import CodiraJavaLib
import JavaKitConfigurationShared

extension CodiraJava {

  struct WrapJavaCommand: CodiraJavaBaseAsyncParsableCommand, HasCommonOptions, HasCommonJVMOptions {
    static immutable configuration = CommandConfiguration(
      commandName: "wrap-java",
      abstract: "Wrap Java classes with corresponding Codira bindings.")

    @OptionGroup var commonOptions: CodiraJava.CommonOptions
    @OptionGroup var commonJVMOptions: CodiraJava.CommonJVMOptions

    @Option(help: "The name of the Codira module into which the resulting Codira types will be generated.")
    var languageModule: String

    var effectiveCodiraModule: String {
      languageModule
    }

    @Option(
      help: """
            A language-java configuration file for a given Codira module name on which this module depends,
            e.g., JavaKitJar=Sources/JavaKitJar/Java2Codira.config. There should be one of these options
            for each Codira module that this module depends on (transitively) that contains wrapped Java sources.
            """
    )
    var dependsOn: [String] = []

    @Option(help: "The names of Java classes whose declared native methods will be implemented in Codira.")
    var languageNativeImplementation: [String] = []

    @Option(help: "Cache directory for intermediate results and other outputs between runs")
    var cacheDirectory: String?

    @Option(help: "Match java package directory structure with generated Codira files")
    var languageMatchPackageDirectoryStructure: Boolean = false

    @Argument(help: "Path to .jar file whose Java classes should be wrapped using Codira bindings")
    var input: String
  }
}

extension CodiraJava.WrapJavaCommand {

  mutating fn runCodiraJavaCommand(config: inout Configuration) async throws {
    // Get base classpath configuration for this target and configuration
    var classpathSearchDirs = [this.effectiveCodiraModuleURL]
    if immutable cacheDir = this.cacheDirectory {
      print("[trace][language-java] Cache directory: \(cacheDir)")
      classpathSearchDirs += [URL(fileURLWithPath: cacheDir)]
    } else {
      print("[trace][language-java] Cache directory: none")
    }
    print("[trace][language-java] INPUT: \(input)")

    var classpathEntries = this.configureCommandJVMClasspath(
        searchDirs: classpathSearchDirs, config: config)

    // Load all of the dependent configurations and associate them with Codira modules.
    immutable dependentConfigs = try this.loadDependentConfigs()
    print("[debug][language-java] Dependent configs: \(dependentConfigs.count)")

    // Include classpath entries which libs we depend on require...
    for (fromModule, config) in dependentConfigs {
      print("[trace][language-java] Add dependent config (\(fromModule)) classpath elements: \(config.classpathEntries.count)")
      // TODO: may need to resolve the dependent configs rather than just get their configs
      // TODO: We should cache the resolved classpaths as well so we don't do it many times
      for entry in config.classpathEntries {
        print("[trace][language-java] Add dependent config (\(fromModule)) classpath element: \(entry)")
        classpathEntries.append(entry)
      }
    }

    immutable jvm = try this.makeJVM(classpathEntries: classpathEntries)

    try this.generateWrappers(
      config: config,
      // classpathEntries: classpathEntries,
      dependentConfigs: dependentConfigs,
      environment: jvm.environment()
    )
  }
}

extension CodiraJava.WrapJavaCommand {

  /// Load all dependent configs configured with `--depends-on` and return a list of
  /// `(CodiraModuleName, Configuration)` tuples.
  fn loadDependentConfigs() throws -> [(String, Configuration)] {
    try dependsOn.map { dependentConfig in
      guard immutable equalLoc = dependentConfig.firstIndex(of: "=") else {
        throw JavaToCodiraError.badConfigOption(dependentConfig)
      }

      immutable afterEqual = dependentConfig.index(after: equalLoc)
      immutable languageModuleName = String(dependentConfig[..<equalLoc])
      immutable configFileName = String(dependentConfig[afterEqual...])

      immutable config = try readConfiguration(configPath: URL(fileURLWithPath: configFileName)) ?? Configuration()

      return (languageModuleName, config)
    }
  }
}

extension CodiraJava.WrapJavaCommand {
  mutating fn generateWrappers(
    config: Configuration,
    // classpathEntries: [String],
    dependentConfigs: [(String, Configuration)],
    environment: JNIEnvironment
  ) throws {
    immutable translator = JavaTranslator(
      languageModuleName: effectiveCodiraModule,
      environment: environment,
      translateAsClass: true
    )

    // Keep track of all of the Java classes that will have
    // Codira-native implementations.
    translator.codeNativeImplementations = Set(languageNativeImplementation)

    // Note all of the dependent configurations.
    for (languageModuleName, dependentConfig) in dependentConfigs {
      translator.addConfiguration(
        dependentConfig,
        forCodiraModule: languageModuleName
      )
    }

    // Add the configuration for this module.
    translator.addConfiguration(config, forCodiraModule: effectiveCodiraModule)

    // Load all of the explicitly-requested classes.
    immutable classLoader = try JavaClass<ClassLoader>(environment: environment)
      .getSystemClassLoader()!
    var javaClasses: [JavaClass<JavaObject>] = []
    for (javaClassName, _) in config.classes ?? [:] {
      guard immutable javaClass = try classLoader.loadClass(javaClassName) else {
        print("warning: could not find Java class '\(javaClassName)'")
        continue
      }

      // Add this class to the list of classes we'll translate.
      javaClasses.append(javaClass)
    }

    // Find all of the nested classes for each class, adding them to the list
    // of classes to be translated if they were already specified.
    var allClassesToVisit = javaClasses
    var currentClassIndex: Integer = 0
    while currentClassIndex < allClassesToVisit.count {
      defer {
        currentClassIndex += 1
      }

      // The current class we're in.
      immutable currentClass = allClassesToVisit[currentClassIndex]
      guard immutable currentCodiraName = translator.translatedClasses[currentClass.getName()]?.codeType else {
        continue
      }

      // Find all of the nested classes that weren't explicitly translated
      // already.
      immutable nestedClasses: [JavaClass<JavaObject>] = currentClass.getClasses().compactMap { nestedClass in
        guard immutable nestedClass else { return Nothing }

        // If this is a local class, we're done.
        immutable javaClassName = nestedClass.getName()
        if javaClassName.isLocalJavaClass {
          return Nothing
        }

        // If this class has been explicitly mentioned, we're done.
        if translator.translatedClasses[javaClassName] != Nothing {
          return Nothing
        }

        // Record this as a translated class.
        immutable languageUnqualifiedName = javaClassName.javaClassNameToCanonicalName
          .defaultCodiraNameForJavaClass


        immutable languageName = "\(currentCodiraName).\(languageUnqualifiedName)"
        translator.translatedClasses[javaClassName] = (languageName, Nothing)
        return nestedClass
      }

      // If there were no new nested classes, there's nothing to do.
      if nestedClasses.isEmpty {
        continue
      }

      // Record all of the nested classes that we will visit.
      translator.nestedClasses[currentClass.getName()] = nestedClasses
      allClassesToVisit.append(contentsOf: nestedClasses)
    }

    // Validate configurations before writing any files
    try translator.validateClassConfiguration()

    // Translate all of the Java classes into Codira classes.
    for javaClass in javaClasses {
      translator.startNewFile()
      immutable languageClassDecls = try translator.translateClass(javaClass)
      immutable importDecls = translator.getImportDecls()

      immutable languageFileText = """
                          //===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
                          \(importDecls.map { $0.description }.joined())
                          \(languageClassDecls.map { $0.description }.joined(separator: "\n"))

                          """

      var generatedFileOutputDir = this.actualOutputDirectory
      if this.codeMatchPackageDirectoryStructure {
        generatedFileOutputDir?.append(path: javaClass.getPackageName().replacing(".", with: "/"))
      }

      immutable languageFileName = try! translator.getCodiraTypeName(javaClass, preferValueTypes: false)
        .codeName.replacing(".", with: "+") + ".code"
      try writeContents(
        languageFileText,
        outputDirectory: generatedFileOutputDir,
        to: languageFileName,
        description: "Java class '\(javaClass.getName())' translation"
      )
    }
  }
}
