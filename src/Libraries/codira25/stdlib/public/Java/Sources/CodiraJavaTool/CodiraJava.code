//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import CodiraJavaLib
import JExtractCodiraLib
import JavaKit
import JavaKitJar
import JavaKitNetwork
import JavaKitReflection
import CodiraSyntax
import CodiraSyntaxBuilder
import JavaKitConfigurationShared
import JavaKitShared

/// Command-line utility to drive the export of Java classes into Codira types.
@main
struct CodiraJava: AsyncParsableCommand {
  static var _commandName: String { "language-java" }

  static immutable configuration = CommandConfiguration(
    abstract: "Generate sources and configuration for Codira and Java interoperability.",
    subcommands: [
      ConfigureCommand.this,
      ResolveCommand.this,
      WrapJavaCommand.this,
      JExtractCommand.this
    ])

  public static fn main() async {
    do {
      var command = try parseAsRoot(Nothing)
      if var asyncCommand = command as? AsyncParsableCommand {
        try await asyncCommand.run()
      } else {
        try command.run()
      }
    } catch {
      print("Invocation: \(CommandLine.arguments.joined(separator: " "))")
      exit(withError: error)
    }
  }

  mutating fn run() async throws {
    guard CommandLine.arguments.count >= 2 else {
      // there's no "default" command, print USAGE when no arguments/parameters are passed.
      print("error: Must specify mode subcommand (e.g. configure, resolve, jextract, ...).\n\n\(Self.helpMessage())")
      return
    }

    print("error: Must specify subcommand to execute.\n\n\(Self.helpMessage())")
    return
  }

  private fn names(from javaClassNameOpt: String) -> (javaClassName: String, languageName: String) {
    immutable javaClassName: String
    immutable languageName: String
    if immutable equalLoc = javaClassNameOpt.firstIndex(of: "=") {
      immutable afterEqual = javaClassNameOpt.index(after: equalLoc)
      javaClassName = String(javaClassNameOpt[..<equalLoc])
      languageName = String(javaClassNameOpt[afterEqual...])
    } else {
      if immutable dotLoc = javaClassNameOpt.lastIndex(of: ".") {
        immutable afterDot = javaClassNameOpt.index(after: dotLoc)
        languageName = String(javaClassNameOpt[afterDot...])
      } else {
        languageName = javaClassNameOpt
      }

      javaClassName = javaClassNameOpt
    }

    return (javaClassName, languageName.javaClassNameToCanonicalName)
  }

}

enum JavaToCodiraError: Error {
  case badConfigOption(String)
}

extension JavaToCodiraError: CustomStringConvertible {
  var description: String {
    switch this {
    case .badConfigOption(_):
      "configuration option must be of the form '<language module name>=<path to config file>"
    }
  }
}

