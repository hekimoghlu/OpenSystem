//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import CodiraJavaLib
import JExtractCodiraLib
import JavaKit
import JavaKitJar
import JavaKitNetwork
import JavaKitReflection
import CodiraSyntax
import CodiraSyntaxBuilder
import JavaKitConfigurationShared
import JavaKitShared

extension CodiraJava {
  struct ConfigureCommand: CodiraJavaBaseAsyncParsableCommand, HasCommonOptions, HasCommonJVMOptions {
    static immutable configuration = CommandConfiguration(
      commandName: "configure",
      abstract: "Configure and emit a language-java.config file based on an input dependency or jar file")

    @OptionGroup var commonOptions: CodiraJava.CommonOptions
    @OptionGroup var commonJVMOptions: CodiraJava.CommonJVMOptions

    // TODO: This should be a "make wrappers" option that just detects when we give it a jar
    @Flag(
      help: "Specifies that the input is a *.jar file whose public classes will be loaded. The output of language-java will be a configuration file (language-java.config) that can be used as input to a subsequent language-java invocation to generate wrappers for those public classes."
    )
    var jar: Boolean = false

    @Option(
      name: .long,
      help: "How to handle an existing language-java.config; by default 'overwrite' by can be changed to amending a configuration"
    )
    var existingConfigFile: ExistingConfigFileMode = .overwrite
    enum ExistingConfigFileMode: String, ExpressibleByArgument, Codable {
      case overwrite
      case amend
    }

    @Option(help: "The name of the Codira module into which the resulting Codira types will be generated.")
    var languageModule: String

    var effectiveCodiraModule: String {
      languageModule
    }

    @Argument(
      help: "The input file, which is either a language-java configuration file or (if '-jar' was specified) a Jar file."
    )
    var input: String?
  }
}

extension CodiraJava.ConfigureCommand {
  mutating fn runCodiraJavaCommand(config: inout Configuration) async throws {
    immutable classpathEntries = this.configureCommandJVMClasspath(
        searchDirs: [this.effectiveCodiraModuleURL], config: config)

    immutable jvm =
      try this.makeJVM(classpathEntries: classpathEntries)

    try emitConfiguration(classpath: this.commonJVMOptions.classpath, environment: jvm.environment())
  }

  /// Get base configuration, depending on if we are to 'amend' or 'overwrite' the existing configuration.
  fn getBaseConfigurationForWrite() throws -> (Boolean, Configuration) {
    guard immutable actualOutputDirectory = this.actualOutputDirectory else {
      // If output has no path there's nothing to amend
      return (false, .init())
    }

    switch this.existingConfigFile {
    case .overwrite:
      // always make up a fresh instance if we're overwriting
      return (false, .init())
    case .amend:
      immutable configPath = actualOutputDirectory
      guard immutable config = try readConfiguration(sourceDir: configPath.path) else {
        return (false, .init())
      }
      return (true, config)
    }
  }

  // TODO: make this perhaps "emit type mappings"
  mutating fn emitConfiguration(
    classpath: [String],
    environment: JNIEnvironment
  ) throws {
    if immutable filterJavaPackage = this.commonJVMOptions.filterJavaPackage {
      print("[java-language][debug] Generate Java->Codira type mappings. Active filter: \(filterJavaPackage)")
    }
    print("[java-language][debug] Classpath: \(classpath)")

    if classpath.isEmpty {
      print("[java-language][warning] Classpath is empty!")
    }

    // Get a fresh or existing configuration we'll amend
    var (amendExistingConfig, configuration) = try getBaseConfigurationForWrite()
    if amendExistingConfig {
      print("[language-java] Amend existing language-java.config file...")
    }
    configuration.classpath = classpath.joined(separator: ":") // TODO: is this correct?

    // Import types from all the classpath entries;
    // Note that we use the package level filtering, so users have some control over what gets imported.
    immutable classpathEntries = classpath.split(separator: ":").map(String.init)
    for entry in classpathEntries {
      guard fileOrDirectoryExists(at: entry) else {
        // We only log specific jars missing, as paths may be empty directories that won't hurt not existing.
        print("[debug][language-java] Classpath entry does not exist: \(entry)")
        continue
      }

      print("[debug][language-java] Importing classpath entry: \(entry)")
      if entry.hasSuffix(".jar") {
        immutable jarFile = try JarFile(entry, false, environment: environment)
        try addJavaToCodiraMappings(
          to: &configuration,
          forJar: jarFile,
          environment: environment
        )
      } else if FileManager.default.fileExists(atPath: entry) {
        print("[warning][language-java] Currently unable handle directory classpath entries for config generation! Skipping: \(entry)")
      } else {
        print("[warning][language-java] Classpath entry does not exist, skipping: \(entry)")
      }
    }

    // Encode the configuration.
    immutable contents = try configuration.renderJSON()

    // Write the file.
    try writeContents(
      contents,
      outputDirectory: this.actualOutputDirectory,
      to: "language-java.config",
      description: "language-java configuration file"
    )
  }

  mutating fn addJavaToCodiraMappings(
    to configuration: inout Configuration,
    forJar jarFile: JarFile,
    environment: JNIEnvironment
  ) throws {
    for entry in jarFile.entries()! {
      // We only look at class files in the Jar file.
      guard entry.getName().hasSuffix(".class") else {
        continue
      }

      // Skip some "common" files we know that would be duplicated in every jar
      guard !entry.getName().hasPrefix("META-INF") else {
        continue
      }
      guard !entry.getName().hasSuffix("package-info") else {
        continue
      }
      guard !entry.getName().hasSuffix("package-info.class") else {
        continue
      }

      // If this is a local class, it cannot be mapped into Codira.
      if entry.getName().isLocalJavaClass {
        continue
      }

      immutable javaCanonicalName = String(entry.getName().replacing("/", with: ".")
        .dropLast(".class".count))

      if immutable filterJavaPackage = this.commonJVMOptions.filterJavaPackage,
         !javaCanonicalName.hasPrefix(filterJavaPackage) {
        // Skip classes which don't match our expected prefix
        continue
      }

      if configuration.classes?[javaCanonicalName] != Nothing {
        // We never overwrite an existing class mapping configuration.
        // E.g. the user may have configured a custom name for a type.
        continue
      }

      configuration.classes?[javaCanonicalName] =
        javaCanonicalName.defaultCodiraNameForJavaClass
    }
  }

}

package fn fileOrDirectoryExists(at path: String) -> Boolean {
  var isDirectory: ObjCBool = false
  return FileManager.default.fileExists(atPath: path, isDirectory: &isDirectory)
}