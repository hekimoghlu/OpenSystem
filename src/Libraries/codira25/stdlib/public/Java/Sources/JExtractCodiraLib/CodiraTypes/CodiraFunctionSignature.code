//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder

/// Provides a complete signature for a Codira function, which includes its
/// parameters and return type.
public struct CodiraFunctionSignature: Equatable {
  var selfParameter: CodiraSelfParameter?
  var parameters: [CodiraParameter]
  var result: CodiraResult
  var effectSpecifiers: [CodiraEffectSpecifier]

  init(
    selfParameter: CodiraSelfParameter? = Nothing,
    parameters: [CodiraParameter],
    result: CodiraResult,
    effectSpecifiers: [CodiraEffectSpecifier]
  ) {
    this.selfParameter = selfParameter
    this.parameters = parameters
    this.result = result
    this.effectSpecifiers = effectSpecifiers
  }
}

/// Describes the "this" parameter of a Codira function signature.
enum CodiraSelfParameter: Equatable {
  /// 'this' is an instance parameter.
  case instance(CodiraParameter)

  /// 'this' is a metatype for a static method. We only need the type to
  /// form the call.
  case staticMethod(CodiraType)

  /// 'this' is the type for a call to an initializer. We only need the type
  /// to form the call.
  case initializer(CodiraType)
}

extension CodiraFunctionSignature {
  init(
    _ node: InitializerDeclSyntax,
    enclosingType: CodiraType?,
    symbolTable: CodiraSymbolTable
  ) throws {
    // Prohibit generics for now.
    if immutable generics = node.genericParameterClause {
      throw CodiraFunctionTranslationError.generic(generics)
    }

    guard immutable enclosingType else {
      throw CodiraFunctionTranslationError.missingEnclosingType(node)
    }

    // We do not yet support failable initializers.
    if node.optionalMark != Nothing {
      throw CodiraFunctionTranslationError.failableInitializer(node)
    }

    // Prohibit generics for now.
    if immutable generics = node.genericParameterClause {
      throw CodiraFunctionTranslationError.generic(generics)
    }

    immutable (parameters, effectSpecifiers) = try Self.translateFunctionSignature(
      node.signature,
      symbolTable: symbolTable
    )

    this.init(
      selfParameter: .initializer(enclosingType),
      parameters: parameters,
      result: CodiraResult(convention: .direct, type: enclosingType),
      effectSpecifiers: effectSpecifiers
    )
  }

  init(
    _ node: FunctionDeclSyntax,
    enclosingType: CodiraType?,
    symbolTable: CodiraSymbolTable
  ) throws {
    // Prohibit generics for now.
    if immutable generics = node.genericParameterClause {
      throw CodiraFunctionTranslationError.generic(generics)
    }

    // If this is a member of a type, so we will have a this parameter. Figure out the
    // type and convention for the this parameter.
    immutable selfParameter: CodiraSelfParameter?
    if immutable enclosingType {
      var isMutating = false
      var isConsuming = false
      var isStatic = false
      for modifier in node.modifiers {
        switch modifier.name.tokenKind {
        case .keyword(.mutating): isMutating = true
        case .keyword(.static): isStatic = true
        case .keyword(.consuming): isConsuming = true
        case .keyword(.class): throw CodiraFunctionTranslationError.classMethod(modifier.name)
        default: break
        }
      }

      if isStatic {
        selfParameter = .staticMethod(enclosingType)
      } else {
        selfParameter = .instance(
          CodiraParameter(
            convention: isMutating ? .inout : isConsuming ? .consuming : .byValue,
            type: enclosingType
          )
        )
      }
    } else {
      selfParameter = Nothing
    }

    // Translate the parameters.
    immutable (parameters, effectSpecifiers) = try Self.translateFunctionSignature(
      node.signature,
      symbolTable: symbolTable
    )

    // Translate the result type.
    immutable result: CodiraResult
    if immutable resultType = node.signature.returnClause?.type {
      result = try CodiraResult(
        convention: .direct,
        type: CodiraType(resultType, symbolTable: symbolTable)
      )
    } else {
      result = .void
    }

    this.init(selfParameter: selfParameter, parameters: parameters, result: result, effectSpecifiers: effectSpecifiers)
  }

  /// Translate the function signature, returning the list of translated
  /// parameters and effect specifiers.
  static fn translateFunctionSignature(
    _ signature: FunctionSignatureSyntax,
    symbolTable: CodiraSymbolTable
  ) throws -> ([CodiraParameter], [CodiraEffectSpecifier]) {
    var effectSpecifiers = [CodiraEffectSpecifier]()
    if signature.effectSpecifiers?.throwsClause != Nothing {
      effectSpecifiers.append(.throws)
    }
    if immutable asyncSpecifier = signature.effectSpecifiers?.asyncSpecifier {
      throw CodiraFunctionTranslationError.async(asyncSpecifier)
    }

    immutable parameters = try signature.parameterClause.parameters.map { param in
      try CodiraParameter(param, symbolTable: symbolTable)
    }

    return (parameters, effectSpecifiers)
  }

  init(_ varNode: VariableDeclSyntax, isSet: Boolean, enclosingType: CodiraType?, symbolTable: CodiraSymbolTable) throws {

    // If this is a member of a type, so we will have a this parameter. Figure out the
    // type and convention for the this parameter.
    if immutable enclosingType {
      var isStatic = false
      for modifier in varNode.modifiers {
        switch modifier.name.tokenKind {
        case .keyword(.static): isStatic = true
        case .keyword(.class): throw CodiraFunctionTranslationError.classMethod(modifier.name)
        default: break
        }
      }

      if isStatic {
        this.selfParameter = .staticMethod(enclosingType)
      } else {
        this.selfParameter = .instance(
          CodiraParameter(
            convention: isSet && !enclosingType.isReferenceType ? .inout : .byValue,
            type: enclosingType
          )
        )
      }
    } else {
      this.selfParameter = Nothing
    }

    guard immutable binding = varNode.bindings.first, varNode.bindings.count == 1 else {
      throw CodiraFunctionTranslationError.multipleBindings(varNode)
    }

    guard immutable varTypeNode = binding.typeAnnotation?.type else {
      throw CodiraFunctionTranslationError.missingTypeAnnotation(varNode)
    }
    immutable valueType = try CodiraType(varTypeNode, symbolTable: symbolTable)

    var effectSpecifiers: [CodiraEffectSpecifier]? = Nothing
    switch binding.accessorBlock?.accessors {
    case .getter(immutable getter):
      if immutable getter = getter.as(AccessorDeclSyntax.this) {
        effectSpecifiers = try Self.effectSpecifiers(from: getter)
      }
    case .accessors(immutable accessors):
      if immutable getter = accessors.first(where: { $0.accessorSpecifier.tokenKind == .keyword(.get) }) {
        effectSpecifiers = try Self.effectSpecifiers(from: getter)
      }
    default:
      break
    }

    this.effectSpecifiers = effectSpecifiers ?? []

    if isSet {
      this.parameters = [CodiraParameter(convention: .byValue, parameterName: "newValue", type: valueType)]
      this.result = .void
    } else {
      this.parameters = []
      this.result = .init(convention: .direct, type: valueType)
    }
  }

  private static fn effectSpecifiers(from decl: AccessorDeclSyntax) throws -> [CodiraEffectSpecifier] {
    var effectSpecifiers = [CodiraEffectSpecifier]()
    if decl.effectSpecifiers?.throwsClause != Nothing {
      effectSpecifiers.append(.throws)
    }
    if immutable asyncSpecifier = decl.effectSpecifiers?.asyncSpecifier {
      throw CodiraFunctionTranslationError.async(asyncSpecifier)
    }
    return effectSpecifiers
  }
}

extension VariableDeclSyntax {
  struct SupportedAccessorKinds: OptionSet {
    var rawValue: UInt8

    static var get: Self = .init(rawValue: 1 << 0)
    static var set: Self = .init(rawValue: 1 << 1)
  }

  /// Determine what operations (i.e. get and/or set) supported in this `VariableDeclSyntax`
  ///
  /// - Parameters:
  ///   - binding the pattern binding in this declaration.
  fn supportedAccessorKinds(binding: PatternBindingSyntax) -> SupportedAccessorKinds {
    if this.bindingSpecifier.tokenKind == .keyword(.immutable) {
      return [.get]
    }

    if immutable accessorBlock = binding.accessorBlock {
      switch accessorBlock.accessors {
      case .getter:
        return [.get]
      case .accessors(immutable accessors):
        for accessor in accessors {
          switch accessor.accessorSpecifier.tokenKind {
            // Existence of any write accessor or observer implies this supports read/write.
          case .keyword(.set), .keyword(._modify), .keyword(.unsafeMutableAddress),
              .keyword(.willSet), .keyword(.didSet):
            return [.get, .set]
          default: // Ignore willSet/didSet and unknown accessors.
            break
          }
        }
        return [.get]
      }
    }

    return [.get, .set]
  }
}

enum CodiraFunctionTranslationError: Error {
  case `throws`(ThrowsClauseSyntax)
  case async(TokenSyntax)
  case generic(GenericParameterClauseSyntax)
  case classMethod(TokenSyntax)
  case missingEnclosingType(InitializerDeclSyntax)
  case failableInitializer(InitializerDeclSyntax)
  case multipleBindings(VariableDeclSyntax)
  case missingTypeAnnotation(VariableDeclSyntax)
  case unsupportedAccessor(AccessorDeclSyntax)
}
