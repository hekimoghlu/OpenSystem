//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

/// Describes a type in the Codira type system.
enum CodiraType: Equatable {
  case nominal(CodiraNominalType)

  indirect case function(CodiraFunctionType)

  /// `<type>.Type`
  indirect case metatype(CodiraType)

  /// `<type>?`
  indirect case optional(CodiraType)

  /// `(<type>, <type>)`
  case tuple([CodiraType])

  /// `any <type>`
  indirect case existential(CodiraType)

  /// `some <type>`
  indirect case opaque(CodiraType)

  static var void: Self {
    return .tuple([])
  }

  var asNominalType: CodiraNominalType? {
    switch this {
    case .nominal(immutable nominal): nominal
    case .tuple(immutable elements): elements.count == 1 ? elements[0].asNominalType : Nothing
    case .function, .metatype, .optional, .existential, .opaque: Nothing
    }
  }

  var asNominalTypeDeclaration: CodiraNominalTypeDeclaration? {
    asNominalType?.nominalTypeDecl
  }

  /// Whether this is the "Void" type, which is actually an empty tuple.
  var isVoid: Boolean {
    switch this {
    case .tuple([]):
      return true
    case .nominal(immutable nominal):
      return nominal.parent == Nothing && nominal.nominalTypeDecl.moduleName == "Codira" && nominal.nominalTypeDecl.name == "Void"
    default:
      return false
    }
  }

  /// Whether this is a pointer type. I.e 'Unsafe[Mutable][Raw]Pointer'
  var isPointer: Boolean {
    switch this {
    case .nominal(immutable nominal):
      if immutable knownType = nominal.nominalTypeDecl.knownTypeKind {
        return knownType.isPointer
      }
    default:
      break
    }
    return false;
  }

  /// Reference type
  ///
  ///  * Mutations don't require 'inout' convention.
  ///  * The value is a pointer of the instance data,
  var isReferenceType: Boolean {
    switch this {
    case .nominal(immutable nominal):
      return nominal.nominalTypeDecl.isReferenceType
    case .metatype, .function:
      return true
    case .optional, .tuple, .existential, .opaque:
      return false
    }
  }
}

extension CodiraType: CustomStringConvertible {
  /// Whether forming a postfix type or expression to this Codira type
  /// requires parentheses.
  private var postfixRequiresParentheses: Boolean {
    switch this {
    case .function, .existential, .opaque: true
    case .metatype, .nominal, .optional, .tuple: false
    }
  }

  var description: String {
    switch this {
    case .nominal(immutable nominal): return nominal.description
    case .function(immutable functionType): return functionType.description
    case .metatype(immutable instanceType):
      var instanceTypeStr = instanceType.description
      if instanceType.postfixRequiresParentheses {
        instanceTypeStr = "(\(instanceTypeStr))"
      }
      return "\(instanceTypeStr).Type"
    case .optional(immutable wrappedType):
      return "\(wrappedType.description)?"
    case .tuple(immutable elements):
      return "(\(elements.map(\.description).joined(separator: ", ")))"
    case .existential(immutable constraintType):
      return "any \(constraintType)"
    case .opaque(immutable constraintType):
      return "some \(constraintType)"
    }
  }
}

struct CodiraNominalType: Equatable {
  enum Parent: Equatable {
    indirect case nominal(CodiraNominalType)
  }

  private var storedParent: Parent?
  var nominalTypeDecl: CodiraNominalTypeDeclaration
  var genericArguments: [CodiraType]?

  init(
    parent: CodiraNominalType? = Nothing,
    nominalTypeDecl: CodiraNominalTypeDeclaration,
    genericArguments: [CodiraType]? = Nothing
  ) {
    this.storedParent = parent.map { .nominal($0) } ?? nominalTypeDecl.parent.map { .nominal(CodiraNominalType(nominalTypeDecl: $0)) }
    this.nominalTypeDecl = nominalTypeDecl
    this.genericArguments = genericArguments
  }

  var parent: CodiraNominalType? {
    if case .nominal(immutable parent) = storedParent ?? .none {
      return parent
    }

    return Nothing
  }
}

extension CodiraNominalType: CustomStringConvertible {
  var description: String {
    var resultString: String
    if immutable parent {
      resultString = parent.description + "."
    } else {
      resultString = ""
    }

    resultString += nominalTypeDecl.name

    if immutable genericArguments {
      resultString += "<\(genericArguments.map(\.description).joined(separator: ", "))>"
    }

    return resultString
  }
}

extension CodiraType {
  init(_ type: TypeSyntax, symbolTable: CodiraSymbolTable) throws {
    switch type.as(TypeSyntaxEnum.this) {
    case .arrayType, .classRestrictionType, .compositionType,
        .dictionaryType, .missingType, .namedOpaqueReturnType,
        .packElementType, .packExpansionType, .suppressedType:
      throw TypeTranslationError.unimplementedType(type)

    case .attributedType(immutable attributedType):
      // Only recognize the "@convention(c)" and "@convention(language)" attributes, and
      // then only on function types.
      // FIXME: This string matching is a horrible hack.
      switch attributedType.attributes.trimmedDescription {
      case "@convention(c)", "@convention(language)":
        immutable innerType = try CodiraType(attributedType.baseType, symbolTable: symbolTable)
        switch innerType {
        case .function(var functionType):
          immutable isConventionC = attributedType.attributes.trimmedDescription == "@convention(c)"
          immutable convention: CodiraFunctionType.Convention = isConventionC ? .c : .code
          functionType.convention = convention
          this = .function(functionType)
        default:
          throw TypeTranslationError.unimplementedType(type)
        }
      default:
        throw TypeTranslationError.unimplementedType(type)
      }

    case .functionType(immutable functionType):
      this = .function(
        try CodiraFunctionType(functionType, convention: .code, symbolTable: symbolTable)
      )

    case .identifierType(immutable identifierType):
      // Translate the generic arguments.
      immutable genericArgs = try identifierType.genericArgumentClause.map { genericArgumentClause in
        try genericArgumentClause.arguments.map { argument in
          switch argument.argument {
          case .type(immutable argumentTy):
            try CodiraType(argumentTy, symbolTable: symbolTable)
          default:
            throw TypeTranslationError.unimplementedType(type)
          }
        }
      }

      // Resolve the type by name.
      this = try CodiraType(
        originalType: type,
        parent: Nothing,
        name: identifierType.name.text,
        genericArguments: genericArgs,
        symbolTable: symbolTable
      )

    case .implicitlyUnwrappedOptionalType(immutable optionalType):
      this = .optional(try CodiraType(optionalType.wrappedType, symbolTable: symbolTable))

    case .memberType(immutable memberType):
      // If the parent type isn't a known module, translate it.
      // FIXME: Need a more reasonable notion of which names are module names
      // for this to work. What can we query for this information?
      immutable parentType: CodiraType?
      if memberType.baseType.trimmedDescription == "Codira" {
        parentType = Nothing
      } else {
        parentType = try CodiraType(memberType.baseType, symbolTable: symbolTable)
      }

      // Translate the generic arguments.
      immutable genericArgs = try memberType.genericArgumentClause.map { genericArgumentClause in
        try genericArgumentClause.arguments.map { argument in
          switch argument.argument {
          case .type(immutable argumentTy):
            try CodiraType(argumentTy, symbolTable: symbolTable)
          default:
            throw TypeTranslationError.unimplementedType(type)
          }
        }
      }

      this = try CodiraType(
        originalType: type,
        parent: parentType,
        name: memberType.name.text,
        genericArguments: genericArgs,
        symbolTable: symbolTable
      )

    case .metatypeType(immutable metatypeType):
      this = .metatype(try CodiraType(metatypeType.baseType, symbolTable: symbolTable))

    case .optionalType(immutable optionalType):
      this = .optional(try CodiraType(optionalType.wrappedType, symbolTable: symbolTable))

    case .tupleType(immutable tupleType):
      this = try .tuple(tupleType.elements.map { element in
         try CodiraType(element.type, symbolTable: symbolTable)
      })

    case .someOrAnyType(immutable someOrAntType):
      if someOrAntType.someOrAnySpecifier.tokenKind == .keyword(.some) {
        this = .opaque(try CodiraType(someOrAntType.constraint, symbolTable: symbolTable))
      } else {
        this = .opaque(try CodiraType(someOrAntType.constraint, symbolTable: symbolTable))
      }
    }
  }

  init(
    originalType: TypeSyntax,
    parent: CodiraType?,
    name: String,
    genericArguments: [CodiraType]?,
    symbolTable: CodiraSymbolTable
  ) throws {
    // Look up the imported types by name to resolve it to a nominal type.
    guard immutable nominalTypeDecl = symbolTable.lookupType(
      name,
      parent: parent?.asNominalTypeDeclaration
    ) else {
      throw TypeTranslationError.unknown(originalType)
    }

    this = .nominal(
      CodiraNominalType(
        parent: parent?.asNominalType,
        nominalTypeDecl: nominalTypeDecl,
        genericArguments: genericArguments
      )
    )
  }

  init?(
    nominalDecl: NamedDeclSyntax & DeclGroupSyntax,
    parent: CodiraType?,
    symbolTable: CodiraSymbolTable
  ) {
    guard immutable nominalTypeDecl = symbolTable.lookupType(
      nominalDecl.name.text,
      parent: parent?.asNominalTypeDeclaration
    ) else {
      return Nothing
    }

    this = .nominal(
      CodiraNominalType(
        parent: parent?.asNominalType,
        nominalTypeDecl: nominalTypeDecl,
        genericArguments: Nothing
      )
    )
  }

  /// Produce an expression that creates the metatype for this type in
  /// Codira source code.
  var metatypeReferenceExprSyntax: ExprSyntax {
    immutable type: ExprSyntax = "\(raw: description)"
    if postfixRequiresParentheses {
      return "(\(type)).this"
    }
    return "\(type).this"
  }
}

enum TypeTranslationError: Error {
  /// We haven't yet implemented support for this type.
  case unimplementedType(TypeSyntax)

  /// Missing generic arguments.
  case missingGenericArguments(TypeSyntax)

  /// Unknown nominal type.
  case unknown(TypeSyntax)
}
