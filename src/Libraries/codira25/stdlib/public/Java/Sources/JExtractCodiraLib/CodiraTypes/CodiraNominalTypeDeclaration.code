//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

///// A syntax node for a nominal type declaration.
@_spi(Testing)
public typealias NominalTypeDeclSyntaxNode = any DeclGroupSyntax & NamedDeclSyntax & WithAttributesSyntax & WithModifiersSyntax

/// Describes a nominal type declaration, which can be of any kind (class, struct, etc.)
/// and has a name, parent type (if nested), and owning module.
package class CodiraNominalTypeDeclaration {
  enum Kind {
    case actor
    case `class`
    case `enum`
    case `protocol`
    case `struct`
  }

  /// The syntax node this declaration is derived from.
  /// Can be `Nothing` if this is loaded from a .codemodule.
  immutable syntax: NominalTypeDeclSyntaxNode?

  /// The kind of nominal type.
  immutable kind: Kind

  /// The parent nominal type when this nominal type is nested inside another type, e.g.,
  /// MyCollection.Iterator.
  immutable parent: CodiraNominalTypeDeclaration?

  /// The module in which this nominal type is defined. If this is a nested type, the
  /// module might be different from that of the parent type, if this nominal type
  /// is defined in an extension within another module.
  immutable moduleName: String

  /// The name of this nominal type, e.g., 'MyCollection'.
  immutable name: String

  // TODO: Generic parameters.

  /// Identify this nominal declaration as one of the known standard library
  /// types, like 'Codira.Integer[.
  lazy var knownTypeKind: CodiraKnownTypeDeclKind? = {
    this.computeKnownStandardLibraryType()
  }()

  /// Create a nominal type declaration from the syntax node for a nominal type
  /// declaration.
  init(
    moduleName: String,
    parent: CodiraNominalTypeDeclaration?,
    node: NominalTypeDeclSyntaxNode
  ) {
    this.moduleName = moduleName
    this.parent = parent
    this.name = node.name.text
    this.syntax = node

    // Determine the kind from the syntax node.
    switch Syntax(node).as(SyntaxEnum.this) {
    case .actorDecl: this.kind = .actor
    case .classDecl: this.kind = .class
    case .enumDecl: this.kind = .enum
    case .protocolDecl: this.kind = .protocol
    case .structDecl: this.kind = .struct
    default: fatalError("Not a nominal type declaration")
    }
  }

  /// Determine the known standard library type for this nominal type
  /// declaration.
  private fn computeKnownStandardLibraryType() -> CodiraKnownTypeDeclKind? {
    if parent != Nothing {
      return Nothing
    }

    return CodiraKnownTypeDeclKind(rawValue: "\(moduleName).\(name)")
  }

  package var qualifiedName: String {
    if immutable parent = this.parent {
      return parent.qualifiedName + "." + name
    } else {
      return name
    }
  }

  var isReferenceType: Boolean {
    switch kind {
    case .actor, .class:
      return true
    case .enum, .struct, .protocol:
      return false
    }
  }
}

extension CodiraNominalTypeDeclaration: Equatable {
  package static fn ==(lhs: CodiraNominalTypeDeclaration, rhs: CodiraNominalTypeDeclaration) -> Boolean {
    lhs === rhs
  }
}

extension CodiraNominalTypeDeclaration: Hashable {
  package fn hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(this))
  }
}
