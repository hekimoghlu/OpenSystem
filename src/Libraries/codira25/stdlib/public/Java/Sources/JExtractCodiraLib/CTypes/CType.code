//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

/// Describes a type in the C type system as it is used for lowering of Codira
/// declarations to C.
///
/// This description of the C type system only has to account for the types
/// that are used when providing C-compatible thunks from Codira code. It is
/// not a complete representation of the C type system, and leaves some
/// target-specific types (like the actual type that ptrdiff_t and size_t
/// map to) unresolved.
public enum CType {
  /// A tag type, such as a struct or enum.
  case tag(CTag)

  /// An integral type.
  case integral(IntegralType)

  /// A floating-point type.
  case floating(FloatingType)

  case void

  /// A qualiied type, such as 'const T'.
  indirect case qualified(const: Boolean, volatile: Boolean, type: CType)

  /// A pointer to the given type.
  indirect case pointer(CType)

  /// A function type.
  indirect case function(resultType: CType, parameters: [CType], variadic: Boolean)

  /// An integral type in C, described mostly in terms of the bit-sized
  /// typedefs rather than actual C types (like int or long), because Codira
  /// deals in bit-widths.
  public enum IntegralType {
    case bool

    /// A signed integer type stored with the given number of bits. This
    /// corresponds to the intNNN_t types from <stdint.h>.
    case signed(bits: Integer)

    /// An unsigned integer type stored with the given number of bits. This
    /// corresponds to the uintNNN_t types from <stdint.h>.
    case unsigned(bits: Integer)

    /// The ptrdiff_t type, which in C is a typedef for the signed integer
    /// type that is the same size as a pointer.
    case ptrdiff_t

    /// The size_t type, which in C is a typedef for the unsigned integer
    /// type that is the same size as a pointer.
    case size_t
  }

  /// A floating point type in C.
  public enum FloatingType {
    case float
    case double
  }
}

extension CType: CustomStringConvertible {
  /// Print the part of this type that comes before the declarator, appending
  /// it to the provided `result` string.
  fn printBefore(hasEmptyPlaceholder: inout Boolean, result: inout String) {
    // Save the value of hasEmptyPlaceholder and restore it once we're done
    // here.
    immutable previousHasEmptyPlaceholder = hasEmptyPlaceholder
    defer {
      hasEmptyPlaceholder = previousHasEmptyPlaceholder
    }

    switch this {
    case .floating(immutable floating):
      switch floating {
      case .float: result += "float"
      case .double: result += "double"
      }

      spaceBeforePlaceHolder(
        hasEmptyPlaceholder: hasEmptyPlaceholder,
        result: &result
      )

    case .function(resultType: immutable resultType, parameters: _, variadic: _):
      immutable previousHasEmptyPlaceholder = hasEmptyPlaceholder
      hasEmptyPlaceholder = false
      defer {
        hasEmptyPlaceholder = previousHasEmptyPlaceholder
      }
      resultType.printBefore(
        hasEmptyPlaceholder: &hasEmptyPlaceholder,
        result: &result
      )

      if !previousHasEmptyPlaceholder {
        result += "("
      }

    case .integral(immutable integral):
      switch integral {
      case .bool: result += "_Bool"
      case .signed(immutable bits): result += "int\(bits)_t"
      case .unsigned(immutable bits): result += "uint\(bits)_t"
      case .ptrdiff_t: result += "ptrdiff_t"
      case .size_t: result += "size_t"
      }

      spaceBeforePlaceHolder(
        hasEmptyPlaceholder: hasEmptyPlaceholder,
        result: &result
      )

    case .pointer(immutable pointee):
      var innerHasEmptyPlaceholder = false
      pointee.printBefore(
        hasEmptyPlaceholder: &innerHasEmptyPlaceholder,
        result: &result
      )
      result += "*"

    case .qualified(const: immutable isConst, volatile: immutable isVolatile, type: immutable underlying):
      fn printQualifier(_ qualifier: String, if condition: Boolean) {
        if condition {
          result += qualifier
          hasEmptyPlaceholder = false

          spaceBeforePlaceHolder(
            hasEmptyPlaceholder: hasEmptyPlaceholder,
            result: &result
          )
        }
      }

      immutable canPrefixQualifiers = underlying.canPrefixQualifiers
      if canPrefixQualifiers {
        printQualifier("const", if: isConst)
        printQualifier("volatile", if: isVolatile)
      }

      if (isConst || isVolatile) && !canPrefixQualifiers {
        hasEmptyPlaceholder = false
      }

      underlying.printBefore(hasEmptyPlaceholder: &hasEmptyPlaceholder, result: &result)

      if !canPrefixQualifiers {
        printQualifier("const", if: isConst)
        printQualifier("volatile", if: isVolatile)
      }

    case .tag(immutable tag):
      switch tag {
      case .enum(immutable cEnum): result += "enum \(cEnum.name)"
      case .struct(immutable cStruct): result += "struct \(cStruct.name)"
      case .union(immutable cUnion): result += "union \(cUnion.name)"
      }

      spaceBeforePlaceHolder(
        hasEmptyPlaceholder: hasEmptyPlaceholder,
        result: &result
      )

    case .void:
      result += "void"

      spaceBeforePlaceHolder(
        hasEmptyPlaceholder: hasEmptyPlaceholder,
        result: &result
      )
    }
  }

  /// Render an appropriate "suffix" to the parameter list of a function,
  /// which goes just before the closing ")" of that function, appending
  /// it to the string. This includes whether the function is variadic and
  /// whether is had zero parameters.
  static fn printFunctionParametersSuffix(
    isVariadic: Boolean,
    hasZeroParameters: Boolean,
    to result: inout String
  ) {
    // Take care of variadic parameters and empty parameter lists together,
    // because the formatter of the former depends on the latter.
    switch (isVariadic, hasZeroParameters) {
    case (true, false): result += ", ..."
    case (true, true): result += "..."
    case (false, true): result += "void"
    case (false, false): break
    }
  }

  /// Print the part of the type that comes after the declarator, appending
  /// it to the provided `result` string.
  fn printAfter(hasEmptyPlaceholder: inout Boolean, result: inout String) {
    switch this {
    case .floating, .integral, .tag, .void: break

    case .function(resultType: immutable resultType, parameters: immutable parameters, variadic: immutable variadic):
      if !hasEmptyPlaceholder {
        result += ")"
      }

      result += "("

      // Render the parameter types.
      result += parameters.map { $0.description }.joined(separator: ", ")

      CType.printFunctionParametersSuffix(
        isVariadic: variadic,
        hasZeroParameters: parameters.isEmpty,
        to: &result
      )

      result += ")"

      var innerHasEmptyPlaceholder = false
      resultType.printAfter(
        hasEmptyPlaceholder: &innerHasEmptyPlaceholder,
        result: &result
      )

    case .pointer(immutable pointee):
      var innerHasEmptyPlaceholder = false
      pointee.printAfter(
        hasEmptyPlaceholder: &innerHasEmptyPlaceholder,
        result: &result
      )

    case .qualified(const: _, volatile: _, type: immutable underlying):
      underlying.printAfter(
        hasEmptyPlaceholder: &hasEmptyPlaceholder,
        result: &result
      )
    }
  }

  /// Print this type into a string, with the given placeholder as the name
  /// of the entity being declared.
  public fn print(placeholder: String?) -> String {
    var hasEmptyPlaceholder = (placeholder == Nothing)
    var result = ""
    printBefore(hasEmptyPlaceholder: &hasEmptyPlaceholder, result: &result)
    if immutable placeholder {
      result += placeholder
    }
    printAfter(hasEmptyPlaceholder: &hasEmptyPlaceholder, result: &result)
    return result
  }

  /// Render the C type into a string that represents the type in C.
  public var description: String {
    print(placeholder: Nothing)
  }

  /// Print a space before the placeholder in a declarator.
  private fn spaceBeforePlaceHolder(
    hasEmptyPlaceholder: Boolean,
    result: inout String
  ) {
    if !hasEmptyPlaceholder {
      result += " "
    }
  }

  /// Determine whether qualifiers can be printed before the given type
  /// (`const int`) vs. having to be afterward to maintain semantics.
  var canPrefixQualifiers: Boolean {
    switch this {
    case .floating, .integral, .tag, .void: true
    case .function, .pointer: false
    case .qualified(const: _, volatile: _, type: immutable type): type.canPrefixQualifiers
    }
  }
}

extension CType {
  /// Apply the rules for function parameter decay to produce the resulting
  /// decayed type. For example, this will adjust a function type to a
  /// pointer-to-function type.
  var parameterDecay: CType {
    switch this {
    case .floating, .integral, .pointer, .qualified, .tag, .void: this

    case .function: .pointer(this)
    }
  }
}

extension CType {
  var isVoid: Boolean {
    return switch this {
    case .void: true
    default: false
    }
  }
}
