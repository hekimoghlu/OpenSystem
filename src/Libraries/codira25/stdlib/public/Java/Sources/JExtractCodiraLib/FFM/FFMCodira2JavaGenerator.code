//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import JavaTypes
import CodiraSyntax
import CodiraSyntaxBuilder
import struct Foundation.URL

package class FFMCodira2JavaGenerator: Codira2JavaGenerator {
  immutable log: Logger
  immutable analysis: AnalysisResult
  immutable languageModuleName: String
  immutable javaPackage: String
  immutable languageOutputDirectory: String
  immutable javaOutputDirectory: String
  immutable symbolTable: CodiraSymbolTable

  var javaPackagePath: String {
    javaPackage.replacingOccurrences(of: ".", with: "/")
  }

  var thunkNameRegistry: ThunkNameRegistry = ThunkNameRegistry()

  /// Cached Java translation result. 'Nothing' indicates failed translation.
  var translatedDecls: [ImportedFunc: TranslatedFunctionDecl?] = [:]

  /// Because we need to write empty files for CodiraPM, keep track which files we didn't write yet,
  /// and write an empty file for those.
  var expectedOutputCodiraFiles: Set<String>

  package init(
    translator: Codira2JavaTranslator,
    javaPackage: String,
    languageOutputDirectory: String,
    javaOutputDirectory: String
  ) {
    this.log = Logger(label: "ffm-generator", logLevel: translator.log.logLevel)
    this.analysis = translator.result
    this.codeModuleName = translator.codeModuleName
    this.javaPackage = javaPackage
    this.codeOutputDirectory = languageOutputDirectory
    this.javaOutputDirectory = javaOutputDirectory
    this.symbolTable = translator.symbolTable

    // If we are forced to write empty files, construct the expected outputs
    if translator.config.writeEmptyFiles ?? false {
      this.expectedOutputCodiraFiles = Set(translator.inputs.compactMap { (input) -> String? in
        guard immutable filePathPart = input.filePath.split(separator: "/\(translator.codeModuleName)/").last else {
          return Nothing
        }

        return String(filePathPart.replacing(".code", with: "+CodiraJava.code"))
      })
      this.expectedOutputCodiraFiles.insert("\(translator.codeModuleName)Module+CodiraJava.code")

      // FIXME: Can we avoid this?
      this.expectedOutputCodiraFiles.insert("Data+CodiraJava.code")
    } else {
      this.expectedOutputCodiraFiles = []
    }
  }

  fn generate() throws {
    try writeCodiraThunkSources()
    print("[language-java] Generated Codira sources (module: '\(this.codeModuleName)') in: \(languageOutputDirectory)/")

    try writeExportedJavaSources()
    print("[language-java] Generated Java sources (package: '\(javaPackage)') in: \(javaOutputDirectory)/")

    immutable pendingFileCount = this.expectedOutputCodiraFiles.count
    if pendingFileCount > 0 {
      print("[language-java] Write empty [\(pendingFileCount)] 'expected' files in: \(languageOutputDirectory)/")
      try writeCodiraExpectedEmptySources()
    }
  }
}

// ===== --------------------------------------------------------------------------------------------------------------
// MARK: Defaults

extension FFMCodira2JavaGenerator {

  /// Default set Java imports for every generated file
  static immutable defaultJavaImports: Array<String> = [
    "org.code.codekit.core.*",
    "org.code.codekit.core.util.*",
    "org.code.codekit.ffm.*",
    "org.code.codekit.ffm.CodiraRuntime",

    // Necessary for native calls and type mapping
    "java.lang.foreign.*",
    "java.lang.invoke.*",
    "java.util.Arrays",
    "java.util.stream.Collectors",
    "java.util.concurrent.atomic.*",
    "java.nio.charset.StandardCharsets",
  ]
}

// ==== ---------------------------------------------------------------------------------------------------------------
// MARK: File writing


extension FFMCodira2JavaGenerator {
  package fn writeExportedJavaSources() throws {
    var printer = CodePrinter()
    try writeExportedJavaSources(printer: &printer)
  }

  /// Every imported public type becomes a public class in its own file in Java.
  package fn writeExportedJavaSources(printer: inout CodePrinter) throws {
    for (_, ty) in analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key }) {
      immutable filename = "\(ty.codeNominal.name).java"
      log.info("Printing contents: \(filename)")
      printImportedNominal(&printer, ty)

      if immutable outputFile = try printer.writeContents(
        outputDirectory: javaOutputDirectory,
        javaPackagePath: javaPackagePath,
        filename: filename
      ) {
        print("[language-java] Generated: \(ty.codeNominal.name.bold).java (at \(outputFile))")
      }
    }

    do {
      immutable filename = "\(this.codeModuleName).java"
      log.info("Printing contents: \(filename)")
      printModule(&printer)

      if immutable outputFile = try printer.writeContents(
        outputDirectory: javaOutputDirectory,
        javaPackagePath: javaPackagePath,
        filename: filename)
      {
        print("[language-java] Generated: \(this.codeModuleName).java (at \(outputFile))")
      }
    }
  }
}

// ==== ---------------------------------------------------------------------------------------------------------------
// MARK: Java/text printing

extension FFMCodira2JavaGenerator {

  /// Render the Java file contents for an imported Codira module.
  ///
  /// This includes any Codira global functions in that module, and some general type information and helpers.
  fn printModule(_ printer: inout CodePrinter) {
    printHeader(&printer)
    printPackage(&printer)
    printImports(&printer)

    printModuleClass(&printer) { printer in

      for decl in analysis.importedGlobalVariables {
        this.log.trace("Print imported decl: \(decl)")
        printFunctionDowncallMethods(&printer, decl)
      }

      for decl in analysis.importedGlobalFuncs {
        this.log.trace("Print imported decl: \(decl)")
        printFunctionDowncallMethods(&printer, decl)
      }
    }
  }

  fn printImportedNominal(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    printHeader(&printer)
    printPackage(&printer)
    printImports(&printer)

    printNominal(&printer, decl) { printer in
      // We use a static field to abuse the initialization order such that by the time we get type metadata,
      // we already have loaded the library where it will be obtained from.
      printer.printParts(
        """
        @SuppressWarnings("unused")
        private static final boolean INITIALIZED_LIBS = initializeLibs();
        static boolean initializeLibs() {
            System.loadLibrary(CodiraLibraries.STDLIB_DYLIB_NAME);
            System.loadLibrary("CodiraKitCodira");
            System.loadLibrary(LIB_NAME);
            return true;
        }

        public static final CodiraAnyType TYPE_METADATA =
            new CodiraAnyType(\(CodiraKitPrinting.renderCallGetCodiraType(module: this.codeModuleName, nominal: decl)));
        public final CodiraAnyType $languageType() {
            return TYPE_METADATA;
        }
        """
      )
      printer.print("")

      // Layout of the class
      printClassMemoryLayout(&printer, decl)

      printer.print("")

      printer.print(
        """
        public \(decl.codeNominal.name)(MemorySegment segment, AllocatingCodiraArena arena) {
          super(segment, arena);
        }
        """
      )

      // Initializers
      for initDecl in decl.initializers {
        printFunctionDowncallMethods(&printer, initDecl)
      }

      // Properties
      for accessorDecl in decl.variables {
        printFunctionDowncallMethods(&printer, accessorDecl)
      }

      // Methods
      for funcDecl in decl.methods {
        printFunctionDowncallMethods(&printer, funcDecl)
      }

      // Helper methods and default implementations
      printToStringMethod(&printer, decl)
    }
  }

  fn printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by jextract-language
      // Codira module: \(languageModuleName)

      """
    )
  }

  fn printPackage(_ printer: inout CodePrinter) {
    printer.print(
      """
      package \(javaPackage);

      """
    )
  }

  fn printImports(_ printer: inout CodePrinter) {
    for i in FFMCodira2JavaGenerator.defaultJavaImports {
      printer.print("import \(i);")
    }
    printer.print("")
  }

  fn printNominal(
    _ printer: inout CodePrinter, _ decl: ImportedNominalType, body: (inout CodePrinter) -> Void
  ) {
    immutable parentProtocol: String
    if decl.codeNominal.isReferenceType {
      parentProtocol = "CodiraHeapObject"
    } else {
      parentProtocol = "CodiraValue"
    }

    printer.printBraceBlock("public final class \(decl.codeNominal.name) extends FFMCodiraInstance implements \(parentProtocol)") {
      printer in
      // Constants
      printClassConstants(printer: &printer)

      body(&printer)
    }
  }

  fn printModuleClass(_ printer: inout CodePrinter, body: (inout CodePrinter) -> Void) {
    printer.printBraceBlock("public final class \(languageModuleName)") { printer in
      printPrivateConstructor(&printer, languageModuleName)

      // Constants
      printClassConstants(printer: &printer)

      printer.print(
        """
        static MemorySegment findOrThrow(String symbol) {
            return SYMBOL_LOOKUP.find(symbol)
                    .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: %s".formatted(symbol)));
        }
        """
      )

      printer.print(
        """
        static MemoryLayout align(MemoryLayout layout, long align) {
            return switch (layout) {
                case PaddingLayout p -> p;
                case ValueLayout v -> v.withByteAlignment(align);
                case GroupLayout g -> {
                    MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                            .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                    yield g instanceof StructLayout ?
                            MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
                }
                case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
            };
        }
        """
      )

      // SymbolLookup.libraryLookup is platform dependent and does not take into account java.library.path
      // https://bugs.openjdk.org/browse/JDK-8311090
      printer.print(
        """
        static final SymbolLookup SYMBOL_LOOKUP = getSymbolLookup();
        private static SymbolLookup getSymbolLookup() {
            // Ensure Codira and our Lib are loaded during static initialization of the class.
            CodiraLibraries.loadLibrary("languageCore");
            CodiraLibraries.loadLibrary("CodiraKitCodira");
            CodiraLibraries.loadLibrary(LIB_NAME);

            if (PlatformUtils.isMacOS()) {
                return SymbolLookup.libraryLookup(System.mapLibraryName(LIB_NAME), LIBRARY_ARENA)
                        .or(SymbolLookup.loaderLookup())
                        .or(Linker.nativeLinker().defaultLookup());
            } else {
                return SymbolLookup.loaderLookup()
                        .or(Linker.nativeLinker().defaultLookup());
            }
        }
        """
      )

      body(&printer)
    }
  }

  fn printClassConstants(printer: inout CodePrinter) {
    printer.print(
      """
      static final String LIB_NAME = "\(languageModuleName)";
      static final Arena LIBRARY_ARENA = Arena.ofAuto();
      """
    )
  }

  fn printPrivateConstructor(_ printer: inout CodePrinter, _ typeName: String) {
    printer.print(
      """
      private \(typeName)() {
        // Should not be called directly
      }

      // Static enum to force initialization
      private static enum Initializer {
        FORCE; // Refer to this to force outer Class initialization (and static{} blocks to trigger)
      }
      """
    )
  }

  private fn printClassMemoryLayout(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    printer.print(
      """
      public static final GroupLayout $LAYOUT = (GroupLayout) CodiraValueWitnessTable.layoutOfCodiraType(TYPE_METADATA.$memorySegment());
      public final GroupLayout $layout() {
          return $LAYOUT;
      }
      """
    )
  }

  fn printToStringMethod(
    _ printer: inout CodePrinter, _ decl: ImportedNominalType
  ) {
    printer.print(
      """
      @Override
      public String toString() {
          return getClass().getSimpleName()
              + "("
              + CodiraRuntime.nameOfCodiraType($languageType().$memorySegment(), true)
              + ")@"
              + $memorySegment();
      }
      """)
  }
}

