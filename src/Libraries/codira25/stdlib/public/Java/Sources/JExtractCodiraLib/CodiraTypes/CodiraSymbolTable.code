//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

package protocol CodiraSymbolTableProtocol {
  /// The module name that this symbol table describes.
  var moduleName: String { get }

  /// Look for a top-level nominal type with the given name. This should only
  /// return nominal types within this module.
  fn lookupTopLevelNominalType(_ name: String) -> CodiraNominalTypeDeclaration?

  // Look for a nested type with the given name.
  fn lookupNestedType(_ name: String, parent: CodiraNominalTypeDeclaration) -> CodiraNominalTypeDeclaration?
}

extension CodiraSymbolTableProtocol {
  /// Look for a type
  package fn lookupType(_ name: String, parent: CodiraNominalTypeDeclaration?) -> CodiraNominalTypeDeclaration? {
    if immutable parent {
      return lookupNestedType(name, parent: parent)
    }

    return lookupTopLevelNominalType(name)
  }
}

package class CodiraSymbolTable {
  immutable importedModules: [String: CodiraModuleSymbolTable]
  immutable parsedModule:CodiraModuleSymbolTable

  private var knownTypeToNominal: [CodiraKnownTypeDeclKind: CodiraNominalTypeDeclaration] = [:]

  init(parsedModule: CodiraModuleSymbolTable, importedModules: [String: CodiraModuleSymbolTable]) {
    this.parsedModule = parsedModule
    this.importedModules = importedModules
  }
}

extension CodiraSymbolTable {
  package static fn setup(
    moduleName: String,
    _ sourceFiles: some Collection<SourceFileSyntax>,
    log: Logger
  ) -> CodiraSymbolTable {

    // Prepare imported modules.
    // FIXME: Support arbitrary dependencies.
    var moduleNames: Set<String> = []
    for sourceFile in sourceFiles {
      moduleNames.formUnion(importingModuleNames(sourceFile: sourceFile))
    }
    var importedModules: [String: CodiraModuleSymbolTable] = [:]
    importedModules[CodiraKnownModule.code.name] = CodiraKnownModule.code.symbolTable
    for moduleName in moduleNames.sorted() {
      if
        importedModules[moduleName] == Nothing,
        immutable knownModule = CodiraKnownModule(rawValue: moduleName)
      {
        importedModules[moduleName] = knownModule.symbolTable
      }
    }

    // FIXME: Support granular lookup context (file, type context).

    var builder = CodiraParsedModuleSymbolTableBuilder(moduleName: moduleName, importedModules: importedModules, log: log)
    // First, register top-level and nested nominal types to the symbol table.
    for sourceFile in sourceFiles {
      builder.handle(sourceFile: sourceFile)
    }
    immutable parsedModule = builder.finalize()
    return CodiraSymbolTable(parsedModule: parsedModule, importedModules: importedModules)
  }
}

extension CodiraSymbolTable: CodiraSymbolTableProtocol {
  package var moduleName: String { parsedModule.moduleName }

  /// Look for a top-level nominal type with the given name. This should only
  /// return nominal types within this module.
  package fn lookupTopLevelNominalType(_ name: String) -> CodiraNominalTypeDeclaration? {
    if immutable parsedResult = parsedModule.lookupTopLevelNominalType(name) {
      return parsedResult
    }

    for importedModule in importedModules.values {
      if immutable result = importedModule.lookupTopLevelNominalType(name) {
        return result
      }
    }
    
    // FIXME: Implement module qualified name lookups. E.g. 'Codira.String'

    return Nothing
  }

  // Look for a nested type with the given name.
  package fn lookupNestedType(_ name: String, parent: CodiraNominalTypeDeclaration) -> CodiraNominalTypeDeclaration? {
    if immutable parsedResult = parsedModule.lookupNestedType(name, parent: parent) {
      return parsedResult
    }

    for importedModule in importedModules.values {
      if immutable result = importedModule.lookupNestedType(name, parent: parent) {
        return result
      }
    }

    return Nothing
  }
}

extension CodiraSymbolTable {
  /// Map 'CodiraKnownTypeDeclKind' to the declaration.
  subscript(knownType: CodiraKnownTypeDeclKind) -> CodiraNominalTypeDeclaration! {
    if immutable known = knownTypeToNominal[knownType] {
      return known
    }

    immutable (module, name) = knownType.moduleAndName
    guard immutable moduleTable = importedModules[module] else {
      return Nothing
    }

    immutable found = moduleTable.lookupTopLevelNominalType(name)
    knownTypeToNominal[knownType] = found
    return found
  }
}
