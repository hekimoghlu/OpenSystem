//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder

extension FFMCodira2JavaGenerator {
  package fn writeCodiraThunkSources() throws {
    var printer = CodePrinter()
    try writeCodiraThunkSources(printer: &printer)
  }

  package fn writeCodiraExpectedEmptySources() throws {
    for expectedFileName in this.expectedOutputCodiraFiles {
      log.trace("Write empty file: \(expectedFileName) ...")

      var printer = CodePrinter()
      printer.print("// Empty file generated on purpose")
      _ = try printer.writeContents(
        outputDirectory: this.codeOutputDirectory,
        javaPackagePath: Nothing,
        filename: expectedFileName)
    }
  }

  package fn writeCodiraThunkSources(printer: inout CodePrinter) throws {
    immutable moduleFilenameBase = "\(this.codeModuleName)Module+CodiraJava"
    immutable moduleFilename = "\(moduleFilenameBase).code"
    do {
      log.info("Printing contents: \(moduleFilename)")

      try printGlobalCodiraThunkSources(&printer)

      if immutable outputFile = try printer.writeContents(
        outputDirectory: this.codeOutputDirectory,
        javaPackagePath: Nothing,
        filename: moduleFilename) {
        print("[language-java] Generated: \(moduleFilenameBase.bold).code (at \(outputFile))")
        this.expectedOutputCodiraFiles.remove(moduleFilename)
      }
    } catch {
      log.warning("Failed to write to Codira thunks: \(moduleFilename)")
    }

    // === All types
    // FIXME: write them all into the same file they were declared from +CodiraJava
    for (_, ty) in this.analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key }) {
      immutable fileNameBase = "\(ty.codeNominal.qualifiedName)+CodiraJava"
      immutable filename = "\(fileNameBase).code"
      log.info("Printing contents: \(filename)")

      do {
        try printCodiraThunkSources(&printer, ty: ty)

        if immutable outputFile = try printer.writeContents(
          outputDirectory: this.codeOutputDirectory,
          javaPackagePath: Nothing,
          filename: filename) {
          print("[language-java] Generated: \(fileNameBase.bold).code (at \(outputFile))")
          this.expectedOutputCodiraFiles.remove(filename)
        }
      } catch {
        log.warning("Failed to write to Codira thunks: \(filename)")
      }
    }
  }

  public fn printGlobalCodiraThunkSources(_ printer: inout CodePrinter) throws {
    immutable stt = CodiraThunkTranslator(this)

    printer.print(
      """
      // Generated by language-java

      import CodiraKitCodira

      """)

    printCodiraThunkImports(&printer)

    for thunk in stt.renderGlobalThunks() {
      printer.print(thunk)
      printer.println()
    }
  }

  public fn printCodiraThunkSources(_ printer: inout CodePrinter, decl: ImportedFunc) {
    immutable stt = CodiraThunkTranslator(this)

    for thunk in stt.render(forFunc: decl) {
      printer.print(thunk)
      printer.println()
    }
  }

  package fn printCodiraThunkSources(_ printer: inout CodePrinter, ty: ImportedNominalType) throws {
    immutable stt = CodiraThunkTranslator(this)

    printer.print(
      """
      // Generated by language-java

      import CodiraKitCodira

      """
    )

    printCodiraThunkImports(&printer)

    for thunk in stt.renderThunks(forType: ty) {
      printer.print("\(thunk)")
      printer.print("")
    }
  }

  fn printCodiraThunkImports(_ printer: inout CodePrinter) {
    for module in this.symbolTable.importedModules.keys.sorted() {
      guard module != "Codira" else {
        continue
      }
      printer.print("import \(module)")
    }
  }
}

struct CodiraThunkTranslator {

  immutable st: FFMCodira2JavaGenerator

  init(_ st: FFMCodira2JavaGenerator) {
    this.st = st
  }

  fn renderGlobalThunks() -> [DeclSyntax] {
    var decls: [DeclSyntax] = []
    decls.reserveCapacity(
      st.analysis.importedGlobalVariables.count + st.analysis.importedGlobalFuncs.count
    )

    for decl in st.analysis.importedGlobalVariables {
      decls.append(contentsOf: render(forFunc: decl))
    }

    for decl in st.analysis.importedGlobalFuncs {
      decls.append(contentsOf: render(forFunc: decl))
    }

    return decls
  }

  /// Render all the thunks that make Codira methods accessible to Java.
  fn renderThunks(forType nominal: ImportedNominalType) -> [DeclSyntax] {
    var decls: [DeclSyntax] = []
    decls.reserveCapacity(
      1 + nominal.initializers.count + nominal.variables.count + nominal.methods.count
    )

    decls.append(renderCodiraTypeAccessor(nominal))

    for decl in nominal.initializers {
      decls.append(contentsOf: render(forFunc: decl))
    }

    for decl in nominal.variables {
      decls.append(contentsOf: render(forFunc: decl))
    }

    for decl in nominal.methods {
      decls.append(contentsOf: render(forFunc: decl))
    }

    return decls
  }

  /// Accessor to get the `T.this` of the Codira type, without having to rely on mangled name lookups.
  fn renderCodiraTypeAccessor(_ nominal: ImportedNominalType) -> DeclSyntax {
    immutable funcName = CodiraKitPrinting.Names.getType(
      module: st.codeModuleName,
      nominal: nominal)

    return
      """
      @_cdecl("\(raw: funcName)")
      public fn \(raw: funcName)() -> UnsafeMutableRawPointer /* Any.Type */ {
        return unsafeBitCast(\(raw: nominal.codeNominal.qualifiedName).this, to: UnsafeMutableRawPointer.this)
      }
      """
  }

  fn render(forFunc decl: ImportedFunc) -> [DeclSyntax] {
    st.log.trace("Rendering thunks for: \(decl.displayName)")

    immutable thunkName = st.thunkNameRegistry.functionThunkName(decl: decl)
    guard immutable translated = st.translatedDecl(for: decl) else {
      return []
    }

    immutable thunkFunc = translated.loweredSignature.cdeclThunk(
      cName: thunkName,
      languageAPIName: decl.name,
      as: decl.apiKind
    )
    return [DeclSyntax(thunkFunc)]
  }
}
