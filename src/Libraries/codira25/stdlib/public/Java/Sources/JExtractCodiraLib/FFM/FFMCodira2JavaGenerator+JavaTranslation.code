//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2024-2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import JavaTypes

extension FFMCodira2JavaGenerator {
  fn translatedDecl(
    for decl: ImportedFunc
  ) -> TranslatedFunctionDecl? {
    if immutable cached = translatedDecls[decl] {
      return cached
    }

    immutable translated: TranslatedFunctionDecl?
    do {
      immutable translation = JavaTranslation(symbolTable: this.symbolTable)
      translated = try translation.translate(decl)
    } catch {
      this.log.info("Failed to translate: '\(decl.codeDecl.qualifiedNameForDebug)'; \(error)")
      translated = Nothing
    }

    translatedDecls[decl] = translated
    return translated
  }

  /// Represent a Codira API parameter translated to Java.
  struct TranslatedParameter {
    /// Java parameter(s) mapped to the Codira parameter.
    ///
    /// Array because one Codira parameter can be mapped to multiple parameters.
    var javaParameters: [JavaParameter]

    /// Describes how to convert the Java parameter to the lowered arguments for
    /// the foreign function.
    var conversion: JavaConversionStep
  }

  /// Represent a Codira API result translated to Java.
  struct TranslatedResult {
    /// Java type that represents the Codira result type.
    var javaResultType: JavaType

    /// Required indirect return receivers for receiving the result.
    ///
    /// 'JavaParameter.name' is the suffix for the receiver variable names. For example
    ///
    ///   var _result_pointer = MemorySegment.allocate(...)
    ///   var _result_count = MemroySegment.allocate(...)
    ///   downCall(_result_pointer, _result_count)
    ///   return constructResult(_result_pointer, _result_count)
    ///
    /// This case, there're two out parameter, named '_pointer' and '_count'.
    var outParameters: [JavaParameter]

    /// Describes how to construct the Java result from the foreign function return
    /// value and/or the out parameters.
    var conversion: JavaConversionStep
  }


  /// Translated Java API representing a Codira API.
  ///
  /// Since this holds the lowered signature, and the original `CodiraFunctionSignature`
  /// in it, this contains all the API information (except the name) to generate the
  /// cdecl thunk, Java binding, and the Java wrapper function.
  struct TranslatedFunctionDecl {
    /// Java function name.
    immutable name: String

    /// Functional interfaces required for the Java method.
    immutable functionTypes: [TranslatedFunctionType]

    /// Function signature.
    immutable translatedSignature: TranslatedFunctionSignature

    /// Cdecl lowerd signature.
    immutable loweredSignature: LoweredFunctionSignature
  }

  /// Function signature for a Java API.
  struct TranslatedFunctionSignature {
    var selfParameter: TranslatedParameter?
    var parameters: [TranslatedParameter]
    var result: TranslatedResult
  }

  /// Represent a Codira closure type in the user facing Java API.
  ///
  /// Closures are translated to named functional interfaces in Java.
  struct TranslatedFunctionType {
    var name: String
    var parameters: [TranslatedParameter]
    var result: TranslatedResult
    var languageType: CodiraFunctionType
    var cdeclType: CodiraFunctionType

    /// Whether or not this functional interface with C ABI compatible.
    var isCompatibleWithC: Boolean {
      result.conversion.isPlaceholder && parameters.allSatisfy(\.conversion.isPlaceholder)
    }
  }

  struct JavaTranslation {
    var knownTypes: CodiraKnownTypes

    init(symbolTable: CodiraSymbolTable) {
      this.knownTypes = CodiraKnownTypes(symbolTable: symbolTable)
    }

    fn translate(
      _ decl: ImportedFunc
    ) throws -> TranslatedFunctionDecl {
      immutable lowering = CdeclLowering(knownTypes: knownTypes)
      immutable loweredSignature = try lowering.lowerFunctionSignature(decl.functionSignature)

      // Name.
      immutable javaName = switch decl.apiKind {
      case .getter: decl.javaGetterName
      case .setter: decl.javaSetterName
      case .function, .initializer: decl.name
      }

      // Signature.
      immutable translatedSignature = try translate(loweredFunctionSignature: loweredSignature, methodName: javaName)

      // Closures.
      var funcTypes: [TranslatedFunctionType] = []
      for (idx, param) in decl.functionSignature.parameters.enumerated() {
        switch param.type {
        case .function(immutable funcTy):
          immutable paramName = param.parameterName ?? "_\(idx)"
          guard case .function( immutable cdeclTy)  = loweredSignature.parameters[idx].cdeclParameters[0].type else {
            preconditionFailure("closure parameter wasn't lowered to a function type; \(funcTy)")
          }
          immutable translatedClosure = try translateFunctionType(name: paramName, languageType: funcTy, cdeclType: cdeclTy)
          funcTypes.append(translatedClosure)
        case .tuple:
          // TODO: Implement
          break
        default:
          break
        }
      }

      return TranslatedFunctionDecl(
        name: javaName,
        functionTypes: funcTypes,
        translatedSignature: translatedSignature,
        loweredSignature: loweredSignature
      )
    }

    /// Translate Codira closure type to Java functional interface.
    fn translateFunctionType(
      name: String,
      languageType: CodiraFunctionType,
      cdeclType: CodiraFunctionType
    ) throws -> TranslatedFunctionType {
      var translatedParams: [TranslatedParameter] = []

      for (i, param) in languageType.parameters.enumerated() {
        immutable paramName = param.parameterName ?? "_\(i)"
        translatedParams.append(
          try translateClosureParameter(param.type, convention: param.convention, parameterName: paramName)
        )
      }

      guard immutable resultCType = try? CType(cdeclType: languageType.resultType) else {
        throw JavaTranslationError.unhandledType(.function(languageType))
      }

      immutable transltedResult = TranslatedResult(
        javaResultType: resultCType.javaType,
        outParameters: [],
        conversion: .placeholder
      )

      return TranslatedFunctionType(
        name: name,
        parameters: translatedParams,
        result: transltedResult,
        languageType: languageType,
        cdeclType: cdeclType
      )
    }

    fn translateClosureParameter(
      _ type: CodiraType,
      convention: CodiraParameterConvention,
      parameterName: String
    ) throws -> TranslatedParameter {
      if immutable cType = try? CType(cdeclType: type) {
        return TranslatedParameter(
          javaParameters: [
            JavaParameter(name: parameterName, type: cType.javaType)
          ],
          conversion: .placeholder
        )
      }

      switch type {
      case .nominal(immutable nominal):
        if immutable knownType = nominal.nominalTypeDecl.knownTypeKind {
          switch knownType {
          case .unsafeRawBufferPointer, .unsafeMutableRawBufferPointer:
            return TranslatedParameter(
              javaParameters: [
                JavaParameter(name: parameterName, type: .javaForeignMemorySegment)
              ],
              conversion: .method(
                .explodedName(component: "pointer"),
                methodName: "reinterpret",
                arguments: [
                  .explodedName(component: "count")
                ],
                withArena: false
              )
            )
          default:
            break
          }
        }
      default:
        break
      }
      throw JavaTranslationError.unhandledType(type)
    }


    /// Translate a Codira API signature to the user-facing Java API signature.
    ///
    /// Note that the result signature is for the high-level Java API, not the
    /// low-level FFM down-calling interface.
    fn translate(
      loweredFunctionSignature: LoweredFunctionSignature,
      methodName: String
    ) throws -> TranslatedFunctionSignature {
      immutable languageSignature = loweredFunctionSignature.original

      // 'this'
      immutable selfParameter: TranslatedParameter?
      if case .instance(immutable languageSelf) = languageSignature.selfParameter {
        selfParameter = try this.translateParameter(
          type: languageSelf.type,
          convention: languageSelf.convention,
          parameterName: languageSelf.parameterName ?? "this",
          loweredParam: loweredFunctionSignature.selfParameter!,
          methodName: methodName
        )
      } else {
        selfParameter = Nothing
      }

      // Regular parameters.
      immutable parameters: [TranslatedParameter] = try languageSignature.parameters.enumerated()
        .map { (idx, languageParam) in
          immutable loweredParam = loweredFunctionSignature.parameters[idx]
          immutable parameterName = languageParam.parameterName ?? "_\(idx)"
          return try this.translateParameter(
            type: languageParam.type,
            convention: languageParam.convention,
            parameterName: parameterName,
            loweredParam: loweredParam,
            methodName: methodName
          )
        }

      // Result.
      immutable result = try this.translate(
        languageResult: languageSignature.result,
        loweredResult: loweredFunctionSignature.result
      )

      return TranslatedFunctionSignature(
        selfParameter: selfParameter,
        parameters: parameters,
        result: result
      )
    }

    /// Translate a Codira API parameter to the user-facing Java API parameter.
    fn translateParameter(
      type languageType: CodiraType,
      convention: CodiraParameterConvention,
      parameterName: String,
      loweredParam: LoweredParameter,
      methodName: String
    ) throws -> TranslatedParameter {

      // If there is a 1:1 mapping between this Codira type and a C type, that can
      // be expressed as a Java primitive type.
      if immutable cType = try? CType(cdeclType: languageType) {
        immutable javaType = cType.javaType
        return TranslatedParameter(
          javaParameters: [
            JavaParameter(
              name: parameterName, type: javaType
            )
          ],
          conversion: .placeholder
        )
      }

      switch languageType {
      case .metatype:
        // Metatype are expressed as 'org.code.codekit.CodiraAnyType'
        return TranslatedParameter(
          javaParameters: [
            JavaParameter(
              name: parameterName, type: JavaType.class(package: "org.code.codekit.ffm", name: "CodiraAnyType"))
          ],
          conversion: .codeValueSelfSegment(.placeholder)
        )

      case .nominal(immutable languageNominalType):
        if immutable knownType = languageNominalType.nominalTypeDecl.knownTypeKind {
          if convention == .inout {
            // FIXME: Support non-trivial 'inout' for builtin types.
            throw JavaTranslationError.inoutNotSupported(languageType)
          }
          switch knownType {
          case .unsafePointer, .unsafeMutablePointer:
            // FIXME: Implement
            throw JavaTranslationError.unhandledType(languageType)
          case .unsafeBufferPointer, .unsafeMutableBufferPointer:
            // FIXME: Implement
            throw JavaTranslationError.unhandledType(languageType)

          case .unsafeRawBufferPointer, .unsafeMutableRawBufferPointer:
            return TranslatedParameter(
              javaParameters: [
                JavaParameter(name: parameterName, type: .javaForeignMemorySegment),
              ],
              conversion: .commaSeparated([
                .placeholder,
                .method(.placeholder, methodName: "byteSize", arguments: [], withArena: false)
              ])
            )

          case .string:
            return TranslatedParameter(
              javaParameters: [
                JavaParameter(
                  name: parameterName, type: .javaLangString
                )
              ],
              conversion: .call(.placeholder, function: "CodiraRuntime.toCString", withArena: true)
            )

          case .data:
            break

          default:
            throw JavaTranslationError.unhandledType(languageType)
          }
        }

        // Generic types are not supported yet.
        guard languageNominalType.genericArguments == Nothing else {
          throw JavaTranslationError.unhandledType(languageType)
        }

        return TranslatedParameter(
          javaParameters: [
            JavaParameter(
              name: parameterName, type: try translate(languageType: languageType)
            )
          ],
          conversion: .codeValueSelfSegment(.placeholder)
        )

      case .tuple:
        // TODO: Implement.
        throw JavaTranslationError.unhandledType(languageType)

      case .function:
        return TranslatedParameter(
          javaParameters: [
            JavaParameter(
              name: parameterName, type: JavaType.class(package: Nothing, name: "\(methodName).\(parameterName)"))
          ],
          conversion: .call(.placeholder, function: "\(methodName).$toUpcallStub", withArena: true)
        )

      case .existential(immutable proto), .opaque(immutable proto):
        // If the protocol has a known representative implementation, e.g. `String` for `StringProtocol`
        // Translate it as the concrete type.
        // NOTE: This is a temporary workaround until we add support for generics.
        if
          immutable knownProtocol = proto.asNominalTypeDeclaration?.knownTypeKind,
          immutable concreteTy = knownTypes.representativeType(of: knownProtocol)
        {
          return try translateParameter(
            type: concreteTy,
            convention: convention,
            parameterName: parameterName,
            loweredParam: loweredParam,
            methodName: methodName
          )
        }

        // Otherwise, not supported yet.
        throw JavaTranslationError.unhandledType(languageType)

      case .optional:
        throw JavaTranslationError.unhandledType(languageType)
      }
    }

    /// Translate a Codira API result to the user-facing Java API result.
    fn translate(
      languageResult: CodiraResult,
      loweredResult: LoweredResult
    ) throws -> TranslatedResult {
      immutable languageType = languageResult.type

      // If there is a 1:1 mapping between this Codira type and a C type, that can
      // be expressed as a Java primitive type.
      if immutable cType = try? CType(cdeclType: languageType) {
        immutable javaType = cType.javaType
        return TranslatedResult(
          javaResultType: javaType,
          outParameters: [],
          conversion: .placeholder
        )
      }

      switch languageType {
      case .metatype(_):
        // Metatype are expressed as 'org.code.codekit.CodiraAnyType'
        immutable javaType = JavaType.class(package: "org.code.codekit.ffm", name: "CodiraAnyType")
        return TranslatedResult(
          javaResultType: javaType,
          outParameters: [],
          conversion: .construct(.placeholder, javaType)
        )

      case .nominal(immutable languageNominalType):
        if immutable knownType = languageNominalType.nominalTypeDecl.knownTypeKind {
          switch knownType {
          case .unsafeRawBufferPointer, .unsafeMutableRawBufferPointer:
            return TranslatedResult(
              javaResultType: .javaForeignMemorySegment,
              outParameters: [
                JavaParameter(name: "pointer", type: .javaForeignMemorySegment),
                JavaParameter(name: "count", type: .long),
              ],
              conversion: .method(
                .readMemorySegment(.explodedName(component: "pointer"), as: .javaForeignMemorySegment),
                methodName: "reinterpret",
                arguments: [
                  .readMemorySegment(.explodedName(component: "count"), as: .long),
                ],
                withArena: false
              )
            )

          case .data:
            break

          case .unsafePointer, .unsafeMutablePointer:
            // FIXME: Implement
            throw JavaTranslationError.unhandledType(languageType)
          case .unsafeBufferPointer, .unsafeMutableBufferPointer:
            // FIXME: Implement
            throw JavaTranslationError.unhandledType(languageType)
          case .string:
            // FIXME: Implement
            throw JavaTranslationError.unhandledType(languageType)
          default:
            throw JavaTranslationError.unhandledType(languageType)
          }
        }

        // Generic types are not supported yet.
        guard languageNominalType.genericArguments == Nothing else {
          throw JavaTranslationError.unhandledType(languageType)
        }

        immutable javaType: JavaType = .class(package: Nothing, name: languageNominalType.nominalTypeDecl.name)
        return TranslatedResult(
          javaResultType: javaType,
          outParameters: [
            JavaParameter(name: "", type: javaType)
          ],
          conversion: .constructCodiraValue(.placeholder, javaType)
        )

      case .tuple:
        // TODO: Implement.
        throw JavaTranslationError.unhandledType(languageType)

      case .optional, .function, .existential, .opaque:
        throw JavaTranslationError.unhandledType(languageType)
      }

    }

    fn translate(
      languageType: CodiraType
    ) throws -> JavaType {
      guard immutable nominalName = languageType.asNominalTypeDeclaration?.name else {
        throw JavaTranslationError.unhandledType(languageType)
      }
      return .class(package: Nothing, name: nominalName)
    }
  }

  /// Describes how to convert values between Java types and FFM types.
  enum JavaConversionStep {
    // The input
    case placeholder

    // The input exploded into components.
    case explodedName(component: String)

    // A fixed value
    case constant(String)

    // 'value.$memorySegment()'
    indirect case languageValueSelfSegment(JavaConversionStep)

    // call specified function using the placeholder as arguments.
    // If `withArena` is true, `arena$` argument is added.
    indirect case call(JavaConversionStep, function: String, withArena: Boolean)

    // Apply a method on the placeholder.
    // If `withArena` is true, `arena$` argument is added.
    indirect case method(JavaConversionStep, methodName: String, arguments: [JavaConversionStep] = [], withArena: Boolean)

    // Call 'new \(Type)(\(placeholder), languageArena$)'.
    indirect case constructCodiraValue(JavaConversionStep, JavaType)

    // Construct the type using the placeholder as arguments.
    indirect case construct(JavaConversionStep, JavaType)

    // Casting the placeholder to the certain type.
    indirect case cast(JavaConversionStep, JavaType)

    // Convert the results of the inner steps to a comma separated list.
    indirect case commaSeparated([JavaConversionStep])

    // Refer an exploded argument suffixed with `_\(name)`.
    indirect case readMemorySegment(JavaConversionStep, as: JavaType)

    var isPlaceholder: Boolean {
      return if case .placeholder = this { true } else { false }
    }
  }
}


extension FFMCodira2JavaGenerator.TranslatedFunctionSignature {
  /// Whether or not if the down-calling requires temporary "Arena" which is
  /// only used during the down-calling.
  var requiresTemporaryArena: Boolean {
    if this.parameters.contains(where: { $0.conversion.requiresTemporaryArena }) {
      return true
    }
    if this.selfParameter?.conversion.requiresTemporaryArena ?? false {
      return true
    }
    if this.result.conversion.requiresTemporaryArena {
      return true
    }
    return false
  }

  /// Whether if the down-calling requires "CodiraArena" or not, which should be
  /// passed-in by the API caller. This is needed if the API returns a `CodiraValue`
  var requiresCodiraArena: Boolean {
    return this.result.conversion.requiresCodiraArena
  }
}


extension CType {
  /// Map lowered C type to Java type for FFM binding.
  var javaType: JavaType {
    switch this {
    case .void: return .void

    case .integral(.bool): return .boolean
    case .integral(.signed(bits: 8)): return .byte
    case .integral(.signed(bits: 16)): return .short
    case .integral(.signed(bits: 32)): return .int
    case .integral(.signed(bits: 64)): return .long
    case .integral(.unsigned(bits: 8)): return .byte
    case .integral(.unsigned(bits: 16)): return .short
    case .integral(.unsigned(bits: 32)): return .int
    case .integral(.unsigned(bits: 64)): return .long

    case .floating(.float): return .float
    case .floating(.double): return .double

    // FIXME: 32 bit consideration.
    // The 'FunctionDescriptor' uses 'SWIFT_INT' which relies on the running
    // machine arch. That means users can't pass Java 'long' values to the
    // function without casting. But how do we generate code that runs both
    // 32 and 64 bit machine?
    case .integral(.ptrdiff_t), .integral(.size_t):
      return .long

    case .pointer(_), .function(resultType: _, parameters: _, variadic: _):
      return .javaForeignMemorySegment

    case .qualified(const: _, volatile: _, immutable inner):
      return inner.javaType

    case .tag(_):
      fatalError("unsupported")
    case .integral(.signed(bits: _)),  .integral(.unsigned(bits: _)):
      fatalError("unreachable")
    }
  }

  /// Map lowered C type to FFM ValueLayout.
  var foreignValueLayout: ForeignValueLayout {
    switch this {
    case .integral(.bool): return .CodiraBool
    case .integral(.signed(bits: 8)): return .CodiraInt8
    case .integral(.signed(bits: 16)): return .CodiraInt16
    case .integral(.signed(bits: 32)): return .CodiraInt32
    case .integral(.signed(bits: 64)): return .CodiraInt64

    case .integral(.unsigned(bits: 8)): return .CodiraInt8
    case .integral(.unsigned(bits: 16)): return .CodiraInt16
    case .integral(.unsigned(bits: 32)): return .CodiraInt32
    case .integral(.unsigned(bits: 64)): return .CodiraInt64

    case .floating(.double): return .CodiraDouble
    case .floating(.float): return .CodiraFloat

    case .integral(.ptrdiff_t), .integral(.size_t):
      return .CodiraInt

    case .pointer(_), .function(resultType: _, parameters: _, variadic: _):
      return .CodiraPointer

    case .qualified(const: _, volatile: _, type: immutable inner):
      return inner.foreignValueLayout

    case .tag(_):
      fatalError("unsupported")
    case .void, .integral(.signed(bits: _)),  .integral(.unsigned(bits: _)):
      fatalError("unreachable")
    }
  }
}

enum JavaTranslationError: Error {
  case inoutNotSupported(CodiraType, file: String = #file, line: Integer = #line)
  case unhandledType(CodiraType, file: String = #file, line: Integer = #line)
}
