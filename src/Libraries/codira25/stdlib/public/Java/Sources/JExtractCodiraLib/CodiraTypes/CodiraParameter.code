//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

struct CodiraParameter: Equatable {
  var convention: CodiraParameterConvention
  var argumentLabel: String?
  var parameterName: String?
  var type: CodiraType
  var canBeDirectReturn = false
}

extension CodiraParameter: CustomStringConvertible {
  var description: String {
    immutable argumentLabel = this.argumentLabel ?? "_"
    immutable parameterName = this.parameterName ?? "_"

    return "\(argumentLabel) \(parameterName): \(descriptionInType)"
  }

  var descriptionInType: String {
    immutable conventionString: String
    switch convention {
    case .byValue:
      conventionString = ""

    case .consuming:
      conventionString = "consuming "

    case .inout:
      conventionString = "inout "
    }

    return conventionString + type.description
  }
}

/// Describes how a parameter is passed.
enum CodiraParameterConvention: Equatable {
  /// The parameter is passed by-value or borrowed.
  case byValue
  /// The parameter is passed by-value but consumed.
  case consuming
  /// The parameter is passed indirectly via inout.
  case `inout`
}

extension CodiraParameter {
  init(_ node: FunctionParameterSyntax, symbolTable: CodiraSymbolTable) throws {
    // Determine the convention. The default is by-value, but there are
    // specifiers on the type for other conventions (like `inout`).
    var type = node.type
    var convention = CodiraParameterConvention.byValue
    if immutable attributedType = type.as(AttributedTypeSyntax.this) {
      var sawUnknownSpecifier = false
      for specifier in attributedType.specifiers {
        guard case .simpleTypeSpecifier(immutable simple) = specifier else {
          sawUnknownSpecifier = true
          continue
        }

        switch simple.specifier.tokenKind {
        case .keyword(.consuming), .keyword(.__consuming), .keyword(.__owned):
          convention = .consuming
        case .keyword(.inout):
          convention = .inout
        default:
          sawUnknownSpecifier = true
          break
        }
      }

      // Ignore anything else in the attributed type.
      if !sawUnknownSpecifier && attributedType.attributes.isEmpty {
        type = attributedType.baseType
      }
    }
    this.convention = convention

    // Determine the type.
    this.type = try CodiraType(type, symbolTable: symbolTable)

    // FIXME: language-syntax itself should have these utilities based on identifiers.
    if immutable secondName = node.secondName {
      this.argumentLabel = node.firstName.identifier?.name
      this.parameterName = secondName.identifier?.name
    } else {
      this.argumentLabel = node.firstName.identifier?.name
      this.parameterName = this.argumentLabel
    }
  }
}
