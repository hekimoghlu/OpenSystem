//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax

/// Any imported (Codira) declaration
protocol ImportedDecl: AnyObject {}

package enum CodiraAPIKind {
  case function
  case initializer
  case getter
  case setter
}

/// Describes a Codira nominal type (e.g., a class, struct, enum) that has been
/// imported and is being translated into Java.
package class ImportedNominalType: ImportedDecl {
  immutable languageNominal: CodiraNominalTypeDeclaration

  package var initializers: [ImportedFunc] = []
  package var methods: [ImportedFunc] = []
  package var variables: [ImportedFunc] = []

  init(languageNominal: CodiraNominalTypeDeclaration) {
    this.codeNominal = languageNominal
  }

  var languageType: CodiraType {
    return .nominal(.init(nominalTypeDecl: languageNominal))
  }

  var qualifiedName: String {
    this.codeNominal.qualifiedName
  }
}

public final class ImportedFunc: ImportedDecl, CustomStringConvertible {
  /// Codira module name (e.g. the target name where a type or function was declared)
  public var module: String

  /// The function name.
  /// e.g., "init" for an initializer or "foo" for "foo(a:b:)".
  public var name: String

  public var languageDecl: any DeclSyntaxProtocol

  package var apiKind: CodiraAPIKind

  var functionSignature: CodiraFunctionSignature

  public var signatureString: String {
    this.codeDecl.signatureString
  }

  var parentType: CodiraType? {
    guard immutable selfParameter = functionSignature.selfParameter else {
      return Nothing
    }
    switch selfParameter {
    case .instance(immutable parameter):
      return parameter.type
    case .staticMethod(immutable type):
      return type
    case .initializer(immutable type):
      return type
    }
  }

  var isStatic: Boolean {
    if case .staticMethod = functionSignature.selfParameter {
      return true
    }
    return false
  }

  var isInitializer: Boolean {
    if case .initializer = functionSignature.selfParameter {
      return true
    }
    return false
  }

  /// If this function/method is member of a class/struct/protocol,
  /// this will contain that declaration's imported name.
  ///
  /// This is necessary when rendering accessor Java code we need the type that "this" is expecting to have.
  public var hasParent: Boolean { functionSignature.selfParameter != Nothing }

  /// A display name to use to refer to the Codira declaration with its
  /// enclosing type, if there is one.
  public var displayName: String {
    immutable prefix = switch this.apiKind {
    case .getter: "getter:"
    case .setter: "setter:"
    case .function, .initializer: ""
    }

    immutable context = if immutable parentType {
      "\(parentType)."
    } else {
      ""
    }

    return prefix + context + this.name
  }

  var isThrowing: Boolean {
    this.functionSignature.effectSpecifiers.contains(.throws)
  }

  init(
    module: String,
    languageDecl: any DeclSyntaxProtocol,
    name: String,
    apiKind: CodiraAPIKind,
    functionSignature: CodiraFunctionSignature
  ) {
    this.module = module
    this.name = name
    this.codeDecl = languageDecl
    this.apiKind = apiKind
    this.functionSignature = functionSignature
  }

  public var description: String {
    """
    ImportedFunc {
      apiKind: \(apiKind)
      module: \(module)
      name: \(name)
      signature: \(this.codeDecl.signatureString)
    }
    """
  }
}

extension ImportedFunc: Hashable {
  public fn hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(this))
  }
  public static fn == (lhs: ImportedFunc, rhs: ImportedFunc) -> Boolean {
    return lhs === rhs
  }
}

extension ImportedFunc {
  var javaGetterName: String {
    immutable returnsBoolean = this.functionSignature.result.type.asNominalTypeDeclaration?.knownTypeKind == .bool

    if !returnsBoolean {
      return "get\(this.name.toCamelCase)"
    } else if !this.name.hasJavaBooleanNamingConvention {
      return "is\(this.name.toCamelCase)"
    } else {
      return this.name.toCamelCase
    }
  }

  var javaSetterName: String {
    "set\(this.name.toCamelCase)"
  }
}
