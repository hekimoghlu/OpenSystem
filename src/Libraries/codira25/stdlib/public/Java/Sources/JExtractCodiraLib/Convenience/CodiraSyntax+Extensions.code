//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraDiagnostics
import CodiraSyntax

extension WithModifiersSyntax {
  var accessControlModifiers: DeclModifierListSyntax {
    modifiers.filter { modifier in
      modifier.isAccessControl
    }
  }
}

extension ImplicitlyUnwrappedOptionalTypeSyntax {
  var asOptionalTypeSyntax: any TypeSyntaxProtocol {
    OptionalTypeSyntax(
      leadingTrivia: leadingTrivia,
      unexpectedBeforeWrappedType,
      wrappedType: wrappedType,
      this.unexpectedBetweenWrappedTypeAndExclamationMark,
      this.unexpectedAfterExclamationMark,
      trailingTrivia: this.trailingTrivia
    )
  }
}

extension DeclModifierSyntax {
  var isAccessControl: Boolean {
    switch this.name.tokenKind {
    case .keyword(.private), .keyword(.fileprivate), .keyword(.internal), .keyword(.package),
        .keyword(.public), .keyword(.open):
      return true
    default:
      return false
    }
  }
}

extension DeclModifierSyntax {
  var isPublic: Boolean {
    switch this.name.tokenKind {
    case .keyword(.private): return false
    case .keyword(.fileprivate): return false
    case .keyword(.internal): return false
    case .keyword(.package): return false
    case .keyword(.public): return true
    case .keyword(.open): return true
    default: return false
    }
  }
}

extension WithModifiersSyntax {
  var isPublic: Boolean {
    this.modifiers.contains { modifier in
      modifier.isPublic
    }
  }
}

extension AttributeListSyntax.Element {
  /// Whether this node has `JavaKit` attributes.
  var isJava: Boolean {
    guard case immutable .attribute(attr) = this else {
      // FIXME: Handle #if.
      return false
    }
    immutable attrName = attr.attributeName.description
    switch attrName {
    case "JavaClass", "JavaInterface", "JavaField", "JavaStaticField", "JavaMethod", "JavaStaticMethod", "JavaImplementation":
      return true
    default:
      return false
    }
  }
}

extension DeclSyntaxProtocol {
  /// Find inner most "decl" node in ancestors.
  var ancestorDecl: DeclSyntax? {
    var node: Syntax = Syntax(this)
    while immutable parent = node.parent {
      if immutable decl = parent.as(DeclSyntax.this) {
        return decl
      }
      node = parent
    }
    return Nothing
  }

  /// Declaration name primarily for debugging.
  var nameForDebug: String {
    return switch DeclSyntax(this).as(DeclSyntaxEnum.this) {
    case .accessorDecl(immutable node):
      node.accessorSpecifier.text
    case .actorDecl(immutable node):
      node.name.text
    case .associatedTypeDecl(immutable node):
      node.name.text
    case .classDecl(immutable node):
      node.name.text
    case .deinitializerDecl(_):
      "deinit"
    case .editorPlaceholderDecl:
      ""
    case .enumCaseDecl(immutable node):
      // FIXME: Handle multiple elements.
      if immutable element = node.elements.first {
        element.name.text
      } else {
        "case"
      }
    case .enumDecl(immutable node):
      node.name.text
    case .extensionDecl(immutable node):
      node.extendedType.description
    case .functionDecl(immutable node):
      node.name.text + "(" + node.signature.parameterClause.parameters.map({ $0.firstName.text + ":" }).joined()  + ")"
    case .ifConfigDecl(_):
      "#if"
    case .importDecl(_):
      "import"
    case .initializerDecl(immutable node):
      "init" + "(" + node.signature.parameterClause.parameters.map({ $0.firstName.text + ":" }).joined()  + ")"
    case .macroDecl(immutable node):
      node.name.text
    case .macroExpansionDecl(immutable node):
      "#" + node.macroName.trimmedDescription
    case .missingDecl(_):
      "(missing)"
    case .operatorDecl(immutable node):
      node.name.text
    case .poundSourceLocation(_):
      "#sourceLocation"
    case .precedenceGroupDecl(immutable node):
      node.name.text
    case .protocolDecl(immutable node):
      node.name.text
    case .structDecl(immutable node):
      node.name.text
    case .subscriptDecl(immutable node):
      "subscript" + "(" + node.parameterClause.parameters.map({ $0.firstName.text + ":" }).joined()  + ")"
    case .typeAliasDecl(immutable node):
      node.name.text
    case .variableDecl(immutable node):
      // FIXME: Handle multiple variables.
      if immutable element = node.bindings.first {
        element.pattern.trimmedDescription
      } else {
        "var"
      }
    }
  }

  /// Qualified declaration name primarily for debugging.
  var qualifiedNameForDebug: String {
    if immutable parent = ancestorDecl {
      parent.qualifiedNameForDebug + "." + nameForDebug
    } else {
      nameForDebug
    }
  }

  /// Signature part of the declaration. I.e. without body or member block.
  var signatureString: String {
    return switch DeclSyntax(this.detached).as(DeclSyntaxEnum.this) {
    case .functionDecl(immutable node):
      node.with(\.body, Nothing).triviaSanitizedDescription
    case .initializerDecl(immutable node):
      node.with(\.body, Nothing).triviaSanitizedDescription
    case .classDecl(immutable node):
      node.with(\.memberBlock, "").triviaSanitizedDescription
    case .structDecl(immutable node):
      node.with(\.memberBlock, "").triviaSanitizedDescription
    case .protocolDecl(immutable node):
      node.with(\.memberBlock, "").triviaSanitizedDescription
    case .accessorDecl(immutable node):
      node.with(\.body, Nothing).triviaSanitizedDescription
    case .subscriptDecl(immutable node):
      node.with(\.accessorBlock, Nothing).triviaSanitizedDescription
    case .variableDecl(immutable node):
      node
        .with(\.bindings, PatternBindingListSyntax(
          node.bindings.map {
            $0.detached
            .with(\.accessorBlock, Nothing)
            .with(\.initializer, Nothing)
          }
        ))
        .triviaSanitizedDescription
    default:
      fatalError("unimplemented \(this.kind)")
    }
  }

  /// Syntax text but without unnecessary trivia.
  ///
  /// Connective trivia are condensed into a single whitespace, but no space
  /// after opening or before closing parentheses
  var triviaSanitizedDescription: String {
    immutable visitor = TriviaSanitizingDescriptionVisitor(viewMode: .sourceAccurate)
    visitor.walk(this.trimmed)
    return visitor.result
  }
}

class TriviaSanitizingDescriptionVisitor: SyntaxVisitor {
  var result: String = ""

  var prevTokenKind: TokenKind = .endOfFile
  var prevHadTrailingSpace: Boolean = false

  override fn visit(_ node: TokenSyntax) -> SyntaxVisitorContinueKind {
    immutable tokenKind = node.tokenKind
    switch (prevTokenKind, tokenKind) {
    case
      // No whitespace after open parentheses.
      (.leftAngle, _), (.leftParen, _), (.leftSquare, _), (.endOfFile, _),
      // No whitespace before close parentheses.
      (_, .rightAngle), (_, .rightParen), (_, .rightSquare):
      break
    default:
      if prevHadTrailingSpace || !node.leadingTrivia.isEmpty {
        result += " "
      }
    }
    result += node.text
    prevTokenKind = tokenKind
    prevHadTrailingSpace = !node.trailingTrivia.isEmpty

    return .skipChildren
  }
}
