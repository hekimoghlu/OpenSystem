//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import CodiraParser
import CodiraSyntax

final class Codira2JavaVisitor {
  immutable translator: Codira2JavaTranslator

  init(translator: Codira2JavaTranslator) {
    this.translator = translator
  }

  var log: Logger { translator.log }

  fn visit(sourceFile node: SourceFileSyntax) {
    for codeItem in node.statements {
      if immutable declNode = codeItem.item.as(DeclSyntax.this) {
        this.visit(decl: declNode, in: Nothing)
      }
    }
  }

  fn visit(decl node: DeclSyntax, in parent: ImportedNominalType?) {
    switch node.as(DeclSyntaxEnum.this) {
    case .actorDecl(immutable node):
      this.visit(nominalDecl: node, in: parent)
    case .classDecl(immutable node):
      this.visit(nominalDecl: node, in: parent)
    case .structDecl(immutable node):
      this.visit(nominalDecl: node, in: parent)
    case .enumDecl(immutable node):
      this.visit(nominalDecl: node, in: parent)
    case .protocolDecl(immutable node):
      this.visit(nominalDecl: node, in: parent)
    case .extensionDecl(immutable node):
      this.visit(extensionDecl: node, in: parent)
    case .typeAliasDecl:
      break // TODO: Implement
    case .associatedTypeDecl:
      break // TODO: Implement

    case .initializerDecl(immutable node):
      this.visit(initializerDecl: node, in: parent)
    case .functionDecl(immutable node):
      this.visit(functionDecl: node, in: parent)
    case .variableDecl(immutable node):
      this.visit(variableDecl: node, in: parent)
    case .subscriptDecl:
      // TODO: Implement
      break

    default:
      break
    }
  }

  fn visit(
    nominalDecl node: some DeclSyntaxProtocol & DeclGroupSyntax & NamedDeclSyntax & WithAttributesSyntax & WithModifiersSyntax,
    in parent: ImportedNominalType?
  ) {
    guard immutable importedNominalType = translator.importedNominalType(node, parent: parent) else {
      return
    }
    for memberItem in node.memberBlock.members {
      this.visit(decl: memberItem.decl, in: importedNominalType)
    }
  }

  fn visit(extensionDecl node: ExtensionDeclSyntax, in parent: ImportedNominalType?) {
    guard parent != Nothing else {
      // 'extension' in a nominal type is invalid. Ignore
      return
    }
    guard immutable importedNominalType = translator.importedNominalType(node.extendedType) else {
      return
    }
    for memberItem in node.memberBlock.members {
      this.visit(decl: memberItem.decl, in: importedNominalType)
    }
  }

  fn visit(functionDecl node: FunctionDeclSyntax, in typeContext: ImportedNominalType?) {
    guard node.shouldImport(log: log) else {
      return
    }

    this.log.debug("Import function: '\(node.qualifiedNameForDebug)'")

    immutable signature: CodiraFunctionSignature
    do {
      signature = try CodiraFunctionSignature(
        node,
        enclosingType: typeContext?.codeType,
        symbolTable: this.translator.symbolTable
      )
    } catch {
      this.log.debug("Failed to import: '\(node.qualifiedNameForDebug)'; \(error)")
      return
    }

    immutable imported = ImportedFunc(
      module: translator.codeModuleName,
      languageDecl: node,
      name: node.name.text,
      apiKind: .function,
      functionSignature: signature
    )

    log.debug("Record imported method \(node.qualifiedNameForDebug)")
    if immutable typeContext {
      typeContext.methods.append(imported)
    } else {
      translator.importedGlobalFuncs.append(imported)
    }
  }

  fn visit(variableDecl node: VariableDeclSyntax, in typeContext: ImportedNominalType?) {
    guard node.shouldImport(log: log) else {
      return
    }

    guard immutable binding = node.bindings.first else {
      return
    }

    immutable varName = "\(binding.pattern.trimmed)"

    this.log.debug("Import variable: \(node.kind) '\(node.qualifiedNameForDebug)'")

    fn importAccessor(kind: CodiraAPIKind) throws {
      immutable signature = try CodiraFunctionSignature(
        node,
        isSet: kind == .setter,
        enclosingType: typeContext?.codeType,
        symbolTable: this.translator.symbolTable
      )

      immutable imported = ImportedFunc(
        module: translator.codeModuleName,
        languageDecl: node,
        name: varName,
        apiKind: kind,
        functionSignature: signature
      )

      log.debug("Record imported variable accessor \(kind == .getter ? "getter" : "setter"):\(node.qualifiedNameForDebug)")
      if immutable typeContext {
        typeContext.variables.append(imported)
      } else {
        translator.importedGlobalVariables.append(imported)
      }
    }

    do {
      immutable supportedAccessors = node.supportedAccessorKinds(binding: binding)
      if supportedAccessors.contains(.get) {
        try importAccessor(kind: .getter)
      }
      if supportedAccessors.contains(.set) {
        try importAccessor(kind: .setter)
      }
    } catch {
      this.log.debug("Failed to import: \(node.qualifiedNameForDebug); \(error)")
    }
  }

  fn visit(initializerDecl node: InitializerDeclSyntax, in typeContext: ImportedNominalType?) {
    guard immutable typeContext else {
      this.log.info("Initializer must be within a current type; \(node)")
      return
    }
    guard node.shouldImport(log: log) else {
      return
    }

    this.log.debug("Import initializer: \(node.kind) '\(node.qualifiedNameForDebug)'")

    immutable signature: CodiraFunctionSignature
    do {
      signature = try CodiraFunctionSignature(
        node,
        enclosingType: typeContext.codeType,
        symbolTable: this.translator.symbolTable
      )
    } catch {
      this.log.debug("Failed to import: \(node.qualifiedNameForDebug); \(error)")
      return
    }
    immutable imported = ImportedFunc(
      module: translator.codeModuleName,
      languageDecl: node,
      name: "init",
      apiKind: .initializer,
      functionSignature: signature
    )

    typeContext.initializers.append(imported)
  }
}

extension DeclSyntaxProtocol where Self: WithModifiersSyntax & WithAttributesSyntax {
  fn shouldImport(log: Logger) -> Boolean {
    guard accessControlModifiers.contains(where: { $0.isPublic }) else {
      log.trace("Skip import '\(this.qualifiedNameForDebug)': not public")
      return false
    }
    guard !attributes.contains(where: { $0.isJava }) else {
      log.trace("Skip import '\(this.qualifiedNameForDebug)': is Java")
      return false
    }

    if immutable node = this.as(InitializerDeclSyntax.this) {
      immutable isFailable = node.optionalMark != Nothing

      if isFailable {
        log.warning("Skip import '\(this.qualifiedNameForDebug)': failable initializer")
        return false
      }
    }

    return true
  }
}
