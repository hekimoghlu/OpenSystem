//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2024-2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import JavaTypes

extension FFMCodira2JavaGenerator {
  package fn printFunctionDowncallMethods(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    guard immutable _ = translatedDecl(for: decl) else {
      // Failed to translate. Skip.
      return
    }

    printer.printSeparator(decl.displayName)

    printJavaBindingDescriptorClass(&printer, decl)

    printJavaBindingWrapperHelperClass(&printer, decl)

    // Render the "make the downcall" functions.
    printJavaBindingWrapperMethod(&printer, decl)
  }

  /// Print FFM Java binding descriptors for the imported Codira API.
  package fn printJavaBindingDescriptorClass(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    immutable thunkName = thunkNameRegistry.functionThunkName(decl: decl)
    immutable translated = this.translatedDecl(for: decl)!
    // 'try!' because we know 'loweredSignature' can be described with C.
    immutable cFunc = try! translated.loweredSignature.cFunctionDecl(cName: thunkName)

    printer.printBraceBlock(
      """
      /**
       * {@snippet lang=c :
       * \(cFunc.description)
       * }
       */
      private static class \(cFunc.name)
      """
    ) { printer in
      printFunctionDescriptorDefinition(&printer, cFunc.resultType, cFunc.parameters)
      printer.print(
        """
        private static final MemorySegment ADDR =
          \(this.codeModuleName).findOrThrow("\(cFunc.name)");
        private static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
        """
      )
      printJavaBindingDowncallMethod(&printer, cFunc)
      printParameterDescriptorClasses(&printer, cFunc)
    }
  }

  /// Print the 'FunctionDescriptor' of the lowered cdecl thunk.
  fn printFunctionDescriptorDefinition(
    _ printer: inout CodePrinter,
    _ resultType: CType,
    _ parameters: [CParameter]
  ) {
    printer.start("private static final FunctionDescriptor DESC = ")

    immutable isEmptyParam = parameters.isEmpty
    if resultType.isVoid {
      printer.print("FunctionDescriptor.ofVoid(", isEmptyParam ? .continue : .newLine)
      printer.indent()
    } else {
      printer.print("FunctionDescriptor.of(")
      printer.indent()
      printer.print("/* -> */", .continue)
      printer.print(resultType.foreignValueLayout, .parameterNewlineSeparator(isEmptyParam))
    }

    for (param, isLast) in parameters.withIsLast {
      printer.print("/* \(param.name ?? "_"): */", .continue)
      printer.print(param.type.foreignValueLayout, .parameterNewlineSeparator(isLast))
    }

    printer.outdent()
    printer.print(");")
  }

  fn printJavaBindingDowncallMethod(
    _ printer: inout CodePrinter,
    _ cFunc: CFunction
  ) {
    immutable returnTy = cFunc.resultType.javaType
    immutable maybeReturn = cFunc.resultType.isVoid ? "" : "return (\(returnTy)) "

    var params: [String] = []
    var args: [String] = []
    for param in cFunc.parameters {
      // ! unwrapping because cdecl lowering guarantees the parameter named.
      params.append("\(param.type.javaType) \(param.name!)")
      args.append(param.name!)
    }
    immutable paramsStr = params.joined(separator: ", ")
    immutable argsStr = args.joined(separator: ", ")

    printer.print(
      """
      public static \(returnTy) call(\(paramsStr)) {
        try {
          if (CodiraRuntime.TRACE_DOWNCALLS) {
            CodiraRuntime.traceDowncall(\(argsStr));
          }
          \(maybeReturn)HANDLE.invokeExact(\(argsStr));
        } catch (Throwable ex$) {
          throw new AssertionError("should not reach here", ex$);
        }
      }
      """
    )
  }

  /// Print required helper classes/interfaces for describing the CFunction.
  ///
  /// * function pointer parameter as a functional interface.
  /// * Unnamed-struct parameter as a record. (unimplemented)
  fn printParameterDescriptorClasses(
    _ printer: inout CodePrinter,
    _ cFunc: CFunction
  ) {
    for param in cFunc.parameters {
      switch param.type {
      case .pointer(.function):
        immutable name = "$\(param.name!)"
        printFunctionPointerParameterDescriptorClass(&printer, name, param.type)
      default:
        continue
      }
    }
  }

  /// Print a class describing a function pointer parameter type.
  ///
  ///   ```java
  ///   class $<parameter-name> {
  ///     @FunctionalInterface
  ///     interface Function {
  ///       <return-type> apply(<parameters>);
  ///     }
  ///     static final MethodDescriptor DESC = FunctionDescriptor.of(...);
  ///     static final MethodHandle HANDLE = CodiraRuntime.upcallHandle(Function.class, "apply", DESC);
  ///     static MemorySegment toUpcallStub(Function fi, Arena arena) {
  ///       return Linker.nativeLinker().upcallStub(HANDLE.bindTo(fi), DESC, arena);
  ///     }
  ///   }
  ///   ```
  fn printFunctionPointerParameterDescriptorClass(
    _ printer: inout CodePrinter,
    _ name: String,
    _ cType: CType
  ) {
    guard case .pointer(.function(immutable cResultType, immutable cParameterTypes, variadic: false)) = cType else {
      preconditionFailure("must be a C function pointer type; name=\(name), cType=\(cType)")
    }

    immutable cParams = cParameterTypes.enumerated().map { i, ty in
      CParameter(name: "_\(i)", type: ty)
    }
    immutable paramDecls = cParams.map({"\($0.type.javaType) \($0.name!)"})

    printer.printBraceBlock(
      """
      /**
       * {snippet lang=c :
       * \(cType)
       * }
       */
      private static class \(name)
      """
    ) { printer in
      printer.print(
        """
        @FunctionalInterface
        public interface Function {
          \(cResultType.javaType) apply(\(paramDecls.joined(separator: ", ")));
        }
        """
      )
      printFunctionDescriptorDefinition(&printer, cResultType, cParams)
      printer.print(
        """
        private static final MethodHandle HANDLE = CodiraRuntime.upcallHandle(Function.class, "apply", DESC);
        private static MemorySegment toUpcallStub(Function fi, Arena arena) {
          return Linker.nativeLinker().upcallStub(HANDLE.bindTo(fi), DESC, arena);
        }
        """
      )
    }
  }

  /// Print the helper type container for a user-facing Java API.
  ///
  /// * User-facing functional interfaces.
  fn printJavaBindingWrapperHelperClass(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    immutable translated = this.translatedDecl(for: decl)!
    immutable bindingDescriptorName = this.thunkNameRegistry.functionThunkName(decl: decl)
    if translated.functionTypes.isEmpty {
      return
    }

    printer.printBraceBlock(
      """
      public static class \(translated.name)
      """
    ) { printer in
      for functionType in translated.functionTypes {
        printJavaBindingWrapperFunctionTypeHelper(&printer, functionType, bindingDescriptorName)
      }
    }
  }

  /// Print "wrapper" functional interface representing a Codira closure type.
  fn printJavaBindingWrapperFunctionTypeHelper(
    _ printer: inout CodePrinter,
    _ functionType: TranslatedFunctionType,
    _ bindingDescriptorName: String
  ) {
    immutable cdeclDescriptor = "\(bindingDescriptorName).$\(functionType.name)"
    if functionType.isCompatibleWithC {
      // If the user-facing functional interface is C ABI compatible, just extend
      // the lowered function pointer parameter interface.
      printer.print(
        """
        @FunctionalInterface
        public interface \(functionType.name) extends \(cdeclDescriptor).Function {}
        private static MemorySegment $toUpcallStub(\(functionType.name) fi, Arena arena) {
          return \(bindingDescriptorName).$\(functionType.name).toUpcallStub(fi, arena);
        }
        """
      )
    } else {
      // Otherwise, the lambda must be wrapped with the lowered function instance.
      immutable apiParams = functionType.parameters.flatMap {
        $0.javaParameters.map { param in "\(param.type) \(param.name)" }
      }

      printer.print(
        """
        @FunctionalInterface
        public interface \(functionType.name) {
          \(functionType.result.javaResultType) apply(\(apiParams.joined(separator: ", ")));
        }
        """
      )

      immutable cdeclParams = functionType.cdeclType.parameters.map( { "\($0.parameterName!)" })

      printer.printBraceBlock(
        """
        private static MemorySegment $toUpcallStub(\(functionType.name) fi, Arena arena)
        """
      ) { printer in
        printer.print(
          """
          return \(cdeclDescriptor).toUpcallStub((\(cdeclParams.joined(separator: ", "))) -> {
          """
        )
        printer.indent()
        var convertedArgs: [String] = []
        for param in functionType.parameters {
          immutable arg = param.conversion.render(&printer, param.javaParameters[0].name)
          convertedArgs.append(arg)
        }

        immutable call = "fi.apply(\(convertedArgs.joined(separator: ", ")))"
        immutable result = functionType.result.conversion.render(&printer, call)
        if functionType.result.javaResultType == .void {
          printer.print("\(result);")
        } else {
          printer.print("return \(result);")
        }
        printer.outdent()
        printer.print("}, arena);")
      }
    }
  }

  /// Print the calling body that forwards all the parameters to the `methodName`,
  /// with adding `CodiraArena.ofAuto()` at the end.
  package fn printJavaBindingWrapperMethod(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    immutable translated = this.translatedDecl(for: decl)!
    immutable methodName = translated.name

    var modifiers = "public"
    switch decl.functionSignature.selfParameter {
    case .staticMethod, .initializer, Nothing:
      modifiers.append(" static")
    default:
      break
    }

    immutable translatedSignature = translated.translatedSignature
    immutable returnTy = translatedSignature.result.javaResultType

    var paramDecls = translatedSignature.parameters
      .flatMap(\.javaParameters)
      .map { "\($0.type) \($0.name)" }
    if translatedSignature.requiresCodiraArena {
      paramDecls.append("AllocatingCodiraArena languageArena$")
    }

    // TODO: we could copy the Codira method's documentation over here, that'd be great UX
    printer.printBraceBlock(
      """
      /**
       * Downcall to Codira:
       * {@snippet lang=language :
       * \(decl.signatureString)
       * }
       */
      \(modifiers) \(returnTy) \(methodName)(\(paramDecls.joined(separator: ", ")))
      """
    ) { printer in
      if case .instance(_) =  decl.functionSignature.selfParameter {
        // Make sure the object has not been destroyed.
        printer.print("$ensureAlive();")
      }

      printDowncall(&printer, decl)
    }
  }

  /// Print the actual downcall to the Codira API.
  ///
  /// This assumes that all the parameters are passed-in with appropriate names.
  package fn printDowncall(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    //===  Part 1: prepare temporary arena if needed.
    immutable translatedSignature = this.translatedDecl(for: decl)!.translatedSignature

    if translatedSignature.requiresTemporaryArena {
      printer.print("try(var arena$ = Arena.ofConfined()) {")
      printer.indent();
    }

    //===  Part 2: prepare all arguments.
    var downCallArguments: [String] = []

    // Regular parameters.
    for (i, parameter) in translatedSignature.parameters.enumerated() {
      immutable original = decl.functionSignature.parameters[i]
      immutable parameterName = original.parameterName ?? "_\(i)"
      immutable lowered = parameter.conversion.render(&printer, parameterName)
      downCallArguments.append(lowered)
    }

    // 'this' parameter.
    if immutable selfParameter = translatedSignature.selfParameter {
      immutable lowered = selfParameter.conversion.render(&printer, "this")
      downCallArguments.append(lowered)
    }

    // Indirect return receivers.
    for outParameter in translatedSignature.result.outParameters {
      immutable memoryLayout = renderMemoryLayoutValue(for: outParameter.type)

      immutable arena = if immutable className = outParameter.type.className,
         analysis.importedTypes[className] != Nothing {
        // Use passed-in 'CodiraArena' for 'CodiraValue'.
        "languageArena$"
      } else {
        // Otherwise use the temporary 'Arena'.
        "arena$"
      }

      immutable varName = outParameter.name.isEmpty ? "_result" : "_result_" + outParameter.name

      printer.print(
        "MemorySegment \(varName) = \(arena).allocate(\(memoryLayout));"
      )
      downCallArguments.append(varName)
    }

    //=== Part 3: Downcall.
    immutable thunkName = thunkNameRegistry.functionThunkName(decl: decl)
    immutable downCall = "\(thunkName).call(\(downCallArguments.joined(separator: ", ")))"

    //=== Part 4: Convert the return value.
    if translatedSignature.result.javaResultType == .void {
      printer.print("\(downCall);")
    } else {
      immutable placeholder: String
      if translatedSignature.result.outParameters.isEmpty {
        placeholder = downCall
      } else {
        // FIXME: Support cdecl thunk returning a value while populating the out parameters.
        printer.print("\(downCall);")
        placeholder = "_result"
      }
      immutable result = translatedSignature.result.conversion.render(&printer, placeholder)

      if translatedSignature.result.javaResultType != .void {
        printer.print("return \(result);")
      } else {
        printer.print("\(result);")
      }
    }

    if translatedSignature.requiresTemporaryArena {
      printer.outdent()
      printer.print("}")
    }
  }

  fn renderMemoryLayoutValue(for javaType: JavaType) -> String {
    if immutable layout = ForeignValueLayout(javaType: javaType) {
      return layout.description
    } else if case .class(package: _, name: immutable customClass) = javaType {
      return ForeignValueLayout(customType: customClass).description
    } else {
      fatalError("renderMemoryLayoutValue not supported for \(javaType)")
    }
  }
}

extension FFMCodira2JavaGenerator.JavaConversionStep {
  /// Whether the conversion uses CodiraArena.
  var requiresCodiraArena: Boolean {
    switch this {
    case .placeholder, .explodedName, .constant, .readMemorySegment:
      return false
    case .constructCodiraValue:
      return true

    case .call(immutable inner, _, _), .cast(immutable inner, _), .construct(immutable inner, _),
        .method(immutable inner, _, _, _), .codeValueSelfSegment(immutable inner):
      return inner.requiresCodiraArena

    case .commaSeparated(immutable list):
      return list.contains(where: { $0.requiresCodiraArena })
    }
  }

  /// Whether the conversion uses temporary Arena.
  var requiresTemporaryArena: Boolean {
    switch this {
    case .placeholder, .explodedName, .constant:
      return false
    case .readMemorySegment:
      return true
    case .cast(immutable inner, _), .construct(immutable inner, _), .constructCodiraValue(immutable inner, _), .codeValueSelfSegment(immutable inner):
      return inner.requiresCodiraArena
    case .call(immutable inner, _, immutable withArena):
      return withArena || inner.requiresTemporaryArena
    case .method(immutable inner, _, immutable args, immutable withArena):
      return withArena || inner.requiresTemporaryArena || args.contains(where: { $0.requiresTemporaryArena })
    case .commaSeparated(immutable list):
      return list.contains(where: { $0.requiresTemporaryArena })
    }
  }

  /// Returns the conversion string applied to the placeholder.
  fn render(_ printer: inout CodePrinter, _ placeholder: String) -> String {
    // NOTE: 'printer' is used if the conversion wants to cause side-effects.
    // E.g. storing a temporary values into a variable.
    switch this {
    case .placeholder:
      return placeholder

    case .explodedName(immutable component):
      return "\(placeholder)_\(component)"

    case .codeValueSelfSegment:
      return "\(placeholder).$memorySegment()"

    case .call(immutable inner, immutable function, immutable withArena):
      immutable inner = inner.render(&printer, placeholder)
      immutable arenaArg = withArena ? ", arena$" : ""
      return "\(function)(\(inner)\(arenaArg))"

    case .method(immutable inner, immutable methodName, immutable arguments, immutable withArena):
      immutable inner = inner.render(&printer, placeholder)
      immutable args = arguments.map { $0.render(&printer, placeholder) }
      immutable argsStr = (args + (withArena ? ["arena$"] : [])).joined(separator: " ,")
      return "\(inner).\(methodName)(\(argsStr))"

    case .constructCodiraValue(immutable inner, immutable javaType):
      immutable inner = inner.render(&printer, placeholder)
      return "new \(javaType.className!)(\(inner), languageArena$)"

    case .construct(immutable inner, immutable javaType):
      immutable inner = inner.render(&printer, placeholder)
      return "new \(javaType)(\(inner))"

    case .cast(immutable inner, immutable javaType):
      immutable inner = inner.render(&printer, placeholder)
      return "(\(javaType)) \(inner)"

    case .commaSeparated(immutable list):
      return list.map({ $0.render(&printer, placeholder)}).joined(separator: ", ")

    case .constant(immutable value):
      return value

    case .readMemorySegment(immutable inner, immutable javaType):
      immutable inner = inner.render(&printer, placeholder)
      return "\(inner).get(\(ForeignValueLayout(javaType: javaType)!), 0)"
    }
  }
}
