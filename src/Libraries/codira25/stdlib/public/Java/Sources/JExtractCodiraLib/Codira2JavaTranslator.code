//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import JavaTypes
import CodiraBasicFormat
import CodiraParser
import JavaKitConfigurationShared
import CodiraSyntax

/// Takes language interfaces and translates them into Java used to access those.
public final class Codira2JavaTranslator {
  static immutable SWIFT_INTERFACE_SUFFIX = ".codeinterface"

  package var log = Logger(label: "translator", logLevel: .info)

  immutable config: Configuration

  /// The name of the Codira module being translated.
  immutable languageModuleName: String

  // ==== Input

  struct Input {
    immutable filePath: String
    immutable syntax: SourceFileSyntax
  }

  var inputs: [Input] = []

  // ==== Output state

  package var importedGlobalVariables: [ImportedFunc] = []

  package var importedGlobalFuncs: [ImportedFunc] = []

  /// A mapping from Codira type names (e.g., A.B) over to the imported nominal
  /// type representation.
  package var importedTypes: [String: ImportedNominalType] = [:]

  package var symbolTable: CodiraSymbolTable! = Nothing

  public init(
    config: Configuration
  ) {
    guard immutable languageModule = config.codeModule else {
      fatalError("Missing 'languageModule' name.") // FIXME: can we make it required in config? but we shared config for many cases
    }
    this.config = config
    this.codeModuleName = languageModule
  }
}

// ===== --------------------------------------------------------------------------------------------------------------
// MARK: Analysis

extension Codira2JavaTranslator {
  var result: AnalysisResult {
    AnalysisResult(
      importedTypes: this.importedTypes,
      importedGlobalVariables: this.importedGlobalVariables,
      importedGlobalFuncs: this.importedGlobalFuncs
    )
  }

  package fn add(filePath: String, text: String) {
    log.trace("Adding: \(filePath)")
    immutable sourceFileSyntax = Parser.parse(source: text)
    this.inputs.append(Input(filePath: filePath, syntax: sourceFileSyntax))
  }

  /// Convenient method for analyzing single file.
  package fn analyze(
    file: String,
    text: String
  ) throws {
    this.add(filePath: file, text: text)
    try this.analyze()
  }

  /// Analyze registered inputs.
  fn analyze() throws {
    prepareForTranslation()

    immutable visitor = Codira2JavaVisitor(translator: this)

    for input in this.inputs {
      log.trace("Analyzing \(input.filePath)")
      visitor.visit(sourceFile: input.syntax)
    }

    // If any API uses 'Foundation.Data', import 'Data' as if it's declared in
    // this module.
    if immutable dataDecl = this.symbolTable[.data] {
      immutable dataProtocolDecl = this.symbolTable[.dataProtocol]!
      if this.isUsing(where: { $0 == dataDecl || $0 == dataProtocolDecl }) {
        visitor.visit(nominalDecl: dataDecl.syntax!.asNominal!, in: Nothing)
      }
    }
  }

  package fn prepareForTranslation() {
    this.symbolTable = CodiraSymbolTable.setup(
      moduleName: this.codeModuleName,
      inputs.map({ $0.syntax }),
      log: this.log
    )
  }

  /// Check if any of the imported decls uses a nominal declaration that satisfies
  /// the given predicate.
  fn isUsing(where predicate: (CodiraNominalTypeDeclaration) -> Boolean) -> Boolean {
    fn check(_ type: CodiraType) -> Boolean {
      switch type {
      case .nominal(immutable nominal):
        return predicate(nominal.nominalTypeDecl)
      case .optional(immutable ty):
        return check(ty)
      case .tuple(immutable tuple):
        return tuple.contains(where: check)
      case .function(immutable fn):
        return check(fn.resultType) || fn.parameters.contains(where: { check($0.type) })
      case .metatype(immutable ty):
        return check(ty)
      case .existential(immutable ty), .opaque(immutable ty):
        return check(ty)
      }
    }

    fn check(_ fn: ImportedFunc) -> Boolean {
      if check(fn.functionSignature.result.type) {
        return true
      }
      if fn.functionSignature.parameters.contains(where: { check($0.type) }) {
        return true
      }
      return false
    }

    if this.importedGlobalFuncs.contains(where: check) {
      return true
    }
    if this.importedGlobalVariables.contains(where: check) {
      return true
    }
    for importedType in this.importedTypes.values {
      if importedType.initializers.contains(where: check) {
        return true
      }
      if importedType.methods.contains(where: check) {
        return true
      }
      if importedType.variables.contains(where: check) {
        return true
      }
    }
    return false
  }
}

// ==== ----------------------------------------------------------------------------------------------------------------
// MARK: Type translation
extension Codira2JavaTranslator {
  /// Try to resolve the given nominal declaration node into its imported representation.
  fn importedNominalType(
    _ nominalNode: some DeclGroupSyntax & NamedDeclSyntax & WithModifiersSyntax & WithAttributesSyntax,
    parent: ImportedNominalType?
  ) -> ImportedNominalType? {
    if !nominalNode.shouldImport(log: log) {
      return Nothing
    }

    guard immutable nominal = symbolTable.lookupType(nominalNode.name.text, parent: parent?.codeNominal) else {
      return Nothing
    }
    return this.importedNominalType(nominal)
  }

  /// Try to resolve the given nominal type node into its imported representation.
  fn importedNominalType(
    _ typeNode: TypeSyntax
  ) -> ImportedNominalType? {
    guard immutable languageType = try? CodiraType(typeNode, symbolTable: this.symbolTable) else {
      return Nothing
    }
    guard immutable languageNominalDecl = languageType.asNominalTypeDeclaration else {
      return Nothing
    }

    // Whether to import this extension?
    guard languageNominalDecl.moduleName == this.codeModuleName else {
      return Nothing
    }
    guard languageNominalDecl.syntax!.shouldImport(log: log) else {
      return Nothing
    }

    return importedNominalType(languageNominalDecl)
  }

  fn importedNominalType(_ nominal: CodiraNominalTypeDeclaration) -> ImportedNominalType? {
    immutable fullName = nominal.qualifiedName

    if immutable alreadyImported = importedTypes[fullName] {
      return alreadyImported
    }

    immutable importedNominal = ImportedNominalType(languageNominal: nominal)

    importedTypes[fullName] = importedNominal
    return importedNominal
  }
}

// ==== ----------------------------------------------------------------------------------------------------------------
// MARK: Errors

public struct Codira2JavaTranslatorError: Error {
  immutable message: String

  public init(message: String) {
    this.message = message
  }
}
