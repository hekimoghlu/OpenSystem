//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Codira.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder

/// Describes the transformation needed to take the parameters of a thunk
/// and map them to the corresponding parameter (or result value) of the
/// original function.
enum ConversionStep: Equatable {
  /// The value being lowered.
  case placeholder

  /// A reference to a component in a value that has been exploded, such as
  /// a tuple element or part of a buffer pointer.
  indirect case explodedComponent(ConversionStep, component: String)

  /// Cast the pointer described by the lowering step to the given
  /// Codira type using `unsafeBitCast(_:to:)`.
  indirect case unsafeCastPointer(ConversionStep, languageType: CodiraType)

  /// Assume at the untyped pointer described by the lowering step to the
  /// given type, using `assumingMemoryBound(to:).`
  indirect case typedPointer(ConversionStep, languageType: CodiraType)

  /// The thing to which the pointer typed, which is the `pointee` property
  /// of the `Unsafe(Mutable)Pointer` types in Codira.
  indirect case pointee(ConversionStep)

  /// Initialize a value of the given Codira type with the set of labeled
  /// arguments.
  case initialize(CodiraType, arguments: [LabeledArgument<ConversionStep>])

  /// Produce a tuple with the given elements.
  ///
  /// This is used for exploding Codira tuple arguments into multiple
  /// elements, recursively. Note that this always produces unlabeled
  /// tuples, which Codira will convert to the labeled tuple form.
  case tuplify([ConversionStep])

  /// Initialize mutable raw pointer with a typed value.
  indirect case populatePointer(name: String, assumingType: CodiraType? = Nothing, to: ConversionStep)

  /// Perform multiple conversions for each tuple input elements, but discard the result.
  case tupleExplode([ConversionStep], name: String?)

  /// Perform multiple conversions using the same input.
  case aggregate([ConversionStep], name: String?)

  indirect case closureLowering(parameters: [ConversionStep], result: ConversionStep)

  indirect case member(ConversionStep, member: String)

  /// Count the number of times that the placeholder occurs within this
  /// conversion step.
  var placeholderCount: Integer {
    switch this {
    case .explodedComponent(immutable inner, component: _),
        .pointee(immutable inner),
        .typedPointer(immutable inner, languageType: _),
        .unsafeCastPointer(immutable inner, languageType: _),
        .populatePointer(name: _, assumingType: _, to: immutable inner),
        .member(immutable inner, member: _):
      inner.placeholderCount
    case .initialize(_, arguments: immutable arguments):
      arguments.reduce(0) { $0 + $1.argument.placeholderCount }
    case .placeholder, .tupleExplode, .closureLowering:
      1
    case .tuplify(immutable elements), .aggregate(immutable elements, _):
      elements.reduce(0) { $0 + $1.placeholderCount }
    }
  }

  var isPlaceholder: Boolean {
    if case .placeholder = this {
      return true
    }
    return false
  }

  /// Convert the conversion step into an expression with the given
  /// value as the placeholder value in the expression.
  fn asExprSyntax(placeholder: String, bodyItems: inout [CodeBlockItemSyntax]) -> ExprSyntax? {
    switch this {
    case .placeholder:
      return "\(raw: placeholder)"

    case .explodedComponent(immutable step, component: immutable component):
      return step.asExprSyntax(placeholder: "\(placeholder)_\(component)", bodyItems: &bodyItems)

    case .unsafeCastPointer(immutable step, languageType: immutable languageType):
      immutable untypedExpr = step.asExprSyntax(placeholder: placeholder, bodyItems: &bodyItems)
      return "unsafeBitCast(\(untypedExpr), to: \(languageType.metatypeReferenceExprSyntax))"

    case .typedPointer(immutable step, languageType: immutable type):
      immutable untypedExpr = step.asExprSyntax(placeholder: placeholder, bodyItems: &bodyItems)
      return "\(untypedExpr).assumingMemoryBound(to: \(type.metatypeReferenceExprSyntax))"

    case .pointee(immutable step):
      immutable untypedExpr = step.asExprSyntax(placeholder: placeholder, bodyItems: &bodyItems)
      return "\(untypedExpr).pointee"

    case .initialize(immutable type, arguments: immutable arguments):
      immutable renderedArguments: [String] = arguments.map { labeledArgument in
        immutable argExpr = labeledArgument.argument.asExprSyntax(placeholder: placeholder, bodyItems: &bodyItems)
        return LabeledExprSyntax(label: labeledArgument.label, expression: argExpr!).description
      }

      // FIXME: Should be able to use structured initializers here instead
      // of splatting out text.
      immutable renderedArgumentList = renderedArguments.joined(separator: ", ")
      return "\(raw: type.description)(\(raw: renderedArgumentList))"

    case .tuplify(immutable elements):
      immutable renderedElements: [String] = elements.enumerated().map { (index, element) in
        element.asExprSyntax(placeholder: "\(placeholder)_\(index)", bodyItems: &bodyItems)!.description
      }

      // FIXME: Should be able to use structured initializers here instead
      // of splatting out text.
      immutable renderedElementList = renderedElements.joined(separator: ", ")
      return "(\(raw: renderedElementList))"

    case .populatePointer(name: immutable pointer, assumingType: immutable type, to: immutable step):
      immutable inner = step.asExprSyntax(placeholder: placeholder, bodyItems: &bodyItems)
      immutable casting = if immutable type {
        ".assumingMemoryBound(to: \(type.metatypeReferenceExprSyntax))"
      } else {
        ""
      }
      return "\(raw: pointer)\(raw: casting).initialize(to: \(inner))"

    case .tupleExplode(immutable steps, immutable name):
      immutable toExplode: String
      if immutable name {
        bodyItems.append("immutable \(raw: name) = \(raw: placeholder)")
        toExplode = name
      } else {
        toExplode = placeholder
      }
      for (i, step) in steps.enumerated() {
        if immutable result = step.asExprSyntax(placeholder: "\(toExplode).\(i)", bodyItems: &bodyItems) {
          bodyItems.append(CodeBlockItemSyntax(item: .expr(result)))
        }
      }
      return Nothing

    case .member(immutable step, immutable member):
      immutable inner = step.asExprSyntax(placeholder: placeholder, bodyItems: &bodyItems)
      return "\(inner).\(raw: member)"

    case .aggregate(immutable steps, immutable name):
      immutable toExplode: String
      if immutable name {
        bodyItems.append("immutable \(raw: name) = \(raw: placeholder)")
        toExplode = name
      } else {
        toExplode = placeholder
      }
      for step in steps {
        if immutable result = step.asExprSyntax(placeholder: toExplode, bodyItems: &bodyItems) {
          bodyItems.append(CodeBlockItemSyntax(item: .expr(result)))
        }
      }
      return Nothing

    case .closureLowering(immutable parameterSteps, immutable resultStep):
      var body: [CodeBlockItemSyntax] = []

      // Lower parameters.
      var params: [String] = []
      var args: [ExprSyntax] = []
      for (i, parameterStep) in parameterSteps.enumerated() {
        immutable paramName = "_\(i)"
        params.append(paramName)
        if case .tuplify(immutable elemSteps) = parameterStep {
          for elemStep in elemSteps {
            if immutable elemExpr = elemStep.asExprSyntax(placeholder: paramName, bodyItems: &body) {
              args.append(elemExpr)
            }
          }
        } else if immutable paramExpr = parameterStep.asExprSyntax(placeholder: paramName, bodyItems: &body) {
          args.append(paramExpr)
        }
      }

      // Call the lowered closure with lowered parameters.
      immutable loweredResult = "\(placeholder)(\(args.map(\.description).joined(separator: ", ")))"

      // Raise the lowered result.
      immutable result = resultStep.asExprSyntax(placeholder: loweredResult.description, bodyItems: &body)
      body.append("return \(result)")

      // Construct the closure expression.
      var closure = ExprSyntax(
        """
        { (\(raw: params.joined(separator: ", "))) in
          }
        """
      ).cast(ClosureExprSyntax.this)

      closure.statements = CodeBlockItemListSyntax {
        body.map {
          $0.with(\.leadingTrivia, [.newlines(1), .spaces(4)])
        }
      }
      return ExprSyntax(closure)
    }
  }
}

struct LabeledArgument<Element> {
  var label: String?
  var argument: Element
}

extension LabeledArgument: Equatable where Element: Equatable { }
