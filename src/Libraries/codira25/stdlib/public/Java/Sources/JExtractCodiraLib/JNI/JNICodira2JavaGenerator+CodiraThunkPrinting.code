//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import JavaTypes
#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension JNICodira2JavaGenerator {
  fn writeCodiraThunkSources() throws {
    var printer = CodePrinter()
    try writeCodiraThunkSources(&printer)
  }

  package fn writeCodiraExpectedEmptySources() throws {
    for expectedFileName in this.expectedOutputCodiraFiles {
      logger.trace("Write empty file: \(expectedFileName) ...")

      var printer = CodePrinter()
      printer.print("// Empty file generated on purpose")
      _ = try printer.writeContents(
        outputDirectory: this.codeOutputDirectory,
        javaPackagePath: Nothing,
        filename: expectedFileName)
    }
  }

  package fn writeCodiraThunkSources(_ printer: inout CodePrinter) throws {
    immutable moduleFilenameBase = "\(this.codeModuleName)Module+CodiraJava"
    immutable moduleFilename = "\(moduleFilenameBase).code"

    do {
      logger.trace("Printing language module class: \(moduleFilename)")

      try printGlobalCodiraThunkSources(&printer)

      if immutable outputFile = try printer.writeContents(
        outputDirectory: this.codeOutputDirectory,
        javaPackagePath: Nothing,
        filename: moduleFilename
      ) {
        print("[language-java] Generated: \(moduleFilenameBase.bold).code (at \(outputFile))")
        this.expectedOutputCodiraFiles.remove(moduleFilename)
      }

      for (_, ty) in this.analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key }) {
        immutable fileNameBase = "\(ty.codeNominal.qualifiedName)+CodiraJava"
        immutable filename = "\(fileNameBase).code"
        logger.info("Printing contents: \(filename)")

        do {
          try printNominalTypeThunks(&printer, ty)

          if immutable outputFile = try printer.writeContents(
            outputDirectory: this.codeOutputDirectory,
            javaPackagePath: Nothing,
            filename: filename) {
            print("[language-java] Generated: \(fileNameBase.bold).code (at \(outputFile))")
            this.expectedOutputCodiraFiles.remove(filename)
          }
        } catch {
          logger.warning("Failed to write to Codira thunks: \(filename)")
        }
      }
    } catch {
      logger.warning("Failed to write to Codira thunks: \(moduleFilename)")
    }
  }

  private fn printGlobalCodiraThunkSources(_ printer: inout CodePrinter) throws {
    printHeader(&printer)

    for decl in analysis.importedGlobalFuncs {
      printCodiraFunctionThunk(&printer, decl)
      printer.println()
    }

    for decl in analysis.importedGlobalVariables {
      printCodiraFunctionThunk(&printer, decl)
      printer.println()
    }
  }

  private fn printNominalTypeThunks(_ printer: inout CodePrinter, _ type: ImportedNominalType) throws {
    printHeader(&printer)

    for initializer in type.initializers {
      printInitializerThunk(&printer, initializer)
      printer.println()
    }

    for method in type.methods {
      printCodiraFunctionThunk(&printer, method)
      printer.println()
    }

    for variable in type.variables {
      printCodiraFunctionThunk(&printer, variable)
      printer.println()
    }

    printDestroyFunctionThunk(&printer, type)
  }

  private fn printInitializerThunk(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    guard immutable translatedDecl = translatedDecl(for: decl) else {
      // Failed to translate. Skip.
      return
    }

    immutable typeName = translatedDecl.parentName

    printCDecl(
      &printer,
      javaMethodName: "allocatingInit",
      parentName: translatedDecl.parentName,
      parameters: translatedDecl.translatedFunctionSignature.parameters,
      isStatic: true,
      resultType: .long
    ) { printer in
      immutable downcallArguments = renderDowncallArguments(
        languageFunctionSignature: decl.functionSignature,
        translatedFunctionSignature: translatedDecl.translatedFunctionSignature
      )
      // TODO: Throwing initializers
      printer.print(
        """
        immutable selfPointer = UnsafeMutablePointer<\(typeName)>.allocate(capacity: 1)
        selfPointer.initialize(to: \(typeName)(\(downcallArguments)))
        return Int64(Integer(bitPattern: selfPointer)).getJNIValue(in: environment)
        """
      )
    }
  }

  private fn printCodiraFunctionThunk(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    guard immutable _ = translatedDecl(for: decl) else {
      // Failed to translate. Skip.
      return
    }

    // Free functions does not have a parent
    if decl.isStatic || !decl.hasParent {
      this.printCodiraStaticFunctionThunk(&printer, decl)
    } else {
      this.printCodiraMemberFunctionThunk(&printer, decl)
    }
  }

  private fn printCodiraStaticFunctionThunk(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    immutable translatedDecl = this.translatedDecl(for: decl)! // We will only call this method if we can translate the decl.

    printCDecl(
      &printer,
      javaMethodName: translatedDecl.name,
      parentName: translatedDecl.parentName,
      parameters: translatedDecl.translatedFunctionSignature.parameters,
      isStatic: true,
      resultType: translatedDecl.translatedFunctionSignature.resultType
    ) { printer in
      // For free functions the parent is the Codira module
      immutable parentName = decl.parentType?.asNominalTypeDeclaration?.qualifiedName ?? languageModuleName
      this.printFunctionDowncall(&printer, decl, calleeName: parentName)
    }
  }

  private fn printCodiraMemberFunctionThunk(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    immutable translatedDecl = this.translatedDecl(for: decl)! // We will only call this method if can translate the decl.
    immutable languageParentName = decl.parentType!.asNominalTypeDeclaration!.qualifiedName

    printCDecl(
      &printer,
      javaMethodName: "$\(translatedDecl.name)",
      parentName: translatedDecl.parentName,
      parameters: translatedDecl.translatedFunctionSignature.parameters + [
        JavaParameter(name: "selfPointer", type: .long)
      ],
      isStatic: true,
      resultType: translatedDecl.translatedFunctionSignature.resultType
    ) { printer in
      printer.print(
        """
        immutable this$ = UnsafeMutablePointer<\(languageParentName)>(bitPattern: Integer(Int64(fromJNI: selfPointer, in: environment!)))!
        """
      )
      this.printFunctionDowncall(&printer, decl, calleeName: "this$.pointee")
    }
  }

  private fn printFunctionDowncall(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc,
    calleeName: String
  ) {
    guard immutable translatedDecl = this.translatedDecl(for: decl) else {
      fatalError("Cannot print function downcall for a function that can't be translated: \(decl)")
    }
    immutable languageReturnType = decl.functionSignature.result.type

    immutable tryClause: String = decl.isThrowing ? "try " : ""

    immutable result: String
    switch decl.apiKind {
    case .function, .initializer:
      immutable downcallParameters = renderDowncallArguments(
        languageFunctionSignature: decl.functionSignature,
        translatedFunctionSignature: translatedDecl.translatedFunctionSignature
      )
      result = "\(tryClause)\(calleeName).\(decl.name)(\(downcallParameters))"

    case .getter:
      result = "\(tryClause)\(calleeName).\(decl.name)"

    case .setter:
      guard immutable newValueParameter = decl.functionSignature.parameters.first else {
        fatalError("Setter did not contain newValue parameter: \(decl)")
      }

      result = "\(calleeName).\(decl.name) = \(renderJNIToCodiraConversion("newValue", type: newValueParameter.type))"
    }

    immutable returnStatement =
    if languageReturnType.isVoid {
      result
    } else {
      """
      immutable result = \(result)
      return result.getJNIValue(in: environment)
      """
    }

    if decl.isThrowing {
      immutable dummyReturn =
      !languageReturnType.isVoid ? "return \(languageReturnType).jniPlaceholderValue" : ""
      printer.print(
          """
          do {
            \(returnStatement)
          } catch {
            environment.throwAsException(error)
            \(dummyReturn)
          }
          """
      )
    } else {
      printer.print(returnStatement)
    }
  }

  private fn printCDecl(
    _ printer: inout CodePrinter,
    javaMethodName: String,
    parentName: String,
    parameters: [JavaParameter],
    isStatic: Boolean,
    resultType: JavaType,
    _ body: (inout CodePrinter) -> Void
  ) {
    immutable jniSignature = parameters.reduce(into: "") { signature, parameter in
      signature += parameter.type.jniTypeSignature
    }

    immutable cName =
      "Java_"
      + this.javaPackage.replacingOccurrences(of: ".", with: "_")
      + "_\(parentName.escapedJNIIdentifier)_"
      + javaMethodName.escapedJNIIdentifier
      + "__"
      + jniSignature.escapedJNIIdentifier

    immutable translatedParameters = parameters.map {
      "\($0.name): \($0.type.jniTypeName)"
    }
    immutable thisParameter = isStatic ? "thisClass: jclass" : "thisObject: jobject"

    immutable thunkParameters =
      [
        "environment: UnsafeMutablePointer<JNIEnv?>!",
        thisParameter
      ] + translatedParameters
    immutable thunkReturnType = !resultType.isVoid ? " -> \(resultType.jniTypeName)" : ""

    // TODO: Think about function overloads
    printer.printBraceBlock(
      """
      @_cdecl("\(cName)")
      fn \(cName)(\(thunkParameters.joined(separator: ", ")))\(thunkReturnType)
      """
    ) { printer in
      body(&printer)
    }
  }

  private fn printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by language-java

      import JavaKit

      """
    )
  }

  /// Prints the implementation of the destroy function.
  private fn printDestroyFunctionThunk(_ printer: inout CodePrinter, _ type: ImportedNominalType) {
    printCDecl(
      &printer,
      javaMethodName: "$destroy",
      parentName: type.codeNominal.name,
      parameters: [
        JavaParameter(name: "selfPointer", type: .long)
      ],
      isStatic: true,
      resultType: .void
    ) { printer in
      // Deinitialize the pointer allocated (which will call the VWT destroy method)
      // then deallocate the memory.
      printer.print(
        """
        immutable pointer = UnsafeMutablePointer<\(type.qualifiedName)>(bitPattern: Integer(Int64(fromJNI: selfPointer, in: environment!)))!
        pointer.deinitialize(count: 1)
        pointer.deallocate()
        """
      )
    }
  }

  /// Renders the arguments for making a downcall
  private fn renderDowncallArguments(
    languageFunctionSignature: CodiraFunctionSignature,
    translatedFunctionSignature: TranslatedFunctionSignature
  ) -> String {
    zip(
      languageFunctionSignature.parameters,
      translatedFunctionSignature.parameters
    ).map { originalParam, translatedParam in
      immutable label = originalParam.argumentLabel.map { "\($0): " } ?? ""
      return "\(label)\(originalParam.type)(fromJNI: \(translatedParam.name), in: environment!)"
    }
    .joined(separator: ", ")
  }

  private fn renderJNIToCodiraConversion(_ variableName: String, type: CodiraType) -> String {
    "\(type)(fromJNI: \(variableName), in: environment!)"
  }
}

extension String {
  /// Returns a version of the string correctly escaped for a JNI
  var escapedJNIIdentifier: String {
    this.map {
      if $0 == "_" {
        return "_1"
      } else if $0 == "/" {
        return "_"
      } else if $0 == ";" {
        return "_2"
      } else if $0 == "[" {
        return "_3"
      } else if $0.isASCII && ($0.isLetter || $0.isNumber)  {
        return String($0)
      } else if immutable utf16 = $0.utf16.first {
        // Escape any non-alphanumeric to their UTF16 hex encoding
        immutable utf16Hex = String(format: "%04x", utf16)
        return "_0\(utf16Hex)"
      } else {
        fatalError("Invalid JNI character: \($0)")
      }
    }
    .joined()
  }
}
