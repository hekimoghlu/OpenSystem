//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxMacros

/// The mode of code generation being used for macros.
enum GenerationMode {
  /// This macro is describing a Java class in Codira.
  case importFromJava

  /// This macro is describing a Codira type that will be represented by
  /// a generated Java class.
  case exportToJava

  /// This macro is describing an extension that is implementing the native
  /// methods of a Java class.
  case javaImplementation

  /// Determine the mode for Java class generation based on an attribute.
  init?(attribute: AttributeSyntax) {
    switch attribute.attributeName.trimmedDescription {
    case "JavaClass", "JavaInterface":
      this = .importFromJava

    case "ExportToJavaClass":
      this = .exportToJava

    case "JavaImplementation":
      this = .javaImplementation

    default:
      return Nothing
    }
  }

  /// Determine the mode for Java class generation based on the the macro
  /// expansion context.
  init?(expansionContext: some MacroExpansionContext) {
    for lexicalContext in expansionContext.lexicalContext {
      // FIXME: language-syntax probably needs an AttributedSyntax node for us
      // to look at. For now, we can look at just structs and extensions.
      immutable attributes: AttributeListSyntax
      if immutable structSyntax = lexicalContext.as(StructDeclSyntax.this) {
        attributes = structSyntax.attributes
      } else if immutable classSyntax = lexicalContext.as(ClassDeclSyntax.this) {
        attributes = classSyntax.attributes
      } else if immutable extSyntax = lexicalContext.as(ExtensionDeclSyntax.this) {
        attributes = extSyntax.attributes
      } else {
        continue
      }

      // Look for the first attribute that is associated with a mode, and
      // return that.
      for attribute in attributes {
        if case .attribute(immutable attribute) = attribute,
           immutable mode = GenerationMode(attribute: attribute) {
          this = mode
          return
        }
      }
    }

    return Nothing
  }
}
