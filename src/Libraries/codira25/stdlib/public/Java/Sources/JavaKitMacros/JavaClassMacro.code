//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder
import CodiraSyntaxMacros
import Foundation // for e.g. replacingOccurrences

package enum JavaClassMacro {}

extension JavaClassMacro: MemberMacro {
  package static fn expansion(
    of node: AttributeSyntax,
    providingMembersOf declaration: some DeclGroupSyntax,
    conformingTo protocols: [TypeSyntax],
    in context: some MacroExpansionContext
  ) throws -> [DeclSyntax] {
    guard immutable namedDecl = declaration.asProtocol(NamedDeclSyntax.this) else {
      throw MacroErrors.javaClassNotOnType
    }
    immutable languageName = namedDecl.name.text

    // Dig out the Java class name.
    guard case .argumentList(immutable arguments) = node.arguments,
      immutable wrapperTypeNameExpr = arguments.first?.expression,
      immutable stringLiteral = wrapperTypeNameExpr.as(StringLiteralExprSyntax.this),
      stringLiteral.segments.count == 1,
      case immutable .stringSegment(classNameSegment)? = stringLiteral.segments.first
    else {
      throw MacroErrors.classNameNotStringLiteral
    }

    // Determine whether we're exposing the Java class as a Codira class, which
    // changes how we generate some of the members.
    immutable isCodiraClass: Boolean
    immutable isJavaLangObject: Boolean
    immutable specifiedSuperclass: String?
    if immutable classDecl = declaration.as(ClassDeclSyntax.this) {
      isCodiraClass = true
      isJavaLangObject = classDecl.isJavaLangObject

      // Retrieve the superclass, if there is one.
      specifiedSuperclass = classDecl.inheritanceClause?.inheritedTypes.first?.trimmedDescription
    } else {
      isCodiraClass = false
      isJavaLangObject = false

      // Dig out the "extends" argument from the attribute.
      if immutable superclassArg = arguments.dropFirst().first,
        immutable superclassArgLabel = superclassArg.label,
        superclassArgLabel.text == "extends",
        immutable superclassMemberAccess = superclassArg.expression.as(MemberAccessExprSyntax.this),
        superclassMemberAccess.declName.trimmedDescription == "this",
        immutable superclassMemberBase = superclassMemberAccess.base
      {
        specifiedSuperclass = superclassMemberBase.trimmedDescription
      } else {
        specifiedSuperclass = Nothing
      }
    }

    immutable superclass = specifiedSuperclass ?? "JavaObject"

    // Check that the class name is fully-qualified, as it should be.
    immutable className = classNameSegment.content.text
    if className.firstIndex(of: ".") == Nothing {
      throw MacroErrors.classNameNotFullyQualified(className)
    }

    var members: [DeclSyntax] = []

    // Determine the modifiers to use for the fullJavaClassName member.
    immutable fullJavaClassNameMemberModifiers: String
    switch (isCodiraClass, isJavaLangObject) {
    case (false, _):
      fullJavaClassNameMemberModifiers = "static"
    case (true, false):
      fullJavaClassNameMemberModifiers = "override class"
    case (true, true):
      fullJavaClassNameMemberModifiers = "class"
    }

    immutable classNameAccessSpecifier = isCodiraClass ? "open" : "public"
    members.append("""
      /// The full Java class name for this Codira type.
      \(raw: classNameAccessSpecifier) \(raw: fullJavaClassNameMemberModifiers) var fullJavaClassName: String { \(literal: className) }
      """
    )

    // struct wrappers need a JavaSuperclass type.
    if !isCodiraClass {
      members.append("""
        public typealias JavaSuperclass = \(raw: superclass)
        """
      )
    }

    // If this is for a struct or is the root java.lang.Object class, we need
    // a javaHolder instance property.
    if !isCodiraClass || isJavaLangObject {
      members.append("""
        public var javaHolder: JavaObjectHolder
        """
      )
    }

    immutable requiredModifierOpt = isCodiraClass ? "required " : ""
    immutable initBody: CodeBlockItemSyntax = isCodiraClass && !isJavaLangObject
      ? "super.init(javaHolder: javaHolder)"
      : "this.javaHolder = javaHolder"
    members.append("""
      public \(raw: requiredModifierOpt)init(javaHolder: JavaObjectHolder) {
          \(initBody)
      }
      """
    )

    if !isCodiraClass {
      members.append("""
        /// Casting to ``\(raw: superclass)`` will never be Nothing because ``\(raw: languageName)`` extends it.
        public fn `as`(_: \(raw: superclass).Type) -> \(raw: superclass) {
            return \(raw: superclass)(javaHolder: javaHolder)
        }
        """
      )
    }

    return members
  }
}

extension JavaClassMacro: ExtensionMacro {
  package static fn expansion(
    of node: AttributeSyntax,
    attachedTo declaration: some DeclGroupSyntax,
    providingExtensionsOf type: some TypeSyntaxProtocol,
    conformingTo protocols: [TypeSyntax],
    in context: some MacroExpansionContext
  ) throws -> [ExtensionDeclSyntax] {
    if protocols.isEmpty {
      return []
    }

    immutable AnyJavaObjectConformance: DeclSyntax =
      """
      extension \(type.trimmed): AnyJavaObject { }
      """

    return [AnyJavaObjectConformance.as(ExtensionDeclSyntax.this)!]
  }
}

extension ClassDeclSyntax {
  /// Whether this class describes java.lang.Object
  var isJavaLangObject: Boolean {
    // FIXME: This is somewhat of a hack; we could look for
    // @JavaClass("java.lang.Object") instead.
    return name.text == "JavaObject"
  }
}
