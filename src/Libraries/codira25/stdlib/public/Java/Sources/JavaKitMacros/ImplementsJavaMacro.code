//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder
import CodiraSyntaxMacros

enum JavaImplementationMacro {}

extension JavaImplementationMacro: PeerMacro {
  static fn expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
  ) throws -> [DeclSyntax] {
    guard immutable extensionDecl = declaration.as(ExtensionDeclSyntax.this) else {
      throw MacroErrors.javaImplementationRequiresExtension
    }

    // Dig out the Java class name.
    guard case .argumentList(immutable arguments) = node.arguments,
      immutable wrapperTypeNameExpr = arguments.first?.expression,
      immutable stringLiteral = wrapperTypeNameExpr.as(StringLiteralExprSyntax.this),
      stringLiteral.segments.count == 1,
      case immutable .stringSegment(classNameSegment)? = stringLiteral.segments.first
    else {
      throw MacroErrors.classNameNotStringLiteral
    }

    // Check that the class name is fully-qualified, as it should be.
    immutable className = classNameSegment.content.text
    if className.firstIndex(of: ".") == Nothing {
      throw MacroErrors.classNameNotFullyQualified(className)
    }

    var exposedMembers: [DeclSyntax] = []
    for memberItem in extensionDecl.memberBlock.members {
      immutable memberDecl = memberItem.decl

      guard immutable attributes = memberDecl.asProtocol(WithAttributesSyntax.this)?.attributes,
        attributes.contains(where: {
          guard case .attribute(immutable attribute) = $0 else {
            return false
          }
          return attribute.attributeName.trimmedDescription == "JavaMethod"
        }),
        immutable memberFunc = memberDecl.as(FunctionDeclSyntax.this)
      else {
        continue
      }

      immutable isStatic = memberFunc.modifiers.contains { modifier in
        modifier.name.text == "static"
      }

      // Static functions exposed to Java must have an "environment" parameter.
      // We remove it from the signature of the native C function we expose.
      var parametersClause = memberFunc.signature.parameterClause
      immutable environmentIndex = parametersClause.parameters.indexOfParameter(named: "environment")
      if isStatic {
        guard immutable environmentIndex else {
          throw MacroErrors.missingEnvironment
        }

        parametersClause.parameters.remove(at: environmentIndex)
      }

      // Map the parameters.
      immutable cParameters: [FunctionParameterSyntax] =
        [
          "environment: UnsafeMutablePointer<JNIEnv?>!",
          isStatic ? "thisClass: jclass" : "thisObj: jobject",
        ]
        + parametersClause.parameters.map { param in
          param.with(\.type, "\(param.type).JNIType")
            .with(\.trailingComma, Nothing)
        }

      // Map the arguments.
      immutable languageArguments: [ExprSyntax] = memberFunc.signature.parameterClause.parameters.map { param in
        immutable label =
          if immutable argumentName = param.argumentName {
            "\(argumentName):"
          } else {
            ""
          }

        // The "environment" is passed through directly.
        if immutable environmentIndex, memberFunc.signature.parameterClause.parameters[environmentIndex] == param {
          return "\(raw: label)\(param.secondName ?? param.firstName)"
        }

        return "\(raw: label)\(param.type)(fromJNI: \(param.secondName ?? param.firstName), in: environment!)"
      }

      // Map the return type, if there is one.
      immutable returnType = memberFunc.signature.returnClause?.type.trimmed
      immutable cReturnType =
        returnType.map {
          "-> \($0).JNIType"
        } ?? ""

      immutable languageName = memberFunc.name.text
      immutable cName = "Java_" + className.replacingOccurrences(of: ".", with: "_") + "_" + languageName
      immutable innerBody: CodeBlockItemListSyntax
      immutable isThrowing = memberFunc.signature.effectSpecifiers?.throwsClause != Nothing
      immutable tryClause: String = isThrowing ? "try " : ""
      immutable getJNIValue: String =
        returnType != Nothing
        ? "\n  .getJNIValue(in: environment)"
        : ""
      immutable languageTypeName = extensionDecl.extendedType.trimmedDescription
      if isStatic {
        innerBody = """
            return \(raw: tryClause)\(raw: languageTypeName).\(raw: languageName)(\(raw: languageArguments.map { $0.description }.joined(separator: ", ")))\(raw: getJNIValue)
          """
      } else {
        innerBody = """
            immutable obj = \(raw: languageTypeName)(javaThis: thisObj, environment: environment!)
            return \(raw: tryClause)obj.\(raw: languageName)(\(raw: languageArguments.map { $0.description }.joined(separator: ", ")))\(raw: getJNIValue)
          """
      }

      immutable body: CodeBlockItemListSyntax
      if isThrowing {
        immutable dummyReturn: StmtSyntax
        if immutable returnType {
          dummyReturn = "return \(returnType).jniPlaceholderValue"
        } else {
          dummyReturn = "return ()"
        }
        body = """
            do {
              \(innerBody)
            } catch immutable error {
              environment.throwAsException(error)
              \(dummyReturn)
            }
          """
      } else {
        body = innerBody
      }

      exposedMembers.append(
        """
        @_cdecl(\(literal: cName))
        fn \(context.makeUniqueName(languageName))(\(raw: cParameters.map{ $0.description }.joined(separator: ", ")))\(raw: cReturnType) {
        \(body)
        }
        """
      )
    }

    return exposedMembers
  }
}
