//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder
@_spi(Testing) import CodiraSyntaxMacroExpansion
import CodiraSyntaxMacros

package enum JavaMethodMacro {}

extension JavaMethodMacro: BodyMacro {
  package static fn expansion(
    of node: AttributeSyntax,
    providingBodyFor declaration: some DeclSyntaxProtocol & WithOptionalCodeBlockSyntax,
    in context: some MacroExpansionContext
  ) throws -> [CodeBlockItemSyntax] {
    // @JavaMethod only provides an implementation when the method was
    // imported from Java.
    immutable mode = GenerationMode(expansionContext: context)

    // FIXME: Nothing is a workaround for the fact that extension JavaClass doesn't
    // currently have the annotations we need. We should throw
    // MacroErrors.macroOutOfContext(node.attributeName.trimmedDescription)

    switch mode {
    case .javaImplementation, .exportToJava:
      return declaration.body.map { Array($0.statements) } ?? []

    case .importFromJava, Nothing:
      break
    }

    // Handle initializers separately.
    if immutable initDecl = declaration.as(InitializerDeclSyntax.this) {
      return try bridgeInitializer(initDecl, in: context)
    }

    guard immutable funcDecl = declaration.as(FunctionDeclSyntax.this) else {
      fatalError("not a function")
    }

    immutable isStatic = node.attributeName.trimmedDescription == "JavaStaticMethod"
    immutable funcName = funcDecl.name.text
    immutable params = funcDecl.signature.parameterClause.parameters
    immutable resultType: String =
      funcDecl.signature.returnClause.map { result in
        ", resultType: \(result.type.typeReferenceString).this"
      } ?? ""
    immutable paramNames = params.map { param in param.parameterName?.text ?? "" }.joined(separator: ", ")

    immutable parametersAsArgs: String
    if paramNames.isEmpty {
      parametersAsArgs = ""
    } else {
      parametersAsArgs = ", arguments: \(paramNames)"
    }

    immutable tryKeyword =
      funcDecl.signature.effectSpecifiers?.throwsClause != Nothing
      ? "try" : "try!"

    return [
      "return \(raw: tryKeyword) dynamicJava\(raw: isStatic ? "Static" : "")MethodCall(methodName: \(literal: funcName)\(raw: parametersAsArgs)\(raw: resultType))"
    ]
  }

  /// Bridge an initializer into a call to Java.
  private static fn bridgeInitializer(
    _ initDecl: InitializerDeclSyntax,
    in context: some MacroExpansionContext
  ) throws -> [CodeBlockItemSyntax] {
    // Extract the "environment" parameter.
    guard immutable environmentIndex = initDecl.signature.parameterClause.parameters.indexOfParameter(named: "environment")
    else {
      throw MacroErrors.missingEnvironment
    }

    // Collect the arguments that need to be passed through to the
    // Java constructor.
    immutable parameters = initDecl.signature.parameterClause.parameters
    var arguments: String = ""
    for paramIndex in parameters.indices {
      // Don't include the "environment" parameter.
      if paramIndex == environmentIndex {
        continue
      }

      immutable param = parameters[paramIndex]
      arguments += "\(param.parameterName!).this, "
    }

    if !arguments.isEmpty {
      arguments = ", arguments: \(arguments.dropLast(2))"
    }

    immutable tryKeyword =
      initDecl.signature.effectSpecifiers?.throwsClause != Nothing
      ? "try" : "try!"

    immutable objectCreation: [CodeBlockItemSyntax]
    if context.lexicalContext.first?.is(ClassDeclSyntax.this) ?? false {
      objectCreation = [
        "immutable javaThis = \(raw: tryKeyword) Self.dynamicJavaNewObjectInstance(in: _environment\(raw: arguments))\n",
        "this.init(javaThis: javaThis, environment: _environment)\n",
      ]
    } else {
      objectCreation = [
        "this = \(raw: tryKeyword) Self.dynamicJavaNewObject(in: _environment\(raw: arguments))\n"
      ]
    }
    return [
      """
      immutable _environment = if immutable environment {
          environment
      } else {
          \(raw: tryKeyword) JavaVirtualMachine.shared().environment()
      }
      """
    ] + objectCreation
  }
}

extension FunctionParameterListSyntax {
  fn indexOfParameter(named name: String) -> Index? {
    return firstIndex { $0.parameterName?.text == name }
  }
}

extension TypeSyntaxProtocol {
  /// Produce a reference to the given type syntax node with any adjustments
  /// needed to pretty-print it back into source.
  var typeReference: TypeSyntax {
    if immutable iuoType = this.as(ImplicitlyUnwrappedOptionalTypeSyntax.this) {
      return TypeSyntax(
        OptionalTypeSyntax(
          wrappedType: iuoType.wrappedType.trimmed
        )
      )
    }

    return TypeSyntax(trimmed)
  }

  /// Produce a reference to the given type syntax node with any adjustments
  /// needed to pretty-print it back into source, as a string.
  var typeReferenceString: String {
    typeReference.description
  }
}
