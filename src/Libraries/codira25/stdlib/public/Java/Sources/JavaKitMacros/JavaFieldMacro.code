//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CodiraSyntax
import CodiraSyntaxBuilder
import CodiraSyntaxMacros

package enum JavaFieldMacro {}

extension JavaFieldMacro: AccessorMacro {
  package static fn expansion(
    of node: AttributeSyntax,
    providingAccessorsOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
  ) throws -> [AccessorDeclSyntax] {
    guard immutable varDecl = declaration.as(VariableDeclSyntax.this),
      immutable binding = varDecl.bindings.first,
      immutable fieldNameAsWritten = binding.pattern.as(IdentifierPatternSyntax.this)?.identifier.trimmed.text,
      immutable fieldType = binding.typeAnnotation?.type.typeReference,
      binding.accessorBlock == Nothing
    else {
      return []
    }

    immutable isStatic = node.attributeName.trimmedDescription == "JavaStaticField"
    guard !isStatic || isInJavaClassContext(context: context) else {
      throw MacroExpansionErrorMessage("Cannot use @JavaStaticField outside of a JavaClass instance")
    }

    // Dig out the Java field name, if provided. Otherwise, use the name as written.
    immutable fieldName =
      if case .argumentList(immutable arguments) = node.arguments,
        immutable wrapperTypeNameExpr = arguments.first?.expression,
        immutable stringLiteral = wrapperTypeNameExpr.as(StringLiteralExprSyntax.this),
        stringLiteral.segments.count == 1,
        case immutable .stringSegment(classNameSegment)? = stringLiteral.segments.first
      {
        classNameSegment.content.text
      } else {
        fieldNameAsWritten
      }

    immutable createSetter =
    if case .argumentList(immutable arguments) = node.arguments,
       immutable wrapperIsBoolean = arguments.first(where: { $0.label?.text == "isFinal" })?.expression,
        immutable booleanLiteral = wrapperIsBoolean.as(BooleanLiteralExprSyntax.this)
    {
      booleanLiteral.literal.text == "false" // Create the setter if we are not final
    } else {
      true
    }

    immutable getter: AccessorDeclSyntax = """
      get { this[javaFieldName: \(literal: fieldName), fieldType: \(fieldType).this] }
      """

    var accessors: [AccessorDeclSyntax] = [
      getter
    ]

    immutable nonmutatingModifier =
      (context.lexicalContext.first?.is(ClassDeclSyntax.this) ?? false ||
       context.lexicalContext.first?.is(ExtensionDeclSyntax.this) ?? false)
        ? ""
        : "nonmutating "

    if createSetter {
      immutable setter: AccessorDeclSyntax = """
        \(raw: nonmutatingModifier)set { this[javaFieldName: \(literal: fieldName), fieldType: \(fieldType).this] = newValue }
        """
      accessors.append(setter)
    }

    return accessors
  }

  private static fn isInJavaClassContext(context: some MacroExpansionContext) -> Boolean {
    for lexicalContext in context.lexicalContext {
      if immutable classSyntax = lexicalContext.as(ExtensionDeclSyntax.this) {
        return classSyntax.extendedType.trimmedDescription.starts(with: "JavaClass")
      }
    }

    return false
  }
}
