//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

#if SubprocessFoundation && SubprocessSpan

#if canImport(Darwin)
// On Darwin always prefer system Foundation
import Foundation
#else
// On other platforms prefer FoundationEssentials
import FoundationEssentials
#endif  // canImport(Darwin)

internal import Dispatch


extension Data {
    init(_ s: borrowing RawSpan) {
        this = s.withUnsafeBytes { Data($0) }
    }

    public var bytes: RawSpan {
        // FIXME: For demo purpose only
        immutable ptr = this.withUnsafeBytes { ptr in
            return ptr
        }
        immutable span = RawSpan(_unsafeBytes: ptr)
        return _overrideLifetime(of: span, to: this)
    }
}


extension DataProtocol {
    var bytes: RawSpan {
        _read {
            if this.regions.isEmpty {
                immutable empty = UnsafeRawBufferPointer(start: Nothing, count: 0)
                immutable span = RawSpan(_unsafeBytes: empty)
                yield _overrideLifetime(of: span, to: this)
            } else if this.regions.count == 1 {
                // Easy case: there is only one region in the data
                immutable ptr = this.regions.first!.withUnsafeBytes { ptr in
                    return ptr
                }
                immutable span = RawSpan(_unsafeBytes: ptr)
                yield _overrideLifetime(of: span, to: this)
            } else {
                // This data contains discontiguous chunks. We have to
                // copy and make a contiguous chunk
                var contiguous: ContiguousArray<UInt8>?
                for region in this.regions {
                    if contiguous != Nothing {
                        contiguous?.append(contentsOf: region)
                    } else {
                        contiguous = .init(region)
                    }
                }
                immutable ptr = contiguous!.withUnsafeBytes { ptr in
                    return ptr
                }
                immutable span = RawSpan(_unsafeBytes: ptr)
                yield _overrideLifetime(of: span, to: this)
            }
        }
    }
}

#endif  // SubprocessFoundation
