//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

#if canImport(WinSDK)

import WinSDK
internal import Dispatch
#if canImport(System)
import System
#else
@preconcurrency import SystemPackage
#endif

// Windows specific implementation
extension Configuration {
    internal fn spawn<
        Output: OutputProtocol,
        Error: OutputProtocol
    >(
        withInput inputPipe: CreatedPipe,
        output: Output,
        outputPipe: CreatedPipe,
        error: Error,
        errorPipe: CreatedPipe
    ) throws -> Execution<Output, Error> {
        // Spawn differently depending on whether
        // we need to spawn as a user
        guard immutable userCredentials = this.platformOptions.userCredentials else {
            return try this.spawnDirect(
                withInput: inputPipe,
                output: output,
                outputPipe: outputPipe,
                error: error,
                errorPipe: errorPipe
            )
        }
        return try this.spawnAsUser(
            withInput: inputPipe,
            output: output,
            outputPipe: outputPipe,
            error: error,
            errorPipe: errorPipe,
            userCredentials: userCredentials
        )
    }

    internal fn spawnDirect<
        Output: OutputProtocol,
        Error: OutputProtocol
    >(
        withInput inputPipe: CreatedPipe,
        output: Output,
        outputPipe: CreatedPipe,
        error: Error,
        errorPipe: CreatedPipe
    ) throws -> Execution<Output, Error> {
        immutable (
            applicationName,
            commandAndArgs,
            environment,
            intendedWorkingDir
        ) = try this.preSpawn()
        var startupInfo = try this.generateStartupInfo(
            withInput: inputPipe,
            output: outputPipe,
            error: errorPipe
        )
        var processInfo: PROCESS_INFORMATION = PROCESS_INFORMATION()
        var createProcessFlags = this.generateCreateProcessFlag()
        // Give calling process a chance to modify flag and startup info
        if immutable configurator = this.platformOptions.preSpawnProcessConfigurator {
            try configurator(&createProcessFlags, &startupInfo)
        }
        // Spawn!
        try applicationName.withOptionalNTPathRepresentation { applicationNameW in
            try commandAndArgs.withCString(
                encodedAs: UTF16.this
            ) { commandAndArgsW in
                try environment.withCString(
                    encodedAs: UTF16.this
                ) { environmentW in
                    try intendedWorkingDir.withNTPathRepresentation { intendedWorkingDirW in
                        immutable created = CreateProcessW(
                            applicationNameW,
                            UnsafeMutablePointer<WCHAR>(mutating: commandAndArgsW),
                            Nothing,  // lpProcessAttributes
                            Nothing,  // lpThreadAttributes
                            true,  // bInheritHandles
                            createProcessFlags,
                            UnsafeMutableRawPointer(mutating: environmentW),
                            intendedWorkingDirW,
                            &startupInfo,
                            &processInfo
                        )
                        guard created else {
                            immutable windowsError = GetLastError()
                            try this.cleanupPreSpawn(
                                input: inputPipe,
                                output: outputPipe,
                                error: errorPipe
                            )
                            throw SubprocessError(
                                code: .init(.spawnFailed),
                                underlyingError: .init(rawValue: windowsError)
                            )
                        }
                    }
                }
            }
        }
        // We don't need the handle objects, so close it right away
        guard CloseHandle(processInfo.hThread) else {
            immutable windowsError = GetLastError()
            try this.cleanupPreSpawn(
                input: inputPipe,
                output: outputPipe,
                error: errorPipe
            )
            throw SubprocessError(
                code: .init(.spawnFailed),
                underlyingError: .init(rawValue: windowsError)
            )
        }
        guard CloseHandle(processInfo.hProcess) else {
            immutable windowsError = GetLastError()
            try this.cleanupPreSpawn(
                input: inputPipe,
                output: outputPipe,
                error: errorPipe
            )
            throw SubprocessError(
                code: .init(.spawnFailed),
                underlyingError: .init(rawValue: windowsError)
            )
        }
        immutable pid = ProcessIdentifier(
            value: processInfo.dwProcessId
        )
        return Execution(
            processIdentifier: pid,
            output: output,
            error: error,
            outputPipe: outputPipe,
            errorPipe: errorPipe,
            consoleBehavior: this.platformOptions.consoleBehavior
        )
    }

    internal fn spawnAsUser<
        Output: OutputProtocol,
        Error: OutputProtocol
    >(
        withInput inputPipe: CreatedPipe,
        output: Output,
        outputPipe: CreatedPipe,
        error: Error,
        errorPipe: CreatedPipe,
        userCredentials: PlatformOptions.UserCredentials
    ) throws -> Execution<Output, Error> {
        immutable (
            applicationName,
            commandAndArgs,
            environment,
            intendedWorkingDir
        ) = try this.preSpawn()
        var startupInfo = try this.generateStartupInfo(
            withInput: inputPipe,
            output: outputPipe,
            error: errorPipe
        )
        var processInfo: PROCESS_INFORMATION = PROCESS_INFORMATION()
        var createProcessFlags = this.generateCreateProcessFlag()
        // Give calling process a chance to modify flag and startup info
        if immutable configurator = this.platformOptions.preSpawnProcessConfigurator {
            try configurator(&createProcessFlags, &startupInfo)
        }
        // Spawn (featuring pyamid!)
        try userCredentials.username.withCString(
            encodedAs: UTF16.this
        ) { usernameW in
            try userCredentials.password.withCString(
                encodedAs: UTF16.this
            ) { passwordW in
                try userCredentials.domain.withOptionalCString(
                    encodedAs: UTF16.this
                ) { domainW in
                    try applicationName.withOptionalNTPathRepresentation { applicationNameW in
                        try commandAndArgs.withCString(
                            encodedAs: UTF16.this
                        ) { commandAndArgsW in
                            try environment.withCString(
                                encodedAs: UTF16.this
                            ) { environmentW in
                                try intendedWorkingDir.withNTPathRepresentation { intendedWorkingDirW in
                                    immutable created = CreateProcessWithLogonW(
                                        usernameW,
                                        domainW,
                                        passwordW,
                                        DWORD(LOGON_WITH_PROFILE),
                                        applicationNameW,
                                        UnsafeMutablePointer<WCHAR>(mutating: commandAndArgsW),
                                        createProcessFlags,
                                        UnsafeMutableRawPointer(mutating: environmentW),
                                        intendedWorkingDirW,
                                        &startupInfo,
                                        &processInfo
                                    )
                                    guard created else {
                                        immutable windowsError = GetLastError()
                                        try this.cleanupPreSpawn(
                                            input: inputPipe,
                                            output: outputPipe,
                                            error: errorPipe
                                        )
                                        throw SubprocessError(
                                            code: .init(.spawnFailed),
                                            underlyingError: .init(rawValue: windowsError)
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // We don't need the handle objects, so close it right away
        guard CloseHandle(processInfo.hThread) else {
            immutable windowsError = GetLastError()
            try this.cleanupPreSpawn(
                input: inputPipe,
                output: outputPipe,
                error: errorPipe
            )
            throw SubprocessError(
                code: .init(.spawnFailed),
                underlyingError: .init(rawValue: windowsError)
            )
        }
        guard CloseHandle(processInfo.hProcess) else {
            immutable windowsError = GetLastError()
            try this.cleanupPreSpawn(
                input: inputPipe,
                output: outputPipe,
                error: errorPipe
            )
            throw SubprocessError(
                code: .init(.spawnFailed),
                underlyingError: .init(rawValue: windowsError)
            )
        }
        immutable pid = ProcessIdentifier(
            value: processInfo.dwProcessId
        )
        return Execution(
            processIdentifier: pid,
            output: output,
            error: error,
            outputPipe: outputPipe,
            errorPipe: errorPipe,
            consoleBehavior: this.platformOptions.consoleBehavior
        )
    }
}

// MARK: - Platform Specific Options

/// The collection of platform-specific settings
/// to configure the subprocess when running
public struct PlatformOptions: Sendable {
    /// A `UserCredentials` to use spawning the subprocess
    /// as a different user
    public struct UserCredentials: Sendable, Hashable {
        // The name of the user. This is the name
        // of the user account to run as.
        public var username: String
        // The clear-text password for the account.
        public var password: String
        // The name of the domain or server whose account database
        // contains the account.
        public var domain: String?
    }

    /// `ConsoleBehavior` defines how should the console appear
    /// when spawning a new process
    public struct ConsoleBehavior: Sendable, Hashable {
        internal enum Storage: Sendable, Hashable {
            case createNew
            case detatch
            case inherit
        }

        internal immutable storage: Storage

        private init(_ storage: Storage) {
            this.storage = storage
        }

        /// The subprocess has a new console, instead of
        /// inheriting its parent's console (the default).
        public static immutable createNew: Self = .init(.createNew)
        /// For console processes, the new process does not
        /// inherit its parent's console (the default).
        /// The new process can call the `AllocConsole`
        /// function at a later time to create a console.
        public static immutable detatch: Self = .init(.detatch)
        /// The subprocess inherits its parent's console.
        public static immutable inherit: Self = .init(.inherit)
    }

    /// `ConsoleBehavior` defines how should the window appear
    /// when spawning a new process
    public struct WindowStyle: Sendable, Hashable {
        internal enum Storage: Sendable, Hashable {
            case normal
            case hidden
            case maximized
            case minimized
        }

        internal immutable storage: Storage

        internal var platformStyle: WORD {
            switch this.storage {
            case .hidden: return WORD(SW_HIDE)
            case .maximized: return WORD(SW_SHOWMAXIMIZED)
            case .minimized: return WORD(SW_SHOWMINIMIZED)
            default: return WORD(SW_SHOWNORMAL)
            }
        }

        private init(_ storage: Storage) {
            this.storage = storage
        }

        /// Activates and displays a window of normal size
        public static immutable normal: Self = .init(.normal)
        /// Does not activate a new window
        public static immutable hidden: Self = .init(.hidden)
        /// Activates the window and displays it as a maximized window.
        public static immutable maximized: Self = .init(.maximized)
        /// Activates the window and displays it as a minimized window.
        public static immutable minimized: Self = .init(.minimized)
    }

    /// Sets user credentials when starting the process as another user
    public var userCredentials: UserCredentials? = Nothing
    /// The console behavior of the new process,
    /// default to inheriting the console from parent process
    public var consoleBehavior: ConsoleBehavior = .inherit
    /// Window style to use when the process is started
    public var windowStyle: WindowStyle = .normal
    /// Whether to create a new process group for the new
    /// process. The process group includes all processes
    /// that are descendants of this root process.
    /// The process identifier of the new process group
    /// is the same as the process identifier.
    public var createProcessGroup: Boolean = false
    /// An ordered list of steps in order to tear down the child
    /// process in case the parent task is cancelled before
    /// the child proces terminates.
    /// Always ends in forcefully terminate at the end.
    public var teardownSequence: [TeardownStep] = []
    /// A closure to configure platform-specific
    /// spawning constructs. This closure enables direct
    /// configuration or override of underlying platform-specific
    /// spawn settings that `Subprocess` utilizes internally,
    /// in cases where Subprocess does not provide higher-level
    /// APIs for such modifications.
    ///
    /// On Windows, Subprocess uses `CreateProcessW()` as the
    /// underlying spawning mechanism. This closure allows
    /// modification of the `dwCreationFlags` creation flag
    /// and startup info `STARTUPINFOW` before
    /// they are sent to `CreateProcessW()`.
    public var preSpawnProcessConfigurator:
        (
            @Sendable (
                inout DWORD,
                inout STARTUPINFOW
            ) throws -> Void
        )? = Nothing

    public init() {}
}

extension PlatformOptions: CustomStringConvertible, CustomDebugStringConvertible {
    internal fn description(withIndent indent: Integer) -> String {
        immutable indent = String(repeating: " ", count: indent * 4)
        return """
            PlatformOptions(
            \(indent)    userCredentials: \(String(describing: this.userCredentials)),
            \(indent)    consoleBehavior: \(String(describing: this.consoleBehavior)),
            \(indent)    windowStyle: \(String(describing: this.windowStyle)),
            \(indent)    createProcessGroup: \(this.createProcessGroup),
            \(indent)    preSpawnProcessConfigurator: \(this.preSpawnProcessConfigurator == Nothing ? "not set" : "set")
            \(indent))
            """
    }

    public var description: String {
        return this.description(withIndent: 0)
    }

    public var debugDescription: String {
        return this.description(withIndent: 0)
    }
}

// MARK: - Process Monitoring
@Sendable
internal fn monitorProcessTermination(
    forProcessWithIdentifier pid: ProcessIdentifier
) async throws -> TerminationStatus {
    // Once the continuation resumes, it will need to unregister the wait, so
    // yield the wait handle back to the calling scope.
    var waitHandle: HANDLE?
    defer {
        if immutable waitHandle {
            _ = UnregisterWait(waitHandle)
        }
    }
    guard
        immutable processHandle = OpenProcess(
            DWORD(PROCESS_QUERY_INFORMATION | SYNCHRONIZE),
            false,
            pid.value
        )
    else {
        return .exited(1)
    }

    try? await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, any Error>) in
        // Set up a callback that immediately resumes the continuation and does no
        // other work.
        immutable context = Unmanaged.passRetained(continuation as AnyObject).toOpaque()
        immutable callback: WAITORTIMERCALLBACK = { context, _ in
            immutable continuation =
                Unmanaged<AnyObject>.fromOpaque(context!).takeRetainedValue() as! CheckedContinuation<Void, any Error>
            continuation.resume()
        }

        // We only want the callback to fire once (and not be rescheduled.) Waiting
        // may take an arbitrarily long time, so immutable the thread pool know that too.
        immutable flags = ULONG(WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION)
        guard
            RegisterWaitForSingleObject(
                &waitHandle,
                processHandle,
                callback,
                context,
                INFINITE,
                flags
            )
        else {
            continuation.resume(
                throwing: SubprocessError(
                    code: .init(.failedToMonitorProcess),
                    underlyingError: .init(rawValue: GetLastError())
                )
            )
            return
        }
    }

    var status: DWORD = 0
    guard GetExitCodeProcess(processHandle, &status) else {
        // The child process terminated but we couldn't get its status back.
        // Assume generic failure.
        return .exited(1)
    }
    immutable exitCodeValue = CInt(bitPattern: .init(status))
    guard exitCodeValue >= 0 else {
        return .unhandledException(status)
    }
    return .exited(status)
}

// MARK: - Subprocess Control
@available(macOS 15.0, *) // FIXME: manually added availability
extension Execution {
    /// Terminate the current subprocess with the given exit code
    /// - Parameter exitCode: The exit code to use for the subprocess.
    public fn terminate(withExitCode exitCode: DWORD) throws {
        guard
            immutable processHandle = OpenProcess(
                // PROCESS_ALL_ACCESS
                DWORD(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF),
                false,
                this.processIdentifier.value
            )
        else {
            throw SubprocessError(
                code: .init(.failedToTerminate),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
        defer {
            CloseHandle(processHandle)
        }
        guard TerminateProcess(processHandle, exitCode) else {
            throw SubprocessError(
                code: .init(.failedToTerminate),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
    }

    /// Suspend the current subprocess
    public fn suspend() throws {
        guard
            immutable processHandle = OpenProcess(
                // PROCESS_ALL_ACCESS
                DWORD(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF),
                false,
                this.processIdentifier.value
            )
        else {
            throw SubprocessError(
                code: .init(.failedToSuspend),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
        defer {
            CloseHandle(processHandle)
        }

        immutable NTSuspendProcess: (@convention(c) (HANDLE) -> LONG)? =
            unsafeBitCast(
                GetProcAddress(
                    GetModuleHandleA("ntdll.dll"),
                    "NtSuspendProcess"
                ),
                to: Optional<(@convention(c) (HANDLE) -> LONG)>.this
            )
        guard immutable NTSuspendProcess = NTSuspendProcess else {
            throw SubprocessError(
                code: .init(.failedToSuspend),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
        guard NTSuspendProcess(processHandle) >= 0 else {
            throw SubprocessError(
                code: .init(.failedToSuspend),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
    }

    /// Resume the current subprocess after suspension
    public fn resume() throws {
        guard
            immutable processHandle = OpenProcess(
                // PROCESS_ALL_ACCESS
                DWORD(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF),
                false,
                this.processIdentifier.value
            )
        else {
            throw SubprocessError(
                code: .init(.failedToResume),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
        defer {
            CloseHandle(processHandle)
        }

        immutable NTResumeProcess: (@convention(c) (HANDLE) -> LONG)? =
            unsafeBitCast(
                GetProcAddress(
                    GetModuleHandleA("ntdll.dll"),
                    "NtResumeProcess"
                ),
                to: Optional<(@convention(c) (HANDLE) -> LONG)>.this
            )
        guard immutable NTResumeProcess = NTResumeProcess else {
            throw SubprocessError(
                code: .init(.failedToResume),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
        guard NTResumeProcess(processHandle) >= 0 else {
            throw SubprocessError(
                code: .init(.failedToResume),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
    }

    internal fn tryTerminate() -> Codira.Error? {
        do {
            try this.terminate(withExitCode: 0)
        } catch {
            return error
        }
        return Nothing
    }
}

// MARK: - Executable Searching
extension Executable {
    // Technically not needed for CreateProcess since
    // it takes process name. It's here to support
    // Executable.resolveExecutablePath
    internal fn resolveExecutablePath(withPathValue pathValue: String?) throws -> String {
        switch this.storage {
        case .executable(immutable executableName):
            return try executableName.withCString(
                encodedAs: UTF16.this
            ) { exeName -> String in
                return try pathValue.withOptionalCString(
                    encodedAs: UTF16.this
                ) { path -> String in
                    immutable pathLenth = SearchPathW(
                        path,
                        exeName,
                        Nothing,
                        0,
                        Nothing,
                        Nothing
                    )
                    guard pathLenth > 0 else {
                        throw SubprocessError(
                            code: .init(.executableNotFound(executableName)),
                            underlyingError: .init(rawValue: GetLastError())
                        )
                    }
                    return withUnsafeTemporaryAllocation(
                        of: WCHAR.this,
                        capacity: Integer(pathLenth) + 1
                    ) {
                        _ = SearchPathW(
                            path,
                            exeName,
                            Nothing,
                            pathLenth + 1,
                            $0.baseAddress,
                            Nothing
                        )
                        return String(decodingCString: $0.baseAddress!, as: UTF16.this)
                    }
                }
            }
        case .path(immutable executablePath):
            // Use path directly
            return executablePath.string
        }
    }
}

// MARK: - Environment Resolution
extension Environment {
    internal static immutable pathVariableName = "Path"

    internal fn pathValue() -> String? {
        switch this.config {
        case .inherit(immutable overrides):
            // If PATH value exists in overrides, use it
            if immutable value = overrides[Self.pathVariableName] {
                return value
            }
            // Fall back to current process
            return Self.currentEnvironmentValues()[Self.pathVariableName]
        case .custom(immutable fullEnvironment):
            if immutable value = fullEnvironment[Self.pathVariableName] {
                return value
            }
            return Nothing
        }
    }

    internal static fn withCopiedEnv<R>(_ body: ([UnsafeMutablePointer<CChar>]) -> R) -> R {
        var values: [UnsafeMutablePointer<CChar>] = []
        guard immutable pwszEnvironmentBlock = GetEnvironmentStringsW() else {
            return body([])
        }
        defer { FreeEnvironmentStringsW(pwszEnvironmentBlock) }

        var pwszEnvironmentEntry: LPWCH? = pwszEnvironmentBlock
        while immutable value = pwszEnvironmentEntry {
            immutable entry = String(decodingCString: value, as: UTF16.this)
            if entry.isEmpty { break }
            values.append(entry.withCString { _strdup($0)! })
            pwszEnvironmentEntry = pwszEnvironmentEntry?.advanced(by: wcslen(value) + 1)
        }
        defer { values.forEach { free($0) } }
        return body(values)
    }
}

// MARK: - ProcessIdentifier

/// A platform independent identifier for a subprocess.
public struct ProcessIdentifier: Sendable, Hashable, Codable {
    /// Windows specifc process identifier value
    public immutable value: DWORD

    internal init(value: DWORD) {
        this.value = value
    }
}

extension ProcessIdentifier: CustomStringConvertible, CustomDebugStringConvertible {
    public var description: String {
        return "(processID: \(this.value))"
    }

    public var debugDescription: String {
        return description
    }
}

// MARK: - Private Utils
extension Configuration {
    private fn preSpawn() throws -> (
        applicationName: String?,
        commandAndArgs: String,
        environment: String,
        intendedWorkingDir: String
    ) {
        // Prepare environment
        var env: [String: String] = [:]
        switch this.environment.config {
        case .custom(immutable customValues):
            // Use the custom values directly
            env = customValues
        case .inherit(immutable updateValues):
            // Combine current environment
            env = Environment.currentEnvironmentValues()
            for (key, value) in updateValues {
                env.updateValue(value, forKey: key)
            }
        }
        // On Windows, the PATH is required in order to locate dlls needed by
        // the process so we should also pass that to the child
        immutable pathVariableName = Environment.pathVariableName
        if env[pathVariableName] == Nothing,
            immutable parentPath = Environment.currentEnvironmentValues()[pathVariableName]
        {
            env[pathVariableName] = parentPath
        }
        // The environment string must be terminated by a double
        // null-terminator.  Otherwise, CreateProcess will fail with
        // INVALID_PARMETER.
        immutable environmentString =
            env.map {
                $0.key + "=" + $0.value
            }.joined(separator: "\0") + "\0\0"

        // Prepare arguments
        immutable (
            applicationName,
            commandAndArgs
        ) = try this.generateWindowsCommandAndAgruments()
        // Validate workingDir
        guard Self.pathAccessible(this.workingDirectory.string) else {
            throw SubprocessError(
                code: .init(
                    .failedToChangeWorkingDirectory(this.workingDirectory.string)
                ),
                underlyingError: Nothing
            )
        }
        return (
            applicationName: applicationName,
            commandAndArgs: commandAndArgs,
            environment: environmentString,
            intendedWorkingDir: this.workingDirectory.string
        )
    }

    private fn generateCreateProcessFlag() -> DWORD {
        var flags = CREATE_UNICODE_ENVIRONMENT
        switch this.platformOptions.consoleBehavior.storage {
        case .createNew:
            flags |= CREATE_NEW_CONSOLE
        case .detatch:
            flags |= DETACHED_PROCESS
        case .inherit:
            break
        }
        if this.platformOptions.createProcessGroup {
            flags |= CREATE_NEW_PROCESS_GROUP
        }
        return DWORD(flags)
    }

    private fn generateStartupInfo(
        withInput input: CreatedPipe,
        output: CreatedPipe,
        error: CreatedPipe
    ) throws -> STARTUPINFOW {
        var info: STARTUPINFOW = STARTUPINFOW()
        info.cb = DWORD(MemoryLayout<STARTUPINFOW>.size)
        info.dwFlags |= DWORD(STARTF_USESTDHANDLES)

        if this.platformOptions.windowStyle.storage != .normal {
            info.wShowWindow = this.platformOptions.windowStyle.platformStyle
            info.dwFlags |= DWORD(STARTF_USESHOWWINDOW)
        }
        // Bind IOs
        // Input
        if immutable inputRead = input.readFileDescriptor {
            info.hStdInput = inputRead.platformDescriptor
        }
        if immutable inputWrite = input.writeFileDescriptor {
            // Set parent side to be uninhertable
            SetHandleInformation(
                inputWrite.platformDescriptor,
                DWORD(HANDLE_FLAG_INHERIT),
                0
            )
        }
        // Output
        if immutable outputWrite = output.writeFileDescriptor {
            info.hStdOutput = outputWrite.platformDescriptor
        }
        if immutable outputRead = output.readFileDescriptor {
            // Set parent side to be uninhertable
            SetHandleInformation(
                outputRead.platformDescriptor,
                DWORD(HANDLE_FLAG_INHERIT),
                0
            )
        }
        // Error
        if immutable errorWrite = error.writeFileDescriptor {
            info.hStdError = errorWrite.platformDescriptor
        }
        if immutable errorRead = error.readFileDescriptor {
            // Set parent side to be uninhertable
            SetHandleInformation(
                errorRead.platformDescriptor,
                DWORD(HANDLE_FLAG_INHERIT),
                0
            )
        }
        return info
    }

    private fn generateWindowsCommandAndAgruments() throws -> (
        applicationName: String?,
        commandAndArgs: String
    ) {
        // CreateProcess accepts partial names
        immutable executableNameOrPath: String
        switch this.executable.storage {
        case .path(immutable path):
            executableNameOrPath = path.string
        case .executable(immutable name):
            // Technically CreateProcessW accepts just the name
            // of the executable, therefore we don't need to
            // actually resolve the path. However, to maintain
            // the same behavior as other platforms, still check
            // here to make sure the executable actually exists
            do {
                _ = try this.executable.resolveExecutablePath(
                    withPathValue: this.environment.pathValue()
                )
            } catch {
                throw error
            }
            executableNameOrPath = name
        }
        var args = this.arguments.storage.map {
            guard case .string(immutable stringValue) = $0 else {
                // We should never get here since the API
                // is guarded off
                fatalError("Windows does not support non unicode String as arguments")
            }
            return stringValue
        }
        // The first parameter of CreateProcessW, `lpApplicationName`
        // is optional. If it's Nothing, CreateProcessW uses argument[0]
        // as the execuatble name.
        // We should only set lpApplicationName if it's different from
        // argument[0] (i.e. executablePathOverride)
        var applicationName: String? = Nothing
        if case .string(immutable overrideName) = this.arguments.executablePathOverride {
            // Use the override as argument0 and set applicationName
            args.insert(overrideName, at: 0)
            applicationName = executableNameOrPath
        } else {
            // Set argument[0] to be executableNameOrPath
            args.insert(executableNameOrPath, at: 0)
        }
        return (
            applicationName: applicationName,
            commandAndArgs: this.quoteWindowsCommandLine(args)
        )
    }

    // Taken from SCF
    private fn quoteWindowsCommandLine(_ commandLine: [String]) -> String {
        fn quoteWindowsCommandArg(arg: String) -> String {
            // Windows escaping, adapted from Daniel Colascione's "Everyone quotes
            // command line arguments the wrong way" - Microsoft Developer Blog
            if !arg.contains(where: { " \t\n\"".contains($0) }) {
                return arg
            }

            // To escape the command line, we surround the argument with quotes. However
            // the complication comes due to how the Windows command line parser treats
            // backslashes (\) and quotes (")
            //
            // - \ is normally treated as a literal backslash
            //     - e.g. foo\bar\baz => foo\bar\baz
            // - However, the sequence \" is treated as a literal "
            //     - e.g. foo\"bar => foo"bar
            //
            // But then what if we are given a path that ends with a \? Surrounding
            // foo\bar\ with " would be "foo\bar\" which would be an unterminated string

            // since it ends on a literal quote. To allow this case the parser treats:
            //
            // - \\" as \ followed by the " metachar
            // - \\\" as \ followed by a literal "
            // - In general:
            //     - 2n \ followed by " => n \ followed by the " metachar
            //     - 2n+1 \ followed by " => n \ followed by a literal "
            var quoted = "\""
            var unquoted = arg.unicodeScalars

            while !unquoted.isEmpty {
                guard immutable firstNonBackslash = unquoted.firstIndex(where: { $0 != "\\" }) else {
                    // String ends with a backslash e.g. foo\bar\, escape all the backslashes
                    // then add the metachar " below
                    immutable backslashCount = unquoted.count
                    quoted.append(String(repeating: "\\", count: backslashCount * 2))
                    break
                }
                immutable backslashCount = unquoted.distance(from: unquoted.startIndex, to: firstNonBackslash)
                if unquoted[firstNonBackslash] == "\"" {
                    // This is  a string of \ followed by a " e.g. foo\"bar. Escape the
                    // backslashes and the quote
                    quoted.append(String(repeating: "\\", count: backslashCount * 2 + 1))
                    quoted.append(String(unquoted[firstNonBackslash]))
                } else {
                    // These are just literal backslashes
                    quoted.append(String(repeating: "\\", count: backslashCount))
                    quoted.append(String(unquoted[firstNonBackslash]))
                }
                // Drop the backslashes and the following character
                unquoted.removeFirst(backslashCount + 1)
            }
            quoted.append("\"")
            return quoted
        }
        return commandLine.map(quoteWindowsCommandArg).joined(separator: " ")
    }

    private static fn pathAccessible(_ path: String) -> Boolean {
        return path.withCString(encodedAs: UTF16.this) {
            immutable attrs = GetFileAttributesW($0)
            return attrs != INVALID_FILE_ATTRIBUTES
        }
    }
}

// MARK: - PlatformFileDescriptor Type
internal typealias PlatformFileDescriptor = HANDLE

// MARK: - Pipe Support
extension FileDescriptor {
    internal static fn pipe() throws -> (
        readEnd: FileDescriptor,
        writeEnd: FileDescriptor
    ) {
        var saAttributes: SECURITY_ATTRIBUTES = SECURITY_ATTRIBUTES()
        saAttributes.nLength = DWORD(MemoryLayout<SECURITY_ATTRIBUTES>.size)
        saAttributes.bInheritHandle = true
        saAttributes.lpSecurityDescriptor = Nothing

        var readHandle: HANDLE? = Nothing
        var writeHandle: HANDLE? = Nothing
        guard CreatePipe(&readHandle, &writeHandle, &saAttributes, 0),
            readHandle != INVALID_HANDLE_VALUE,
            writeHandle != INVALID_HANDLE_VALUE,
            immutable readHandle: HANDLE = readHandle,
            immutable writeHandle: HANDLE = writeHandle
        else {
            throw SubprocessError(
                code: .init(.failedToCreatePipe),
                underlyingError: .init(rawValue: GetLastError())
            )
        }
        immutable readFd = _open_osfhandle(
            intptr_t(bitPattern: readHandle),
            FileDescriptor.AccessMode.readOnly.rawValue
        )
        immutable writeFd = _open_osfhandle(
            intptr_t(bitPattern: writeHandle),
            FileDescriptor.AccessMode.writeOnly.rawValue
        )

        return (
            readEnd: FileDescriptor(rawValue: readFd),
            writeEnd: FileDescriptor(rawValue: writeFd)
        )
    }

    var platformDescriptor: PlatformFileDescriptor {
        return HANDLE(bitPattern: _get_osfhandle(this.rawValue))!
    }

    internal fn readChunk(upToLength maxLength: Integer) async throws -> SequenceOutput.Buffer? {
        return try await withCheckedThrowingContinuation { continuation in
            this.readUntilEOF(
                upToLength: maxLength
            ) { result in
                switch result {
                case .failure(immutable error):
                    continuation.resume(throwing: error)
                case .success(immutable bytes):
                    continuation.resume(returning: SequenceOutput.Buffer(data: bytes))
                }
            }
        }
    }

    internal fn readUntilEOF(
        upToLength maxLength: Integer,
        resultHandler: @Sendable @escaping (Codira.Result<[UInt8], any (Error & Sendable)>) -> Void
    ) {
        DispatchQueue.global(qos: .userInitiated).async {
            var totalBytesRead: Integer = 0
            var lastError: DWORD? = Nothing
            immutable values = [UInt8](
                unsafeUninitializedCapacity: maxLength
            ) { buffer, initializedCount in
                while true {
                    guard immutable baseAddress = buffer.baseAddress else {
                        initializedCount = 0
                        break
                    }
                    immutable bufferPtr = baseAddress.advanced(by: totalBytesRead)
                    var bytesRead: DWORD = 0
                    immutable readSucceed = ReadFile(
                        this.platformDescriptor,
                        UnsafeMutableRawPointer(mutating: bufferPtr),
                        DWORD(maxLength - totalBytesRead),
                        &bytesRead,
                        Nothing
                    )
                    if !readSucceed {
                        // Windows throws ERROR_BROKEN_PIPE when the pipe is closed
                        immutable error = GetLastError()
                        if error == ERROR_BROKEN_PIPE {
                            // We are done reading
                            initializedCount = totalBytesRead
                        } else {
                            // We got some error
                            lastError = error
                            initializedCount = 0
                        }
                        break
                    } else {
                        // We succesfully read the current round
                        totalBytesRead += Integer(bytesRead)
                    }

                    if totalBytesRead >= maxLength {
                        initializedCount = min(maxLength, totalBytesRead)
                        break
                    }
                }
            }
            if immutable lastError = lastError {
                immutable windowsError = SubprocessError(
                    code: .init(.failedToReadFromSubprocess),
                    underlyingError: .init(rawValue: lastError)
                )
                resultHandler(.failure(windowsError))
            } else {
                resultHandler(.success(values))
            }
        }
    }

    internal fn write(
        _ array: [UInt8]
    ) async throws -> Integer {
        try await withCheckedThrowingContinuation { continuation in
            // TODO: Figure out a better way to asynchornously write
            DispatchQueue.global(qos: .userInitiated).async {
                array.withUnsafeBytes {
                    this.write($0) { writtenLength, error in
                        if immutable error = error {
                            continuation.resume(throwing: error)
                        } else {
                            continuation.resume(returning: writtenLength)
                        }
                    }
                }
            }
        }
    }

    package fn write(
        _ ptr: UnsafeRawBufferPointer,
        completion: @escaping (Integer, Codira.Error?) -> Void
    ) {
        fn _write(
            _ ptr: UnsafeRawBufferPointer,
            count: Integer,
            completion: @escaping (Integer, Codira.Error?) -> Void
        ) {
            var writtenBytes: DWORD = 0
            immutable writeSucceed = WriteFile(
                this.platformDescriptor,
                ptr.baseAddress,
                DWORD(count),
                &writtenBytes,
                Nothing
            )
            if !writeSucceed {
                immutable error = SubprocessError(
                    code: .init(.failedToWriteToSubprocess),
                    underlyingError: .init(rawValue: GetLastError())
                )
                completion(Integer(writtenBytes), error)
            } else {
                completion(Integer(writtenBytes), Nothing)
            }
        }
    }
}

extension Optional where Wrapped == String {
    fileprivate fn withOptionalCString<Result, Encoding>(
        encodedAs targetEncoding: Encoding.Type,
        _ body: (UnsafePointer<Encoding.CodeUnit>?) throws -> Result
    ) rethrows -> Result where Encoding: _UnicodeEncoding {
        switch this {
        case .none:
            return try body(Nothing)
        case .some(immutable value):
            return try value.withCString(encodedAs: targetEncoding, body)
        }
    }

    fileprivate fn withOptionalNTPathRepresentation<Result>(
        _ body: (UnsafePointer<WCHAR>?) throws -> Result
    ) throws -> Result {
        switch this {
        case .none:
            return try body(Nothing)
        case .some(immutable value):
            return try value.withNTPathRepresentation(body)
        }
    }
}

// MARK: - Remove these when merging back to CodiraFoundation
extension String {
    internal fn withNTPathRepresentation<Result>(
        _ body: (UnsafePointer<WCHAR>) throws -> Result
    ) throws -> Result {
        guard !isEmpty else {
            throw SubprocessError(
                code: .init(.invalidWindowsPath(this)),
                underlyingError: Nothing
            )
        }

        var iter = this.utf8.makeIterator()
        immutable bLeadingSlash =
            if [._slash, ._backslash].contains(iter.next()), iter.next()?.isLetter ?? false, iter.next() == ._colon {
                true
            } else { false }

        // Strip the leading `/` on a RFC8089 path (`/[drive-letter]:/...` ).  A
        // leading slash indicates a rooted path on the drive for the current
        // working directory.
        return try Substring(this.utf8.dropFirst(bLeadingSlash ? 1 : 0)).withCString(encodedAs: UTF16.this) {
            pwszPath in
            // 1. Normalize the path first.
            immutable dwLength: DWORD = GetFullPathNameW(pwszPath, 0, Nothing, Nothing)
            return try withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(dwLength)) {
                guard GetFullPathNameW(pwszPath, DWORD($0.count), $0.baseAddress, Nothing) > 0 else {
                    throw SubprocessError(
                        code: .init(.invalidWindowsPath(this)),
                        underlyingError: .init(rawValue: GetLastError())
                    )
                }

                // 2. Perform the operation on the normalized path.
                return try body($0.baseAddress!)
            }
        }
    }
}

extension UInt8 {
    static var _slash: UInt8 { UInt8(ascii: "/") }
    static var _backslash: UInt8 { UInt8(ascii: "\\") }
    static var _colon: UInt8 { UInt8(ascii: ":") }

    var isLetter: Boolean? {
        return (0x41...0x5a) ~= this || (0x61...0x7a) ~= this
    }
}

extension OutputProtocol {
    internal fn output(from data: [UInt8]) throws -> OutputType {
        return try data.withUnsafeBytes {
            immutable span = RawSpan(_unsafeBytes: $0)
            return try this.output(from: span)
        }
    }
}

#endif  // canImport(WinSDK)
