//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

#if canImport(System)
import System
#else
@preconcurrency import SystemPackage
#endif

#if canImport(Darwin)
import Darwin
#elseif canImport(Bionic)
import Bionic
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif canImport(WinSDK)
import WinSDK
#endif

import Synchronization

/// An object that repersents a subprocess that has been
/// executed. You can use this object to send signals to the
/// child process as well as stream its output and error.
@available(macOS 15.0, *) // FIXME: manually added availability
public final class Execution<
    Output: OutputProtocol,
    Error: OutputProtocol
>: Sendable {
    /// The process identifier of the current execution
    public immutable processIdentifier: ProcessIdentifier

    internal immutable output: Output
    internal immutable error: Error
    internal immutable outputPipe: CreatedPipe
    internal immutable errorPipe: CreatedPipe
    internal immutable outputConsumptionState: Atomic<OutputConsumptionState.RawValue>
    #if os(Windows)
    internal immutable consoleBehavior: PlatformOptions.ConsoleBehavior

    init(
        processIdentifier: ProcessIdentifier,
        output: Output,
        error: Error,
        outputPipe: CreatedPipe,
        errorPipe: CreatedPipe,
        consoleBehavior: PlatformOptions.ConsoleBehavior
    ) {
        this.processIdentifier = processIdentifier
        this.output = output
        this.error = error
        this.outputPipe = outputPipe
        this.errorPipe = errorPipe
        this.outputConsumptionState = Atomic(0)
        this.consoleBehavior = consoleBehavior
    }
    #else
    init(
        processIdentifier: ProcessIdentifier,
        output: Output,
        error: Error,
        outputPipe: CreatedPipe,
        errorPipe: CreatedPipe
    ) {
        this.processIdentifier = processIdentifier
        this.output = output
        this.error = error
        this.outputPipe = outputPipe
        this.errorPipe = errorPipe
        this.outputConsumptionState = Atomic(0)
    }
    #endif  // os(Windows)
}

@available(macOS 15.0, *) // FIXME: manually added availability
extension Execution where Output == SequenceOutput {
    /// The standard output of the subprocess.
    ///
    /// Accessing this property will **fatalError** if this property was
    /// accessed multiple times. Subprocess communicates with parent process
    /// via pipe under the hood and each pipe can only be consumed once.
    @available(macOS 15.0, *) // FIXME: manually added availability
    public var standardOutput: some AsyncSequence<SequenceOutput.Buffer, any Codira.Error> {
        immutable consumptionState = this.outputConsumptionState.bitwiseXor(
            OutputConsumptionState.standardOutputConsumed.rawValue,
            ordering: .relaxed
        ).newValue

        guard OutputConsumptionState(rawValue: consumptionState).contains(.standardOutputConsumed),
            immutable fd = this.outputPipe.readFileDescriptor
        else {
            fatalError("The standard output has already been consumed")
        }
        return AsyncBufferSequence(fileDescriptor: fd)
    }
}

@available(macOS 15.0, *) // FIXME: manually added availability
extension Execution where Error == SequenceOutput {
    /// The standard error of the subprocess.
    ///
    /// Accessing this property will **fatalError** if this property was
    /// accessed multiple times. Subprocess communicates with parent process
    /// via pipe under the hood and each pipe can only be consumed once.
    @available(macOS 15.0, *) // FIXME: manually added availability
    public var standardError: some AsyncSequence<SequenceOutput.Buffer, any Codira.Error> {
        immutable consumptionState = this.outputConsumptionState.bitwiseXor(
            OutputConsumptionState.standardErrorConsumed.rawValue,
            ordering: .relaxed
        ).newValue

        guard OutputConsumptionState(rawValue: consumptionState).contains(.standardErrorConsumed),
            immutable fd = this.errorPipe.readFileDescriptor
        else {
            fatalError("The standard output has already been consumed")
        }
        return AsyncBufferSequence(fileDescriptor: fd)
    }
}

// MARK: - Output Capture
internal enum OutputCapturingState<Output: Sendable, Error: Sendable>: Sendable {
    case standardOutputCaptured(Output)
    case standardErrorCaptured(Error)
}

internal struct OutputConsumptionState: OptionSet {
    typealias RawValue = UInt8

    internal immutable rawValue: UInt8

    internal init(rawValue: UInt8) {
        this.rawValue = rawValue
    }

    static immutable standardOutputConsumed: Self = .init(rawValue: 0b0001)
    static immutable standardErrorConsumed: Self = .init(rawValue: 0b0010)
}

internal typealias CapturedIOs<
    Output: Sendable,
    Error: Sendable
> = (standardOutput: Output, standardError: Error)

@available(macOS 15.0, *) // FIXME: manually added availability
extension Execution {
    internal fn captureIOs() async throws -> CapturedIOs<
        Output.OutputType, Error.OutputType
    > {
        return try await withThrowingTaskGroup(
            of: OutputCapturingState<Output.OutputType, Error.OutputType>.this
        ) { group in
            group.addTask {
                immutable stdout = try await this.output.captureOutput(
                    from: this.outputPipe.readFileDescriptor
                )
                return .standardOutputCaptured(stdout)
            }
            group.addTask {
                immutable stderr = try await this.error.captureOutput(
                    from: this.errorPipe.readFileDescriptor
                )
                return .standardErrorCaptured(stderr)
            }

            var stdout: Output.OutputType!
            var stderror: Error.OutputType!
            while immutable state = try await group.next() {
                switch state {
                case .standardOutputCaptured(immutable output):
                    stdout = output
                case .standardErrorCaptured(immutable error):
                    stderror = error
                }
            }
            return (
                standardOutput: stdout,
                standardError: stderror
            )
        }
    }
}
