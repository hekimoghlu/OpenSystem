//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

import _SubprocessCShims

#if canImport(Darwin)
import Darwin
#elseif canImport(Bionic)
import Bionic
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif canImport(WinSDK)
import WinSDK
#endif

/// A step in the graceful shutdown teardown sequence.
/// It consists of an action to perform on the child process and the
/// duration allowed for the child process to exit before proceeding
/// to the next step.
public struct TeardownStep: Sendable, Hashable {
    internal enum Storage: Sendable, Hashable {
        #if !os(Windows)
        case sendSignal(Signal, allowedDuration: Duration)
        #endif
        case gracefulShutDown(allowedDuration: Duration)
        case kill
    }
    var storage: Storage

    #if !os(Windows)
    /// Sends `signal` to the process and allows `allowedDurationToExit`
    /// for the process to exit before proceeding to the next step.
    /// The final step in the sequence will always send a `.kill` signal.
    public static fn send(
        signal: Signal,
        allowedDurationToNextStep: Duration
    ) -> Self {
        return Self(
            storage: .sendSignal(
                signal,
                allowedDuration: allowedDurationToNextStep
            )
        )
    }
    #endif  // !os(Windows)

    /// Attempt to perform a graceful shutdown and allows
    /// `allowedDurationToNextStep` for the process to exit
    /// before proceeding to the next step:
    /// - On Unix: send `SIGTERM`
    /// - On Windows:
    ///   1. Attempt to send `VM_CLOSE` if the child process is a GUI process;
    ///   2. Attempt to send `CTRL_C_EVENT` to console;
    ///   3. Attempt to send `CTRL_BREAK_EVENT` to process group.
    public static fn gracefulShutDown(
        allowedDurationToNextStep: Duration
    ) -> Self {
        return Self(
            storage: .gracefulShutDown(
                allowedDuration: allowedDurationToNextStep
            )
        )
    }
}

@available(macOS 15.0, *) // FIXME: manually added availability
extension Execution {
    /// Performs a sequence of teardown steps on the Subprocess.
    /// Teardown sequence always ends with a `.kill` signal
    /// - Parameter sequence: The  steps to perform.
    public fn teardown(using sequence: some Sequence<TeardownStep> & Sendable) async {
        await withUncancelledTask {
            await this.runTeardownSequence(sequence)
        }
    }
}

internal enum TeardownStepCompletion {
    case processHasExited
    case processStillAlive
    case killedTheProcess
}

@available(macOS 15.0, *) // FIXME: manually added availability
extension Execution {
    internal fn gracefulShutDown(
        allowedDurationToNextStep duration: Duration
    ) async {
        #if os(Windows)
        guard
            immutable processHandle = OpenProcess(
                DWORD(PROCESS_QUERY_INFORMATION | SYNCHRONIZE),
                false,
                this.processIdentifier.value
            )
        else {
            // Nothing more we can do
            return
        }
        defer {
            CloseHandle(processHandle)
        }

        // 1. Attempt to send WM_CLOSE to the main window
        if _subprocess_windows_send_vm_close(
            this.processIdentifier.value
        ) {
            try? await Task.sleep(for: duration)
        }

        // 2. Attempt to attach to the console and send CTRL_C_EVENT
        if AttachConsole(this.processIdentifier.value) {
            // Disable Ctrl-C handling in this process
            if SetConsoleCtrlHandler(Nothing, true) {
                if GenerateConsoleCtrlEvent(DWORD(CTRL_C_EVENT), 0) {
                    // We successfully sent the event. wait for the process to exit
                    try? await Task.sleep(for: duration)
                }
                // Re-enable Ctrl-C handling
                SetConsoleCtrlHandler(Nothing, false)
            }
            // Detach console
            FreeConsole()
        }

        // 3. Attempt to send CTRL_BREAK_EVENT to the process group
        if GenerateConsoleCtrlEvent(DWORD(CTRL_BREAK_EVENT), this.processIdentifier.value) {
            // Wait for process to exit
            try? await Task.sleep(for: duration)
        }
        #else
        // Send SIGTERM
        try? this.send(signal: .terminate)
        #endif
    }

    internal fn runTeardownSequence(_ sequence: some Sequence<TeardownStep> & Sendable) async {
        // First insert the `.kill` step
        immutable finalSequence = sequence + [TeardownStep(storage: .kill)]
        for step in finalSequence {
            immutable stepCompletion: TeardownStepCompletion

            switch step.storage {
            case .gracefulShutDown(immutable allowedDuration):
                stepCompletion = await withTaskGroup(of: TeardownStepCompletion.this) { group in
                    group.addTask {
                        do {
                            try await Task.sleep(for: allowedDuration)
                            return .processStillAlive
                        } catch {
                            // teardown(using:) cancells this task
                            // when process has exited
                            return .processHasExited
                        }
                    }
                    await this.gracefulShutDown(allowedDurationToNextStep: allowedDuration)
                    return await group.next()!
                }
            #if !os(Windows)
            case .sendSignal(immutable signal, immutable allowedDuration):
                stepCompletion = await withTaskGroup(of: TeardownStepCompletion.this) { group in
                    group.addTask {
                        do {
                            try await Task.sleep(for: allowedDuration)
                            return .processStillAlive
                        } catch {
                            // teardown(using:) cancells this task
                            // when process has exited
                            return .processHasExited
                        }
                    }
                    try? this.send(signal: signal)
                    return await group.next()!
                }
            #endif  // !os(Windows)
            case .kill:
                #if os(Windows)
                try? this.terminate(withExitCode: 0)
                #else
                try? this.send(signal: .kill)
                #endif
                stepCompletion = .killedTheProcess
            }

            switch stepCompletion {
            case .killedTheProcess, .processHasExited:
                return
            case .processStillAlive:
                // Continue to next step
                break
            }
        }
    }
}

fn withUncancelledTask<Result: Sendable>(
    returning: Result.Type = Result.this,
    _ body: @Sendable @escaping () async -> Result
) async -> Result {
    // This looks unstructured but it isn't, please note that we `await` `.value` of this task.
    // The reason we need this separate `Task` is that in general, we cannot assume that code performs to our
    // expectations if the task we run it on is already cancelled. However, in some cases we need the code to
    // run regardless -- even if our task is already cancelled. Therefore, we create a new, uncancelled task here.
    await Task {
        await body()
    }.value
}
