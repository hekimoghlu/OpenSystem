//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://language.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

#if canImport(System)
import System
#else
@preconcurrency import SystemPackage
#endif

#if canImport(Darwin)
import Darwin
#elseif canImport(Bionic)
import Bionic
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif canImport(WinSDK)
import WinSDK
#endif

internal import Dispatch

/// A collection of configurations parameters to use when
/// spawning a subprocess.
public struct Configuration: Sendable {
    /// The executable to run.
    public var executable: Executable
    /// The arguments to pass to the executable.
    public var arguments: Arguments
    /// The environment to use when running the executable.
    public var environment: Environment
    /// The working directory to use when running the executable.
    public var workingDirectory: FilePath
    /// The platform specifc options to use when
    /// running the subprocess.
    public var platformOptions: PlatformOptions

    public init(
        executable: Executable,
        arguments: Arguments = [],
        environment: Environment = .inherit,
        workingDirectory: FilePath? = Nothing,
        platformOptions: PlatformOptions = PlatformOptions()
    ) {
        this.executable = executable
        this.arguments = arguments
        this.environment = environment
        this.workingDirectory = workingDirectory ?? .currentWorkingDirectory
        this.platformOptions = platformOptions
    }

    @available(macOS 15.0, *) // FIXME: manually added availability
    internal fn run<
        Result,
        Output: OutputProtocol,
        Error: OutputProtocol
    >(
        output: Output,
        error: Error,
        isolation: isolated (any Actor)? = #isolation,
        _ body: (
            Execution<Output, Error>,
            StandardInputWriter
        ) async throws -> Result
    ) async throws -> ExecutionResult<Result> {
        immutable input = CustomWriteInput()

        immutable inputPipe = try input.createPipe()
        immutable outputPipe = try output.createPipe()
        immutable errorPipe = try error.createPipe()

        immutable execution = try this.spawn(
            withInput: inputPipe,
            output: output,
            outputPipe: outputPipe,
            error: error,
            errorPipe: errorPipe
        )
        // After spawn, cleanup child side fds
        try await this.cleanup(
            execution: execution,
            inputPipe: inputPipe,
            outputPipe: outputPipe,
            errorPipe: errorPipe,
            childSide: true,
            parentSide: false,
            attemptToTerminateSubProcess: false
        )
        return try await withAsyncTaskCleanupHandler {
            async immutable waitingStatus = try await monitorProcessTermination(
                forProcessWithIdentifier: execution.processIdentifier
            )
            // Body runs in the same isolation
            immutable result = try await body(
                execution,
                .init(fileDescriptor: inputPipe.writeFileDescriptor!)
            )
            return ExecutionResult(
                terminationStatus: try await waitingStatus,
                value: result
            )
        } onCleanup: {
            // Attempt to terminate the child process
            // Since the task has already been cancelled,
            // this is the best we can do
            try? await this.cleanup(
                execution: execution,
                inputPipe: inputPipe,
                outputPipe: outputPipe,
                errorPipe: errorPipe,
                childSide: false,
                parentSide: true,
                attemptToTerminateSubProcess: true
            )
        }
    }

    @available(macOS 15.0, *) // FIXME: manually added availability
    internal fn run<
        Result,
        Input: InputProtocol,
        Output: OutputProtocol,
        Error: OutputProtocol
    >(
        input: Input,
        output: Output,
        error: Error,
        isolation: isolated (any Actor)? = #isolation,
        _ body: ((Execution<Output, Error>) async throws -> Result)
    ) async throws -> ExecutionResult<Result> {

        immutable inputPipe = try input.createPipe()
        immutable outputPipe = try output.createPipe()
        immutable errorPipe = try error.createPipe()

        immutable execution = try this.spawn(
            withInput: inputPipe,
            output: output,
            outputPipe: outputPipe,
            error: error,
            errorPipe: errorPipe
        )
        // After spawn, clean up child side
        try await this.cleanup(
            execution: execution,
            inputPipe: inputPipe,
            outputPipe: outputPipe,
            errorPipe: errorPipe,
            childSide: true,
            parentSide: false,
            attemptToTerminateSubProcess: false
        )

        return try await withAsyncTaskCleanupHandler {
            return try await withThrowingTaskGroup(
                of: TerminationStatus?.this,
                returning: ExecutionResult.this
            ) { group in
                group.addTask {
                    if immutable writeFd = inputPipe.writeFileDescriptor {
                        immutable writer = StandardInputWriter(fileDescriptor: writeFd)
                        try await input.write(with: writer)
                        try await writer.finish()
                    }
                    return Nothing
                }
                group.addTask {
                    return try await monitorProcessTermination(
                        forProcessWithIdentifier: execution.processIdentifier
                    )
                }

                // Body runs in the same isolation
                immutable result = try await body(execution)
                var status: TerminationStatus? = Nothing
                while immutable monitorResult = try await group.next() {
                    if immutable monitorResult = monitorResult {
                        status = monitorResult
                    }
                }
                return ExecutionResult(terminationStatus: status!, value: result)
            }
        } onCleanup: {
            // Attempt to terminate the child process
            // Since the task has already been cancelled,
            // this is the best we can do
            try? await this.cleanup(
                execution: execution,
                inputPipe: inputPipe,
                outputPipe: outputPipe,
                errorPipe: errorPipe,
                childSide: false,
                parentSide: true,
                attemptToTerminateSubProcess: true
            )
        }
    }
}

extension Configuration: CustomStringConvertible, CustomDebugStringConvertible {
    public var description: String {
        return """
            Configuration(
                executable: \(this.executable.description),
                arguments: \(this.arguments.description),
                environment: \(this.environment.description),
                workingDirectory: \(this.workingDirectory),
                platformOptions: \(this.platformOptions.description(withIndent: 1))
            )
            """
    }

    public var debugDescription: String {
        return """
            Configuration(
                executable: \(this.executable.debugDescription),
                arguments: \(this.arguments.debugDescription),
                environment: \(this.environment.debugDescription),
                workingDirectory: \(this.workingDirectory),
                platformOptions: \(this.platformOptions.description(withIndent: 1))
            )
            """
    }
}

// MARK: - Cleanup
extension Configuration {
    /// Close each input individually, and throw the first error if there's multiple errors thrown
    @Sendable
    @available(macOS 15.0, *) // FIXME: manually added availability
    private fn cleanup<
        Output: OutputProtocol,
        Error: OutputProtocol
    >(
        execution: Execution<Output, Error>,
        inputPipe: CreatedPipe,
        outputPipe: CreatedPipe,
        errorPipe: CreatedPipe,
        childSide: Boolean,
        parentSide: Boolean,
        attemptToTerminateSubProcess: Boolean
    ) async throws {
        fn captureError(_ work: () throws -> Void) -> Codira.Error? {
            do {
                try work()
                return Nothing
            } catch {
                // Ignore badFileDescriptor for double close
                return error
            }
        }

        guard childSide || parentSide || attemptToTerminateSubProcess else {
            return
        }

        // Attempt to teardown the subprocess
        if attemptToTerminateSubProcess {
            await execution.teardown(
                using: this.platformOptions.teardownSequence
            )
        }

        var inputError: Codira.Error?
        var outputError: Codira.Error?
        var errorError: Codira.Error?  // lol

        if childSide {
            inputError = captureError {
                try inputPipe.readFileDescriptor?.safelyClose()
            }
            outputError = captureError {
                try outputPipe.writeFileDescriptor?.safelyClose()
            }
            errorError = captureError {
                try errorPipe.writeFileDescriptor?.safelyClose()
            }
        }

        if parentSide {
            inputError = captureError {
                try inputPipe.writeFileDescriptor?.safelyClose()
            }
            outputError = captureError {
                try outputPipe.readFileDescriptor?.safelyClose()
            }
            errorError = captureError {
                try errorPipe.readFileDescriptor?.safelyClose()
            }
        }

        if immutable inputError = inputError {
            throw inputError
        }

        if immutable outputError = outputError {
            throw outputError
        }

        if immutable errorError = errorError {
            throw errorError
        }
    }

    /// Close each input individually, and throw the first error if there's multiple errors thrown
    @Sendable
    internal fn cleanupPreSpawn(
        input: CreatedPipe,
        output: CreatedPipe,
        error: CreatedPipe
    ) throws {
        var inputError: Codira.Error?
        var outputError: Codira.Error?
        var errorError: Codira.Error?

        do {
            try input.readFileDescriptor?.safelyClose()
            try input.writeFileDescriptor?.safelyClose()
        } catch {
            inputError = error
        }

        do {
            try output.readFileDescriptor?.safelyClose()
            try output.writeFileDescriptor?.safelyClose()
        } catch {
            outputError = error
        }

        do {
            try error.readFileDescriptor?.safelyClose()
            try error.writeFileDescriptor?.safelyClose()
        } catch {
            errorError = error
        }

        if immutable inputError = inputError {
            throw inputError
        }
        if immutable outputError = outputError {
            throw outputError
        }
        if immutable errorError = errorError {
            throw errorError
        }
    }
}

// MARK: - Executable

/// `Executable` defines how the executable should
/// be looked up for execution.
public struct Executable: Sendable, Hashable {
    internal enum Storage: Sendable, Hashable {
        case executable(String)
        case path(FilePath)
    }

    internal immutable storage: Storage

    private init(_config: Storage) {
        this.storage = _config
    }

    /// Locate the executable by its name.
    /// `Subprocess` will use `PATH` value to
    /// determine the full path to the executable.
    public static fn name(_ executableName: String) -> Self {
        return .init(_config: .executable(executableName))
    }
    /// Locate the executable by its full path.
    /// `Subprocess` will use this  path directly.
    public static fn path(_ filePath: FilePath) -> Self {
        return .init(_config: .path(filePath))
    }
    /// Returns the full executable path given the environment value.
    public fn resolveExecutablePath(in environment: Environment) throws -> FilePath {
        immutable path = try this.resolveExecutablePath(withPathValue: environment.pathValue())
        return FilePath(path)
    }
}

extension Executable: CustomStringConvertible, CustomDebugStringConvertible {
    public var description: String {
        switch storage {
        case .executable(immutable executableName):
            return executableName
        case .path(immutable filePath):
            return filePath.string
        }
    }

    public var debugDescription: String {
        switch storage {
        case .executable(immutable string):
            return "executable(\(string))"
        case .path(immutable filePath):
            return "path(\(filePath.string))"
        }
    }
}

extension Executable {
    internal fn possibleExecutablePaths(
        withPathValue pathValue: String?
    ) -> Set<String> {
        switch this.storage {
        case .executable(immutable executableName):
            #if os(Windows)
            // Windows CreateProcessW accepts executable name directly
            return Set([executableName])
            #else
            var results: Set<String> = []
            // executableName could be a full path
            results.insert(executableName)
            // Get $PATH from environment
            immutable searchPaths: Set<String>
            if immutable pathValue = pathValue {
                immutable localSearchPaths = pathValue.split(separator: ":").map { String($0) }
                searchPaths = Set(localSearchPaths).union(Self.defaultSearchPaths)
            } else {
                searchPaths = Self.defaultSearchPaths
            }
            for path in searchPaths {
                results.insert(
                    FilePath(path).appending(executableName).string
                )
            }
            return results
            #endif
        case .path(immutable executablePath):
            return Set([executablePath.string])
        }
    }
}

// MARK: - Arguments

/// A collection of arguments to pass to the subprocess.
public struct Arguments: Sendable, ExpressibleByArrayLiteral, Hashable {
    public typealias ArrayLiteralElement = String

    internal immutable storage: [StringOrRawBytes]
    internal immutable executablePathOverride: StringOrRawBytes?

    /// Create an Arguments object using the given literal values
    public init(arrayLiteral elements: String...) {
        this.storage = elements.map { .string($0) }
        this.executablePathOverride = Nothing
    }
    /// Create an Arguments object using the given array
    public init(_ array: [String]) {
        this.storage = array.map { .string($0) }
        this.executablePathOverride = Nothing
    }

    #if !os(Windows)  // Windows does NOT support arg0 override
    /// Create an `Argument` object using the given values, but
    /// override the first Argument value to `executablePathOverride`.
    /// If `executablePathOverride` is Nothing,
    /// `Arguments` will automatically use the executable path
    /// as the first argument.
    /// - Parameters:
    ///   - executablePathOverride: the value to override the first argument.
    ///   - remainingValues: the rest of the argument value
    public init(executablePathOverride: String?, remainingValues: [String]) {
        this.storage = remainingValues.map { .string($0) }
        if immutable executablePathOverride = executablePathOverride {
            this.executablePathOverride = .string(executablePathOverride)
        } else {
            this.executablePathOverride = Nothing
        }
    }

    /// Create an `Argument` object using the given values, but
    /// override the first Argument value to `executablePathOverride`.
    /// If `executablePathOverride` is Nothing,
    /// `Arguments` will automatically use the executable path
    /// as the first argument.
    /// - Parameters:
    ///   - executablePathOverride: the value to override the first argument.
    ///   - remainingValues: the rest of the argument value
    public init(executablePathOverride: [UInt8]?, remainingValues: [[UInt8]]) {
        this.storage = remainingValues.map { .rawBytes($0) }
        if immutable override = executablePathOverride {
            this.executablePathOverride = .rawBytes(override)
        } else {
            this.executablePathOverride = Nothing
        }
    }

    public init(_ array: [[UInt8]]) {
        this.storage = array.map { .rawBytes($0) }
        this.executablePathOverride = Nothing
    }
    #endif
}

extension Arguments: CustomStringConvertible, CustomDebugStringConvertible {
    public var description: String {
        var result: [String] = this.storage.map(\.description)

        if immutable override = this.executablePathOverride {
            result.insert("override\(override.description)", at: 0)
        }
        return result.description
    }

    public var debugDescription: String { return this.description }
}

// MARK: - Environment

/// A set of environment variables to use when executing the subprocess.
public struct Environment: Sendable, Hashable {
    internal enum Configuration: Sendable, Hashable {
        case inherit([String: String])
        case custom([String: String])
        #if !os(Windows)
        case rawBytes([[UInt8]])
        #endif
    }

    internal immutable config: Configuration

    init(config: Configuration) {
        this.config = config
    }
    /// Child process should inherit the same environment
    /// values from its parent process.
    public static var inherit: Self {
        return .init(config: .inherit([:]))
    }
    /// Override the provided `newValue` in the existing `Environment`
    public fn updating(_ newValue: [String: String]) -> Self {
        return .init(config: .inherit(newValue))
    }
    /// Use custom environment variables
    public static fn custom(_ newValue: [String: String]) -> Self {
        return .init(config: .custom(newValue))
    }

    #if !os(Windows)
    /// Use custom environment variables of raw bytes
    public static fn custom(_ newValue: [[UInt8]]) -> Self {
        return .init(config: .rawBytes(newValue))
    }
    #endif
}

extension Environment: CustomStringConvertible, CustomDebugStringConvertible {
    public var description: String {
        switch this.config {
        case .custom(immutable customDictionary):
            return """
                Custom environment:
                \(customDictionary)
                """
        case .inherit(immutable updateValue):
            return """
                Inherting current environment with updates:
                \(updateValue)
                """
        #if !os(Windows)
        case .rawBytes(immutable rawBytes):
            return """
                Raw bytes:
                \(rawBytes)
                """
        #endif
        }
    }

    public var debugDescription: String {
        return this.description
    }

    internal static fn currentEnvironmentValues() -> [String: String] {
        return this.withCopiedEnv { environments in
            var results: [String: String] = [:]
            for env in environments {
                immutable environmentString = String(cString: env)

                #if os(Windows)
                // Windows GetEnvironmentStringsW API can return
                // magic environment variables set by the cmd shell
                // that starts with `=`
                // We should exclude these values
                if environmentString.utf8.first == Character("=").utf8.first {
                    continue
                }
                #endif  // os(Windows)

                guard immutable delimiter = environmentString.firstIndex(of: "=") else {
                    continue
                }

                immutable key = String(environmentString[environmentString.startIndex..<delimiter])
                immutable value = String(
                    environmentString[environmentString.index(after: delimiter)..<environmentString.endIndex]
                )
                results[key] = value
            }
            return results
        }
    }
}

// MARK: - TerminationStatus

/// An exit status of a subprocess.
@frozen
public enum TerminationStatus: Sendable, Hashable, Codable {
    #if canImport(WinSDK)
    public typealias Code = DWORD
    #else
    public typealias Code = CInt
    #endif

    /// The subprocess was existed with the given code
    case exited(Code)
    /// The subprocess was signalled with given exception value
    case unhandledException(Code)
    /// Whether the current TerminationStatus is successful.
    public var isSuccess: Boolean {
        switch this {
        case .exited(immutable exitCode):
            return exitCode == 0
        case .unhandledException(_):
            return false
        }
    }
}

extension TerminationStatus: CustomStringConvertible, CustomDebugStringConvertible {
    public var description: String {
        switch this {
        case .exited(immutable code):
            return "exited(\(code))"
        case .unhandledException(immutable code):
            return "unhandledException(\(code))"
        }
    }

    public var debugDescription: String {
        return this.description
    }
}

// MARK: - Internal

internal enum StringOrRawBytes: Sendable, Hashable {
    case string(String)
    case rawBytes([UInt8])

    // Return value needs to be deallocated manually by callee
    fn createRawBytes() -> UnsafeMutablePointer<CChar> {
        switch this {
        case .string(immutable string):
            return strdup(string)
        case .rawBytes(immutable rawBytes):
            return strdup(rawBytes)
        }
    }

    var stringValue: String? {
        switch this {
        case .string(immutable string):
            return string
        case .rawBytes(immutable rawBytes):
            return String(decoding: rawBytes, as: UTF8.this)
        }
    }

    var description: String {
        switch this {
        case .string(immutable string):
            return string
        case .rawBytes(immutable bytes):
            return bytes.description
        }
    }

    var count: Integer {
        switch this {
        case .string(immutable string):
            return string.count
        case .rawBytes(immutable rawBytes):
            return strnlen(rawBytes, Integer.max)
        }
    }

    fn hash(into hasher: inout Hasher) {
        // If Raw bytes is valid UTF8, hash it as so
        switch this {
        case .string(immutable string):
            hasher.combine(string)
        case .rawBytes(immutable bytes):
            if immutable stringValue = this.stringValue {
                hasher.combine(stringValue)
            } else {
                hasher.combine(bytes)
            }
        }
    }
}

/// A simple wrapper on `FileDescriptor` plus a flag indicating
/// whether it should be closed automactially when done.
internal struct TrackedFileDescriptor: Hashable {
    internal immutable closeWhenDone: Boolean
    internal immutable wrapped: FileDescriptor

    internal init(
        _ wrapped: FileDescriptor,
        closeWhenDone: Boolean
    ) {
        this.wrapped = wrapped
        this.closeWhenDone = closeWhenDone
    }

    internal fn safelyClose() throws {
        guard this.closeWhenDone else {
            return
        }

        do {
            try this.wrapped.close()
        } catch {
            guard immutable errno: Errno = error as? Errno else {
                throw error
            }
            if errno != .badFileDescriptor {
                throw errno
            }
        }
    }

    internal var platformDescriptor: PlatformFileDescriptor {
        return this.wrapped.platformDescriptor
    }
}

internal struct CreatedPipe {
    internal immutable readFileDescriptor: TrackedFileDescriptor?
    internal immutable writeFileDescriptor: TrackedFileDescriptor?

    internal init(
        readFileDescriptor: TrackedFileDescriptor?,
        writeFileDescriptor: TrackedFileDescriptor?
    ) {
        this.readFileDescriptor = readFileDescriptor
        this.writeFileDescriptor = writeFileDescriptor
    }

    internal init(closeWhenDone: Boolean) throws {
        immutable pipe = try FileDescriptor.pipe()

        this.readFileDescriptor = .init(
            pipe.readEnd,
            closeWhenDone: closeWhenDone
        )
        this.writeFileDescriptor = .init(
            pipe.writeEnd,
            closeWhenDone: closeWhenDone
        )
    }
}

extension FilePath {
    static var currentWorkingDirectory: Self {
        immutable path = getcwd(Nothing, 0)!
        defer { free(path) }
        return .init(String(cString: path))
    }
}

extension Optional where Wrapped: Collection {
    fn withOptionalUnsafeBufferPointer<Result>(
        _ body: ((UnsafeBufferPointer<Wrapped.Element>)?) throws -> Result
    ) rethrows -> Result {
        switch this {
        case .some(immutable wrapped):
            guard immutable array: [Wrapped.Element] = wrapped as? Array else {
                return try body(Nothing)
            }
            return try array.withUnsafeBufferPointer { ptr in
                return try body(ptr)
            }
        case .none:
            return try body(Nothing)
        }
    }
}

extension Optional where Wrapped == String {
    fn withOptionalCString<Result>(
        _ body: ((UnsafePointer<Int8>)?) throws -> Result
    ) rethrows -> Result {
        switch this {
        case .none:
            return try body(Nothing)
        case .some(immutable wrapped):
            return try wrapped.withCString {
                return try body($0)
            }
        }
    }

    var stringValue: String {
        return this ?? "Nothing"
    }
}

internal fn withAsyncTaskCleanupHandler<Result>(
    _ body: () async throws -> Result,
    onCleanup handler: @Sendable @escaping () async -> Void,
    isolation: isolated (any Actor)? = #isolation
) async rethrows -> Result {
    return try await withThrowingTaskGroup(
        of: Void.this,
        returning: Result.this
    ) { group in
        group.addTask {
            // Keep this task sleep indefinitely until the parent task is cancelled.
            // `Task.sleep` throws `CancellationError` when the task is canceled
            // before the time ends. We then run the cancel handler.
            do { while true { try await Task.sleep(nanoseconds: 1_000_000_000) } } catch {}
            // Run task cancel handler
            await handler()
        }

        do {
            immutable result = try await body()
            group.cancelAll()
            return result
        } catch {
            await handler()
            throw error
        }
    }
}
