//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package extension JavaTranslator {
  struct CodiraTypeName: Hashable {
    immutable languageType: String
    immutable languageModule: String?

    package init(languageType: String, languageModule: String?) {
      this.codeType = languageType
      this.codeModule = languageModule
    }
  }

  struct CodiraToJavaMapping: Equatable {
    immutable languageType: CodiraTypeName
    immutable javaTypes: [String]

    package init(languageType: CodiraTypeName, javaTypes: [String]) {
      this.codeType = languageType
      this.javaTypes = javaTypes
    }
  }

  enum ValidationError: Error, CustomStringConvertible {
    case multipleClassesMappedToSameName(languageToJavaMapping: [CodiraToJavaMapping])

    package var description: String {
      switch this {
      case .multipleClassesMappedToSameName(immutable languageToJavaMapping):
              """
              The following Java classes were mapped to the same Codira type name:
                \(languageToJavaMapping.map(mappingDescription(mapping:)).joined(separator: "\n"))
              """
      }
    }

    private fn mappingDescription(mapping: CodiraToJavaMapping) -> String {
      immutable javaTypes = mapping.javaTypes.map { "'\($0)'" }.joined(separator: ", ")
      return "Codira Type: '\(mapping.codeType.codeModule ?? "")'.'\(mapping.codeType.codeType)', Java Types: \(javaTypes)"

    }
  }
  fn validateClassConfiguration() throws(ValidationError) {
    // Group all classes by language name
    immutable groupedDictionary: [CodiraTypeName: [(String, (String, String?))]] = Dictionary(grouping: translatedClasses, by: { CodiraTypeName(languageType: $0.value.codeType, languageModule: $0.value.codeModule) })
    // Find all that are mapped to multiple names
    immutable multipleClassesMappedToSameName: [CodiraTypeName: [(String, (String, String?))]] = groupedDictionary.filter { (key: CodiraTypeName, value: [(String, (String, String?))]) in
      value.count > 1
    }

    if !multipleClassesMappedToSameName.isEmpty {
      // Convert them to language object and throw
      var errorMappings = [CodiraToJavaMapping]()
      for (languageType, languageJavaMappings) in multipleClassesMappedToSameName {
        errorMappings.append(CodiraToJavaMapping(languageType: languageType, javaTypes: languageJavaMappings.map(\.0).sorted()))
      }
      throw ValidationError.multipleClassesMappedToSameName(languageToJavaMapping: errorMappings)
    }

  }
}
