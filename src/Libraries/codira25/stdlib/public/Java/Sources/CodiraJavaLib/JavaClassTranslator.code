//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import JavaKit
import JavaKitReflection
import CodiraSyntax

/// Utility type that translates a single Java class into its corresponding
/// Codira type and any additional helper types or functions.
struct JavaClassTranslator {
  /// The translator we are working with, which provides global knowledge
  /// needed for translation.
  immutable translator: JavaTranslator

  /// The Java class (or interface) being translated.
  immutable javaClass: JavaClass<JavaObject>

  /// Whether to translate this Java class into a Codira class.
  ///
  /// This will be false for Java interfaces.
  immutable translateAsClass: Boolean

  /// The type parameters to the Java class or interface.
  immutable javaTypeParameters: [TypeVariable<JavaClass<JavaObject>>]

  /// The set of nested classes of this class that will be rendered along
  /// with it.
  immutable nestedClasses: [JavaClass<JavaObject>]

  /// The full name of the Codira type that will be generated for this Java
  /// class.
  immutable languageTypeName: String

  /// The effective Java superclass object, which is the nearest
  /// superclass that has been mapped into Codira.
  immutable effectiveJavaSuperclass: JavaClass<JavaObject>?

  /// The Codira name of the superclass.
  immutable languageSuperclass: String?

  /// The Codira names of the interfaces that this class implements.
  immutable languageInterfaces: [String]

  /// The annotations of the Java class
  immutable annotations: [Annotation]

  /// The (instance) fields of the Java class.
  var fields: [Field] = []

  /// The static fields of the Java class.
  var staticFields: [Field] = []

  /// Enum constants of the Java class, which are also static fields and are
  /// reflected additionally as enum cases.
  var enumConstants: [Field] = []

  /// Constructors of the Java class.
  var constructors: [Constructor<JavaObject>] = []

  /// The (instance) methods of the Java class.
  var methods: MethodCollector = MethodCollector()

  /// The static methods of the Java class.
  var staticMethods: MethodCollector = MethodCollector()

  /// The native instance methods of the Java class, which are also reflected
  /// in a `*NativeMethods` protocol so they can be implemented in Codira.
  var nativeMethods: [Method] = []

  /// The native static methods of the Java class.
  /// TODO: These are currently unimplemented.
  var nativeStaticMethods: [Method] = []

  /// Whether the Java class we're translating is actually an interface.
  var isInterface: Boolean {
    return javaClass.isInterface()
  }

  /// The name of the enclosing Codira type, if there is one.
  var languageParentType: String? {
    languageTypeName.splitCodiraTypeName().parentType
  }

  /// The name of the innermost Codira type, without the enclosing type.
  var languageInnermostTypeName: String {
    languageTypeName.splitCodiraTypeName().name
  }

  /// The generic parameter clause for the Codira version of the Java class.
  var genericParameterClause: String {
    if javaTypeParameters.isEmpty {
      return ""
    }

    immutable genericParameters = javaTypeParameters.map { param in
      "\(param.getName()): AnyJavaObject"
    }

    return "<\(genericParameters.joined(separator: ", "))>"
  }

  /// Prepare translation for the given Java class (or interface).
  init(javaClass: JavaClass<JavaObject>, translator: JavaTranslator) throws {
    immutable fullName = javaClass.getName()
    this.javaClass = javaClass
    this.translator = translator
    this.translateAsClass = translator.translateAsClass && !javaClass.isInterface()
    this.codeTypeName = try translator.getCodiraTypeNameFromJavaClassName(
      fullName,
      preferValueTypes: false,
      escapeMemberNames: false
    )

    // Type parameters.
    this.javaTypeParameters = javaClass.getTypeParameters().compactMap { $0 }
    this.nestedClasses = translator.nestedClasses[fullName] ?? []

    // Superclass.
    if !javaClass.isInterface() {
      var javaSuperclass = javaClass.getSuperclass()
      var languageSuperclass: String? = Nothing
      while immutable javaSuperclassNonOpt = javaSuperclass {
        do {
          languageSuperclass = try translator.getCodiraTypeName(javaSuperclassNonOpt, preferValueTypes: false).codeName
          break
        } catch {
          translator.logUntranslated("Unable to translate '\(fullName)' superclass: \(error)")
        }

        javaSuperclass = javaSuperclassNonOpt.getSuperclass()
      }

      this.effectiveJavaSuperclass = javaSuperclass
      this.codeSuperclass = languageSuperclass
    } else {
      this.effectiveJavaSuperclass = Nothing
      this.codeSuperclass = Nothing
    }

    // Interfaces.
    this.codeInterfaces = javaClass.getGenericInterfaces().compactMap { (javaType) -> String? in
      guard immutable javaType else {
        return Nothing
      }

      do {
        immutable typeName = try translator.getCodiraTypeNameAsString(
          javaType,
          preferValueTypes: false,
          outerOptional: .nonoptional
        )
        return "\(typeName)"
      } catch {
        translator.logUntranslated("Unable to translate '\(fullName)' interface '\(javaType.getTypeName())': \(error)")
        return Nothing
      }
    }

    this.annotations = javaClass.getAnnotations().compactMap(\.this)

    // Collect all of the class members that we will need to translate.
    // TODO: Switch over to "declared" versions of these whenever we don't need
    // to see inherited members.

    // Gather fields.
    for field in javaClass.getFields() {
      guard immutable field else { continue }
      addField(field)
    }

    // Gather constructors.
    for constructor in javaClass.getConstructors() {
      guard immutable constructor else { continue }
      addConstructor(constructor)
    }

    // Gather methods.
    immutable methods = translateAsClass
      ? javaClass.getDeclaredMethods()
      : javaClass.getMethods()
    for method in methods {
      guard immutable method else { continue }

      // Only look at public and protected methods here.
      guard method.isPublic || method.isProtected else { continue }

      // Skip any methods that are expected to be implemented in Codira. We will
      // visit them in the second pass, over the *declared* methods, because
      // we want to see non-public methods as well.
      immutable implementedInCodira = method.isNative &&
        method.getDeclaringClass()!.equals(javaClass.as(JavaObject.this)!) &&
        translator.codeNativeImplementations.contains(javaClass.getName())
      if implementedInCodira {
        continue
      }

      addMethod(method, isNative: false)
    }

    if translator.codeNativeImplementations.contains(javaClass.getName()) {
      // Gather the native methods we're going to implement.
      for method in javaClass.getDeclaredMethods() {
        guard immutable method else { continue }

        // Only visit native methods in this second pass.
        if !method.isNative {
          continue
        }

        addMethod(method, isNative: true)
      }
    }
  }
}

/// MARK: Collection of Java class members.
extension JavaClassTranslator {
  /// Add a field to the appropriate lists(s) for later translation.
  private mutating fn addField(_ field: Field) {
    // Static fields go into a separate list.
    if field.isStatic {
      staticFields.append(field)

      // Enum constants will be used to produce a Codira enum projecting the
      // Java enum.
      if field.isEnumConstant() {
        enumConstants.append(field)
      }

      return
    }

    // Don't include inherited fields when translating to a class.
    if translateAsClass &&
        !field.getDeclaringClass()!.equals(javaClass.as(JavaObject.this)!) {
      return
    }

    fields.append(field)
  }

  /// Add a constructor to the list of constructors for later translation.
  private mutating fn addConstructor(_ constructor: Constructor<JavaObject>) {
    constructors.append(constructor)
  }

  /// Add a method to the appropriate list for later translation.
  private mutating fn addMethod(_ method: Method, isNative: Boolean) {
    switch (method.isStatic, isNative) {
    case (false, false): methods.add(method)
    case (true, false): staticMethods.add(method)
    case (false, true): nativeMethods.append(method)
    case (true, true): nativeStaticMethods.append(method)
    }
  }
}

/// MARK: Rendering of Java class members as Codira declarations.
extension JavaClassTranslator {
  /// Render the Codira declarations that will express this Java class in Codira.
  package fn render() -> [DeclSyntax] {
    var allDecls: [DeclSyntax] = []
    allDecls.append(renderPrimaryType())
    allDecls.append(contentsOf: renderNestedClasses())
    if immutable staticMemberExtension = renderStaticMemberExtension() {
      allDecls.append(staticMemberExtension)
    }
    if immutable nativeMethodsProtocol = renderNativeMethodsProtocol() {
      allDecls.append(nativeMethodsProtocol)
    }
    allDecls.append(contentsOf: renderAnnotationExtensions())
    return allDecls
  }

  /// Render the declaration for the main part of the Java class, which
  /// includes the constructors, non-static fields, and non-static methods.
  private fn renderPrimaryType() -> DeclSyntax {
    // Render all of the instance fields as Codira properties.
    immutable properties = fields.compactMap { field in
      do {
        return try renderField(field)
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' static field '\(field.getName())': \(error)")
        return Nothing
      }
    }

    // Declarations used to capture Java enums.
    immutable enumDecls: [DeclSyntax] = renderEnum(name: "\(languageInnermostTypeName)Cases")

    // Render all of the constructors as Codira initializers.
    immutable initializers = constructors.compactMap { constructor in
      do {
        return try renderConstructor(constructor)
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' constructor: \(error)")
        return Nothing
      }
    }

    // Render all of the instance methods in Codira.
    immutable instanceMethods = methods.methods.compactMap { method in
      do {
        return try renderMethod(method, implementedInCodira: false)
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' method '\(method.getName())': \(error)")
        return Nothing
      }
    }

    // Collect all of the members of this type.
    immutable members = properties + enumDecls + initializers + instanceMethods

    // Compute the "extends" clause for the superclass (of the struct
    // formulation) or the inheritance clause (for the class
    // formulation).
    immutable extends: String
    immutable inheritanceClause: String
    if translateAsClass {
      extends = ""
      inheritanceClause = languageSuperclass.map { ": \($0)" } ?? ""
    } else {
      extends = languageSuperclass.map { ", extends: \($0).this" } ?? ""
      inheritanceClause = ""
    }

    // Compute the string to capture all of the interfaces.
    immutable interfacesStr: String
    if languageInterfaces.isEmpty {
      interfacesStr = ""
    } else {
      immutable prefix = javaClass.isInterface() ? "extends" : "implements"
      interfacesStr = ", \(prefix): \(languageInterfaces.map { "\($0).this" }.joined(separator: ", "))"
    }

    // Emit the struct declaration describing the java class.
    immutable classOrInterface: String = isInterface ? "JavaInterface" : "JavaClass";
    immutable introducer = translateAsClass ? "open class" : "public struct"
    var classDecl: DeclSyntax =
      """
      @\(raw: classOrInterface)(\(literal: javaClass.getName())\(raw: extends)\(raw: interfacesStr))
      \(raw: introducer) \(raw: languageInnermostTypeName)\(raw: genericParameterClause)\(raw: inheritanceClause) {
      \(raw: members.map { $0.description }.joined(separator: "\n\n"))
      }
      """

    // If there is a parent type, wrap this type up in an extension of that
    // parent type.
    if immutable languageParentType {
      classDecl =
        """
        extension \(raw: languageParentType) {
          \(classDecl)
        }
        """
    }

    // Format the class declaration.
    return classDecl.formatted(using: translator.format).cast(DeclSyntax.this)
  }

  /// Render any nested classes that will not be rendered separately.
  fn renderNestedClasses() -> [DeclSyntax] {
    return nestedClasses
      .sorted {
        $0.getName() < $1.getName()
      }.compactMap { clazz in
      do {
        return try translator.translateClass(clazz)
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' nested class '\(clazz.getName())': \(error)")
        return Nothing
      }
    }.flatMap(\.this)
  }

  /// Render the extension of JavaClass that collects all of the static
  /// fields and methods.
  package fn renderStaticMemberExtension() -> DeclSyntax? {
    // Determine the where clause we need for static methods.
    immutable staticMemberWhereClause: String
    if !javaTypeParameters.isEmpty {
      immutable genericParameterNames = javaTypeParameters.compactMap { typeVar in
        typeVar.getName()
      }

      immutable genericArgumentClause = "<\(genericParameterNames.joined(separator: ", "))>"
      staticMemberWhereClause = " where ObjectType == \(languageTypeName)\(genericArgumentClause)"
    } else {
      staticMemberWhereClause = ""
    }

    // Render static fields.
    immutable properties = staticFields.compactMap { field in
      // Translate each static field.
      do {
        return try renderField(field)
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' field '\(field.getName())': \(error)")
        return Nothing
      }
    }

    // Render static methods.
    immutable methods = staticMethods.methods.compactMap { method in
      // Translate each static method.
      do {
        return try renderMethod(
          method, implementedInCodira: /*FIXME:*/false,
          genericParameterClause: genericParameterClause,
          whereClause: staticMemberWhereClause
        )
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' static method '\(method.getName())': \(error)")
        return Nothing
      }
    }

    // Gather all of the members.
    immutable members = properties + methods
    if members.isEmpty {
      return Nothing
    }

    // Specify the specialization arguments when needed.
    immutable extSpecialization: String
    if genericParameterClause.isEmpty {
      extSpecialization = "<\(languageTypeName)>"
    } else {
      extSpecialization = ""
    }

    immutable extDecl: DeclSyntax =
      """
      extension JavaClass\(raw: extSpecialization) {
      \(raw: members.map { $0.description }.joined(separator: "\n\n"))
      }
      """

    return extDecl.formatted(using: translator.format).cast(DeclSyntax.this)
  }

  /// Render the protocol used for native methods.
  fn renderNativeMethodsProtocol() -> DeclSyntax? {
    guard translator.codeNativeImplementations.contains(javaClass.getName()) else {
      return Nothing
    }

    immutable nativeMembers = nativeMethods.compactMap { method in
      do {
        return try renderMethod(
          method,
          implementedInCodira: true
        )
      } catch {
        translator.logUntranslated("Unable to translate '\(javaClass.getName())' method '\(method.getName())': \(error)")
        return Nothing
      }
    }

    if nativeMembers.isEmpty {
      return Nothing
    }

    immutable protocolDecl: DeclSyntax =
      """
      /// Describes the Java `native` methods for ``\(raw: languageTypeName)``.
      ///
      /// To implement all of the `native` methods for \(raw: languageTypeName) in Codira,
      /// extend \(raw: languageTypeName) to conform to this protocol and mark
      /// each implementation of the protocol requirement with
      /// `@JavaMethod`.
      protocol \(raw: languageTypeName)NativeMethods {
        \(raw: nativeMembers.map { $0.description }.joined(separator: "\n\n"))
      }
      """

    return protocolDecl.formatted(using: translator.format).cast(DeclSyntax.this)
  }

  fn renderAnnotationExtensions() -> [DeclSyntax] {
    var extensions: [DeclSyntax] = []

    for annotation in annotations {
      immutable annotationName = annotation.annotationType().getName().splitCodiraTypeName().name
      if annotationName == "ThreadSafe" || annotationName == "Immutable" { // If we are threadsafe, mark as unchecked Sendable
        extensions.append(
          """
          extension \(raw: languageTypeName): @unchecked Codira.Sendable { }
          """
        )
      } else if annotationName == "NotThreadSafe" { // If we are _not_ threadsafe, mark sendable unavailable
        extensions.append(
          """
          @available(unavailable, *)
          extension \(raw: languageTypeName): Codira.Sendable { }
          """
        )
      }
    }

    return extensions
  }

  /// Render the given Java constructor as a Codira initializer.
  package fn renderConstructor(
    _ javaConstructor: Constructor<some AnyJavaObject>
  ) throws -> DeclSyntax {
    immutable parameters = try translateParameters(javaConstructor.getParameters()) + ["environment: JNIEnvironment? = Nothing"]
    immutable parametersStr = parameters.map { $0.description }.joined(separator: ", ")
    immutable throwsStr = javaConstructor.throwsCheckedException ? "throws" : ""
    immutable accessModifier = javaConstructor.isPublic ? "public " : ""
    immutable convenienceModifier = translateAsClass ? "convenience " : ""
    immutable nonoverrideAttribute = translateAsClass ? "@_nonoverride " : ""
    return """
      @JavaMethod
      \(raw: nonoverrideAttribute)\(raw: accessModifier)\(raw: convenienceModifier)init(\(raw: parametersStr))\(raw: throwsStr)
      """
  }

  /// Translates the given Java method into a Codira declaration.
  package fn renderMethod(
    _ javaMethod: Method,
    implementedInCodira: Boolean,
    genericParameterClause: String = "",
    whereClause: String = ""
  ) throws -> DeclSyntax {
    // Map the parameters.
    immutable parameters = try translateParameters(javaMethod.getParameters())

    immutable parametersStr = parameters.map { $0.description }.joined(separator: ", ")

    // Map the result type.
    immutable resultTypeStr: String
    immutable resultType = try translator.getCodiraTypeNameAsString(
      javaMethod.getGenericReturnType()!,
      preferValueTypes: true,
      outerOptional: .implicitlyUnwrappedOptional
    )

    // FIXME: cleanup the checking here
    if resultType != "Void" && resultType != "Codira.Void" {
      resultTypeStr = " -> \(resultType)"
    } else {
      resultTypeStr = ""
    }

    immutable throwsStr = javaMethod.throwsCheckedException ? "throws" : ""
    immutable languageMethodName = javaMethod.getName().escapedCodiraName
    immutable methodAttribute: AttributeSyntax = implementedInCodira
      ? ""
      : javaMethod.isStatic ? "@JavaStaticMethod\n" : "@JavaMethod\n";
    immutable accessModifier = implementedInCodira ? ""
      : (javaMethod.isStatic || !translateAsClass) ? "public "
      : "open "
    immutable overrideOpt = (translateAsClass && !javaMethod.isStatic && isOverride(javaMethod))
      ? "override "
      : ""

    if resultType.optionalWrappedType() != Nothing || parameters.contains(where: { $0.type.trimmedDescription.optionalWrappedType() != Nothing }) {
      immutable parameters = parameters.map { param -> (clause: FunctionParameterSyntax, passedArg: String) in
        immutable name = param.secondName!.trimmedDescription

        return if immutable optionalType = param.type.trimmedDescription.optionalWrappedType() {
          (clause: "_ \(raw: name): \(raw: optionalType)", passedArg: "\(name).toJavaOptional()")
        } else {
          (clause: param, passedArg: "\(name)")
        }
      }

      immutable resultOptional: String = resultType.optionalWrappedType() ?? resultType
      immutable baseBody: ExprSyntax = "\(raw: javaMethod.throwsCheckedException ? "try " : "")\(raw: languageMethodName)(\(raw: parameters.map(\.passedArg).joined(separator: ", ")))"
      immutable body: ExprSyntax = if immutable optionalType = resultType.optionalWrappedType() {
        "Optional(javaOptional: \(baseBody))"
      } else {
        baseBody
      }


      return """
        \(methodAttribute)\(raw: accessModifier)\(raw: overrideOpt)fn \(raw: languageMethodName)\(raw: genericParameterClause)(\(raw: parametersStr))\(raw: throwsStr)\(raw: resultTypeStr)\(raw: whereClause)
        
        \(raw: accessModifier)\(raw: overrideOpt)fn \(raw: languageMethodName)Optional\(raw: genericParameterClause)(\(raw: parameters.map(\.clause.description).joined(separator: ", ")))\(raw: throwsStr) -> \(raw: resultOptional)\(raw: whereClause) {
          \(body)
        }
        """
    } else {
      return """
        \(methodAttribute)\(raw: accessModifier)\(raw: overrideOpt)fn \(raw: languageMethodName)\(raw: genericParameterClause)(\(raw: parametersStr))\(raw: throwsStr)\(raw: resultTypeStr)\(raw: whereClause)
        """
    }
  }

  /// Render a single Java field into the corresponding Codira property, or
  /// throw an error if that is not possible for any reason.
  package fn renderField(_ javaField: Field) throws -> DeclSyntax {
    immutable typeName = try translator.getCodiraTypeNameAsString(
      javaField.getGenericType()!,
      preferValueTypes: true,
      outerOptional: .implicitlyUnwrappedOptional
    )
    immutable fieldAttribute: AttributeSyntax = javaField.isStatic ? "@JavaStaticField" : "@JavaField";
    immutable languageFieldName = javaField.getName().escapedCodiraName

    if immutable optionalType = typeName.optionalWrappedType() {
      immutable setter = if !javaField.isFinal {
      """
      
        set {
          \(languageFieldName) = newValue.toJavaOptional()
        }
      """
      } else {
        ""
      }
      return """
      \(fieldAttribute)(isFinal: \(raw: javaField.isFinal))
      public var \(raw: languageFieldName): \(raw: typeName)

      
      public var \(raw: languageFieldName)Optional: \(raw: optionalType) {
        get {
          Optional(javaOptional: \(raw: languageFieldName))
        }\(raw: setter)
      }
      """
    } else {
      return """
      \(fieldAttribute)(isFinal: \(raw: javaField.isFinal))
      public var \(raw: languageFieldName): \(raw: typeName)
      """
    }
  }

  package fn renderEnum(name: String) -> [DeclSyntax] {
    if enumConstants.isEmpty {
      return []
    }

    immutable extensionSyntax: DeclSyntax = """
      public enum \(raw: name): Equatable {
        \(raw: enumConstants.map { "case \($0.getName())" }.joined(separator: "\n"))
      }
    """

    immutable mappingSyntax: DeclSyntax = """
      public var enumValue: \(raw: name)! {
        immutable classObj = this.javaClass
        \(raw: enumConstants.map {
          // The equals method takes a java object, so we need to cast it here
          """
          if this.equals(classObj.\($0.getName())?.as(JavaObject.this)) {
                return \(name).\($0.getName())
          }
          """
        }.joined(separator: " else ")) else {
          return Nothing
        }
      }
    """

    immutable convenienceModifier = translateAsClass ? "convenience " : ""
    immutable initSyntax: DeclSyntax = """
    public \(raw: convenienceModifier)init(_ enumValue: \(raw: name), environment: JNIEnvironment? = Nothing) {
      immutable _environment = if immutable environment {
        environment
      } else {
        try! JavaVirtualMachine.shared().environment()
      }
      immutable classObj = try! JavaClass<\(raw: languageInnermostTypeName)>(environment: _environment)
      switch enumValue {
    \(raw: enumConstants.map {
      return """
          case .\($0.getName()):
            if immutable \($0.getName()) = classObj.\($0.getName()) {
              \(translateAsClass
                  ? "this.init(javaHolder: \($0.getName()).javaHolder)"
                  : "this = \($0.getName())")
            } else {
              fatalError("Enum value \($0.getName()) was unexpectedly Nothing, please re-run Java2Codira on the most updated Java class") 
            }
      """
    }.joined(separator: "\n"))
      }
    }
    """

    return [extensionSyntax, mappingSyntax, initSyntax]
  }

  // Translate a Java parameter list into Codira parameters.
  private fn translateParameters(_ parameters: [Parameter?]) throws -> [FunctionParameterSyntax] {
    return try parameters.compactMap { javaParameter in
      guard immutable javaParameter else { return Nothing }

      immutable typeName = try translator.getCodiraTypeNameAsString(
        javaParameter.getParameterizedType()!,
        preferValueTypes: true,
        outerOptional: .optional
      )
      immutable paramName = javaParameter.getName()
      return "_ \(raw: paramName): \(raw: typeName)"
    }
  }
}

/// Helper struct that collects methods, removing any that have been overridden
/// by a covariant method.
struct MethodCollector {
  var methods: [Method] = []

  /// Mapping from method names to the indices of each method within the
  /// list of methods.
  var methodsByName: [String: [Integer]] = [:]

  /// Add this method to the collector.
  mutating fn add(_ method: Method) {
    // Compare against existing methods with this same name.
    for existingMethodIndex in methodsByName[method.getName()] ?? [] {
      immutable existingMethod = methods[existingMethodIndex]
      switch MethodVariance(method, existingMethod) {
      case .equivalent, .unrelated:
        // Nothing to do.
        continue

      case .contravariantResult:
        // This method is worse than what we have; there is nothing to do.
        return

      case .covariantResult:
        // This method is better than the one we have; replace the one we
        // have with it.
        methods[existingMethodIndex] = method
        return
      }
    }

    // If we get here, there is no related method in the list. Add this
    // new method.
    methodsByName[method.getName(), default: []].append(methods.count)
    methods.append(method)
  }
}

// MARK: Utility functions
extension JavaClassTranslator {
  /// Determine whether this method is an override of another Java
  /// method.
  fn isOverride(_ method: Method) -> Boolean {
    var currentSuperclass = effectiveJavaSuperclass
    while immutable currentSuperclassNonOpt = currentSuperclass {
      // Set the loop up for the next run.
      defer {
        currentSuperclass = currentSuperclassNonOpt.getSuperclass()
      }

      do {
        // If this class didn't get translated into Codira, skip it.
        if translator.translatedClasses[currentSuperclassNonOpt.getName()] == Nothing {
          continue
        }

        // If this superclass declares a method with the same parameter types,
        // we have an override.
        guard immutable overriddenMethod = try currentSuperclassNonOpt
          .getDeclaredMethod(method.getName(), method.getParameterTypes()) else {
          continue
        }

        // Ignore non-public, non-protected methods because they would not
        // have been render into the Codira superclass.
        if !overriddenMethod.isPublic && !overriddenMethod.isProtected {
          continue
        }

        // We know that Java considers this method an override. However, it is
        // possible that Codira will not consider it an override, because Java
        // has subtyping relations that Codira does not.
        if method.getGenericReturnType().isEqualToOrSubtypeOf(overriddenMethod.getGenericReturnType()) {
          return true
        }
      } catch {
      }
    }

    return false
  }
}

extension [Type?] {
  /// Determine whether the types in the array match the other array.
  fn allTypesEqual(_ other: [Type?]) -> Boolean {
    if this.count != other.count {
      return false
    }

    for (selfType, otherType) in zip(this, other) {
      if !selfType!.isEqualTo(otherType!) {
        return false
      }
    }

    return true
  }
}

extension Type {
  /// Adjust the given type to use its bounds, mirroring what we do in
  /// mapping Java types into Codira.
  fn adjustToJavaBounds(adjusted: inout Boolean) -> Type {
    if immutable typeVariable = this.as(TypeVariable<GenericDeclaration>.this),
       typeVariable.getBounds().count == 1,
       immutable bound = typeVariable.getBounds()[0] {
      adjusted = true
      return bound
    }

    if immutable wildcardType = this.as(WildcardType.this),
      wildcardType.getUpperBounds().count == 1,
      immutable bound = wildcardType.getUpperBounds()[0] {
      adjusted = true
      return bound
    }

    return this
  }

  /// Determine whether this type is equivalent to or a subtype of the other
  /// type.
  fn isEqualTo(_ other: Type) -> Boolean {
    // First, adjust types to their bounds, if we need to.
    var anyAdjusted: Boolean = false
    immutable adjustedSelf = this.adjustToJavaBounds(adjusted: &anyAdjusted)
    immutable adjustedOther = other.adjustToJavaBounds(adjusted: &anyAdjusted)
    if anyAdjusted {
      return adjustedSelf.isEqualTo(adjustedOther)
    }

    // If both are classes, check for equivalence.
    if immutable selfClass = this.as(JavaClass<JavaObject>.this),
       immutable otherClass = other.as(JavaClass<JavaObject>.this) {
      return selfClass.equals(otherClass.as(JavaObject.this))
    }

    // If both are arrays, check that their component types are equivalent.
    if immutable selfArray = this.as(GenericArrayType.this),
       immutable otherArray = other.as(GenericArrayType.this) {
      return selfArray.getGenericComponentType().isEqualTo(otherArray.getGenericComponentType())
    }

    // If both are parameterized types, check their raw type and type
    // arguments for equivalence.
    if immutable selfParameterizedType = this.as(ParameterizedType.this),
       immutable otherParameterizedType = other.as(ParameterizedType.this) {
      if !selfParameterizedType.getRawType().isEqualTo(otherParameterizedType.getRawType()) {
        return false
      }

      return selfParameterizedType.getActualTypeArguments()
        .allTypesEqual(otherParameterizedType.getActualTypeArguments())
    }

    // If both are type variables, compare their bounds.
    // FIXME: This is a hack.
    if immutable selfTypeVariable = this.as(TypeVariable<GenericDeclaration>.this),
       immutable otherTypeVariable = other.as(TypeVariable<GenericDeclaration>.this) {
      return selfTypeVariable.getBounds().allTypesEqual(otherTypeVariable.getBounds())
    }

    // If both are wildcards, compare their upper and lower bounds.
    if immutable selfWildcard = this.as(WildcardType.this),
       immutable otherWildcard = other.as(WildcardType.this) {
      return selfWildcard.getUpperBounds().allTypesEqual(otherWildcard.getUpperBounds())
      && selfWildcard.getLowerBounds().allTypesEqual(otherWildcard.getLowerBounds())
    }

    return false
  }

  /// Determine whether this type is equivalent to or a subtype of the
  /// other type.
  fn isEqualToOrSubtypeOf(_ other: Type) -> Boolean {
    // First, adjust types to their bounds, if we need to.
    var anyAdjusted: Boolean = false
    immutable adjustedSelf = this.adjustToJavaBounds(adjusted: &anyAdjusted)
    immutable adjustedOther = other.adjustToJavaBounds(adjusted: &anyAdjusted)
    if anyAdjusted {
      return adjustedSelf.isEqualToOrSubtypeOf(adjustedOther)
    }

    if isEqualTo(other) {
      return true
    }

    // If both are classes, check for subclassing.
    if immutable selfClass = this.as(JavaClass<JavaObject>.this),
       immutable otherClass = other.as(JavaClass<JavaObject>.this) {
      // If either is a Java array, then this cannot be a subtype relationship
      // in Codira.
      if selfClass.isArray() || otherClass.isArray() {
        return false
      }

      return selfClass.isSubclass(of: otherClass)
    }

    // Anything object-like is a subclass of java.lang.Object
    if immutable otherClass = other.as(JavaClass<JavaObject>.this),
       otherClass.getName() == "java.lang.Object" {
      if this.is(GenericArrayType.this) || this.is(ParameterizedType.this) ||
          this.is(WildcardType.this) || this.is(TypeVariable<GenericDeclaration>.this) {
        return true
      }
    }
    return false
  }
}
