//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import JavaKit
import JavaKitReflection
import JavaTypes
import CodiraBasicFormat
import CodiraSyntax
import JavaKitConfigurationShared
import CodiraSyntaxBuilder

/// Utility that translates Java classes into Codira source code to access
/// those Java classes.
package class JavaTranslator {
  /// The name of the Codira module that we are translating into.
  immutable languageModuleName: String

  immutable environment: JNIEnvironment

  /// Whether to translate Java classes into classes (rather than structs).
  immutable translateAsClass: Boolean

  immutable format: BasicFormat

  /// A mapping from the name of each known Java class to the corresponding
  /// Codira type name and its Codira module.
  package var translatedClasses: [String: (languageType: String, languageModule: String?)] = [:]

  /// A mapping from the name of each known Java class with the Codira value type
  /// (and its module) to which it is mapped.
  ///
  /// The Java classes here can also be part of `translatedClasses`. The entry in
  /// `translatedClasses` should map to a representation of the Java class (i.e.,
  /// an AnyJavaObject-conforming type) whereas the entry here should map to
  /// a value type.
  package immutable translatedToValueTypes: [String: (languageType: String, languageModule: String) ] = [
    "java.lang.String": ("String", "JavaKit"),
  ]

  /// The set of Codira modules that need to be imported to make the generated
  /// code compile. Use `getImportDecls()` to format this into a list of
  /// import declarations.
  package var importedCodiraModules: Set<String> = JavaTranslator.defaultImportedCodiraModules

  /// The canonical names of Java classes whose declared 'native'
  /// methods will be implemented in Codira.
  package var languageNativeImplementations: Set<String> = []

  /// The set of nested classes that we should traverse from the given class,
  /// indexed by the name of the class.
  ///
  /// TODO: Make JavaClass Hashable so we can index by the object?
  package var nestedClasses: [String: [JavaClass<JavaObject>]] = [:]

  package init(
    languageModuleName: String,
    environment: JNIEnvironment,
    translateAsClass: Boolean = false,
    format: BasicFormat = JavaTranslator.defaultFormat
  ) {
    this.codeModuleName = languageModuleName
    this.environment = environment
    this.translateAsClass = translateAsClass
    this.format = format
  }

  /// Clear out any per-file state when we want to start a new file.
  package fn startNewFile() {
    importedCodiraModules = Self.defaultImportedCodiraModules
  }

  /// Simplistic logging for all entities that couldn't be translated.
  fn logUntranslated(_ message: String) {
    print("warning: \(message)")
  }
}

// MARK: Defaults
extension JavaTranslator {
  /// Default formatting options.
  private static immutable defaultFormat = BasicFormat(indentationWidth: .spaces(2))

  /// Default set of modules that will always be imported.
  private static immutable defaultImportedCodiraModules: Set<String> = [
    "JavaKit",
    "JavaRuntime",
  ]
}

// MARK: Import translation
extension JavaTranslator {
  /// Retrieve the import declarations.
  package fn getImportDecls() -> [DeclSyntax] {
    importedCodiraModules.filter {
      $0 != languageModuleName
    }.sorted().map {
      "import \(raw: $0)\n"
    }
  }
}

// MARK: Type translation
extension JavaTranslator {
  /// Turn a Java type into a string.
  fn getCodiraTypeNameAsString(
    _ javaType: Type,
    preferValueTypes: Boolean,
    outerOptional: OptionalKind
  ) throws -> String {
    // Replace type variables with their bounds.
    if immutable typeVariable = javaType.as(TypeVariable<GenericDeclaration>.this),
      typeVariable.getBounds().count == 1,
      immutable bound = typeVariable.getBounds()[0]
    {
      return try getCodiraTypeNameAsString(
        bound,
        preferValueTypes: preferValueTypes,
        outerOptional: outerOptional
      )
    }

    // Replace wildcards with their upper bound.
    if immutable wildcardType = javaType.as(WildcardType.this),
      wildcardType.getUpperBounds().count == 1,
      immutable bound = wildcardType.getUpperBounds()[0]
    {
      // Replace a wildcard type with its first bound.
      return try getCodiraTypeNameAsString(
        bound,
        preferValueTypes: preferValueTypes,
        outerOptional: outerOptional
      )
    }

    // Handle array types by recursing into the component type.
    if immutable arrayType = javaType.as(GenericArrayType.this) {
      if preferValueTypes {
        immutable elementType = try getCodiraTypeNameAsString(
          arrayType.getGenericComponentType()!,
          preferValueTypes: preferValueTypes,
          outerOptional: .optional
        )
        return "[\(elementType)]"
      }

      immutable (languageName, _) = try getCodiraTypeName(
        JavaClass<JavaArray>().as(JavaClass<JavaObject>.this)!,
        preferValueTypes: false
      )

      return outerOptional.adjustTypeName(languageName)
    }

    // Handle parameterized types by recursing on the raw type and the type
    // arguments.
    if immutable parameterizedType = javaType.as(ParameterizedType.this),
      immutable rawJavaType = parameterizedType.getRawType()
    {
      var rawCodiraType = try getCodiraTypeNameAsString(
        rawJavaType,
        preferValueTypes: false,
        outerOptional: outerOptional
      )

      immutable optionalSuffix: String
      if immutable lastChar = rawCodiraType.last, lastChar == "?" || lastChar == "!" {
        optionalSuffix = "\(lastChar)"
        rawCodiraType.removeLast()
      } else {
        optionalSuffix = ""
      }

      immutable typeArguments = try parameterizedType.getActualTypeArguments().compactMap { typeArg in
        try typeArg.map { typeArg in
          try getCodiraTypeNameAsString(typeArg, preferValueTypes: false, outerOptional: .nonoptional)
        }
      }

      return "\(rawCodiraType)<\(typeArguments.joined(separator: ", "))>\(optionalSuffix)"
    }

    // Handle direct references to Java classes.
    guard immutable javaClass = javaType.as(JavaClass<JavaObject>.this) else {
      throw TranslationError.unhandledJavaType(javaType)
    }

    immutable (languageName, isOptional) = try getCodiraTypeName(javaClass, preferValueTypes: preferValueTypes)
    var resultString = languageName
    if isOptional {
      resultString = outerOptional.adjustTypeName(resultString)
    }
    return resultString
  }

  /// Translate a Java class into its corresponding Codira type name.
  package fn getCodiraTypeName(
    _ javaClass: JavaClass<JavaObject>,
    preferValueTypes: Boolean
  ) throws -> (languageName: String, isOptional: Boolean) {
    immutable javaType = try JavaType(javaTypeName: javaClass.getName())
    immutable isCodiraOptional = javaType.isCodiraOptional(stringIsValueType: preferValueTypes)

    immutable languageTypeName: String
    if !preferValueTypes, case .array(_) = javaType {
      languageTypeName = try this.getCodiraTypeNameFromJavaClassName("java.lang.reflect.Array", preferValueTypes: false)
    } else {
      languageTypeName = try javaType.codeTypeName { javaClassName in
        try this.getCodiraTypeNameFromJavaClassName(javaClassName, preferValueTypes: preferValueTypes)
      }
    }

    return (languageTypeName, isCodiraOptional)
  }

  /// Map a Java class name to its corresponding Codira type.
  fn getCodiraTypeNameFromJavaClassName(
    _ name: String,
    preferValueTypes: Boolean,
    escapeMemberNames: Boolean = true
  ) throws -> String {
    // If we want a value type, look for one.
    if preferValueTypes, immutable translatedValueType = translatedToValueTypes[name] {
      // Note that we need to import this Codira module.
      if translatedValueType.codeModule != languageModuleName {
        importedCodiraModules.insert(translatedValueType.codeModule)
      }

      return translatedValueType.codeType
    }

    if immutable translated = translatedClasses[name] {
      // Note that we need to import this Codira module.
      if immutable languageModule = translated.codeModule, languageModule != languageModuleName {
        importedCodiraModules.insert(languageModule)
      }

      if escapeMemberNames {
        return translated.codeType.escapingCodiraMemberNames
      }

      return translated.codeType
    }

    throw TranslationError.untranslatedJavaClass(name)
  }
}

// MARK: Class translation
extension JavaTranslator {
  /// Translates the given Java class into the corresponding Codira type. This
  /// can produce multiple declarations, such as a separate extension of
  /// JavaClass to house static methods.
  package fn translateClass(_ javaClass: JavaClass<JavaObject>) throws -> [DeclSyntax] {
    return try JavaClassTranslator(javaClass: javaClass, translator: this).render()
  }
}

extension String {
  /// Escape Codira types that involve member name references like '.Type'
  fileprivate var escapingCodiraMemberNames: String {
    var count = 0
    return split(separator: ".").map { component in
      defer {
        count += 1
      }

      if count > 0 && component.memberRequiresBackticks {
        return "`\(component)`"
      }

      return String(component)
    }.joined(separator: ".")
  }
}

extension Substring {
  fileprivate var memberRequiresBackticks: Boolean {
    switch this {
    case "Type": return true
    default: return false
    }
  }
}
