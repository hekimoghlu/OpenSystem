diff --git a/ncurses/ncurses/tinfo/alloc_entry.c b/ncurses/ncurses/tinfo/alloc_entry.c
index 4638e99..6c1af12 100644
--- a/ncurses/ncurses/tinfo/alloc_entry.c
+++ b/ncurses/ncurses/tinfo/alloc_entry.c
@@ -53,8 +53,6 @@ MODULE_ID("$Id: alloc_entry.c,v 1.48 2008/08/16 16:25:31 tom Exp $")
 #define ABSENT_OFFSET    -1
 #define CANCELLED_OFFSET -2
 
-#define MAX_STRTAB	4096	/* documented maximum entry size */
-
 static char *stringbuf;		/* buffer for string capabilities */
 static size_t next_free;	/* next free character in stringbuf */
 
@@ -72,7 +70,7 @@ _nc_init_entry(TERMTYPE *const tp)
 #endif
 
     if (stringbuf == 0)
-	stringbuf = (char *) malloc(MAX_STRTAB);
+	stringbuf = (char *) malloc(MAX_ENTRY_SIZE);
 
 #if NCURSES_XNAMES
     tp->num_Booleans = BOOLCOUNT;
@@ -126,10 +124,10 @@ _nc_save_str(const char *const string)
 	 * Cheat a little by making an empty string point to the end of the
 	 * previous string.
 	 */
-	if (next_free < MAX_STRTAB) {
+	if (next_free < MAX_ENTRY_SIZE) {
 	    result = (stringbuf + next_free - 1);
 	}
-    } else if (next_free + len < MAX_STRTAB) {
+    } else if (next_free + len < MAX_ENTRY_SIZE) {
 	strcpy(&stringbuf[next_free], string);
 	DEBUG(7, ("Saved string %s", _nc_visbuf(string)));
 	DEBUG(7, ("at location %d", (int) next_free));
diff --git a/ncurses/ncurses/tinfo/read_entry.c b/ncurses/ncurses/tinfo/read_entry.c
index b4ea61c..de887ef 100644
--- a/ncurses/ncurses/tinfo/read_entry.c
+++ b/ncurses/ncurses/tinfo/read_entry.c
@@ -67,6 +67,7 @@ convert_strings(char *buf, char **Strings, int count, int size, char *table)
 {
     int i;
     char *p;
+    bool corrupt = FALSE;
 
     for (i = 0; i < count; i++) {
 	if (IS_NEG1(buf + 2 * i)) {
@@ -76,8 +77,20 @@ convert_strings(char *buf, char **Strings, int count, int size, char *table)
 	} else if ((int) LOW_MSB(buf + 2 * i) > size) {
 	    Strings[i] = ABSENT_STRING;
 	} else {
-	    Strings[i] = (LOW_MSB(buf + 2 * i) + table);
-	    TR(TRACE_DATABASE, ("Strings[%d] = %s", i, _nc_visbuf(Strings[i])));
+	    int nn = LOW_MSB(buf + 2 * i);
+	    if (nn >= 0 && nn < size) {
+		Strings[i] = (nn + table);
+		TR(TRACE_DATABASE, ("Strings[%d] = %s", i,
+				    _nc_visbuf(Strings[i])));
+	    } else {
+		if (!corrupt) {
+		    corrupt = TRUE;
+		    TR(TRACE_DATABASE,
+		       ("ignore out-of-range index %d to Strings[]", nn));
+		    _nc_warning("corrupt data found in convert_strings");
+		}
+		Strings[i] = ABSENT_STRING;
+	    }
 	}
 
 	/* make sure all strings are NUL terminated */
