# German translation for gtkmm-documentation.
# Copyright (C) 2010 gtkmm-documentation's COPYRIGHT HOLDER
# This file is distributed under the same license as the gtkmm-documentation package.
# Mario Blättermann <mario.blaettermann@gmail.com>, 2010-2012, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: gtkmm-documentation master\n"
"POT-Creation-Date: 2014-04-03 21:30+0000\n"
"PO-Revision-Date: 2017-10-24 11:11+0200\n"
"Last-Translator: Mario Blättermann <mario.blaettermann@gmail.com>\n"
"Language-Team: German <gnome-de@gnome.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 2.0.3\n"

#: C/gtkmm-tutorial-in.xml:34(title)
msgid "Programming with <application>gtkmm</application> 3"
msgstr "Programmierung mit <application>gtkmm</application> 3"

#: C/gtkmm-tutorial-in.xml:38(firstname)
msgid "Murray"
msgstr "Murray"

#: C/gtkmm-tutorial-in.xml:39(surname)
msgid "Cumming"
msgstr "Cumming"

#: C/gtkmm-tutorial-in.xml:42(firstname)
msgid "Bernhard"
msgstr "Bernhard"

#: C/gtkmm-tutorial-in.xml:43(surname)
msgid "Rieder"
msgstr "Rieder"

#: C/gtkmm-tutorial-in.xml:44(contrib)
msgid "Chapter on \"Timeouts\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:47(firstname)
msgid "Jonathon"
msgstr "Jonathon"

#: C/gtkmm-tutorial-in.xml:48(surname)
msgid "Jongsma"
msgstr "Jongsma"

#: C/gtkmm-tutorial-in.xml:49(contrib)
msgid "Chapter on \"Drawing with Cairo\"."
msgstr "Kapitel zu »Zeichnen mit Cairo«"

#: C/gtkmm-tutorial-in.xml:50(contrib)
msgid "Chapter on \"Working with gtkmm's Source Code\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:51(contrib)
msgid "Chapter on \"Recent Files\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:54(firstname)
msgid "Ole"
msgstr "Ole"

#: C/gtkmm-tutorial-in.xml:55(surname)
msgid "Laursen"
msgstr "Laursen"

#: C/gtkmm-tutorial-in.xml:56(contrib) C/gtkmm-tutorial-in.xml:62(contrib)
msgid "Parts of chapter on \"Internationalization\"."
msgstr "Teile des Kapitels zur »Internationalisierung«"

#: C/gtkmm-tutorial-in.xml:59(firstname)
msgid "Marko"
msgstr "Marko"

#: C/gtkmm-tutorial-in.xml:60(surname)
msgid "Anastasov"
msgstr "Anastasov"

#: C/gtkmm-tutorial-in.xml:61(contrib)
msgid "Chapter on \"Printing\"."
msgstr "Kapitel zum »Drucken«."

#: C/gtkmm-tutorial-in.xml:65(firstname)
msgid "Daniel"
msgstr "Daniel"

#: C/gtkmm-tutorial-in.xml:66(surname)
msgid "Elstner"
msgstr "Elstner"

#: C/gtkmm-tutorial-in.xml:67(contrib)
msgid "Section \"Build Structure\" of chapter on \"Wrapping C Libraries with gmmproc\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:71(firstname)
msgid "Chris"
msgstr "Chris"

#: C/gtkmm-tutorial-in.xml:72(surname)
msgid "Vine"
msgstr "Vine"

#: C/gtkmm-tutorial-in.xml:73(contrib)
msgid "Chapter on \"Multi-threaded programs\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:76(firstname)
msgid "David"
msgstr "David"

#: C/gtkmm-tutorial-in.xml:77(surname)
msgid "King"
msgstr "King"

#: C/gtkmm-tutorial-in.xml:78(contrib)
msgid "Section on Gtk::Grid."
msgstr "Abschnitt zu Gtk::Grid."

#: C/gtkmm-tutorial-in.xml:81(firstname)
msgid "Pedro"
msgstr "Pedro"

#: C/gtkmm-tutorial-in.xml:82(surname)
msgid "Ferreira"
msgstr "Ferreira"

#: C/gtkmm-tutorial-in.xml:83(contrib)
msgid "Chapter on Keyboard Events."
msgstr "Kapitel zu Tastaturereignissen."

#: C/gtkmm-tutorial-in.xml:86(firstname)
msgid "Kjell"
msgstr "Kjell"

#: C/gtkmm-tutorial-in.xml:87(surname)
msgid "Ahlstedt"
msgstr "Ahlstedt"

#: C/gtkmm-tutorial-in.xml:88(contrib)
msgid "Parts of the update from gtkmm 2 to gtkmm 3."
msgstr "Teile der Aktualisierung von gtkmm 2 auf gtkmm 3."

#. This text is copied from the introduction.
#: C/gtkmm-tutorial-in.xml:95(para)
msgid ""
"This book explains key concepts of the <application>gtkmm</application> C++ API for creating user interfaces. It also introduces the main user "
"interface elements (\"widgets\")."
msgstr ""

#: C/gtkmm-tutorial-in.xml:101(year)
msgid "2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010"
msgstr "2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010"

#: C/gtkmm-tutorial-in.xml:102(holder)
msgid "Murray Cumming"
msgstr "Murray Cumming"

#: C/gtkmm-tutorial-in.xml:106(para)
msgid ""
"Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any "
"later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You may "
"obtain a copy of the GNU Free Documentation License from the Free Software Foundation by visiting their Web site or by writing to: Free "
"Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."
msgstr ""
"Das vorliegende Dokument kann gemäß den Bedingungen der GNU Free Documentation License (GFDL), Version 1.2 oder jeder späteren, von der Free "
"Software Foundation veröffentlichten Version ohne unveränderbare Abschnitte sowie ohne Texte auf dem vorderen und hinteren Buchdeckel kopiert, "
"verteilt und/oder modifiziert werden. Eine Kopie der GFDL erhalten Sie auf der Webseite der Free Software Foundation, oder schreiben Sie an: "
"Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."

#: C/gtkmm-tutorial-in.xml:118(title)
msgid "Introduction"
msgstr "Einführung"

#: C/gtkmm-tutorial-in.xml:121(title)
msgid "This book"
msgstr "Dieses Buch"

#: C/gtkmm-tutorial-in.xml:123(para)
msgid ""
"This book explains key concepts of the <application>gtkmm</application> C++ API for creating user interfaces. It also introduces the main user "
"interface elements (\"widgets\"). Although it mentions classes, constructors, and methods, it does not go into great detail. Therefore, for "
"full API information you should follow the links into the reference documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:125(para)
msgid "This book assumes a good understanding of C++, and how to create C++ programs."
msgstr "Dieses Buch setzt gutes Verständnis von C++ und in der Erstellung von C++-Programmen voraus."

#: C/gtkmm-tutorial-in.xml:127(para)
msgid ""
"We would very much like to hear of any problems you have learning <application>gtkmm</application> with this document, and would appreciate "
"input regarding improvements. Please see the <link linkend=\"chapter-contributing\">Contributing</link> section for further information."
msgstr ""

#: C/gtkmm-tutorial-in.xml:134(title)
msgid "gtkmm"
msgstr "gtkmm"

#: C/gtkmm-tutorial-in.xml:135(para)
msgid ""
"<application>gtkmm</application> is a C++ wrapper for <ulink url=\"http://www.gtk.org/\">GTK+</ulink>, a library used to create graphical user "
"interfaces. It is licensed using the LGPL license, so you can develop open software, free software, or even commercial non-free software using "
"<application>gtkmm</application> without purchasing licenses."
msgstr ""

#: C/gtkmm-tutorial-in.xml:143(para)
msgid ""
"<application>gtkmm</application> was originally named gtk-- because GTK+ already has a + in the name. However, as -- is not easily indexed by "
"search engines the package generally went by the name <application>gtkmm</application>, and that's what we stuck with."
msgstr ""

#: C/gtkmm-tutorial-in.xml:146(title)
msgid "Why use <application>gtkmm</application> instead of GTK+?"
msgstr "Warum sollte ich <application>gtkmm</application> anstelle von GTK+ verwenden?"

#: C/gtkmm-tutorial-in.xml:147(para)
msgid ""
"<application>gtkmm</application> allows you to write code using normal C++ techniques such as encapsulation, derivation, and polymorphism. As a "
"C++ programmer you probably already realise that this leads to clearer and better organized code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:148(para)
msgid ""
"<application>gtkmm</application> is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. "
"This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration."
msgstr ""

#: C/gtkmm-tutorial-in.xml:149(para)
msgid ""
"Inheritance can be used to derive new widgets. The derivation of new widgets in GTK+ C code is so complicated and error prone that almost no C "
"coders do it. As a C++ developer you know that derivation is an essential Object Orientated technique."
msgstr ""

#: C/gtkmm-tutorial-in.xml:150(para)
msgid ""
"Member instances can be used, simplifying memory management. All GTK+ C widgets are dealt with by use of pointers. As a C++ coder you know that "
"pointers should be avoided where possible."
msgstr ""

#: C/gtkmm-tutorial-in.xml:151(para)
msgid "<application>gtkmm</application> involves less code compared to GTK+, which uses prefixed function names and lots of cast macros."
msgstr ""

#: C/gtkmm-tutorial-in.xml:155(title)
msgid "<application>gtkmm</application> compared to Qt"
msgstr "<application>gtkmm</application> im Vergleich zu Qt"

#: C/gtkmm-tutorial-in.xml:156(para)
msgid "Trolltech's Qt is the closest competition to <application>gtkmm</application>, so it deserves discussion."
msgstr ""

#: C/gtkmm-tutorial-in.xml:158(para)
msgid ""
"<application>gtkmm</application> developers tend to prefer <application>gtkmm</application> to Qt because <application>gtkmm</application> does "
"things in a more C++ way. Qt originates from a time when C++ and the standard library were not standardised or well supported by compilers. It "
"therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech "
"modified the C++ language to provide signals, so that Qt classes cannot be used easily with non-Qt classes. <application>gtkmm</application> "
"was able to use standard C++ to provide signals without changing the C++ language. See the <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"FAQ\">FAQ</ulink> for more detailed differences."
msgstr ""

#: C/gtkmm-tutorial-in.xml:163(title)
msgid "<application>gtkmm</application> is a wrapper"
msgstr "<application>gtkmm</application> ist ein Wrapper"

#: C/gtkmm-tutorial-in.xml:164(para)
msgid ""
"<application>gtkmm</application> is not a native C++ toolkit, but a C++ wrapper of a C toolkit. This separation of interface and implementation "
"has advantages. The <application>gtkmm</application> developers spend most of their time talking about how <application>gtkmm</application> can "
"present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK+ code "
"base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK+ benefits from a broader user base than language-"
"specific toolkits - there are more implementers, more developers, more testers, and more users."
msgstr ""

#: C/gtkmm-tutorial-in.xml:172(title)
msgid "Installation"
msgstr "Installation"

#: C/gtkmm-tutorial-in.xml:174(title)
msgid "Dependencies"
msgstr "Abhängigkeiten"

#: C/gtkmm-tutorial-in.xml:175(para)
msgid "Before attempting to install <application>gtkmm</application> 3.0, you might first need to install these other packages."
msgstr "Bevor Sie versuchen, <application>gtkmm</application> 3.0 zu installieren, müssen Sie zuerst diese anderen Pakete installieren."

#: C/gtkmm-tutorial-in.xml:180(application)
msgid "libsigc++ 2.0"
msgstr "libsigc++ 2.0"

#: C/gtkmm-tutorial-in.xml:181(application)
msgid "GTK+ 3.0"
msgstr "GTK+ 3.0"

#: C/gtkmm-tutorial-in.xml:182(application)
#| msgid "glib"
msgid "glibmm"
msgstr "glibmm"

#: C/gtkmm-tutorial-in.xml:183(application)
msgid "cairomm"
msgstr "cairomm"

#: C/gtkmm-tutorial-in.xml:184(application)
msgid "pangomm"
msgstr "pangomm"

#: C/gtkmm-tutorial-in.xml:185(application)
msgid "atkmm"
msgstr "atkmm"

#: C/gtkmm-tutorial-in.xml:187(para)
msgid "These dependencies have their own dependencies, including the following applications and libraries:"
msgstr "Diese Abhängigkeiten haben wiederum ihre eigenen Abhängigkeiten, wie die folgenden Anwendungen und Bibliotheken:"

#: C/gtkmm-tutorial-in.xml:192(application)
msgid "pkg-config"
msgstr "pkg-config"

#: C/gtkmm-tutorial-in.xml:193(application)
msgid "glib"
msgstr "glib"

#: C/gtkmm-tutorial-in.xml:194(application)
msgid "ATK"
msgstr "ATK"

#: C/gtkmm-tutorial-in.xml:195(application)
msgid "Pango"
msgstr "Pango"

#: C/gtkmm-tutorial-in.xml:196(application)
msgid "cairo"
msgstr "Cairo"

#: C/gtkmm-tutorial-in.xml:197(application)
msgid "gdk-pixbuf"
msgstr "gdk-pixbuf"

#: C/gtkmm-tutorial-in.xml:202(title)
msgid "Unix and Linux"
msgstr "Unix und Linux"

#: C/gtkmm-tutorial-in.xml:205(title)
msgid "Prebuilt Packages"
msgstr "Vorkompilierte Pakete"

#: C/gtkmm-tutorial-in.xml:207(para)
msgid ""
"Recent versions of <application>gtkmm</application> are packaged by nearly every major Linux distribution these days. So, if you use Linux, you "
"can probably get started with <application>gtkmm</application> by installing the package from the official repository for your distribution. "
"Distributions that include <application>gtkmm</application> in their repositories include Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and "
"many others."
msgstr ""

#: C/gtkmm-tutorial-in.xml:215(para)
msgid ""
"The names of the <application>gtkmm</application> packages vary from distribution to distribution (e.g. <application>libgtkmm-3.0-dev</"
"application> on Debian and Ubuntu or <application>gtkmm30-devel</application> on Red Hat Fedora), so check with your distribution's package "
"management program for the correct package name and install it like you would any other package."
msgstr ""

#: C/gtkmm-tutorial-in.xml:223(para)
msgid ""
"The package names will not change when new API/ABI-compatible versions of <application>gtkmm</application> are released. Otherwise they would "
"not be API/ABI-compatible. So don't be surprised, for instance, to find <application>gtkmm</application> 3.8 supplied by Debian's "
"<application>libgtkmm-3.0-dev</application> package."
msgstr ""

#: C/gtkmm-tutorial-in.xml:233(title)
msgid "Installing From Source"
msgstr "Installieren aus den Quellen"

#: C/gtkmm-tutorial-in.xml:235(para)
msgid ""
"If your distribution does not provide a pre-built <application>gtkmm</application> package, or if you want to install a different version than "
"the one provided by your distribution, you can also install <application>gtkmm</application> from source. The source code for "
"<application>gtkmm</application> can be downloaded from <ulink url=\"http://www.gtkmm.org/\"/>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:241(para)
msgid ""
"After you've installed all of the dependencies, download the <application>gtkmm</application> source code, unpack it, and change to the newly "
"created directory. <application>gtkmm</application> can be built and installed with the following sequence of commands:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:246(screen)
#, no-wrap
msgid ""
"\n"
"# ./configure\n"
"# make\n"
"# make install\n"
msgstr ""
"\n"
"# ./configure\n"
"# make\n"
"# make install\n"

#: C/gtkmm-tutorial-in.xml:252(para)
msgid ""
"Remember that on a Unix or Linux operating system, you will probably need to be <literal>root</literal> to install software. The <command>su</"
"command> or <command>sudo</command> command will allow you to enter the <literal>root</literal> password and have <literal>root</literal> "
"status temporarily."
msgstr ""

#: C/gtkmm-tutorial-in.xml:259(para)
msgid ""
"The <filename>configure</filename> script will check to make sure all of the required dependencies are already installed. If you are missing "
"any dependencies, it will exit and display an error."
msgstr ""

#: C/gtkmm-tutorial-in.xml:264(para)
msgid ""
"By default, <application>gtkmm</application> will be installed under the <filename>/usr/local</filename> directory. On some systems you may "
"need to install to a different location. For instance, on Red Hat Linux systems you might use the <literal>--prefix</literal> option with "
"configure, like so: <screen>\n"
"# ./configure --prefix=/usr\n"
"</screen>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:275(para)
msgid ""
"You should be very careful when installing to standard system prefixes such as <filename>/usr</filename>. Linux distributions install software "
"packages to <filename>/usr</filename>, so installing a source package to this prefix could corrupt or conflict with software installed using "
"your distribution's package-management system. Ideally, you should use a separate prefix for all software you install from source."
msgstr ""

#: C/gtkmm-tutorial-in.xml:284(para)
msgid ""
"If you want to help develop <application>gtkmm</application> or experiment with new features, you can also install <application>gtkmm</"
"application> from git. Most users will never need to do this, but if you're interested in helping with <application>gtkmm</application> "
"development, see the <link linkend=\"chapter-working-with-source\">Working with gtkmm's Source Code</link> appendix."
msgstr ""

#: C/gtkmm-tutorial-in.xml:295(title)
msgid "Microsoft Windows"
msgstr "Microsoft Windows"

#: C/gtkmm-tutorial-in.xml:296(para)
msgid ""
"GTK+ and <application>gtkmm</application> were designed to work well with Microsoft Windows, and the developers encourage its use on the win32 "
"platform. However, Windows has no standard installation system for development libraries. Please see the <ulink url=\"https://wiki.gnome.org/"
"Projects/gtkmm/MSWindows\">Windows Installation</ulink> page for Windows-specific installation instructions and notes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:303(title)
msgid "Basics"
msgstr "Grundlagen"

#: C/gtkmm-tutorial-in.xml:305(para)
msgid ""
"This chapter will introduce some of the most important aspects of <application>gtkmm</application> coding. These will be demonstrated with "
"simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information."
msgstr ""

#: C/gtkmm-tutorial-in.xml:308(para)
msgid ""
"Your existing knowledge of C++ will help you with <application>gtkmm</application> as it would with any library. Unless we state otherwise, you "
"can expect <application>gtkmm</application> classes to behave like any other C++ class, and you can expect to use your existing C++ techniques "
"with <application>gtkmm</application> classes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:313(title) C/gtkmm-tutorial-in.xml:3341(title)
msgid "Simple Example"
msgstr "Einfaches Beispiel"

#: C/gtkmm-tutorial-in.xml:315(para)
msgid ""
"To begin our introduction to <application>gtkmm</application>, we'll start with the simplest program possible. This program will create an "
"empty 200 x 200 pixel window."
msgstr ""
"Am Anfang unserer Einführung in <application>gtkmm</application> beginnen wir mit dem einfachsten möglichen Programm. Es erzeugt ein leeres, "
"200 mal 200 Pixel großes Fenster."

#: C/gtkmm-tutorial-in.xml:320(ulink) C/gtkmm-tutorial-in.xml:502(ulink) C/gtkmm-tutorial-in.xml:769(ulink) C/gtkmm-tutorial-in.xml:877(ulink)
#: C/gtkmm-tutorial-in.xml:986(ulink) C/gtkmm-tutorial-in.xml:1108(ulink) C/gtkmm-tutorial-in.xml:1164(ulink) C/gtkmm-tutorial-in.xml:1234(ulink)
#: C/gtkmm-tutorial-in.xml:1281(ulink) C/gtkmm-tutorial-in.xml:1308(ulink) C/gtkmm-tutorial-in.xml:1333(ulink) C/gtkmm-tutorial-in.xml:1469(ulink)
#: C/gtkmm-tutorial-in.xml:1530(ulink) C/gtkmm-tutorial-in.xml:1554(ulink) C/gtkmm-tutorial-in.xml:1585(ulink) C/gtkmm-tutorial-in.xml:1642(ulink)
#: C/gtkmm-tutorial-in.xml:1682(ulink) C/gtkmm-tutorial-in.xml:1727(ulink) C/gtkmm-tutorial-in.xml:1762(ulink) C/gtkmm-tutorial-in.xml:1801(ulink)
#: C/gtkmm-tutorial-in.xml:1930(ulink) C/gtkmm-tutorial-in.xml:2091(ulink) C/gtkmm-tutorial-in.xml:2132(ulink) C/gtkmm-tutorial-in.xml:2174(ulink)
#: C/gtkmm-tutorial-in.xml:2235(ulink) C/gtkmm-tutorial-in.xml:2275(ulink) C/gtkmm-tutorial-in.xml:2867(ulink) C/gtkmm-tutorial-in.xml:2886(ulink)
#: C/gtkmm-tutorial-in.xml:2905(ulink) C/gtkmm-tutorial-in.xml:2927(ulink) C/gtkmm-tutorial-in.xml:2949(ulink) C/gtkmm-tutorial-in.xml:3022(ulink)
#: C/gtkmm-tutorial-in.xml:3035(ulink) C/gtkmm-tutorial-in.xml:3106(ulink) C/gtkmm-tutorial-in.xml:3119(ulink) C/gtkmm-tutorial-in.xml:3350(ulink)
#: C/gtkmm-tutorial-in.xml:3523(ulink) C/gtkmm-tutorial-in.xml:3536(ulink) C/gtkmm-tutorial-in.xml:3592(ulink) C/gtkmm-tutorial-in.xml:3847(ulink)
#: C/gtkmm-tutorial-in.xml:3909(ulink) C/gtkmm-tutorial-in.xml:3936(ulink) C/gtkmm-tutorial-in.xml:3959(ulink) C/gtkmm-tutorial-in.xml:3983(ulink)
#: C/gtkmm-tutorial-in.xml:4015(ulink) C/gtkmm-tutorial-in.xml:4216(ulink) C/gtkmm-tutorial-in.xml:4306(ulink) C/gtkmm-tutorial-in.xml:4334(ulink)
#: C/gtkmm-tutorial-in.xml:4410(ulink) C/gtkmm-tutorial-in.xml:4482(ulink) C/gtkmm-tutorial-in.xml:4545(ulink) C/gtkmm-tutorial-in.xml:4571(ulink)
#: C/gtkmm-tutorial-in.xml:4786(ulink) C/gtkmm-tutorial-in.xml:4952(ulink) C/gtkmm-tutorial-in.xml:4972(ulink) C/gtkmm-tutorial-in.xml:5346(ulink)
#: C/gtkmm-tutorial-in.xml:5567(ulink) C/gtkmm-tutorial-in.xml:5701(ulink) C/gtkmm-tutorial-in.xml:5825(ulink) C/gtkmm-tutorial-in.xml:5893(ulink)
#: C/gtkmm-tutorial-in.xml:5955(ulink) C/gtkmm-tutorial-in.xml:6052(ulink) C/gtkmm-tutorial-in.xml:6090(ulink) C/gtkmm-tutorial-in.xml:6417(ulink)
#: C/gtkmm-tutorial-in.xml:6485(ulink) C/gtkmm-tutorial-in.xml:7129(ulink) C/gtkmm-tutorial-in.xml:7186(ulink) C/gtkmm-tutorial-in.xml:7442(ulink)
#: C/gtkmm-tutorial-in.xml:8327(ulink)
msgid "Source Code"
msgstr "Quelltext"

#: C/gtkmm-tutorial-in.xml:322(para)
msgid "We will now explain each line of the example"
msgstr "Erklärung der einzelnen Zeilen des Beispiels"

#: C/gtkmm-tutorial-in.xml:323(programlisting)
#, no-wrap
msgid "#include &lt;gtkmm.h&gt;"
msgstr "#include &lt;gtkmm.h&gt;"

#: C/gtkmm-tutorial-in.xml:324(para)
msgid ""
"All <application>gtkmm</application> programs must include certain <application>gtkmm</application> headers; <literal>gtkmm.h</literal> "
"includes the entire <application>gtkmm</application> kit. This is usually not a good idea, because it includes a megabyte or so of headers, but "
"for simple programs, it suffices."
msgstr ""

#: C/gtkmm-tutorial-in.xml:334(programlisting)
#, no-wrap
msgid "Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.examples.base\");"
msgstr "Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.examples.base\");"

#: C/gtkmm-tutorial-in.xml:331(para)
msgid ""
"The next statement: <placeholder-1/> creates a <classname>Gtk::Application</classname> object, stored in a <classname>RefPtr</classname> "
"smartpointer. This is needed in all <application>gtkmm</application> applications. The <methodname>create()</methodname> method for this object "
"initializes <application>gtkmm</application>, and checks the arguments passed to your application on the command line, looking for standard "
"options such as <literal>--display</literal>. It takes these from the argument list, leaving anything it does not recognize for your "
"application to parse or ignore. This ensures that all <application>gtkmm</application> applications accept the same set of standard arguments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:344(para)
msgid "The next two lines of code create a window and set its default (initial) size:"
msgstr "Die nächsten zwei Codezeilen erzeugen ein Fenster und legen dessen (initiale) Standardgröße fest:"

#: C/gtkmm-tutorial-in.xml:347(programlisting)
#, no-wrap
msgid ""
"Gtk::Window window;\n"
"window.set_default_size(200, 200);"
msgstr ""
"Gtk::Window window;\n"
"window.set_default_size(200, 200);"

#: C/gtkmm-tutorial-in.xml:349(para)
msgid ""
"The last line shows the window and enters the <application>gtkmm</application> main processing loop, which will finish when the window is "
"closed. Your <function>main()</function> function will then return with an appropriate success or error code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:354(programlisting)
#, no-wrap
msgid "return app-&gt;run(window);"
msgstr "return app-&gt;run(window);"

#: C/gtkmm-tutorial-in.xml:359(programlisting)
#, no-wrap
msgid "g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`"
msgstr "g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`"

#: C/gtkmm-tutorial-in.xml:356(para)
msgid ""
"After putting the source code in <literal>simple.cc</literal> you can compile the above program with <application>gcc</application> using: "
"<placeholder-1/> Note that you must surround the <literal>pkg-config</literal> invocation with backquotes. Backquotes cause the shell to "
"execute the command inside them, and to use the command's output as part of the command line. Note also that <literal>simple.cc</literal> must "
"come before the <literal>pkg-config</literal> invocation on the command line."
msgstr ""

#: C/gtkmm-tutorial-in.xml:369(title)
msgid "Headers and Linking"
msgstr ""

#: C/gtkmm-tutorial-in.xml:370(para)
msgid ""
"Although we have shown the compilation command for the simple example, you really should use the automake and autoconf tools, as described in "
"\"Autoconf, Automake, Libtool\", by G. V. Vaughan et al. The examples used in this book are included in the <application>gtkmm-documentation</"
"application> package, with appropriate build files, so we won't show the build commands in future. You'll just need to find the appropriate "
"directory and type <literal>make</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:373(para)
msgid ""
"To simplify compilation, we use <literal>pkg-config</literal>, which is present in all (properly installed) <application>gtkmm</application> "
"installations. This program 'knows' what compiler switches are needed to compile programs that use <application>gtkmm</application>. The "
"<literal>--cflags</literal> option causes <literal>pkg-config</literal> to output a list of include directories for the compiler to look in; "
"the <literal>--libs</literal> option requests the list of libraries for the compiler to link with and the directories to find them in. Try "
"running it from your shell-prompt to see the results on your system."
msgstr ""

#: C/gtkmm-tutorial-in.xml:386(programlisting)
#, no-wrap
#| msgid "PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.0.0])"
msgid "PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.8.0])"
msgstr "PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.8.0])"

#: C/gtkmm-tutorial-in.xml:383(para)
msgid ""
"However, this is even simpler when using the <function>PKG_CHECK_MODULES()</function> macro in a standard configure.ac file with autoconf and "
"automake. For instance: <placeholder-1/> This checks for the presence of gtkmm and defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile."
"am files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:389(para)
msgid ""
"gtkmm-3.0 is the name of the current stable API. There was an older API called gtkmm-2-4 which installs in parallel when it is available. There "
"were several versions of gtkmm-2.4, such as gtkmm 2.10 and there are several versions of the gtkmm-3.0 API. Note that the API name does not "
"change for every version because that would be an incompatible API and ABI break. Theoretically, there might be a future gtkmm-4.0 API which "
"would install in parallel with gtkmm-3.0 without affecting existing applications."
msgstr ""

#: C/gtkmm-tutorial-in.xml:392(para)
msgid "Note that if you mention extra modules in addition to gtkmm-3.0, they should be separated by spaces, not commas."
msgstr ""

#: C/gtkmm-tutorial-in.xml:394(para)
msgid ""
"Openismus has more <ulink url=\"http://www.openismus.com/documents/linux/automake/automake.shtml\">basic help with automake and autoconf</"
"ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:401(title) C/gtkmm-tutorial-in.xml:6113(title)
msgid "Widgets"
msgstr "Widgets"

#: C/gtkmm-tutorial-in.xml:402(para)
msgid ""
"<application>gtkmm</application> applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, "
"widgets are called \"controls\". For each widget in your application's windows, there is a C++ object in your application's code. So you just "
"need to call a method of the widget's class to affect the visible widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:404(programlisting)
#, no-wrap
msgid ""
"m_box.pack_start(m_Button1);\n"
"m_box.pack_start(m_Button2);"
msgstr ""
"m_box.pack_start(m_Button1);\n"
"m_box.pack_start(m_Button2);"

#: C/gtkmm-tutorial-in.xml:407(programlisting)
#, no-wrap
msgid "m_frame.add(m_box);"
msgstr "m_frame.add(m_box);"

#: C/gtkmm-tutorial-in.xml:403(para)
msgid ""
"Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container "
"widgets, such as <classname>Gtk::Grid</classname>, are not visible - they exist only to arrange other widgets. Here is some example code that "
"adds 2 <classname>Gtk::Button</classname> widgets to a <classname>Gtk::Box</classname> container widget: <placeholder-1/> and here is how to "
"add the <classname>Gtk::Box</classname>, containing those buttons, to a <classname>Gtk::Frame</classname>, which has a visible frame and title: "
"<placeholder-2/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:409(para)
msgid ""
"Most of the chapters in this book deal with specific widgets. See the <link linkend=\"chapter-container-widgets\">Container Widgets</link> "
"section for more details about adding widgets to container widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:413(para)
msgid ""
"Although you can specify the layout and appearance of windows and widgets with C++ code, you will probably find it more convenient to design "
"your user interfaces with <literal>Glade</literal> and load them at runtime with <literal>Gtk::Builder</literal>. See the <link linkend="
"\"chapter-builder\">Glade and Gtk::Builder</link> chapter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:416(para)
msgid ""
"Although <application>gtkmm</application> widget instances have lifetimes and scopes just like those of other C++ classes, <application>gtkmm</"
"application> has an optional time-saving feature that you will see in some of the examples. <function>Gtk::manage()</function> allows you to "
"say that a child widget is owned by the container into which you place it. This allows you to <function>new</function> the widget, add it to "
"the container and forget about deleting it. You can learn more about <application>gtkmm</application> memory management techniques in the <link "
"linkend=\"chapter-memory\">Memory Management chapter</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:422(title) C/gtkmm-tutorial-in.xml:773(title) C/gtkmm-tutorial-in.xml:4699(title) C/gtkmm-tutorial-in.xml:5001(title)
#: C/gtkmm-tutorial-in.xml:7722(title)
msgid "Signals"
msgstr "Signale"

#: C/gtkmm-tutorial-in.xml:424(para)
msgid ""
"<application>gtkmm</application>, like most GUI toolkits, is <emphasis>event-driven</emphasis>. When an event occurs, such as the press of a "
"mouse button, the appropriate signal will be <emphasis>emitted</emphasis> by the Widget that was pressed. Each Widget has a different set of "
"signals that it can emit. To make a button click result in an action, we set up a <emphasis>signal handler</emphasis> to catch the button's "
"\"clicked\" signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:432(programlisting)
#, no-wrap
msgid ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"
msgstr ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"

#: C/gtkmm-tutorial-in.xml:431(para)
msgid ""
"<application>gtkmm</application> uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's "
"\"clicked\" signal with a signal handler called \"on_button_clicked\": <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:436(para)
msgid "For more detailed information about signals, see the <link linkend=\"chapter-signals\">appendix</link>."
msgstr "Detailliertere Informationen über Signale finden Sie im <link linkend=\"chapter-signals\">Anhang</link>."

#: C/gtkmm-tutorial-in.xml:437(para)
msgid ""
"For information about implementing your own signals rather than just connecting to the existing <application>gtkmm</application> signals, see "
"the <link linkend=\"chapter-custom-signals\">appendix</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:443(title) C/gtkmm-tutorial-in.xml:9842(classname)
msgid "Glib::ustring"
msgstr "Glib::ustring"

#: C/gtkmm-tutorial-in.xml:444(para)
msgid ""
"You might be surprised to learn that <application>gtkmm</application> doesn't use <classname>std::string</classname> in its interfaces. Instead "
"it uses <classname>Glib::ustring</classname>, which is so similar and unobtrusive that you could actually pretend that each <classname>Glib::"
"ustring</classname> is a <classname>std::string</classname> and ignore the rest of this section. But read on if you want to use languages other "
"than English in your application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:445(para)
msgid ""
"std::string uses 8 bit per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese. Although the "
"encodings for these languages have now been specified by the Unicode Consortium, the C and C++ languages do not yet provide any standardised "
"Unicode support. GTK+ and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring. It provides almost exactly "
"the same interface as std::string, along with automatic conversions to and from std::string."
msgstr ""

#: C/gtkmm-tutorial-in.xml:446(para)
msgid ""
"One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. "
"<classname>std::string</classname> will still work for 7-bit ASCII strings. But when you try to localize your application for languages like "
"Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using <classname>Glib::"
"ustring</classname> instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:447(para)
msgid ""
"Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more "
"than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting "
"\"Grüß Gott\" would be \"Gr\\xC3\\xBC\\xC3\\x9F Gott\")."
msgstr ""

#: C/gtkmm-tutorial-in.xml:448(para)
msgid ""
"You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so "
"it's not possible to assume that the next byte is another character. <classname>Glib::ustring</classname> worries about the details of this for "
"you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:450(para)
msgid ""
"Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not "
"result in Unicode executables and libraries which are incompatible with ASCII ones."
msgstr ""

#: C/gtkmm-tutorial-in.xml:452(ulink) C/gtkmm-tutorial-in.xml:753(ulink) C/gtkmm-tutorial-in.xml:851(ulink) C/gtkmm-tutorial-in.xml:866(ulink)
#: C/gtkmm-tutorial-in.xml:969(ulink) C/gtkmm-tutorial-in.xml:1023(ulink) C/gtkmm-tutorial-in.xml:1040(ulink) C/gtkmm-tutorial-in.xml:1085(ulink)
#: C/gtkmm-tutorial-in.xml:1146(ulink) C/gtkmm-tutorial-in.xml:1218(ulink) C/gtkmm-tutorial-in.xml:1264(ulink) C/gtkmm-tutorial-in.xml:1452(ulink)
#: C/gtkmm-tutorial-in.xml:1495(ulink) C/gtkmm-tutorial-in.xml:1543(ulink) C/gtkmm-tutorial-in.xml:1631(ulink) C/gtkmm-tutorial-in.xml:1671(ulink)
#: C/gtkmm-tutorial-in.xml:1712(ulink) C/gtkmm-tutorial-in.xml:1745(ulink) C/gtkmm-tutorial-in.xml:1785(ulink) C/gtkmm-tutorial-in.xml:2021(ulink)
#: C/gtkmm-tutorial-in.xml:2120(ulink) C/gtkmm-tutorial-in.xml:2157(ulink) C/gtkmm-tutorial-in.xml:2224(ulink) C/gtkmm-tutorial-in.xml:2264(ulink)
#: C/gtkmm-tutorial-in.xml:2311(ulink) C/gtkmm-tutorial-in.xml:2327(ulink) C/gtkmm-tutorial-in.xml:2345(ulink) C/gtkmm-tutorial-in.xml:2453(ulink)
#: C/gtkmm-tutorial-in.xml:2968(ulink) C/gtkmm-tutorial-in.xml:3158(ulink) C/gtkmm-tutorial-in.xml:3186(ulink) C/gtkmm-tutorial-in.xml:3215(ulink)
#: C/gtkmm-tutorial-in.xml:3267(ulink) C/gtkmm-tutorial-in.xml:3287(ulink) C/gtkmm-tutorial-in.xml:3335(ulink) C/gtkmm-tutorial-in.xml:3829(ulink)
#: C/gtkmm-tutorial-in.xml:3886(ulink) C/gtkmm-tutorial-in.xml:3897(ulink) C/gtkmm-tutorial-in.xml:3924(ulink) C/gtkmm-tutorial-in.xml:3947(ulink)
#: C/gtkmm-tutorial-in.xml:3971(ulink) C/gtkmm-tutorial-in.xml:4003(ulink) C/gtkmm-tutorial-in.xml:4819(ulink) C/gtkmm-tutorial-in.xml:5091(ulink)
#: C/gtkmm-tutorial-in.xml:5123(ulink) C/gtkmm-tutorial-in.xml:7594(ulink)
msgid "Reference"
msgstr "Referenz"

#: C/gtkmm-tutorial-in.xml:454(para)
msgid ""
"See the <link linkend=\"chapter-internationalization\">Internationalization</link> section for information about providing the UTF-8 string "
"literals."
msgstr ""

#: C/gtkmm-tutorial-in.xml:459(title)
msgid "Intermediate types"
msgstr ""

#: C/gtkmm-tutorial-in.xml:460(para)
msgid ""
"Some API related to gtkmm uses intermediate data containers, such as <classname>Glib::StringArrayHandle</classname>, instead of a specific "
"Standard C++ container such as <classname>std::vector</classname> or <classname>std::list</classname>, though <application>gtkmm</application> "
"itself now uses just <classname>std::vector</classname> since <application>gtkmm</application> 3.0."
msgstr ""

#: C/gtkmm-tutorial-in.xml:463(para)
msgid ""
"<classname>Glib::StringArrayHandle</classname> or <classname>Glib::ArrayHandle&lt;Glib::ustring&gt;</classname>: Use <classname>std::vector&lt;"
"Glib::ustring&gt;</classname>, <classname>std::list&lt;Glib::ustring&gt;</classname>, <type>const char*[]</type>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:464(para)
msgid ""
"<classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>: Use <classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
"list&lt;Gtk::Widget*&gt;</classname>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:465(para)
msgid ""
"<classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>: Use <classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
"list&lt;Gtk::Widget*&gt;</classname>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:461(para)
msgid ""
"You should not declare these types yourself. You should instead use whatever Standard C++ container you prefer. glibmm will do the conversion "
"for you. Here are some of these intermediate types: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:473(title)
msgid "Mixing C and C++ APIs"
msgstr "Mischen der APIs von C und C++"

#: C/gtkmm-tutorial-in.xml:474(para)
msgid ""
"You can use C APIs which do not yet have convenient C++ interfaces. It is generally not a problem to use C APIs from C++, and "
"<application>gtkmm</application> helps by providing access to the underlying C object, and providing an easy way to create a C++ wrapper object "
"from a C object, provided that the C API is also based on the GObject system."
msgstr ""

#: C/gtkmm-tutorial-in.xml:476(para)
msgid ""
"To use a <application>gtkmm</application> instance with a C function that requires a C GObject instance, use the <function>gobj()</function> "
"function to obtain a pointer to the underlying GObject instance. For instance"
msgstr ""

#: C/gtkmm-tutorial-in.xml:479(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Button* button = new Gtk::Button(\"example\");\n"
"gtk_button_do_something_new(button-&gt;gobj());\n"
msgstr ""
"\n"
"Gtk::Button* button = new Gtk::Button(\"example\");\n"
"gtk_button_do_something_new(button-&gt;gobj());\n"

#: C/gtkmm-tutorial-in.xml:485(para)
msgid "To obtain a <application>gtkmm</application> instance from a C GObject instance, use the Glib::wrap() function. For instance"
msgstr ""

#: C/gtkmm-tutorial-in.xml:487(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"
msgstr ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"

#: C/gtkmm-tutorial-in.xml:495(title)
msgid "Hello World in <application>gtkmm</application>"
msgstr "»Hello World« in <application>gtkmm</application>"

#: C/gtkmm-tutorial-in.xml:497(para)
msgid ""
"We've now learned enough to look at a real example. In accordance with an ancient tradition of computer science, we now introduce Hello World, "
"a la <application>gtkmm</application>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:504(para)
msgid "Try to compile and run it before going on. You should see something like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:509(title)
msgid "Hello World"
msgstr "Hello World"

#: C/gtkmm-tutorial-in.xml:515(para)
msgid "Pretty thrilling, eh? Let's examine the code. First, the <classname>HelloWorld</classname> class:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:520(programlisting)
#, no-wrap
msgid ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"\n"
"public:\n"
"  HelloWorld();\n"
"  virtual ~HelloWorld();\n"
"\n"
"protected:\n"
"  //Signal handlers:\n"
"  virtual void on_button_clicked();\n"
"\n"
"  //Member widgets:\n"
"  Gtk::Button m_button;\n"
"};"
msgstr ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"\n"
"public:\n"
"  HelloWorld();\n"
"  virtual ~HelloWorld();\n"
"\n"
"protected:\n"
"  //Signal handlers:\n"
"  virtual void on_button_clicked();\n"
"\n"
"  //Member widgets:\n"
"  Gtk::Button m_button;\n"
"};"

#: C/gtkmm-tutorial-in.xml:535(para)
msgid ""
"This class implements the \"Hello World\" window. It's derived from <classname>Gtk::Window</classname>, and has a single <classname>Gtk::"
"Button</classname> as a member. We've chosen to use the constructor to do all of the initialisation work for the window, including setting up "
"the signals. Here it is, with the comments omitted:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:544(programlisting)
#, no-wrap
msgid ""
"HelloWorld::HelloWorld()\n"
":\n"
"  m_button (\"Hello World\")\n"
"{\n"
"  set_border_width(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  add(m_button);.\n"
"  m_button.show();\n"
"}"
msgstr ""
"HelloWorld::HelloWorld()\n"
":\n"
"  m_button (\"Hello World\")\n"
"{\n"
"  set_border_width(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  add(m_button);.\n"
"  m_button.show();\n"
"}"

#: C/gtkmm-tutorial-in.xml:555(para)
msgid "Notice that we've used an initialiser statement to give the <literal>m_button</literal> object the label \"Hello World\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:560(para)
msgid ""
"Next we call the Window's <methodname>set_border_width()</methodname> method. This sets the amount of space between the sides of the window and "
"the widget it contains."
msgstr ""

#: C/gtkmm-tutorial-in.xml:566(para)
msgid ""
"We then hook up a signal handler to <literal>m_button</literal>'s <literal>clicked</literal> signal. This prints our friendly greeting to "
"<literal>stdout</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:571(para)
msgid ""
"Next, we use the Window's <methodname>add()</methodname> method to put <literal>m_button</literal> in the Window. (<methodname>add()</"
"methodname> comes from <classname>Gtk::Container</classname>, which is described in the chapter on container widgets.) The <methodname>add()</"
"methodname> method places the Widget in the Window, but it doesn't display the widget. <application>gtkmm</application> widgets are always "
"invisible when you create them - to display them, you must call their <methodname>show()</methodname> method, which is what we do in the next "
"line."
msgstr ""

#: C/gtkmm-tutorial-in.xml:581(para)
msgid "Now let's look at our program's <function>main()</function> function. Here it is, without comments:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:586(programlisting)
#, no-wrap
msgid ""
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.example\");\n"
"\n"
"  HelloWorld helloworld;\n"
"  return app-&gt;run(helloworld);\n"
"}"
msgstr ""
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.example\");\n"
"\n"
"  HelloWorld helloworld;\n"
"  return app-&gt;run(helloworld);\n"
"}"

#: C/gtkmm-tutorial-in.xml:594(para)
msgid ""
"First we instantiate an object stored in a <classname>RefPtr</classname> smartpointer called <literal>app</literal>. This is of type "
"<classname>Gtk::Application</classname>. Every <application>gtkmm</application> program must have one of these. We pass our command-line "
"arguments to its create() method. It takes the arguments it wants, and leaves you the rest, as we described earlier."
msgstr ""

#: C/gtkmm-tutorial-in.xml:601(para)
msgid ""
"Next we make an object of our <classname>HelloWorld</classname> class, whose constructor takes no arguments, but it isn't visible yet. When we "
"call <methodname>Gtk::Application::run()</methodname>, giving it the helloworld Window, it shows the Window and starts the <application>gtkmm</"
"application><emphasis>event loop</emphasis>. During the event loop <application>gtkmm</application> idles, waiting for actions from the user, "
"and responding appropriately. When the user closes the Window, run() will return, causing the final line of our main() function be to executed. "
"The application will then finish."
msgstr ""

#: C/gtkmm-tutorial-in.xml:610(title)
msgid "Changes in <application>gtkmm</application> 3"
msgstr "Änderungen in <application>gtkmm</application> 3"

#: C/gtkmm-tutorial-in.xml:612(para)
msgid ""
"<application>gtkmm</application>-3.0 is a new version of the <application>gtkmm</application> API that installs in parallel with the older "
"<application>gtkmm</application>-2.4 API. The last version of the <application>gtkmm</application>-2.4 API was <application>gtkmm</application> "
"2.24. <application>gtkmm</application> 3 has no major fundamental differences to <application>gtkmm</application> 2 but does make several small "
"changes that were not possible while maintaining binary compatibility. If you never used the <application>gtkmm</application>-2.4 API then you "
"can safely ignore this chapter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:614(para)
msgid ""
"<application>gtkmm</application> 3's library is called <literal>libgtkmm-3.0</literal> rather than <literal>libgtkmm-2.4</literal> and installs "
"its headers in a similarly-versioned directory, so your pkg-config check should ask for <literal>gtkmm-3.0</literal> rather than "
"<literal>gtkmm-2.4</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:617(para)
msgid "<application>gtkmm</application> 3 added some new classes:"
msgstr "<application>gtkmm</application> 3 fügt einige neue Klassen hinzu:"

#: C/gtkmm-tutorial-in.xml:620(simpara)
msgid ""
"<classname>Gtk::AppChooser</classname>, <classname>Gtk::AppChooserButton</classname>, <classname>Gtk::AppChooserDialog</classname> allow the "
"user to select an installed application to open a particular type of content."
msgstr ""

#: C/gtkmm-tutorial-in.xml:621(simpara)
msgid ""
"<classname>Gtk::Grid</classname> is a new container widget that will eventually replace <classname>Gtk::Box</classname> and <classname>Gtk::"
"Table</classname>. It arranges its children according to properties of those children rather than its own layout details."
msgstr ""

#: C/gtkmm-tutorial-in.xml:622(simpara)
msgid ""
"<classname>Gtk::Switch</classname> displays On/Off states more explictly than <classname>Gtk::CheckBox</classname>. It may be useful, for "
"instance, when allowing users to activate hardware."
msgstr ""

#: C/gtkmm-tutorial-in.xml:625(para)
msgid ""
"<application>gtkmm</application> 3 also made several small changes to the API, which you will probably encounter when porting code that used "
"<application>gtkmm</application>-2.4. Here is a short list:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:630(simpara)
msgid ""
"<classname>Gtk::CellLayout</classname>, used by <classname>Gtk::IconView</classname>, <classname>Gtk::TreeView::Column</classname> and "
"<classname>Gtk::ComboBox</classname>, now has a <classname>Gtk::CellArea</classname> which can be used to specify more details of how the "
"<classname>CellRenderer</classname>s are arranged and aligned."
msgstr ""

#: C/gtkmm-tutorial-in.xml:632(simpara)
msgid "Gtk::ComboBox now derives from CellLayout, allowing easier layout and alignment of its <classname>Gtk::CellRenderer</classname>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:634(simpara)
msgid ""
"<classname>Gtk::Adjustment</classname> and <classname>IconSet</classname> and <classname>Gdk::Cursor</classname> are now used via "
"<classname>Glib::RefPtr</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:636(simpara)
msgid ""
"<classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>, <classname>Gtk::IconView</classname>, <classname>Gtk::Paned</"
"classname>, <classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</classname>, <classname>Gtk::Scrollbar</classname> and "
"<classname>Gtk::Separator</classname> now derive from <classname>Gtk::Orientable</classname>, allowing their orientation (vertical or "
"horizontal) to be specified without requiring the use of a derived class such as <classname>Gtk::HBox</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:639(simpara)
msgid ""
"<classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, <classname>Gtk::TreeView</classname> and other widgets derive from "
"Scrollable instead of having their own methods such as <methodname>get_vadjustment()</methodname> and instead of having their own "
"set_scroll_adjustments signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:641(simpara)
msgid ""
"<classname>Gtk::Style</classname> and <classname>Gtk::Rc</classname> were removed, replaced by <classname>Gtk::StyleContext</classname>, and "
"<classname>Gtk::StyleProvider</classname>s, such as <classname>Gtk::CssProvider</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:643(simpara)
msgid ""
"Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes that cairomm is used for drawing, via the provided <classname>Cairo::"
"Context</classname> and does not require you to call <methodname>Cairo::Context::clip()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:645(simpara)
msgid ""
"<classname>Gdk::RGBA</classname> replaces <classname>Color</classname>, adding an alpha component for opacity. <classname>Colormap</classname> "
"was removed, along with its awkward use to allocate colors."
msgstr ""

#: C/gtkmm-tutorial-in.xml:647(simpara)
msgid "<classname>Gdk::Pixmap</classname> and <classname>Gdk::Bitmap</classname> were removed in favour of <classname>Gdk::Pixbuf</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:649(simpara)
msgid "<classname>Gdk::Drawable</classname> was removed, with its methods moving into <classname>Gdk::Window</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:651(simpara)
msgid "We now use std::vector in several methods instead of the intermediate *Handle types to make the API clearer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:656(para)
msgid "All deprecated API was removed in <application>gtkmm</application> 3.0, though there will be new deprecations in future versions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:658(para)
msgid ""
"As a first step to porting your source code to <application>gtkmm</application>-3.0 you should probably ensure that your application builds "
"with the deprecated <application>gtkmm</application>-2.4 API disabled, by defining macro such as GTKMM_DISABLE_DEPRECATED. There are some "
"autotools macros that can help with this by defining them optionally at build time. See the <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"PortingToGtkmm3\">gtkmm 3 porting wiki page</ulink> for more details."
msgstr ""

#: C/gtkmm-tutorial-in.xml:663(title)
msgid "Buttons"
msgstr "Knöpfe"

#: C/gtkmm-tutorial-in.xml:665(para)
msgid "<application>gtkmm</application> provides four basic types of buttons:"
msgstr "<application>gtkmm</application> stellt vier grundlegende Knopftypen bereit:"

#: C/gtkmm-tutorial-in.xml:672(term)
msgid "Push-Buttons"
msgstr ""

#: C/gtkmm-tutorial-in.xml:674(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html\"><classname>Gtk::Button</classname></ulink>. Standard buttons, "
"usually marked with a label or picture. Pushing one triggers an action. See the <link linkend=\"sec-pushbuttons\">Button</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:681(term)
msgid "Toggle buttons"
msgstr "Umschaltknöpfe"

#: C/gtkmm-tutorial-in.xml:683(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html\"><classname>Gtk::ToggleButton</classname></ulink>. Unlike "
"a normal Button, which springs back up, a ToggleButton stays down until you press it again. It might be useful as an on/off switch. See the "
"<link linkend=\"sec-toggle-buttons\">ToggleButton</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:691(term)
msgid "Checkboxes"
msgstr "Ankreuzfelder"

#: C/gtkmm-tutorial-in.xml:693(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html\"><classname>Gtk::CheckButton</classname></ulink>. These "
"act like ToggleButtons, but show their state in small squares, with their label at the side. They should be used in most situations which "
"require an on/off setting. See the <link linkend=\"sec-checkboxes\">CheckButton</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:703(term)
msgid "Radio buttons"
msgstr "Radioknöpfe"

#: C/gtkmm-tutorial-in.xml:705(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1RadioButton.html\"><classname>Gtk::RadioButton</classname></ulink>. Named "
"after the station selectors on old car radios, these buttons are used in groups for options which are mutually exclusive. Pressing one causes "
"all the others in its group to turn off. They are similar to CheckBoxes (a small widget with a label at the side), but usually look different. "
"See the <link linkend=\"sec-radio-buttons\">RadioButton</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:719(para)
msgid ""
"Note that, due to GTK+'s theming system, the appearance of these widgets will vary. In the case of checkboxes and radio buttons, they may vary "
"considerably."
msgstr ""

#: C/gtkmm-tutorial-in.xml:726(title)
msgid "Button"
msgstr "Knopf"

#: C/gtkmm-tutorial-in.xml:728(title)
msgid "Constructors"
msgstr "Konstruktoren"

#: C/gtkmm-tutorial-in.xml:730(para)
msgid ""
"There are two ways to create a Button. You can specify a label string in the <classname>Gtk::Button</classname> constructor, or set it later "
"with <methodname>set_label()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:736(para)
msgid ""
"To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify <literal>true</"
"literal> for the optional <literal>mnemonic</literal> parameter. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:738(programlisting)
#, no-wrap
msgid "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"
msgstr "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"

#: C/gtkmm-tutorial-in.xml:740(para)
msgid ""
"Stock items have been recommended for use in buttons. From <application>gtkmm</application>-3.10 they are deprecated. They should not be used "
"in newly-written code. However, the documentation of <ulink url=\"http://developer.gnome.org/gtkmm/unstable/namespaceGtk_1_1Stock.html"
"\">namespace Gtk::Stock</ulink> shows recommended labels and named icons to show in buttons."
msgstr ""

#: C/gtkmm-tutorial-in.xml:747(para)
msgid ""
"<classname>Gtk::Button</classname> is also a container so you could put any other widget, such as a <classname>Gtk::Image</classname> into it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:756(title) C/gtkmm-tutorial-in.xml:868(title) C/gtkmm-tutorial-in.xml:973(title) C/gtkmm-tutorial-in.xml:1091(title)
#: C/gtkmm-tutorial-in.xml:1148(title) C/gtkmm-tutorial-in.xml:1456(title) C/gtkmm-tutorial-in.xml:1521(title) C/gtkmm-tutorial-in.xml:1545(title)
#: C/gtkmm-tutorial-in.xml:1576(title) C/gtkmm-tutorial-in.xml:1633(title) C/gtkmm-tutorial-in.xml:1673(title) C/gtkmm-tutorial-in.xml:1714(title)
#: C/gtkmm-tutorial-in.xml:1748(title) C/gtkmm-tutorial-in.xml:1788(title) C/gtkmm-tutorial-in.xml:2087(title) C/gtkmm-tutorial-in.xml:2123(title)
#: C/gtkmm-tutorial-in.xml:2159(title) C/gtkmm-tutorial-in.xml:2226(title) C/gtkmm-tutorial-in.xml:2266(title) C/gtkmm-tutorial-in.xml:3832(title)
#: C/gtkmm-tutorial-in.xml:3900(title) C/gtkmm-tutorial-in.xml:3927(title) C/gtkmm-tutorial-in.xml:3950(title) C/gtkmm-tutorial-in.xml:3974(title)
#: C/gtkmm-tutorial-in.xml:4006(title) C/gtkmm-tutorial-in.xml:4178(title) C/gtkmm-tutorial-in.xml:4322(title) C/gtkmm-tutorial-in.xml:4397(title)
#: C/gtkmm-tutorial-in.xml:4469(title) C/gtkmm-tutorial-in.xml:4534(title) C/gtkmm-tutorial-in.xml:4776(title) C/gtkmm-tutorial-in.xml:5327(title)
#: C/gtkmm-tutorial-in.xml:5807(title) C/gtkmm-tutorial-in.xml:5856(title) C/gtkmm-tutorial-in.xml:6411(title) C/gtkmm-tutorial-in.xml:6480(title)
#: C/gtkmm-tutorial-in.xml:7116(title) C/gtkmm-tutorial-in.xml:7175(title) C/gtkmm-tutorial-in.xml:7418(title) C/gtkmm-tutorial-in.xml:8321(title)
msgid "Example"
msgstr "Beispiel"

#: C/gtkmm-tutorial-in.xml:758(para)
msgid "This example creates a button with a picture and a label."
msgstr "Dieses Beispiel erzeugt einen Knopf mit einer Grafik und einer Beschriftung."

#: C/gtkmm-tutorial-in.xml:763(title)
msgid "buttons example"
msgstr "Beispiel für Knöpfe"

#: C/gtkmm-tutorial-in.xml:775(para)
msgid ""
"The <classname>Gtk::Button</classname> widget has the following signals, but most of the time you will just handle the <literal>clicked</"
"literal> signal:"
msgstr ""
"Das <classname>Gtk::Button</classname>-Widget gibt folgende Signale aus, wobei Sie jedoch meist nur das <literal>clicked</literal>-Signal "
"verarbeiten müssen:"

#: C/gtkmm-tutorial-in.xml:783(literal)
msgid "pressed"
msgstr "pressed"

#: C/gtkmm-tutorial-in.xml:785(para)
msgid "Emitted when the button is pressed."
msgstr "Wird ausgegeben, wenn der Knopf gedrückt wird."

#: C/gtkmm-tutorial-in.xml:791(literal)
msgid "released"
msgstr "released"

#: C/gtkmm-tutorial-in.xml:793(para)
msgid "Emitted when the button is released."
msgstr "Wird ausgegeben, wenn der Knopf losgelassen wird."

#: C/gtkmm-tutorial-in.xml:799(literal)
msgid "clicked"
msgstr "clicked"

#: C/gtkmm-tutorial-in.xml:801(para)
msgid "Emitted when the button is pressed and released."
msgstr "Wird ausgegeben, wenn der Knopf angeklickt und losgelassen wird."

#: C/gtkmm-tutorial-in.xml:807(literal)
msgid "enter"
msgstr "enter"

#: C/gtkmm-tutorial-in.xml:809(para)
msgid "Emitted when the mouse pointer moves over the button's window."
msgstr "Wird ausgegeben, wenn sich der Mauszeiger über dem Fenster mit dem Knopf befindet."

#: C/gtkmm-tutorial-in.xml:815(literal)
msgid "leave"
msgstr "leave"

#: C/gtkmm-tutorial-in.xml:817(para)
msgid "Emitted when the mouse pointer leaves the button's window."
msgstr "Wird ausgegeben, wenn der Mauszeiger das Fenster mit dem Knopf verlässt."

#: C/gtkmm-tutorial-in.xml:829(title)
msgid "ToggleButton"
msgstr "ToggleButton"

#: C/gtkmm-tutorial-in.xml:831(para)
msgid ""
"<classname>ToggleButton</classname>s are like normal <classname>Button</classname>s, but when clicked they remain activated, or pressed, until "
"clicked again."
msgstr ""

#: C/gtkmm-tutorial-in.xml:833(para)
msgid ""
"To retrieve the state of the <classname>ToggleButton</classname>, you can use the <methodname>get_active()</methodname> method. This returns "
"<literal>true</literal> if the button is \"down\". You can also set the toggle button's state, with <methodname>set_active()</methodname>. Note "
"that, if you do this, and the state actually changes, it causes the \"clicked\" signal to be emitted. This is usually what you want."
msgstr ""

#: C/gtkmm-tutorial-in.xml:840(para)
msgid ""
"You can use the <methodname>toggled()</methodname> method to toggle the button, rather than forcing it to be up or down: This switches the "
"button's state, and causes the <literal>toggled</literal> signal to be emitted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:845(para)
msgid ""
"<classname>Gtk::ToggleButton</classname> is most useful as a base class for the <classname>Gtk::CheckButton</classname> and <classname>Gtk::"
"RadioButton</classname> classes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:856(title) C/gtkmm-tutorial-in.xml:871(title)
msgid "CheckButton"
msgstr "CheckButton"

#: C/gtkmm-tutorial-in.xml:858(para)
msgid ""
"<classname>Gtk::CheckButton</classname> inherits from <classname>Gtk::ToggleButton</classname>. The only real difference between the two is "
"<classname>Gtk::CheckButton</classname>'s appearance. You can check, set, and toggle a checkbox using the same member methods as for "
"<classname>Gtk::ToggleButton</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:883(title) C/gtkmm-tutorial-in.xml:980(title)
msgid "RadioButton"
msgstr "RadioButton"

#: C/gtkmm-tutorial-in.xml:885(para)
msgid ""
"Like checkboxes, radio buttons also inherit from <classname>Gtk::ToggleButton</classname>, but these work in groups, and only one RadioButton "
"in a group can be selected at any one time."
msgstr ""

#: C/gtkmm-tutorial-in.xml:891(title)
msgid "Groups"
msgstr "Gruppen"

#: C/gtkmm-tutorial-in.xml:892(para)
msgid ""
"There are two ways to set up a group of radio buttons. The first way is to create the buttons, and set up their groups afterwards. Only the "
"first two constructors are used. In the following example, we make a new window class called <classname>RadioButtons</classname>, and then put "
"three radio buttons in it:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:900(programlisting)
#, no-wrap
msgid ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"\n"
"protected:\n"
"    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"  : m_rb1(\"button1\"),\n"
"    m_rb2(\"button2\"),\n"
"    m_rb3(\"button3\")\n"
"{\n"
"    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
"    m_rb2.set_group(group);\n"
"    m_rb3.set_group(group);\n"
"}"
msgstr ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"\n"
"protected:\n"
"    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"  : m_rb1(\"button1\"),\n"
"    m_rb2(\"button2\"),\n"
"    m_rb3(\"button3\")\n"
"{\n"
"    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
"    m_rb2.set_group(group);\n"
"    m_rb3.set_group(group);\n"
"}"

#: C/gtkmm-tutorial-in.xml:918(para)
msgid ""
"We told <application>gtkmm</application> to put all three <classname>RadioButton</classname>s in the same group by obtaining the group with "
"<methodname>get_group()</methodname> and using <methodname>set_group()</methodname> to tell the other <classname>RadioButton</classname>s to "
"share that group."
msgstr ""

#: C/gtkmm-tutorial-in.xml:927(programlisting)
#, no-wrap
msgid "m_rb2.set_group(m_rb1.get_group()); //doesn't work"
msgstr "m_rb2.set_group(m_rb1.get_group()); //doesn't work"

#: C/gtkmm-tutorial-in.xml:925(para)
msgid ""
"Note that you can't just do <placeholder-1/> because the group is modified by <methodname>set_group()</methodname> and therefore non-const."
msgstr ""

#: C/gtkmm-tutorial-in.xml:933(para)
msgid "The second way to set up radio buttons is to make a group first, and then add radio buttons to it. Here's an example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:937(programlisting)
#, no-wrap
msgid ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"{\n"
"    Gtk::RadioButton::Group group;\n"
"    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
"      new Gtk::RadioButton(group,\"button1\"));\n"
"    Gtk::RadioButton *m_rb2 = manage(\n"
"      new Gtk::RadioButton(group,\"button2\"));\n"
"      Gtk::RadioButton *m_rb3 = manage(\n"
"        new Gtk::RadioButton(group,\"button3\"));\n"
"}"
msgstr ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"{\n"
"    Gtk::RadioButton::Group group;\n"
"    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
"      new Gtk::RadioButton(group,\"button1\"));\n"
"    Gtk::RadioButton *m_rb2 = manage(\n"
"      new Gtk::RadioButton(group,\"button2\"));\n"
"      Gtk::RadioButton *m_rb3 = manage(\n"
"        new Gtk::RadioButton(group,\"button3\"));\n"
"}"

#: C/gtkmm-tutorial-in.xml:954(para)
msgid ""
"We made a new group by simply declaring a variable, <literal>group</literal>, of type <classname>Gtk::RadioButton::Group</classname>. Then we "
"made three radio buttons, using a constructor to make each of them part of <literal>group</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:962(title) C/gtkmm-tutorial-in.xml:1418(title) C/gtkmm-tutorial-in.xml:4645(title)
msgid "Methods"
msgstr "Methoden"

#: C/gtkmm-tutorial-in.xml:963(para)
msgid ""
"<classname>RadioButtons</classname> are \"off\" when created; this means that when you first make a group of them, they will all be off. Don't "
"forget to turn one of them on using <methodname>set_active()</methodname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:974(para)
msgid "The following example demonstrates the use of <classname>RadioButton</classname>s:"
msgstr "Das folgende Beispiel demonstriert die Verwendung von Radioknöpfen (<classname>RadioButton</classname>):"

#: C/gtkmm-tutorial-in.xml:996(title) C/gtkmm-tutorial-in.xml:1102(title)
msgid "Range Widgets"
msgstr ""

#: C/gtkmm-tutorial-in.xml:998(para)
msgid ""
"<classname>Gtk::Scale</classname> and <classname>Gtk::Scrollbar</classname> both inherit from <classname>Gtk::Range</classname> and share much "
"functionality. They contain a \"trough\" and a \"slider\" (sometimes called a \"thumbwheel\" in other GUI environments). Dragging the slider "
"with the pointer moves it within the trough, while clicking in the trough advances the slider towards the location of the click, either "
"completely, or by a designated amount, depending on which mouse button is used. This should be familiar scrollbar behaviour."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1009(para)
msgid ""
"As will be explained in the <link linkend=\"chapter-adjustment\">Adjustment</link> section, all Range widgets are associated with a "
"<classname>Adjustment</classname> object. To change the lower, upper, and current values used by the widget you need to use the methods of its "
"<classname>Adjustment</classname>, which you can get with the <methodname>get_adjustment()</methodname> method. The <classname>Range</"
"classname> widgets' default constructors create an <classname>Adjustment</classname> automatically, or you can specify an existing "
"<classname>Adjustment</classname>, maybe to share it with another widget. See the <link linkend=\"chapter-adjustment\">Adjustments</link> "
"section for further details."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1026(title)
msgid "Scrollbar Widgets"
msgstr "Rollbalken-Widgets"

#: C/gtkmm-tutorial-in.xml:1028(para)
msgid ""
"These are standard scrollbars. They should be used only to scroll another widget, such as, a <classname>Gtk::Entry</classname>, or a "
"<classname>Gtk::Viewport</classname>, though it's usually easier to use the <classname>Gtk::ScrolledWindow</classname> widget in most cases."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1035(para)
msgid "The orientation of a <classname>Gtk::Scrollbar</classname> can be either horizontal or vertical."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1045(title)
msgid "Scale Widgets"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1047(para)
msgid ""
"<classname>Gtk::Scale</classname> widgets (or \"sliders\") allow the user to visually select and manipulate a value within a specific range. "
"You might use one, for instance, to adjust the magnification level on a zoomed preview of a picture, or to control the brightness of a colour, "
"or to specify the number of minutes of inactivity before a screensaver takes over the screen."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1056(para)
msgid ""
"As with <classname>Scrollbar</classname>s, the orientation can be either horizontal or vertical. The default constructor creates an "
"<classname>Adjustment</classname> with all of its values set to <literal>0.0</literal>. This isn't useful so you will need to set some "
"<classname>Adjustment</classname> details to get meaningful behaviour."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1065(title)
msgid "Useful methods"
msgstr "Nützliche Methoden"

#: C/gtkmm-tutorial-in.xml:1067(para)
msgid ""
"<classname>Scale</classname> widgets can display their current value as a number next to the trough. By default they show the value, but you "
"can change this with the <methodname>set_draw_value()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1073(para)
msgid ""
"The value displayed by a scale widget is rounded to one decimal point by default, as is the <literal>value</literal> field in its "
"<classname>Gtk::Adjustment</classname>. You can change this with the <methodname>set_digits()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1080(para)
msgid ""
"Also, the value can be drawn in different positions relative to the trough, specified by the <methodname>set_value_pos()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1093(para)
msgid ""
"This example displays a window with three range widgets all connected to the same adjustment, along with a couple of controls for adjusting "
"some of the parameters mentioned above and in the section on adjustments, so you can see how they affect the way these widgets work for the "
"user."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1115(title)
msgid "Miscellaneous Widgets"
msgstr "Verschiedene Widgets"

#: C/gtkmm-tutorial-in.xml:1118(title) C/gtkmm-tutorial-in.xml:1158(title)
msgid "Label"
msgstr "Bezeichnung"

#: C/gtkmm-tutorial-in.xml:1120(para)
msgid ""
"Labels are the main method of placing non-editable text in windows, for instance to place a title next to a <classname>Entry</classname> "
"widget. You can specify the text in the constructor, or later with the <methodname>set_text()</methodname> or <methodname>set_markup()</"
"methodname> methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1127(para)
msgid ""
"The width of the label will be adjusted automatically. You can produce multi-line labels by putting line breaks (\"\\n\") in the label string."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1131(para)
msgid ""
"The label text can be justified using the <methodname>set_justify()</methodname> method. The widget is also capable of word-wrapping, which can "
"be activated with <methodname>set_line_wrap()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1137(para)
msgid ""
"Gtk::Label support some simple formatting, for instance allowing you to make some text bold, colored, or larger. You can do this by providing a "
"string to <methodname>set_markup()</methodname>, using the <ulink url=\"http://developer.gnome.org/pango/unstable/PangoMarkupFormat.html"
"\">Pango Markup syntax</ulink>. For instance, <code> &lt;b&gt;bold text&lt;/b&gt; and &lt;s&gt;strikethrough text&lt;/s&gt; </code> ."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1149(para)
msgid ""
"Below is a short example to illustrate these functions. This example makes use of the Frame widget to better demonstrate the label styles. (The "
"Frame widget is explained in the <link linkend=\"sec-frame\">Frame</link> section.) It is possible that the first character in "
"<literal>m_Label_Normal</literal> is shown underlined only when you press the <keycap>Alt</keycap> key."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1171(title) C/gtkmm-tutorial-in.xml:1228(title)
msgid "Entry"
msgstr "Eintrag"

#: C/gtkmm-tutorial-in.xml:1174(title)
msgid "Simple Use"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1176(para)
msgid ""
"Entry widgets allow the user to enter text. You can change the contents with the <methodname>set_text()</methodname> method, and read the "
"current contents with the <methodname>get_text()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1181(para)
msgid ""
"Occasionally you might want to make an <classname>Entry</classname> widget read-only. This can be done by passing <literal>false</literal> to "
"the <methodname>set_editable()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1187(para)
msgid ""
"For the input of passwords, passphrases and other information you don't want echoed on the screen, calling <methodname>set_visibility()</"
"methodname> with <literal>false</literal> will cause the text to be hidden."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1193(para)
msgid ""
"You might want to be notified whenever the user types in a text entry widget. <classname>Gtk::Entry</classname> provides two signals, "
"<literal>activate</literal> and <literal>changed</literal>, for this purpose. <literal>activate</literal> is emitted when the user presses the "
"Enter key in a text-entry widget; <literal>changed</literal> is emitted when the text in the widget changes. You can use these, for instance, "
"to validate or filter the text the user types. Moving the keyboard focus to another widget may also signal that the user has finished entering "
"text. The <literal>focus_out_event</literal> signal that <classname>Gtk::Entry</classname> inherits from <classname>Gtk::Widget</classname> can "
"notify you when that happens. The <link linkend=\"sec-comboboxentry\">ComboBox with an Entry</link> section contains example programs that use "
"these signals."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1208(para)
msgid ""
"If you pass <literal>true</literal> to the <methodname>set_activates_default()</methodname> method, pressing Enter in the <classname>Gtk::"
"Entry</classname> will activate the default widget for the window containing the <classname>Gtk::Entry</classname>. This is especially useful "
"in dialog boxes. The default widget is usually one of the dialog buttons, which e.g. will close the dialog box. To set a widget as the default "
"widget, use <methodname>Gtk::Widget::set_can_default()</methodname> and <methodname>Gtk::Widget::grab_default()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1220(title)
msgid "Simple Entry Example"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1221(para)
msgid ""
"This example uses <classname>Gtk::Entry</classname>. It also has two <classname>CheckButton</classname>s, with which you can toggle the "
"editable and visible flags."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1241(title) C/gtkmm-tutorial-in.xml:1275(title)
msgid "Entry Completion"
msgstr "Vervollständigung des Eintrags"

#: C/gtkmm-tutorial-in.xml:1242(para)
msgid ""
"A <classname>Entry</classname> widget can offer a drop-down list of pre-existing choices based on the first few characters typed by the user. "
"For instance, a search dialog could suggest text from previous searches."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1247(para)
msgid ""
"To enable this functionality, you must create a <classname>EntryCompletion</classname> object, and provide it to the <classname>Entry</"
"classname> widget via the <methodname>set_completion()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1252(para)
msgid ""
"The <classname>EntryCompletion</classname> may use a <classname>TreeModel</classname> containing possible entries, specified with "
"<methodname>set_model()</methodname>. You should then call <methodname>set_text_column()</methodname> to specify which of your model columns "
"should be used to match possible text entries."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1258(para)
msgid ""
"Alternatively, if a complete list of possible entries would be too large or too inconvenient to generate, a callback slot may instead be "
"specified with <methodname>set_match_func()</methodname>. This is also useful if you wish to match on a part of the string other than the start."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1266(title)
msgid "Entry Completion Example"
msgstr "Beispiel für die Vervollständigung eines Eintrags"

#: C/gtkmm-tutorial-in.xml:1267(para)
msgid ""
"This example creates a <classname>Gtk::EntryCompletion</classname> and associates it with a <classname>Gtk::Entry</classname> widget. The "
"completion uses a <classname>Gtk::TreeModel</classname> of possible entries, and some additional actions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1287(title)
msgid "Entry Icons"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1288(para)
msgid ""
"An <classname>Entry</classname> widget can show an icon at the start or end of the text area. The icon can be specifed by methods such as "
"<methodname>set_icon_from_pixbuf()</methodname> or <methodname>set_icon_from_icon_name()</methodname>. An application can respond to the user "
"pressing the icon by handling the <methodname>signal_icon_press</methodname> signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1295(title)
msgid "Entry Icon Example"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1296(para)
msgid ""
"This example shows a <classname>Gtk::Entry</classname> widget with a named search icon, and prints text to the terminal when the icon is "
"pressed."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1302(title)
msgid "Entry with Icon"
msgstr "Eintrag mit Symbol"

#: C/gtkmm-tutorial-in.xml:1314(title)
msgid "Entry Progress"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1315(para)
msgid ""
"An <classname>Entry</classname> widget can show a progress bar inside the text area, under the entered text. The progress bar will be shown if "
"the <methodname>set_progress_fraction()</methodname> or <methodname>set_progress_pulse_step()</methodname> methods are called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1320(title)
msgid "Entry Progress Example"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1321(para)
msgid "This example shows a <classname>Gtk::Entry</classname> widget with a progress bar."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1327(title)
msgid "Entry with Progress Bar"
msgstr "Eintrag mit Fortschrittsbalken"

#: C/gtkmm-tutorial-in.xml:1341(title) C/gtkmm-tutorial-in.xml:1463(title)
msgid "SpinButton"
msgstr "SpinButton"

#: C/gtkmm-tutorial-in.xml:1343(para)
msgid ""
"A <classname>SpinButton</classname> allows the user to select a value from a range of numeric values. It has an <classname>Entry</classname> "
"widget with increment and decrement buttons at the side. Clicking the buttons causes the value to 'spin' up and down across the range of "
"possible values. The <classname>Entry</classname> widget may also be used to enter a value directly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1351(para)
msgid ""
"The value can have an adjustable number of decimal places, and the step size is configurable. <classname>SpinButton</classname>s have an 'auto-"
"repeat' feature as well: holding down the increment or decrement button can optionally cause the value to change more quickly the longer the "
"button is held down."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1366(para)
msgid "<literal>value</literal>: value for the Spin Button"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1372(para)
msgid "<literal>lower</literal>: lower range value"
msgstr "<literal>lower</literal>: unterer Grenzwert"

#: C/gtkmm-tutorial-in.xml:1378(para)
msgid "<literal>upper</literal>: upper range value"
msgstr "<literal>upper</literal>: oberer Grenzwert"

#: C/gtkmm-tutorial-in.xml:1383(para)
msgid "<literal>step_increment</literal>: value to increment/decrement when pressing mouse button 1 on a button"
msgstr "<literal>step_increment</literal>: Erhöhung/Verringerung des Wertes, wenn auf einem Knopf die Maustaste 1 gedrückt wird"

#: C/gtkmm-tutorial-in.xml:1390(para)
msgid "<literal>page_increment</literal>: value to increment/decrement when pressing mouse button 2 on a button"
msgstr "<literal>page_increment</literal>: Erhöhung/Verringerung des Wertes, wenn auf einem Knopf die Maustaste 2 gedrückt wird"

#: C/gtkmm-tutorial-in.xml:1397(para)
msgid "<literal>page_size</literal>: unused"
msgstr "<literal>page_size</literal>: nicht genutzt"

#: C/gtkmm-tutorial-in.xml:1358(para)
msgid ""
"<classname>SpinButton</classname>s use an <link linkend=\"chapter-adjustment\">Adjustment</link> object to hold information about the range of "
"values. These Adjustment attributes are used by the Spin Button like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1405(para)
msgid "Additionally, mouse button 3 can be used to jump directly to the <literal>upper</literal> or <literal>lower</literal> values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1410(para)
msgid ""
"The <classname>SpinButton</classname> can create a default <classname>Adjustment</classname>, which you can access via the "
"<methodname>get_adjustment()</methodname> method, or you can specify an existing <classname>Adjustment</classname> in the constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1420(para)
msgid "The number of decimal places can be altered using the <methodname>set_digits()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1425(para)
msgid ""
"You can set the spinbutton's value using the <methodname>set_value()</methodname> method, and retrieve it with <methodname>get_value()</"
"methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1430(para)
msgid ""
"The <methodname>spin()</methodname> method 'spins' the <classname>SpinButton</classname>, as if its increment or decrement button had been "
"clicked. You need to specify a <classname>Gtk::SpinType</classname> to specify the direction or new position."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1437(para)
msgid ""
"To prevent the user from typing non-numeric characters into the entry box, pass <literal>true</literal> to the <methodname>set_numeric()</"
"methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1442(para)
msgid ""
"To make the <classname>SpinButton</classname> 'wrap' between its upper and lower bounds, use the <methodname>set_wrap()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1447(para)
msgid "To force it to snap to the nearest <literal>step_increment</literal>, use <methodname>set_snap_to_ticks()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1458(para)
msgid "Here's an example of a <classname>SpinButton</classname> in action:"
msgstr "Hier ist ein Beispiel für einen <classname>SpinButton</classname> in Aktion:"

#: C/gtkmm-tutorial-in.xml:1476(title) C/gtkmm-tutorial-in.xml:1524(title)
msgid "ProgressBar"
msgstr "ProgressBar"

#: C/gtkmm-tutorial-in.xml:1478(para)
msgid ""
"Progress bars are used to show the status of an ongoing operation. For instance, a <classname>ProgressBar</classname> can show how much of a "
"task has been completed."
msgstr ""
"Fortschrittsbalken werden verwendet, um den Status eines laufenden Vorgangs anzuzeigen. Zum Beispiel kann ein <classname>ProgressBar</"
"classname> zeigen, wie viel von einer Aufgabe bereits abgearbeitet wurde."

#: C/gtkmm-tutorial-in.xml:1484(para)
msgid ""
"To change the value shown, use the <methodname>set_fraction()</methodname> method, passing a <type>double</type> between 0.0 and 1.0 to provide "
"the new percentage."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1489(para)
msgid ""
"A <classname>ProgressBar</classname> is horizontal and left-to-right by default, but you can change it to a vertical progress bar by using the "
"<methodname>set_orientation()</methodname> method."
msgstr ""
"Ein <classname>ProgressBar</classname> ist standardmäßig horizontal und von links nach rechts angeordnet, aber Sie können die vertikale "
"Ausrichtung mit der Methode <methodname>set_orientation()</methodname> erreichen."

#: C/gtkmm-tutorial-in.xml:1498(title)
msgid "Activity Mode"
msgstr "Aktivitätsmodus"

#: C/gtkmm-tutorial-in.xml:1499(para)
msgid ""
"Besides indicating the amount of progress that has occured, the progress bar can also be used to indicate that there is some activity; this is "
"done by placing the progress bar in <emphasis>activity mode</emphasis>. In this mode, the progress bar displays a small rectangle which moves "
"back and forth. Activity mode is useful in situations where the progress of an operation cannot be calculated as a value range (e.g., receiving "
"a file of unknown length)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1509(para)
msgid ""
"To do this, you need to call the <methodname>pulse()</methodname> method at regular intervals. You can also choose the step size, with the "
"<methodname>set_pulse_step()</methodname> method."
msgstr ""
"Um das zu erreichen, müssen Sie die Methode <methodname>pulse()</methodname> in regelmäßigen Abständen aufrufen. Außerdem können Sie mit der "
"Methode <methodname>set_pulse_step()</methodname> die Schrittweite wählen."

#: C/gtkmm-tutorial-in.xml:1515(para)
msgid "The progress bar can also display a configurable text string within its trough, using the <methodname>set_text()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1538(title) C/gtkmm-tutorial-in.xml:1548(title)
msgid "InfoBar"
msgstr "InfoBar"

#: C/gtkmm-tutorial-in.xml:1540(para)
msgid ""
"An <classname>InfoBar</classname> may show small items of information or ask brief questions. Unlike a <classname>Dialog</classname>, it "
"appears at the top of the current window instead of opening a new window. Its API is very similar to the <link linkend=\"chapter-dialogs\">Gtk::"
"Dialog</link> API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1561(title)
msgid "Tooltips"
msgstr "Minihilfen"

#: C/gtkmm-tutorial-in.xml:1563(para)
msgid ""
"Tooltips are the little information windows that pop up when you leave your pointer over a widget for a few seconds. Use "
"<methodname>set_tooltip_text()</methodname> to set a text string as a tooltip on any <classname>Widget</classname>. <classname>Gtk::ToolItem</"
"classname>s are not <classname>Widget</classname>s, but have the same method for convenience. <classname>Gtk::Tooltip</classname> is used for "
"more advanced tooltip usage, such as showing an image as well as text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1573(ulink)
msgid "Widget Reference"
msgstr "Widget-Referenz"

#: C/gtkmm-tutorial-in.xml:1574(ulink)
msgid "Tooltip Reference"
msgstr "Minihilfen-Referenz"

#: C/gtkmm-tutorial-in.xml:1579(title)
msgid "Tooltip"
msgstr "Minihilfe"

#: C/gtkmm-tutorial-in.xml:1594(title)
msgid "Container Widgets"
msgstr "Container-Widgets"

#: C/gtkmm-tutorial-in.xml:1596(para)
msgid ""
"All container widgets derive from <classname>Gtk::Container</classname>, not always directly. Some container widgets, such as <classname>Gtk::"
"Grid</classname> can hold many child widgets, so these typically have more complex interfaces. Others, such as <classname>Gtk::Frame</"
"classname> contain only one child widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1605(title)
msgid "Single-item Containers"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1607(para)
msgid ""
"The single-item container widgets derive from <classname>Gtk::Bin</classname>, which provides the <methodname>add()</methodname> and "
"<methodname>remove()</methodname> methods for the child widget. Note that <classname>Gtk::Button</classname> and <classname>Gtk::Window</"
"classname> are technically single-item containers, but we have discussed them already elsewhere."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1615(para)
msgid ""
"We also discuss the <classname>Gtk::Paned</classname> widget, which allows you to divide a window into two separate \"panes\". This widget "
"actually contains two child widgets, but the number is fixed so it seems appropriate."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1622(title) C/gtkmm-tutorial-in.xml:1636(title)
msgid "Frame"
msgstr "Rahmen"

#: C/gtkmm-tutorial-in.xml:1624(para)
msgid ""
"Frames can enclose one or a group of widgets within a box, optionally with a title. For instance, you might place a group of "
"<classname>RadioButton</classname>s or <classname>CheckButton</classname>s in a <classname>Frame</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1650(title) C/gtkmm-tutorial-in.xml:1676(title)
msgid "Paned"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1652(para)
msgid ""
"Panes divide a widget into two halves, separated by a moveable divider. The two halves (panes) can be oriented either horizontally (side by "
"side) or vertically (one above the other)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1658(para)
msgid ""
"Unlike the other widgets in this section, pane widgets contain not one but two child widgets, one in each pane. Therefore, you should use "
"<methodname>add1()</methodname> and <methodname>add2()</methodname> instead of the <methodname>add()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1665(para)
msgid "You can adjust the position of the divider using the <methodname>set_position()</methodname> method, and you will probably need to do so."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1689(title) C/gtkmm-tutorial-in.xml:1721(title)
msgid "ScrolledWindow"
msgstr "ScrolledWindow"

#: C/gtkmm-tutorial-in.xml:1691(para)
msgid ""
"<classname>ScrolledWindow</classname> widgets create a scrollable area. You can insert any type of widget into a <classname>ScrolledWindow</"
"classname> window, and it will be accessible regardless of its size by using the scrollbars. Note that <classname>ScrolledWindow</classname> is "
"not a <classname>Gtk::Window</classname> despite the slightly misleading name."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1700(para)
msgid ""
"Scrolled windows have <emphasis>scrollbar policies</emphasis> which determine whether the <classname>Scrollbar</classname>s will be displayed. "
"The policies can be set with the <methodname>set_policy()</methodname> method. The policy may be one of <literal>Gtk::POLICY_AUTOMATIC</"
"literal> or <literal>Gtk::POLICY_ALWAYS</literal>. <literal>Gtk::POLICY_AUTOMATIC</literal> will cause the scrolled window to display the "
"scrollbar only if the contained widget is larger than the visible area. <literal>Gtk::POLICY_ALWAYS</literal> will cause the scrollbar to be "
"displayed always."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1716(para)
msgid "Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1734(title) C/gtkmm-tutorial-in.xml:1756(title)
msgid "AspectFrame"
msgstr "AspectFrame"

#: C/gtkmm-tutorial-in.xml:1736(para)
msgid ""
"The <classname>AspectFrame</classname> widget looks like a <classname>Frame</classname> widget, but it also enforces the <emphasis>aspect "
"ratio</emphasis> (the ratio of the width to the height) of the child widget, adding extra space if necessary. For instance, this would allow "
"you to display a photograph without allowing the user to distort it horizontally or vertically while resizing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1749(para)
msgid ""
"The following program uses a <classname>Gtk::AspectFrame</classname> to present a drawing area whose aspect ratio will always be 2:1, no matter "
"how the user resizes the top-level window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1769(title) C/gtkmm-tutorial-in.xml:1795(title)
msgid "Alignment"
msgstr "Alignment"

#: C/gtkmm-tutorial-in.xml:1771(para)
msgid ""
"The <classname>Alignment</classname> widget allows you to place a widget at a position and size relative to the size of the "
"<classname>Alignment</classname> widget itself. For instance, it might be used to center a widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1777(para)
msgid ""
"You need to specify the <classname>Alignment</classname>'s characteristics to the constructor, or to the <methodname>set()</methodname> method. "
"In particular, you won't notice much effect unless you specify a number other than 1.0 for the <literal>xscale</literal> and <literal>yscale</"
"literal> parameters, because 1.0 simply means that the child widget will expand to fill all available space."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1789(para)
msgid "This example right-aligns a button in a window by using an <classname>Alignment</classname> widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1803(para)
msgid "See the <link linkend=\"sec-progressbar\">ProgressBar</link> section for another example that uses an <classname>Alignment</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1815(title)
msgid "Multiple-item widgets"
msgstr "Widgets mit mehreren Objekten"

#: C/gtkmm-tutorial-in.xml:1817(para)
msgid ""
"Multiple-item widgets inherit from <classname>Gtk::Container</classname>; just as with <classname>Gtk::Bin</classname>, you use the "
"<methodname>add()</methodname> and <methodname>remove()</methodname> methods to add and remove contained widgets. Unlike <methodname>Gtk::Bin::"
"remove()</methodname>, however, the <methodname>remove()</methodname> method for <classname>Gtk::Container</classname> takes an argument, "
"specifiying which widget to remove."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1827(title)
msgid "Packing"
msgstr "Packen"

#: C/gtkmm-tutorial-in.xml:1828(para)
msgid ""
"You've probably noticed that <application>gtkmm</application> windows seem \"elastic\" - they can usually be stretched in many different ways. "
"This is due to the <emphasis>widget packing</emphasis> system."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1833(para)
msgid ""
"Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to "
"several problems:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1840(para)
msgid ""
"The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless "
"space appears when the window is made larger."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1844(para)
msgid ""
"It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different "
"font. On Unix it is also impossible to anticipate the effects of every theme and window manager."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1848(para)
msgid ""
"Changing the layout of a window \"on the fly\", to make some extra widgets appear, for instance, is complex. It requires tedious recalculation "
"of every widget's position."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1854(para)
msgid ""
"<application>gtkmm</application> uses the packing system to solve these problems. Rather than specifying the position and size of each widget "
"in the window, you can arrange your widgets in rows, columns, and/or grids. <application>gtkmm</application> can size your window "
"automatically, based on the sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they "
"contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between "
"sets of widgets. You can perfect your layout by specifying padding distance and centering values for each of your widgets. <application>gtkmm</"
"application> then uses all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1863(para)
msgid ""
"<application>gtkmm</application> arranges widgets hierarchically, using <emphasis>containers</emphasis>. A Container widget contains other "
"widgets. Most <application>gtkmm</application> widgets are containers. Windows, Notebook tabs, and Buttons are all container widgets. There are "
"two flavours of containers: single-child containers, which are all descendants of <classname>Gtk::Bin</classname>, and multiple-child "
"containers, which are descendants of <classname>Gtk::Container</classname>. Most widgets in <application>gtkmm</application> are descendants of "
"<classname>Gtk::Bin</classname>, including <classname>Gtk::Window</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1874(para)
msgid ""
"Yes, that's correct: a Window can contain at most one widget. How, then, can we use a window for anything useful? By placing a multiple-child "
"container in the window. The most useful container widgets are <classname>Gtk::Grid</classname> and <classname>Gtk::Box</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1885(para)
msgid ""
"<classname>Gtk::Grid</classname> arranges its child widgets in rows and columns. Use <methodname>attach()</methodname>, "
"<methodname>attach_next_to()</methodname> and <methodname>add()</methodname> to insert child widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1894(para)
msgid ""
"<classname>Gtk::Box</classname> arranges its child widgets vertically or horizontally. Use <methodname>pack_start()</methodname> and "
"<methodname>pack_end()</methodname> to insert child widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1903(para)
msgid "There are several other containers, which we will also discuss."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1907(para)
msgid ""
"If you've never used a packing toolkit before, it can take some getting used to. You'll probably find, however, that you don't need to rely on "
"visual form editors quite as much as you might with other toolkits."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1917(title)
msgid "An improved Hello World"
msgstr "Ein verbessertes »Hello World«"

#: C/gtkmm-tutorial-in.xml:1919(para)
msgid "Let's take a look at a slightly improved <literal>helloworld</literal>, showing what we've learnt."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1924(title)
msgid "Hello World 2"
msgstr "Hello World 2"

#: C/gtkmm-tutorial-in.xml:1932(para)
msgid ""
"After building and running this program, try resizing the window to see the behaviour. Also, try playing with the options to "
"<methodname>pack_start()</methodname> while reading the <link linkend=\"sec-boxes\">Boxes</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1942(title)
msgid "Boxes"
msgstr "Boxen"

#: C/gtkmm-tutorial-in.xml:1944(para)
msgid ""
"Most packing uses boxes as in the above example. These are invisible containers into which we can pack our widgets. When packing widgets into a "
"horizontal box, the objects are inserted horizontally from left to right or right to left depending on whether <methodname>pack_start()</"
"methodname> or <methodname>pack_end()</methodname> is used. In a vertical box, widgets are packed from top to bottom or vice versa. You may use "
"any combination of boxes inside or beside other boxes to create the desired effect."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1955(title)
msgid "Adding widgets"
msgstr "Hinzufügen von Widgets"

#: C/gtkmm-tutorial-in.xml:1956(title)
msgid "Per-child packing options"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1957(para)
msgid ""
"The <methodname>pack_start()</methodname> and <methodname>pack_end()</methodname> methods place widgets inside these containers. The "
"<methodname>pack_start()</methodname> method will start at the top and work its way down in a <classname>Box</classname> with vertical "
"orientation, or pack left to right in a <classname>Box</classname> with horizontal orientation. <methodname>pack_end()</methodname> will do the "
"opposite, packing from bottom to top or from right to left. Using these methods allows us to right justify or left justify our widgets. We will "
"use <methodname>pack_start()</methodname> in most of our examples."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1969(para)
msgid ""
"There are several options governing how widgets are to be packed, and this can be confusing at first. If you have difficulties then it is "
"sometimes a good idea to play with the <application>glade</application> GUI designer to see what is possible. You might even decide to use the "
"<application>Gtk::Builder</application> API to load your GUI at runtime."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1977(para)
msgid "There are basically five different styles, as shown in this picture:"
msgstr "Es gibt fünf verschiedene grundlegende Stile, wie in diesem Bild gezeigt:"

#: C/gtkmm-tutorial-in.xml:1983(title)
msgid "Box Packing 1"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1989(para)
msgid ""
"Each line contains one horizontal <classname>Box</classname> with several buttons. Each of the buttons on a line is packed into the "
"<classname>Box</classname> with the same arguments to the <methodname>pack_start()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1996(para)
msgid "This is the declaration of the <methodname>pack_start()</methodname> method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1999(programlisting)
#, no-wrap
#| msgid ""
#| "void pack_start(Gtk::Widget&amp; child,\n"
#| "                PackOptions options = PACK_EXPAND_WIDGET,\n"
#| "                guint padding = 0);"
msgid ""
"void pack_start(Gtk::Widget&amp; child,\n"
"                Gtk::PackOptions options = Gtk::PACK_EXPAND_WIDGET,\n"
"                guint padding = 0);"
msgstr ""
"void pack_start(Gtk::Widget&amp; child,\n"
"                Gtk::PackOptions options = Gtk::PACK_EXPAND_WIDGET,\n"
"                guint padding = 0);"

#: C/gtkmm-tutorial-in.xml:2003(para)
msgid "The first argument is the widget you're packing. In our example these are all <classname>Button</classname>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2010(para)
msgid ""
"<literal>Gtk::PACK_SHRINK</literal>: Space is contracted to the child widget size. The widget will take up just-enough space and never expand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2011(para)
msgid ""
"<literal>Gtk::PACK_EXPAND_PADDING</literal>: Extra space is filled with padding. The widgets will be spaced out evenly, but their sizes won't "
"change - there will be empty space between the widgets instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2012(para)
msgid ""
"<literal>Gtk::PACK_EXPAND_WIDGET</literal>: Extra space is taken up by increasing the child widget size, without changing the amount of space "
"between widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2007(para)
msgid "The <parameter>options</parameter> argument can take one of these three options: <placeholder-1/>"
msgstr "Das Argument <parameter>options</parameter> akzeptiert eine dieser drei Optionen: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:2016(para)
msgid "The <parameter>padding</parameter> argument specifies the width of an extra border area to leave around the packed widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2025(title)
msgid "Per-container packing options"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2029(programlisting)
#, no-wrap
msgid ""
"Gtk::Box(Gtk::Orientation orientation = Gtk::ORIENTATION_HORIZONTAL, int spacing = 0);\n"
"void set_spacing(int spacing);\n"
"void set_homogeneous(bool homogeneous = true);"
msgstr ""
"Gtk::Box(Gtk::Orientation orientation = Gtk::ORIENTATION_HORIZONTAL, int spacing = 0);\n"
"void set_spacing(int spacing);\n"
"void set_homogeneous(bool homogeneous = true);"

#: C/gtkmm-tutorial-in.xml:2026(para)
msgid ""
"Here's the constructor for the <classname>Box</classname> widget, and methods that set per-container packing options: <placeholder-1/> Passing "
"<literal>true</literal> to <methodname>set_homogeneous()</methodname> will cause all of the contained widgets to be the same size. "
"<parameter>spacing</parameter> is a (minimum) number of pixels to leave between each widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2038(para)
msgid ""
"What's the difference between spacing (set when the box is created) and padding (set when elements are packed)? Spacing is added between "
"objects, and padding is added on either side of a widget. The following figure should make it clearer:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2046(title)
msgid "Box Packing 2"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2056(title)
msgid "Gtk::Application and command-line options"
msgstr "Gtk::Application und Befehlszeilenoptionen"

#: C/gtkmm-tutorial-in.xml:2057(para)
msgid ""
"The following example program requires a command-line option. The source code shows two ways of handling command-line options in combination "
"with <classname>Gtk::Application</classname>."
msgstr ""
"Das folgende Beispielprogramm benötigt eine Befehlszeilenoption. Der Quellcode zeigt zwei Wege, wie in Kombination mit <classname>Gtk::"
"Application</classname> mit Befehlszeilenoptionen umgegangen werden kann."

#: C/gtkmm-tutorial-in.xml:2063(para)
msgid ""
"Handle the options in <function>main()</function> and hide them from <classname>Gtk::Application</classname> by setting <literal>argc = 1</"
"literal> in the call to <methodname>Gtk::Application::create()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2069(para)
msgid ""
"Give all command-line options to <methodname>Gtk::Application::create()</methodname> and add the flag <literal>Gio::"
"APPLICATION_HANDLES_COMMAND_LINE</literal>. Connect a signal handler to the <literal>command_line</literal> signal, and handle the command-line "
"options in the signal handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2075(para)
msgid ""
"You must set the optional parameter <literal>after = false</literal> in the call to <literal>signal_command_line().connect()</literal>, because "
"your signal handler must be called before the default signal handler. You must also call <methodname>Gio::Application::activate()</methodname> "
"in the signal handler, unless you want your application to exit without showing its main window. (<classname>Gio::Application</classname> is a "
"base class of <classname>Gtk::Application</classname>.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2088(para)
msgid ""
"Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a "
"command-line option, to see different packing options in use."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2097(title)
msgid "ButtonBoxes"
msgstr "ButtonBoxes"

#: C/gtkmm-tutorial-in.xml:2099(para)
msgid "Button boxes are a convenient way to quickly arrange a group of buttons. Their orientation can be either horizontal or vertical."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2104(para)
msgid ""
"<classname>ButtonBox</classname>es help to make applications appear consistent because they use standard settings, such as inter-button spacing "
"and packing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2109(para)
msgid "Buttons are added to a <classname>ButtonBox</classname> with the <methodname>add()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2114(para)
msgid ""
"Button boxes support several layout styles. The style can be retrieved and changed using <methodname>get_layout()</methodname> and "
"<methodname>set_layout()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2126(title)
msgid "ButtonBox"
msgstr "ButtonBox"

#: C/gtkmm-tutorial-in.xml:2139(title) C/gtkmm-tutorial-in.xml:2168(title)
msgid "Grid"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2141(para)
msgid ""
"A <classname>Grid</classname> dynamically lays out child widgets in rows and columns. The dimensions of the grid do not need to be specified in "
"the constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2146(para)
msgid ""
"Child widgets can span multiple rows or columns, using <methodname>attach()</methodname>, or added next to an existing widget inside the grid "
"with <methodname>attach_next_to()</methodname>. Individual rows and columns of the grid can be set to have uniform height or width with "
"<methodname>set_row_homogeneous()</methodname> and <methodname>set_column_homogeneous()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2153(para)
msgid ""
"You can set the <emphasis>margin</emphasis> and <emphasis>expand</emphasis> properties of the child <classname>Widget</classname>s to control "
"their spacing and their behaviour when the Grid is resized."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2160(para)
msgid ""
"This example creates a window with three buttons in a grid. The first two buttons are in the upper row, from left to right. A third button is "
"attached underneath the first button, in a new lower row, spanning two columns."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2181(title)
msgid "Table"
msgstr "Tabelle"

#: C/gtkmm-tutorial-in.xml:2183(para)
msgid "<classname>Gtk::Table</classname> allows us to place widgets in a grid, similar to <classname>Gtk::Grid</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2187(para)
msgid ""
"<classname>Gtk::Table</classname> is deprecated from <application>gtkmm</application> version 3.4 and should not be used in newly-written code. "
"Use <classname>Gtk::Grid</classname> instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2194(title) C/gtkmm-tutorial-in.xml:2229(title)
msgid "Notebook"
msgstr "Reitermappe"

#: C/gtkmm-tutorial-in.xml:2196(para)
msgid ""
"A <classname>Notebook</classname> has a set of stacked <literal>pages</literal>, each of which contains widgets. Labelled <literal>tabs</"
"literal> allow the user to select the pages. <classname>Notebook</classname>s allow several sets of widgets to be placed in a small space, by "
"only showing one page at a time. For instance, they are often used in preferences dialogs."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2205(para)
msgid ""
"Use the <methodname>append_page()</methodname>, <methodname>prepend_page()</methodname> and <methodname>insert_page()</methodname> methods to "
"add tabbed pages to the <literal>Notebook</literal>, supplying the child widget and the name for the tab."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2212(para)
msgid ""
"To discover the currently visible page, use the <methodname>get_current_page()</methodname> method. This returns the page number, and then "
"calling <methodname>get_nth_page()</methodname> with that number will give you a pointer to the actual child widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2219(para)
msgid "To programmatically change the selected page, use the <methodname>set_current_page()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2242(title) C/gtkmm-tutorial-in.xml:2269(title)
msgid "Assistant"
msgstr "Assistent"

#: C/gtkmm-tutorial-in.xml:2244(para)
msgid ""
"An <classname>Assistant</classname> splits a complex operation into steps. Each step is a page, containing a header, a child widget and an "
"action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with "
"<methodname>set_page_type()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2248(para)
msgid ""
"Use the <methodname>append_page()</methodname>, <methodname>prepend_page</methodname> and <methodname>insert_page()</methodname> methods to add "
"pages to the <classname>Assistant</classname>, supplying the child widget for each page."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2252(para)
msgid ""
"To determine the currently-visible page, use the <methodname>get_current_page()</methodname> method, and pass the result to "
"<methodname>get_nth_page()</methodname>, which returns a pointer to the actual widget. To programmatically change the current page, use the "
"<methodname>set_current_page()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2256(para)
msgid ""
"To set the title of a page, use the <methodname>set_page_title()</methodname> method. The header and side images of a page can be set with the "
"<methodname>set_page_header_image()</methodname> and <methodname>set_page_side_image()</methodname> methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2260(para)
msgid ""
"To add widgets to the action area, use the <methodname>add_action_widget()</methodname> method. They will be packed alongside the default "
"buttons. Use the <methodname>remove_action_widget()</methodname> method to remove widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2287(title)
msgid "The TreeView widget"
msgstr "Das TreeView-Widget"

#: C/gtkmm-tutorial-in.xml:2288(para)
msgid "The <classname>Gtk::TreeView</classname> widget can contain lists or trees of data, in columns."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2294(title)
msgid "The Model"
msgstr "Das Modell"

#: C/gtkmm-tutorial-in.xml:2295(para)
msgid ""
"Each <classname>Gtk::TreeView</classname> has an associated <classname>Gtk::TreeModel</classname>, which contains the data displayed by the "
"<classname>TreeView</classname>. Each <classname>Gtk::TreeModel</classname> can be used by more than one <classname>Gtk::TreeView</classname>. "
"For instance, this allows the same underlying data to be displayed and edited in 2 different ways at the same time. Or the 2 Views might "
"display different columns from the same Model data, in the same way that 2 SQL queries (or \"views\") might show different fields from the same "
"database table."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2305(para)
msgid ""
"Although you can theoretically implement your own Model, you will normally use either the <classname>ListStore</classname> or "
"<classname>TreeStore</classname> model classes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2314(title)
msgid "ListStore, for rows"
msgstr "ListStore, für Zeilen"

#: C/gtkmm-tutorial-in.xml:2315(para)
msgid "The <classname>ListStore</classname> contains simple rows of data, and each row has no children."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2321(title) C/gtkmm-tutorial-in.xml:2861(title)
msgid "TreeView - ListStore"
msgstr "TreeView - ListStore"

#: C/gtkmm-tutorial-in.xml:2332(title)
msgid "TreeStore, for a hierarchy"
msgstr "TreeStore, für eine Hierarchie"

#: C/gtkmm-tutorial-in.xml:2333(para)
msgid "The <classname>TreeStore</classname> contains rows of data, and each row may have child rows."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2339(title) C/gtkmm-tutorial-in.xml:2880(title)
msgid "TreeView - TreeStore"
msgstr "TreeView - TreeStore"

#: C/gtkmm-tutorial-in.xml:2350(title)
msgid "Model Columns"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2351(para)
msgid ""
"The <classname>TreeModelColumnRecord</classname> class is used to keep track of the columns and their data types. You add "
"<classname>TreeModelColumn</classname> instances to the <classname>ColumnRecord</classname> and then use those <classname>TreeModelColumns</"
"classname> when getting and setting the data in model rows. You will probably find it convenient to derive a new "
"<classname>TreeModelColumnRecord</classname> which has your <classname>TreeModelColumn</classname> instances as member data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2362(programlisting)
#, no-wrap
msgid ""
"class ModelColumns : public Gtk::TreeModelColumnRecord\n"
"{\n"
"public:\n"
"\n"
"  ModelColumns()\n"
"    { add(m_col_text); add(m_col_number); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_number;\n"
"};\n"
"\n"
"ModelColumns m_Columns;"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2375(para)
msgid "You specify the <classname>ColumnRecord</classname> when creating the Model, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2379(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"
msgstr ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"

#: C/gtkmm-tutorial-in.xml:2381(para)
msgid ""
"Note that the instance (such as m_Columns here) should usually not be static, because it often needs to be instantiated after glibmm has been "
"instantiated."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2386(title)
msgid "Adding Rows"
msgstr "Hinzufügen von Zeilen"

#: C/gtkmm-tutorial-in.xml:2387(para)
msgid ""
"Add rows to the model with the <methodname>append()</methodname>, <methodname>prepend()</methodname>, or <methodname>insert()</methodname> "
"methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2391(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();"
msgstr "Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();"

#: C/gtkmm-tutorial-in.xml:2392(para)
msgid "You can dereference the iterator to get the Row:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2394(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::Row row = *iter;"
msgstr "Gtk::TreeModel::Row row = *iter;"

#: C/gtkmm-tutorial-in.xml:2395(title)
msgid "Adding child rows"
msgstr "Hinzufügen von Unterzeilen"

#: C/gtkmm-tutorial-in.xml:2396(para)
msgid ""
"<classname>Gtk::TreeStore</classname> models can have child items. Add them with the <methodname>append()</methodname>, <methodname>prepend()</"
"methodname>, or <methodname>insert()</methodname> methods, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2401(programlisting)
#, no-wrap
#| msgid ""
#| "Gtk::TreeModel::iterator iter_child =\n"
#| "    m_refListStore-&gt;append(row.children());"
msgid ""
"Gtk::TreeModel::iterator iter_child =\n"
"    m_refTreeStore-&gt;append(row.children());"
msgstr ""
"Gtk::TreeModel::iterator iter_child =\n"
"    m_refTreeStore-&gt;append(row.children());"

#: C/gtkmm-tutorial-in.xml:2408(title)
msgid "Setting values"
msgstr "Festlegen von Werten"

#: C/gtkmm-tutorial-in.xml:2409(para)
msgid ""
"You can use the <methodname>operator[]</methodname> override to set the data for a particular column in the row, specifying the "
"<classname>TreeModelColumn</classname> used to create the model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2414(programlisting)
#, no-wrap
msgid "row[m_Columns.m_col_text] = \"sometext\";"
msgstr "row[m_Columns.m_col_text] = \"sometext\";"

#: C/gtkmm-tutorial-in.xml:2418(title)
msgid "Getting values"
msgstr "Ermitteln von Werten"

#: C/gtkmm-tutorial-in.xml:2419(para)
msgid ""
"You can use the <methodname>operator[]</methodname> override to get the data in a particular column in a row, specifiying the "
"<classname>TreeModelColumn</classname> used to create the model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2424(programlisting)
#, no-wrap
msgid ""
"Glib::ustring strText = row[m_Columns.m_col_text];\n"
"int number = row[m_Columns.m_col_number];"
msgstr ""
"Glib::ustring strText = row[m_Columns.m_col_text];\n"
"int number = row[m_Columns.m_col_number];"

#: C/gtkmm-tutorial-in.xml:2426(para)
msgid "The compiler will complain if you use an inappropriate type. For instance, this would generate a compiler error:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2430(programlisting)
#, no-wrap
msgid ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"
msgstr ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"

#: C/gtkmm-tutorial-in.xml:2435(title)
msgid "\"Hidden\" Columns"
msgstr "»Verborgene« Spalten"

#: C/gtkmm-tutorial-in.xml:2436(para)
msgid "You might want to associate extra data with each row. If so, just add it as a Model column, but don't add it to the View."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2445(title) C/gtkmm-tutorial-in.xml:3272(title)
msgid "The View"
msgstr "Die Ansicht"

#: C/gtkmm-tutorial-in.xml:2446(para)
msgid ""
"The View is the actual widget (<classname>Gtk::TreeView</classname>) that displays the model (<classname>Gtk::TreeModel</classname>) data and "
"allows the user to interact with it. The View can show all of the model's columns, or just some, and it can show them in various ways."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2456(title)
msgid "Using a Model"
msgstr "Verwendung eines Modells"

#: C/gtkmm-tutorial-in.xml:2457(para)
msgid ""
"You can specify a <classname>Gtk::TreeModel</classname> when constructing the <classname>Gtk::TreeView</classname>, or you can use the "
"<methodname>set_model()</methodname> method, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2462(programlisting)
#, no-wrap
msgid "m_TreeView.set_model(m_refListStore);"
msgstr "m_TreeView.set_model(m_refListStore);"

#: C/gtkmm-tutorial-in.xml:2466(title)
msgid "Adding View Columns"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2467(para)
msgid ""
"You can use the <methodname>append_column()</methodname> method to tell the View that it should display certain Model columns, in a certain "
"order, with a certain column title."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2472(programlisting)
#, no-wrap
msgid "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"
msgstr "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"

#: C/gtkmm-tutorial-in.xml:2473(para)
msgid ""
"When using this simple <methodname>append_column()</methodname> override, the <classname>TreeView</classname> will display the model data with "
"an appropriate <classname>CellRenderer</classname>. For instance, strings and numbers are shown in a simple <classname>Gtk::Entry</classname> "
"widget, and booleans are shown in a <classname>Gtk::CheckButton</classname>. This is usually what you need. For other column types you must "
"either connect a callback that converts your type into a string representation, with <methodname>TreeViewColumn::set_cell_data_func()</"
"methodname>, or derive a custom <classname>CellRenderer</classname>. Note that (unsigned) short is not supported by default - You could use "
"(unsigned) int or (unsigned) long as the column type instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2489(title)
msgid "More than one Model Column per View Column"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2490(para)
msgid ""
"To render more than one model column in a view column, you need to create the <classname>TreeView::Column</classname> widget manually, and use "
"<methodname>pack_start()</methodname> to add the model columns to it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2496(para)
msgid ""
"Then use <methodname>append_column()</methodname> to add the view Column to the View. Notice that <methodname>Gtk::TreeView::append_column()</"
"methodname> is overridden to accept either a prebuilt <classname>Gtk::TreeView::Column</classname> widget, or just the "
"<classname>TreeModelColumn</classname> from which it generates an appropriate <classname>Gtk::TreeView::Column</classname> widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2503(para)
msgid ""
"Here is some example code from <filename>gtkmm/demos/gtk-demo/example_icontheme.cc</filename>, which has a pixbuf icon and a text name in the "
"same column:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2508(programlisting)
#, no-wrap
#| msgid ""
#| "Gtk::TreeView::Column* pColumn =\n"
#| "    Gtk::manage( new Gtk::TreeView::Column(\"Symbol\") );\n"
#| "\n"
#| "// m_columns.icon and m_columns.symbol are columns in the model.\n"
#| "// pColumn is the column in the TreeView:\n"
#| "pColumn-&gt;pack_start(m_columns.icon, false); //false = don't expand.\n"
#| "pColumn-&gt;pack_start(m_columns.symbol);\n"
#| "\n"
#| "m_TreeView.append_column(*pColumn);"
msgid ""
"Gtk::TreeView::Column* pColumn =\n"
"  Gtk::manage(new Gtk::TreeView::Column(\"Icon Name\"));\n"
"\n"
"// m_columns.icon and m_columns.iconname are columns in the model.\n"
"// pColumn is the column in the TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);\n"
"pColumn-&gt;pack_start(m_columns.iconname);\n"
"\n"
"m_TreeView.append_column(*pColumn);"
msgstr ""
"Gtk::TreeView::Column* pColumn =\n"
"  Gtk::manage(new Gtk::TreeView::Column(\"Icon Name\"));\n"
"\n"
"// m_columns.icon and m_columns.iconname are columns in the model.\n"
"// pColumn is the column in the TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);\n"
"pColumn-&gt;pack_start(m_columns.iconname);\n"
"\n"
"m_TreeView.append_column(*pColumn);"

#: C/gtkmm-tutorial-in.xml:2520(title)
msgid "Specifying CellRenderer details"
msgstr "Angeben von CellRenderer-Details"

#: C/gtkmm-tutorial-in.xml:2521(para)
msgid ""
"The default <classname>CellRenderers</classname> and their default behaviour will normally suffice, but you might occasionally need finer "
"control. For instance, this example code from <filename>gtkmm/demos/gtk-demo/example_treeview_treestore.cc</filename>, appends a "
"<classname>Gtk::CellRenderer</classname> widget and instructs it to render the data from various model columns through various aspects of its "
"appearance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2529(programlisting)
#, no-wrap
#| msgid ""
#| "Gtk::CellRendererToggle* pRenderer =\n"
#| "    Gtk::manage( new Gtk::CellRendererToggle() );\n"
#| "int cols_count = m_TreeView.append_column(\"Alex\", *pRenderer);\n"
#| "Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);\n"
#| "if(pColumn)\n"
#| "{\n"
#| "  pColumn-&gt;add_attribute(pRenderer-&gt;property_active(),\n"
#| "      m_columns.alex);\n"
#| "  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(),\n"
#| "      m_columns.visible);\n"
#| "  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(),\n"
#| "      m_columns.world);"
msgid ""
"int cols_count = m_TreeView.append_column_editable(\"Alex\", m_columns.alex);\n"
"Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  Gtk::CellRendererToggle* pRenderer =\n"
"    static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);"
msgstr ""
"int cols_count = m_TreeView.append_column_editable(\"Alex\", m_columns.alex);\n"
"Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  Gtk::CellRendererToggle* pRenderer =\n"
"    static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);"

#: C/gtkmm-tutorial-in.xml:2538(para)
msgid "You can also connect to <classname>CellRenderer</classname> signals to detect user actions. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2542(programlisting)
#, no-wrap
msgid ""
"Gtk::CellRendererToggle* pRenderer =\n"
"    Gtk::manage( new Gtk::CellRendererToggle() );\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"
msgstr ""
"Gtk::CellRendererToggle* pRenderer =\n"
"    Gtk::manage( new Gtk::CellRendererToggle() );\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"

#: C/gtkmm-tutorial-in.xml:2551(title) C/gtkmm-tutorial-in.xml:2890(title)
msgid "Editable Cells"
msgstr "Bearbeitbare Zellen"

#: C/gtkmm-tutorial-in.xml:2554(title)
msgid "Automatically-stored editable cells."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2555(para)
msgid ""
"Cells in a <classname>TreeView</classname> can be edited in-place by the user. To allow this, use the <classname>Gtk::TreeView</"
"classname><methodname>insert_column_editable()</methodname> and <methodname>append_column_editable()</methodname> methods instead of "
"<methodname>insert_column()</methodname> and <methodname>append_column()</methodname>. When these cells are edited the new values will be "
"stored immediately in the Model. Note that these methods are templates which can only be instantiated for simple column types such as "
"<classname>Glib::ustring</classname>, int, and long."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2569(title)
msgid "Implementing custom logic for editable cells."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2570(para)
msgid ""
"However, you might not want the new values to be stored immediately. For instance, maybe you want to restrict the input to certain characters "
"or ranges of values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2575(para)
msgid ""
"To achieve this, you should use the normal <classname>Gtk::TreeView</classname><methodname>insert_column()</methodname> and "
"<methodname>append_column()</methodname> methods, then use <methodname>get_column_cell_renderer()</methodname> to get the <classname>Gtk::"
"CellRenderer</classname> used by that column."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2581(para)
msgid ""
"You should then cast that <classname>Gtk::CellRenderer*</classname> to the specific <classname>CellRenderer</classname> that you expect, so you "
"can use specific API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2585(para)
msgid "For instance, for a CellRendererText, you would set the cell's <emphasis>editable</emphasis> property to true, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2588(programlisting)
#, no-wrap
msgid "cell.property_editable() = true;"
msgstr "cell.property_editable() = true;"

#: C/gtkmm-tutorial-in.xml:2589(para)
msgid "For a CellRendererToggle, you would set the <emphasis>activatable</emphasis> property instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2593(para)
msgid ""
"You can then connect to the appropriate \"edited\" signal. For instance, connect to <methodname>Gtk::CellRendererText::signal_edited()</"
"methodname>, or <methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. If the column contains more than one "
"<classname>CellRenderer</classname> then you will need to use <methodname>Gtk::TreeView::get_column()</methodname> and then call "
"<methodname>get_cell_renderers()</methodname> on that view Column."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2601(para)
msgid "In your signal handler, you should examine the new value and then store it in the Model if that is appropriate for your application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2613(title)
msgid "Iterating over Model Rows"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2614(para)
msgid ""
"<classname>Gtk::TreeModel</classname> provides a C++ Standard Library-style container of its children, via the <methodname>children()</"
"methodname> method. You can use the familiar <methodname>begin()</methodname> and <methodname>end()</methodname> methods iterator incrementing, "
"like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2620(programlisting)
#, no-wrap
msgid ""
"typedef Gtk::TreeModel::Children type_children; //minimise code length.\n"
"type_children children = refModel-&gt;children();\n"
"for(type_children::iterator iter = children.begin();\n"
"    iter != children.end(); ++iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"  //Do something with the row - see above for set/get.\n"
"}"
msgstr ""
"typedef Gtk::TreeModel::Children type_children; //minimise code length.\n"
"type_children children = refModel-&gt;children();\n"
"for(type_children::iterator iter = children.begin();\n"
"    iter != children.end(); ++iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"  //Do something with the row - see above for set/get.\n"
"}"

#: C/gtkmm-tutorial-in.xml:2630(title)
msgid "Row children"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2635(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::Children children = row.children();"
msgstr "Gtk::TreeModel::Children children = row.children();"

#: C/gtkmm-tutorial-in.xml:2631(para)
msgid ""
"When using a <classname>Gtk::TreeStore</classname>, the rows can have child rows, which can have their own children in turn. Use "
"<methodname>Gtk::TreeModel::Row::children()</methodname> to get the container of child <classname>Row</classname>s: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2642(title)
msgid "The Selection"
msgstr "Die Auswahl"

#: C/gtkmm-tutorial-in.xml:2643(para)
msgid ""
"To find out what rows the user has selected, get the <classname>Gtk::TreeView::Selection</classname> object from the <classname>TreeView</"
"classname>, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2648(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"    m_TreeView.get_selection();"
msgstr ""
"Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"    m_TreeView.get_selection();"

#: C/gtkmm-tutorial-in.xml:2652(title)
msgid "Single or multiple selection"
msgstr "Einfache oder mehrfache Auswahl"

#: C/gtkmm-tutorial-in.xml:2656(programlisting)
#, no-wrap
msgid "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"
msgstr "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"

#: C/gtkmm-tutorial-in.xml:2653(para)
msgid "By default, only single rows can be selected, but you can allow multiple selection by setting the mode, like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2661(title)
msgid "The selected rows"
msgstr "Die ausgewählten Zeilen"

#: C/gtkmm-tutorial-in.xml:2662(para)
msgid "For single-selection, you can just call <methodname>get_selected()</methodname>, like so:"
msgstr "Für Einfachauswahlen können Sie einfach <methodname>get_selected()</methodname> folgendermaßen aufrufen:"

#: C/gtkmm-tutorial-in.xml:2666(programlisting)
#, no-wrap
msgid ""
"TreeModel::iterator iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) //If anything is selected\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""
"TreeModel::iterator iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) //If anything is selected\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"

#: C/gtkmm-tutorial-in.xml:2673(para)
msgid ""
"For multiple-selection, you need to define a callback, and give it to <methodname>selected_foreach()</methodname>, "
"<methodname>selected_foreach_path()</methodname>, or <methodname>selected_foreach_iter()</methodname>, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2679(programlisting)
#, no-wrap
msgid ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::iterator&amp; iter)\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::iterator&amp; iter)\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"

#: C/gtkmm-tutorial-in.xml:2692(title)
msgid "The \"changed\" signal"
msgstr "Das »changed«-Signal"

#: C/gtkmm-tutorial-in.xml:2693(para)
msgid "To respond to the user clicking on a row or range of rows, connect to the signal like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2697(programlisting)
#, no-wrap
#| msgid ""
#| "refTreeSelection-&gt;signal_changed().connect(\n"
#| "    sigc::mem_fun(*this, &amp;Example_StockBrowser::on_selection_changed)\n"
#| ");"
msgid ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)\n"
");"
msgstr ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)\n"
");"

#: C/gtkmm-tutorial-in.xml:2703(title)
msgid "Preventing row selection"
msgstr "Verhindern der Zeilenauswahl"

#: C/gtkmm-tutorial-in.xml:2704(para)
msgid ""
"Maybe the user should not be able to select every item in your list or tree. For instance, in the gtk-demo, you can select a demo to see the "
"source code, but it doesn't make any sense to select a demo category."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2709(para)
msgid ""
"To control which rows can be selected, use the <methodname>set_select_function()</methodname> method, providing a <classname>sigc::slot</"
"classname> callback. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2714(programlisting)
#, no-wrap
msgid ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"
msgstr ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"

#: C/gtkmm-tutorial-in.xml:2716(para)
msgid "and then"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2719(programlisting)
#, no-wrap
msgid ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"
msgstr ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"

#: C/gtkmm-tutorial-in.xml:2729(title)
msgid "Changing the selection"
msgstr "Ändern der Auswahl"

#: C/gtkmm-tutorial-in.xml:2730(para)
msgid "To change the selection, specify a <classname>Gtk::TreeModel::iterator</classname> or <classname>Gtk::TreeModel::Row</classname>, like so:"
msgstr ""
"Um die Auswahl zu ändern, geben Sie einen <classname>Gtk::TreeModel::iterator</classname> oder <classname>Gtk::TreeModel::Row</classname> "
"folgendermaßen an:"

#: C/gtkmm-tutorial-in.xml:2735(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row);"
msgstr ""
"Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row);"

#: C/gtkmm-tutorial-in.xml:2738(para)
msgid "or"
msgstr "oder"

#: C/gtkmm-tutorial-in.xml:2741(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"
msgstr ""
"Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"

#: C/gtkmm-tutorial-in.xml:2750(title)
msgid "Sorting"
msgstr "Sortierung"

#: C/gtkmm-tutorial-in.xml:2751(para)
msgid ""
"The standard tree models (<classname>TreeStore</classname> and <classname>ListStore</classname>) derive from <classname>TreeSortable</"
"classname>, so they offer sorting functionality. For instance, call <methodname>set_sort_column()</methodname>, to sort the model by the "
"specified column. Or supply a callback function to <methodname>set_sort_func()</methodname> to implement a more complicated sorting algorithm."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2755(ulink)
msgid "TreeSortable Reference"
msgstr "TreeSortable-Referenz"

#: C/gtkmm-tutorial-in.xml:2758(title)
msgid "Sorting by clicking on columns"
msgstr "Sortierung durch Anklicken von Spalten"

#: C/gtkmm-tutorial-in.xml:2759(para)
msgid ""
"So that a user can click on a <classname>TreeView</classname>'s column header to sort the <classname>TreeView</classname>'s contents, call "
"<methodname>Gtk::TreeView::Column::set_sort_column()</methodname>, supplying the model column on which model should be sorted when the header "
"is clicked. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2762(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeView::Column* pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"
msgstr ""
"Gtk::TreeView::Column* pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"

#: C/gtkmm-tutorial-in.xml:2768(title)
msgid "Independently sorted views of the same model"
msgstr "Unabhängig sortierte Ansichten des gleichen Modells"

#: C/gtkmm-tutorial-in.xml:2769(para)
msgid ""
"The <classname>TreeView</classname> already allows you to show the same <classname>TreeModel</classname> in two <classname>TreeView</classname> "
"widgets. If you need one of these TreeViews to sort the model differently than the other then you should use a <classname>TreeModelSort</"
"classname> instead of just, for instance, <methodname>Gtk::TreeViewModel::set_sort_column()</methodname>. <classname>TreeModelSort</classname> "
"is a model that contains another model, presenting a sorted version of that model. For instance, you might add a sorted version of a model to a "
"<classname>TreeView</classname> like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2772(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TreeModelSort&gt; sorted_model =\n"
"    Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TreeModelSort&gt; sorted_model =\n"
"    Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"

#: C/gtkmm-tutorial-in.xml:2777(para)
msgid ""
"Note, however, that the TreeView will provide iterators to the sorted model. You must convert them to iterators to the underlying child model "
"in order to perform actions on that model. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2779(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"      m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    Gtk::TreeModel::iterator sorted_iter =\n"
"        m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      Gtk::TreeModel::iterator iter =\n"
"          m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"
msgstr ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"      m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    Gtk::TreeModel::iterator sorted_iter =\n"
"        m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      Gtk::TreeModel::iterator iter =\n"
"          m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"

#: C/gtkmm-tutorial-in.xml:2796(ulink)
msgid "TreeModelSort Reference"
msgstr "TreeModelSort-Referenz"

#: C/gtkmm-tutorial-in.xml:2802(title) C/gtkmm-tutorial-in.xml:2909(title) C/gtkmm-tutorial-in.xml:3576(title) C/gtkmm-tutorial-in.xml:4616(title)
#: C/gtkmm-tutorial-in.xml:4780(title)
msgid "Drag and Drop"
msgstr "Ziehen und Ablegen"

#: C/gtkmm-tutorial-in.xml:2803(para)
msgid ""
"<classname>Gtk::TreeView</classname> already implements simple drag-and-drop when used with the <classname>Gtk::ListStore</classname> or "
"<classname>Gtk::TreeStore</classname> models. If necessary, it also allows you to implement more complex behaviour when items are dragged and "
"dropped, using the normal <link linkend=\"chapter-draganddrop\">Drag and Drop</link> API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2812(title)
msgid "Reorderable rows"
msgstr "Neu sortierbare Zeilen"

#: C/gtkmm-tutorial-in.xml:2813(para)
msgid ""
"If you call <methodname>Gtk::TreeView::set_reorderable()</methodname> then your TreeView's items can be moved within the treeview itself. This "
"is demonstrated in the <classname>TreeStore</classname> example."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2818(para)
msgid ""
"However, this does not allow you any control of which items can be dragged, and where they can be dropped. If you need that extra control then "
"you might create a derived <literal>Gtk::TreeModel</literal> from <literal>Gtk::TreeStore</literal> or <literal>Gtk::ListStore</literal> and "
"override the <literal>Gtk::TreeDragSource::row_draggable()</literal> and <literal>Gdk::TreeDragDest::row_drop_possible()</literal> virtual "
"methods. You can examine the <literal>Gtk::TreeModel::Path</literal>s provided and allow or disallow dragging or dropping by returning "
"<literal>true</literal> or <literal>false</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2819(para)
msgid "This is demonstrated in the drag_and_drop example."
msgstr "Dies wird im drag_and_drop-Beispiel demonstriert."

#: C/gtkmm-tutorial-in.xml:2825(title) C/gtkmm-tutorial-in.xml:2931(title)
msgid "Popup Context Menu"
msgstr "Popup-Kontextmenü"

#: C/gtkmm-tutorial-in.xml:2826(para)
msgid ""
"Lots of people need to implement right-click context menus for <classname>TreeView</classname>'s so we will explain how to do that here to save "
"you some time. Apart from one or two points, it's much the same as a normal context menu, as described in the <link linkend=\"sec-menus-popup"
"\">menus chapter</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2835(title)
msgid "Handling <literal>button_press_event</literal>"
msgstr "Umgang mit <literal>button_press_event</literal>"

#: C/gtkmm-tutorial-in.xml:2836(para)
msgid ""
"To detect a click of the right mouse button, you need to handle the <literal>button_press_event</literal> signal, and check exactly which "
"button was pressed. Because the <classname>TreeView</classname> normally handles this signal completely, you need to either override the "
"default signal handler in a derived <classname>TreeView</classname> class, or use <methodname>connect_notify()</methodname> instead of "
"<methodname>connect()</methodname>. You probably also want to call the default handler before doing anything else, so that the right-click will "
"cause the row to be selected first."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2846(para)
msgid "This is demonstrated in the Popup Context Menu example."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2851(title) C/gtkmm-tutorial-in.xml:3339(title) C/gtkmm-tutorial-in.xml:3512(title) C/gtkmm-tutorial-in.xml:4935(title)
msgid "Examples"
msgstr "Beispiele"

#: C/gtkmm-tutorial-in.xml:2853(title)
msgid "ListStore"
msgstr "ListStore"

#: C/gtkmm-tutorial-in.xml:2854(para)
msgid "This example has a <classname>Gtk::TreeView</classname> widget, with a <classname>Gtk::ListStore</classname> model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2871(title)
msgid "TreeStore"
msgstr "TreeStore"

#: C/gtkmm-tutorial-in.xml:2873(para)
msgid ""
"This example is very similar to the <classname>ListStore</classname> example, but uses a <classname>Gtk::TreeStore</classname> model instead, "
"and adds children to the rows."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2892(para)
msgid ""
"This example is identical to the <classname>ListStore</classname> example, but it uses <methodname>TreeView::append_column_editable()</"
"methodname> instead of <methodname>TreeView::append_column()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2899(title)
msgid "TreeView - Editable Cells"
msgstr "TreeView - Bearbeitbare Zellen"

#: C/gtkmm-tutorial-in.xml:2911(para)
msgid ""
"This example is much like the <classname>TreeStore</classname> example, but has 2 extra columns to indicate whether the row can be dragged, and "
"whether it can receive drag-and-dropped rows. It uses a derived <classname>Gtk::TreeStore</classname> which overrides the virtual functions as "
"described in the <link linkend=\"sec-treeview-draganddrop\">TreeView Drag and Drop</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2921(title)
msgid "TreeView - Drag And Drop"
msgstr "TreeView - Ziehen und Ablegen"

#: C/gtkmm-tutorial-in.xml:2933(para)
msgid ""
"This example is much like the <classname>ListStore</classname> example, but derives a custom <classname>TreeView</classname> in order to "
"override the <literal>button_press_event</literal>, and also to encapsulate the tree model code in our derived class. See the <link linkend="
"\"sec-treeview-contextmenu\">TreeView Popup Context Menu</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2943(title)
msgid "TreeView - Popup Context Menu"
msgstr "TreeView - Aufklappendes Kontextmenü"

#: C/gtkmm-tutorial-in.xml:2960(title)
msgid "Combo Boxes"
msgstr "Kombinierte Auswahlfelder"

#: C/gtkmm-tutorial-in.xml:2962(para)
msgid ""
"The <classname>ComboBox</classname> widget offers a list (or tree) of choices in a dropdown menu. If appropriate, it can show extra information "
"about each item, such as text, a picture, a checkbox, or a progress bar. The <classname>ComboBox</classname> widget usually restricts the user "
"to the available choices, but it can optionally have an <classname>Entry</classname>, allowing the user to enter arbitrary text if none of the "
"available choices are suitable."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2965(para)
msgid ""
"The list is provided via a <classname>TreeModel</classname>, and columns from this model are added to the ComboBox's view with the "
"<methodname>ComboBox::pack_start()</methodname> method. This provides flexibility and compile-time type-safety, but the "
"<classname>ComboBoxText</classname> class provides a simpler text-based specialization in case that flexibility is not required."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2971(title)
msgid "The model"
msgstr "Das Modell"

#: C/gtkmm-tutorial-in.xml:2972(para)
msgid ""
"The model for a ComboBox can be defined and filled exactly as for a <classname>TreeView</classname>. For instance, you might derive a ComboBox "
"class with one integer and one text column, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2974(programlisting)
#, no-wrap
msgid ""
"ModelColumns()\n"
"{ add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"
msgstr ""
"ModelColumns()\n"
"{ add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"

#: C/gtkmm-tutorial-in.xml:2983(para)
msgid ""
"After appending rows to this model, you should provide the model to the <classname>ComboBox</classname> with the <methodname>set_model()</"
"methodname> method. Then use the <methodname>pack_start()</methodname> or <methodname>pack_end()</methodname> methods to specify what columns "
"will be displayed in the ComboBox. As with the TreeView you may either use the default cell renderer by passing the <classname>TreeModelColumn</"
"classname> to the pack methods, or you may instantiate a specific <classname>CellRenderer</classname> and specify a particular mapping with "
"either <methodname>add_attribute()</methodname> or <methodname>set_cell_data_func()</methodname>. Note that these methods are in the "
"<classname>CellLayout</classname> base class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2987(title)
msgid "The chosen item"
msgstr "Das gewählte Objekt"

#: C/gtkmm-tutorial-in.xml:2988(para)
msgid ""
"To discover what item, if any, the user has chosen from the ComboBox, call <methodname>ComboBox::get_active()</methodname>. This returns a "
"<classname>TreeModel::iterator</classname> that you can dereference to a <classname>Row</classname> in order to read the values in your "
"columns. For instance, you might read an integer ID value from the model, even though you have chosen only to show the human-readable "
"description in the ComboBox. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2990(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"\n"
"  //Get the data for the selected row, using our knowledge\n"
"  //of the tree model:\n"
"  int id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); //Your own function.\n"
"}\n"
"else\n"
"  set_nothing_chosen(); //Your own function."
msgstr ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"\n"
"  //Get the data for the selected row, using our knowledge\n"
"  //of the tree model:\n"
"  int id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); //Your own function.\n"
"}\n"
"else\n"
"  set_nothing_chosen(); //Your own function."

#: C/gtkmm-tutorial-in.xml:3005(title) C/gtkmm-tutorial-in.xml:3061(title)
msgid "Responding to changes"
msgstr "Reaktion auf Änderungen"

#: C/gtkmm-tutorial-in.xml:3006(para)
msgid ""
"You might need to react to every change of selection in the ComboBox, for instance to update other widgets. To do so, you should handle the "
"<literal>changed</literal> signal. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3009(programlisting)
#, no-wrap
msgid ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"
msgstr ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"

#: C/gtkmm-tutorial-in.xml:3013(title) C/gtkmm-tutorial-in.xml:3097(title)
msgid "Full Example"
msgstr "Vollständiges Beispiel"

#: C/gtkmm-tutorial-in.xml:3016(title)
msgid "ComboBox"
msgstr "ComboBox"

#: C/gtkmm-tutorial-in.xml:3026(title) C/gtkmm-tutorial-in.xml:3110(title)
msgid "Simple Text Example"
msgstr "Einfaches Textbeispiel"

#: C/gtkmm-tutorial-in.xml:3029(title)
#| msgid "ComboBoxEntryText"
msgid "ComboBoxText"
msgstr "ComboBoxText"

#: C/gtkmm-tutorial-in.xml:3040(title)
msgid "ComboBox with an Entry"
msgstr "ComboBox mit Eingabe"

#: C/gtkmm-tutorial-in.xml:3042(para)
msgid ""
"A <classname>ComboBox</classname> may contain an <classname>Entry</classname> widget for entering of arbitrary text, by specifying "
"<literal>true</literal> for the constructor's <literal>has_entry</literal> parameter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3045(title)
msgid "The text column"
msgstr "Die Textspalte"

#: C/gtkmm-tutorial-in.xml:3047(programlisting)
#, no-wrap
#| msgid "m_combo.set_text_column(m_columns.m_col_name);"
msgid "m_combo.set_entry_text_column(m_columns.m_col_name);"
msgstr "m_combo.set_entry_text_column(m_columns.m_col_name);"

#: C/gtkmm-tutorial-in.xml:3046(para)
msgid ""
"So that the <classname>Entry</classname> can interact with the drop-down list of choices, you must specify which of your model columns is the "
"text column, with <methodname>set_entry_text_column()</methodname>. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3049(para)
msgid "When you select a choice from the drop-down menu, the value from this column will be placed in the <classname>Entry</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3055(title)
msgid "The entry"
msgstr "Der Eintrag"

#: C/gtkmm-tutorial-in.xml:3056(para)
msgid ""
"Because the user may enter arbitrary text, an active model row isn't enough to tell us what text the user has entered. Therefore, you should "
"retrieve the <classname>Entry</classname> widget with the <methodname>ComboBox::get_entry()</methodname> method and call "
"<methodname>get_text()</methodname> on that."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3070(programlisting)
#, no-wrap
msgid ""
"Gtk::Entry* entry = m_Combo.get_entry();\n"
"if (entry)\n"
"{\n"
"  // The Entry shall receive focus-out events.\n"
"  entry-&gt;add_events(Gdk::FOCUS_CHANGE_MASK);\n"
"\n"
"  // Alternatively you can connect to m_Combo.signal_changed().\n"
"  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_changed) );\n"
"\n"
"  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_activate) );\n"
"\n"
"  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_focus_out_event) );\n"
"}"
msgstr ""
"Gtk::Entry* entry = m_Combo.get_entry();\n"
"if (entry)\n"
"{\n"
"  // The Entry shall receive focus-out events.\n"
"  entry-&gt;add_events(Gdk::FOCUS_CHANGE_MASK);\n"
"\n"
"  // Alternatively you can connect to m_Combo.signal_changed().\n"
"  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_changed) );\n"
"\n"
"  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_activate) );\n"
"\n"
"  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_focus_out_event) );\n"
"}"

#: C/gtkmm-tutorial-in.xml:3062(para)
msgid ""
"When the user enters arbitrary text, it may not be enough to connect to the <literal>changed</literal> signal, which is emitted for every typed "
"character. It is not emitted when the user presses the Enter key. Pressing the Enter key or moving the keyboard focus to another widget may "
"signal that the user has finished entering text. To be notified of these events, connect to the <classname>Entry</classname>'s "
"<literal>activate</literal> and <literal>focus_out_event</literal> signals, like so <placeholder-1/> The <literal>changed</literal> signals of "
"<classname>ComboBox</classname> and <classname>Entry</classname> are both emitted for every change. It doesn't matter which one you connect to. "
"But only <classname>Entry</classname>'s <literal>focus_out_event</literal> signal is useful here."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3091(para)
msgid "X events are described in more detail in the <link linkend=\"sec-xeventsignals\">X Event signals</link> section in the appendix."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3100(title)
msgid "ComboBox with Entry"
msgstr "ComboBox mit Eintrag"

#: C/gtkmm-tutorial-in.xml:3113(title)
#| msgid "ComboBox with an Entry"
msgid "ComboBoxText with Entry"
msgstr "ComboBoxText mit Eintrag"

#: C/gtkmm-tutorial-in.xml:3132(title) C/gtkmm-tutorial-in.xml:3344(title)
msgid "TextView"
msgstr "TextView"

#: C/gtkmm-tutorial-in.xml:3133(para)
msgid ""
"The <classname>TextView</classname> widget can be used to display and edit large amounts of formatted text. Like the <classname>TreeView</"
"classname>, it has a model/view design. In this case the <classname>TextBuffer</classname> is the model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3141(title)
msgid "The Buffer"
msgstr "Der Puffer"

#: C/gtkmm-tutorial-in.xml:3142(para)
msgid ""
"<classname>Gtk::TextBuffer</classname> is a model containing the data for the <classname>Gtk::TextView</classname>, like the <classname>Gtk::"
"TreeModel</classname> used by <classname>Gtk::TreeView</classname>. This allows two or more <classname>Gtk::TextView</classname>s to share the "
"same <classname>TextBuffer</classname>, and allows those TextBuffers to be displayed slightly differently. Or you could maintain several "
"<classname>Gtk::TextBuffer</classname>s and choose to display each one at different times in the same <classname>Gtk::TextView</classname> "
"widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3152(para)
msgid ""
"The <classname>TextView</classname> creates its own default <classname>TextBuffer</classname>, which you can access via the "
"<methodname>get_buffer()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3161(title)
msgid "Iterators"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3167(title)
msgid "Tags and Formatting"
msgstr "Tags und Formatierung"

#: C/gtkmm-tutorial-in.xml:3170(title)
msgid "Tags"
msgstr "Tags"

#: C/gtkmm-tutorial-in.xml:3171(para)
msgid ""
"To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then "
"apply that tag to the region of text. For instance, to define the tag and its properties:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3174(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch =\n"
"    Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch =\n"
"    Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"

#: C/gtkmm-tutorial-in.xml:3177(para)
msgid ""
"You can specify a name for the <classname>Tag</classname> when using the <methodname>create()</methodname> method, but it is not necessary."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3182(para)
msgid "The <classname>Tag</classname> class has many other properties."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3191(title)
msgid "TagTable"
msgstr "TagTable"

#: C/gtkmm-tutorial-in.xml:3193(para)
msgid ""
"Each <classname>Gtk::TextBuffer</classname> uses a <classname>Gtk::TextBuffer::TagTable</classname>, which contains the <classname>Tag</"
"classname>s for that buffer. 2 or more <classname>TextBuffer</classname>s may share the same <classname>TagTable</classname>. When you create "
"<classname>Tag</classname>s you should add them to the <classname>TagTable</classname>. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3201(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable =\n"
"    Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,\n"
"//for use after creation of the buffer.\n"
"Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer =\n"
"    Gtk::TextBuffer::create(refTagTable);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable =\n"
"    Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,\n"
"//for use after creation of the buffer.\n"
"Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer =\n"
"    Gtk::TextBuffer::create(refTagTable);"

#: C/gtkmm-tutorial-in.xml:3209(para)
msgid ""
"You can also use <methodname>get_tag_table()</methodname> to get, and maybe modify, the <classname>TextBuffer</classname>'s default "
"<classname>TagTable</classname> instead of creating one explicitly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3220(title)
msgid "Applying Tags"
msgstr "Anwenden von Tags"

#: C/gtkmm-tutorial-in.xml:3221(para)
msgid ""
"If you have created a <classname>Tag</classname> and added it to the <classname>TagTable</classname>, you may apply that tag to part of the "
"<classname>TextBuffer</classname> so that some of the text is displayed with that formatting. You define the start and end of the range of text "
"by specifying <classname>Gtk::TextBuffer::iterator</classname>s. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3228(programlisting)
#, no-wrap
msgid "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"
msgstr "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"

#: C/gtkmm-tutorial-in.xml:3231(programlisting)
#, no-wrap
msgid "refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"
msgstr "refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"

#: C/gtkmm-tutorial-in.xml:3229(para)
msgid "Or you could specify the tag when first inserting the text: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3234(para)
msgid ""
"You can apply more than one <classname>Tag</classname> to the same text, by using <methodname>apply_tag()</methodname> more than once, or by "
"using <methodname>insert_with_tags()</methodname>. The <classname>Tag</classname>s might specify different values for the same properties, but "
"you can resolve these conflicts by using <methodname>Tag::set_priority()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3246(title)
msgid "Marks"
msgstr "Markierungen"

#: C/gtkmm-tutorial-in.xml:3247(para)
msgid ""
"<classname>TextBuffer</classname> iterators are generally invalidated when the text changes, but you can use a <classname>Gtk::TextBuffer::"
"Mark</classname> to remember a position in these situations. For instance,"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3252(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark =\n"
"    refBuffer-&gt;create_mark(iter);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark =\n"
"    refBuffer-&gt;create_mark(iter);"

#: C/gtkmm-tutorial-in.xml:3255(para)
msgid ""
"You can then use the <methodname>get_iter()</methodname> method later to create an iterator for the <classname>Mark</classname>'s new position."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3260(para)
msgid ""
"There are two built-in <classname>Mark</classname>s - <literal>insert</literal> and <literal>selection_bound</literal>, which you can access "
"with <classname>TextBuffer</classname>'s <methodname>get_insert()</methodname> and <methodname>get_selection_bound()</methodname> methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3273(para)
msgid ""
"As mentioned above, each <classname>TextView</classname> has a <classname>TextBuffer</classname>, and one or more <classname>TextView</"
"classname>s can share the same <classname>TextBuffer</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3280(para)
msgid ""
"Like the <classname>TreeView</classname>, you should probably put your <classname>TextView</classname> inside a <classname>ScrolledWindow</"
"classname> to allow the user to see and move around the whole text area with scrollbars."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3290(title)
msgid "Default formatting"
msgstr "Standardformatierung"

#: C/gtkmm-tutorial-in.xml:3291(para)
msgid ""
"<classname>TextView</classname> has various methods which allow you to change the presentation of the buffer for this particular view. Some of "
"these may be overridden by the <classname>Gtk::TextTag</classname>s in the buffer, if they specify the same things. For instance, "
"<methodname>set_left_margin()</methodname>, <methodname>set_right_margin()</methodname>, <methodname>set_indent()</methodname>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3302(title)
msgid "Scrolling"
msgstr "Rollen"

#: C/gtkmm-tutorial-in.xml:3303(para)
msgid ""
"<classname>Gtk::TextView</classname> has various <methodname>scroll_to_*()</methodname> methods. These allow you to ensure that a particular "
"part of the text buffer is visible. For instance, your application's Find feature might use <methodname>Gtk::TextView::scroll_to_iter()</"
"methodname> to show the found text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3318(title)
msgid "Widgets and ChildAnchors"
msgstr "Widgets und ChildAnchors"

#: C/gtkmm-tutorial-in.xml:3319(para)
msgid ""
"You can embed widgets, such as <classname>Gtk::Button</classname>s, in the text. Each such child widget needs a <classname>ChildAnchor</"
"classname>. ChildAnchors are associated with <classname>iterators</classname>. For instance, to create a child anchor at a particular position, "
"use <methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3326(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor =\n"
"    refBuffer-&gt;create_child_anchor(iter);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor =\n"
"    refBuffer-&gt;create_child_anchor(iter);"

#: C/gtkmm-tutorial-in.xml:3329(para)
msgid "Then, to add a widget at that position, use <methodname>Gtk::TextView::add_child_at_anchor()</methodname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3333(programlisting)
#, no-wrap
msgid "m_TextView.add_child_at_anchor(m_Button, refAnchor);"
msgstr "m_TextView.add_child_at_anchor(m_Button, refAnchor);"

#: C/gtkmm-tutorial-in.xml:3359(title)
msgid "Menus and Toolbars"
msgstr "Menüs und Werkzeugleisten"

#: C/gtkmm-tutorial-in.xml:3361(para)
msgid ""
"There are specific APIs for Menus and toolbars, but you should usually deal with them together, using the <classname>UIManager</classname> to "
"define <classname>Action</classname>s which you can then arrange in menus and toolbars. In this way you can handle activation of the action "
"instead of responding to the menu and toolbar items separately. And you can enable or disable both the menu and toolbar item via the action."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3369(para)
msgid ""
"This involves the use of the <classname>Gtk::ActionGroup</classname>, <classname>Gtk::Action</classname>, and <classname>UIManager</classname> "
"classes, all of which should be instantiated via their <methodname>create()</methodname> methods, which return <classname>RefPtr</classname>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3378(title)
msgid "Actions"
msgstr "Aktionen"

#: C/gtkmm-tutorial-in.xml:3379(para)
msgid ""
"First create the <classname>Action</classname>s and add them to an <classname>ActionGroup</classname>, with <methodname>ActionGroup::add()</"
"methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3385(para)
msgid "The arguments to <methodname>Action::create()</methodname> specify the action's name and how it will appear in menus and toolbars."
msgstr ""
"Die Argumente zu <methodname>Action::create()</methodname> geben den Namen der Aktion an, und wie es in Menüs und Werkzeugleisten erscheint."

#: C/gtkmm-tutorial-in.xml:3389(para)
msgid ""
"You can also specify a signal handler when calling <methodname>ActionGroup::add()</methodname>. This signal handler will be called when the "
"action is activated via either a menu item or a toolbar button."
msgstr ""
"Sie können auch einen Signalhandler beim Aufruf von <methodname>ActionGroup::add()</methodname> angeben. Dieser Signalhandler wird aufgerufen, "
"wenn eine Aktion über das Menü oder einen Werkzeugleistenknopf aktiviert wird."

#: C/gtkmm-tutorial-in.xml:3394(para)
msgid "Note that you must specify actions for sub menus as well as menu items."
msgstr "Beachten Sie, dass Sie Aktionen für Untermenüs wie auch für Menüeinträge angeben müssen."

#: C/gtkmm-tutorial-in.xml:3396(para)
msgid "For instance:"
msgstr "Zum Beispiel:"

#: C/gtkmm-tutorial-in.xml:3398(programlisting)
#, no-wrap
#| msgid ""
#| "m_refActionGroup = Gtk::ActionGroup::create();\n"
#| "\n"
#| "m_refActionGroup-&gt;add( Gtk::Action::create(\"MenuFile\", \"_File\") );\n"
#| "m_refActionGroup-&gt;add( Gtk::Action::create(\"New\", Gtk::Stock::NEW),\n"
#| "  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );\n"
#| "m_refActionGroup-&gt;add( Gtk::Action::create(\"ExportData\", \"Export Data\"),\n"
#| "  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );\n"
#| "m_refActionGroup-&gt;add( Gtk::Action::create(\"Quit\", Gtk::Stock::QUIT),\n"
#| "  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );"
msgid ""
"m_refActionGroup = Gtk::ActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"MenuFile\", \"_File\") );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"New\", \"_New\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"ExportData\", \"Export Data\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"Quit\", \"_Quit\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );"
msgstr ""
"m_refActionGroup = Gtk::ActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"MenuFile\", \"_File\") );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"New\", \"_New\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"ExportData\", \"Export Data\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"Quit\", \"_Quit\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );"

#: C/gtkmm-tutorial-in.xml:3408(para)
msgid ""
"Note that this is where we specify the names of the actions as they will be seen by users in menus and toolbars. Therefore, this is where you "
"should make strings translatable, by putting them inside the _() macro."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3413(title)
msgid "UIManager"
msgstr "UIManager"

#: C/gtkmm-tutorial-in.xml:3414(para)
msgid ""
"Next you should create a <classname>UIManager</classname> and add the <classname>ActionGroup</classname> to the <classname>UIManager</"
"classname> with <methodname>insert_action_group()</methodname> At this point is also a good idea to tell the parent window to respond to the "
"specified keyboard shortcuts, by using <methodname>add_accel_group()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3422(para) C/gtkmm-tutorial-in.xml:4856(para)
msgid "For instance,"
msgstr "Zum Beispiel,"

#: C/gtkmm-tutorial-in.xml:3424(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager =\n"
"    Gtk::UIManager::create();\n"
"m_refUIManager-&gt;insert_action_group(m_refActionGroup);\n"
"add_accel_group(m_refUIManager-&gt;get_accel_group());"
msgstr ""
"Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager =\n"
"    Gtk::UIManager::create();\n"
"m_refUIManager-&gt;insert_action_group(m_refActionGroup);\n"
"add_accel_group(m_refUIManager-&gt;get_accel_group());"

#: C/gtkmm-tutorial-in.xml:3428(para)
msgid ""
"Then, you can define the actual visible layout of the menus and toolbars, and add the UI layout to the <classname>UIManager</classname>. This "
"\"ui string\" uses an XML format, in which you should mention the names of the actions that you have already created. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3434(programlisting)
#, no-wrap
msgid ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;menubar name='MenuBar'&gt;\"\n"
"    \"    &lt;menu action='MenuFile'&gt;\"\n"
"    \"      &lt;menuitem action='New'/&gt;\"\n"
"    \"      &lt;menuitem action='Open'/&gt;\"\n"
"    \"      &lt;separator/&gt;\"\n"
"    \"      &lt;menuitem action='Quit'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"    &lt;menu action='MenuEdit'&gt;\"\n"
"    \"      &lt;menuitem action='Cut'/&gt;\"\n"
"    \"      &lt;menuitem action='Copy'/&gt;\"\n"
"    \"      &lt;menuitem action='Paste'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"  &lt;/menubar&gt;\"\n"
"    \"  &lt;toolbar  name='ToolBar'&gt;\"\n"
"    \"    &lt;toolitem action='Open'/&gt;\"\n"
"    \"    &lt;toolitem action='Quit'/&gt;\"\n"
"    \"  &lt;/toolbar&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"
msgstr ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;menubar name='MenuBar'&gt;\"\n"
"    \"    &lt;menu action='MenuFile'&gt;\"\n"
"    \"      &lt;menuitem action='New'/&gt;\"\n"
"    \"      &lt;menuitem action='Open'/&gt;\"\n"
"    \"      &lt;separator/&gt;\"\n"
"    \"      &lt;menuitem action='Quit'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"    &lt;menu action='MenuEdit'&gt;\"\n"
"    \"      &lt;menuitem action='Cut'/&gt;\"\n"
"    \"      &lt;menuitem action='Copy'/&gt;\"\n"
"    \"      &lt;menuitem action='Paste'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"  &lt;/menubar&gt;\"\n"
"    \"  &lt;toolbar  name='ToolBar'&gt;\"\n"
"    \"    &lt;toolitem action='Open'/&gt;\"\n"
"    \"    &lt;toolitem action='Quit'/&gt;\"\n"
"    \"  &lt;/toolbar&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"

#: C/gtkmm-tutorial-in.xml:3457(para)
msgid ""
"Remember that these names are just the identifiers that we used when creating the actions. They are not the text that the user will see in the "
"menus and toolbars. We provided those human-readable names when we created the actions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3458(para)
msgid ""
"To instantiate a <classname>Gtk::MenuBar</classname> or <classname>Gtk::Toolbar</classname> which you can actually show, you should use the "
"<methodname>UIManager::get_widget()</methodname> method, and then add the widget to a container. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3464(programlisting)
#, no-wrap
msgid ""
"Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget(\"/MenuBar\");\n"
"pBox-&gt;add(*pMenuBar, Gtk::PACK_SHRINK);"
msgstr ""
"Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget(\"/MenuBar\");\n"
"pBox-&gt;add(*pMenuBar, Gtk::PACK_SHRINK);"

#: C/gtkmm-tutorial-in.xml:3470(title)
msgid "Popup Menus"
msgstr "Kontextmenüs"

#: C/gtkmm-tutorial-in.xml:3471(para)
msgid ""
"<classname>Menus</classname> are normally just added to a window, but they can also be displayed temporarily as the result of a mouse button "
"click. For instance, a context menu might be displayed when the user clicks their right mouse button."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3478(para)
msgid "The UI layout for a popup menu should use the <literal>popup</literal> node. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3480(programlisting)
#, no-wrap
msgid ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;popup name='PopupMenu'&gt;\"\n"
"    \"    &lt;menuitem action='ContextEdit'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextProcess'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextRemove'/&gt;\"\n"
"    \"  &lt;/popup&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"
msgstr ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;popup name='PopupMenu'&gt;\"\n"
"    \"    &lt;menuitem action='ContextEdit'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextProcess'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextRemove'/&gt;\"\n"
"    \"  &lt;/popup&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"

#: C/gtkmm-tutorial-in.xml:3491(para)
msgid ""
"To show the popup menu, use <classname>Gtk::Menu</classname>'s <methodname>popup()</methodname> method, providing the button identifier and the "
"time of activation, as provided by the <literal>button_press_event</literal> signal, which you will need to handle anyway. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3497(programlisting)
#, no-wrap
msgid ""
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;\n"
"      (event-&gt;button == 3) )\n"
"  {\n"
"    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; //It has been handled.\n"
"  }\n"
"  else\n"
"    return false;\n"
"}"
msgstr ""
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;\n"
"      (event-&gt;button == 3) )\n"
"  {\n"
"    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; //It has been handled.\n"
"  }\n"
"  else\n"
"    return false;\n"
"}"

#: C/gtkmm-tutorial-in.xml:3514(title)
msgid "Main Menu example"
msgstr "Hauptmenü-Beispiel"

#: C/gtkmm-tutorial-in.xml:3517(title)
msgid "Main Menu"
msgstr "Hauptmenü"

#: C/gtkmm-tutorial-in.xml:3527(title)
msgid "Popup Menu example"
msgstr "Kontextmenü-Beispiel"

#: C/gtkmm-tutorial-in.xml:3530(title)
msgid "Popup Menu"
msgstr "Kontextmenü"

#: C/gtkmm-tutorial-in.xml:3545(title) C/gtkmm-tutorial-in.xml:3586(title)
msgid "ToolPalette"
msgstr "ToolPalette"

#: C/gtkmm-tutorial-in.xml:3547(para)
msgid ""
"A <classname>ToolPalette</classname> is similar to a <classname>Toolbar</classname> but can contain a grid of items, categorized into groups. "
"The user may hide or expand each group. As in a toolbar, the items may be displayed as only icons, as only text, or as icons with text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3549(para)
msgid ""
"The <classname>ToolPalette</classname>'s items might be dragged or simply activated. For instance, the user might drag objects to a canvas to "
"create new items there. Or the user might click an item to activate a certain brush size in a drawing application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3550(para)
msgid ""
"<classname>ToolItemGroup</classname>s should be added to the tool palette via the base class's <function>Gtk::Container::add()</function> "
"method, for instance like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3553(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::ToolItemGroup* group_brushes =\n"
"  Gtk::manage(new Gtk::ToolItemGroup(\"Brushes\"));\n"
"m_ToolPalette.add(*group_brushes);\n"
msgstr ""
"\n"
"Gtk::ToolItemGroup* group_brushes =\n"
"  Gtk::manage(new Gtk::ToolItemGroup(\"Brushes\"));\n"
"m_ToolPalette.add(*group_brushes);\n"

#: C/gtkmm-tutorial-in.xml:3559(para)
msgid "<classname>Gtk::ToolItem</classname>s can then be added to the group. For instance, like so:"
msgstr "<classname>Gtk::ToolItem</classname>s können dann zur Gruppe hinzugefügt werden, zum Beispiel so:"

#: C/gtkmm-tutorial-in.xml:3563(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, \"Big\"));\n"
"button-&gt;set_tooltip_text(\"Big Brush);\n"
"group_brushes-&gt;insert(*button);\n"
msgstr ""
"\n"
"Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, \"Big\"));\n"
"button-&gt;set_tooltip_text(\"Big Brush);\n"
"group_brushes-&gt;insert(*button);\n"

#: C/gtkmm-tutorial-in.xml:3569(para)
msgid ""
"You might then handle the <classname>ToolButton</classname>'s <literal>clicked</literal> signal. Alternatively, you could allow the item to be "
"dragged to another widget, by calling <methodname>Gtk::ToolPalette::add_drag_dest()</methodname> and then using <methodname>Gtk::ToolPalette::"
"get_drag_item()</methodname> in the other widget's <literal>drag_data_received</literal> signal handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3571(ulink)
msgid "ToolPalette Reference"
msgstr "ToolPalette-Referenz"

#: C/gtkmm-tutorial-in.xml:3572(ulink)
msgid "ToolItemGroup Reference"
msgstr "ToolItemGroup-Referenz"

#: C/gtkmm-tutorial-in.xml:3573(ulink)
msgid "ToolItem Reference"
msgstr "ToolItem-Referenz"

#: C/gtkmm-tutorial-in.xml:3577(para)
msgid ""
"Call <methodname>add_drag_dest()</methodname> to allow items or groups to be dragged from the tool palette to a particular destination widget. "
"You can then use <methodname>get_drag_item()</methodname> to discover which ToolItem or ToolItemGroup is being dragged. You can use "
"<literal>dynamic_cast</literal> to discover whether it is an item or a group. For instance, you might use this in your "
"<literal>drag_data_received</literal> signal handler, to add a dropped item, or to show a suitable icon while dragging."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3578(para)
msgid "See the <link linkend=\"chapter-draganddrop\">Drag and Drop</link> chapter for general advice about Drag and Drop with gtkmm."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3581(title)
msgid "ToolPalette Example"
msgstr "Beispiel für ToolPalette"

#: C/gtkmm-tutorial-in.xml:3583(para)
msgid ""
"This example adds a <classname>ToolPalette</classname> and a <classname>DrawingArea</classname> to a window and allows the user to drag icons "
"from the tool palette to the drawing area. The tool palette contains several groups of items. The combo boxes allow the user to change the "
"style and orientation of the tool palette."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3599(title)
msgid "Adjustments"
msgstr "Anpassungen"

#: C/gtkmm-tutorial-in.xml:3601(para)
msgid ""
"<application>gtkmm</application> has various widgets that can be visually adjusted using the mouse or the keyboard, such as the "
"<classname>Range</classname> widgets (described in the <link linkend=\"chapter-range-widgets\">Range Widgets</link> section). There are also a "
"few widgets that display some adjustable part of a larger area, such as the <classname>Viewport</classname> widget. These widgets have "
"<classname>Gtk::Adjustment</classname> objects that express this common part of their API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3611(para)
msgid ""
"So that applications can react to changes, for instance when a user moves a scrollbar, <classname>Gtk::Adjustment</classname> has a "
"<literal>value_changed</literal> signal. You can then use the <methodname>get_value()</methodname> method to discover the new value."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3619(title)
msgid "Creating an Adjustment"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3621(para)
msgid "The <classname>Gtk::Adjustment</classname> is created by its <methodname>create()</methodname> method which is as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3626(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(\n"
"  double value,\n"
"  double lower,\n"
"  double upper,\n"
"  double step_increment = 1,\n"
"  double page_increment = 10,\n"
"  double page_size = 0);"
msgstr ""
"Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(\n"
"  double value,\n"
"  double lower,\n"
"  double upper,\n"
"  double step_increment = 1,\n"
"  double page_increment = 10,\n"
"  double page_size = 0);"

#: C/gtkmm-tutorial-in.xml:3634(para)
msgid ""
"The <parameter>value</parameter> argument is the initial value of the adjustment, usually corresponding to the topmost or leftmost position of "
"an adjustable widget. The <parameter>lower</parameter> and <parameter>upper</parameter> arguments specify the possible range of values which "
"the adjustment can hold. The <parameter>step_increment</parameter> argument specifies the smaller of the two increments by which the user can "
"change the value, while the <parameter>page_increment</parameter> is the larger one. The <parameter>page_size</parameter> argument usually "
"corresponds somehow to the visible area of a panning widget. The <parameter>upper</parameter> argument is used to represent the bottommost or "
"rightmost coordinate in a panning widget's child."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3653(title)
msgid "Using Adjustments the Easy Way"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3655(para)
msgid ""
"The adjustable widgets can be roughly divided into those which use and require specific units for these values, and those which treat them as "
"arbitrary numbers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3660(para)
msgid ""
"The group which treats the values as arbitrary numbers includes the <classname>Range</classname> widgets (<classname>Scrollbar</classname> and "
"<classname>Scale</classname>), the <classname>ScaleButton</classname> widget, and the <classname>SpinButton</classname> widget. These widgets "
"are typically \"adjusted\" directly by the user with the mouse or keyboard. They will treat the <parameter>lower</parameter> and "
"<parameter>upper</parameter> values of an adjustment as a range within which the user can manipulate the adjustment's <parameter>value</"
"parameter>. By default, they will only modify the <parameter>value</parameter> of an adjustment."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3672(para)
msgid ""
"The other group includes the <classname>Viewport</classname> widget and the <classname>ScrolledWindow</classname> widget. All of these widgets "
"use pixel values for their adjustments. These are also typically adjusted indirectly using scrollbars. While all widgets which use adjustments "
"can either create their own adjustments or use ones you supply, you'll generally want to let this particular category of widgets create its own "
"adjustments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3681(para)
msgid ""
"If you share an adjustment object between a Scrollbar and a TextView widget, manipulating the scrollbar will automagically adjust the TextView "
"widget. You can set it up like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3686(programlisting)
#, no-wrap
msgid ""
"// creates its own adjustments\n"
"Gtk::TextView textview;\n"
"// uses the newly-created adjustment for the scrollbar as well\n"
"Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);"
msgstr ""
"// creates its own adjustments\n"
"Gtk::TextView textview;\n"
"// uses the newly-created adjustment for the scrollbar as well\n"
"Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);"

#: C/gtkmm-tutorial-in.xml:3694(title)
msgid "Adjustment Internals"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3696(para)
msgid ""
"OK, you say, that's nice, but what if I want to create my own handlers to respond when the user adjusts a <classname>Range</classname> widget "
"or a <classname>SpinButton</classname>. To access the value of a <classname>Gtk::Adjustment</classname>, you can use the "
"<methodname>get_value()</methodname> and <methodname>set_value()</methodname> methods:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3704(para)
msgid ""
"As mentioned earlier, <classname>Gtk::Adjustment</classname> can emit signals. This is, of course, how updates happen automatically when you "
"share an <classname>Adjustment</classname> object between a <classname>Scrollbar</classname> and another adjustable widget; all adjustable "
"widgets connect signal handlers to their adjustment's <literal>value_changed</literal> signal, as can your program."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3713(para)
msgid ""
"So, for example, if you have a <classname>Scale</classname> widget, and you want to change the rotation of a picture whenever its value "
"changes, you would create a signal handler like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3718(programlisting)
#, no-wrap
#| msgid ""
#| "void cb_rotate_picture (Gtk::Widget *picture)\n"
#| "{\n"
#| "  picture-&gt;set_rotation (adj-&gt;value);\n"
#| "..."
msgid ""
"void cb_rotate_picture (MyPicture* picture)\n"
"{\n"
"  picture-&gt;set_rotation(adj-&gt;get_value());\n"
"..."
msgstr ""
"void cb_rotate_picture (MyPicture* picture)\n"
"{\n"
"  picture-&gt;set_rotation(adj-&gt;get_value());\n"
"..."

#: C/gtkmm-tutorial-in.xml:3722(para)
msgid "and connect it to the scale widget's adjustment like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3725(programlisting)
#, no-wrap
#| msgid ""
#| "adj.value_changed.connect(sigc::bind&lt;Widget*&gt;(sigc::mem_fun(*this,\n"
#| "    &amp;cb_rotate_picture), picture));"
msgid ""
"adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"
msgstr ""
"adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"

#: C/gtkmm-tutorial-in.xml:3728(para)
msgid ""
"What if a widget reconfigures the <parameter>upper</parameter> or <parameter>lower</parameter> fields of its <classname>Adjustment</classname>, "
"such as when a user adds more text to a text widget? In this case, it emits the <literal>changed</literal> signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3735(para)
msgid ""
"<classname>Range</classname> widgets typically connect a handler to this signal, which changes their appearance to reflect the change - for "
"example, the size of the slider in a scrollbar will grow or shrink in inverse proportion to the difference between the <parameter>lower</"
"parameter> and <parameter>upper</parameter> values of its <classname>Adjustment</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3744(para)
msgid "You probably won't ever need to attach a handler to this signal, unless you're writing a new type of range widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3748(programlisting)
#, no-wrap
#| msgid "adjustment-&gt;changed();"
msgid "adjustment-&gt;signal_changed();"
msgstr "adjustment-&gt;signal_changed();"

#: C/gtkmm-tutorial-in.xml:3755(title)
msgid "Widgets Without X-Windows"
msgstr "Widgets ohne X-Windows"

#: C/gtkmm-tutorial-in.xml:3757(para)
msgid ""
"Some Widgets do not have an associated X-Window, so they therefore do not receive X events. This means that the signals described in the <link "
"linkend=\"sec-xeventsignals\">X event signals</link> section will not be emitted. If you want to capture events for these widgets you can use a "
"special container called <classname>Gtk::EventBox</classname>, which is described in the <link linkend=\"sec-eventbox\">EventBox</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3766(para)
msgid "Here is a list of some of these Widgets:"
msgstr "Es folgt eine Liste einiger dieser Widgets:"

#: C/gtkmm-tutorial-in.xml:3769(programlisting)
#, no-wrap
msgid ""
"Gtk::Alignment\n"
"Gtk::Arrow\n"
"Gtk::AspectFrame\n"
"Gtk::Bin\n"
"Gtk::Box\n"
"Gtk::Button\n"
"Gtk::CheckButton\n"
"Gtk::Fixed\n"
"Gtk::Frame\n"
"Gtk::Grid\n"
"Gtk::Image\n"
"Gtk::Label\n"
"Gtk::MenuItem\n"
"Gtk::Notebook\n"
"Gtk::Paned\n"
"Gtk::RadioButton\n"
"Gtk::Range\n"
"Gtk::ScrolledWindow\n"
"Gtk::Separator\n"
"Gtk::Table (deprecated from <application>gtkmm</application> version 3.4)\n"
"Gtk::Toolbar"
msgstr ""
"Gtk::Alignment\n"
"Gtk::Arrow\n"
"Gtk::AspectFrame\n"
"Gtk::Bin\n"
"Gtk::Box\n"
"Gtk::Button\n"
"Gtk::CheckButton\n"
"Gtk::Fixed\n"
"Gtk::Frame\n"
"Gtk::Grid\n"
"Gtk::Image\n"
"Gtk::Label\n"
"Gtk::MenuItem\n"
"Gtk::Notebook\n"
"Gtk::Paned\n"
"Gtk::RadioButton\n"
"Gtk::Range\n"
"Gtk::ScrolledWindow\n"
"Gtk::Separator\n"
"Gtk::Table (deprecated from <application>gtkmm</application> version 3.4)\n"
"Gtk::Toolbar"

#: C/gtkmm-tutorial-in.xml:3791(para)
msgid ""
"These widgets are mainly used for decoration or layout, so you won't often need to capture events on them. They are intended to have no X-"
"Window in order to improve performance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3797(title) C/gtkmm-tutorial-in.xml:3841(title)
msgid "EventBox"
msgstr "EventBox"

#: C/gtkmm-tutorial-in.xml:3799(para)
msgid ""
"Some <application>gtkmm</application> widgets don't have associated X windows; they draw on their parents' windows. Because of this, they "
"cannot receive events. Also, if they are incorrectly sized, they don't clip, so you can get messy overwriting etc. To receive events on one of "
"these widgets, you can place it inside an <classname>EventBox</classname> widget and then call <methodname>Gtk::Widget::set_events()</"
"methodname> on the EventBox before showing it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3807(para)
msgid ""
"Although the name <classname>EventBox</classname> emphasises the event-handling method, the widget can also be used for clipping (and more; see "
"the example below)."
msgstr ""

#. <para>TODO: Why don't they have X Windows - explain clipping.
#. Also, how does this affect platform such as Windows and MacOS that don't use X.
#. </para>
#: C/gtkmm-tutorial-in.xml:3817(para)
msgid "The constructor for <classname>Gtk::EventBox</classname> is:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3821(programlisting)
#, no-wrap
msgid "Gtk::EventBox();"
msgstr "Gtk::EventBox();"

#: C/gtkmm-tutorial-in.xml:3823(para)
msgid "A child widget can be added to the <classname>EventBox</classname> using:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3827(programlisting)
#, no-wrap
msgid "event_box.add(child_widget);"
msgstr "event_box.add(child_widget);"

#: C/gtkmm-tutorial-in.xml:3833(para)
msgid ""
"The following example demonstrates both uses of an <classname>EventBox</classname> - a label is created that is clipped to a small box, and set "
"up so that a mouse-click on the label causes the program to exit. Resizing the window reveals varying amounts of the label."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3855(title)
msgid "Dialogs"
msgstr "Dialoge"

#: C/gtkmm-tutorial-in.xml:3857(para)
msgid ""
"Dialogs are used as secondary windows, to provide specific information or to ask questions. <classname>Gtk::Dialog</classname> windows contain "
"a few pre-packed widgets to ensure consistency, and a <methodname>run()</methodname> method which blocks until the user dismisses the dialog."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3864(para)
msgid ""
"There are several derived <classname>Dialog</classname> classes which you might find useful. <classname>Gtk::MessageDialog</classname> is used "
"for most simple notifications. But at other times you might need to derive your own dialog class to provide more complex functionality."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3871(para)
msgid ""
"To pack widgets into a custom dialog, you should pack them into the <classname>Gtk::Box</classname>, available via "
"<methodname>get_content_area()</methodname>. To just add a <classname>Button</classname> to the bottom of the <classname>Dialog</classname>, "
"you could use the <methodname>add_button()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3879(para)
msgid ""
"The <methodname>run()</methodname> method returns an <literal>int</literal>. This may be a value from the <literal>Gtk::ResponseType</literal> "
"if the user closed the dialog by clicking a standard button, or it could be the custom response value that you specified when using "
"<methodname>add_button()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3888(title) C/gtkmm-tutorial-in.xml:3903(title)
msgid "MessageDialog"
msgstr "MessageDialog"

#: C/gtkmm-tutorial-in.xml:3889(para)
msgid ""
"<classname>MessageDialog</classname> is a convenience class, used to create simple, standard message dialogs, with a message, an icon, and "
"buttons for user response. You can specify the type of message and the text in the constructor, as well as specifying standard buttons via the "
"<literal>Gtk::ButtonsType</literal> enum."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3914(title)
msgid "FileChooserDialog"
msgstr "FileChooserDialog"

#: C/gtkmm-tutorial-in.xml:3915(para)
msgid "The <classname>FileChooserDialog</classname> is suitable for use with \"Open\" or \"Save\" menu items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3919(para)
msgid "Most of the useful member methods for this class are actually in the <classname>Gtk::FileChooser</classname> base class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3930(title)
msgid "FileChooser"
msgstr "FileChooser"

#: C/gtkmm-tutorial-in.xml:3940(title) C/gtkmm-tutorial-in.xml:3953(title)
msgid "ColorChooserDialog"
msgstr "ColorChooserDialog"

#: C/gtkmm-tutorial-in.xml:3941(para)
msgid ""
"The <classname>ColorChooserDialog</classname> allows the user to choose a color. The <classname>ColorButton</classname> opens a color selection "
"dialog when it is clicked."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3964(title) C/gtkmm-tutorial-in.xml:3977(title)
msgid "FontChooserDialog"
msgstr "FontChooserDialog"

#: C/gtkmm-tutorial-in.xml:3965(para)
msgid ""
"The <classname>FontChooserDialog</classname> allows the user to choose a font. The <classname>FontButton</classname> opens a font chooser "
"dialog when it is clicked."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3988(title)
msgid "Non-modal AboutDialog"
msgstr "Nicht-modaler AboutDialog"

#: C/gtkmm-tutorial-in.xml:3989(para)
msgid ""
"The <classname>AboutDialog</classname> offers a simple way to display information about a program, like its logo, name, copyright, website and "
"license."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3993(para)
msgid ""
"Most dialogs in this chapter are modal, that is, they freeze the rest of the application while they are shown. It's also possible to create a "
"non-modal dialog, which does not freeze other windows in the application. The following example shows a non-modal <classname>AboutDialog</"
"classname>. This is perhaps not the kind of dialog you would normally make non-modal, but non-modal dialogs can be useful in other cases. E.g. "
"<application>gedit</application>'s search-and-replace dialog is non-modal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4009(title)
#| msgid "Dialogs"
msgid "AboutDialog"
msgstr "AboutDialog"

#: C/gtkmm-tutorial-in.xml:4023(title)
msgid "The Drawing Area Widget"
msgstr "Das Zeichenbereich-Widget"

#: C/gtkmm-tutorial-in.xml:4024(para)
msgid ""
"The <classname>DrawingArea</classname> widget is a blank window that gives you the freedom to create any graphic you desire. Along with that "
"freedom comes the responsibility to handle draw signals on the widget. When a widget is first shown, or when it is covered and then uncovered "
"again it needs to redraw itself. Most widgets have code to do this, but the DrawingArea does not, allowing you to write your own draw signal "
"handler to determine how the contents of the widget will be drawn. This is most often done by overriding the virtual <methodname>on_draw()</"
"methodname> member function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4036(para)
msgid ""
"GTK+ uses the <ulink url=\"http://cairographics.org\">Cairo</ulink> drawing API. With <application>gtkmm</application>, you may use the <ulink "
"url=\"http://www.cairographics.org/cairomm/\">cairomm</ulink> C++ API for cairo."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4041(para)
msgid ""
"You can draw very sophisticated shapes using Cairo, but the methods to do so are quite basic. Cairo provides methods for drawing straight "
"lines, curved lines, and arcs (including circles). These basic shapes can be combined to create more complex shapes and paths which can be "
"filled with solid colors, gradients, patterns, and other things. In addition, Cairo can perform complex transformations, do compositing of "
"images, and render antialiased text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4051(title)
msgid "Cairo and Pango"
msgstr "Cairo und Pango"

#: C/gtkmm-tutorial-in.xml:4052(para)
msgid ""
"Although Cairo can render text, it's not meant to be a replacement for Pango. Pango is a better choice if you need to perform more advanced "
"text rendering such as wrapping or ellipsizing text. Drawing text with Cairo should only be done if the text is part of a graphic."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4057(para)
msgid ""
"In this section of the tutorial, we'll cover the basic Cairo drawing model, describe each of the basic drawing elements in some detail (with "
"examples), and then present a simple application that uses Cairo to draw a custom clock widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4064(title)
msgid "The Cairo Drawing Model"
msgstr "Das Cairo-Zeichenmodell"

#: C/gtkmm-tutorial-in.xml:4065(para)
msgid "The basic concept of drawing in Cairo involves defining 'invisible' paths and then stroking or filling them to make them visible."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4069(para)
msgid ""
"To do any drawing in <application>gtkmm</application> with Cairo, you must first create a <classname>Cairo::Context</classname> object. This "
"class holds all of the graphics state parameters that describe how drawing is to be done. This includes information such as line width, color, "
"the surface to draw to, and many other things. This allows the actual drawing functions to take fewer arguments to simplify the interface. In "
"<application>gtkmm</application>, a <classname>Cairo::Context</classname> is created by calling the <methodname>Gdk::Window::"
"create_cairo_context()</methodname> function. Since Cairo contexts are reference-counted objects, this function returns a <classname>Cairo::"
"RefPtr&lt;Cairo::Context&gt;</classname> object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4082(para)
msgid ""
"The following example shows how to set up a Cairo context with a foreground color of red and a width of 2. Any drawing functions that use this "
"context will use these settings."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4087(programlisting)
#, no-wrap
msgid ""
"Gtk::DrawingArea myArea;\n"
"Cairo::RefPtr&lt;Cairo::Context&gt; myContext = myArea.get_window()-&gt;create_cairo_context();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);"
msgstr ""
"Gtk::DrawingArea myArea;\n"
"Cairo::RefPtr&lt;Cairo::Context&gt; myContext = myArea.get_window()-&gt;create_cairo_context();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);"

#: C/gtkmm-tutorial-in.xml:4091(para)
msgid ""
"Each <classname>Cairo::Context</classname> is associated with a particular <classname>Gdk::Window</classname>, so the first line of the above "
"example creates a <classname>Gtk::DrawingArea</classname> widget and the second line uses its associated <classname>Gdk::Window</classname> to "
"create a <classname>Cairo::Context</classname> object. The final two lines change the graphics state of the context."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4100(para)
msgid ""
"There are a number of graphics state variables that can be set for a Cairo context. The most common context attributes are color (using "
"<methodname>set_source_rgb()</methodname> or <methodname>set_source_rgba()</methodname> for translucent colors), line width (using "
"<methodname>set_line_width()</methodname>), line dash pattern (using <methodname>set_dash()</methodname>), line cap style (using "
"<methodname>set_line_cap()</methodname>), and line join style (using <methodname>set_line_join()</methodname>), and font styles (using "
"<methodname>set_font_size()</methodname>, <methodname>set_font_face()</methodname> and others). There are many other settings as well, such as "
"transformation matrices, fill rules, whether to perform antialiasing, and others. For further information, see the <ulink url=\"http://www."
"cairographics.org/cairomm/\">cairomm</ulink> API documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4132(para)
msgid ""
"It is good practice to put all modifications to the graphics state between <methodname>save()</methodname>/<methodname>restore()</methodname> "
"function calls. For example, if you have a function that takes a <classname>Cairo::Context</classname> reference as an argument, you might "
"implement it as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4138(programlisting)
#, no-wrap
#| msgid ""
#| "void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
#| "{\n"
#| "    context-&gt;save();\n"
#| "    // change graphics state\n"
#| "    // peform drawing operations\n"
#| "    context-&gt;restore();\n"
#| "}"
msgid ""
"void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // change graphics state\n"
"    // perform drawing operations\n"
"    context-&gt;restore();\n"
"}"
msgstr ""
"void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // change graphics state\n"
"    // perform drawing operations\n"
"    context-&gt;restore();\n"
"}"

#: C/gtkmm-tutorial-in.xml:4115(para)
msgid ""
"The current state of a <classname>Cairo::Context</classname> can be saved to an internal stack of saved states and later be restored to the "
"state it was in when you saved it. To do this, use the <methodname>save()</methodname> method and the <methodname>restore()</methodname> "
"method. This can be useful if you need to temporarily change the line width and color (or any other graphics setting) in order to draw "
"something and then return to the previous settings. In this situation, you could call <methodname>Cairo::Context::save()</methodname>, change "
"the graphics settings, draw the lines, and then call <methodname>Cairo::Context::restore()</methodname> to restore the original graphics state. "
"Multiple calls to <methodname>save()</methodname> and <methodname>restore()</methodname> can be nested; each call to <methodname>restore()</"
"methodname> restores the state from the matching paired <methodname>save()</methodname>. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4147(para)
msgid ""
"The virtual <methodname>on_draw()</methodname> method provides a Cairo context that you shall use for drawing in the <classname>Gtk::"
"DrawingArea</classname> widget. It is not necessary to save and restore this Cairo context in <methodname>on_draw()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4155(title)
msgid "Drawing Straight Lines"
msgstr "Zeichnen gerader Linien"

#: C/gtkmm-tutorial-in.xml:4164(para)
msgid ""
"Since the Cairo graphics library was written with support for multiple output targets (the X window system, PNG images, OpenGL, etc), there is "
"a distinction between user-space and device-space coordinates. The mapping between these two coordinate systems defaults to one-to-one so that "
"integer values map roughly to pixels on the screen, but this setting can be adjusted if desired. Sometimes it may be useful to scale the "
"coordinates so that the full width and height of a window both range from 0 to 1 (the 'unit square') or some other mapping that works for your "
"application. This can be done with the <methodname>Cairo::Context::scale()</methodname> function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4156(para)
msgid ""
"Now that we understand the basics of the Cairo graphics library, we're almost ready to start drawing. We'll start with the simplest of drawing "
"elements: the straight line. But first you need to know a little bit about Cairo's coordinate system. The origin of the Cairo coordinate system "
"is located in the upper-left corner of the window with positive x values to the right and positive y values going down. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4179(para)
msgid ""
"In this example, we'll construct a small but fully functional <application>gtkmm</application> program and draw some lines into the window. The "
"lines are drawn by creating a path and then stroking it. A path is created using the functions <methodname>Cairo::Context::move_to()</"
"methodname> and <methodname>Cairo::Context::line_to()</methodname>. The function <methodname>move_to()</methodname> is similar to the act of "
"lifting your pen off of the paper and placing it somewhere else -- no line is drawn between the point you were at and the point you moved to. "
"To draw a line between two points, use the <methodname>line_to()</methodname> function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4191(para)
msgid ""
"After you've finished creating your path, you still haven't drawn anything visible yet. To make the path visible, you must use the function "
"<methodname>stroke()</methodname> which will stroke the current path with the line width and style specified in your <classname>Cairo::Context</"
"classname> object. After stroking, the current path will be cleared so that you can start on your next path."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4200(para)
msgid ""
"Many Cairo drawing functions have a <methodname>_preserve()</methodname> variant. Normally drawing functions such as <methodname>clip()</"
"methodname>, <methodname>fill()</methodname>, or <methodname>stroke()</methodname> will clear the current path. If you use the "
"<methodname>_preserve()</methodname> variant, the current path will be retained so that you can use the same path with the next drawing "
"function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4210(title) C/gtkmm-tutorial-in.xml:4328(title)
msgid "Drawing Area - Lines"
msgstr "Zeichenbereich - Linien"

#: C/gtkmm-tutorial-in.xml:4218(para)
msgid ""
"This program contains a single class, <classname>MyArea</classname>, which is a subclass of <classname>Gtk::DrawingArea</classname> and "
"contains an <methodname>on_draw()</methodname> member function. This function is called whenever the image in the drawing area needs to be "
"redrawn. It is passed a <classname>Cairo::RefPtr</classname> pointer to a <classname>Cairo::Context</classname> that we use for the drawing. "
"The actual drawing code sets the color we want to use for drawing by using <methodname>set_source_rgb()</methodname> which takes arguments "
"defining the Red, Green, and Blue components of the desired color (valid values are between 0 and 1). After setting the color, we created a new "
"path using the functions <methodname>move_to()</methodname> and <methodname>line_to()</methodname>, and then stroked this path with "
"<methodname>stroke()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4235(title)
msgid "Drawing with relative coordinates"
msgstr "Zeichnen mit relativen Koordinaten"

#: C/gtkmm-tutorial-in.xml:4236(para)
msgid ""
"In the example above we drew everything using absolute coordinates. You can also draw using relative coordinates. For a straight line, this is "
"done with the function <methodname>Cairo::Context::rel_line_to()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4242(title)
msgid "Line styles"
msgstr "Linienstile"

#: C/gtkmm-tutorial-in.xml:4243(para)
msgid ""
"In addition to drawing basic straight lines, there are a number of things that you can customize about a line. You've already seen examples of "
"setting a line's color and width, but there are others as well."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4249(para)
msgid ""
"If you've drawn a series of lines that form a path, you may want them to join together in a certain way. Cairo offers three different ways to "
"join lines together: Miter, Bevel, and Round. These are show below:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4256(title)
msgid "Different join types in Cairo"
msgstr "Verschiedene Verbindungstypen in Cairo"

#: C/gtkmm-tutorial-in.xml:4261(para)
msgid "The line join style is set using the function <methodname>Cairo::Context::set_line_join()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4265(para)
msgid ""
"Line ends can have different styles as well. The default style is for the line to start and stop exactly at the destination points of the line. "
"This is called a Butt cap. The other options are Round (uses a round ending, with the center of the circle at the end point) or Square (uses a "
"squared ending, with the center of the square at the end point). This setting is set using the function <methodname>Cairo::Context::"
"set_line_cap()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4275(para)
msgid ""
"There are other things you can customize as well, including creating dashed lines and other things. For more information, see the Cairo API "
"documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4282(title)
msgid "Drawing thin lines"
msgstr "Zeichnen dünner Linien"

#: C/gtkmm-tutorial-in.xml:4283(para)
msgid ""
"If you try to draw one pixel wide lines, you may notice that the line sometimes comes up blurred and wider than it ought to be. This happens "
"because Cairo will try to draw from the selected position, to both sides (half to each), so if you're positioned right on the intersection of "
"the pixels, and want a one pixel wide line, Cairo will try to use half of each adjacent pixel, which isn't possible (a pixel is the smallest "
"unit possible). This happens when the width of the line is an odd number of pixels (not just one pixel)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4293(para)
msgid ""
"The trick is to position in the middle of the pixel where you want the line to be drawn, and thus guaranteeing you get the desired results. See "
"<ulink url=\"http://cairographics.org/FAQ/#sharp_lines\">Cairo FAQ</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4300(title)
msgid "Drawing Area - Thin Lines"
msgstr "Zeichenbereich - Dünne Linien"

#: C/gtkmm-tutorial-in.xml:4311(title)
msgid "Drawing Curved Lines"
msgstr "Zeichnen von gebogenen Linien"

#: C/gtkmm-tutorial-in.xml:4312(para)
msgid ""
"In addition to drawing straight lines Cairo allows you to easily draw curved lines (technically a cubic Bézier spline) using the "
"<methodname>Cairo::Context::curve_to()</methodname> and <methodname>Cairo::Context::rel_curve_to()</methodname> functions. These functions take "
"coordinates for a destination point as well as coordinates for two 'control' points. This is best explained using an example, so let's dive in."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4323(para)
msgid "This simple application draws a curve with Cairo and displays the control points for each end of the curve."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4335(para)
msgid ""
"The only difference between this example and the straight line example is in the <methodname>on_draw()</methodname> function, but there are a "
"few new concepts and functions introduced here, so let's examine them briefly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4341(para)
msgid ""
"We make a call to <methodname>Cairo::Context::scale()</methodname>, passing in the width and height of the drawing area. This scales the user-"
"space coordinate system such that the width and height of the widget are both equal to 1.0 'units'. There's no particular reason to scale the "
"coordinate system in this case, but sometimes it can make drawing operations easier."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4350(para)
msgid ""
"The call to <methodname>Cairo::Context::curve_to()</methodname> should be fairly self-explanatory. The first pair of coordinates define the "
"control point for the beginning of the curve. The second set of coordinates define the control point for the end of the curve, and the last set "
"of coordinates define the destination point. To make the concept of control points a bit easier to visualize, a line has been drawn from each "
"control point to the end-point on the curve that it is associated with. Note that these control point lines are both translucent. This is "
"achieved with a variant of <methodname>set_source_rgb()</methodname> called <methodname>set_source_rgba()</methodname>. This function takes a "
"fourth argument specifying the alpha value of the color (valid values are between 0 and 1)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4368(title)
msgid "Drawing Arcs and Circles"
msgstr "Zeichnen von Kreisbögen und Kreisen"

#: C/gtkmm-tutorial-in.xml:4369(para)
msgid ""
"With Cairo, the same function is used to draw arcs, circles, or ellipses: <methodname>Cairo::Context::arc()</methodname>. This function takes "
"five arguments. The first two are the coordinates of the center point of the arc, the third argument is the radius of the arc, and the final "
"two arguments define the start and end angle of the arc. All angles are defined in radians, so drawing a circle is the same as drawing an arc "
"from 0 to 2 * M_PI radians. An angle of 0 is in the direction of the positive X axis (in user-space). An angle of M_PI/2 radians (90 degrees) "
"is in the direction of the positive Y axis (in user-space). Angles increase in the direction from the positive X axis toward the positive Y "
"axis. So with the default transformation matrix, angles increase in a clockwise direction. (Remember that the positive Y axis points downwards.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4390(programlisting)
#, no-wrap
msgid ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"
msgstr ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"

#: C/gtkmm-tutorial-in.xml:4384(para)
msgid ""
"To draw an ellipse, you can scale the current transformation matrix by different amounts in the X and Y directions. For example, to draw an "
"ellipse with center at <varname>x</varname>, <varname>y</varname> and size <varname>width</varname>, <varname>height</varname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4398(para)
msgid "Here's an example of a simple program that draws an arc, a circle and an ellipse into a drawing area."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4403(title)
msgid "Drawing Area - Arcs"
msgstr "Zeichenbereich - Bögen"

#: C/gtkmm-tutorial-in.xml:4412(para)
msgid ""
"There are a couple of things to note about this example code. Again, the only real difference between this example and the previous ones is the "
"<methodname>on_draw()</methodname> function, so we'll limit our focus to that function. In addition, the first part of the function is nearly "
"identical to the previous examples, so we'll skip that portion."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4420(para)
msgid ""
"Note that in this case, we've expressed nearly everything in terms of the height and width of the window, including the width of the lines. "
"Because of this, when you resize the window, everything scales with the window. Also note that there are three drawing sections in the function "
"and each is wrapped with a <methodname>save()</methodname>/<methodname>restore()</methodname> pair so that we're back at a known state after "
"each drawing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4429(para)
msgid ""
"The section for drawing an arc introduces one new function, <methodname>close_path()</methodname>. This function will in effect draw a straight "
"line from the current point back to the first point in the path. There is a significant difference between calling <methodname>close_path()</"
"methodname> and manually drawing a line back to the starting point, however. If you use <methodname>close_path()</methodname>, the lines will "
"be nicely joined together. If you use <methodname>line_to()</methodname> instead, the lines will end at the same point, but Cairo won't do any "
"special joining."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4442(title)
msgid "Drawing counter-clockwise"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4443(para)
msgid ""
"The function <methodname>Cairo::Context::arc_negative()</methodname> is exactly the same as <methodname>Cairo::Context::arc()</methodname> but "
"the angles go the opposite direction."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4455(title)
msgid "Drawing Text"
msgstr "Zeichnen von Text"

#: C/gtkmm-tutorial-in.xml:4457(title)
msgid "Drawing Text with Pango"
msgstr "Zeichnen von Text mit Pango"

#: C/gtkmm-tutorial-in.xml:4458(para)
msgid ""
"Text is drawn via Pango Layouts. The easiest way to create a <classname>Pango::Layout</classname> is to use <methodname>Gtk::Widget::"
"create_pango_layout()</methodname>. Once created, the layout can be manipulated in various ways, including changing the text, font, etc. "
"Finally, the layout can be rendered using the <methodname>Pango::Layout::show_in_cairo_context()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4470(para)
msgid ""
"Here is an example of a program that draws some text, some of it upside-down. The Printing chapter contains another <link linkend=\"sec-"
"printing-example\">example</link> of drawing text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4476(title)
msgid "Drawing Area - Text"
msgstr "Zeichenbereich - Text"

#: C/gtkmm-tutorial-in.xml:4493(title)
msgid "Drawing Images"
msgstr "Zeichnen von Grafiken"

#: C/gtkmm-tutorial-in.xml:4494(para)
msgid ""
"There is a method for drawing from a <classname>Gdk::Pixbuf</classname> to a <classname>Cairo::Context</classname>. A <classname>Gdk::Pixbuf</"
"classname> buffer is a useful wrapper around a collection of pixels, which can be read from files, and manipulated in various ways."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4501(para)
msgid ""
"Probably the most common way of creating <classname>Gdk::Pixbuf</classname>s is to use <methodname>Gdk::Pixbuf::create_from_file()</"
"methodname>, which can read an image file, such as a png file into a pixbuf ready for rendering."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4508(para)
msgid ""
"The <classname>Gdk::Pixbuf</classname> can be rendered by setting it as the source pattern of the Cairo context with <methodname>Gdk::Cairo::"
"set_source_pixbuf()</methodname>. Then draw the image with either <methodname>Cairo::Context::paint()</methodname> (to draw the whole image), "
"or <methodname>Cairo::Context::rectangle()</methodname> and <methodname>Cairo::Context::fill()</methodname> (to fill the specified rectangle). "
"<methodname>set_source_pixbuf()</methodname> is not a member of <classname>Cairo::Context</classname>. It takes a <classname>Cairo::Context</"
"classname> as its first parameter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4519(para)
msgid ""
"Here is a small bit of code to tie it all together: (Note that usually you wouldn't load the image every time in the draw signal handler! It's "
"just shown here to keep it all together.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4524(programlisting)
#, no-wrap
msgid ""
"bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)\n"
"{\n"
"  Glib::RefPtr&lt;Gdk::Pixbuf&gt; image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"  // Draw the image at 110, 90, except for the outermost 10 pixels.\n"
"  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);\n"
"  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);\n"
"  cr-&gt;fill();\n"
"  return true;\n"
"}"
msgstr ""
"bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)\n"
"{\n"
"  Glib::RefPtr&lt;Gdk::Pixbuf&gt; image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"  // Draw the image at 110, 90, except for the outermost 10 pixels.\n"
"  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);\n"
"  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);\n"
"  cr-&gt;fill();\n"
"  return true;\n"
"}"

#: C/gtkmm-tutorial-in.xml:4535(para)
msgid "Here is an example of a simple program that draws an image."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4539(title)
msgid "Drawing Area - Image"
msgstr "Zeichenbereich - Bild"

#: C/gtkmm-tutorial-in.xml:4559(title)
msgid "Example Application: Creating a Clock with Cairo"
msgstr "Beispielanwendung: Eine Uhr mit Cairo"

#: C/gtkmm-tutorial-in.xml:4560(para)
msgid ""
"Now that we've covered the basics of drawing with Cairo, let's try to put it all together and create a simple application that actually does "
"something. The following example uses Cairo to create a custom <classname>Clock</classname> widget. The clock has a second hand, a minute hand, "
"and an hour hand, and updates itself every second."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4572(para)
msgid ""
"As before, almost all of the interesting stuff is done in the draw signal handler <methodname>on_draw()</methodname>. Before we dig into the "
"draw signal handler, notice that the constructor for the <classname>Clock</classname> widget connects a handler function "
"<methodname>on_timeout()</methodname> to a timer with a timeout period of 1000 milliseconds (1 second). This means that "
"<methodname>on_timeout()</methodname> will get called once per second. The sole responsibility of this function is to invalidate the window so "
"that <application>gtkmm</application> will be forced to redraw it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4583(para)
msgid ""
"Now let's take a look at the code that performs the actual drawing. The first section of <methodname>on_draw()</methodname> should be pretty "
"familiar by now. This example again scales the coordinate system to be a unit square so that it's easier to draw the clock as a percentage of "
"window size so that it will automatically scale when the window size is adjusted. Furthermore, the coordinate system is scaled over and down so "
"that the (0, 0) coordinate is in the very center of the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4593(para)
msgid ""
"The function <methodname>Cairo::Context::paint()</methodname> is used here to set the background color of the window. This function takes no "
"arguments and fills the current surface (or the clipped portion of the surface) with the source color currently active. After setting the "
"background color of the window, we draw a circle for the clock outline, fill it with white, and then stroke the outline in black. Notice that "
"both of these actions use the <methodname>_preserve</methodname> variant to preserve the current path, and then this same path is clipped to "
"make sure that our next lines don't go outside the outline of the clock."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4605(para)
msgid ""
"After drawing the outline, we go around the clock and draw ticks for every hour, with a larger tick at 12, 3, 6, and 9. Now we're finally ready "
"to implement the time-keeping functionality of the clock, which simply involves getting the current values for hours, minutes and seconds, and "
"drawing the hands at the correct angles."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4617(para)
msgid "<classname>Gtk::Widget</classname> has several methods and signals which are prefixed with \"drag_\". These are used for Drag and Drop."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4622(title)
msgid "Sources and Destinations"
msgstr "Quellen und Ziele"

#: C/gtkmm-tutorial-in.xml:4623(para)
msgid ""
"Things are dragged from <literal>sources</literal> to be dropped on <literal>destinations</literal>. Each source and destination has infomation "
"about the data formats that it can send or receive, provided by <classname>Gtk::TargetEntry</classname> items. A drop destination will only "
"accept a dragged item if they both share a compatible <classname>Gtk::TargetEntry</classname> item. Appropriate signals will then be emitted, "
"telling the signal handlers which <classname>Gtk::TargetEntry</classname> was used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4636(para)
msgid "target: A name, such as \"STRING\""
msgstr ""

#: C/gtkmm-tutorial-in.xml:4637(para)
msgid "info: An identifier which will be sent to your signals to tell you which TargetEntry was used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4638(para)
msgid ""
"flags: Used only for drag and drop, this specifies whether the data may be dragged to other widgets and applications, or only to the same ones."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4633(para)
msgid "<classname>Gtk::TargetEntry</classname> objects contain this information: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4646(para)
msgid "<classname>Widget</classname>s can be identified as sources or destinations using these <classname>Gtk::Widget</classname> methods:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4650(programlisting)
#, no-wrap
msgid ""
"void drag_source_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);"
msgstr ""
"void drag_source_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);"

#: C/gtkmm-tutorial-in.xml:4655(para)
msgid "<literal>targets</literal> is a vector of <classname>Gtk::TargetEntry</classname> elements."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4661(para)
msgid ""
"<literal>start_button_mask</literal> is an ORed combination of values, which specify which modifier key or mouse button must be pressed to "
"start the drag."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4668(para)
msgid ""
"<literal>actions</literal> is an ORed combination of values, which specified which Drag and Drop operations will be possible from this source - "
"for instance, copy, move, or link. The user can choose between the actions by using modifier keys, such as <keycap>Shift</keycap> to change "
"from <literal>copy</literal> to <literal>move</literal>, and this will be shown by a different cursor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4679(programlisting)
#, no-wrap
msgid ""
"void drag_dest_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"    Gtk::DestDefaults flags, Gdk::DragAction actions);"
msgstr ""
"void drag_dest_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"    Gtk::DestDefaults flags, Gdk::DragAction actions);"

#: C/gtkmm-tutorial-in.xml:4684(para)
msgid "<literal>flags</literal> is an ORed combination of values which indicates how the widget will respond visually to Drag and Drop items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4690(para)
msgid "<literal>actions</literal> indicates the Drag and Drop actions which this destination can receive - see the description above."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4700(para)
msgid ""
"When a drop destination has accepted a dragged item, certain signals will be emitted, depending on what action has been selected. For instance, "
"the user might have held down the <keycap>Shift</keycap> key to specify a <literal>move</literal> rather than a <literal>copy</literal>. "
"Remember that the user can only select the actions which you have specified in your calls to <methodname>drag_dest_set()</methodname> and "
"<methodname>drag_source_set()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4711(title) C/gtkmm-tutorial-in.xml:4848(title)
msgid "Copy"
msgstr "Kopieren"

#: C/gtkmm-tutorial-in.xml:4715(para)
msgid "<literal>drag_begin</literal>: Provides DragContext."
msgstr "<literal>drag_begin</literal>: Stellt DragContext bereit."

#: C/gtkmm-tutorial-in.xml:4716(para)
msgid ""
"<literal>drag_data_get</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>Gtk::SelectionData</literal> "
"structure, in which you should put the requested data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4717(para)
msgid "<literal>drag_end</literal>: Provides DragContext."
msgstr "<literal>drag_end</literal>: Stellt DragContext bereit."

#: C/gtkmm-tutorial-in.xml:4712(para)
msgid "The source widget will emit these signals, in this order: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4723(para)
msgid ""
"<literal>drag_motion</literal>: Provides DragContext and coordinates. You can call the <methodname>drag_status()</methodname> method of the "
"DragContext to indicate which action will be accepted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4726(para)
msgid ""
"<literal>drag_drop</literal>: Provides DragContext and coordinates. You can call <methodname>drag_get_data()</methodname>, which triggers the "
"<literal>drag_data_get</literal> signal in the source widget, and then the <literal>drag_data_received</literal> signal in the destination "
"widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4731(para)
msgid ""
"<literal>drag_data_received</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>Gtk::SelectionData</"
"literal> structure which contains the dropped data. You should call the <methodname>drag_finish()</methodname> method of the "
"<literal>DragContext</literal> to indicate whether the operation was successful."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4720(para)
msgid "The destination widget will emit these signals, in this order: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4746(title)
msgid "Move"
msgstr "Verschieben"

#: C/gtkmm-tutorial-in.xml:4749(para)
msgid "<literal>drag_data_delete</literal>: Gives the source the opportunity to delete the original data if that's appropriate."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4747(para)
msgid "During a <literal>move</literal>, the source widget will also emit this signal: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4763(title)
msgid "DragContext"
msgstr "DragContext"

#: C/gtkmm-tutorial-in.xml:4764(para)
msgid ""
"The drag and drop signals provide a DragContext, which contains some information about the drag and drop operation and can be used to influence "
"the process. For instance, you can discover the source widget, or change the drag and drop icon, by using the <methodname>set_icon()</"
"methodname> methods. More importantly, you should call the <methodname>drag_finish()</methodname> method from your <literal>drag_data_received</"
"literal> signal handler to indicate whether the drop was successful."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4777(para)
msgid "Here is a very simple example, demonstrating a drag and drop <literal>Copy</literal> operation:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4788(para)
msgid "There is a more complex example in examples/others/dnd."
msgstr "In examples/others/dnd finden Sie ein komplexeres Beispiel."

#: C/gtkmm-tutorial-in.xml:4797(title)
msgid "The Clipboard"
msgstr "Die Zwischenablage"

#: C/gtkmm-tutorial-in.xml:4798(para)
msgid ""
"Simple text copy-paste functionality is provided for free by widgets such as <classname>Gtk::Entry</classname> and <classname>Gtk::TextView</"
"classname>, but you might need special code to deal with your own data formats. For instance, a drawing program would need special code to "
"allow copy and paste within a view, or between documents."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4804(para)
msgid ""
"You can usually pretend that <classname>Gtk::Clipboard</classname> is a singleton. You can get the default clipboard instance with "
"<methodname>Gtk::Clipboard::get()</methodname>. This is probably the only clipboard you will ever need."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4810(para)
msgid ""
"Your application doesn't need to wait for clipboard operations, particularly between the time when the user chooses Copy and then later chooses "
"Paste. Most <classname>Gtk::Clipboard</classname> methods take <classname>sigc::slot</classname>s which specify callback methods. When "
"<classname>Gtk::Clipboard</classname> is ready, it will call these methods, either providing the requested data, or asking for data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4822(title)
msgid "Targets"
msgstr "Ziele"

#: C/gtkmm-tutorial-in.xml:4823(para)
msgid ""
"Different applications contain different types of data, and they might make that data available in a variety of formats. <application>gtkmm</"
"application> calls these data types <literal>target</literal>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4827(para)
msgid ""
"For instance, <application>gedit</application> can supply and receive the <literal>\"UTF8_STRING\"</literal> target, so you can paste data into "
"<application>gedit</application> from any application that supplies that target. Or two different image editing applications might supply and "
"receive a variety of image formats as targets. As long as one application can receive one of the targets that the other supplies then you will "
"be able to copy data from one to the other."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4834(para)
msgid ""
"A target can be in a variety of binary formats. This chapter, and the examples, assume that the data is 8-bit text. This would allow us to use "
"an XML format for the clipboard data. However this would probably not be appropriate for binary data such as images. <classname>Gtk::Clipboard</"
"classname> provides overloads that allow you to specify the format in more detail if necessary."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4843(para)
msgid ""
"The <link linkend=\"chapter-draganddrop\">Drag and Drop</link> API uses the same mechanism. You should probably use the same data targets and "
"formats for both Clipboard and Drag and Drop operations."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4849(para)
msgid ""
"When the user asks to copy some data, you should tell the <classname>Clipboard</classname> what targets are available, and provide the callback "
"methods that it can use to get the data. At this point you should store a copy of the data, to be provided when the clipboard calls your "
"callback method in response to a paste."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4858(programlisting)
#, no-wrap
#| msgid ""
#| "Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();\n"
#| "\n"
#| "//Targets:\n"
#| "std::list&lt;Gtk::TargetEntry&gt; listTargets;\n"
#| "listTargets.push_back( Gtk::TargetEntry(\"example_custom_target\") );\n"
#| "listTargets.push_back( Gtk::TargetEntry(\"UTF8_STRING\") );\n"
#| "\n"
#| "refClipboard-&gt;set( listTargets,\n"
#| "    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),\n"
#| "    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );"
msgid ""
"Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();\n"
"\n"
"//Targets:\n"
"std::vector&lt;Gtk::TargetEntry&gt; targets;\n"
"targets.push_back( Gtk::TargetEntry(\"example_custom_target\") );\n"
"targets.push_back( Gtk::TargetEntry(\"UTF8_STRING\") );\n"
"\n"
"refClipboard-&gt;set( targets,\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );"
msgstr ""
"Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();\n"
"\n"
"//Targets:\n"
"std::vector&lt;Gtk::TargetEntry&gt; targets;\n"
"targets.push_back( Gtk::TargetEntry(\"example_custom_target\") );\n"
"targets.push_back( Gtk::TargetEntry(\"UTF8_STRING\") );\n"
"\n"
"refClipboard-&gt;set( targets,\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );"

#: C/gtkmm-tutorial-in.xml:4869(para)
msgid "Your callback will then provide the stored data when the user chooses to paste the data. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4871(programlisting)
#, no-wrap
#| msgid ""
#| "void ExampleWindow::on_clipboard_get(\n"
#| "    Gtk::SelectionData&amp; selection_data, guint info)\n"
#| "{\n"
#| "  const Glib::ustring target = selection_data.get_target();\n"
#| "\n"
#| "  if(target == \"example_custom_target\")\n"
#| "    selection_data.set(\"example_custom_target\", m_ClipboardStore);\n"
#| "}"
msgid ""
"void ExampleWindow::on_clipboard_get(\n"
"    Gtk::SelectionData&amp; selection_data, guint /* info */)\n"
"{\n"
"  const std::string target = selection_data.get_target();\n"
"\n"
"  if(target == \"example_custom_target\")\n"
"    selection_data.set(\"example_custom_target\", m_ClipboardStore);\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_get(\n"
"    Gtk::SelectionData&amp; selection_data, guint /* info */)\n"
"{\n"
"  const std::string target = selection_data.get_target();\n"
"\n"
"  if(target == \"example_custom_target\")\n"
"    selection_data.set(\"example_custom_target\", m_ClipboardStore);\n"
"}"

#: C/gtkmm-tutorial-in.xml:4879(para)
msgid "The <literal>ideal</literal> example below can supply more than one clipboard target."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4883(para)
msgid "The clear callback allows you to free the memory used by your stored data when the clipboard replaces its data with something else."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4889(title)
msgid "Paste"
msgstr "Einfügen"

#: C/gtkmm-tutorial-in.xml:4890(para)
msgid ""
"When the user asks to paste data from the <classname>Clipboard</classname>, you should request a specific format and provide a callback method "
"which will be called with the actual data. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4895(programlisting)
#, no-wrap
msgid ""
"refClipboard-&gt;request_contents(\"example_custom_target\",\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );"
msgstr ""
"refClipboard-&gt;request_contents(\"example_custom_target\",\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );"

#: C/gtkmm-tutorial-in.xml:4898(para)
msgid "Here is an example callback method:"
msgstr "Hier ist ein Beispiel für eine Callback-Methode:"

#: C/gtkmm-tutorial-in.xml:4900(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_received(\n"
"    const Gtk::SelectionData&amp; selection_data)\n"
"{\n"
"  Glib::ustring clipboard_data = selection_data.get_data_as_string();\n"
"  //Do something with the pasted data.\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_received(\n"
"    const Gtk::SelectionData&amp; selection_data)\n"
"{\n"
"  Glib::ustring clipboard_data = selection_data.get_data_as_string();\n"
"  //Do something with the pasted data.\n"
"}"

#: C/gtkmm-tutorial-in.xml:4908(title)
msgid "Discovering the available targets"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4909(para)
msgid ""
"To find out what targets are currently available on the <classname>Clipboard</classname> for pasting, call the <methodname>request_targets()</"
"methodname> method, specifying a method to be called with the information. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4915(programlisting)
#, no-wrap
msgid ""
"refClipboard-&gt;request_targets( sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_clipboard_received_targets) );"
msgstr ""
"refClipboard-&gt;request_targets( sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_clipboard_received_targets) );"

#: C/gtkmm-tutorial-in.xml:4918(para)
msgid ""
"In your callback, compare the vector of available targets with those that your application supports for pasting. You could enable or disable a "
"Paste menu item, depending on whether pasting is currently possible. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4921(programlisting)
#, no-wrap
#| msgid ""
#| "void ExampleWindow::on_clipboard_received_targets(\n"
#| "  const Glib::StringArrayHandle&amp; targets_array)\n"
#| "{\n"
#| "  // Get the list of available clipboard targets:\n"
#| "  std::list&lt;std::string&gt; targets = targets_array;\n"
#| "\n"
#| "  const bool bPasteIsPossible =\n"
#| "    std::find(targets.begin(), targets.end(),\n"
#| "      example_target_custom) != targets.end();\n"
#| "\n"
#| "  // Enable/Disable the Paste button appropriately:\n"
#| "  m_Button_Paste.set_sensitive(bPasteIsPossible);\n"
#| "}"
msgid ""
"void ExampleWindow::on_clipboard_received_targets(\n"
"  const std::vector&lt;Glib::ustring&gt;&amp; targets)\n"
"{\n"
"  const bool bPasteIsPossible =\n"
"    std::find(targets.begin(), targets.end(),\n"
"      example_target_custom) != targets.end();\n"
"\n"
"  // Enable/Disable the Paste button appropriately:\n"
"  m_Button_Paste.set_sensitive(bPasteIsPossible);\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_received_targets(\n"
"  const std::vector&lt;Glib::ustring&gt;&amp; targets)\n"
"{\n"
"  const bool bPasteIsPossible =\n"
"    std::find(targets.begin(), targets.end(),\n"
"      example_target_custom) != targets.end();\n"
"\n"
"  // Enable/Disable the Paste button appropriately:\n"
"  m_Button_Paste.set_sensitive(bPasteIsPossible);\n"
"}"

#: C/gtkmm-tutorial-in.xml:4937(title) C/gtkmm-tutorial-in.xml:5330(title)
msgid "Simple"
msgstr "Einfach"

#: C/gtkmm-tutorial-in.xml:4938(para)
msgid ""
"This example allows copy and pasting of application-specific data, using the standard text target. Although this is simple, it's not ideal "
"because it does not identify the <classname>Clipboard</classname> data as being of a particular type."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4946(title)
msgid "Clipboard - Simple"
msgstr "Zwischenablage - Einfach"

#: C/gtkmm-tutorial-in.xml:4956(title)
msgid "Ideal"
msgstr "Ideal"

#: C/gtkmm-tutorial-in.xml:4959(simpara)
msgid "Defines a custom clipboard target, though the format of that target is still text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4960(simpara)
msgid "It supports pasting of 2 targets - both the custom one and a text one that creates an arbitrary text representation of the custom data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4961(simpara)
msgid ""
"It uses <methodname>request_targets()</methodname> and the <literal>owner_change</literal> signal and disables the Paste button if it can't use "
"anything on the clipboard."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4957(para)
msgid "This is like the simple example, but it <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4966(title)
msgid "Clipboard - Ideal"
msgstr "Zwischenablage - Ideal"

#: C/gtkmm-tutorial-in.xml:4982(title)
msgid "Printing"
msgstr "Drucken"

#: C/gtkmm-tutorial-in.xml:4984(para)
msgid ""
"At the application development level, <application>gtkmm</application>'s printing API provides dialogs that are consistent across applications "
"and allows use of Cairo's common drawing API, with Pango-driven text rendering. In the implementation of this common API, platform-specific "
"backends and printer-specific drivers are used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4990(title)
msgid "PrintOperation"
msgstr "PrintOperation"

#: C/gtkmm-tutorial-in.xml:4992(para)
msgid ""
"The primary object is <classname>Gtk::PrintOperation</classname>, allocated for each print operation. To handle page drawing connect to its "
"signals, or inherit from it and override the default virtual signal handlers. <classname>PrintOperation</classname> automatically handles all "
"the settings affecting the print loop."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5009(para)
msgid ""
"<literal>begin_print</literal>: You must handle this signal, because this is where you create and set up a <classname>Pango::Layout</classname> "
"using the provided <classname>Gtk::PrintContext</classname>, and break up your printing output into pages."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5019(para)
msgid ""
"<literal>paginate</literal>: Pagination is potentially slow so if you need to monitor it you can call the <methodname>PrintOperation::"
"set_show_progress()</methodname> method and handle this signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5033(para)
msgid ""
"<literal>request_page_setup</literal>: Provides a <classname>PrintContext</classname>, page number and <classname>Gtk::PageSetup</classname>. "
"Handle this signal if you need to modify page setup on a per-page basis."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5042(para)
msgid ""
"<literal>draw_page</literal>: You must handle this signal, which provides a <classname>PrintContext</classname> and a page number. The "
"<classname>PrintContext</classname> should be used to create a <classname>Cairo::Context</classname> into which the provided page should be "
"drawn. To render text, iterate over the <classname>Pango::Layout</classname> you created in the <literal>begin_print</literal> handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5028(para)
msgid "For each page that needs to be rendered, the following signals are emitted: <placeholder-1/>"
msgstr "Für jede darzustellende Seite werden folgende Signale ausgegeben: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5057(para)
msgid ""
"<literal>end_print</literal>: A handler for it is a safe place to free any resources related to a <classname>PrintOperation</classname>. If you "
"have your custom class that inherits from <classname>PrintOperation</classname>, it is naturally simpler to do it in the destructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5067(para)
msgid ""
"<literal>done</literal>: This signal is emitted when printing is finished, meaning when the print data is spooled. Note that the provided "
"<literal>Gtk::PrintOperationResult</literal> may indicate that an error occurred. In any case you probably want to notify the user about the "
"final status."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5077(para)
msgid ""
"<literal>status_changed</literal>: Emitted whenever a print job's status changes, until it is finished. Call the <methodname>PrintOperation::"
"set_track_print_status()</methodname> method to monitor the job status after spooling. To see the status, use <methodname>get_status()</"
"methodname> or <methodname>get_status_string()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5003(para)
msgid ""
"The <methodname>PrintOperation::run()</methodname> method starts the print loop, during which various signals are emitted: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5099(title)
msgid "Page setup"
msgstr "Seite einrichten"

#: C/gtkmm-tutorial-in.xml:5101(para)
msgid ""
"The <classname>PrintOperation</classname> class has a method called <methodname>set_default_page_setup()</methodname> which selects the default "
"paper size, orientation and margins. To show a page setup dialog from your application, use the <methodname>Gtk::run_page_setup_dialog()</"
"methodname> method, which returns a <classname>Gtk::PageSetup</classname> object with the chosen settings. Use this object to update a "
"<classname>PrintOperation</classname> and to access the selected <classname>Gtk::PaperSize</classname>, <literal>Gtk::PageOrientation</literal> "
"and printer-specific margins."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5111(para)
msgid "You should save the chosen <classname>Gtk::PageSetup</classname> so you can use it again if the page setup dialog is shown again."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5115(programlisting)
#, no-wrap
msgid ""
"\n"
"//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...\n"
"Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"
msgstr ""
"\n"
"//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...\n"
"Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"

#: C/gtkmm-tutorial-in.xml:5114(para) C/gtkmm-tutorial-in.xml:5179(para) C/gtkmm-tutorial-in.xml:9985(para)
msgid "For instance, <placeholder-1/>"
msgstr "Zum Beispiel, <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5126(para)
msgid ""
"The Cairo coordinate system, in the <literal>draw_page</literal> handler, is automatically rotated to the current page orientation. It is "
"normally within the printer margins, but you can change that via the <methodname>PrintOperation::set_use_full_page()</methodname> method. The "
"default measurement unit is device pixels. To select other units, use the <methodname>PrintOperation::set_unit()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5138(title)
msgid "Rendering text"
msgstr "Darstellen von Text"

#: C/gtkmm-tutorial-in.xml:5140(para)
msgid ""
"Text rendering is done using Pango. The <classname>Pango::Layout</classname> object for printing should be created by calling the "
"<methodname>PrintContext::create_pango_layout()</methodname> method. The <classname>PrintContext</classname> object also provides the page "
"metrics, via <methodname>get_width()</methodname> and <methodname>get_height()</methodname>. The number of pages can be set with "
"<methodname>PrintOperation::set_n_pages()</methodname>. To actually render the Pango text in <literal>on_draw_page</literal>, get a "
"<classname>Cairo::Context</classname> with <methodname>PrintContext::get_cairo_context()</methodname> and show the <classname>Pango::"
"LayoutLine</classname>s that appear within the requested page number."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5155(para)
msgid "See <link linkend=\"sec-printing-example-simple\">an example</link> of exactly how this can be done."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5163(title)
msgid "Asynchronous operations"
msgstr "Asynchrone Vorgänge"

#: C/gtkmm-tutorial-in.xml:5165(para)
msgid ""
"By default, <methodname>PrintOperation::run()</methodname> returns when a print operation is completed. If you need to run a non-blocking print "
"operation, call <methodname>PrintOperation::set_allow_async()</methodname>. Note that <methodname>set_allow_async()</methodname> is not "
"supported on all platforms, however the <literal>done</literal> signal will still be emitted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5172(para)
msgid ""
"<methodname>run()</methodname> may return <literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>. To track status and handle the result or error "
"you need to implement signal handlers for the <literal>done</literal> and <literal>status_changed</literal> signals:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5180(programlisting)
#, no-wrap
msgid ""
"\n"
"// in class ExampleWindow's method...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// run the op\n"
msgstr ""
"\n"
"// in class ExampleWindow's method...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// run the op\n"

#: C/gtkmm-tutorial-in.xml:5190(programlisting)
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    //notify user\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    //Update PrintSettings with the ones used in this PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"
msgstr ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    //notify user\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    //Update PrintSettings with the ones used in this PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:5189(para)
msgid "Second, check for an error and connect to the <literal>status_changed</literal> signal. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5205(programlisting)
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    //the print job is finished\n"
"  else\n"
"    //get the status with get_status() or get_status_string()\n"
"\n"
"  //update UI\n"
"}\n"
msgstr ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    //the print job is finished\n"
"  else\n"
"    //get the status with get_status() or get_status_string()\n"
"\n"
"  //update UI\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:5204(para)
msgid "Finally, check the status. For instance, <placeholder-1/>"
msgstr "Zum Schluss überprüfen Sie den Status. Zum Beispiel <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5221(title)
msgid "Export to PDF"
msgstr "PDF-Export"

#: C/gtkmm-tutorial-in.xml:5225(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::PrintOperation&gt; op = Gtk::PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"Gtk::PrintOperationResult res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::PrintOperation&gt; op = Gtk::PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"Gtk::PrintOperationResult res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"

#: C/gtkmm-tutorial-in.xml:5222(para)
msgid ""
"The 'Print to file' option is available in the print dialog, without the need for extra implementation. However, it is sometimes useful to "
"generate a pdf file directly from code. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5237(title)
msgid "Extending the print dialog"
msgstr "Erweitern des Druckdialogs"

#: C/gtkmm-tutorial-in.xml:5244(para)
msgid ""
"Set the title of the tab via <methodname>PrintOperation::set_custom_tab_label()</methodname>, create a new widget and return it from the "
"<literal>create_custom_widget</literal> signal handler. You'll probably want this to be a container widget, packed with some others."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5254(para)
msgid "Get the data from the widgets in the <literal>custom_widget_apply</literal> signal handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5239(para)
msgid "You may add a custom tab to the print dialog: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5269(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  Gtk::Box* hbox = new Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 8);\n"
"  hbox-&gt;set_border_width(6);\n"
"\n"
"  Gtk::Label* label = Gtk::manage(new Gtk::Label(\"Enter some text: \"));\n"
"  hbox-&gt;pack_start(*label, false, false);\n"
"  label-&gt;show();\n"
"\n"
"  hbox-&gt;pack_start(m_Entry, false, false);\n"
"  m_Entry.show();\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  Glib::ustring user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"
msgstr ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  Gtk::Box* hbox = new Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 8);\n"
"  hbox-&gt;set_border_width(6);\n"
"\n"
"  Gtk::Label* label = Gtk::manage(new Gtk::Label(\"Enter some text: \"));\n"
"  hbox-&gt;pack_start(*label, false, false);\n"
"  label-&gt;show();\n"
"\n"
"  hbox-&gt;pack_start(m_Entry, false, false);\n"
"  m_Entry.show();\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  Glib::ustring user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:5262(para)
msgid ""
"Although the <literal>custom_widget_apply</literal> signal provides the widget you previously created, to simplify things you can keep the "
"widgets you expect to contain some user input as class members. For example, let's say you have a <classname>Gtk::Entry</classname> called "
"<literal>m_Entry</literal> as a member of your <classname>CustomPrintOperation</classname> class: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5296(para)
msgid "The example in examples/book/printing/advanced demonstrates this."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5303(title)
msgid "Preview"
msgstr "Vorschau"

#: C/gtkmm-tutorial-in.xml:5309(programlisting)
#, no-wrap
msgid ""
"\n"
"// in a class that inherits from Gtk::Window...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"
msgstr ""
"\n"
"// in a class that inherits from Gtk::Window...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"

#: C/gtkmm-tutorial-in.xml:5305(para)
msgid "The native GTK+ print dialog has a preview button, but you may also start a preview directly from an application: <placeholder-1/>"
msgstr ""
"Der native GTK+-Druckdialog verfügt über einen Vorschauknopf, aber Sie können die Vorschau auch direkt aus der Anwendung starten: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5317(para)
msgid ""
"On Unix, the default preview handler uses an external viewer program. On Windows, the native preview dialog will be shown. If necessary you may "
"override this behaviour and provide a custom preview dialog. See the example located in /examples/book/printing/advanced."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5332(para)
msgid ""
"The following example demonstrates how to print some input from a user interface. It shows how to implement <literal>on_begin_print</literal> "
"and <literal>on_draw_page</literal>, as well as how to track print status and update the print settings."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5340(title)
msgid "Printing - Simple"
msgstr "Drucken - Einfach"

#: C/gtkmm-tutorial-in.xml:5355(title)
msgid "Recently Used Documents"
msgstr "Kürzlich geöffnete Dokumente"

#: C/gtkmm-tutorial-in.xml:5357(para)
msgid ""
"<application>gtkmm</application> provides an easy way to manage recently used documents. The classes involved in implementing this "
"functionality are <classname>RecentManager</classname>, <classname>RecentChooserDialog</classname>, <classname>RecentChooserMenu</classname>, "
"<classname>RecentChooserWidget</classname>, <classname>RecentAction</classname>, and <classname>RecentFilter</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5367(para)
msgid ""
"Each item in the list of recently used files is identified by its URI, and can have associated metadata. The metadata can be used to specify "
"how the file should be displayed, a description of the file, its mime type, which application registered it, whether it's private to the "
"registering application, and several other things."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5375(title)
msgid "RecentManager"
msgstr "RecentManager"

#: C/gtkmm-tutorial-in.xml:5376(para)
msgid ""
"<classname>RecentManager</classname> acts as a database of recently used files. You use this class to register new files, remove files from the "
"list, or look up recently used files. There is one list of recently used files per user."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5382(para)
msgid ""
"You can create a new <classname>RecentManager</classname>, but you'll most likely just want to use the default one. You can get a reference to "
"the default <classname>RecentManager</classname> with <methodname>get_default()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5388(para)
msgid ""
"<classname>RecentManager</classname> is the model of a model-view pattern, where the view is a class that implements the "
"<classname>RecentChooser</classname> interface."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5394(title)
msgid "Adding Items to the List of Recent Files"
msgstr "Hinzufügen von Objekten zur Liste der kürzlich geöffneten Dateien"

#: C/gtkmm-tutorial-in.xml:5395(para)
msgid "To add a new file to the list of recent documents, in the simplest case, you only need to provide the URI. For example:"
msgstr ""
"Im einfachsten Fall müssen Sie zum Hinzufügen einer Datei zur Liste der kürzlich geöffneten Dateien nur deren Adresse angeben. Zum Beispiel:"

#: C/gtkmm-tutorial-in.xml:5399(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::RecentManager&gt; recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"
msgstr ""
"Glib::RefPtr&lt;Gtk::RecentManager&gt; recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"

#: C/gtkmm-tutorial-in.xml:5401(para)
msgid ""
"If you want to register a file with metadata, you can pass a <classname>RecentManager::Data</classname> parameter to <methodname>add_item()</"
"methodname>. The metadata that can be set on a particular file item is as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5409(para)
msgid ""
"<varname>app_exec</varname>: The command line to be used to launch this resource. This string may contain the \"f\" and \"u\" escape characters "
"which will be expanded to the resource file path and URI respectively"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5415(para)
msgid "<varname>app_name</varname>: The name of the application that registered the resource"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5419(para)
msgid "<varname>description</varname>: A short description of the resource as a UTF-8 encoded string"
msgstr "<varname>description</varname>: Eine Kurzbeschreibung der Ressource als UTF-8-kodierte Zeichenkette"

#: C/gtkmm-tutorial-in.xml:5423(para)
msgid "<varname>display_name</varname>: The name of the resource to be used for display as a UTF-8 encoded string"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5427(para)
msgid ""
"<varname>groups</varname>: A list of groups associated with this item. Groups are essentially arbitrary strings associated with a particular "
"resource. They can be thought of as 'categories' (such as \"email\", \"graphics\", etc) or tags for the resource."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5433(para)
msgid "<varname>is_private</varname>: Whether this resource should be visible only to applications that have registered it or not"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5437(para)
msgid "<varname>mime_type</varname>: The MIME type of the resource"
msgstr "<varname>mime_type</varname>: Der MIME-Type der Ressource"

#: C/gtkmm-tutorial-in.xml:5440(para)
msgid "In addition to adding items to the list, you can also look up items from the list and modify or remove items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5446(title)
msgid "Looking up Items in the List of Recent Files"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5447(para)
msgid ""
"To look up recently used files, <classname>RecentManager</classname> provides several functions. To look up a specific item by its URI, you can "
"use the <methodname>lookup_item()</methodname> function, which will return a <classname>RecentInfo</classname> class. If the specified URI did "
"not exist in the list of recent files, <methodname>lookup_item()</methodname> throws a <classname>RecentManagerError</classname> exception. For "
"example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5456(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;\n"
"try\n"
"{\n"
"  info = recent_manager-&gt;lookup_item(uri);\n"
"}\n"
"catch(const Gtk::RecentManagerError&amp; ex)\n"
"{\n"
"  std::cerr &lt;&lt; \"RecentManagerError: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n"
"}\n"
"if (info)\n"
"{\n"
"  // item was found\n"
"}"
msgstr ""
"Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;\n"
"try\n"
"{\n"
"  info = recent_manager-&gt;lookup_item(uri);\n"
"}\n"
"catch(const Gtk::RecentManagerError&amp; ex)\n"
"{\n"
"  std::cerr &lt;&lt; \"RecentManagerError: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n"
"}\n"
"if (info)\n"
"{\n"
"  // item was found\n"
"}"

#: C/gtkmm-tutorial-in.xml:5469(para)
msgid ""
"A <classname>RecentInfo</classname> object is essentially an object containing all of the metadata about a single recently-used file. You can "
"use this object to look up any of the properties listed <link linkend=\"list-file-metadata\">above</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5475(para)
msgid ""
"If you don't want to look for a specific URI, but instead want to get a list of all recently used items, <classname>RecentManager</classname> "
"provides the <methodname>get_items()</methodname> function. The return value of this function is a <classname>std::vector</classname> of all "
"recently used files. The following code demonstrates how you might get a list of recently used files:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5483(programlisting)
#, no-wrap
msgid "std::vector&lt; Glib::RefPtr&lt;Gtk::RecentInfo&gt; &gt; info_list = recent_manager-&gt;get_items();"
msgstr "std::vector&lt; Glib::RefPtr&lt;Gtk::RecentInfo&gt; &gt; info_list = recent_manager-&gt;get_items();"

#: C/gtkmm-tutorial-in.xml:5484(para)
msgid ""
"The maximum age of items in the recently used files list can be set with <methodname>Gtk::Settings::property_gtk_recent_files_max_age()</"
"methodname>. Default value: 30 days."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5491(title)
msgid "Modifying the List of Recent Files"
msgstr "Anpassen der Liste der kürzlich geöffneten Dateien"

#: C/gtkmm-tutorial-in.xml:5492(para)
msgid ""
"There may be times when you need to modify the list of recent files. For instance, if a file is moved or renamed, you may need to update the "
"file's location in the recent files list so that it doesn't point to an incorrect location. You can update an item's location by using "
"<methodname>move_item()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5499(para)
msgid ""
"In addition to changing a file's URI, you can also remove items from the list, either one at a time or by clearing them all at once. The former "
"is accomplished with <methodname>remove_item()</methodname>, the latter with <methodname>purge_items()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5506(para)
msgid ""
"The functions <methodname>move_item()</methodname>, <methodname>remove_item()</methodname> and <methodname>purge_items()</methodname> have no "
"effect on the actual files that are referred to by the URIs, they only modify the list of recent files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5518(title)
msgid "RecentChooser"
msgstr "RecentChooser"

#: C/gtkmm-tutorial-in.xml:5519(para)
msgid ""
"<classname>RecentChooser</classname> is an interface that can be implemented by widgets displaying the list of recently used files. "
"<application>gtkmm</application> provides four built-in implementations for choosing recent files: <classname>RecentChooserWidget</classname>, "
"<classname>RecentChooserDialog</classname>, <classname>RecentChooserMenu</classname>, and <classname>RecentAction</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5528(para)
msgid ""
"<classname>RecentChooserWidget</classname> is a simple widget for displaying a list of recently used files. <classname>RecentChooserWidget</"
"classname> is the basic building block for <classname>RecentChooserDialog</classname>, but you can embed it into your user interface if you "
"want to."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5535(para)
msgid "<classname>RecentChooserMenu</classname> and <classname>RecentAction</classname> allow you to list recently used files as a menu."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5541(title)
msgid "Simple RecentChooserDialog example"
msgstr "Einfaches Beispiel für RecentChooserDialog"

#: C/gtkmm-tutorial-in.xml:5542(para)
msgid ""
"Shown below is a simple example of how to use the <classname>RecentChooserDialog</classname> and the <classname>RecentAction</classname> "
"classes in a program. This simple program has a menubar with a <guimenuitem>Recent Files Dialog</guimenuitem> menu item. When you select this "
"menu item, a dialog pops up showing the list of recently used files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5552(para)
msgid ""
"If this is the first time you're using a program that uses the Recent Files framework, the dialog may be empty at first. Otherwise it should "
"show the list of recently used documents registered by other applications."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5559(para)
msgid "After selecting the <guimenuitem>Recent Files Dialog</guimenuitem> menu item, you should see something similar to the following window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5568(para)
msgid ""
"The constructor for <classname>ExampleWindow</classname> creates the menu using <classname>UIManager</classname> (see <xref linkend=\"chapter-"
"menus-and-toolbars\"/> for more information). It then adds the menu and the toolbar to the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5576(title)
msgid "Filtering Recent Files"
msgstr "Filtern kürzlich geöffneter Dateien"

#: C/gtkmm-tutorial-in.xml:5577(para)
msgid ""
"For any of the <classname>RecentChooser</classname> classes, if you don't wish to display all of the items in the list of recent files, you can "
"filter the list to show only those that you want. You can filter the list with the help of the <classname>RecentFilter</classname> class. This "
"class allows you to filter recent files by their name (<methodname>add_pattern()</methodname>), their mime type (<methodname>add_mime_type()</"
"methodname>), the application that registered them (<methodname>add_application()</methodname>), or by a custom filter function "
"(<methodname>add_custom()</methodname>). It also provides the ability to filter based on how long ago the file was modified and which groups it "
"belongs to."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5590(para)
msgid ""
"After you've created and set up the filter to match only the items you want, you can apply a filter to a chooser widget with the "
"<methodname>RecentChooser::add_filter()</methodname> function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5600(title)
msgid "Plugs and Sockets"
msgstr "Plugs und Sockets"

#: C/gtkmm-tutorial-in.xml:5602(title) C/gtkmm-tutorial-in.xml:5759(title)
msgid "Overview"
msgstr "Übersicht"

#: C/gtkmm-tutorial-in.xml:5603(para)
msgid ""
"From time to time, it may be useful to be able to embed a widget from another application within your application. <application>gtkmm</"
"application> allows you to do this with the <classname>Gtk::Socket</classname> and <classname>Gtk::Plug</classname> classes. It is not "
"anticipated that very many applications will need this functionality, but in the rare case that you need to display a widget that is running in "
"a completely different process, these classes can be very helpful."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5612(para)
msgid ""
"The communication between a <classname>Socket</classname> and a <classname>Plug</classname> follows the XEmbed protocol. This protocol has also "
"been implemented in other toolkits (e.g. Qt), which allows the same level of integration when embedding a Qt widget in GTK+ or vice versa."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5618(para)
msgid ""
"The way that <classname>Sockets</classname> and <classname>Plugs</classname> work together is through their window ids. Both a "
"<classname>Socket</classname> and a <classname>Plug</classname> have IDs that can be retrieved with their <methodname>get_id()</methodname> "
"member functions. The use of these IDs will be explained below in <xref linkend=\"sec-connecting-plugs-sockets\"/>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5627(title)
msgid "Sockets"
msgstr "Sockets"

#: C/gtkmm-tutorial-in.xml:5628(para)
msgid ""
"A <classname>Socket</classname> is a special kind of container widget that provides the ability to embed widgets from one process into another "
"process in a way that is transparent to the user."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5635(title)
msgid "Plugs"
msgstr "Plugs"

#: C/gtkmm-tutorial-in.xml:5636(para)
msgid ""
"A <classname>Plug</classname> is a special kind of Window that can be plugged into a <classname>Socket</classname>. Besides the normal "
"properties and methods of <classname>Gtk::Window</classname>, a <classname>Plug</classname> provides a constructor that takes the ID of a "
"<classname>Socket</classname>, which will automatically embed the <classname>Plug</classname> into the <classname>Socket</classname> that "
"matches that ID."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5645(para)
msgid ""
"Since a <classname>Plug</classname> is just a special type of <classname>Gtk::Window</classname> class, you can add containers or widgets to it "
"like you would to any other window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5652(title)
msgid "Connecting Plugs and Sockets"
msgstr "Verbinden von Plugs und Sockets"

#: C/gtkmm-tutorial-in.xml:5653(para)
msgid ""
"After a <classname>Socket</classname> or <classname>Plug</classname> object is realized, you can obtain its ID with its <methodname>get_id()</"
"methodname> function. This ID can then be shared with other processes so that other processes know how to connect to each other."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5664(para)
msgid ""
"Create a <classname>Socket</classname> object in one process and pass the ID of that <classname>Socket</classname> to another process so that "
"it can create a <classname>Plug</classname> object by specifying the given <classname>Socket</classname> ID in its constructor. There is no way "
"to assign a <classname>Plug</classname> to a particular <classname>Socket</classname> after creation, so you must pass the <classname>Socket</"
"classname> ID to the <classname>Plug</classname>'s constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5677(para)
msgid ""
"Create a <classname>Plug</classname> independantly from any particular <classname>Socket</classname> and pass the ID of the <classname>Plug</"
"classname> to other processes that need to use it. The ID of the <classname>Plug</classname> can be associated with a particular "
"<classname>Socket</classname> object using the <methodname>Socket::add_id()</methodname> function. This is the approach used in the example "
"below."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5660(para)
msgid "There are two basic strategies that can be used: <placeholder-1/>"
msgstr "Zwei grundlegende Strategien können angewendet werden: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5692(title)
msgid "Plugs and Sockets Example"
msgstr "Beispiel für Plugs und Sockets"

#: C/gtkmm-tutorial-in.xml:5693(para)
msgid ""
"The following is a simple example of using sockets and plugs. The method of communication between processes is deliberately kept very simple: "
"The <classname>Plug</classname> writes its ID out to a text file named <filename>plug.id</filename> and the process with the socket reads the "
"ID from this file. In a real program, you may want to use a more sophisticated method of inter-process communication."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5702(para)
msgid ""
"This example creates two executable programs: <filename>socket</filename> and <filename>plug</filename>. The idea is that <filename>socket</"
"filename> has an application window that will embed a widget from the <filename>plug</filename> program. The way this example is designed, "
"<filename>plug</filename> must be running first before starting <filename>socket</filename>. To see the example in action, execute the "
"following commands in order from within the example directory:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5711(para)
msgid "Start the <filename>plug</filename> program and send it to the background (or just use a different terminal)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5715(screen)
#, no-wrap
msgid "$ ./plug &amp;"
msgstr "$ ./plug &amp;"

#: C/gtkmm-tutorial-in.xml:5716(para)
msgid "After which you should see something like the following:"
msgstr "Danach sollten Sie etwa Folgendes sehen:"

#: C/gtkmm-tutorial-in.xml:5719(screen)
#, no-wrap
msgid "The window ID is: 69206019"
msgstr "The window ID is: 69206019"

#: C/gtkmm-tutorial-in.xml:5720(para)
msgid "Then start the <filename>socket</filename> program:"
msgstr "Dann starten Sie das <filename>socket</filename>-Programm:"

#: C/gtkmm-tutorial-in.xml:5721(screen)
#, no-wrap
msgid "$ ./socket"
msgstr "$ ./socket"

#: C/gtkmm-tutorial-in.xml:5722(para)
msgid "After starting <filename>socket</filename>, you should see the following output in the terminal:"
msgstr "Nach dem Starten von <filename>socket</filename> sollte Folgendes im Terminal ausgegeben werden:"

#: C/gtkmm-tutorial-in.xml:5726(screen)
#, no-wrap
msgid ""
"I've been embedded.\n"
"A plug was added"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5728(para)
msgid ""
"The first line of output is from <filename>plug</filename>, after it has been notified that it has been embedded inside of a <classname>Socket</"
"classname>. The second line was emitted by <filename>socket</filename> in response to its <methodname>plug_added</methodname> signal. If "
"everything was done as described above, the <filename>socket</filename> window should look roughly like the following:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5740(para)
msgid ""
"If for some reason the <classname>Socket</classname> couldn't attach the <classname>Plug</classname>, the window would look something like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5751(title)
msgid "Keyboard Events"
msgstr "Tastaturereignisse"

#: C/gtkmm-tutorial-in.xml:5752(para)
msgid ""
"X events differ in some ways from other signals. These differences are described in the <link linkend=\"sec-xeventsignals\">X Event signals</"
"link> section in the appendix. Here we will use keyboard events to show how X events can be used in a program."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5760(para)
msgid "Whenever you press or release a key, an event is emitted. You can connect a signal handler to handle such events."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5764(para)
msgid ""
"To receive the keyboard events, you must first call the <methodname>Gtk::Widget::add_events()</methodname> function with a bit mask of the "
"events you're interested in. The event signal handler will receive an argument that depends on the type of event. For keyboard events it's a "
"<type>GdkEventKey*</type>. As discribed in the <link linkend=\"sec-xeventsignals\">appendix</link>, the event signal handler returns a "
"<type>bool</type> value, to indicate that the signal is fully handled (<literal>true</literal>) or allow event propagation (<literal>false</"
"literal>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5775(para)
msgid ""
"To determine which key was pressed or released, you read the value of <varname>GdkEventKey::keyval</varname> and compare it with a constant in "
"the <filename>&lt;gdk/gdkkeysyms.h&gt;</filename> header file. The states of modifier keys (shift, ctrl, etc.) are available as bit-flags in "
"<varname>GdkEventKey::state</varname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5784(programlisting)
#, no-wrap
msgid ""
"\n"
"bool on_key_press_or_release_event(GdkEventKey* event)\n"
"{\n"
"  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;\n"
"    event-&gt;keyval == GDK_KEY_1 &amp;&amp;\n"
"    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)\n"
"  {\n"
"    handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key\n"
"    return true;\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"Gtk::Entry m_entry; // in a class definition\n"
"\n"
"// in the class constructor\n"
"m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.add_events(Gdk::KEY_PRESS_MASK | Gdk::KEY_RELEASE_MASK);\n"
msgstr ""
"\n"
"bool on_key_press_or_release_event(GdkEventKey* event)\n"
"{\n"
"  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;\n"
"    event-&gt;keyval == GDK_KEY_1 &amp;&amp;\n"
"    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)\n"
"  {\n"
"    handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key\n"
"    return true;\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"Gtk::Entry m_entry; // in a class definition\n"
"\n"
"// in the class constructor\n"
"m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.add_events(Gdk::KEY_PRESS_MASK | Gdk::KEY_RELEASE_MASK);\n"

#: C/gtkmm-tutorial-in.xml:5782(para) C/gtkmm-tutorial-in.xml:8087(para)
msgid "Here's a simple example: <placeholder-1/>"
msgstr "Hier ist ein einfaches Beispiel: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5808(para)
msgid ""
"In this example there are three keyboard shortcuts: <keycap>Alt</keycap>+<keycap>1</keycap> selects the first radio button, <keycap>Alt</keycap>"
"+<keycap>2</keycap> selects the second one, and the <keycap>Esc</keycap> key hides (closes) the window. The default event signal handler is "
"overridden, as described in the <link linkend=\"sec-overriding-default-signal-handlers\">Overriding default signal handlers</link> section in "
"the appendix."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5819(title)
msgid "Keyboard Events - Simple"
msgstr "Tastaturereignisse - Einfach"

#: C/gtkmm-tutorial-in.xml:5830(title)
msgid "Event Propagation"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5831(para)
msgid ""
"Event propagation means that, when an event is emitted on a particular widget, it can be passed to its parent widget (and that widget can pass "
"it to its parent, and so on) and, if the parent has an event handler, that handler will be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5837(para)
msgid ""
"Contrary to other events, keyboard events are first sent to the toplevel window (<classname>Gtk::Window</classname>), where it will be checked "
"for any keyboard shortcuts that may be set (accelerator keys and mnemonics, used for selecting menu items from the keyboard). After this (and "
"assuming the event wasn't handled), it is sent to the widget which has focus, and the propagation begins from there."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5845(para)
msgid ""
"The event will propagate until it reaches the top-level widget, or until you stop the propagation by returning <literal>true</literal> from an "
"event handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5850(para)
msgid "Notice, that after canceling an event, no other function will be called (even if it is from the same widget)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5857(para)
msgid ""
"In this example there are three event handlers that are called after <classname>Gtk::Window</classname>'s default event handler, one in the "
"<classname>Gtk::Entry</classname>, one in the <classname>Gtk::Grid</classname> and one in the <classname>Gtk::Window</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5863(para)
msgid ""
"In the <classname>Gtk::Window</classname>, we have also the default handler overridden (<methodname>on_key_release_event()</methodname>), and "
"another handler being called before the default handler (<methodname>windowKeyReleaseBefore()</methodname>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5869(para)
msgid "The purpose of this example is to show the steps the event takes when it is emitted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5872(para)
msgid ""
"When you write in the entry, a key release event will be emitted, which will go first to the toplevel window (<classname>Gtk::Window</"
"classname>), since we have one event handler set to be called before, that's what is called first (<methodname>windowKeyReleaseBefore()</"
"methodname>). Then the default handler is called (which we have overridden), and after that the event is sent to the widget that has focus, the "
"<classname>Entry</classname> in our example and, depending on whether we let it propagate, it can reach the <classname>Grid</classname>'s and "
"the <classname>Window</classname>'s event handlers. If it propagates, the text you're writing will appear in the <classname>Label</classname> "
"above the <classname>Entry</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5887(title)
msgid "Keyboard Events - Event Propagation"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5899(title)
msgid "Timeouts, I/O and Idle Functions"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5902(title)
msgid "Timeouts"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5904(para)
msgid ""
"You may be wondering how to make <application>gtkmm</application> do useful work while it's idling along. Happily, you have several options. "
"Using the following methods you can create a timeout method that will be called every few milliseconds."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5911(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot, unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"
msgid ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"

#: C/gtkmm-tutorial-in.xml:5917(para)
msgid ""
"The first argument is a <classname>slot</classname> you wish to have called when the timeout occurs. The second argument is the number of "
"milliseconds between calls to that method. You receive a <classname>sigc::connection</classname> object that can be used to deactivate the "
"connection using its <methodname>disconnect()</methodname> method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5927(programlisting)
#, no-wrap
msgid ""
"\n"
"my_connection.disconnect();\n"
msgstr ""
"\n"
"my_connection.disconnect();\n"

#: C/gtkmm-tutorial-in.xml:5939(programlisting)
#, no-wrap
msgid ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n\" &lt;&lt; std::endl; return true; }\n"
msgstr ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n\" &lt;&lt; std::endl; return true; }\n"

#: C/gtkmm-tutorial-in.xml:5932(para)
msgid ""
"Another way of destroying the connection is your signal handler. It has to be of the type <classname>sigc::slot&lt;bool&gt;</classname>. As you "
"see from the definition your signal handler has to return a value of the type <literal>bool</literal>. A definition of a sample method might "
"look like this: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5945(para)
msgid ""
"You can stop the timeout method by returning <literal>false</literal> from your signal handler. Therefore, if you want your method to be called "
"repeatedly, it should return <literal>true</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5951(para)
msgid "Here's an example of this technique:"
msgstr "Hier ein Beispiel für diese Technik:"

#: C/gtkmm-tutorial-in.xml:5960(title)
msgid "Monitoring I/O"
msgstr "Überwachung von Ein- und Ausgaben"

#: C/gtkmm-tutorial-in.xml:5962(para)
msgid ""
"A nifty feature of Glib (one of the libraries underlying <application>gtkmm</application>) is the ability to have it check for data on a file "
"descriptor for you. This is especially useful for networking applications. The following method is used to do this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5970(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "sigc::connection Glib::SignalInput::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,\n"
#| "                                    int fd, Glib::IOCondition condition,\n"
#| "                                    int priority = Glib::PRIORITY_DEFAULT);\n"
msgid ""
"\n"
"sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,\n"
"                                 int fd, Glib::IOCondition condition,\n"
"                                 int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""
"\n"
"sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,\n"
"                                 int fd, Glib::IOCondition condition,\n"
"                                 int priority = Glib::PRIORITY_DEFAULT);\n"

#: C/gtkmm-tutorial-in.xml:5977(para)
msgid ""
"The first argument is a slot you wish to have called when the specified event (see argument 3) occurs on the file descriptor you specify using "
"argument two. Argument three may be one or more (using <literal>|</literal>) of:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5987(para)
msgid "Glib::IO_IN - Call your method when there is data ready for reading on your file descriptor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5995(para)
msgid "Glib::IO_OUT - Call your method when the file descriptor is ready for writing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6003(para)
msgid "Glib::IO_PRI - Call your method when the file descriptor has urgent data to be read."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6010(para)
msgid "Glib::IO_ERR - Call your method when an error has occurred on the file descriptor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6017(para)
msgid "Glib::IO_HUP - Call your method when hung up (the connection has been broken usually for pipes and sockets)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6024(para)
msgid ""
"The return value is a <classname>sigc::connection</classname> that may be used to stop monitoring this file descriptor using its "
"<methodname>disconnect()</methodname> method. The <parameter>slot</parameter> signal handler should be declared as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6031(programlisting)
#, no-wrap
msgid ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"
msgstr ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"

#: C/gtkmm-tutorial-in.xml:6036(para)
msgid ""
"where <parameter>condition</parameter> is as specified above. As usual the slot is created with <function>sigc::mem_fun()</function> (for a "
"member method of an object), or <function>sigc::ptr_fun()</function> (for a function)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6043(para)
msgid ""
"A little example follows. To use the example just execute it from a terminal; it doesn't create a window. It will create a pipe named "
"<literal>testfifo</literal> in the current directory. Then start another shell and execute <literal>echo \"Hello\" &gt; testfifo</literal>. The "
"example will print each line you enter until you execute <literal>echo \"Q\" &gt; testfifo</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6057(title)
msgid "Idle Functions"
msgstr "Untätigkeitsfunktionen"

#: C/gtkmm-tutorial-in.xml:6059(para)
msgid "If you want to specify a method that gets called when nothing else is happening, use the following:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6064(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot, int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"
msgid ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"
msgstr ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"

#: C/gtkmm-tutorial-in.xml:6070(para)
msgid ""
"This causes <application>gtkmm</application> to call the specified method whenever nothing else is happening. You can add a priority (lower "
"numbers are higher priorities). There are two ways to remove the signal handler: calling <methodname>disconnect()</methodname> on the "
"<classname>sigc::connection</classname> object, or returning <literal>false</literal> in the signal handler, which should be declared as "
"follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6080(programlisting)
#, no-wrap
msgid ""
"\n"
"bool idleFunc();\n"
msgstr ""
"\n"
"bool idleFunc();\n"

#: C/gtkmm-tutorial-in.xml:6085(para)
msgid ""
"Since this is very similar to the methods above this explanation should be sufficient to understand what's going on. However, here's a little "
"example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6092(para)
msgid ""
"This example points out the difference of idle and timeout methods a little. If you need methods that are called periodically, and speed is not "
"very important, then you want timeout methods. If you want methods that are called as often as possible (like calculating a fractal in "
"background), then use idle methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6100(para)
msgid "Try executing the example and increasing the system load. The upper progress bar will increase steadily; the lower one will slow down."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6110(title)
msgid "Memory management"
msgstr "Speicherverwaltung"

#: C/gtkmm-tutorial-in.xml:6116(title)
msgid "Normal C++ memory management"
msgstr "Normale C++-Speicherverwaltung"

#: C/gtkmm-tutorial-in.xml:6118(para)
msgid ""
"<application>gtkmm</application> allows the programmer to control the lifetime (that is, the construction and destruction) of any widget in the "
"same manner as any other C++ object. This flexibility allows you to use <literal>new</literal> and <literal>delete</literal> to create and "
"destroy objects dynamically or to use regular class members (that are destroyed automatically when the class is destroyed) or to use local "
"instances (that are destroyed when the instance goes out of scope). This flexibility is not present in some C++ GUI toolkits, which restrict "
"the programmer to only a subset of C++'s memory management features."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6130(para)
msgid "Here are some examples of normal C++ memory management:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6133(title)
msgid "Class Scope widgets"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6135(para)
msgid ""
"If a programmer does not need dynamic memory allocation, automatic widgets in class scope may be used. One advantage of automatic widgets in "
"class scope is that memory management is grouped in one place. The programmer does not risk memory leaks from failing to <literal>delete</"
"literal> a widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6142(para)
msgid ""
"The primary disadvantage of using class scope widgets is revealing the class implementation rather than the class interface in the class header."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6148(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "#include &lt;gtkmm/button.h&gt;\n"
#| "class Foo\n"
#| "{\n"
#| "private:\n"
#| "  Gtk::Button theButton;\n"
#| "  // will be destroyed when the Foo object is destroyed\n"
#| "};\n"
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"#include &lt;gtkmm/window.h&gt;\n"
"class Foo : public Gtk::Window\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // will be destroyed when the Foo object is destroyed\n"
"};\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"#include &lt;gtkmm/window.h&gt;\n"
"class Foo : public Gtk::Window\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // will be destroyed when the Foo object is destroyed\n"
"};\n"

#: C/gtkmm-tutorial-in.xml:6162(title)
msgid "Function scope widgets"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6168(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "{\n"
#| "  Gtk::Button aButton;\n"
#| "  aButton.show();\n"
#| "  ...\n"
#| "  kit.run();\n"
#| "}\n"
msgid ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  app-&gt;run();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6164(para)
msgid ""
"If a programmer does not need a class scope widget, a function scope widget may also be used. The advantages to function scope over class scope "
"are the increased data hiding and reduced dependencies. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6180(title)
msgid "Dynamic allocation with new and delete"
msgstr "Dynamische Zuweisung mit new und delete"

#: C/gtkmm-tutorial-in.xml:6188(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Button* pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// do something useful with pButton\n"
"\n"
"delete pButton;\n"
msgstr ""
"\n"
"Gtk::Button* pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// do something useful with pButton\n"
"\n"
"delete pButton;\n"

#: C/gtkmm-tutorial-in.xml:6182(para)
msgid ""
"Although, in most cases, the programmer will prefer to allow containers to automatically destroy their children using <function>Gtk::manage()</"
"function> (see below), the programmer is not required to use <function>Gtk::manage()</function>. The traditional <literal>new</literal> and "
"<literal>delete</literal> operators may also be used. <placeholder-1/> Here, the programmer deletes <varname>pButton</varname> to prevent a "
"memory leak."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6202(title)
msgid "Managed Widgets"
msgstr "Verwaltete Widgets"

#: C/gtkmm-tutorial-in.xml:6204(para)
msgid ""
"Alternatively, you can let a widget's container control when the widget is destroyed. In most cases, you want a widget to last only as long as "
"the container it is in. To delegate the management of a widget's lifetime to its container, first create it with <function>Gtk::manage()</"
"function> and pack it into its container with <methodname>Gtk::Container::add()</methodname>, <methodname>Gtk::Box::pack_start()</methodname>, "
"or a similar method. Now the widget will be destroyed whenever its container is destroyed."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6215(title)
msgid "Dynamic allocation with manage() and add()"
msgstr "Dynamische Zuweisung mit manage() und add()"

#: C/gtkmm-tutorial-in.xml:6217(para)
msgid ""
"<application>gtkmm</application> provides the <function>manage()</function> function and <methodname>add()</methodname> methods to create and "
"destroy widgets. Every widget except a top-level window must be added or packed into a container in order to be displayed. The "
"<function>manage()</function> function marks a widget so that when the widget is added to a container, the container becomes responsible for "
"deleting the widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6227(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "MyWidget::MyWidget()\n"
#| "{\n"
#| "  Gtk::Button* pButton = manage(new Gtk::Button(\"Test\"));\n"
#| "  add(*pButton); //add aButton to MyWidget\n"
#| "}\n"
msgid ""
"\n"
"MyContainer::MyContainer()\n"
"{\n"
"  Gtk::Button* pButton = Gtk::manage(new Gtk::Button(\"Test\"));\n"
"  add(*pButton); //add *pButton to MyContainer\n"
"}\n"
msgstr ""
"\n"
"MyContainer::MyContainer()\n"
"{\n"
"  Gtk::Button* pButton = Gtk::manage(new Gtk::Button(\"Test\"));\n"
"  add(*pButton); //add *pButton to MyContainer\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6226(para)
msgid ""
"<placeholder-1/> Now, when objects of type <classname>MyContainer</classname> are destroyed, the button will also be deleted. It is no longer "
"necessary to delete <varname>pButton</varname> to free the button's memory; its deletion has been delegated to the <classname>MyContainer</"
"classname> object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6240(para)
msgid ""
"Of course, a top-level container will not be added to another container. The programmer is responsible for destroying the top-level container "
"using one of the traditional C++ techniques. For instance, your top-level Window might just be an instance in your <function>main()</function> "
"function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6252(title)
msgid "Shared resources"
msgstr "Gemeinsame Ressourcen"

#: C/gtkmm-tutorial-in.xml:6254(para)
msgid ""
"Some objects, such as <classname>Gdk::Pixbuf</classname>s and <classname>Pango::Font</classname>s, are obtained from a shared store. Therefore "
"you cannot instantiate your own instances. These classes typically inherit from <classname>Glib::Object</classname>. Rather than requiring you "
"to reference and unreference these objects, <application>gtkmm</application> uses the <classname>Glib::RefPtr&lt;&gt;</classname> smartpointer. "
"Cairomm has its own smartpointer, <classname>Cairo::RefPtr&lt;&gt;</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6267(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf = Gdk::Pixbuf::create_from_file(filename);\n"

#: C/gtkmm-tutorial-in.xml:6264(para)
msgid ""
"Objects such as <classname>Gdk::Pixbuf</classname> can only be instantiated with a <methodname>create()</methodname> function. For instance, "
"<placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6276(programlisting)
#, no-wrap
msgid ""
"\n"
"int width = 0;\n"
"if(pixbuf)\n"
"{\n"
"  width = pixbuf-&gt;get_width();\n"
"}\n"
msgstr ""
"\n"
"int width = 0;\n"
"if(pixbuf)\n"
"{\n"
"  width = pixbuf-&gt;get_width();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6272(para)
msgid ""
"You have no way of getting a bare <classname>Gdk::Pixbuf</classname>. In the example, <varname>pixbuf</varname> is a smart pointer, so you can "
"do this, much like a normal pointer: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6285(para)
msgid ""
"When <varname>pixbuf</varname> goes out of scope an <methodname>unref()</methodname> will happen in the background and you don't need to worry "
"about it anymore. There's no <literal>new</literal> so there's no <literal>delete</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6293(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf2 = pixbuf;\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf2 = pixbuf;\n"

#: C/gtkmm-tutorial-in.xml:6291(para)
msgid ""
"If you copy a <classname>RefPtr</classname>, for instance <placeholder-1/> , or if you pass it as a method argument or a return type, then "
"<classname>RefPtr</classname> will do any necessary referencing to ensure that the instance will not be destroyed until the last "
"<classname>RefPtr</classname> has gone out of scope."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6301(para)
msgid "See the <link linkend=\"chapter-refptr\">appendix</link> for detailed information about RefPtr."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6306(para)
msgid "Bjarne Stroustrup, \"The C++ Programming Language\" Forth Edition - section 34.3"
msgstr "Bjarne Stroustrup, »The C++ Programming Language«, 4. Ausgabe – Abschnitt 34.3"

#: C/gtkmm-tutorial-in.xml:6309(para)
msgid "Nicolai M. Josuttis, \"The C++ Standard Library\" - section 4.2"
msgstr "Nicolai M. Josuttis, »The C++ Standard Library« - Abschnitt 4.2"

#: C/gtkmm-tutorial-in.xml:6302(para)
msgid "If you wish to learn more about smartpointers, you might look in these books: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6320(title)
msgid "Glade and Gtk::Builder"
msgstr "Glade und Gtk::Builder"

#: C/gtkmm-tutorial-in.xml:6321(para)
msgid ""
"Although you can use C++ code to instantiate and arrange widgets, this can soon become tedious and repetitive. And it requires a recompilation "
"to show changes. The <application>Glade</application> application allows you to layout widgets on screen and then save an XML description of "
"the arrangement. Your application can then use the <application>Gtk::Builder</application> API to load that XML file at runtime and obtain a "
"pointer to specifically named widget instances."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6334(simpara)
msgid "Less C++ code is required."
msgstr "Es wird weniger C++-Code benötigt."

#: C/gtkmm-tutorial-in.xml:6335(simpara)
msgid "UI changes can be seen more quickly, so UIs are able to improve."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6336(simpara)
msgid "Designers without programming skills can create and edit UIs."
msgstr "Designer ohne Programmierkenntnisse können grafische Benutzeroberflächen entwerfen und bearbeiten."

#: C/gtkmm-tutorial-in.xml:6331(para)
msgid "This has the following advantages: <placeholder-1/>"
msgstr "Dies hat folgende Vorteile: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6340(para)
msgid ""
"You still need C++ code to deal with User Interface changes triggered by user actions, but using <application>Gtk::Builder</application> for "
"the widget layout allows you to focus on implementing that functionality."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6347(title)
msgid "Loading the .glade file"
msgstr "Laden der .glade-Datei"

#: C/gtkmm-tutorial-in.xml:6352(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"

#: C/gtkmm-tutorial-in.xml:6348(para)
msgid ""
"<classname>Gtk::Builder</classname> must be used via a <classname>Glib::RefPtr</classname>. Like all such classes, you need to use a "
"<methodname>create()</methodname> method to instantiate it. For instance, <placeholder-1/> This will instantiate the windows defined in the ."
"glade file, though they will not be shown immediately unless you have specified that via the <guilabel>Properties</guilabel> window in "
"<application>Glade</application>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6361(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"

#: C/gtkmm-tutorial-in.xml:6360(para)
msgid ""
"To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance, "
"<placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6369(title)
msgid "Accessing widgets"
msgstr "Zugriff auf Widgets"

#: C/gtkmm-tutorial-in.xml:6377(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Dialog* pDialog = 0;\n"
"builder-&gt;get_widget(\"DialogBasic\", pDialog);\n"
msgstr ""
"\n"
"Gtk::Dialog* pDialog = 0;\n"
"builder-&gt;get_widget(\"DialogBasic\", pDialog);\n"

#: C/gtkmm-tutorial-in.xml:6371(para)
msgid ""
"To access a widget, for instance to <methodname>show()</methodname> a dialog, use the <methodname>get_widget()</methodname> method, providing "
"the widget's name. This name should be specified in the <application>Glade</application> Properties window. If the widget could not be found, "
"or is of the wrong type, then the pointer will be set to 0. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6383(para)
msgid ""
"<application>Gtk::Builder</application> checks for a null pointer, and checks that the widget is of the expected type, and will show warnings "
"on the command line about these."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6389(para)
msgid ""
"Remember that you are not instantiating a widget with <methodname>get_widget()</methodname>, you are just obtaining a pointer to one that "
"already exists. You will always receive a pointer to the same instance when you call <methodname>get_widget()</methodname> on the same "
"<classname>Gtk::Builder</classname>, with the same widget name. The widgets are instantiated during <methodname>Gtk::Builder::"
"create_from_file()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6398(para)
msgid ""
"<methodname>get_widget()</methodname> returns child widgets that are <function>manage()</function>ed (see the <link linkend=\"chapter-memory"
"\">Memory Management</link> chapter), so they will be deleted when their parent container is deleted. So, if you get only a child widget from "
"<application>Gtk::Builder</application>, instead of a whole window, then you must either put it in a <classname>Container</classname> or delete "
"it. <classname>Windows</classname> (such as <classname>Dialogs</classname>) cannot be managed because they have no parent container, so you "
"must delete them at some point."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6412(para)
msgid ""
"This simple example shows how to load a <application>Glade</application> file at runtime and access the widgets with <application>Gtk::Builder</"
"application>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6425(title)
msgid "Using derived widgets"
msgstr "Verwenden abgeleiteter Widgets"

#: C/gtkmm-tutorial-in.xml:6426(para)
msgid ""
"You can use <application>Glade</application> to layout your own custom widgets derived from <application>gtkmm</application> widget classes. "
"This keeps your code organized and encapsulated. Of course you won't see the exact appearance and properties of your derived widget in "
"<application>Glade</application>, but you can specify its location and child widgets and the properties of its <application>gtkmm</application> "
"base class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6435(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog* pDialog = 0;\n"
"builder-&gt;get_widget_derived(\"DialogBasic\", pDialog);\n"
msgstr ""
"\n"
"DerivedDialog* pDialog = 0;\n"
"builder-&gt;get_widget_derived(\"DialogBasic\", pDialog);\n"

#: C/gtkmm-tutorial-in.xml:6434(para)
msgid "Use <methodname>Gtk::Builder::get_widget_derived()</methodname> like so: <placeholder-1/>"
msgstr "Verwenden Sie <methodname>Gtk::Builder::get_widget_derived()</methodname> folgendermaßen: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6441(para)
msgid ""
"Your derived class must have a constructor that takes a pointer to the underlying C type, and the <classname>Gtk::Builder</classname> instance. "
"All relevant classes of <application>gtkmm</application> typedef their underlying C type as <classname>BaseObjectType</classname> "
"(<classname>Gtk::Dialog</classname> typedefs <classname>BaseObjectType</classname> as <type>GtkDialog</type>, for instance)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6451(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6448(para)
msgid "You must call the base class's constructor in the initialization list, providing the C pointer. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6463(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(0)\n"
"{\n"
"  //Get the Glade-instantiated Button, and connect a signal handler:\n"
"  m_builder-&gt;get_widget(\"quit_button\", m_pButton);\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(0)\n"
"{\n"
"  //Get the Glade-instantiated Button, and connect a signal handler:\n"
"  m_builder-&gt;get_widget(\"quit_button\", m_pButton);\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6459(para)
msgid ""
"You could then encapsulate the manipulation of the child widgets in the constructor of the derived class, maybe using <methodname>get_widget()</"
"methodname> or <methodname>get_widget_derived()</methodname> again. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6481(para)
msgid "This example shows how to load a <application>Glade</application> file at runtime and access the widgets via a derived class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6494(title)
msgid "Internationalization and Localization"
msgstr "Internationalisierung und Lokalisierung"

#: C/gtkmm-tutorial-in.xml:6496(para)
msgid ""
"<application>gtkmm</application> applications can easily support multiple languages, including non-European languages such as Chinese and right-"
"to-left languages such as Arabic. An appropriately-written and translated <application>gtkmm</application> application will use the appropriate "
"language at runtime based on the user's environment."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6502(para)
msgid ""
"You might not anticipate the need to support additional languages, but you can never rule it out. And it's easier to develop the application "
"properly in the first place rather than retrofitting later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6508(para)
msgid ""
"The process of writing source code that allows for translation is called <literal>internationalization</literal>, often abbreviated to "
"<literal>i18n</literal>. The <literal>Localization</literal> process, sometimes abbreviated as <literal>l10n</literal>, provides translated "
"text for other languages, based on that source code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6516(para)
msgid ""
"The main activity in the internationalization process is finding strings seen by users and marking them for translation. You do not need to do "
"it all at once - if you set up the necessary project infrastructure correctly then your application will work normally regardless of how many "
"strings you've covered."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6524(para)
msgid ""
"String literals should be typed in the source code in English, but surrounded by a macro. The <application>gettext</application> (or intltool) "
"utility can then extract the marked strings for translation, and substitute the translated text at runtime."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6532(title)
msgid "Preparing your project"
msgstr "Einrichten Ihres Projekts"

#: C/gtkmm-tutorial-in.xml:6535(para)
msgid ""
"In the instructions below we will assume that you will not be using <application>gettext</application> directly, but <application>intltool</"
"application>, which was written specifically for <literal>GNOME</literal>. <application>intltool</application> uses <function>gettext()</"
"function>, which extracts strings from source code, but <application>intltool</application> can also combine strings from other files, for "
"example from desktop menu details, and GUI resource files such as <application>Glade</application> files, into standard <application>gettext</"
"application><filename>.pot/.po</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6546(para)
msgid ""
"We also assume that you are using autotools (e.g. <application>automake</application> and <application>autoconf</application>) to build your "
"project, and that you are using <ulink url=\"http://git.gnome.org/browse/gnome-common/tree/autogen.sh\"><literal>./autogen.sh</literal> from "
"<application>gnome-common</application></ulink>, which, among other things, takes care of some <application>intltool</application> "
"initialization."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6559(para)
msgid ""
"Create a sub-directory named <literal>po</literal> in your project's root directory. This directory will eventually contain all of your "
"translations. Within it, create a file named <literal>LINGUAS</literal> and a file named <literal>POTFILES.in</literal>. It is common practice "
"to also create a <literal>ChangeLog</literal> file in the <literal>po</literal> directory so that translators can keep track of translation "
"changes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6569(para)
msgid ""
"<literal>LINGUAS</literal> contains an alphabetically sorted list of codes identifying the languages for which your program is translated "
"(comment lines starting with a <literal>#</literal> are ignored). Each language code listed in the <literal>LINGUAS</literal> file must have a "
"corresponding <literal>.po</literal> file. So, if your program has German and Japanese translations, your <literal>LINGUAS</literal> file would "
"look like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6578(programlisting)
#, no-wrap
msgid ""
"# keep this file sorted alphabetically, one language code per line\n"
"de\n"
"ja"
msgstr ""
"# keep this file sorted alphabetically, one language code per line\n"
"de\n"
"ja"

#: C/gtkmm-tutorial-in.xml:6581(para)
msgid ""
"(In addition, you'd have the files <literal>ja.po</literal> and <literal>de.po</literal> in your <literal>po</literal> directory which contain "
"the German and Japanese translations, respectively.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6588(para)
msgid ""
"<literal>POTFILES.in</literal> is a list of paths to all files which contain strings marked up for translation, starting from the project root "
"directory. So for example, if your project sources were located in a subdirectory named <literal>src</literal>, and you had two files that "
"contained strings that should be translated, your <literal>POTFILES.in</literal> file might look like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6597(programlisting)
#, no-wrap
msgid ""
"src/main.cc\n"
"src/other.cc"
msgstr ""
"src/main.cc\n"
"src/other.cc"

#: C/gtkmm-tutorial-in.xml:6600(para)
msgid ""
"If you are using <application>gettext</application> directly, you can only mark strings for translation if they are in source code file. "
"However, if you use <application>intltool</application>, you can mark strings for translation in a variety of other file formats, including "
"<application>Glade</application> UI files, xml, <ulink url=\"http://standards.freedesktop.org/desktop-entry-spec/latest/\">.desktop files</"
"ulink> and several more. So, if you have designed some of the application UI in <application>Glade</application> then also add your <filename>."
"glade</filename> files to the list in <literal>POTFILES.in</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6613(para)
msgid ""
"Now that there is a place to put your translations, you need to initialize <application>intltool</application> and <application>gettext</"
"application>. Add the following code to your <literal>configure.ac</literal>, substituting 'programname' with the name of your program:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6620(programlisting)
#, no-wrap
msgid ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=programname\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [The domain to use with gettext])\n"
"AM_GLIB_GNU_GETTEXT\n"
"\n"
"PROGRAMNAME_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(PROGRAMNAME_LOCALEDIR)"
msgstr ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=programname\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [The domain to use with gettext])\n"
"AM_GLIB_GNU_GETTEXT\n"
"\n"
"PROGRAMNAME_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(PROGRAMNAME_LOCALEDIR)"

#: C/gtkmm-tutorial-in.xml:6631(para)
msgid ""
"This <varname>PROGRAMNAME_LOCALEDIR</varname> variable will be used later in the <literal>Makefile.am</literal> file, to define a macro that "
"will be used when you initialize <application>gettext</application> in your source code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6642(para)
msgid ""
"Add <literal>po</literal> to the <literal>SUBDIRS</literal> variable. Without this, your translations won't get built and installed when you "
"build the program"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6649(programlisting)
#, no-wrap
msgid ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"
msgstr ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"

#: C/gtkmm-tutorial-in.xml:6647(para)
msgid "Define <literal>INTLTOOL_FILES</literal> as: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6655(para)
msgid ""
"Add <literal>INTLTOOL_FILES</literal> to the <literal>EXTRA_DIST</literal> list of files. This ensures that when you do a <command>make dist</"
"command>, these commands will be included in the source tarball."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6665(programlisting)
#, no-wrap
msgid ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"
msgstr ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"

#: C/gtkmm-tutorial-in.xml:6663(para)
msgid "Update your <literal>DISTCLEANFILES</literal>: <placeholder-1/>"
msgstr "Aktualisieren Sie Ihre <literal>DISTCLEANFILES</literal>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6638(para)
msgid "In the top-level Makefile.am: <placeholder-1/>"
msgstr "In der Datei Makefile.am der obersten Ebene: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6674(para)
msgid "In your <literal>src/Makefile.am</literal>, update your <literal>AM_CPPFLAGS</literal> to add the following preprocessor macro definition:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6679(programlisting)
#, no-wrap
msgid "AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\\"${PROGRAMNAME_LOCALEDIR}\\\""
msgstr "AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\\"${PROGRAMNAME_LOCALEDIR}\\\""

#: C/gtkmm-tutorial-in.xml:6680(para)
msgid "This macro will be used when you initialize <literal>gettext</literal> in your source code."
msgstr "Dieses Makro wird verwendet, wenn Sie <literal>gettext</literal> in Ihrem Quellcode initialisieren."

#: C/gtkmm-tutorial-in.xml:6687(title)
msgid "Marking strings for translation"
msgstr "Markieren von Zeichenketten für die Übersetzung"

#: C/gtkmm-tutorial-in.xml:6689(para)
msgid ""
"String literals should be typed in the source code in English, but they should be surrounded by a call to the <function>gettext()</function> "
"function. These strings will be extracted for translation and the translations may be used at runtime instead of the original English strings."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6697(para)
msgid ""
"The <application>GNU gettext</application> package allows you to mark strings in source code, extract those strings for translation, and use "
"the translated strings in your application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6709(programlisting)
#, no-wrap
msgid "display_message(\"Getting ready for i18n.\");"
msgstr "display_message(\"Getting ready for i18n.\");"

#: C/gtkmm-tutorial-in.xml:6711(programlisting)
#, no-wrap
msgid "display_message(_(\"Getting ready for i18n.\"));"
msgstr "display_message(_(\"Getting ready for i18n.\"));"

#: C/gtkmm-tutorial-in.xml:6703(para)
msgid ""
"However, <application>Glib</application> defines <function>gettext()</function> support macros which are shorter wrappers in an easy-to-use "
"form. To use these macros, include <literal>&lt;glibmm/i18n.h&gt;</literal>, and then, for example, substitute: <placeholder-1/> with: "
"<placeholder-2/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6722(programlisting)
#, no-wrap
msgid "xgettext -a -o my-strings --omit-header *.cc *.h"
msgstr "xgettext -a -o my-strings --omit-header *.cc *.h"

#: C/gtkmm-tutorial-in.xml:6714(para)
msgid ""
"For reference, it is possible to generate a file which contains all strings which appear in your code, even if they are not marked for "
"translation, together with file name and line number references. To generate such a file named <literal>my-strings</literal>, execute the "
"following command, within the source code directory: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6729(programlisting)
#, no-wrap
msgid ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"
msgstr ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"

#: C/gtkmm-tutorial-in.xml:6725(para)
msgid ""
"Finally, to let your program use the translation for the current locale, add this code to the beginning of your <filename>main.cc</filename> "
"file, to initialize gettext. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6735(title)
msgid "How gettext works"
msgstr "Funktionsweise von Gettext"

#: C/gtkmm-tutorial-in.xml:6737(para)
msgid ""
"<application>intltool</application> / <application>xgettext</application> script extracts the strings and puts them in a <filename>mypackage."
"pot</filename> file. The translators of your application create their translations by first copying this <filename>.pot</filename> file to a "
"<filename>localename.po</filename> file. A locale identifies a language and an encoding for that language, including date and numerical "
"formats. Later, when the text in your source code has changed, the <literal>msmerge</literal> script is used to update the <filename>localename."
"po</filename> files from the regenerated <filename>.pot</filename> file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6751(para)
msgid ""
"At install time, the <filename>.po</filename> files are converted to a binary format (with the extension <filename>.mo</filename>) and placed "
"in a system-wide directory for locale files, for example <filename>/usr/share/locale/</filename>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6758(para)
msgid ""
"When the application runs, the <application>gettext</application> library checks the system-wide directory to see if there is a <filename>.mo</"
"filename> file for the user's locale environment (you can set the locale with, for instance, \"export LANG=de_DE.UTF-8\" from a bash console). "
"Later, when the program reaches a <literal>gettext</literal> call, it looks for a translation of a particular string. If none is found, the "
"original string is used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6770(title)
msgid "Testing and adding translations"
msgstr "Testen und Hinzufügen von Übersetzungen"

#: C/gtkmm-tutorial-in.xml:6777(programlisting)
#, no-wrap
msgid "intltool-update --pot"
msgstr "intltool-update --pot"

#: C/gtkmm-tutorial-in.xml:6772(para)
msgid ""
"To convince yourself that you've done well, you may wish to add a translation for a new locale. In order to do that, go to the <filename>po</"
"filename> subdirectory of your project and execute the following command: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6780(para)
msgid ""
"That will create a file named <filename>programname.pot</filename>. Now copy that file to <filename>languagecode.po</filename>, such as "
"<filename>de.po</filename> or <filename>hu.po</filename>. Also add that language code to <literal>LINGUAS</literal>. The <filename>.po</"
"filename> file contains a header and a list of English strings, with space for the translated strings to be entered. Make sure you set the "
"encoding of the <filename>.po</filename> file (specified in the header, but also as content) to <literal>UTF-8</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6793(para)
msgid ""
"It's possible that certain strings will be marked as <literal>fuzzy</literal> in the <filename>.po</filename> file. These translations will not "
"substitute the original string. To make them appear, simply remove the <literal>fuzzy</literal> tag."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6803(title)
msgid "Resources"
msgstr "Ressourcen"

#: C/gtkmm-tutorial-in.xml:6812(ulink)
msgid "L10N Guidelines for Developers"
msgstr "L10N-Richtlinien für Entwickler"

#: C/gtkmm-tutorial-in.xml:6819(ulink)
msgid "Intltool README"
msgstr "Intltool-README"

#: C/gtkmm-tutorial-in.xml:6825(ulink)
msgid "How to use Git for GNOME translators"
msgstr "Nutzung des GNOME-Git als Übersetzer"

#: C/gtkmm-tutorial-in.xml:6831(ulink)
msgid "gettext manual"
msgstr "Gettext-Handbuch"

#: C/gtkmm-tutorial-in.xml:6837(literal)
msgid "gtkmm_hello"
msgstr "gtkmm_hello"

#: C/gtkmm-tutorial-in.xml:6837(ulink) C/gtkmm-tutorial-in.xml:6843(ulink)
msgid "<placeholder-1/> example package"
msgstr "<placeholder-1/>-Beispielpaket"

#: C/gtkmm-tutorial-in.xml:6843(literal)
msgid "gnomemm_hello"
msgstr "gnomemm_hello"

#: C/gtkmm-tutorial-in.xml:6805(para)
msgid ""
"More information about what lies behind the internationalization and localization process is presented and demonstrated in: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6853(title)
msgid "Expecting UTF8"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6854(para)
msgid ""
"A properly internationalized application will not make assumptions about the number of bytes in a character. That means that you shouldn't use "
"pointer arithmetic to step through the characters in a string, and it means you shouldn't use <classname>std::string</classname> or standard C "
"functions such as <function>strlen()</function> because they make the same assumption."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6861(para)
msgid ""
"However, you probably already avoid bare char* arrays and pointer arithmetic by using <classname>std::string</classname>, so you just need to "
"start using <classname>Glib::ustring</classname> instead. See the <link linkend=\"sec-basics-ustring\">Basics</link> chapter about "
"<classname>Glib::ustring</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6869(title)
msgid "Glib::ustring and std::iostreams"
msgstr "Glib::ustring und std::iostreams"

#: C/gtkmm-tutorial-in.xml:6886(programlisting)
#, no-wrap
msgid ""
"std::ostringstream output;\n"
"output.imbue(std::locale(\"\")); // use the user's locale for this stream\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"
msgstr ""
"std::ostringstream output;\n"
"output.imbue(std::locale(\"\")); // use the user's locale for this stream\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"

#. <para>TODO: This section is not clear - it needs to spell things out more clearly and obviously.</para>
#: C/gtkmm-tutorial-in.xml:6871(para)
msgid ""
"Unfortunately, the integration with the standard iostreams is not completely foolproof. <application>gtkmm</application> converts "
"<classname>Glib::ustring</classname>s to a locale-specific encoding (which usually is not UTF-8) if you output them to an <classname>ostream</"
"classname> with <function>operator&lt;&lt;</function>. Likewise, retrieving <classname>Glib::ustrings</classname> from <classname>istream</"
"classname> with <function>operator&gt;&gt;</function> causes a conversion in the opposite direction. But this scheme breaks down if you go "
"through a <classname>std::string</classname>, e.g. by inputting text from a stream to a <classname>std::string</classname> and then implicitly "
"converting it to a <classname>Glib::ustring</classname>. If the string contained non-ASCII characters and the current locale is not UTF-8 "
"encoded, the result is a corrupted <classname>Glib::ustring</classname>. You can work around this with a manual conversion. For instance, to "
"retrieve the <classname>std::string</classname> from a <classname>ostringstream</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6896(title)
msgid "Pitfalls"
msgstr "Fallstricke"

#: C/gtkmm-tutorial-in.xml:6898(para)
msgid "There are a few common mistakes that you would discover eventually yourself. But this section might help you to avoid them."
msgstr ""
"Es gibt einige typische Fehler, denen Sie möglicherweise auch selbst begegnen werden. Dieser Abschnitt könnte Ihnen dabei helfen, dies zu "
"vermeiden."

#: C/gtkmm-tutorial-in.xml:6901(title)
msgid "Same strings, different semantics"
msgstr "Gleiche Zeichenketten, unterschiedliche Semantik"

#: C/gtkmm-tutorial-in.xml:6903(para)
msgid ""
"Sometimes two english strings are identical but have different meanings in different contexts, so they would probably not be identical when "
"translated. Since the English strings are used as look-up keys, this causes problems."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6907(para)
msgid ""
"In these cases, you should add extra characters to the strings. For instance, use <literal>\"jumps[noun]\"</literal> and <literal>"
"\"jumps[verb]\"</literal> instead of just <literal>\"jumps\"</literal> and strip them again outside the <function>gettext</function> call. If "
"you add extra characters you should also add a comment for the translators before the <function>gettext</function> call. Such comments will be "
"shown in the <filename>.po</filename> files. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6917(programlisting)
#, no-wrap
msgid ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"
msgstr ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"

#: C/gtkmm-tutorial-in.xml:6923(title)
msgid "Composition of strings"
msgstr "Zusammenstellung der Zeichenketten"

#: C/gtkmm-tutorial-in.xml:6925(para)
msgid ""
"C programmers use <function>sprintf()</function> to compose and concatenate strings. C++ favours streams, but unfortunately, this approach "
"makes translation difficult, because each fragment of text is translated separately, without allowing the translators to rearrange them "
"according to the grammar of the language."
msgstr ""
"C-Programmierer nutzen die Funktion <function>sprintf()</function> zum Erstellen und Verketten von Strings. C++ favorisiert Streams, aber "
"leider erschwert dieser Ansatz die Übersetzungen, da jedes Textfragment separat übersetzt wird und Übersetzer keine Möglichkeiten haben, die "
"Fragmente neu anzuordnen, um der Grammatik ihrer Sprache gerecht zu werden."

#: C/gtkmm-tutorial-in.xml:6932(para)
msgid "For instance, this code would be problematic:"
msgstr "Folgendes könnte beispielsweise problematisch sein:"

#: C/gtkmm-tutorial-in.xml:6934(programlisting)
#, no-wrap
msgid ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"
msgstr ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"

#: C/gtkmm-tutorial-in.xml:6943(programlisting)
#, no-wrap
#| msgid ""
#| "std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
#| "          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
#| "\n"
#| "label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"
msgid ""
"std::cout &lt;&lt; Glib::ustring::compose(\n"
"             _(\"Current amount: %1 Future: %2\"), amount, future) &lt;&lt; std::endl;\n"
"\n"
"label.set_text(Glib::ustring::compose(_(\"Really delete %1 now?\"), filename));"
msgstr ""
"std::cout &lt;&lt; Glib::ustring::compose(\n"
"             _(\"Current amount: %1 Future: %2\"), amount, future) &lt;&lt; std::endl;\n"
"\n"
"label.set_text(Glib::ustring::compose(_(\"Really delete %1 now?\"), filename));"

#: C/gtkmm-tutorial-in.xml:6939(para)
msgid ""
"So you should either avoid this situation or use <ulink url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html"
"\"><function>Glib::ustring::compose()</function></ulink> which supports syntax such as: <placeholder-1/>"
msgstr ""
"Daher sollten Sie diese Situation entweder gänzlich vermeiden oder <ulink url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring."
"html\"><function>Glib::ustring::compose()</function></ulink> verwenden, das folgend Syntax unterstützt: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6951(title)
msgid "Assuming the displayed size of strings"
msgstr "Einschätzen der Anzeigegröße von Zeichenketten"

#: C/gtkmm-tutorial-in.xml:6953(para)
msgid ""
"You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English "
"string. Luckily, most <application>gtkmm</application> widgets will expand at runtime to the required size."
msgstr ""
"Sie wissen nie, wie viel Platz ein String auf dem Bildschirm einnimmt, wenn er erst einmal übersetzt ist. Es kann durchaus die doppelte Größe "
"der englischen Originalversion sein. Glücklicherweise expandiert <application>gtkmm</application> die Widgets zur Laufzeit auf die "
"erforderliche Größe."

#: C/gtkmm-tutorial-in.xml:6957(title)
msgid "Unusual words"
msgstr "Unübliche Wörter"

#: C/gtkmm-tutorial-in.xml:6959(para)
msgid ""
"You should avoid cryptic abbreviations, slang, or jargon. They are usually difficult to translate, and are often difficult for even native "
"speakers to understand. For instance, prefer \"application\" to \"app\""
msgstr ""
"Sie sollten kryptische Abkürzungen, Slang oder Jargon vermeiden. So etwas ist recht schwierig zu übersetzen und oft selbst für Muttersprachler "
"nur schwer verständlich. Beispielsweise sollten Sie »application« gegenüber »app« bevorzugen."

#: C/gtkmm-tutorial-in.xml:6965(title)
msgid "Using non-ASCII characters in strings"
msgstr "Verwendubg von Nicht-ASCII-Zeichen in Zeichenketten"

#: C/gtkmm-tutorial-in.xml:6967(para)
msgid ""
"Currently, <application>gettext</application> does not support non-ASCII characters (i.e. any characters with a code above 127) in source code. "
"For instance, you cannot use the copyright sign (©)."
msgstr ""
"Gegenwärtig unterstützt <application>gettext</application> keine Nicht-ASCII-Zeichen im Quellcode (also Zeichen mit einem Code über 127). Zum "
"Beispiel können Sie kein Copyright-Zeichen verwenden (©)."

#: C/gtkmm-tutorial-in.xml:6973(para)
msgid ""
"To work around this, you could write a comment in the source code just before the string, telling the translators to use the special character "
"if it is available in their languages. For english, you could then make an American English <filename>en_US.po</filename> translation which "
"used that special character."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6981(title)
msgid "Getting help with translations"
msgstr "Hilfe zu Übersetzungen erhalten"

#: C/gtkmm-tutorial-in.xml:6983(para)
msgid ""
"If your program is free software, there is a whole <literal>GNOME</literal> subproject devoted to helping you make translations, the <ulink url="
"\"https://wiki.gnome.org/TranslationProject/\"><literal>GNOME</literal> Translation Project</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6988(para)
msgid ""
"The way it works is that you upload your source code to a git repository where translators can access it, then contact the gnome-i18n mailing "
"list and ask to have your program added to the <ulink url=\"http://l10n.gnome.org/module/\">list of modules to translate</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6993(para)
msgid ""
"Then you make sure you update the file <filename>POTFILES.in</filename> in the <filename>po/</filename> subdirectory (<command>intltool-update -"
"M</command> can help with this) so that the translators always access updated <filename>myprogram.pot</filename> files, and simply freeze the "
"strings at least a couple of days before you make a new release, announcing it on gnome-i18n. Depending on the number of strings your program "
"contains and how popular it is, the translations will then start to tick in as <filename>languagename.po</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7005(para)
msgid ""
"Note that most language teams only consist of 1-3 persons, so if your program contains a lot of strings, it might last a while before anyone "
"has the time to look at it. Also, most translators do not want to waste their time (translating is a very time-consuming task) so if they do "
"not assess your project as being really serious (in the sense that it is polished and being maintained) they may decide to spend their time on "
"some other project."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7017(title) C/gtkmm-tutorial-in.xml:7135(title)
msgid "Custom Widgets"
msgstr "Benutzerdefinierte Widgets"

#: C/gtkmm-tutorial-in.xml:7019(para)
msgid ""
"<application>gtkmm</application> makes it very easy to derive new widgets by inheriting from an existing widget class, either by deriving from "
"a container and adding child widgets, or by deriving from a single-item widget, and changing its behaviour. But you might occasionally find "
"that no suitable starting point already exists. In this case, you can implement a widget from scratch."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7026(title)
msgid "Custom Containers"
msgstr "Benutzerdefinierte Container"

#: C/gtkmm-tutorial-in.xml:7029(para)
msgid "<methodname>get_request_mode_vfunc()</methodname>: Return what <literal>Gtk::SizeRequestMode</literal> is preferred by the container."
msgstr "<methodname>get_request_mode_vfunc()</methodname>: Gibt den vom Container bevorzugten <literal>Gtk::SizeRequestMode</literal> zurück."

#: C/gtkmm-tutorial-in.xml:7030(para)
msgid "<methodname>get_preferred_width_vfunc()</methodname>: Calculate the minimum and natural width of the container."
msgstr "<methodname>get_preferred_width_vfunc()</methodname>: Berechnet die minimale und natürliche Breite des Containers."

#: C/gtkmm-tutorial-in.xml:7031(para)
msgid "<methodname>get_preferred_height_vfunc()</methodname>: Calculate the minimum and natural height of the container."
msgstr "<methodname>get_preferred_heigth_vfunc()</methodname>: Berechnet die minimale und natürliche Höhe des Containers."

#: C/gtkmm-tutorial-in.xml:7032(para)
msgid ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Calculate the minimum and natural width of the container, if it would be given "
"the specified height."
msgstr ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Berechnet die minimale und natürliche Breite des Containers, falls die Höhe "
"angegeben wurde."

#: C/gtkmm-tutorial-in.xml:7033(para)
msgid ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Calculate the minimum and natural height of the container, if it would be "
"given the specified width."
msgstr ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Berechnet die minimale und natürliche Höhe des Containers, falls die Breite "
"angegeben wurde."

#: C/gtkmm-tutorial-in.xml:7034(para)
msgid ""
"<methodname>on_size_allocate()</methodname>: Position the child widgets, given the height and width that the container has actually been given."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7035(para)
msgid "<methodname>forall_vfunc()</methodname>: Call the same callback for each of the children."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7036(para)
msgid "<methodname>on_add()</methodname>: Add a child widget to the container."
msgstr "<methodname>on_add()</methodname>: Ein Kind-Widget zum Container hinzufügen."

#: C/gtkmm-tutorial-in.xml:7037(para)
msgid "<methodname>on_remove()</methodname>: Remove a child widget from the container."
msgstr "<methodname>on_remove()</methodname>: Ein Kind-Widget aus dem Container entfernen."

#: C/gtkmm-tutorial-in.xml:7038(para)
msgid "<methodname>child_type_vfunc()</methodname>: Return what type of child can be added."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7027(para)
msgid "When deriving from <classname>Gtk::Container</classname>, you should override the following virtual methods: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7042(para)
msgid ""
"The <methodname>get_request_mode_vfunc()</methodname>, <methodname>get_preferred_width_vfunc()</methodname>, "
"<methodname>get_preferred_height_vfunc()</methodname>, <methodname>get_preferred_width_for_height_vfunc()</methodname>, "
"<methodname>get_preferred_height_for_width_vfunc()</methodname>, and <methodname>on_size_allocate()</methodname> virtual methods control the "
"layout of the child widgets. For instance, if your container has 2 child widgets, with one below the other, your "
"<methodname>get_request_mode_vfunc()</methodname> might request height-for-width layout. Then your <methodname>get_preferred_width_vfunc()</"
"methodname> might report the maximum of the widths of the child widgets, and <methodname>get_preferred_height_for_width_vfunc()</methodname> "
"might report the sum of their heights. If you want padding between the child widgets then you would add that to the width and height too. Your "
"widget's container will use this result to ensure that your widget gets enough space, and not less. By examining each widget's parent, and its "
"parent, this logic will eventually decide the size of the top-level window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7062(para)
msgid ""
"You are not guaranteed to get the <literal>Gtk::SizeRequestMode</literal> that you request. Therefore all four of the "
"<methodname>get_preferred_xxx_vfunc()</methodname> methods must return sensible values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7067(para)
msgid ""
"<methodname>on_size_allocate()</methodname> receives the actual height and width that the parent container has decided to give to your widget. "
"This might be more than the minimum, or even more than the natural size, for instance if the top-level window has been expanded. You might "
"choose to ignore the extra space and leave a blank area, or you might choose to expand your child widgets to fill the space, or you might "
"choose to expand the padding between your widgets. It's your container, so you decide. Don't forget to call <methodname>set_allocation()</"
"methodname> inside your <methodname>on_size_allocate()</methodname> implementation to actually use the allocated space that has been offered by "
"the parent container."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7079(para)
msgid ""
"Unless your container is a top-level window that derives from <classname>Gtk::Window</classname>, you should probably also call "
"<methodname>Gtk::Widget::set_has_window(false)</methodname> in your constructor. This means that your container does not create its own "
"<classname>Gdk::Window</classname>, but uses its parent's window. (Note the difference between <classname>Gtk::Window</classname> and "
"<classname>Gdk::Window</classname>.) If your container does need its own <classname>Gdk::Window</classname>, and does not derive from "
"<classname>Gtk::Window</classname>, you must also override the <methodname>on_realize()</methodname> method as described in the <link linkend="
"\"sec-custom-widgets\">Custom Widgets</link> section. And unless your container draws directly onto the underlying <classname>Gdk::Window</"
"classname>, you should probably call <methodname>set_redraw_on_allocate(false)</methodname> to improve performance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7095(para)
msgid ""
"By overriding <methodname>forall_vfunc()</methodname> you can allow applications to operate on all of the container's child widgets. For "
"instance, <methodname>show_all_children()</methodname> uses this to find all the child widgets and show them."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7100(para)
msgid ""
"Although your container might have its own method to set the child widgets, you should still provide an implementation for the virtual "
"<methodname>on_add()</methodname> and <methodname>on_remove()</methodname> methods from the base class, so that the add() and remove() methods "
"will do something appropriate if they are called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7106(para)
msgid ""
"Your implementation of the <methodname>child_type_vfunc()</methodname> method should report the type of widget that may be added to your "
"container, if it is not yet full. This is usually <methodname>Gtk::Widget::get_type()</methodname> to indicate that the container may contain "
"any class derived from <classname>Gtk::Widget</classname>. If the container may not contain any more widgets, then this method should return "
"<literal>G_TYPE_NONE</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7118(para)
msgid ""
"This example implements a container with two child widgets, one above the other. Of course, in this case it would be far simpler just to use a "
"vertical <classname>Gtk::Box</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7123(title)
msgid "Custom Container"
msgstr "Benutzerdefinierter Container"

#: C/gtkmm-tutorial-in.xml:7136(para)
msgid ""
"By deriving directly from <classname>Gtk::Widget</classname> you can do all the drawing for your widget directly, instead of just arranging "
"child widgets. For instance, a <classname>Gtk::Label</classname> draws the text of the label, but does not do this by using other widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7147(para)
msgid ""
"<methodname>get_request_mode_vfunc()</methodname>: (optional) Return what <literal>Gtk::SizeRequestMode</literal> is preferred by the widget."
msgstr ""
"<methodname>get_request_mode_vfunc()</methodname>: (optional) Gibt den vom Widget bevorzugten <literal>Gtk::SizeRequestMode</literal> zurück."

#: C/gtkmm-tutorial-in.xml:7148(para)
msgid "<methodname>get_preferred_width_vfunc()</methodname>: Calculate the minimum and natural width of the widget."
msgstr "<methodname>get_preferred_width_vfunc()</methodname>: Berechnet die minimale und natürliche Breite des Widgets."

#: C/gtkmm-tutorial-in.xml:7149(para)
msgid "<methodname>get_preferred_height_vfunc()</methodname>: Calculate the minimum and natural height of the widget."
msgstr "<methodname>get_preferred_height_vfunc()</methodname>: Berechnet die minimale und natürliche Höhe des Widgets."

#: C/gtkmm-tutorial-in.xml:7150(para)
msgid ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Calculate the minimum and natural width of the widget, if it would be given "
"the specified height."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7151(para)
msgid ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Calculate the minimum and natural height of the widget, if it would be given "
"the specified width."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7152(para)
msgid "<methodname>on_size_allocate()</methodname>: Position the widget, given the height and width that it has actually been given."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7153(para)
msgid "<methodname>on_realize()</methodname>: Associate a <classname>Gdk::Window</classname> with the widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7154(para)
msgid "<methodname>on_unrealize()</methodname>: (optional) Break the association with the <classname>Gdk::Window</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7155(para)
msgid "<methodname>on_map()</methodname>: (optional)"
msgstr "<methodname>on_map()</methodname>: (optional)"

#: C/gtkmm-tutorial-in.xml:7156(para)
msgid "<methodname>on_unmap()</methodname>: (optional)"
msgstr "<methodname>on_unmap()</methodname>: (optional)"

#: C/gtkmm-tutorial-in.xml:7157(para)
msgid "<methodname>on_draw()</methodname>: Draw on the supplied <classname>Cairo::Context</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7142(para)
msgid ""
"When deriving from <classname>Gtk::Widget</classname>, you should override the following virtual methods. The methods marked (optional) need "
"not be overridden in all custom widgets. The base class's methods may be appropriate. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7161(para)
msgid ""
"The first 6 methods in the previous table are also overridden in custom containers. They are briefly described in the <link linkend=\"sec-"
"custom-containers\">Custom Containers</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7166(para)
msgid ""
"Most custom widgets need their own <classname>Gdk::Window</classname> to draw on. Then you can call <methodname>Gtk::Widget::"
"set_has_window(true)</methodname> in your constructor. (This is the default value.) If you do not call <methodname>set_has_window(false)</"
"methodname>, you must override <methodname>on_realize()</methodname> and call <methodname>Gtk::Widget::set_realized()</methodname> and "
"<methodname>Gtk::Widget::set_window()</methodname> from there."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7177(para)
msgid "This example implements a widget which draws a Penrose triangle."
msgstr "Dieses Beispiel implementiert ein Widget, das ein Penrose-Dreieck zeichnet."

#: C/gtkmm-tutorial-in.xml:7180(title)
msgid "Custom Widget"
msgstr "Benutzerdefiniertes Widget"

#: C/gtkmm-tutorial-in.xml:7196(title)
msgid "Multi-threaded programs"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7199(title)
msgid "The constraints"
msgstr "Die Einschränkungen"

#: C/gtkmm-tutorial-in.xml:7201(para)
msgid ""
"<application>glibmm</application> provides the normal set of thread launching functions, mutexes, condition variables and scoped locking "
"classes required for writing multi-threaded programs using C++."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7216(para)
msgid ""
"These interactions arise from the fact that, amongst other things, a class inheriting from <classname>sigc::trackable</classname> will, via "
"that inheritance, have a <classname>std::list</classname> object keeping track of slots created by calls to <function>sigc::mem_fun()</"
"function> representing any of its non-static methods (more particularly it keeps a list of callbacks which will null the connected slots on its "
"destruction). Each <classname>sigc::slot</classname> object also keeps, via <classname>sigc::slot_rep</classname>, its own <classname>sigc::"
"trackable</classname> object to track any <classname>sigc::connection</classname> objects which it needs to inform about its demise, and also "
"has a function to deregister itself from any <classname>sigc::trackable</classname> on disconnection or destruction. <classname>sigc::signal</"
"classname> objects also keep lists of slots, which will be updated by a call to their <methodname>connect()</methodname> method or calls to any "
"<classname>sigc::connection</classname> object relating to such a connection."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7207(para)
msgid ""
"However, care is required when writing programs based on <application>gtkmm</application> using multiple threads of execution, arising from the "
"fact that <application>libsigc++</application>, and in particular <classname>sigc::trackable</classname>, are not thread-safe. That's because "
"none of the complex interactions that occur behind the scenes when using <application>libsigc++</application> are protected by a mutex or other "
"means of synchronization. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7240(title)
msgid "The rules"
msgstr "Die Regeln"

#: C/gtkmm-tutorial-in.xml:7242(para)
msgid ""
"This requires a number of rules to be observed when writing multi-threaded programs using <application>gtkmm</application>. These are set out "
"below, but one point to note is that extra care is required when deriving classes from <classname>sigc::trackable</classname>, because the "
"effects are unintuitive (see particularly points 4 and 5 below)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7253(para)
msgid ""
"Use <classname>Glib::Dispatcher</classname> to invoke <application>gtkmm</application> functions from worker threads (this is dealt with in "
"more detail in the next section)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7261(para)
msgid ""
"A <classname>sigc::signal</classname> object should be regarded as owned by the thread which created it. Only that thread should connect a "
"<classname>sigc::slot</classname> object to the signal object, and only that thread should <methodname>emit()</methodname> or call "
"<methodname>operator()()</methodname> on the signal, or null any connected <classname>sigc::slot</classname> object. It follows (amongst other "
"things) that any signal object provided by a <application>gtkmm</application> widget should only be operated on in the main GUI thread and any "
"object deriving from <classname>sigc::trackable</classname> having its non-static methods referenced by slots connected to the signal object "
"should only be destroyed in that thread."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7277(para)
msgid ""
"Any <classname>sigc::connection</classname> object should be regarded as owned by the thread in which the method returning the <classname>sigc::"
"connection</classname> object was called. Only that thread should call <classname>sigc::connection</classname> methods on the object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7287(para)
msgid ""
"A <classname>sigc::slot</classname> object created by a call to <function>sigc::mem_fun()</function> which references a method of a class "
"deriving from <classname>sigc::trackable</classname> should never be copied to another thread, nor destroyed by a different thread than the one "
"which created it. (One consequence of this is that <methodname>Glib::Threads::Thread::create()</methodname> should not be called with a slot "
"argument created by a call to <function>sigc::mem_fun()</function> which represents a method of such a class. It is however safe to pass "
"<methodname>Glib::Threads::Thread::create()</methodname> a function object representing such a method by using, say, <function>boost::bind()</"
"function> or, in C++11, <function>std::bind()</function> or a C++11 lambda expression.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7305(para)
msgid ""
"If a particular class object derives from <classname>sigc::trackable</classname>, only one thread should create <classname>sigc::slot</"
"classname> objects representing any of the class's non-static methods by calling <function>sigc::mem_fun()</function>. The first thread to "
"create such a slot should be regarded as owning the relevant object for the purpose of creating further slots referencing <emphasis>any</"
"emphasis> of its non-static methods using that function, or nulling those slots by disconnecting them or destroying the trackable object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7319(para)
msgid ""
"Although <application>glib</application> is itself thread-safe, any <application>glibmm</application> wrappers which use <application>libsigc+"
"+</application> will not be. So for example, only the thread in which a main loop runs should call <methodname>Glib::SignalIdle::connect()</"
"methodname>, <methodname>Glib::SignalIO::connect()</methodname>, <methodname>Glib::SignalTimeout::connect()</methodname>, <methodname>Glib::"
"SignalTimeout::connect_seconds</methodname> for that main loop, or manipulate any <classname>sigc::connection</classname> object returned by "
"them."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7331(para)
msgid ""
"The connect*_once() variants, <methodname>Glib::SignalIdle::connect_once()</methodname>, <methodname>Glib::SignalTimeout::connect_once()</"
"methodname>, <methodname>Glib::SignalTimeout::connect_seconds_once()</methodname>, are thread-safe for any case where the slot is not created "
"by a call to <function>sigc::mem_fun()</function> which represents a method of a class deriving from <classname>sigc::trackable</classname>. "
"This is similar to <methodname>Glib::Threads::Thread::create()</methodname> as mentioned in point 4."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7350(title)
msgid "Using Glib::Dispatcher"
msgstr "Verwendung von Glib::Dispatcher"

#: C/gtkmm-tutorial-in.xml:7352(para)
msgid ""
"The slots connected to <classname>sigc::signal</classname> objects execute in the thread which calls <methodname>emit()</methodname> or "
"<methodname>operator()()</methodname> on the signal. <classname>Glib::Dispatcher</classname> does not behave this way: instead its connected "
"slots execute in the thread in which the <classname>Glib::Dispatcher</classname> object was constructed (which must have a glib main loop). If "
"a <classname>Glib::Dispatcher</classname> object is constructed in the main GUI thread (which will therefore be the receiver thread), any "
"worker thread can emit on it and have the connected slots safely execute <application>gtkmm</application> functions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7366(para)
msgid ""
"Some thread safety rules on the use of <classname>Glib::Dispatcher</classname> still apply. As mentioned, a <classname>Glib::Dispatcher</"
"classname> object must be constructed in the receiver thread (the thread in whose main loop it will execute its connected slots). By default "
"this is the main program thread, although there is a <classname>Glib::Dispatcher</classname> constructor which can take the <classname>Glib::"
"MainContext</classname> object of any thread which has a main loop. Only the receiver thread should call <methodname>connect()</methodname> on "
"the <classname>Glib::Dispatcher</classname> object, or manipulate any related <classname>sigc::connection</classname> object, unless additional "
"synchronization is employed. However, any worker thread can safely emit on the <classname>Glib::Dispatcher</classname> object without any "
"locking once the receiver thread has connected the slots, provided that it is constructed before the worker thread is started (if it is "
"constructed after the thread has started, additional synchronization will normally be required to ensure visibility)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7386(para)
msgid ""
"Aside from the fact that connected slots always execute in the receiver thread, <classname>Glib::Dispatcher</classname> objects are similar to "
"<classname>sigc::signal&lt;void&gt;</classname> objects. They therefore cannot pass unbound arguments nor return a value. The best way to pass "
"unbound arguments is with a thread-safe (asynchronous) queue. At the time of writing <application>glibmm</application> does not have one, "
"although most people writing multi-threaded code will have one available to them (they are relatively easy to write although there are "
"subtleties in combining thread safety with strong exception safety)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7399(para)
msgid ""
"A <classname>Glib::Dispatcher</classname> object can be emitted on by the receiver thread as well as by a worker thread, although this should "
"be done within reasonable bounds. On unix-like systems <classname>Glib::Dispatcher</classname> objects share a single common pipe, which could "
"in theory at least fill up on a very heavily loaded system running a program with a very large number of <classname>Dispatcher</classname> "
"objects in use. Were the pipe to fill up before the receiver thread's main loop has had an opportunity to read from it to empty it, and the "
"receiver thread attempt to emit and so write to it when it is in that condition, the receiver thread would block on the write, so deadlocking. "
"Where the receiver thread is to emit, a normal <classname>sigc::signal&lt;void&gt;</classname> object could of course be used instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7419(para)
msgid ""
"This is an example program with two threads, one GUI thread, like in all <application>gtkmm</application> programs, and one worker thread. The "
"worker thread is created when you press the <literal>Start work</literal> button. It is deleted when the work is finished, when you press the "
"<literal>Stop work</literal> button, or when you press the <literal>Quit</literal> button."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7427(para)
msgid ""
"A <classname>Glib::Dispatcher</classname> is used for sending notifications from the worker thread to the GUI thread. The "
"<classname>ExampleWorker</classname> class contains data which is accessed by both threads. This data is protected by a <classname>Glib::"
"Threads::Mutex</classname>. Only the GUI thread updates the GUI."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7436(title)
msgid "Multi-Threaded Program"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7449(title)
msgid "Recommended Techniques"
msgstr "Empfohlene Techniken"

#: C/gtkmm-tutorial-in.xml:7451(para)
msgid ""
"This section is simply a gathering of wisdom, general style guidelines and hints for creating <application>gtkmm</application> applications."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7455(para)
msgid ""
"Use GNU <application>autoconf</application> and <application>automake</application>! They are your friends :) <application>Automake</"
"application> examines C files, determines how they depend on each other, and generates a <filename>Makefile</filename> so the files can be "
"compiled in the correct order. <application>Autoconf</application> permits automatic configuration of software installation, handling a large "
"number of system quirks to increase portability."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7465(para)
msgid ""
"Subclass Widgets to better organize your code. You should probably subclass your main <classname>Window</classname> at least. Then you can make "
"your child Widgets and signal handlers members of that class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7470(para)
msgid ""
"Create your own signals instead of passing pointers around. Objects can communicate with each other via signals and signal handlers. This is "
"much simpler than objects holding pointers to each other and calling each other's methods. <application>gtkmm</application>'s classes uses "
"special versions of <classname>sigc::signal</classname>, but you should use normal <classname>sigc::signal</classname>s, as described in the "
"<application>libsigc++</application> documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7479(title)
msgid "Application Lifetime"
msgstr "Lebensdauer einer Anwendung"

#: C/gtkmm-tutorial-in.xml:7480(para)
msgid ""
"Most applications will have only one <classname>Window</classname>, or only one main window. These applications can use the <methodname>Gtk::"
"Application::run(Gtk::Window&amp;)</methodname> overload. It shows the window and returns when the window has been hidden. This might happen "
"when the user closes the window, or when your code decides to <methodname>hide()</methodname> the window. You can prevent the user from closing "
"the window (for instance, if there are unsaved changes) by overriding <methodname>Gtk::Window::on_delete_event()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7488(para)
msgid "Most of our examples use this technique."
msgstr "Die meisten unserer Beispiele verwenden diese Technik."

#: C/gtkmm-tutorial-in.xml:7492(title)
msgid "Using a <application>gtkmm</application> widget"
msgstr "Verwendung eines <application>gtkmm</application>-Widgets"

#: C/gtkmm-tutorial-in.xml:7494(para)
msgid "Our examples all tend to have the same structure. They follow these steps for using a <classname>Widget</classname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7503(para)
msgid ""
"Declare a variable of the type of <classname>Widget</classname> you wish to use, generally as member variable of a derived container class. You "
"could also declare a pointer to the widget type, and then create it with <literal>new</literal> in your code. Even when using the widget via a "
"pointer, it's still probably best to make that pointer a member variable of a container class so that you can access it later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7514(para)
msgid ""
"Set the attributes of the widget. If the widget has no default constructor, then you will need to initialize the widget in the initalizer list "
"of your container class's constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7520(para)
msgid "Connect any signals you wish to use to the appropriate handlers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7526(para)
msgid ""
"Pack the widget into a container using the appropriate call, e.g. <methodname>Gtk::Container::add()</methodname> or <methodname>pack_start()</"
"methodname>."
msgstr ""
"Packen Sie das Widget mit dem entsprechenden Aufruf in einen Container, zum Beispiel <methodname>Gtk::Container::add()</methodname> oder "
"<methodname>pack_start()</methodname>."

#: C/gtkmm-tutorial-in.xml:7534(para)
msgid "Call <methodname>show()</methodname> to display the widget."
msgstr "Rufen Sie <methodname>show()</methodname> auf, um das Widget anzuzeigen."

#: C/gtkmm-tutorial-in.xml:7543(para)
msgid ""
"<methodname>Gtk::Widget::show()</methodname> lets <application>gtkmm</application> know that we have finished setting the attributes of the "
"widget, and that it is ready to be displayed. You can use <methodname>Gtk::Widget::hide()</methodname> to make it disappear again. The order in "
"which you show the widgets is not important, but we do suggest that you show the top-level window last; this way, the whole window will appear "
"with its contents already drawn. Otherwise, the user will first see a blank window, into which the widgets will be gradually drawn."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7557(title)
msgid "Contributing"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7559(para)
msgid ""
"This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any "
"aspect of <application>gtkmm</application> that does not already have documentation, please consider contributing to this document."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7565(para)
msgid ""
"Ideally, we would like you to <ulink url=\"http://www.gtkmm.org/bugs.shtml\">provide a patch</ulink> to the <filename>docs/tutorial/C/gtkmm-"
"tutorial-in.xml</filename> file. This file is currently in the <literal>gtkmm-documentation</literal> module in GNOME git."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7571(para)
msgid ""
"If you do decide to contribute, please post your contribution to the <application>gtkmm</application> mailing list at <ulink url=\"mailto:gtkmm-"
"list@gnome.org\">&lt;gtkmm-list@gnome.org&gt;</ulink>. Also, be aware that the entirety of this document is free, and any addition you provide "
"must also be free. That is, people must be able to use any portion of your examples in their programs, and copies of this document (including "
"your contribution) may be distributed freely."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7583(title)
msgid "The RefPtr smartpointer"
msgstr "Der RefPtr-Smartpointer"

#: C/gtkmm-tutorial-in.xml:7584(para)
msgid ""
"<classname>Glib::RefPtr</classname> is a smartpointer. Specifically, it is a reference-counting smartpointer. You might be familiar with "
"<classname>std::auto_ptr&lt;&gt;</classname>, <classname>std::unique_ptr&lt;&gt;</classname> and <classname>std::shared_ptr&lt;&gt;</"
"classname>, which are also smartpointers. <classname>Glib::RefPtr&lt;&gt;</classname> is similar to <classname>std::shared_ptr&lt;&gt;</"
"classname>, which is also reference-counting. <classname>Glib::RefPtr&lt;&gt;</classname> was introduced long before there was a reference-"
"counting smartpointer in the C++ Standard Library."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7596(para)
msgid "A smartpointer acts much like a normal pointer. Here are a few examples."
msgstr "Ein Smartpointer agiert wie ein normaler Zeiger. Hier sind einige Beispiele."

#: C/gtkmm-tutorial-in.xml:7599(title)
msgid "Copying"
msgstr "Kopieren"

#: C/gtkmm-tutorial-in.xml:7600(para)
msgid ""
"You can copy <classname>RefPtr</classname>s, just like normal pointers. But unlike normal pointers, you don't need to worry about deleting the "
"underlying instance."
msgstr ""
"Sie können <classname>RefPtr</classname>s ganz einfach wie normale Zeiger kopieren. Aber im Gegensatz zu normalen Zeigern müssen Sie sich keine "
"Gedanken um die darunterliegenden Instanzen machen."

#: C/gtkmm-tutorial-in.xml:7606(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf2 = refPixbuf;\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf2 = refPixbuf;\n"

#: C/gtkmm-tutorial-in.xml:7611(para)
msgid ""
"Of course this means that you can store <classname>RefPtr</classname>s in standard containers, such as <classname>std::vector</classname> or "
"<classname>std::list</classname>."
msgstr ""
"Das bedeutet natürlich, dass Sie <classname>RefPtr</classname>s in Standardcontainern speichern können, wie <classname>std::vector</classname> "
"oder <classname>std::list</classname>."

#: C/gtkmm-tutorial-in.xml:7616(programlisting)
#, no-wrap
msgid ""
"\n"
"std::list&lt; Glib::RefPtr&lt;Gdk::Pixbuf&gt; &gt; listPixbufs;\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"listPixbufs.push_back(refPixbuf);\n"
msgstr ""
"\n"
"std::list&lt; Glib::RefPtr&lt;Gdk::Pixbuf&gt; &gt; listPixbufs;\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"listPixbufs.push_back(refPixbuf);\n"

#: C/gtkmm-tutorial-in.xml:7624(title)
msgid "Dereferencing"
msgstr "Dereferenzierung"

#: C/gtkmm-tutorial-in.xml:7625(para)
msgid "You can dereference a smartpointer with the -&gt; operator, to call the methods of the underlying instance, just like a normal pointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7629(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"int width = refPixbuf-&gt;get_width();\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"int width = refPixbuf-&gt;get_width();\n"

#: C/gtkmm-tutorial-in.xml:7634(para)
msgid "But unlike most smartpointers, you can't use the * operator to access the underlying instance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7638(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Gdk::Pixbuf&amp; underlying = *refPixbuf; //Syntax error - will not compile.\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Gdk::Pixbuf&amp; underlying = *refPixbuf; //Syntax error - will not compile.\n"

#: C/gtkmm-tutorial-in.xml:7645(title)
msgid "Casting"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7646(para)
msgid "You can cast <classname>RefPtr</classname>s to base types, just like normal pointers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7651(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"

#: C/gtkmm-tutorial-in.xml:7656(para)
msgid ""
"This means that any method which takes a <type>const Glib::RefPtr&lt;BaseType&gt;</type> argument can also take a <type>const Glib::RefPtr&lt;"
"DerivedType&gt;</type>. The cast is implicit, just as it would be for a normal pointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7660(para)
msgid "You can also cast to a derived type, but the syntax is a little different than with a normal pointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7664(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);\n"

#: C/gtkmm-tutorial-in.xml:7674(title)
msgid "Checking for null"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7675(para)
msgid "Just like normal pointers, you can check whether a <classname>RefPtr</classname> points to anything."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7680(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();\n"
"if(refModel)\n"
"{\n"
"  int cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();\n"
"if(refModel)\n"
"{\n"
"  int cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7689(para)
msgid ""
"But unlike normal pointers, <classname>RefPtr</classname>s are automatically initialized to null so you don't need to remember to do that "
"yourself."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7696(title)
msgid "Constness"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7697(para)
msgid ""
"The use of the <literal>const</literal> keyword in C++ is not always clear. You might not realise that <type>const Something*</type> declares a "
"pointer to a <type>const Something</type>. The pointer can be changed, but not the <type>Something</type> that it points to."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7703(para)
msgid ""
"Therefore, the <classname>RefPtr</classname> equivalent of <type>Something*</type> for a method parameter is <type>const Glib::RefPtr&lt;"
"Something&gt;&amp;</type>, and the equivalent of <type>const Something*</type> is <type>const Glib::RefPtr&lt;const Something&gt;&amp;</type>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7710(para)
msgid ""
"The <literal>const ... &amp;</literal> around both is just for efficiency, like using <classname>const std::string&amp;</classname> instead of "
"<classname>std::string</classname> for a method parameter to avoid unnecessary copying."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7725(title)
msgid "Connecting signal handlers"
msgstr "Verbinden von Signal-Handlern"

#: C/gtkmm-tutorial-in.xml:7726(para)
msgid ""
"<application>gtkmm</application> widget classes have signal accessor methods, such as <methodname>Gtk::Button::signal_clicked()</methodname>, "
"which allow you to connect your signal handler. Thanks to the flexibility of <application>libsigc++</application>, the callback library used by "
"<application>gtkmm</application>, the signal handler can be almost any kind of function, but you will probably want to use a class method. "
"Among <application>GTK+</application> C coders, these signal handlers are often named callbacks."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7736(para)
msgid "Here's an example of a signal handler being connected to a signal:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7741(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7757(para)
msgid "There's rather a lot to think about in this (non-functional) code. First let's identify the parties involved:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7765(para)
msgid "The signal handler is <methodname>on_button_clicked()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7771(para)
msgid "We're hooking it up to the <classname>Gtk::Button</classname> object called <varname>button</varname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7778(para)
msgid "When the Button emits its <literal>clicked</literal> signal, <methodname>on_button_clicked()</methodname> will be called."
msgstr "Wenn der Knopf sein <literal>clicked</literal>-Signal ausgibt, wird <methodname>on_button_clicked()</methodname> aufgerufen."

#: C/gtkmm-tutorial-in.xml:7786(para)
msgid "Now let's look at the connection again:"
msgstr "Nun werfen wir wieder einen Blick auf die Verbindung:"

#: C/gtkmm-tutorial-in.xml:7791(programlisting)
#, no-wrap
msgid ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"
msgstr ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"

#: C/gtkmm-tutorial-in.xml:7798(para)
msgid ""
"Note that we don't pass a pointer to <methodname>on_button_clicked()</methodname> directly to the signal's <methodname>connect()</methodname> "
"method. Instead, we call <function>sigc::ptr_fun()</function>, and pass the result to <methodname>connect()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7805(para)
msgid ""
"<function>sigc::ptr_fun()</function> generates a <classname>sigc::slot</classname>. A slot is an object which looks and feels like a function, "
"but is actually an object. These are also known as function objects, or functors. <function>sigc::ptr_fun()</function> generates a slot for a "
"standalone function or static method. <function>sigc::mem_fun()</function> generates a slot for a member method of a particular instance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7814(para)
msgid "Here's a slightly larger example of slots in action:"
msgstr "Hier ist ein etwas umfangreicheres Beispiel von Slots in Aktion:"

#: C/gtkmm-tutorial-in.xml:7819(programlisting)
#, no-wrap
msgid ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"
msgstr ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7838(para)
msgid "The first call to <methodname>connect()</methodname> is just like the one we saw last time; nothing new here."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7841(para)
msgid ""
"The next is more interesting. <function>sigc::mem_fun()</function> is called with two arguments. The first argument is <parameter>some_object</"
"parameter>, which is the object that our new slot will be pointing at. The second argument is a pointer to one of its methods. This particular "
"version of <function>sigc::mem_fun()</function> creates a slot which will, when \"called\", call the pointed-to method of the specified object, "
"in this case <methodname>some_object.on_button_clicked()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7851(para)
msgid ""
"Another thing to note about this example is that we made the call to <methodname>connect()</methodname> twice for the same signal object. This "
"is perfectly fine - when the button is clicked, both signal handlers will be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7858(para)
msgid ""
"We just told you that the button's <literal>clicked</literal> signal is expecting to call a method with no arguments. All signals have "
"requirements like this - you can't hook a function with two arguments to a signal expecting none (unless you use an adapter, such as "
"<function>sigc::bind()</function>, of course). Therefore, it's important to know what type of signal handler you'll be expected to connect to a "
"given signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7870(title)
msgid "Writing signal handlers"
msgstr "Schreiben von Signal-Handlern"

#: C/gtkmm-tutorial-in.xml:7872(para)
msgid ""
"To find out what type of signal handler you can connect to a signal, you can look it up in the reference documentation or the header file. "
"Here's an example of a signal declaration you might see in the <application>gtkmm</application> headers:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7879(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy1&lt;bool, Gtk::DirectionType&gt; signal_focus()\n"
msgstr ""
"\n"
"Glib::SignalProxy1&lt;bool, Gtk::DirectionType&gt; signal_focus()\n"

#: C/gtkmm-tutorial-in.xml:7884(para)
msgid ""
"Other than the signal's name (<literal>focus</literal>), two things are important to note here: the number following the word "
"<classname>SignalProxy</classname> at the beginning (1, in this case), and the types in the list (<type>bool</type> and <type>Gtk::"
"DirectionType</type>). The number indicates how many arguments the signal handler should have; the first type, <type>bool</type>, is the type "
"that the signal handler should return; and the next type, <type>Gtk::DirectionType</type>, is the type of this signal's first, and only, "
"argument. By looking at the reference documentation, you can see the names of the arguments too."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7896(para)
msgid ""
"The same principles apply for signals which have more arguments. Here's one with three (taken from <filename>&lt;gtkmm/textbuffer.h&gt;</"
"filename>):"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7902(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "Glib::SignalProxy3&lt;void, const Glib::ustring&amp;, int, int*&gt; signal_insert_text()\n"
#| "\n"
msgid ""
"\n"
"Glib::SignalProxy3&lt;void, const TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int&gt; signal_insert();\n"
msgstr ""
"\n"
"Glib::SignalProxy3&lt;void, const TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int&gt; signal_insert();\n"

#: C/gtkmm-tutorial-in.xml:7907(para)
msgid ""
"It follows the same form. The number 3 at the end of the type's name indicates that our signal handler will need three arguments. The first "
"type in the type list is <type>void</type>, so that should be our signal handler's return type. The following three types are the argument "
"types, in order. Our signal handler's prototype could look like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7916(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "void on_insert_text(const Glib::ustring&amp; text, int length, int* position);\n"
msgid ""
"\n"
"void on_insert(const TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)\n"
msgstr ""
"\n"
"void on_insert(const TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)\n"

#: C/gtkmm-tutorial-in.xml:7923(title)
msgid "Disconnecting signal handlers"
msgstr "Verbindungen von Signal-Handlern trennen"

#: C/gtkmm-tutorial-in.xml:7925(para)
msgid "Let's take another look at a Signal's <literal>connect</literal> method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7930(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );\n"
msgstr ""
"\n"
"sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );\n"

#: C/gtkmm-tutorial-in.xml:7935(para)
msgid ""
"Notice that the return value is of type <classname>sigc::signal&lt;void,int&gt;::iterator</classname>. This can be implicitly converted into a "
"<classname>sigc::connection</classname> which in turn can be used to control the connection. By keeping a connection object you can disconnect "
"its associated signal handler using the method <methodname>sigc::connection::disconnect()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7946(title)
msgid "Overriding default signal handlers"
msgstr "Überschreiben von Standard-Signalhandlern"

#: C/gtkmm-tutorial-in.xml:7948(para)
msgid ""
"So far we've told you to perform actions in response to button-presses and the like by handling signals. That's certainly a good way to do "
"things, but it's not the only way."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7955(para)
msgid ""
"Instead of laboriously connecting signal handlers to signals, you can simply make a new class which inherits from a widget - say, a Button - "
"and then override the default signal handler, such as Button::on_clicked(). This can be a lot simpler than hooking up signal handlers for "
"everything."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7962(para)
msgid ""
"Subclassing isn't always the best way to accomplish things. It is only useful when you want the widget to handle its own signal by itself. If "
"you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several "
"objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7967(para)
msgid ""
"<application>gtkmm</application> classes are designed with overriding in mind; they contain virtual member methods specifically intended to be "
"overridden."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7972(para)
msgid "Let's look at an example of overriding:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7977(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"    virtual void on_clicked();\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"    // call the base class's version of the method:\n"
"    Gtk::Button::on_clicked();\n"
"}\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"    virtual void on_clicked();\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"    // call the base class's version of the method:\n"
"    Gtk::Button::on_clicked();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7996(para)
msgid ""
"Here we define a new class called <classname>OverriddenButton</classname>, which inherits from <classname>Gtk::Button</classname>. The only "
"thing we change is the <methodname>on_clicked()</methodname> method, which is called whenever <classname>Gtk::Button</classname> emits the "
"<literal>clicked</literal> signal. This method prints \"Hello World\" to <literal>stdout</literal>, and then calls the original, overridden "
"method, to let <classname>Gtk::Button</classname> do what it would have done had we not overridden."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8007(para)
msgid ""
"You don't always need to call the parent's method; there are times when you might not want to. Note that we called the parent method "
"<emphasis>after</emphasis> writing \"Hello World\", but we could have called it before. In this simple example, it hardly matters much, but "
"there are times when it will. With signals, it's not quite so easy to change details like this, and you can do something here which you can't "
"do at all with connected signal handlers: you can call the parent method in the <emphasis>middle</emphasis> of your custom code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8021(title)
msgid "Binding extra arguments"
msgstr "Binden weiterer Argumente"

#: C/gtkmm-tutorial-in.xml:8028(programlisting)
#, no-wrap
msgid ""
"\n"
"m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\") );\n"
msgstr ""
"\n"
"m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\") );\n"

#: C/gtkmm-tutorial-in.xml:8035(programlisting)
#, no-wrap
msgid ""
"\n"
"virtual void on_button_clicked(Glib::ustring data);\n"
msgstr ""
"\n"
"virtual void on_button_clicked(Glib::ustring data);\n"

#: C/gtkmm-tutorial-in.xml:8022(para)
msgid ""
"If you use one signal handler to catch the same signal from several widgets, you might like that signal handler to receive some extra "
"information. For instance, you might want to know which button was clicked. You can do this with <function>sigc::bind()</function>. Here's some "
"code from the <link linkend=\"sec-helloworld2\">helloworld2</link> example. <placeholder-1/> This says that we want the signal to send an extra "
"<classname>Glib::ustring</classname> argument to the signal handler, and that the value of that argument should be \"button 1\". Of course we "
"will need to add that extra argument to the declaration of our signal handler: <placeholder-2/> Of course, a normal \"clicked\" signal handler "
"would have no arguments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8040(para)
msgid ""
"<function>sigc::bind()</function> is not commonly used, but you might find it helpful sometimes. If you are familiar with <application>GTK+</"
"application> programming then you have probably noticed that this is similar to the extra <literal>gpointer data</literal> arguments which all "
"GTK+ callbacks have. This is generally overused in <application>GTK+</application> to pass information that should be stored as member data in "
"a derived widget, but widget derivation is very difficult in C. We have far less need of this hack in <application>gtkmm</application>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8052(title)
msgid "X Event signals"
msgstr "X-Ereignissignale"

#: C/gtkmm-tutorial-in.xml:8053(para)
msgid ""
"The <classname>Widget</classname> class has some special signals which correspond to the underlying X-Windows events. These are suffixed by "
"<literal>_event</literal>; for instance, <methodname>Widget::signal_button_press_event()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8059(para)
msgid ""
"You might occasionally find it useful to handle X events when there's something you can't accomplish with normal signals. <classname>Gtk::"
"Button</classname>, for example, does not send mouse-pointer coordinates with its <literal>clicked</literal> signal, but you could handle "
"<literal>button_press_event</literal> if you needed this information. X events are also often used to handle key-presses."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8068(para)
msgid ""
"These signals behave slightly differently. The value returned from the signal handler indicates whether it has fully \"handled\" the event. If "
"the value is <literal>false</literal> then <application>gtkmm</application> will pass the event on to the next signal handler. If the value is "
"<literal>true</literal> then no other signal handlers will need to be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8073(para)
msgid ""
"Handling an X event doesn't affect the Widget's other signals. If you handle <literal>button_press_event</literal> for <classname>Gtk::Button</"
"classname>, you'll still be able to get the <literal>clicked</literal> signal. They are emitted at (nearly) the same time."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8080(para)
msgid ""
"Note also that not all widgets receive all X events by default. To receive additional X events, you can use <methodname>Gtk::Widget::"
"set_events()</methodname> before showing the widget, or <methodname>Gtk::Widget::add_events()</methodname> after showing the widget. However, "
"some widgets must first be placed inside an <classname>EventBox</classname> widget. See the <link linkend=\"chapter-widgets-without-xwindows"
"\">Widgets Without X-Windows</link> chapter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8089(programlisting)
#, no-wrap
msgid ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"
msgstr ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"

#: C/gtkmm-tutorial-in.xml:8095(para)
msgid "When the mouse is over the button and a mouse button is pressed, <methodname>on_button_press()</methodname> will be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8100(para)
msgid ""
"<type>GdkEventButton</type> is a structure containing the event's parameters, such as the coordinates of the mouse pointer at the time the "
"button was pressed. There are several different types of <type>GdkEvent</type> structures for the various events."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8108(title)
msgid "Signal Handler sequence"
msgstr "Signalhandler-Sequenz"

#: C/gtkmm-tutorial-in.xml:8116(programlisting)
#, no-wrap
msgid ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"
msgstr ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"

#: C/gtkmm-tutorial-in.xml:8109(para)
msgid ""
"By default, your signal handlers are called after any previously-connected signal handlers. However, this can be a problem with the X Event "
"signals. For instance, the existing signal handlers, or the default signal handler, might return <literal>true</literal> to stop other signal "
"handlers from being called. To specify that your signal handler should be called before the other signal handlers, so that it will always be "
"called, you can specify <literal>false</literal> for the optional <literal>after</literal> parameter. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8120(para)
msgid ""
"The event is delivered first to the widget the event occurred in. If all signal handlers in that widget return <literal>false</literal> "
"(indicating that the event has not been handled), then the signal will be propagated to the parent widget and emitted there. This continues all "
"the way up to the top-level widget if no one handles the event."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8131(title)
msgid "Exceptions in signal handlers"
msgstr "Ausnahmen in Signal-Handlern"

#: C/gtkmm-tutorial-in.xml:8132(para)
msgid ""
"When a program is aborted because of an unhandled C++ exception, it's sometimes possible to use a debugger to find the location where the "
"exception was thrown. This is more difficult than usual if the exception was thrown from a signal handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8137(para)
msgid ""
"This section describes primarily what you can expect on a Linux system, when you use <ulink url=\"http://www.gnu.org/software/gdb/\">the gdb "
"debugger</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8144(programlisting)
#, no-wrap
#| msgid ""
#| "int main(int argc, char** argv)\n"
#| "{\n"
#| "  Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.example\");\n"
#| "\n"
#| "  HelloWorld helloworld;\n"
#| "  return app-&gt;run(helloworld);\n"
#| "}"
msgid ""
"\n"
"// without_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  throwSomething();\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.without_signal\");\n"
"  return app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"// without_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  throwSomething();\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.without_signal\");\n"
"  return app-&gt;run();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8141(para)
msgid "First, let's look at a simple example where an exception is thrown from a normal function (no signal handler). <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8166(programlisting)
#, no-wrap
msgid ""
"\n"
"&gt; gdb without_signal\n"
"(gdb) run\n"
"terminate called after throwing an instance of 'char const*'\n"
"\n"
"Program received signal SIGABRT, Aborted.\n"
"(gdb) backtrace\n"
"#7  0x08048864 in throwSomething () at without_signal.cc:6\n"
"#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12\n"
msgstr ""
"\n"
"&gt; gdb without_signal\n"
"(gdb) run\n"
"terminate called after throwing an instance of 'char const*'\n"
"\n"
"Program received signal SIGABRT, Aborted.\n"
"(gdb) backtrace\n"
"#7  0x08048864 in throwSomething () at without_signal.cc:6\n"
"#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12\n"

#: C/gtkmm-tutorial-in.xml:8163(para)
msgid ""
"Here is an excerpt from a <application>gdb</application> session. Only the most interesting parts of the output are shown. <placeholder-1/> You "
"can see that the exception was thrown from <filename>without_signal.cc</filename>, line 6 (<code>throw \"Something\";</code>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8182(programlisting)
#, no-wrap
msgid ""
"\n"
"// with_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.with_signal\");\n"
"  app-&gt;hold();\n"
"  return app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"// with_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.with_signal\");\n"
"  app-&gt;hold();\n"
"  return app-&gt;run();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8179(para)
msgid "Now let's see what happens when an exception is thrown from a signal handler. Here's the source code. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8204(programlisting)
#, no-wrap
msgid ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) run\n"
"(with_signal:2703): glibmm-ERROR **:\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
"(gdb) backtrace\n"
"#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77\n"
"#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150\n"
"#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212\n"
"#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178\n"
"#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16\n"
msgstr ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) run\n"
"(with_signal:2703): glibmm-ERROR **:\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
"(gdb) backtrace\n"
"#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77\n"
"#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150\n"
"#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212\n"
"#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178\n"
"#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16\n"

#: C/gtkmm-tutorial-in.xml:8202(para)
msgid ""
"And here's an excerpt from a <application>gdb</application> session. <placeholder-1/> The exception is caught in <application>glibmm</"
"application>, and the program ends with a call to <function>g_error()</function>. Other exceptions may result in different behaviour, but in "
"any case the exception from a signal handler is caught in <application>glibmm</application> or <application>gtkmm</application>, and "
"<application>gdb</application> can't see where it was thrown."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8227(programlisting)
#, no-wrap
msgid ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) catch throw\n"
"Catchpoint 1 (throw)\n"
"(gdb) run\n"
"Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()\n"
"(gdb) backtrace\n"
"#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6\n"
"#1  0x08048bd4 in throwSomething () at with_signal.cc:6\n"
"(gdb) continue\n"
"Continuing.\n"
"(with_signal:2375): glibmm-ERROR **\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
msgstr ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) catch throw\n"
"Catchpoint 1 (throw)\n"
"(gdb) run\n"
"Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()\n"
"(gdb) backtrace\n"
"#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6\n"
"#1  0x08048bd4 in throwSomething () at with_signal.cc:6\n"
"(gdb) continue\n"
"Continuing.\n"
"(with_signal:2375): glibmm-ERROR **\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"

#: C/gtkmm-tutorial-in.xml:8224(para)
msgid ""
"To see where the exception is thrown, you can use the <application>gdb</application> command <userinput>catch throw</userinput>. <placeholder-1/"
">"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8248(programlisting)
#, no-wrap
msgid ""
"\n"
"(gdb) catch throw\n"
"(gdb) commands\n"
"(gdb)   backtrace\n"
"(gdb)   continue\n"
"(gdb)   end\n"
"(gdb) set pagination off\n"
"(gdb) run\n"
msgstr ""
"\n"
"(gdb) catch throw\n"
"(gdb) commands\n"
"(gdb)   backtrace\n"
"(gdb)   continue\n"
"(gdb)   end\n"
"(gdb) set pagination off\n"
"(gdb) run\n"

#: C/gtkmm-tutorial-in.xml:8244(para)
msgid ""
"If there are many caught exceptions before the interesting uncaught one, this method can be tedious. It can be automated with the following "
"<application>gdb</application> commands. <placeholder-1/> These commands will print a backtrace from each <code>throw</code> and continue. The "
"backtrace from the last (or possibly the last but one) <code>throw</code> before the program stops, is the interesting one."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8267(title)
msgid "Creating your own signals"
msgstr "Erzeugen Ihrer eigenen Signale"

#: C/gtkmm-tutorial-in.xml:8268(para)
msgid ""
"Now that you've seen signals and signal handlers in <application>gtkmm</application>, you might like to use the same technique to allow "
"interaction between your own classes. That's actually very simple by using the <application>libsigc++</application> library directly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8274(para)
msgid ""
"This isn't purely a <application>gtkmm</application> or GUI issue. <application>gtkmm</application> uses <application>libsigc++</application> "
"to implement its proxy wrappers for the <application>GTK+</application> signal system, but for new, non-GTK+ signals, you can create pure C++ "
"signals, using the <classname>sigc::signal&lt;&gt;</classname> template."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8285(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void, bool, int&gt; signal_something;\n"
msgstr ""
"\n"
"sigc::signal&lt;void, bool, int&gt; signal_something;\n"

#: C/gtkmm-tutorial-in.xml:8281(para)
msgid ""
"For instance, to create a signal that sends 2 parameters, a <type>bool</type> and an <type>int</type>, just declare a <classname>sigc::signal</"
"classname>, like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8293(programlisting)
#, no-wrap
msgid ""
"\n"
"class Server\n"
"{\n"
"public:\n"
"  //signal accessor:\n"
"  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;\n"
"  type_signal_something signal_something();\n"
"\n"
"protected:\n"
"  type_signal_something m_signal_something;\n"
"};\n"
"\n"
"Server::type_signal_something Server::signal_something()\n"
"{\n"
"  return m_signal_something;\n"
"}\n"
msgstr ""
"\n"
"class Server\n"
"{\n"
"public:\n"
"  //signal accessor:\n"
"  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;\n"
"  type_signal_something signal_something();\n"
"\n"
"protected:\n"
"  type_signal_something m_signal_something;\n"
"};\n"
"\n"
"Server::type_signal_something Server::signal_something()\n"
"{\n"
"  return m_signal_something;\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8289(para)
msgid ""
"You could just declare that signal as a public member variable, but some people find that distasteful and prefer to make it available via an "
"accessor method, like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8315(programlisting)
#, no-wrap
msgid ""
"\n"
"server.signal_something().connect(\n"
"  sigc::mem_fun(client, &amp;Client::on_server_something) );\n"
msgstr ""
"\n"
"server.signal_something().connect(\n"
"  sigc::mem_fun(client, &amp;Client::on_server_something) );\n"

#: C/gtkmm-tutorial-in.xml:8312(para)
msgid ""
"You can then connect to the signal using the same syntax used when connecting to <application>gtkmm</application> signals. For instance, "
"<placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8323(para)
msgid "This is a full working example that defines and uses custom signals."
msgstr "Dies ist ein voll funktionsfähiges Beispiel, welches benutzerdefinierte Signale definiert und nutzt."

#: C/gtkmm-tutorial-in.xml:8337(title)
msgid "Comparison with other signalling systems"
msgstr "Vergleich mit anderen Signalsystemen"

#: C/gtkmm-tutorial-in.xml:8338(para)
msgid ""
"(An aside: <application>GTK+</application> calls this scheme \"signalling\"; the sharp-eyed reader with GUI toolkit experience will note that "
"this same design is often seen under the name of \"broadcaster-listener\" (e.g., in Metrowerks' PowerPlant framework for the Macintosh). It "
"works in much the same way: one sets up <literal>broadcasters</literal>, and then connects <literal>listeners</literal> to them; the "
"broadcaster keeps a list of the objects listening to it, and when someone gives the broadcaster a message, it calls all of its objects in its "
"list with the message. In <application>gtkmm</application>, signal objects play the role of broadcasters, and slots play the role of listeners "
"- sort of. More on this later.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8352(para)
msgid ""
"<application>gtkmm</application> signal handlers are strongly-typed, whereas <application>GTK+</application> C code allows you to connect a "
"callback with the wrong number and type of arguments, leading to a segfault at runtime. And, unlike <application>Qt</application>, "
"<application>gtkmm</application> achieves this without modifying the C++ language."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8358(para)
msgid ""
"Re. Overriding signal handlers: You can do this in the straight-C world of GTK+ too; that's what GTK's object system is for. But in GTK+, you "
"have to go through some complicated procedures to get object-oriented features like inheritance and overloading. In C++, it's simple, since "
"those features are supported in the language itself; you can let the compiler do the dirty work."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8366(para)
msgid ""
"This is one of the places where the beauty of C++ really comes out. One wouldn't think of subclassing a GTK+ widget simply to override its "
"action method; it's just too much trouble. In GTK+, you almost always use signals to get things done, unless you're writing a new widget. But "
"because overriding methods is so easy in C++, it's entirely practical - and sensible - to subclass a button for that purpose."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8377(title)
msgid "<application>gtkmm</application> and Win32"
msgstr "<application>gtkmm</application> und Win32"

#: C/gtkmm-tutorial-in.xml:8378(para)
msgid ""
"One of the major advantages of <application>gtkmm</application> is that it is crossplatform. <application>gtkmm</application> programs written "
"on other platforms such as GNU/Linux can generally be transferred to Windows (and vice versa) with few modifications to the source."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8383(para)
msgid ""
"<application>gtkmm</application> currently works with the <ulink url=\"http://mingw.org/\">MingW/GCC3.4 compiler</ulink> and Microsoft Visual C+"
"+ 2005 or later (including the freely available express editions) on the Windows platform. There is an <ulink url=\"ftp://ftp.gnome.org/pub/"
"GNOME/binaries/win32/gtkmm\"> installer</ulink> available for gtkmm on Microsoft Windows. Refer to <ulink url=\"https://wiki.gnome.org/Projects/"
"gtkmm/MSWindows/\"> https://wiki.gnome.org/Projects/gtkmm/MSWindows</ulink> for instructions how to use it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8395(title)
msgid "Building <application>gtkmm</application> on Win32"
msgstr "Erstellen von <application>gtkmm</application> auf Win32"

#: C/gtkmm-tutorial-in.xml:8396(para)
msgid ""
"Please see <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/MSWindows/BuildingGtkmm\"> https://wiki.gnome.org/Projects/gtkmm/MSWindows/"
"BuildingGtkmm</ulink> for instructions on how to build gtkmm on Windows."
msgstr ""
"Auf <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/MSWindows/BuildingGtkmm\"> https://wiki.gnome.org/Projects/gtkmm/MSWindows/"
"BuildingGtkmm</ulink> finden Sie Anweisungen, wie Sie gtkmm unter Windows erstellen können."

#: C/gtkmm-tutorial-in.xml:8404(title)
msgid "Working with gtkmm's Source Code"
msgstr "Arbeiten mit dem Quelltext von gtkmm"

#: C/gtkmm-tutorial-in.xml:8405(para)
msgid ""
"If you are interested in helping out with the development of <application>gtkmm</application>, or fixing a bug in <application>gtkmm</"
"application>, you'll probably need to build the development version of <application>gtkmm</application>. However, you should not install a "
"development version over your stable version. Instead, you should install it alongside your existing <application>gtkmm</application> "
"installation, in a separate path."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8412(para)
msgid ""
"The easiest way to do this is using <ulink url=\"https://wiki.gnome.org/Projects/Jhbuild\">jhbuild</ulink>. <application>jhbuild</application> "
"is a program that makes building GNOME software much easier by calculating dependencies and building things in the correct order. This section "
"will give a brief explanation of how to set up <application>jhbuild</application> to build and install <application>gtkmm</application> from "
"the source repository (git). For up-to-date information on <application>jhbuild</application>, please refer to the <ulink url=\"http://"
"developer.gnome.org/jhbuild/unstable/\">jhbuild manual</ulink>. If you need assistance using <application>jhbuild</application>, you should ask "
"for help on the <ulink url=\"http://mail.gnome.org/mailman/listinfo/gnome-love\">gnome-love mailing list</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8428(para)
msgid ""
"Note that to build <application>gtkmm</application> from git, you'll often need to build many of its dependencies from git as well. "
"<application>jhbuild</application> makes this easier than it would normally be, but it will take quite a while to build and install them all. "
"You will probably encounter build problems, though these will usually be corrected quickly if you report them."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8437(title)
msgid "Setting up jhbuild"
msgstr "Einrichten von jhbuild"

#: C/gtkmm-tutorial-in.xml:8438(para)
msgid ""
"To set up <application>jhbuild</application>, follow the basic installation instructions from the <ulink url=\"http://developer.gnome.org/"
"jhbuild/unstable/\">jhbuild manual</ulink>. After you have installed <application>jhbuild</application>, you should copy the sample "
"<application>jhbuild</application> configuration file into your home directory by executing the following command from the "
"<application>jhbuild</application> directory: <screen>$ cp examples/sample.jhbuildrc ~/.jhbuildrc</screen>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8453(programlisting)
#, no-wrap
#| msgid "moduleset = 'gnome-suites-core-deps-3.4'"
msgid "moduleset = 'gnome-suites-core-deps-3.12'"
msgstr "moduleset = 'gnome-suites-core-deps-3.12'"

#: C/gtkmm-tutorial-in.xml:8448(para)
msgid ""
"The <application>gtkmm</application> module is defined in the <filename>gnome-suites-core-deps-3.x.modules</filename> moduleset, so edit your "
"<filename>.jhbuildrc</filename> file and set your moduleset setting to the latest version e.g. like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8460(programlisting)
#, no-wrap
msgid "modules = [ 'gtkmm' ]"
msgstr "modules = [ 'gtkmm' ]"

#: C/gtkmm-tutorial-in.xml:8455(para)
msgid ""
"After setting the correct moduleset, you need to tell <application>jhbuild</application> which module or modules to build. To build "
"<application>gtkmm</application> and all of its dependencies, set <varname>modules</varname> like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8462(para)
msgid ""
"You can build several modules by setting the <varname>modules</varname> variable to a meta-package, e.g. <literal>meta-gnome-core</literal>, or "
"listing more than one module name. The <varname>modules</varname> variable specifies which modules will be built when you don't explicitly "
"specify anything on the command line. You can always build a different moduleset later by specifying it on the commandline (e.g. "
"<command>jhbuild build gtkmm</command>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8472(title)
msgid "Setting a prefix"
msgstr "Festlegen eines Präfix"

#: C/gtkmm-tutorial-in.xml:8473(para)
msgid ""
"By default, <application>jhbuild</application>'s configuration is configured to install all software built with <application>jhbuild</"
"application> under the <filename>/opt/gnome</filename> prefix. You can choose a different prefix, but it is recommended that you keep this "
"prefix different from other software that you've installed (don't set it to <filename>/usr</filename>!) If you've followed the jhbuild "
"instructions then this prefix belongs to your user, so you don't need to run jhbuild as <literal>root</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8485(para)
msgid ""
"When you downloaded <application>jhbuild</application> from the git repository, you got a number of <filename>.modules</filename> files, "
"specifying dependencies between modules. By default <application>jhbuild</application> does not use the downloaded versions of these files, but "
"reads the latest versions in the git repository. This is usually what you want. If you don't want it, use the <varname>use_local_modulesets</"
"varname> variable in <filename>.jhbuildrc</filename>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8496(title)
msgid "Installing and Using the git version of <application>gtkmm</application>"
msgstr "Installation und Verwendung der Git-Version von <application>gtkmm</application>"

#: C/gtkmm-tutorial-in.xml:8497(para)
msgid ""
"Once you've configured <application>jhbuild</application> as described above, building <application>gtkmm</application> should be relatively "
"straightforward. The first time you run <application>jhbuild</application>, you should run the following sequence of commands to ensure that "
"<application>jhbuild</application> has the required tools and verify that it is set up correctly: <screen>$ jhbuild bootstrap\n"
"$ jhbuild sanitycheck</screen>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8508(title)
msgid "Installing <application>gtkmm</application> with <application>jhbuild</application>"
msgstr "Installation von <application>gtkmm</application> mit <application>jhbuild</application>"

#: C/gtkmm-tutorial-in.xml:8509(para)
msgid ""
"If everything worked correctly, you should be able to build <application>gtkmm</application> and all of its dependencies from git by executing "
"<command>jhbuild build</command> (or, if you didn't specify <application>gtkmm</application> in the <varname>modules</varname> variable, with "
"the command <command>jhbuild build gtkmm</command>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8516(para)
msgid ""
"This command will build and install a series of modules and will probably take quite a long time the first time through. After the first time, "
"however, it should go quite a bit faster since it only needs to rebuild files that changed since the last build. Alternatively, after you've "
"built and installed <application>gtkmm</application> the first time, you can rebuild <application>gtkmm</application> by itself (without "
"rebuilding all of its dependencies) with the command <command>jhbuild buildone gtkmm</command>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8527(title)
msgid "Using the git version of <application>gtkmm</application>"
msgstr "Verwendung der Git-Version von <application>gtkmm</application>"

#: C/gtkmm-tutorial-in.xml:8528(para)
msgid ""
"After you've installed the git version of <application>gtkmm</application>, you're ready to start using and experimenting with it. In order to "
"use the new version of <application>gtkmm</application> you've just installed, you need to set some environment variables so that your "
"<filename>configure</filename> script knows where to find the new libraries. Fortunately, <application>jhbuild</application> offers an easy "
"solution to this problem. Executing the command <command>jhbuild shell</command> will start a new shell with all of the correct environment "
"variables set. Now if you re-configure and build your project just as you usually do, it should link against the newly installed libraries. To "
"return to your previous environment, simply exit the <application>jhbuild</application> shell."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8542(para)
msgid ""
"Once you've built your software, you'll need to run your program within the jhbuild environment as well. To do this, you can again use the "
"<command>jhbuild shell</command> command to start a new shell with the <application>jhbuild</application> environment set up. Alternatively, "
"you can execute a one-off command in the <application>jhbuild</application> environment using the following command: <command>jhbuild run "
"command-name</command>. In this case, the command will be run with the correct environment variables set, but will return to your previous "
"environment after the program exits."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8559(title)
msgid "Wrapping C Libraries with gmmproc"
msgstr "Wrapping von C-Bibliotheken mit gmmproc"

#: C/gtkmm-tutorial-in.xml:8560(para)
msgid ""
"<application>gtkmm</application> uses the <command>gmmproc</command> tool to generate most of its source code, using .defs files that define "
"the APIs of <classname>GObject</classname>-based libraries. So it's quite easy to create additional gtkmm-style wrappers of other glib/GObject-"
"based libraries."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8565(para)
msgid "This involves a variety of tools, some of them crufty, but at least they work, and has been used successfully by several projects."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8570(title)
msgid "The build structure"
msgstr "Die Erstellungsstruktur"

#: C/gtkmm-tutorial-in.xml:8571(para)
msgid ""
"Generation of the source code for a gtkmm-style wrapper API requires use of tools such as <command>gmmproc</command> and "
"<filename>generate_wrap_init.pl</filename>. In theory you could write your own build files to use these appropriately, but a much better option "
"is to make use of the build infrastructure provided by the mm-common module. To get started, it helps a lot to pick an existing binding module "
"as an example to look at."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8578(para)
msgid ""
"For instance, let's pretend that we are wrapping a C library called libsomething. It provides a <classname>GObject</classname>-based API with "
"types named, for instance, <classname>SomeWidget</classname> and <classname>SomeStuff</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8584(title)
msgid "Copying the skeleton project"
msgstr "Kopieren des Projektgerüsts"

#: C/gtkmm-tutorial-in.xml:8589(programlisting)
#, no-wrap
msgid ""
"\n"
"  $ git clone git://git.gnome.org/mm-common\n"
"  $ cp -a mm-common/skeletonmm libsomethingmm\n"
msgstr ""
"\n"
"  $ git clone git://git.gnome.org/mm-common\n"
"  $ cp -a mm-common/skeletonmm libsomethingmm\n"

#: C/gtkmm-tutorial-in.xml:8586(para)
msgid ""
"Typically our wrapper library would be called libsomethingmm. We can start by copying the <ulink url=\"http://git.gnome.org/browse/mm-common/"
"tree/skeletonmm\">skeleton source tree</ulink> from the mm-common module. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8599(para)
msgid "<filename>libsomethingmm</filename>: The top-level directory."
msgstr "<filename>libsomethingmm</filename>: Der Ordner der obersten Ebene."

#: C/gtkmm-tutorial-in.xml:8601(para)
msgid "<filename>libsomething</filename>: Contains the main include file and the pkg-config .pc file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8603(para)
msgid "<filename>src</filename>: Contains .hg and .ccg source files."
msgstr "<filename>src</filename>: Enthält .hg- und .ccg-Quelldateien."

#: C/gtkmm-tutorial-in.xml:8604(para)
msgid "<filename>libsomethingmm</filename>: Contains generated and hand-written .h and .cc files."
msgstr "<filename>libsomethingmm</filename>: Enthält generierte und handgeschriebene .h- und .cc-Dateien."

#: C/gtkmm-tutorial-in.xml:8606(para)
msgid "<filename>private</filename>: Contains generated <filename>*_p.h</filename> files."
msgstr "<filename>private</filename>: Enthält generierte <filename>*_p.h</filename>-Dateien."

#: C/gtkmm-tutorial-in.xml:8594(para)
msgid ""
"This provides a directory structure for the source .hg and .ccg files and the generated .h and .cc files, with <filename>filelist.am</filename> "
"Automake include files that can specify the various files in use, in terms of generic Automake variables. The directory structure usually looks "
"like this, after we have renamed the directories appropriately: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8618(programlisting)
#, no-wrap
msgid ""
"\n"
"$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\\n"
"    d=\"${f%/*}\"; b=\"${f##*/}\"; mv \"$f\" \"$d/${b//skeleton/libsomething}\"; \\\n"
"  done\n"
msgstr ""
"\n"
"$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\\n"
"    d=\"${f%/*}\"; b=\"${f##*/}\"; mv \"$f\" \"$d/${b//skeleton/libsomething}\"; \\\n"
"  done\n"

#: C/gtkmm-tutorial-in.xml:8616(para)
msgid ""
"As well as renaming the directories, we should rename some of the source files. For instance: <placeholder-1/> A number of the skeleton files "
"must still be filled in with project-specific content later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8625(para)
msgid ""
"Note that files ending in <filename>.in</filename> will be used to generate files with the same name but without the <filename>.in</filename> "
"suffix, by replacing some variables with actual values during the configure stage."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8631(title)
msgid "Modifying build files"
msgstr "Anpassen der Erstellungsdateien"

#: C/gtkmm-tutorial-in.xml:8633(para)
msgid ""
"Now we edit the files to adapt them to our needs. You might prefer to use a multiple-file search-replace utility for this, such as "
"<command>regexxer</command>. Note that nearly all of the files provided with the skeleton source tree contain placeholder text. Thus, the "
"substitutions should be performed globally, and not be limited to the Automake and Autoconf files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8637(para)
msgid ""
"All mentions of <varname>skeleton</varname> should be replaced by the correct name of the C library you are wrapping, such as \"something\" or "
"\"libsomething\". In the same manner, all instances of <varname>SKELETON</varname> should be replaced by \"SOMETHING\" or \"LIBSOMETHING\", and "
"all occurrences of <varname>Skeleton</varname> changed to \"Something\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8641(para)
msgid ""
"Likewise, replace all instances of <varname>Joe Hacker</varname> by the name of the intended copyright holder, which is probably you. Do the "
"same for the <varname>joe@example.com</varname> email address."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8646(title)
msgid "configure.ac"
msgstr "configure.ac"

#: C/gtkmm-tutorial-in.xml:8649(para)
msgid ""
"The <function>AC_CONFIG_SRCDIR()</function> line must mention a file in our source tree. We can edit this later if we don't yet know the names "
"of any of the files that we will create."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8652(para)
msgid ""
"It is common for binding modules to track the version number of the library they are wrapping. So, for instance, if the C library is at version "
"1.23.4, then the initial version of the binding module would be 1.23.0. However, avoid starting with an even minor version number as that "
"usually indicates a stable release."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8657(para)
msgid ""
"The <function>AC_CONFIG_HEADERS()</function> line is used to generate two or more configuration header files. The first header file in the list "
"contains all configuration macros which are set during the configure run. The remaining headers in the list contain only a subset of "
"configuration macros and their corresponding <filename>config.h.in</filename> file will not be autogenerated. The reason for this separation is "
"that the namespaced configuration headers are installed with your library and define publically visible macros."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8665(para)
msgid "The <function>AC_SUBST([SOMETHINGMM_MODULES], ['...'])</function> line may need to be modified to check for the correct dependencies."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8667(para)
msgid "The <function>AC_CONFIG_FILES()</function> block must mention the correct directory names, as described above."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8647(para)
msgid "In <filename>configure.ac</filename>, <placeholder-1/>"
msgstr "In <filename>configure.ac</filename>, <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8674(title)
msgid "Makefile.am files"
msgstr "Makefile.am-Dateien"

#: C/gtkmm-tutorial-in.xml:8677(para)
msgid ""
"In <filename>skeleton/src/Makefile.am</filename> we must mention the correct values for the generic variables that are used elsewhere in the "
"build system:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8682(varname)
msgid "binding_name"
msgstr "binding_name"

#: C/gtkmm-tutorial-in.xml:8683(para)
msgid "The name of the library, such as libsomethingmm."
msgstr "Der Name der Bibliothek, wie libsomethingmm."

#: C/gtkmm-tutorial-in.xml:8687(varname)
msgid "wrap_init_flags"
msgstr "wrap_init_flags"

#: C/gtkmm-tutorial-in.xml:8688(para)
msgid ""
"Additional command-line flags passed to the <filename>generate_wrap_init.pl</filename> script, such as the C++ namespace and the parent "
"directory prefix of include files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8695(para)
msgid ""
"In <filename>skeleton/skeletonmm/Makefile.am</filename> we must mention the correct values for the generic variables that are used elsewhere in "
"the build system:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8700(varname)
msgid "lib_LTLIBRARIES"
msgstr "lib_LTLIBRARIES"

#: C/gtkmm-tutorial-in.xml:8701(para)
msgid ""
"This variable must mention the correct library name, and this library name must be used to form the <varname>_SOURCES</varname>, "
"<varname>_LDFLAGS</varname>, and <varname>_LIBADD</varname> variable names. It is permissible to use variables substituted by "
"<filename>configure</filename> like <varname>@SOMETHINGMM_API_VERSION@</varname> as part of the variable names."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8710(varname)
msgid "AM_CPPFLAGS"
msgstr "AM_CPPFLAGS"

#: C/gtkmm-tutorial-in.xml:8711(para)
msgid "The command line options passed to the C preprocessor."
msgstr "Die an den C-Präprozessor übergebenen Befehlszeilenoptionen."

#: C/gtkmm-tutorial-in.xml:8715(varname)
msgid "AM_CXXFLAGS"
msgstr "AM_CXXFLAGS"

#: C/gtkmm-tutorial-in.xml:8716(para)
msgid "The command line options passed to the C++ compiler."
msgstr "Die an den C++-Compiler übergebenen Befehlszeilenoptionen."

#: C/gtkmm-tutorial-in.xml:8675(para)
msgid "Next we must adapt the various <filename>Makefile.am</filename> files: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8726(title)
msgid "Creating .hg and .ccg files"
msgstr "Erstellen der .hg- und .ccg-Dateien"

#: C/gtkmm-tutorial-in.xml:8727(para)
msgid ""
"We should now create our first <filename>.hg</filename> and <filename>.ccg</filename> files, to wrap one of the objects in the C library. One "
"pair of example source files already exists: <filename>skeleton.ccg</filename> and <filename>skeleton.hg</filename>. Create copies of these "
"files as necessary."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8731(para)
msgid ""
"We must mention all of our <filename>.hg</filename> and <filename>.ccg</filename> files in the <filename>skeleton/src/filelist.am</filename> "
"file, typically in the <varname>files_hg</varname> variable."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8735(para)
msgid ""
"Any additional non-generated <filename>.h</filename> and <filename>.cc</filename> source files may be placed in <filename>skeleton/skeletonmm/</"
"filename> and listed in <filename>skeleton/skeletonmm/filelist.am</filename>, typically in the <varname>files_extra_h</varname> and "
"<varname>files_extra_cc</varname> variables."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8741(para)
msgid "In the <link linkend=\"sec-wrapping-hg-files\">.hg and .ccg files</link> section you can learn about the syntax used in these files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8748(title)
msgid "Generating the .defs files."
msgstr "Erstellen der .defs-Dateien."

#: C/gtkmm-tutorial-in.xml:8752(para)
msgid "objects (GObjects, widgets, interfaces, boxed-types and plain structs)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8753(para)
msgid "functions"
msgstr "functions"

#: C/gtkmm-tutorial-in.xml:8754(para)
msgid "enums"
msgstr "enums"

#: C/gtkmm-tutorial-in.xml:8755(para)
msgid "signals"
msgstr "signals"

#: C/gtkmm-tutorial-in.xml:8756(para)
msgid "properties"
msgstr "properties"

#: C/gtkmm-tutorial-in.xml:8757(para)
msgid "vfuncs"
msgstr "vfuncs"

#: C/gtkmm-tutorial-in.xml:8749(para)
msgid ""
"The <filename>.defs</filename> files are text files, in a lisp format, that describe the API of a C library, including its <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8766(filename)
msgid "gtk.defs"
msgstr "gtk.defs"

#: C/gtkmm-tutorial-in.xml:8767(para)
msgid "Includes the other files."
msgstr "Beinhaltet die andren Dateien."

#: C/gtkmm-tutorial-in.xml:8770(filename)
msgid "gtk_methods.defs"
msgstr "gtk_methods.defs"

#: C/gtkmm-tutorial-in.xml:8771(para)
msgid "Objects and functions."
msgstr "Objekte und Funktionen."

#: C/gtkmm-tutorial-in.xml:8774(filename)
msgid "gtk_enums.defs"
msgstr "gtk_enums.defs"

#: C/gtkmm-tutorial-in.xml:8775(para)
msgid "Enumerations."
msgstr "Aufzählungen."

#: C/gtkmm-tutorial-in.xml:8778(filename)
msgid "gtk_signals.defs"
msgstr "gtk_signals.defs"

#: C/gtkmm-tutorial-in.xml:8779(para)
msgid "Signals and properties."
msgstr "Signale und Eigenschaften."

#: C/gtkmm-tutorial-in.xml:8782(filename)
msgid "gtk_vfuncs.defs"
msgstr "gtk_vfuncs.defs"

#: C/gtkmm-tutorial-in.xml:8783(para)
msgid "vfuncs (function pointer member fields in structs), written by hand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8760(para)
msgid ""
"At the moment, we have separate tools for generating different parts of these <filename>.defs</filename>, so we split them up into separate "
"files. For instance, in the <filename>gtk/src</filename> directory of the <application>gtkmm</application> sources, you will find these files: "
"<placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8787(para)
msgid ""
"The <filename>skeletonmm/codegen/generate_defs_and_docs.sh</filename> script generates all <filename>.defs</filename> files and the "
"<filename>*_docs.xml</filename> file, described in the <link linkend=\"sec-wrapping-documentation\">Documentation</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8793(title)
msgid "Generating the methods .defs"
msgstr "Erzeugen der methods.defs"

#: C/gtkmm-tutorial-in.xml:8797(programlisting)
#, no-wrap
msgid ""
"\n"
"$ ./h2def.py /usr/include/gtk-3.0/gtk/*.h &gt; gtk_methods.defs\n"
msgstr ""
"\n"
"$ ./h2def.py /usr/include/gtk-3.0/gtk/*.h &gt; gtk_methods.defs\n"

#: C/gtkmm-tutorial-in.xml:8794(para)
msgid ""
"This <filename>.defs</filename> file describes objects and their functions. It is generated by the <command>h2def.py</command> script which you "
"can find in glibmm's <filename>tools/defs_gen</filename> directory. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8804(title)
msgid "Generating the enums .defs"
msgstr "Erzeugen der enums.defs"

#: C/gtkmm-tutorial-in.xml:8808(programlisting)
#, no-wrap
msgid ""
"\n"
"$ ./enum.pl /usr/include/gtk-3.0/gtk/*.h &gt; gtk_enums.defs\n"
msgstr ""
"\n"
"$ ./enum.pl /usr/include/gtk-3.0/gtk/*.h &gt; gtk_enums.defs\n"

#: C/gtkmm-tutorial-in.xml:8805(para)
msgid ""
"This <filename>.defs</filename> file describes enum types and their possible values. It is generated by the <filename>enum.pl</filename> script "
"which you can find in glibmm's <filename>tools</filename> directory. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8815(title)
msgid "Generating the signals and properties .defs"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8820(programlisting)
#, no-wrap
msgid ""
"\n"
"$ cd tools/extra_defs_gen\n"
"$ ./generate_extra_defs &gt; gtk_signals.defs\n"
msgstr ""
"\n"
"$ cd tools/extra_defs_gen\n"
"$ ./generate_extra_defs &gt; gtk_signals.defs\n"

#: C/gtkmm-tutorial-in.xml:8816(para)
msgid ""
"This <filename>.defs</filename> file describes signals and properties. It is generated by the special <filename>generate_extra_defs</filename> "
"utility that is in every wrapping project, such as <filename>gtkmm/tools/extra_defs_gen/</filename>. For instance <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8825(para)
msgid ""
"You must edit the source code of your own <filename>generate_extra_defs</filename> tool in order to generate the <filename>.defs</filename> for "
"the GObject C types that you wish to wrap. In the skeleton source tree, the source file is named <filename>codegen/extradefs/"
"generate_extra_defs_skeleton.cc</filename>. If not done so already, the file should be renamed, with the basename of your new binding "
"substituted for the <varname>skeleton</varname> placeholder. The <filename>codegen/Makefile.am</filename> file should also mention the new "
"source filename."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8834(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "#include &lt;libsomething.h&gt;\n"
#| "\n"
#| "int main(int, char**)\n"
#| "{\n"
#| "  something_init();\n"
#| "\n"
#| "  std::cout &lt;&lt; get_defs(EXAMPLE_TYPE_SOMETHING)\n"
#| "            &lt;&lt; get_defs(EXAMPLE_TYPE_THING);\n"
#| "  return 0;\n"
#| "}\n"
msgid ""
"\n"
"#include &lt;libsomething.h&gt;\n"
"\n"
"int main(int, char**)\n"
"{\n"
"  something_init();\n"
"\n"
"  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)\n"
"            &lt;&lt; get_defs(SOME_TYPE_STUFF);\n"
"  return 0;\n"
"}\n"
msgstr ""
"\n"
"#include &lt;libsomething.h&gt;\n"
"\n"
"int main(int, char**)\n"
"{\n"
"  something_init();\n"
"\n"
"  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)\n"
"            &lt;&lt; get_defs(SOME_TYPE_STUFF);\n"
"  return 0;\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8832(para)
msgid ""
"Then edit the <filename>.cc</filename> file to specify the correct types. For instance, your <function>main()</function> function might look "
"like this: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8850(title)
msgid "Writing the vfuncs .defs"
msgstr "Schreiben der vfuncs.defs"

#: C/gtkmm-tutorial-in.xml:8851(para)
msgid ""
"This <filename>.defs</filename> file describes virtual functions (vfuncs). It must be written by hand. There is the skeleton file "
"<filename>skeleton/src/skeleton_vfunc.defs</filename> to start from. You can also look at <application>gtkmm</application>'s <filename>gtk/src/"
"gtk_vfuncs.defs</filename> file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8862(title)
msgid "The .hg and .ccg files"
msgstr "Die .hg- und .ccg-Dateien"

#: C/gtkmm-tutorial-in.xml:8863(para)
msgid ""
"The .hg and .ccg source files are very much like .h and .cc C++ source files, but they contain extra macros, such as "
"<function>_CLASS_GOBJECT()</function> and <function>_WRAP_METHOD()</function>, from which <command>gmmproc</command> generates appropriate C++ "
"source code, usually at the same position in the header. Any additional C++ source code will be copied verbatim into the corresponding .h or ."
"cc file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8876(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "#include &lt;gtkmm/bin.h&gt;\n"
#| "#include &lt;gtkmm/activatable.h&gt;\n"
#| "#include &lt;gtkmm/stockid.h&gt;\n"
#| "_DEFS(gtkmm,gtk)\n"
#| "_PINCLUDE(gtkmm/private/bin_p.h)\n"
#| "\n"
#| "namespace Gtk\n"
#| "{\n"
#| "\n"
#| "class Button\n"
#| "  : public Bin,\n"
#| "    public Activatable\n"
#| "{\n"
#| "  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
#| "  _IMPLEMENTS_INTERFACE(Activatable)\n"
#| "public:\n"
#| "\n"
#| "  _CTOR_DEFAULT\n"
#| "  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
#| "  explicit Button(const StockID&amp; stock_id);\n"
#| "\n"
#| "  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
#| "\n"
#| "  ...\n"
#| "\n"
#| "  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
#| "\n"
#| "  ...\n"
#| "\n"
#| "  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
#| "};\n"
#| "\n"
#| "} // namespace Gtk\n"
msgid ""
"\n"
"#include &lt;gtkmm/bin.h&gt;\n"
"#include &lt;gtkmm/activatable.h&gt;\n"
"_DEFS(gtkmm,gtk)\n"
"_PINCLUDE(gtkmm/private/bin_p.h)\n"
"\n"
"namespace Gtk\n"
"{\n"
"\n"
"class Button\n"
"  : public Bin,\n"
"    public Activatable\n"
"{\n"
"  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
"  _IMPLEMENTS_INTERFACE(Activatable)\n"
"public:\n"
"\n"
"  _CTOR_DEFAULT\n"
"  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
"\n"
"  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
"};\n"
"\n"
"} // namespace Gtk\n"
msgstr ""
"\n"
"#include &lt;gtkmm/bin.h&gt;\n"
"#include &lt;gtkmm/activatable.h&gt;\n"
"_DEFS(gtkmm,gtk)\n"
"_PINCLUDE(gtkmm/private/bin_p.h)\n"
"\n"
"namespace Gtk\n"
"{\n"
"\n"
"class Button\n"
"  : public Bin,\n"
"    public Activatable\n"
"{\n"
"  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
"  _IMPLEMENTS_INTERFACE(Activatable)\n"
"public:\n"
"\n"
"  _CTOR_DEFAULT\n"
"  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
"\n"
"  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
"};\n"
"\n"
"} // namespace Gtk\n"

#: C/gtkmm-tutorial-in.xml:8871(para)
msgid ""
"A .hg file will typically include some headers and then declare a class, using some macros to add API or behaviour to this class. For instance, "
"<application>gtkmm</application>'s <filename>button.hg</filename> looks roughly like this: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8913(function)
msgid "_DEFS()"
msgstr "_DEFS()"

#: C/gtkmm-tutorial-in.xml:8914(para)
msgid ""
"Specifies the destination directory for generated sources, and the name of the main .defs file that <command>gmmproc</command> should parse."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8917(function)
msgid "_PINCLUDE()"
msgstr "_PINCLUDE()"

#: C/gtkmm-tutorial-in.xml:8918(para)
msgid "Tells <command>gmmproc</command> to include a header in the generated private/button_p.h file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8921(function)
msgid "_CLASS_GTKOBJECT()"
msgstr "_CLASS_GTKOBJECT()"

#: C/gtkmm-tutorial-in.xml:8922(para)
msgid ""
"Tells <command>gmmproc</command> to add some typedefs, constructors, and standard methods to this class, as appropriate when wrapping a widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8925(function)
msgid "_IMPLEMENTS_INTERFACE()"
msgstr "_IMPLEMENTS_INTERFACE()"

#: C/gtkmm-tutorial-in.xml:8926(para)
msgid "Tells <command>gmmproc</command> to add initialization code for the interface."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8929(function) C/gtkmm-tutorial-in.xml:9175(title)
msgid "_CTOR_DEFAULT"
msgstr "_CTOR_DEFAULT"

#: C/gtkmm-tutorial-in.xml:8930(para)
msgid "Add a default constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8933(term)
msgid "<function>_WRAP_METHOD()</function>, <function>_WRAP_SIGNAL()</function>, and <function>_WRAP_PROPERTY()</function>"
msgstr "<function>_WRAP_METHOD()</function>, <function>_WRAP_SIGNAL()</function> und <function>_WRAP_PROPERTY()</function>"

#: C/gtkmm-tutorial-in.xml:8936(para)
msgid "Add methods to wrap parts of the C API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8910(para)
msgid "The macros in this example do the following: <placeholder-1/>"
msgstr "Die Makros in diesem Beispiel bewirken Folgendes: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8943(programlisting)
#, no-wrap
msgid ""
"\n"
"$ cd gtk/src\n"
"$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm\n"
msgstr ""
"\n"
"$ cd gtk/src\n"
"$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm\n"

#: C/gtkmm-tutorial-in.xml:8940(para)
msgid ""
"The .h and .cc files will be generated from the .hg and .ccg files by processing them with <command>gmmproc</command> like so, though this "
"happens automatically when using the above build structure: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8948(para)
msgid ""
"Notice that we provided <command>gmmproc</command> with the path to the .m4 convert files, the path to the .defs file, the name of a .hg file, "
"the source directory, and the destination directory."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8951(para)
msgid ""
"You should avoid including the C header from your C++ header, to avoid polluting the global namespace, and to avoid exporting unnecessary "
"public API. But you will need to include the necessary C headers from your .ccg file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8956(para)
msgid "The macros are explained in more detail in the following sections."
msgstr "Die Makros werden in den folgenden Abschnitten detaillierter beschrieben."

#: C/gtkmm-tutorial-in.xml:8959(title)
msgid "m4 Conversions"
msgstr "m4-Umwandlungen"

#: C/gtkmm-tutorial-in.xml:8966(programlisting)
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')\n"
msgstr ""
"\n"
"_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')\n"

#: C/gtkmm-tutorial-in.xml:8960(para)
msgid ""
"The macros that you use in the .hg and .ccg files often need to know how to convert a C++ type to a C type, or vice-versa. gmmproc takes this "
"information from an .m4 file in your <literal>tools/m4/</literal> directory. This allows it to call a C function in the implementation of your C"
"++ method, passing the appropriate parameters to that C functon. For instance, this tells gmmproc how to convert a GtkTreeView pointer to a "
"Gtk::TreeView pointer: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8971(para)
msgid "<literal>$3</literal> will be replaced by the parameter name when this conversion is used by gmmproc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8978(programlisting)
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)\n"
"_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)\n"
"_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))\n"
msgstr ""
"\n"
"_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)\n"
"_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)\n"
"_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))\n"

#: C/gtkmm-tutorial-in.xml:8975(para)
msgid "Some extra macros make this easier and consistent. Look in gtkmm's .m4 files for examples. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8987(title)
msgid "m4 Initializations"
msgstr "m4-Initialisierungen"

#: C/gtkmm-tutorial-in.xml:8988(para)
msgid ""
"Often when wrapping methods, it is desirable to store the return of the C function in what is called an output parameter. In this case, the C++ "
"method returns <type>void</type> but an output parameter in which to store the value of the C function is included in the argument list of the C"
"++ method. gmmproc allows such functionality, but appropriate initialization macros must be included to tell gmmproc how to initialize the C++ "
"parameter from the return of the C function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9003(programlisting)
#, no-wrap
msgid ""
"\n"
"_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')\n"
msgstr ""
"\n"
"_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')\n"

#: C/gtkmm-tutorial-in.xml:8997(para)
msgid ""
"For example, if there was a C function that returned a <type>GtkWidget*</type> and for some reason, instead of having the C++ method also "
"return the widget, it was desirable to have the C++ method place the widget in a specified output parameter, an initialization macro such as "
"the following would be necessary: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9008(para)
msgid ""
"<literal>$3</literal> will be replaced by the output parameter name of the C++ method and <literal>$4</literal> will be replaced by the return "
"of the C function when this initialization is used by gmmproc. For convenience, <literal>$1</literal> will also be replaced by the C++ type "
"without the ampersand (&amp;) and <literal>$2</literal> will be replaced by the C type."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9019(title)
msgid "Class macros"
msgstr "Klassen-Makros"

#: C/gtkmm-tutorial-in.xml:9020(para)
msgid ""
"The class macro declares the class itself and its relationship with the underlying C type. It generates some internal constructors, the member "
"<varname>gobject_</varname>, typedefs, the <function>gobj()</function> accessors, type registration, and the <function>Glib::wrap()</function> "
"method, among other things."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9025(para)
msgid ""
"Other macros, such as <function>_WRAP_METHOD()</function> and <function>_WRAP_SIGNAL()</function> may only be used after a call to a "
"<function>_CLASS_*</function> macro."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9030(title)
msgid "_CLASS_GOBJECT"
msgstr "_CLASS_GOBJECT"

#: C/gtkmm-tutorial-in.xml:9031(para)
msgid ""
"This macro declares a wrapper for a type that is derived from <classname>GObject</classname>, but whose wrapper is not derived from "
"<classname>Gtk::Object</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9034(function)
msgid "_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9036(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)\n"
msgstr ""
"\n"
"_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)\n"

#: C/gtkmm-tutorial-in.xml:9035(para)
msgid "For instance, from <filename>accelgroup.hg</filename>: <placeholder-1/>"
msgstr "Beispiel aus <filename>accelgroup.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9043(title)
msgid "_CLASS_GTKOBJECT"
msgstr "_CLASS_GTKOBJECT"

#: C/gtkmm-tutorial-in.xml:9044(para)
msgid "This macro declares a wrapper for a type whose wrapper is derived from <classname>Gtk::Object</classname>, such as a widget or dialog."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9046(function)
msgid "_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9048(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)\n"
msgstr ""
"\n"
"_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)\n"

#: C/gtkmm-tutorial-in.xml:9047(para) C/gtkmm-tutorial-in.xml:9386(para) C/gtkmm-tutorial-in.xml:9447(para) C/gtkmm-tutorial-in.xml:9564(para)
msgid "For instance, from <filename>button.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9052(para)
msgid ""
"You will typically use this macro when the class already derives from Gtk::Object. For instance, you will use it when wrapping a GTK+ Widget, "
"because Gtk::Widget derives from Gtk::Object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9053(para)
msgid ""
"You might also derive non-widget classes from Gtk::Object so they can be used without <classname>Glib::RefPtr</classname>. For instance, they "
"could then be instantiated with <function>Gtk::manage()</function> or on the stack as a member variable. This is convenient, but you should use "
"this only when you are sure that true reference-counting is not needed. We consider it useful for widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9057(title)
msgid "_CLASS_BOXEDTYPE"
msgstr "_CLASS_BOXEDTYPE"

#: C/gtkmm-tutorial-in.xml:9058(para)
msgid ""
"This macro declares a wrapper for a non-<classname>GObject</classname> struct, registered with <function>g_boxed_type_register_static()</"
"function>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9061(function)
msgid "_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free function )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9063(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_CLASS_BOXEDTYPE(Color, GdkColor, NONE, gdk_color_copy, gdk_color_free)\n"
msgid ""
"\n"
"_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)\n"
msgstr ""
"\n"
"_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)\n"

#: C/gtkmm-tutorial-in.xml:9062(para)
msgid "For instance, from <classname>Gdk::RGBA</classname>: <placeholder-1/>"
msgstr "Beispiel aus <classname>Gdk::RGBA</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9070(title)
msgid "_CLASS_BOXEDTYPE_STATIC"
msgstr "_CLASS_BOXEDTYPE_STATIC"

#: C/gtkmm-tutorial-in.xml:9071(para)
msgid ""
"This macro declares a wrapper for a simple assignable struct such as <classname>GdkRectangle</classname>. It is similar to "
"<function>_CLASS_BOXEDTYPE</function>, but the C struct is not allocated dynamically."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9075(function)
msgid "_CLASS_BOXEDTYPE_STATIC( C++ class, C class )"
msgstr "_CLASS_BOXEDTYPE_STATIC( C++-Klasse, C-Klasse )"

#: C/gtkmm-tutorial-in.xml:9077(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)\n"
msgstr ""
"\n"
"_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)\n"

#: C/gtkmm-tutorial-in.xml:9076(para)
msgid "For instance, for <classname>Gdk::Rectangle</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9084(title)
msgid "_CLASS_OPAQUE_COPYABLE"
msgstr "_CLASS_OPAQUE_COPYABLE"

#: C/gtkmm-tutorial-in.xml:9085(para)
msgid ""
"This macro declares a wrapper for an opaque struct that has copy and free functions. The new, copy and free functions will be used to "
"instantiate the default constructor, copy constructor and destructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9088(function)
msgid "_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, free function )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9090(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_CLASS_OPAQUE_COPYABLE(StockItem, GtkStockItem, NONE, gtk_stock_item_copy, gtk_stock_item_free)\n"
msgid ""
"\n"
"_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)\n"
msgstr ""
"\n"
"_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)\n"

#: C/gtkmm-tutorial-in.xml:9089(para)
msgid "For instance, from <classname>Glib::Checksum</classname>: <placeholder-1/>"
msgstr "Beispiel aus <classname>Glib::Checksum</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9097(title)
msgid "_CLASS_OPAQUE_REFCOUNTED"
msgstr "_CLASS_OPAQUE_REFCOUNTED"

#: C/gtkmm-tutorial-in.xml:9098(para)
msgid ""
"This macro declares a wrapper for a reference-counted opaque struct. The C++ wrapper cannot be directly instantiated and can only be used with "
"<classname>Glib::RefPtr</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9101(function)
msgid "_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function, unref function )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9103(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)\n"
msgstr ""
"\n"
"_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)\n"

#: C/gtkmm-tutorial-in.xml:9102(para)
msgid "For instance, for <classname>Pango::Coverage</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9110(title)
msgid "_CLASS_GENERIC"
msgstr "_CLASS_GENERIC"

#: C/gtkmm-tutorial-in.xml:9111(para)
msgid "This macro can be used to wrap structs which don't fit into any specialized category."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9113(function)
msgid "_CLASS_GENERIC( C++ class, C class )"
msgstr "_CLASS_GENERIC( C++-Klasse, C-Klasse )"

#: C/gtkmm-tutorial-in.xml:9115(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GENERIC(AttrIter, PangoAttrIterator)\n"
msgstr ""
"\n"
"_CLASS_GENERIC(AttrIter, PangoAttrIterator)\n"

#: C/gtkmm-tutorial-in.xml:9114(para)
msgid "For instance, for <classname>Pango::AttrIter</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9122(title)
msgid "_CLASS_INTERFACE"
msgstr "_CLASS_INTERFACE"

#: C/gtkmm-tutorial-in.xml:9123(para)
msgid "This macro declares a wrapper for a type that is derived from <classname>GTypeInterface</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9126(function)
msgid "_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, Base C++ class (optional), Base C class (optional) )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9129(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)\n"
msgstr ""
"\n"
"_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)\n"

#: C/gtkmm-tutorial-in.xml:9127(para)
msgid "For instance, from <filename>celleditable.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9136(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)\n"
msgstr ""
"\n"
"_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)\n"

#: C/gtkmm-tutorial-in.xml:9133(para)
msgid ""
"Two extra parameters are optional, for the case that the interface derives from another interface, which should be the case when the GInterface "
"has another GInterface as a prerequisite. For instance, from <filename>loadableicon.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9145(title)
msgid "Constructor macros"
msgstr "Konstruktor-Makros"

#: C/gtkmm-tutorial-in.xml:9146(para)
msgid ""
"The <function>_CTOR_DEFAULT()</function> and <function>_WRAP_CTOR()</function> macros add constructors, wrapping the specified "
"<function>*_new()</function> C functions. These macros assume that the C object has properties with the same names as the function parameters, "
"as is usually the case, so that it can supply the parameters directly to a <function>g_object_new()</function> call. These constructors never "
"actually call the <function>*_new()</function> C functions, because gtkmm must actually instantiate derived GTypes, and the <function>*_new()</"
"function> C functions are meant only as convenience functions for C programmers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9161(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "class ActionGroup : public Glib::Object\n"
#| "{\n"
#| "  _CLASS_GOBJECT(ActionGroup, GtkActionGroup, GTK_ACTION_GROUP, Glib::Object, GObject)\n"
#| "\n"
#| "protected:\n"
#| "  _WRAP_CTOR(ActionGroup(const Glib::ustring&amp; name = Glib::ustring()), gtk_action_group_new)\n"
#| "\n"
#| "public:\n"
#| "  _WRAP_CREATE(const Glib::ustring&amp; name = Glib::ustring())\n"
msgid ""
"\n"
"class TextMark : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)\n"
"\n"
"protected:\n"
"  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)\n"
"\n"
"public:\n"
"  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)\n"
msgstr ""
"\n"
"class TextMark : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)\n"
"\n"
"protected:\n"
"  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)\n"
"\n"
"public:\n"
"  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)\n"

#: C/gtkmm-tutorial-in.xml:9156(para)
msgid ""
"When using <function>_CLASS_GOBJECT()</function>, the constructors should be protected (rather than public) and each constructor should have a "
"corresponding <function>_WRAP_CREATE()</function> in the public section. This prevents the class from being instantiated without using a "
"<classname>RefPtr</classname>. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9176(para)
msgid "This macro creates a default constructor with no arguments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9181(title)
msgid "_WRAP_CTOR"
msgstr "_WRAP_CTOR"

#: C/gtkmm-tutorial-in.xml:9182(para)
msgid ""
"This macro creates a constructor with arguments, equivalent to a <function>*_new()</function> C function. It won't actually call the "
"<function>*_new()</function> function, but will simply create an equivalent constructor with the same argument types. It takes a C++ "
"constructor signature, and a C function name."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9192(term) C/gtkmm-tutorial-in.xml:9251(term) C/gtkmm-tutorial-in.xml:9487(term)
msgid "errthrow"
msgstr "errthrow"

#: C/gtkmm-tutorial-in.xml:9194(para)
msgid "This tells gmmproc that the C <function>*_new()</function> has a final GError** parameter which should be ignored."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9189(para)
msgid "It also takes an optional extra argument: <placeholder-1/>"
msgstr "Es akzeptiert optional ein zusätzliches Argument: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9203(title)
msgid "Hand-coding constructors"
msgstr "Handgeschriebene Konstruktoren"

#: C/gtkmm-tutorial-in.xml:9212(programlisting)
#, no-wrap
msgid ""
"\n"
"Button::Button(const Glib::ustring&amp; label, bool mnemonic)\n"
":\n"
"  _CONSTRUCT(\"label\", label.c_str(), \"use_underline\", gboolean(mnemonic))\n"
"{}\n"
msgstr ""
"\n"
"Button::Button(const Glib::ustring&amp; label, bool mnemonic)\n"
":\n"
"  _CONSTRUCT(\"label\", label.c_str(), \"use_underline\", gboolean(mnemonic))\n"
"{}\n"

#: C/gtkmm-tutorial-in.xml:9204(para)
msgid ""
"When a constructor must be partly hand written because, for instance, the <function>*_new()</function> C function's parameters do not "
"correspond directly to object properties, or because the <function>*_new()</function> C function does more than call <function>g_object_new()</"
"function>, the <function>_CONSTRUCT()</function> macro may be used in the .ccg file to save some work. The <function>_CONSTRUCT</function> "
"macro takes a series of property names and values. For instance, from <filename>button.ccg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9224(title)
msgid "Method macros"
msgstr "Methoden-Makros"

#: C/gtkmm-tutorial-in.xml:9227(title)
msgid "_WRAP_METHOD"
msgstr "_WRAP_METHOD"

#: C/gtkmm-tutorial-in.xml:9228(para)
msgid "This macro generates the C++ method to wrap a C function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9229(function)
msgid "_WRAP_METHOD( C++ method signature, C function name)"
msgstr "_WRAP_METHOD( C++ method signature, C function name)"

#: C/gtkmm-tutorial-in.xml:9231(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)\n"
msgstr ""
"\n"
"_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)\n"

#: C/gtkmm-tutorial-in.xml:9230(para)
msgid "For instance, from <filename>entry.hg</filename>: <placeholder-1/>"
msgstr "Beispiel aus <filename>entry.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9235(para)
msgid ""
"The C function (e.g. <function>gtk_entry_set_text</function>) is described more fully in the .defs file, and the <filename>convert*.m4</"
"filename> files contain the necessary conversion from the C++ parameter type to the C parameter type. This macro also generates doxygen "
"documentation comments based on the <filename>*_docs.xml</filename> and <filename>*_docs_override.xml</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9244(term) C/gtkmm-tutorial-in.xml:9423(term) C/gtkmm-tutorial-in.xml:9470(term)
msgid "refreturn"
msgstr "refreturn"

#: C/gtkmm-tutorial-in.xml:9246(para)
msgid "Do an extra <function>reference()</function> on the return value, in case the C function does not provide a reference."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9253(para)
msgid "Use the last GError** parameter of the C function to throw an exception."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9258(term)
msgid "deprecated"
msgstr "deprecated"

#: C/gtkmm-tutorial-in.xml:9260(para)
msgid "Puts the generated code in #ifdef blocks. Text about the deprecation can be specified as an optional parameter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9266(term)
msgid "constversion"
msgstr "constversion"

#: C/gtkmm-tutorial-in.xml:9268(para)
msgid "Just call the non-const version of the same function, instead of generating almost duplicate code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9273(term) C/gtkmm-tutorial-in.xml:9431(term) C/gtkmm-tutorial-in.xml:9509(term) C/gtkmm-tutorial-in.xml:9572(term)
msgid "ifdef"
msgstr "ifdef"

#: C/gtkmm-tutorial-in.xml:9275(para) C/gtkmm-tutorial-in.xml:9433(para) C/gtkmm-tutorial-in.xml:9511(para) C/gtkmm-tutorial-in.xml:9574(para)
msgid "Puts the generated code in #ifdef blocks."
msgstr "Setzt den erzeugten Code in #ifdef-Blöcke."

#: C/gtkmm-tutorial-in.xml:9279(term) C/gtkmm-tutorial-in.xml:9515(term)
msgid "slot_name"
msgstr "slot_name"

#: C/gtkmm-tutorial-in.xml:9281(para) C/gtkmm-tutorial-in.xml:9517(para)
msgid ""
"Specifies the name of the slot parameter of the method, if it has one. This enables <command>gmmproc</command> to generate code to copy the "
"slot and pass the copy on to the C function in its final <literal>gpointer user_data</literal> parameter. The <literal>slot_callback</literal> "
"option must also be used to specify the name of the glue callback function to also pass on to the C function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9291(term) C/gtkmm-tutorial-in.xml:9527(term)
#| msgid "custom_c_callback"
msgid "slot_callback"
msgstr "slot_callback"

#: C/gtkmm-tutorial-in.xml:9293(para) C/gtkmm-tutorial-in.xml:9529(para)
msgid ""
"Used in conjunction with the <literal>slot_name</literal> option to specify the name of the glue callback function that handles extracting the "
"slot and then calling it. The address of this callback is also passed on to the C function that the method wraps."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9301(term) C/gtkmm-tutorial-in.xml:9537(term)
msgid "no_slot_copy"
msgstr "no_slot_copy"

#: C/gtkmm-tutorial-in.xml:9303(para) C/gtkmm-tutorial-in.xml:9539(para)
msgid ""
"Tells <command>gmmproc</command> not to pass a copy of the slot to the C function, if the method has one. Instead the slot itself is passed. "
"The slot parameter name and the glue callback function must have been specified with the <literal>slot_name</literal> and "
"<literal>slot_callbback</literal> options respectively."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9241(para) C/gtkmm-tutorial-in.xml:9394(para) C/gtkmm-tutorial-in.xml:9467(para)
msgid "There are some optional extra arguments: <placeholder-1/>"
msgstr "Es gibt einige zusätzliche optionale Argumente: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9316(para)
msgid ""
"Objects used via <classname>RefPtr</classname>: Pass the <classname>RefPtr</classname> as a const reference. For instance, <code>const Glib::"
"RefPtr&lt;Gtk::FileFilter&gt;&amp; filter</code>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9320(para)
msgid ""
"Const Objects used via <classname>RefPtr</classname>: If the object should not be changed by the function, then make sure that the object is "
"const, even if the <classname>RefPtr</classname> is already const. For instance, <code>const Glib::RefPtr&lt;const Gtk::FileFilter&gt;&amp; "
"filter</code>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9325(para)
msgid ""
"Wrapping <classname>GList*</classname> and <classname>GSList*</classname> parameters: First, you need to discover what objects are contained in "
"the list's data field for each item, usually by reading the documentation for the C function. The list can then be wrapped by a <classname>std::"
"vector</classname> type. For instance, <code>std::vector&lt; Glib::RefPtr&lt;Gdk::Pixbuf&gt; &gt;</code>. You may need to define a Traits type "
"to specify how the C and C++ types should be converted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9342(programlisting)
#, no-wrap
msgid "#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')"
msgstr "#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')"

#: C/gtkmm-tutorial-in.xml:9334(para)
msgid ""
"Wrapping <classname>GList*</classname> and <classname>GSList*</classname> return types: You must discover whether the caller should free the "
"list and whether it should release the items in the list, again by reading the documentation of the C function. With this information you can "
"choose the ownership (none, shallow or deep) for the m4 conversion rule, which you should probably put directly into the .hg file because the "
"ownership depends on the function rather than the type. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9312(para)
msgid ""
"Selecting which C++ types should be used is also important when wrapping C API. Though it's usually obvious what C++ types should be used in "
"the C++ method, here are some hints: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9348(title)
msgid "_WRAP_METHOD_DOCS_ONLY"
msgstr "_WRAP_METHOD_DOCS_ONLY"

#: C/gtkmm-tutorial-in.xml:9349(para)
msgid ""
"This macro is like <function>_WRAP_METHOD()</function>, but it generates only the documentation for a C++ method that wraps a C function. Use "
"this when you must hand-code the method, but you want to use the documentation that would be generated if the method was generated."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9353(function)
msgid "_WRAP_METHOD_DOCS_ONLY(C function name)"
msgstr "_WRAP_METHOD_DOCS_ONLY(C-Funktionsname)"

#: C/gtkmm-tutorial-in.xml:9355(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)\n"
msgstr ""
"\n"
"_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)\n"

#: C/gtkmm-tutorial-in.xml:9354(para)
msgid "For instance, from <filename>container.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9362(title)
msgid "_IGNORE / _IGNORE_SIGNAL"
msgstr "_IGNORE / _IGNORE_SIGNAL"

#: C/gtkmm-tutorial-in.xml:9363(para)
msgid ""
"<command>gmmproc</command> will warn you on stdout about functions and signals that you have forgotten to wrap, helping to ensure that you are "
"wrapping the complete API. But if you don't want to wrap some functions or signals, or if you chose to hand-code some methods then you can use "
"the _IGNORE() or _IGNORE_SIGNAL() macro to make <command>gmmproc</command> stop complaining."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9368(function)
msgid "_IGNORE(C function name 1, C function name2, etc)"
msgstr "_IGNORE(C-Funktionsname 1, C-Funktionsname2, usw.)"

#: C/gtkmm-tutorial-in.xml:9369(function)
msgid "_IGNORE_SIGNAL(C signal name 1, C signal name2, etc)"
msgstr "_IGNORE_SIGNAL(C signal name 1, C signal name2, etc)"

#: C/gtkmm-tutorial-in.xml:9371(programlisting)
#, no-wrap
msgid ""
"\n"
"_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing)\n"
msgstr ""
"\n"
"_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing)\n"

#: C/gtkmm-tutorial-in.xml:9370(para)
msgid "For instance, from <filename>buttonbox.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9378(title)
msgid "_WRAP_SIGNAL"
msgstr "_WRAP_SIGNAL"

#: C/gtkmm-tutorial-in.xml:9379(para)
msgid ""
"This macro generates the C++ libsigc++-style signal to wrap a C GObject signal. It actually generates a public accessor method, such as "
"<function>signal_clicked()</function>, which returns a proxy object. <command>gmmproc</command> uses the .defs file to discover the C parameter "
"types and the .m4 convert files to discover appropriate type conversions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9385(function)
msgid "_WRAP_SIGNAL( C++ signal handler signature, C signal name)"
msgstr "_WRAP_SIGNAL( C++ signal handler signature, C signal name)"

#: C/gtkmm-tutorial-in.xml:9387(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_SIGNAL(void clicked(),\"clicked\")\n"
msgstr ""
"\n"
"_WRAP_SIGNAL(void clicked(),\"clicked\")\n"

#: C/gtkmm-tutorial-in.xml:9391(para)
msgid ""
"Signals usually have function pointers in the GTK struct, with a corresponding enum value and a <function>g_signal_new()</function> in the .c "
"file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9397(term)
msgid "no_default_handler"
msgstr "no_default_handler"

#: C/gtkmm-tutorial-in.xml:9399(para)
msgid ""
"Do not generate an <function>on_something()</function> virtual method to allow easy overriding of the default signal handler. Use this when "
"adding a signal with a default signal handler would break the ABI by increasing the size of the class's virtual function table."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9407(term)
msgid "custom_default_handler"
msgstr "custom_default_handler"

#: C/gtkmm-tutorial-in.xml:9409(para)
msgid ""
"Generate a declaration of the <function>on_something()</function> virtual method in the <filename>.h</filename> file, but do not generate a "
"definition in the <filename>.cc</filename> file. Use this when you must generate the definition by hand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9416(term)
msgid "custom_c_callback"
msgstr "custom_c_callback"

#: C/gtkmm-tutorial-in.xml:9418(para)
msgid "Do not generate a C callback function for the signal. Use this when you must generate the callback function by hand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9425(para)
msgid ""
"Do an extra <function>reference()</function> on the return value of the <function>on_something()</function> virtual method, in case the C "
"function does not provide a reference."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9441(title)
msgid "_WRAP_PROPERTY"
msgstr "_WRAP_PROPERTY"

#: C/gtkmm-tutorial-in.xml:9442(para)
msgid ""
"This macro generates the C++ method to wrap a C GObject property. You must specify the property name and the wanted C++ type for the property. "
"<command>gmmproc</command> uses the .defs file to discover the C type and the .m4 convert files to discover appropriate type conversions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9446(function)
msgid "_WRAP_PROPERTY(C property name, C++ type)"
msgstr "_WRAP_PROPERTY(C-Eigenschaftsname, C++-Typ)"

#: C/gtkmm-tutorial-in.xml:9448(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_PROPERTY(\"label\", Glib::ustring)\n"
msgstr ""
"\n"
"_WRAP_PROPERTY(\"label\", Glib::ustring)\n"

#: C/gtkmm-tutorial-in.xml:9455(title)
msgid "_WRAP_VFUNC"
msgstr "_WRAP_VFUNC"

#: C/gtkmm-tutorial-in.xml:9456(para)
msgid "This macro generates the C++ method to wrap a virtual C function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9457(function)
msgid "_WRAP_VFUNC( C++ method signature, C function name)"
msgstr "_WRAP_VFUNC( C++ method signature, C function name)"

#: C/gtkmm-tutorial-in.xml:9459(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)\n"
msgstr ""
"\n"
"_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)\n"

#: C/gtkmm-tutorial-in.xml:9458(para)
msgid "For instance, from <filename>widget.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9463(para)
msgid ""
"The C function (e.g. <function>get_request_mode</function>) is described more fully in the <filename>*_vfuncs.defs</filename> file, and the "
"<filename>convert*.m4</filename> files contain the necessary conversion from the C++ parameter type to the C parameter type."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9472(para)
msgid ""
"Do an extra <function>reference()</function> on the return value of the <function>something_vfunc()</function> function, in case the virtual C "
"function does not provide a reference."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9478(term)
msgid "refreturn_ctype"
msgstr "refreturn_ctype"

#: C/gtkmm-tutorial-in.xml:9480(para)
msgid ""
"Do an extra <function>reference()</function> on the return value of an overridden <function>something_vfunc()</function> function in the C "
"callback function, in case the calling C function expects it to provide a reference."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9489(para)
msgid "Use the last GError** parameter of the C virtual function (if there is one) to throw an exception."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9494(term)
msgid "custom_vfunc"
msgstr "custom_vfunc"

#: C/gtkmm-tutorial-in.xml:9496(para)
msgid "Do not generate a definition of the vfunc in the <filename>.cc</filename> file. Use this when you must generate the vfunc by hand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9502(term)
msgid "custom_vfunc_callback"
msgstr "custom_vfunc_callback"

#: C/gtkmm-tutorial-in.xml:9504(para)
msgid "Do not generate a C callback function for the vfunc. Use this when you must generate the callback function by hand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9548(para)
msgid ""
"A rule to which there may be exceptions: If the virtual C function returns a pointer to an object derived from <classname>GObject</classname>, "
"i.e. a reference-counted object, then the virtual C++ function shall return a <classname>Glib::RefPtr&lt;&gt;</classname> object. One of the "
"extra arguments <parameter>refreturn</parameter> or <parameter>refreturn_ctype</parameter> is required."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9559(title)
msgid "Other macros"
msgstr "Weitere Makros"

#: C/gtkmm-tutorial-in.xml:9561(title)
msgid "_IMPLEMENTS_INTERFACE"
msgstr "_IMPLEMENTS_INTERFACE"

#: C/gtkmm-tutorial-in.xml:9562(para)
msgid "This macro generates initialization code for the interface."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9563(function)
msgid "_IMPLEMENTS_INTERFACE(C++ interface name)"
msgstr "_IMPLEMENTS_INTERFACE(C++ interface name)"

#: C/gtkmm-tutorial-in.xml:9565(programlisting)
#, no-wrap
msgid ""
"\n"
"_IMPLEMENTS_INTERFACE(Activatable)\n"
msgstr ""
"\n"
"_IMPLEMENTS_INTERFACE(Activatable)\n"

#: C/gtkmm-tutorial-in.xml:9569(para)
msgid "There is one optional extra argument: <placeholder-1/>"
msgstr "Es gibt nur ein optionales zusätzliches Argument: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9582(title)
msgid "_WRAP_ENUM"
msgstr "_WRAP_ENUM"

#: C/gtkmm-tutorial-in.xml:9583(para)
msgid "This macro generates a C++ enum to wrap a C enum. You must specify the desired C++ name and the name of the underlying C enum."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9586(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_WRAP_ENUM(WindowType, GdkWindowType)\n"
msgid ""
"\n"
"_WRAP_ENUM(WindowType, GtkWindowType)\n"
msgstr ""
"\n"
"_WRAP_ENUM(WindowType, GtkWindowType)\n"

#: C/gtkmm-tutorial-in.xml:9585(para)
msgid "For instance, from <filename>enums.hg</filename>: <placeholder-1/>"
msgstr "Beispiel aus <filename>enums.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9590(para)
msgid ""
"If the enum is not a <classname>GType</classname>, you must pass a third parameter NO_GTYPE. This is the case when there is no "
"<function>*_get_type()</function> function for the C enum, but be careful that you don't just need to include an extra header for that "
"function. You should also file a bug against the C API, because all enums should be registered as GTypes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9595(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)\n"
msgstr ""
"\n"
"_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)\n"

#: C/gtkmm-tutorial-in.xml:9594(para)
msgid "For example, from <filename>icontheme.hg</filename>: <placeholder-1/>"
msgstr "Beispiel aus <filename>icontheme.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9602(title)
#| msgid "_WRAP_METHOD_DOCS_ONLY"
msgid "_WRAP_ENUM_DOCS_ONLY"
msgstr "_WRAP_ENUM_DOCS_ONLY"

#: C/gtkmm-tutorial-in.xml:9603(para)
msgid ""
"This macro just generates a Doxygen documentationn block for the enum. This is useful for enums that can't be wrapped with "
"<function>_WRAP_ENUM()</function> because they are complexly defined (maybe using C macros) but including the generated enum documentation is "
"still desired. It is used with the same syntax as <function>_WRAP_ENUM()</function> and also process the same options (though NO_GTYPE is just "
"ignored because it makes no difference when just generating the enum's documentation)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9615(title)
msgid "_WRAP_GERROR"
msgstr "_WRAP_GERROR"

#: C/gtkmm-tutorial-in.xml:9616(para)
msgid ""
"This macro generates a C++ exception class, derived from Glib::Error, with a Code enum and a code() method. You must specify the desired C++ "
"name, the name of the corresponding C enum, and the prefix for the C enum values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9619(para)
msgid "This exception can then be thrown by methods which are generated from _WRAP_METHOD() with the errthrow option."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9621(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)\n"
msgstr ""
"\n"
"_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)\n"

#: C/gtkmm-tutorial-in.xml:9620(para)
msgid "For instance, from <filename>pixbuf.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9628(title)
msgid "_MEMBER_GET / _MEMBER_SET"
msgstr "_MEMBER_GET / _MEMBER_SET"

#: C/gtkmm-tutorial-in.xml:9629(para)
msgid ""
"Use these macros if you're wrapping a simple struct or boxed type that provides direct access to its data members, to create getters and "
"setters for the data members."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9633(function)
msgid "_MEMBER_GET(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_GET(C++-Name, C-Name, C++-Typ, C-Typ)"

#: C/gtkmm-tutorial-in.xml:9634(function)
msgid "_MEMBER_SET(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_SET(C++-Name, C-Name, C++-Typ, C-Typ)"

#: C/gtkmm-tutorial-in.xml:9637(programlisting)
#, no-wrap
msgid "_MEMBER_GET(x, x, int, int)"
msgstr "_MEMBER_GET(x, x, int, int)"

#: C/gtkmm-tutorial-in.xml:9635(para)
msgid "For example, in <filename>rectangle.hg</filename>: <placeholder-1/>"
msgstr "Beispielsweise in <filename>rectangle.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9641(title)
msgid "_MEMBER_GET_PTR / _MEMBER_SET_PTR"
msgstr "_MEMBER_GET_PTR / _MEMBER_SET_PTR"

#: C/gtkmm-tutorial-in.xml:9642(para)
msgid ""
"Use these macros to automatically provide getters and setters for a data member that is a pointer type. For the getter function, it will create "
"two methods, one const and one non-const."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9647(function)
msgid "_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_GET_PTR(C++-Name, C-Name, C++-Typ, C-Typ)"

#: C/gtkmm-tutorial-in.xml:9648(function)
msgid "_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9650(programlisting)
#, no-wrap
msgid ""
"\n"
"// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)\n"
"// It's just a comment. It's difficult to find a real-world example.\n"
msgstr ""
"\n"
"// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)\n"
"// It's just a comment. It's difficult to find a real-world example.\n"

#: C/gtkmm-tutorial-in.xml:9649(para)
msgid "For example, for <classname>Pango::Analysis</classname> in <filename>item.hg</filename>: <placeholder-1/>"
msgstr "Beispiel für <classname>Pango::Analysis</classname> in <filename>item.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9657(title)
msgid "_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT"
msgstr "_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT"

#: C/gtkmm-tutorial-in.xml:9658(para)
msgid ""
"Use these macros to provide getters and setters for a data member that is a <classname>GObject</classname> type that must be referenced before "
"being returned."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9663(function)
msgid "_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_GET_GOBJECT(C++-Name, C-Name, C++-Typ, C-Typ)"

#: C/gtkmm-tutorial-in.xml:9664(function)
msgid "_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9666(programlisting)
#, no-wrap
msgid ""
"\n"
"_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)\n"
msgstr ""
"\n"
"_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)\n"

#: C/gtkmm-tutorial-in.xml:9665(para)
msgid "For example, in Pangomm, <filename>layoutline.hg</filename>: <placeholder-1/>"
msgstr "Beispiel in Pangomm für <filename>layoutline.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9674(title)
msgid "gmmproc Parameter Processing"
msgstr "gmmproc-Parameterverarbeitung"

#: C/gtkmm-tutorial-in.xml:9675(para)
msgid ""
"<command>gmmproc</command> allows processing the parameters in a method signature for the macros that process method signatures (like "
"<function>_WRAP_METHOD()</function>, <function>_WRAP_CTOR()</function> and <function>_WRAP_CREATE()</function>) in a variety of ways:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9682(title)
msgid "Parameter Reordering"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9689(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device, GdkEventMask events);\n"
msgid ""
"\n"
"        void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,\n"
"        GdkEventMask events);\n"
"      "
msgstr ""
"\n"
"        void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,\n"
"        GdkEventMask events);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9696(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_WRAP_METHOD(void set_device_events(Gdk::EventMask events{events}, const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}), gtk_widget_set_device_events)\n"
msgid ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},\n"
"        const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),\n"
"        gtk_widget_set_device_events)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},\n"
"        const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),\n"
"        gtk_widget_set_device_events)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9706(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}), gtk_widget_set_device_events)\n"
msgid ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const\n"
"        Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),\n"
"        gtk_widget_set_device_events)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const\n"
"        Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),\n"
"        gtk_widget_set_device_events)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9683(para)
msgid ""
"For all the macros that process method signatures, it is possible to specify a different order for the C++ parameters than the existing order "
"in the C function, virtual function or signal. For example, say that the following C function were being wrapped as a C++ method for the "
"<classname>Gtk::Widget</classname> class: <placeholder-1/> However, changing the order of the C++ method's two parameters is necessary. "
"Something like the following would wrap the function as a C++ method with a different order for the two parameters: <placeholder-2/> The "
"<literal>{c_param_name}</literal> following the method parameter names tells <command>gmmproc</command> to map the C++ parameter to the "
"specified C parameter within the <literal>{}</literal>. Since the C++ parameter names correspond to the C ones, the above could be re-written "
"as: <placeholder-3/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9713(para)
msgid ""
"Please note that when reordering parameters for a <function>_WRAP_SIGNAL()</function> method signature, the C parameter names would always be "
"<literal>p0</literal>, <literal>p1</literal>, etc. because the <filename>generate_extra_defs</filename> utility uses those parameter names no "
"matter what the C API's parameter names may be. It's how the utility is written presently."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9725(title)
msgid "Optional Parameter Processing"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9734(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar* label);\n"
msgid ""
"\n"
"        GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar*\n"
"        label);\n"
"      "
msgstr ""
"\n"
"        GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar*\n"
"        label);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9744(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp; label{?}), gtk_tool_button_new)\n"
msgid ""
"\n"
"        _WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp;\n"
"        label{?}), gtk_tool_button_new)\n"
"      "
msgstr ""
"\n"
"        _WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp;\n"
"        label{?}), gtk_tool_button_new)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9726(para)
msgid ""
"For all macros processing method signatures except <function>_WRAP_SIGNAL()</function> and <function>_WRAP_VFUNC()</function> it is also "
"possible to make the parameters optional so that extra C++ methods are generated without the specified optional parameter. For example, say "
"that the following <function>*_new()</function> function were being wrapped as a constructor in the <classname>Gtk::ToolButton</classname> "
"class: <placeholder-1/> Also, say that the C API allowed NULL for the function's <parameter>label</parameter> parameter so that that parameter "
"is optional. It would be possible to have <command>gmmproc</command> generate the original constructor (with all the parameters) along with an "
"additional constructor without that optional parameter by appending a <literal>{?}</literal> to the parameter name like so: <placeholder-2/> In "
"this case, two constructors would be generated: One with the optional parameter and one without it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9754(title)
msgid "Output Parameter Processing"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9764(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);\n"
msgid ""
"\n"
"        GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);\n"
"      "
msgstr ""
"\n"
"        GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9770(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT}) const, gtk_widget_get_request_mode)\n"
msgid ""
"\n"
"        _WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT})\n"
"        const, gtk_widget_get_request_mode)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT})\n"
"        const, gtk_widget_get_request_mode)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9779(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = (SizeRequestMode)($4)')\n"
msgid ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        (SizeRequestMode)($4)')\n"
"      "
msgstr ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        (SizeRequestMode)($4)')\n"
"      "

#: C/gtkmm-tutorial-in.xml:9784(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = ($1)($4)')\n"
msgid ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        ($1)($4)')\n"
"      "
msgstr ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        ($1)($4)')\n"
"      "

#: C/gtkmm-tutorial-in.xml:9755(para)
msgid ""
"With <function>_WRAP_METHOD()</function> it is also possible for the return of the wrapped C function (if it has one) to be placed in an output "
"parameter of the C++ method instead of having the C++ method also return a value like the C function does. To do that, simply include the "
"output parameter in the C++ method parameter list appending a <literal>{OUT}</literal> to the output parameter name. For example, if "
"<function>gtk_widget_get_request_mode()</function> is declared as the following: <placeholder-1/> And having the C++ method set an output "
"parameter is desired instead of returning a <type>SizeRequestMode</type>, something like the following could be used: <placeholder-2/> The "
"<literal>{OUT}</literal> appended to the name of the <parameter>mode</parameter> output parameter tells <command>gmmproc</command> to place the "
"return of the C function in that output parameter. In this case, however, a necessary initialization macro like the following would also have "
"to be specified: <placeholder-3/> Which could also be written as: <placeholder-4/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9795(programlisting)
#, no-wrap
msgid ""
"\n"
"        gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,\n"
"        GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);\n"
"      "
msgstr ""
"\n"
"        gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,\n"
"        GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9802(programlisting)
#, no-wrap
msgid ""
"\n"
"        _WRAP_METHOD(bool get_cell_rect(const TreeModel::Path&amp; path, const\n"
"        CellRenderer&amp; cell, Gdk::Rectangle&amp; rect{&gt;&gt;}) const,\n"
"        gtk_icon_view_get_cell_rect)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(bool get_cell_rect(const TreeModel::Path&amp; path, const\n"
"        CellRenderer&amp; cell, Gdk::Rectangle&amp; rect{&gt;&gt;}) const,\n"
"        gtk_icon_view_get_cell_rect)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9817(programlisting)
#, no-wrap
#| msgid ""
#| "\n"
#| "_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')\n"
msgid ""
"\n"
"        _INITIALIZATION(`Gdk::Rectangle&amp;',`GdkRectangle', `$3 =\n"
"        Glib::wrap(&amp;($4))')\n"
"      "
msgstr ""
"\n"
"        _INITIALIZATION(`Gdk::Rectangle&amp;',`GdkRectangle', `$3 =\n"
"        Glib::wrap(&amp;($4))')\n"
"      "

#: C/gtkmm-tutorial-in.xml:9789(para)
msgid ""
"<function>_WRAP_METHOD()</function> also supports setting C++ output parameters from C output parameters if the C function being wrapped has "
"any. Suppose, for example, that we want to wrap the following C function that returns a value in its C output parameter <parameter>rect</"
"parameter>: <placeholder-1/> To have <command>gmmproc</command> place the value returned in the C++ <parameter>rect</parameter> output "
"parameter, something like the following <function>_WRAP_METHOD()</function> directive could be used: <placeholder-2/> The <literal>{&gt;&gt;}</"
"literal> following the <parameter>rect</parameter> parameter name indicates that the C++ output parameter should be set from the value returned "
"in the C parameter from the C function. <command>gmmproc</command> will generate a declaration of a temporary variable in which to store the "
"value of the C output parameter and a statement that sets the C++ output parameter from the temporary variable. In this case it may be "
"necessary to have an <function>_INITIALIZATION()</function> describing how to set a <classname>Gdk::Rectangle&amp;</classname> from a "
"<classname>GdkRectangle*</classname> such as the following: <placeholder-3/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9827(title)
msgid "Basic Types"
msgstr "Grundlegende Typen"

#: C/gtkmm-tutorial-in.xml:9828(para)
msgid ""
"Some of the basic types that are used in C APIs have better alternatives in C++. For example, there's no need for a <type>gboolean</type> type "
"since C++ has <type>bool</type>. The following list shows some commonly-used types in C APIs and what you might convert them to in a C++ "
"wrapper library."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9833(title)
msgid "Basic Type equivalents"
msgstr "Grundlegende Typ-Äquivalente"

#: C/gtkmm-tutorial-in.xml:9835(segtitle)
msgid "C type"
msgstr "C-Typ"

#: C/gtkmm-tutorial-in.xml:9836(segtitle)
msgid "C++ type"
msgstr "C++-Typ"

#: C/gtkmm-tutorial-in.xml:9837(type)
msgid "gboolean"
msgstr "gboolean"

#: C/gtkmm-tutorial-in.xml:9837(type)
msgid "bool"
msgstr "bool"

#: C/gtkmm-tutorial-in.xml:9838(type)
msgid "gint"
msgstr "gint"

#: C/gtkmm-tutorial-in.xml:9838(type)
msgid "int"
msgstr "int"

#: C/gtkmm-tutorial-in.xml:9839(type)
msgid "guint"
msgstr "guint"

#: C/gtkmm-tutorial-in.xml:9840(type)
msgid "gdouble"
msgstr "gdouble"

#: C/gtkmm-tutorial-in.xml:9840(type)
msgid "double"
msgstr "double"

#: C/gtkmm-tutorial-in.xml:9841(type)
msgid "gunichar"
msgstr "gunichar"

#: C/gtkmm-tutorial-in.xml:9842(type)
msgid "gchar*"
msgstr "gchar*"

#: C/gtkmm-tutorial-in.xml:9842(classname)
msgid "std::string"
msgstr "std::string"

#: C/gtkmm-tutorial-in.xml:9842(seg)
msgid "<placeholder-1/> (or <placeholder-2/> for filenames)"
msgstr "<placeholder-1/> (oder <placeholder-2/> für Dateinamen)"

#: C/gtkmm-tutorial-in.xml:9849(title)
msgid "Hand-coded source files"
msgstr "Handgeschriebene Quelldateien"

#: C/gtkmm-tutorial-in.xml:9850(para)
msgid ""
"You might want to include additional source files that will not be generated by <command>gmmproc</command> from <filename>.hg</filename> and "
"<filename>.ccg</filename> files. You can simply place these in your <filename>libsomething/libsomethingmm</filename> directory and mention them "
"in the <filename>Makefile.am</filename> in the <varname>files_extra_h</varname> and <varname>files_extra_cc</varname> variables."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9860(title)
msgid "Initialization"
msgstr "Initialisierung"

#: C/gtkmm-tutorial-in.xml:9869(programlisting)
#, no-wrap
msgid ""
"\n"
"void init()\n"
"{\n"
"  Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.\n"
"  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.\n"
"}\n"
msgstr ""
"\n"
"void init()\n"
"{\n"
"  Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.\n"
"  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:9861(para)
msgid ""
"Your library must be initialized before it can be used, to register the new types that it makes available. Also, the C library that you are "
"wrapping might have its own initialization function that you should call. You can do this in an <function>init()</function> function that you "
"can place in hand-coded <filename>init.h</filename> and <filename>init.cc</filename> files. This function should initialize your dependencies "
"(such as the C function, and <application>gtkmm</application>) and call your generated <function>wrap_init()</function> function. For instance: "
"<placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9877(para)
msgid ""
"The implementation of the <function>wrap_init()</function> method in <filename>wrap_init.cc</filename> is generated by "
"<filename>generate_wrap_init.pl</filename>, but the declaration in <filename>wrap_init.h</filename> is hand-coded, so you will need to adjust "
"<filename>wrap_init.h</filename> so that the <function>wrap_init()</function> function appears in the correct C++ namespace."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9886(title)
msgid "Problems in the C API."
msgstr "Probleme in der C-API."

#: C/gtkmm-tutorial-in.xml:9887(para)
msgid ""
"You are likely to encounter some problems in the library that you are wrapping, particularly if it is a new project. Here are some common "
"problems, with solutions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9889(title)
msgid "Unable to predeclare structs"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9891(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _ExampleWidget ExampleWidget;\n"
"\n"
"struct _ExampleWidget\n"
"{\n"
"  ...\n"
"};\n"
msgstr ""
"\n"
"typedef struct _ExampleWidget ExampleWidget;\n"
"\n"
"struct _ExampleWidget\n"
"{\n"
"  ...\n"
"};\n"

#: C/gtkmm-tutorial-in.xml:9890(para)
msgid "By convention, structs are declared in glib/GTK+-style headers like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9900(para)
msgid ""
"The extra typedef allows the struct to be used in a header without including its full definition, simply by predeclaring it, by repeating that "
"typedef. This means that you don't have to include the C library's header in your C++ header, thus keeping it out of your public API. "
"<command>gmmproc</command> assumes that this technique was used, so you will see compiler errors if that is not the case."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9907(programlisting)
#, no-wrap
msgid ""
"\n"
"example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'\n"
"../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here\n"
"make[4]: *** [example-widget.lo] Error 1\n"
msgstr ""
"\n"
"example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'\n"
"../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here\n"
"make[4]: *** [example-widget.lo] Error 1\n"

#: C/gtkmm-tutorial-in.xml:9913(programlisting)
#, no-wrap
msgid ""
"\n"
"example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol\n"
"../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'\n"
msgstr ""
"\n"
"example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol\n"
"../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'\n"

#: C/gtkmm-tutorial-in.xml:9905(para)
msgid "This compiler error might look like this: <placeholder-1/> or this: <placeholder-2/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9918(para)
msgid "This is easy to correct in the C library, so do send a patch to the relevant maintainer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9922(title)
msgid "Lack of properties"
msgstr "Fehlende Eigenschaften"

#: C/gtkmm-tutorial-in.xml:9929(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        return g_object_new (EXAMPLE_TYPE_WIDGET, \"something\", something, \"thing\", thing, NULL);\n"
"}\n"
msgstr ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        return g_object_new (EXAMPLE_TYPE_WIDGET, \"something\", something, \"thing\", thing, NULL);\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:9923(para)
msgid ""
"By convention, glib/GTK+-style objects have <function>*_new()</function> functions, such as <function>example_widget_new()</function> that do "
"nothing more than call <function>g_object_new()</function> and return the result. The input parameters are supplied to "
"<function>g_object_new()</function> along with the names of the properties for which they are values. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9936(para)
msgid ""
"This allows language bindings to implement their own equivalents (such as C++ constructors), without using the <function>*_new()</function> "
"function. This is often necessary so that they can actually instantiate a derived GType, to add their own hooks for signal handlers and vfuncs."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9940(para)
msgid ""
"At the least, the <function>_new()</function> function should not use any private API (functions that are only in a .c file). Even when there "
"are no functions, we can sometimes reimplement 2 or 3 lines of code in a <function>_new()</function> function as long as those lines of code "
"use API that is available to us."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9948(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        ExampleWidget* widget;\n"
"        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);\n"
"        example_widget_construct(widget, \"something\", something, \"thing\", thing);\n"
"}\n"
"\n"
"void example_widget_construct(ExampleWidget* widget, int something, const char* thing)\n"
"{\n"
"        //Do stuff that uses private API:\n"
"        widget-&gt;priv-&gt;thing = thing;\n"
"        do_something(something);\n"
"}\n"
msgstr ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        ExampleWidget* widget;\n"
"        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);\n"
"        example_widget_construct(widget, \"something\", something, \"thing\", thing);\n"
"}\n"
"\n"
"void example_widget_construct(ExampleWidget* widget, int something, const char* thing)\n"
"{\n"
"        //Do stuff that uses private API:\n"
"        widget-&gt;priv-&gt;thing = thing;\n"
"        do_something(something);\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:9945(para)
msgid ""
"Another workaround is to add a <function>*_construct()</function> function that the C++ constructor can call after instantiating its own type. "
"For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:9964(para)
msgid ""
"Adding properties, and ensuring that they interact properly with each other, is relatively difficult to correct in the C library, but it is "
"possible, so do file a bug and try to send a patch to the relevant maintainer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9972(title)
msgid "Documentation"
msgstr "Dokumentation"

#: C/gtkmm-tutorial-in.xml:9973(para)
msgid ""
"In general, gtkmm-style projects use Doxygen, which reads specially formatted C++ comments and generates HTML documentation. You may write "
"these doxygen comments directly in the header files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9976(title)
msgid "Reusing C documentation"
msgstr "Die C-Dokumentation wiederverwenden"

#: C/gtkmm-tutorial-in.xml:9977(para)
msgid ""
"You might wish to reuse documentation that exists for the C library that you are wrapping. GTK-style C libraries typically use gtk-doc and "
"therefore have source code comments formatted for gtk-doc and some extra documentation in .sgml and .xml files. The docextract_to_xml.py "
"script, from glibmm's <filename>tools/defs_gen</filename> directory, can read these files and generate an .xml file that <command>gmmproc</"
"command> can use to generate doxygen comments. <command>gmmproc</command> will even try to transform the documentation to make it more "
"appropriate for a C++ API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9987(programlisting)
#, no-wrap
#| msgid "./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ -s ~/checkout/gnome/gtk+/docs/reference/gtk/ &gt; gtk_docs.xml\n"
msgid "./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ &gt; gtk_docs.xml\n"
msgstr "./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ &gt; gtk_docs.xml\n"

#: C/gtkmm-tutorial-in.xml:9990(para)
msgid ""
"Because this automatic transformation is not always appropriate, you might want to provide hand-written text for a particular method. You can "
"do this by copying the XML node for the function from your <filename>something_docs.xml</filename> file to the "
"<filename>something_docs_override.xml</filename> file and changing the contents."
msgstr ""

#: C/gtkmm-tutorial-in.xml:9999(title)
msgid "Documentation build structure"
msgstr "Struktur zur Dokumentationserstellung"

#: C/gtkmm-tutorial-in.xml:10000(para)
msgid ""
"If you copied the skeleton source tree in mm-common and substituted the placeholder text, then you will already have suitable "
"<filename>Makefile.am</filename> and <filename>Doxyfile.in</filename> files. With the mm-common build setup, the list of Doxygen input files is "
"not defined in the Doxygen configuration file, but passed along from <command>make</command> to the standard input of <command>doxygen</"
"command>. The input file list is defined by the <varname>doc_input</varname> variable in the <filename>Makefile.am</filename> file."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: C/gtkmm-tutorial-in.xml:0(None)
msgid "translator-credits"
msgstr "Mario Blättermann <mario.blaettermann@gmail.com>, 2010-2012"
