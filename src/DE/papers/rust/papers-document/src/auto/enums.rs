// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// from ../pps-girs
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsAnnotationTextIcon")]
pub enum AnnotationTextIcon {
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_NOTE")]
    Note,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_COMMENT")]
    Comment,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_KEY")]
    Key,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_HELP")]
    Help,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_NEW_PARAGRAPH")]
    NewParagraph,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_PARAGRAPH")]
    Paragraph,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_INSERT")]
    Insert,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_CROSS")]
    Cross,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_CIRCLE")]
    Circle,
    #[doc(alias = "PPS_ANNOTATION_TEXT_ICON_UNKNOWN")]
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AnnotationTextIcon {
    type GlibType = ffi::PpsAnnotationTextIcon;

    #[inline]
    fn into_glib(self) -> ffi::PpsAnnotationTextIcon {
        match self {
            Self::Note => ffi::PPS_ANNOTATION_TEXT_ICON_NOTE,
            Self::Comment => ffi::PPS_ANNOTATION_TEXT_ICON_COMMENT,
            Self::Key => ffi::PPS_ANNOTATION_TEXT_ICON_KEY,
            Self::Help => ffi::PPS_ANNOTATION_TEXT_ICON_HELP,
            Self::NewParagraph => ffi::PPS_ANNOTATION_TEXT_ICON_NEW_PARAGRAPH,
            Self::Paragraph => ffi::PPS_ANNOTATION_TEXT_ICON_PARAGRAPH,
            Self::Insert => ffi::PPS_ANNOTATION_TEXT_ICON_INSERT,
            Self::Cross => ffi::PPS_ANNOTATION_TEXT_ICON_CROSS,
            Self::Circle => ffi::PPS_ANNOTATION_TEXT_ICON_CIRCLE,
            Self::Unknown => ffi::PPS_ANNOTATION_TEXT_ICON_UNKNOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsAnnotationTextIcon> for AnnotationTextIcon {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsAnnotationTextIcon) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_ANNOTATION_TEXT_ICON_NOTE => Self::Note,
            ffi::PPS_ANNOTATION_TEXT_ICON_COMMENT => Self::Comment,
            ffi::PPS_ANNOTATION_TEXT_ICON_KEY => Self::Key,
            ffi::PPS_ANNOTATION_TEXT_ICON_HELP => Self::Help,
            ffi::PPS_ANNOTATION_TEXT_ICON_NEW_PARAGRAPH => Self::NewParagraph,
            ffi::PPS_ANNOTATION_TEXT_ICON_PARAGRAPH => Self::Paragraph,
            ffi::PPS_ANNOTATION_TEXT_ICON_INSERT => Self::Insert,
            ffi::PPS_ANNOTATION_TEXT_ICON_CROSS => Self::Cross,
            ffi::PPS_ANNOTATION_TEXT_ICON_CIRCLE => Self::Circle,
            ffi::PPS_ANNOTATION_TEXT_ICON_UNKNOWN => Self::Unknown,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AnnotationTextIcon {
    #[inline]
    #[doc(alias = "pps_annotation_text_icon_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_annotation_text_icon_get_type()) }
    }
}

impl glib::HasParamSpec for AnnotationTextIcon {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AnnotationTextIcon {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AnnotationTextIcon {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AnnotationTextIcon {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AnnotationTextIcon> for glib::Value {
    #[inline]
    fn from(v: AnnotationTextIcon) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsAnnotationTextMarkupType")]
pub enum AnnotationTextMarkupType {
    #[doc(alias = "PPS_ANNOTATION_TEXT_MARKUP_HIGHLIGHT")]
    Highlight,
    #[doc(alias = "PPS_ANNOTATION_TEXT_MARKUP_STRIKE_OUT")]
    StrikeOut,
    #[doc(alias = "PPS_ANNOTATION_TEXT_MARKUP_UNDERLINE")]
    Underline,
    #[doc(alias = "PPS_ANNOTATION_TEXT_MARKUP_SQUIGGLY")]
    Squiggly,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AnnotationTextMarkupType {
    type GlibType = ffi::PpsAnnotationTextMarkupType;

    #[inline]
    fn into_glib(self) -> ffi::PpsAnnotationTextMarkupType {
        match self {
            Self::Highlight => ffi::PPS_ANNOTATION_TEXT_MARKUP_HIGHLIGHT,
            Self::StrikeOut => ffi::PPS_ANNOTATION_TEXT_MARKUP_STRIKE_OUT,
            Self::Underline => ffi::PPS_ANNOTATION_TEXT_MARKUP_UNDERLINE,
            Self::Squiggly => ffi::PPS_ANNOTATION_TEXT_MARKUP_SQUIGGLY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsAnnotationTextMarkupType> for AnnotationTextMarkupType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsAnnotationTextMarkupType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_ANNOTATION_TEXT_MARKUP_HIGHLIGHT => Self::Highlight,
            ffi::PPS_ANNOTATION_TEXT_MARKUP_STRIKE_OUT => Self::StrikeOut,
            ffi::PPS_ANNOTATION_TEXT_MARKUP_UNDERLINE => Self::Underline,
            ffi::PPS_ANNOTATION_TEXT_MARKUP_SQUIGGLY => Self::Squiggly,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AnnotationTextMarkupType {
    #[inline]
    #[doc(alias = "pps_annotation_text_markup_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_annotation_text_markup_type_get_type()) }
    }
}

impl glib::HasParamSpec for AnnotationTextMarkupType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AnnotationTextMarkupType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AnnotationTextMarkupType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AnnotationTextMarkupType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AnnotationTextMarkupType> for glib::Value {
    #[inline]
    fn from(v: AnnotationTextMarkupType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsAnnotationType")]
pub enum AnnotationType {
    #[doc(alias = "PPS_ANNOTATION_TYPE_UNKNOWN")]
    Unknown,
    #[doc(alias = "PPS_ANNOTATION_TYPE_TEXT")]
    Text,
    #[doc(alias = "PPS_ANNOTATION_TYPE_FREE_TEXT")]
    FreeText,
    #[doc(alias = "PPS_ANNOTATION_TYPE_ATTACHMENT")]
    Attachment,
    #[doc(alias = "PPS_ANNOTATION_TYPE_TEXT_MARKUP")]
    TextMarkup,
    #[doc(alias = "PPS_ANNOTATION_TYPE_STAMP")]
    Stamp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AnnotationType {
    type GlibType = ffi::PpsAnnotationType;

    #[inline]
    fn into_glib(self) -> ffi::PpsAnnotationType {
        match self {
            Self::Unknown => ffi::PPS_ANNOTATION_TYPE_UNKNOWN,
            Self::Text => ffi::PPS_ANNOTATION_TYPE_TEXT,
            Self::FreeText => ffi::PPS_ANNOTATION_TYPE_FREE_TEXT,
            Self::Attachment => ffi::PPS_ANNOTATION_TYPE_ATTACHMENT,
            Self::TextMarkup => ffi::PPS_ANNOTATION_TYPE_TEXT_MARKUP,
            Self::Stamp => ffi::PPS_ANNOTATION_TYPE_STAMP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsAnnotationType> for AnnotationType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsAnnotationType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_ANNOTATION_TYPE_UNKNOWN => Self::Unknown,
            ffi::PPS_ANNOTATION_TYPE_TEXT => Self::Text,
            ffi::PPS_ANNOTATION_TYPE_FREE_TEXT => Self::FreeText,
            ffi::PPS_ANNOTATION_TYPE_ATTACHMENT => Self::Attachment,
            ffi::PPS_ANNOTATION_TYPE_TEXT_MARKUP => Self::TextMarkup,
            ffi::PPS_ANNOTATION_TYPE_STAMP => Self::Stamp,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AnnotationType {
    #[inline]
    #[doc(alias = "pps_annotation_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_annotation_type_get_type()) }
    }
}

impl glib::HasParamSpec for AnnotationType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AnnotationType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AnnotationType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AnnotationType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AnnotationType> for glib::Value {
    #[inline]
    fn from(v: AnnotationType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsAnnotationsOverMarkup")]
pub enum AnnotationsOverMarkup {
    #[doc(alias = "PPS_ANNOTATION_OVER_MARKUP_NOT_IMPLEMENTED")]
    NotImplemented,
    #[doc(alias = "PPS_ANNOTATION_OVER_MARKUP_UNKNOWN")]
    Unknown,
    #[doc(alias = "PPS_ANNOTATION_OVER_MARKUP_YES")]
    Yes,
    #[doc(alias = "PPS_ANNOTATION_OVER_MARKUP_NOT")]
    Not,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AnnotationsOverMarkup {
    type GlibType = ffi::PpsAnnotationsOverMarkup;

    #[inline]
    fn into_glib(self) -> ffi::PpsAnnotationsOverMarkup {
        match self {
            Self::NotImplemented => ffi::PPS_ANNOTATION_OVER_MARKUP_NOT_IMPLEMENTED,
            Self::Unknown => ffi::PPS_ANNOTATION_OVER_MARKUP_UNKNOWN,
            Self::Yes => ffi::PPS_ANNOTATION_OVER_MARKUP_YES,
            Self::Not => ffi::PPS_ANNOTATION_OVER_MARKUP_NOT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsAnnotationsOverMarkup> for AnnotationsOverMarkup {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsAnnotationsOverMarkup) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_ANNOTATION_OVER_MARKUP_NOT_IMPLEMENTED => Self::NotImplemented,
            ffi::PPS_ANNOTATION_OVER_MARKUP_UNKNOWN => Self::Unknown,
            ffi::PPS_ANNOTATION_OVER_MARKUP_YES => Self::Yes,
            ffi::PPS_ANNOTATION_OVER_MARKUP_NOT => Self::Not,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AnnotationsOverMarkup {
    #[inline]
    #[doc(alias = "pps_annotations_over_markup_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_annotations_over_markup_get_type()) }
    }
}

impl glib::HasParamSpec for AnnotationsOverMarkup {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AnnotationsOverMarkup {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AnnotationsOverMarkup {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AnnotationsOverMarkup {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AnnotationsOverMarkup> for glib::Value {
    #[inline]
    fn from(v: AnnotationsOverMarkup) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsCertificateStatus")]
pub enum CertificateStatus {
    #[doc(alias = "PPS_CERTIFICATE_STATUS_TRUSTED")]
    Trusted,
    #[doc(alias = "PPS_CERTIFICATE_STATUS_UNTRUSTED_ISSUER")]
    UntrustedIssuer,
    #[doc(alias = "PPS_CERTIFICATE_STATUS_UNKNOWN_ISSUER")]
    UnknownIssuer,
    #[doc(alias = "PPS_CERTIFICATE_STATUS_REVOKED")]
    Revoked,
    #[doc(alias = "PPS_CERTIFICATE_STATUS_EXPIRED")]
    Expired,
    #[doc(alias = "PPS_CERTIFICATE_STATUS_GENERIC_ERROR")]
    GenericError,
    #[doc(alias = "PPS_CERTIFICATE_STATUS_NOT_VERIFIED")]
    NotVerified,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CertificateStatus {
    type GlibType = ffi::PpsCertificateStatus;

    #[inline]
    fn into_glib(self) -> ffi::PpsCertificateStatus {
        match self {
            Self::Trusted => ffi::PPS_CERTIFICATE_STATUS_TRUSTED,
            Self::UntrustedIssuer => ffi::PPS_CERTIFICATE_STATUS_UNTRUSTED_ISSUER,
            Self::UnknownIssuer => ffi::PPS_CERTIFICATE_STATUS_UNKNOWN_ISSUER,
            Self::Revoked => ffi::PPS_CERTIFICATE_STATUS_REVOKED,
            Self::Expired => ffi::PPS_CERTIFICATE_STATUS_EXPIRED,
            Self::GenericError => ffi::PPS_CERTIFICATE_STATUS_GENERIC_ERROR,
            Self::NotVerified => ffi::PPS_CERTIFICATE_STATUS_NOT_VERIFIED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsCertificateStatus> for CertificateStatus {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsCertificateStatus) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_CERTIFICATE_STATUS_TRUSTED => Self::Trusted,
            ffi::PPS_CERTIFICATE_STATUS_UNTRUSTED_ISSUER => Self::UntrustedIssuer,
            ffi::PPS_CERTIFICATE_STATUS_UNKNOWN_ISSUER => Self::UnknownIssuer,
            ffi::PPS_CERTIFICATE_STATUS_REVOKED => Self::Revoked,
            ffi::PPS_CERTIFICATE_STATUS_EXPIRED => Self::Expired,
            ffi::PPS_CERTIFICATE_STATUS_GENERIC_ERROR => Self::GenericError,
            ffi::PPS_CERTIFICATE_STATUS_NOT_VERIFIED => Self::NotVerified,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CertificateStatus {
    #[inline]
    #[doc(alias = "pps_certificate_status_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_certificate_status_get_type()) }
    }
}

impl glib::HasParamSpec for CertificateStatus {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CertificateStatus {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CertificateStatus {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CertificateStatus {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CertificateStatus> for glib::Value {
    #[inline]
    fn from(v: CertificateStatus) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsCompressionType")]
pub enum CompressionType {
    #[doc(alias = "PPS_COMPRESSION_NONE")]
    None,
    #[doc(alias = "PPS_COMPRESSION_BZIP2")]
    Bzip2,
    #[doc(alias = "PPS_COMPRESSION_GZIP")]
    Gzip,
    #[doc(alias = "PPS_COMPRESSION_LZMA")]
    Lzma,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CompressionType {
    type GlibType = ffi::PpsCompressionType;

    #[inline]
    fn into_glib(self) -> ffi::PpsCompressionType {
        match self {
            Self::None => ffi::PPS_COMPRESSION_NONE,
            Self::Bzip2 => ffi::PPS_COMPRESSION_BZIP2,
            Self::Gzip => ffi::PPS_COMPRESSION_GZIP,
            Self::Lzma => ffi::PPS_COMPRESSION_LZMA,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsCompressionType> for CompressionType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsCompressionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_COMPRESSION_NONE => Self::None,
            ffi::PPS_COMPRESSION_BZIP2 => Self::Bzip2,
            ffi::PPS_COMPRESSION_GZIP => Self::Gzip,
            ffi::PPS_COMPRESSION_LZMA => Self::Lzma,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CompressionType {
    #[inline]
    #[doc(alias = "pps_compression_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_compression_type_get_type()) }
    }
}

impl glib::HasParamSpec for CompressionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CompressionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CompressionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CompressionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CompressionType> for glib::Value {
    #[inline]
    fn from(v: CompressionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsDocumentContainsJS")]
pub enum DocumentContainsJS {
    #[doc(alias = "PPS_DOCUMENT_CONTAINS_JS_UNKNOWN")]
    Unknown,
    #[doc(alias = "PPS_DOCUMENT_CONTAINS_JS_NO")]
    No,
    #[doc(alias = "PPS_DOCUMENT_CONTAINS_JS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DocumentContainsJS {
    type GlibType = ffi::PpsDocumentContainsJS;

    #[inline]
    fn into_glib(self) -> ffi::PpsDocumentContainsJS {
        match self {
            Self::Unknown => ffi::PPS_DOCUMENT_CONTAINS_JS_UNKNOWN,
            Self::No => ffi::PPS_DOCUMENT_CONTAINS_JS_NO,
            Self::Yes => ffi::PPS_DOCUMENT_CONTAINS_JS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsDocumentContainsJS> for DocumentContainsJS {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsDocumentContainsJS) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_DOCUMENT_CONTAINS_JS_UNKNOWN => Self::Unknown,
            ffi::PPS_DOCUMENT_CONTAINS_JS_NO => Self::No,
            ffi::PPS_DOCUMENT_CONTAINS_JS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DocumentContainsJS {
    #[inline]
    #[doc(alias = "pps_document_contains_js_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_document_contains_js_get_type()) }
    }
}

impl glib::HasParamSpec for DocumentContainsJS {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DocumentContainsJS {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DocumentContainsJS {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DocumentContainsJS {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DocumentContainsJS> for glib::Value {
    #[inline]
    fn from(v: DocumentContainsJS) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsDocumentError")]
pub enum DocumentError {
    #[doc(alias = "PPS_DOCUMENT_ERROR_INVALID")]
    Invalid,
    #[doc(alias = "PPS_DOCUMENT_ERROR_UNSUPPORTED_CONTENT")]
    UnsupportedContent,
    #[doc(alias = "PPS_DOCUMENT_ERROR_ENCRYPTED")]
    Encrypted,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DocumentError {
    type GlibType = ffi::PpsDocumentError;

    #[inline]
    fn into_glib(self) -> ffi::PpsDocumentError {
        match self {
            Self::Invalid => ffi::PPS_DOCUMENT_ERROR_INVALID,
            Self::UnsupportedContent => ffi::PPS_DOCUMENT_ERROR_UNSUPPORTED_CONTENT,
            Self::Encrypted => ffi::PPS_DOCUMENT_ERROR_ENCRYPTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsDocumentError> for DocumentError {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsDocumentError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_DOCUMENT_ERROR_INVALID => Self::Invalid,
            ffi::PPS_DOCUMENT_ERROR_UNSUPPORTED_CONTENT => Self::UnsupportedContent,
            ffi::PPS_DOCUMENT_ERROR_ENCRYPTED => Self::Encrypted,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for DocumentError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::pps_document_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for DocumentError {
    #[inline]
    #[doc(alias = "pps_document_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_document_error_get_type()) }
    }
}

impl glib::HasParamSpec for DocumentError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DocumentError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DocumentError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DocumentError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DocumentError> for glib::Value {
    #[inline]
    fn from(v: DocumentError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsDocumentMode")]
pub enum DocumentMode {
    #[doc(alias = "PPS_DOCUMENT_MODE_NONE")]
    None,
    #[doc(alias = "PPS_DOCUMENT_MODE_USE_OC")]
    UseOc,
    #[doc(alias = "PPS_DOCUMENT_MODE_USE_THUMBS")]
    UseThumbs,
    #[doc(alias = "PPS_DOCUMENT_MODE_FULL_SCREEN")]
    FullScreen,
    #[doc(alias = "PPS_DOCUMENT_MODE_USE_ATTACHMENTS")]
    UseAttachments,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DocumentMode {
    type GlibType = ffi::PpsDocumentMode;

    #[inline]
    fn into_glib(self) -> ffi::PpsDocumentMode {
        match self {
            Self::None => ffi::PPS_DOCUMENT_MODE_NONE,
            Self::UseOc => ffi::PPS_DOCUMENT_MODE_USE_OC,
            Self::UseThumbs => ffi::PPS_DOCUMENT_MODE_USE_THUMBS,
            Self::FullScreen => ffi::PPS_DOCUMENT_MODE_FULL_SCREEN,
            Self::UseAttachments => ffi::PPS_DOCUMENT_MODE_USE_ATTACHMENTS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsDocumentMode> for DocumentMode {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsDocumentMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_DOCUMENT_MODE_NONE => Self::None,
            ffi::PPS_DOCUMENT_MODE_USE_OC => Self::UseOc,
            ffi::PPS_DOCUMENT_MODE_USE_THUMBS => Self::UseThumbs,
            ffi::PPS_DOCUMENT_MODE_FULL_SCREEN => Self::FullScreen,
            ffi::PPS_DOCUMENT_MODE_USE_ATTACHMENTS => Self::UseAttachments,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DocumentMode {
    #[inline]
    #[doc(alias = "pps_document_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_document_mode_get_type()) }
    }
}

impl glib::HasParamSpec for DocumentMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DocumentMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DocumentMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DocumentMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DocumentMode> for glib::Value {
    #[inline]
    fn from(v: DocumentMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsLinkActionType")]
pub enum LinkActionType {
    #[doc(alias = "PPS_LINK_ACTION_TYPE_GOTO_DEST")]
    GotoDest,
    #[doc(alias = "PPS_LINK_ACTION_TYPE_GOTO_REMOTE")]
    GotoRemote,
    #[doc(alias = "PPS_LINK_ACTION_TYPE_EXTERNAL_URI")]
    ExternalUri,
    #[doc(alias = "PPS_LINK_ACTION_TYPE_LAUNCH")]
    Launch,
    #[doc(alias = "PPS_LINK_ACTION_TYPE_NAMED")]
    Named,
    #[doc(alias = "PPS_LINK_ACTION_TYPE_LAYERS_STATE")]
    LayersState,
    #[doc(alias = "PPS_LINK_ACTION_TYPE_RESET_FORM")]
    ResetForm,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for LinkActionType {
    type GlibType = ffi::PpsLinkActionType;

    #[inline]
    fn into_glib(self) -> ffi::PpsLinkActionType {
        match self {
            Self::GotoDest => ffi::PPS_LINK_ACTION_TYPE_GOTO_DEST,
            Self::GotoRemote => ffi::PPS_LINK_ACTION_TYPE_GOTO_REMOTE,
            Self::ExternalUri => ffi::PPS_LINK_ACTION_TYPE_EXTERNAL_URI,
            Self::Launch => ffi::PPS_LINK_ACTION_TYPE_LAUNCH,
            Self::Named => ffi::PPS_LINK_ACTION_TYPE_NAMED,
            Self::LayersState => ffi::PPS_LINK_ACTION_TYPE_LAYERS_STATE,
            Self::ResetForm => ffi::PPS_LINK_ACTION_TYPE_RESET_FORM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsLinkActionType> for LinkActionType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsLinkActionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_LINK_ACTION_TYPE_GOTO_DEST => Self::GotoDest,
            ffi::PPS_LINK_ACTION_TYPE_GOTO_REMOTE => Self::GotoRemote,
            ffi::PPS_LINK_ACTION_TYPE_EXTERNAL_URI => Self::ExternalUri,
            ffi::PPS_LINK_ACTION_TYPE_LAUNCH => Self::Launch,
            ffi::PPS_LINK_ACTION_TYPE_NAMED => Self::Named,
            ffi::PPS_LINK_ACTION_TYPE_LAYERS_STATE => Self::LayersState,
            ffi::PPS_LINK_ACTION_TYPE_RESET_FORM => Self::ResetForm,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for LinkActionType {
    #[inline]
    #[doc(alias = "pps_link_action_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_link_action_type_get_type()) }
    }
}

impl glib::HasParamSpec for LinkActionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for LinkActionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for LinkActionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LinkActionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<LinkActionType> for glib::Value {
    #[inline]
    fn from(v: LinkActionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsLinkDestType")]
pub enum LinkDestType {
    #[doc(alias = "PPS_LINK_DEST_TYPE_PAGE")]
    Page,
    #[doc(alias = "PPS_LINK_DEST_TYPE_XYZ")]
    Xyz,
    #[doc(alias = "PPS_LINK_DEST_TYPE_FIT")]
    Fit,
    #[doc(alias = "PPS_LINK_DEST_TYPE_FITH")]
    Fith,
    #[doc(alias = "PPS_LINK_DEST_TYPE_FITV")]
    Fitv,
    #[doc(alias = "PPS_LINK_DEST_TYPE_FITR")]
    Fitr,
    #[doc(alias = "PPS_LINK_DEST_TYPE_NAMED")]
    Named,
    #[doc(alias = "PPS_LINK_DEST_TYPE_PAGE_LABEL")]
    PageLabel,
    #[doc(alias = "PPS_LINK_DEST_TYPE_UNKNOWN")]
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for LinkDestType {
    type GlibType = ffi::PpsLinkDestType;

    #[inline]
    fn into_glib(self) -> ffi::PpsLinkDestType {
        match self {
            Self::Page => ffi::PPS_LINK_DEST_TYPE_PAGE,
            Self::Xyz => ffi::PPS_LINK_DEST_TYPE_XYZ,
            Self::Fit => ffi::PPS_LINK_DEST_TYPE_FIT,
            Self::Fith => ffi::PPS_LINK_DEST_TYPE_FITH,
            Self::Fitv => ffi::PPS_LINK_DEST_TYPE_FITV,
            Self::Fitr => ffi::PPS_LINK_DEST_TYPE_FITR,
            Self::Named => ffi::PPS_LINK_DEST_TYPE_NAMED,
            Self::PageLabel => ffi::PPS_LINK_DEST_TYPE_PAGE_LABEL,
            Self::Unknown => ffi::PPS_LINK_DEST_TYPE_UNKNOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsLinkDestType> for LinkDestType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsLinkDestType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_LINK_DEST_TYPE_PAGE => Self::Page,
            ffi::PPS_LINK_DEST_TYPE_XYZ => Self::Xyz,
            ffi::PPS_LINK_DEST_TYPE_FIT => Self::Fit,
            ffi::PPS_LINK_DEST_TYPE_FITH => Self::Fith,
            ffi::PPS_LINK_DEST_TYPE_FITV => Self::Fitv,
            ffi::PPS_LINK_DEST_TYPE_FITR => Self::Fitr,
            ffi::PPS_LINK_DEST_TYPE_NAMED => Self::Named,
            ffi::PPS_LINK_DEST_TYPE_PAGE_LABEL => Self::PageLabel,
            ffi::PPS_LINK_DEST_TYPE_UNKNOWN => Self::Unknown,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for LinkDestType {
    #[inline]
    #[doc(alias = "pps_link_dest_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_link_dest_type_get_type()) }
    }
}

impl glib::HasParamSpec for LinkDestType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for LinkDestType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for LinkDestType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LinkDestType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<LinkDestType> for glib::Value {
    #[inline]
    fn from(v: LinkDestType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsSelectionStyle")]
pub enum SelectionStyle {
    #[doc(alias = "PPS_SELECTION_STYLE_GLYPH")]
    Glyph,
    #[doc(alias = "PPS_SELECTION_STYLE_WORD")]
    Word,
    #[doc(alias = "PPS_SELECTION_STYLE_LINE")]
    Line,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SelectionStyle {
    type GlibType = ffi::PpsSelectionStyle;

    #[inline]
    fn into_glib(self) -> ffi::PpsSelectionStyle {
        match self {
            Self::Glyph => ffi::PPS_SELECTION_STYLE_GLYPH,
            Self::Word => ffi::PPS_SELECTION_STYLE_WORD,
            Self::Line => ffi::PPS_SELECTION_STYLE_LINE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsSelectionStyle> for SelectionStyle {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsSelectionStyle) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_SELECTION_STYLE_GLYPH => Self::Glyph,
            ffi::PPS_SELECTION_STYLE_WORD => Self::Word,
            ffi::PPS_SELECTION_STYLE_LINE => Self::Line,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SelectionStyle {
    #[inline]
    #[doc(alias = "pps_selection_style_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_selection_style_get_type()) }
    }
}

impl glib::HasParamSpec for SelectionStyle {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SelectionStyle {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SelectionStyle {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SelectionStyle {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SelectionStyle> for glib::Value {
    #[inline]
    fn from(v: SelectionStyle) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsSignatureStatus")]
pub enum SignatureStatus {
    #[doc(alias = "PPS_SIGNATURE_STATUS_VALID")]
    Valid,
    #[doc(alias = "PPS_SIGNATURE_STATUS_INVALID")]
    Invalid,
    #[doc(alias = "PPS_SIGNATURE_STATUS_DIGEST_MISMATCH")]
    DigestMismatch,
    #[doc(alias = "PPS_SIGNATURE_STATUS_DECODING_ERROR")]
    DecodingError,
    #[doc(alias = "PPS_SIGNATURE_STATUS_GENERIC_ERROR")]
    GenericError,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SignatureStatus {
    type GlibType = ffi::PpsSignatureStatus;

    #[inline]
    fn into_glib(self) -> ffi::PpsSignatureStatus {
        match self {
            Self::Valid => ffi::PPS_SIGNATURE_STATUS_VALID,
            Self::Invalid => ffi::PPS_SIGNATURE_STATUS_INVALID,
            Self::DigestMismatch => ffi::PPS_SIGNATURE_STATUS_DIGEST_MISMATCH,
            Self::DecodingError => ffi::PPS_SIGNATURE_STATUS_DECODING_ERROR,
            Self::GenericError => ffi::PPS_SIGNATURE_STATUS_GENERIC_ERROR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsSignatureStatus> for SignatureStatus {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsSignatureStatus) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_SIGNATURE_STATUS_VALID => Self::Valid,
            ffi::PPS_SIGNATURE_STATUS_INVALID => Self::Invalid,
            ffi::PPS_SIGNATURE_STATUS_DIGEST_MISMATCH => Self::DigestMismatch,
            ffi::PPS_SIGNATURE_STATUS_DECODING_ERROR => Self::DecodingError,
            ffi::PPS_SIGNATURE_STATUS_GENERIC_ERROR => Self::GenericError,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SignatureStatus {
    #[inline]
    #[doc(alias = "pps_signature_status_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_signature_status_get_type()) }
    }
}

impl glib::HasParamSpec for SignatureStatus {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SignatureStatus {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SignatureStatus {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SignatureStatus {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SignatureStatus> for glib::Value {
    #[inline]
    fn from(v: SignatureStatus) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsTransitionEffectAlignment")]
pub enum TransitionEffectAlignment {
    #[doc(alias = "PPS_TRANSITION_ALIGNMENT_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "PPS_TRANSITION_ALIGNMENT_VERTICAL")]
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransitionEffectAlignment {
    type GlibType = ffi::PpsTransitionEffectAlignment;

    #[inline]
    fn into_glib(self) -> ffi::PpsTransitionEffectAlignment {
        match self {
            Self::Horizontal => ffi::PPS_TRANSITION_ALIGNMENT_HORIZONTAL,
            Self::Vertical => ffi::PPS_TRANSITION_ALIGNMENT_VERTICAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsTransitionEffectAlignment> for TransitionEffectAlignment {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsTransitionEffectAlignment) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_TRANSITION_ALIGNMENT_HORIZONTAL => Self::Horizontal,
            ffi::PPS_TRANSITION_ALIGNMENT_VERTICAL => Self::Vertical,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransitionEffectAlignment {
    #[inline]
    #[doc(alias = "pps_transition_effect_alignment_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_transition_effect_alignment_get_type()) }
    }
}

impl glib::HasParamSpec for TransitionEffectAlignment {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransitionEffectAlignment {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransitionEffectAlignment {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransitionEffectAlignment {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransitionEffectAlignment> for glib::Value {
    #[inline]
    fn from(v: TransitionEffectAlignment) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsTransitionEffectDirection")]
pub enum TransitionEffectDirection {
    #[doc(alias = "PPS_TRANSITION_DIRECTION_INWARD")]
    Inward,
    #[doc(alias = "PPS_TRANSITION_DIRECTION_OUTWARD")]
    Outward,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransitionEffectDirection {
    type GlibType = ffi::PpsTransitionEffectDirection;

    #[inline]
    fn into_glib(self) -> ffi::PpsTransitionEffectDirection {
        match self {
            Self::Inward => ffi::PPS_TRANSITION_DIRECTION_INWARD,
            Self::Outward => ffi::PPS_TRANSITION_DIRECTION_OUTWARD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsTransitionEffectDirection> for TransitionEffectDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsTransitionEffectDirection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_TRANSITION_DIRECTION_INWARD => Self::Inward,
            ffi::PPS_TRANSITION_DIRECTION_OUTWARD => Self::Outward,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransitionEffectDirection {
    #[inline]
    #[doc(alias = "pps_transition_effect_direction_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_transition_effect_direction_get_type()) }
    }
}

impl glib::HasParamSpec for TransitionEffectDirection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransitionEffectDirection {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransitionEffectDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransitionEffectDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransitionEffectDirection> for glib::Value {
    #[inline]
    fn from(v: TransitionEffectDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsTransitionEffectType")]
pub enum TransitionEffectType {
    #[doc(alias = "PPS_TRANSITION_EFFECT_REPLACE")]
    Replace,
    #[doc(alias = "PPS_TRANSITION_EFFECT_SPLIT")]
    Split,
    #[doc(alias = "PPS_TRANSITION_EFFECT_BLINDS")]
    Blinds,
    #[doc(alias = "PPS_TRANSITION_EFFECT_BOX")]
    Box,
    #[doc(alias = "PPS_TRANSITION_EFFECT_WIPE")]
    Wipe,
    #[doc(alias = "PPS_TRANSITION_EFFECT_DISSOLVE")]
    Dissolve,
    #[doc(alias = "PPS_TRANSITION_EFFECT_GLITTER")]
    Glitter,
    #[doc(alias = "PPS_TRANSITION_EFFECT_FLY")]
    Fly,
    #[doc(alias = "PPS_TRANSITION_EFFECT_PUSH")]
    Push,
    #[doc(alias = "PPS_TRANSITION_EFFECT_COVER")]
    Cover,
    #[doc(alias = "PPS_TRANSITION_EFFECT_UNCOVER")]
    Uncover,
    #[doc(alias = "PPS_TRANSITION_EFFECT_FADE")]
    Fade,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransitionEffectType {
    type GlibType = ffi::PpsTransitionEffectType;

    #[inline]
    fn into_glib(self) -> ffi::PpsTransitionEffectType {
        match self {
            Self::Replace => ffi::PPS_TRANSITION_EFFECT_REPLACE,
            Self::Split => ffi::PPS_TRANSITION_EFFECT_SPLIT,
            Self::Blinds => ffi::PPS_TRANSITION_EFFECT_BLINDS,
            Self::Box => ffi::PPS_TRANSITION_EFFECT_BOX,
            Self::Wipe => ffi::PPS_TRANSITION_EFFECT_WIPE,
            Self::Dissolve => ffi::PPS_TRANSITION_EFFECT_DISSOLVE,
            Self::Glitter => ffi::PPS_TRANSITION_EFFECT_GLITTER,
            Self::Fly => ffi::PPS_TRANSITION_EFFECT_FLY,
            Self::Push => ffi::PPS_TRANSITION_EFFECT_PUSH,
            Self::Cover => ffi::PPS_TRANSITION_EFFECT_COVER,
            Self::Uncover => ffi::PPS_TRANSITION_EFFECT_UNCOVER,
            Self::Fade => ffi::PPS_TRANSITION_EFFECT_FADE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsTransitionEffectType> for TransitionEffectType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsTransitionEffectType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_TRANSITION_EFFECT_REPLACE => Self::Replace,
            ffi::PPS_TRANSITION_EFFECT_SPLIT => Self::Split,
            ffi::PPS_TRANSITION_EFFECT_BLINDS => Self::Blinds,
            ffi::PPS_TRANSITION_EFFECT_BOX => Self::Box,
            ffi::PPS_TRANSITION_EFFECT_WIPE => Self::Wipe,
            ffi::PPS_TRANSITION_EFFECT_DISSOLVE => Self::Dissolve,
            ffi::PPS_TRANSITION_EFFECT_GLITTER => Self::Glitter,
            ffi::PPS_TRANSITION_EFFECT_FLY => Self::Fly,
            ffi::PPS_TRANSITION_EFFECT_PUSH => Self::Push,
            ffi::PPS_TRANSITION_EFFECT_COVER => Self::Cover,
            ffi::PPS_TRANSITION_EFFECT_UNCOVER => Self::Uncover,
            ffi::PPS_TRANSITION_EFFECT_FADE => Self::Fade,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransitionEffectType {
    #[inline]
    #[doc(alias = "pps_transition_effect_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_transition_effect_type_get_type()) }
    }
}

impl glib::HasParamSpec for TransitionEffectType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransitionEffectType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransitionEffectType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransitionEffectType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransitionEffectType> for glib::Value {
    #[inline]
    fn from(v: TransitionEffectType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
